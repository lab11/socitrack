
bin/TestBluetooth.axf:     file format elf32-littlearm


Disassembly of section .text:

00018000 <g_am_pfnVectors>:
   18000:	00 2b 00 10 d1 b9 02 00 39 ba 02 00 91 f2 02 00     .+......9.......
   18010:	3f ba 02 00 3f ba 02 00 3f ba 02 00 00 00 00 00     ?...?...?.......
	...
   1802c:	21 a7 02 00 45 ba 02 00 00 00 00 00 31 a8 02 00     !...E.......1...
   1803c:	99 a8 02 00 45 ba 02 00 45 ba 02 00 01 f2 02 00     ....E...E.......
   1804c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1805c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1806c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1807c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1808c:	7d db 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     }...E...E...E...
   1809c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   180ac:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   180bc:	45 ba 02 00 cd aa 02 00 f9 aa 02 00 45 ba 02 00     E...........E...
   180cc:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   180dc:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   180ec:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   180fc:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1810c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1811c:	45 ba 02 00 f1 f0 02 00 35 f1 02 00 79 f1 02 00     E.......5...y...
   1812c:	bd f1 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     ....E...E...E...
   1813c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1814c:	69 e6 02 00 45 ba 02 00 b5 fa 02 00 45 ba 02 00     i...E.......E...
   1815c:	69 f4 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     i...E...E...E...
   1816c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1817c:	45 ba 02 00 45 ba 02 00 45 ba 02 00 45 ba 02 00     E...E...E...E...
   1818c:	45 ba 02 00                                         E...

00018190 <__Patchable>:
	...

00018200 <dw3000_driver>:
   18200:	12 03 ca de 0f ff ff ff 2c 6e 04 00 34 6e 04 00     ........,n..4n..
   18210:	68 6d 04 00 2c 6d 04 00 07 00 06 00                 hm..,m......

0001821c <dw3700_driver>:
   1821c:	13 03 ca de 0f ff ff ff 2c 6e 04 00 34 6e 04 00     ........,n..4n..
   1822c:	a8 6e 04 00 6c 6e 04 00 07 00 06 00                 .n..ln......

00018238 <dw3720_driver>:
   18238:	14 03 ca de 0f ff ff ff 2c 6e 04 00 34 6e 04 00     ........,n..4n..
   18248:	b8 6f 04 00 7c 6f 04 00 07 00 06 00                 .o..|o......

00018254 <memcpy>:
   18254:	4684      	mov	ip, r0
   18256:	ea41 0300 	orr.w	r3, r1, r0
   1825a:	f013 0303 	ands.w	r3, r3, #3
   1825e:	d16d      	bne.n	1833c <memcpy+0xe8>
   18260:	3a40      	subs	r2, #64	; 0x40
   18262:	d341      	bcc.n	182e8 <memcpy+0x94>
   18264:	f851 3b04 	ldr.w	r3, [r1], #4
   18268:	f840 3b04 	str.w	r3, [r0], #4
   1826c:	f851 3b04 	ldr.w	r3, [r1], #4
   18270:	f840 3b04 	str.w	r3, [r0], #4
   18274:	f851 3b04 	ldr.w	r3, [r1], #4
   18278:	f840 3b04 	str.w	r3, [r0], #4
   1827c:	f851 3b04 	ldr.w	r3, [r1], #4
   18280:	f840 3b04 	str.w	r3, [r0], #4
   18284:	f851 3b04 	ldr.w	r3, [r1], #4
   18288:	f840 3b04 	str.w	r3, [r0], #4
   1828c:	f851 3b04 	ldr.w	r3, [r1], #4
   18290:	f840 3b04 	str.w	r3, [r0], #4
   18294:	f851 3b04 	ldr.w	r3, [r1], #4
   18298:	f840 3b04 	str.w	r3, [r0], #4
   1829c:	f851 3b04 	ldr.w	r3, [r1], #4
   182a0:	f840 3b04 	str.w	r3, [r0], #4
   182a4:	f851 3b04 	ldr.w	r3, [r1], #4
   182a8:	f840 3b04 	str.w	r3, [r0], #4
   182ac:	f851 3b04 	ldr.w	r3, [r1], #4
   182b0:	f840 3b04 	str.w	r3, [r0], #4
   182b4:	f851 3b04 	ldr.w	r3, [r1], #4
   182b8:	f840 3b04 	str.w	r3, [r0], #4
   182bc:	f851 3b04 	ldr.w	r3, [r1], #4
   182c0:	f840 3b04 	str.w	r3, [r0], #4
   182c4:	f851 3b04 	ldr.w	r3, [r1], #4
   182c8:	f840 3b04 	str.w	r3, [r0], #4
   182cc:	f851 3b04 	ldr.w	r3, [r1], #4
   182d0:	f840 3b04 	str.w	r3, [r0], #4
   182d4:	f851 3b04 	ldr.w	r3, [r1], #4
   182d8:	f840 3b04 	str.w	r3, [r0], #4
   182dc:	f851 3b04 	ldr.w	r3, [r1], #4
   182e0:	f840 3b04 	str.w	r3, [r0], #4
   182e4:	3a40      	subs	r2, #64	; 0x40
   182e6:	d2bd      	bcs.n	18264 <memcpy+0x10>
   182e8:	3230      	adds	r2, #48	; 0x30
   182ea:	d311      	bcc.n	18310 <memcpy+0xbc>
   182ec:	f851 3b04 	ldr.w	r3, [r1], #4
   182f0:	f840 3b04 	str.w	r3, [r0], #4
   182f4:	f851 3b04 	ldr.w	r3, [r1], #4
   182f8:	f840 3b04 	str.w	r3, [r0], #4
   182fc:	f851 3b04 	ldr.w	r3, [r1], #4
   18300:	f840 3b04 	str.w	r3, [r0], #4
   18304:	f851 3b04 	ldr.w	r3, [r1], #4
   18308:	f840 3b04 	str.w	r3, [r0], #4
   1830c:	3a10      	subs	r2, #16
   1830e:	d2ed      	bcs.n	182ec <memcpy+0x98>
   18310:	320c      	adds	r2, #12
   18312:	d305      	bcc.n	18320 <memcpy+0xcc>
   18314:	f851 3b04 	ldr.w	r3, [r1], #4
   18318:	f840 3b04 	str.w	r3, [r0], #4
   1831c:	3a04      	subs	r2, #4
   1831e:	d2f9      	bcs.n	18314 <memcpy+0xc0>
   18320:	3204      	adds	r2, #4
   18322:	d008      	beq.n	18336 <memcpy+0xe2>
   18324:	07d2      	lsls	r2, r2, #31
   18326:	bf1c      	itt	ne
   18328:	f811 3b01 	ldrbne.w	r3, [r1], #1
   1832c:	f800 3b01 	strbne.w	r3, [r0], #1
   18330:	d301      	bcc.n	18336 <memcpy+0xe2>
   18332:	880b      	ldrh	r3, [r1, #0]
   18334:	8003      	strh	r3, [r0, #0]
   18336:	4660      	mov	r0, ip
   18338:	4770      	bx	lr
   1833a:	bf00      	nop
   1833c:	2a08      	cmp	r2, #8
   1833e:	d313      	bcc.n	18368 <memcpy+0x114>
   18340:	078b      	lsls	r3, r1, #30
   18342:	d08d      	beq.n	18260 <memcpy+0xc>
   18344:	f010 0303 	ands.w	r3, r0, #3
   18348:	d08a      	beq.n	18260 <memcpy+0xc>
   1834a:	f1c3 0304 	rsb	r3, r3, #4
   1834e:	1ad2      	subs	r2, r2, r3
   18350:	07db      	lsls	r3, r3, #31
   18352:	bf1c      	itt	ne
   18354:	f811 3b01 	ldrbne.w	r3, [r1], #1
   18358:	f800 3b01 	strbne.w	r3, [r0], #1
   1835c:	d380      	bcc.n	18260 <memcpy+0xc>
   1835e:	f831 3b02 	ldrh.w	r3, [r1], #2
   18362:	f820 3b02 	strh.w	r3, [r0], #2
   18366:	e77b      	b.n	18260 <memcpy+0xc>
   18368:	3a04      	subs	r2, #4
   1836a:	d3d9      	bcc.n	18320 <memcpy+0xcc>
   1836c:	3a01      	subs	r2, #1
   1836e:	f811 3b01 	ldrb.w	r3, [r1], #1
   18372:	f800 3b01 	strb.w	r3, [r0], #1
   18376:	d2f9      	bcs.n	1836c <memcpy+0x118>
   18378:	780b      	ldrb	r3, [r1, #0]
   1837a:	7003      	strb	r3, [r0, #0]
   1837c:	784b      	ldrb	r3, [r1, #1]
   1837e:	7043      	strb	r3, [r0, #1]
   18380:	788b      	ldrb	r3, [r1, #2]
   18382:	7083      	strb	r3, [r0, #2]
   18384:	4660      	mov	r0, ip
   18386:	4770      	bx	lr
	...

000183c0 <strlen>:
   183c0:	f890 f000 	pld	[r0]
   183c4:	e96d 4502 	strd	r4, r5, [sp, #-8]!
   183c8:	f020 0107 	bic.w	r1, r0, #7
   183cc:	f06f 0c00 	mvn.w	ip, #0
   183d0:	f010 0407 	ands.w	r4, r0, #7
   183d4:	f891 f020 	pld	[r1, #32]
   183d8:	f040 8049 	bne.w	1846e <strlen+0xae>
   183dc:	f04f 0400 	mov.w	r4, #0
   183e0:	f06f 0007 	mvn.w	r0, #7
   183e4:	e9d1 2300 	ldrd	r2, r3, [r1]
   183e8:	f891 f040 	pld	[r1, #64]	; 0x40
   183ec:	f100 0008 	add.w	r0, r0, #8
   183f0:	fa82 f24c 	uadd8	r2, r2, ip
   183f4:	faa4 f28c 	sel	r2, r4, ip
   183f8:	fa83 f34c 	uadd8	r3, r3, ip
   183fc:	faa2 f38c 	sel	r3, r2, ip
   18400:	bb4b      	cbnz	r3, 18456 <strlen+0x96>
   18402:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
   18406:	fa82 f24c 	uadd8	r2, r2, ip
   1840a:	f100 0008 	add.w	r0, r0, #8
   1840e:	faa4 f28c 	sel	r2, r4, ip
   18412:	fa83 f34c 	uadd8	r3, r3, ip
   18416:	faa2 f38c 	sel	r3, r2, ip
   1841a:	b9e3      	cbnz	r3, 18456 <strlen+0x96>
   1841c:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
   18420:	fa82 f24c 	uadd8	r2, r2, ip
   18424:	f100 0008 	add.w	r0, r0, #8
   18428:	faa4 f28c 	sel	r2, r4, ip
   1842c:	fa83 f34c 	uadd8	r3, r3, ip
   18430:	faa2 f38c 	sel	r3, r2, ip
   18434:	b97b      	cbnz	r3, 18456 <strlen+0x96>
   18436:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
   1843a:	f101 0120 	add.w	r1, r1, #32
   1843e:	fa82 f24c 	uadd8	r2, r2, ip
   18442:	f100 0008 	add.w	r0, r0, #8
   18446:	faa4 f28c 	sel	r2, r4, ip
   1844a:	fa83 f34c 	uadd8	r3, r3, ip
   1844e:	faa2 f38c 	sel	r3, r2, ip
   18452:	2b00      	cmp	r3, #0
   18454:	d0c6      	beq.n	183e4 <strlen+0x24>
   18456:	2a00      	cmp	r2, #0
   18458:	bf04      	itt	eq
   1845a:	3004      	addeq	r0, #4
   1845c:	461a      	moveq	r2, r3
   1845e:	ba12      	rev	r2, r2
   18460:	fab2 f282 	clz	r2, r2
   18464:	e8fd 4502 	ldrd	r4, r5, [sp], #8
   18468:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   1846c:	4770      	bx	lr
   1846e:	e9d1 2300 	ldrd	r2, r3, [r1]
   18472:	f004 0503 	and.w	r5, r4, #3
   18476:	f1c4 0000 	rsb	r0, r4, #0
   1847a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   1847e:	f014 0f04 	tst.w	r4, #4
   18482:	f891 f040 	pld	[r1, #64]	; 0x40
   18486:	fa0c f505 	lsl.w	r5, ip, r5
   1848a:	ea62 0205 	orn	r2, r2, r5
   1848e:	bf1c      	itt	ne
   18490:	ea63 0305 	ornne	r3, r3, r5
   18494:	4662      	movne	r2, ip
   18496:	f04f 0400 	mov.w	r4, #0
   1849a:	e7a9      	b.n	183f0 <strlen+0x30>
   1849c:	0000      	movs	r0, r0
   1849e:	0000      	movs	r0, r0
   184a0:	eba2 0003 	sub.w	r0, r2, r3
   184a4:	4770      	bx	lr
   184a6:	bf00      	nop

000184a8 <strcmp>:
   184a8:	7802      	ldrb	r2, [r0, #0]
   184aa:	780b      	ldrb	r3, [r1, #0]
   184ac:	2a01      	cmp	r2, #1
   184ae:	bf28      	it	cs
   184b0:	429a      	cmpcs	r2, r3
   184b2:	d1f5      	bne.n	184a0 <strlen+0xe0>
   184b4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
   184b8:	ea40 0401 	orr.w	r4, r0, r1
   184bc:	e9cd 6702 	strd	r6, r7, [sp, #8]
   184c0:	f06f 0c00 	mvn.w	ip, #0
   184c4:	ea4f 7244 	mov.w	r2, r4, lsl #29
   184c8:	b312      	cbz	r2, 18510 <strcmp+0x68>
   184ca:	ea80 0401 	eor.w	r4, r0, r1
   184ce:	f014 0f07 	tst.w	r4, #7
   184d2:	d16a      	bne.n	185aa <strcmp+0x102>
   184d4:	f000 0407 	and.w	r4, r0, #7
   184d8:	f020 0007 	bic.w	r0, r0, #7
   184dc:	f004 0503 	and.w	r5, r4, #3
   184e0:	f021 0107 	bic.w	r1, r1, #7
   184e4:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   184e8:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   184ec:	f014 0f04 	tst.w	r4, #4
   184f0:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   184f4:	fa0c f405 	lsl.w	r4, ip, r5
   184f8:	ea62 0204 	orn	r2, r2, r4
   184fc:	ea66 0604 	orn	r6, r6, r4
   18500:	d00a      	beq.n	18518 <strcmp+0x70>
   18502:	ea63 0304 	orn	r3, r3, r4
   18506:	4662      	mov	r2, ip
   18508:	ea67 0704 	orn	r7, r7, r4
   1850c:	4666      	mov	r6, ip
   1850e:	e003      	b.n	18518 <strcmp+0x70>
   18510:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   18514:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   18518:	fa82 f54c 	uadd8	r5, r2, ip
   1851c:	ea82 0406 	eor.w	r4, r2, r6
   18520:	faa4 f48c 	sel	r4, r4, ip
   18524:	bb6c      	cbnz	r4, 18582 <strcmp+0xda>
   18526:	fa83 f54c 	uadd8	r5, r3, ip
   1852a:	ea83 0507 	eor.w	r5, r3, r7
   1852e:	faa5 f58c 	sel	r5, r5, ip
   18532:	b995      	cbnz	r5, 1855a <strcmp+0xb2>
   18534:	e950 2302 	ldrd	r2, r3, [r0, #-8]
   18538:	e951 6702 	ldrd	r6, r7, [r1, #-8]
   1853c:	fa82 f54c 	uadd8	r5, r2, ip
   18540:	ea82 0406 	eor.w	r4, r2, r6
   18544:	faa4 f48c 	sel	r4, r4, ip
   18548:	fa83 f54c 	uadd8	r5, r3, ip
   1854c:	ea83 0507 	eor.w	r5, r3, r7
   18550:	faa5 f58c 	sel	r5, r5, ip
   18554:	4325      	orrs	r5, r4
   18556:	d0db      	beq.n	18510 <strcmp+0x68>
   18558:	b99c      	cbnz	r4, 18582 <strcmp+0xda>
   1855a:	ba2d      	rev	r5, r5
   1855c:	fab5 f485 	clz	r4, r5
   18560:	f024 0407 	bic.w	r4, r4, #7
   18564:	fa27 f104 	lsr.w	r1, r7, r4
   18568:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   1856c:	fa23 f304 	lsr.w	r3, r3, r4
   18570:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   18574:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   18578:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   1857c:	eba0 0001 	sub.w	r0, r0, r1
   18580:	4770      	bx	lr
   18582:	ba24      	rev	r4, r4
   18584:	fab4 f484 	clz	r4, r4
   18588:	f024 0407 	bic.w	r4, r4, #7
   1858c:	fa26 f104 	lsr.w	r1, r6, r4
   18590:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   18594:	fa22 f204 	lsr.w	r2, r2, r4
   18598:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   1859c:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   185a0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   185a4:	eba0 0001 	sub.w	r0, r0, r1
   185a8:	4770      	bx	lr
   185aa:	f014 0f03 	tst.w	r4, #3
   185ae:	d13c      	bne.n	1862a <strcmp+0x182>
   185b0:	f010 0403 	ands.w	r4, r0, #3
   185b4:	d128      	bne.n	18608 <strcmp+0x160>
   185b6:	f850 2b08 	ldr.w	r2, [r0], #8
   185ba:	f851 3b08 	ldr.w	r3, [r1], #8
   185be:	fa82 f54c 	uadd8	r5, r2, ip
   185c2:	ea82 0503 	eor.w	r5, r2, r3
   185c6:	faa5 f58c 	sel	r5, r5, ip
   185ca:	b95d      	cbnz	r5, 185e4 <strcmp+0x13c>
   185cc:	f850 2c04 	ldr.w	r2, [r0, #-4]
   185d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
   185d4:	fa82 f54c 	uadd8	r5, r2, ip
   185d8:	ea82 0503 	eor.w	r5, r2, r3
   185dc:	faa5 f58c 	sel	r5, r5, ip
   185e0:	2d00      	cmp	r5, #0
   185e2:	d0e8      	beq.n	185b6 <strcmp+0x10e>
   185e4:	ba2d      	rev	r5, r5
   185e6:	fab5 f485 	clz	r4, r5
   185ea:	f024 0407 	bic.w	r4, r4, #7
   185ee:	fa23 f104 	lsr.w	r1, r3, r4
   185f2:	fa22 f204 	lsr.w	r2, r2, r4
   185f6:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   185fa:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   185fe:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   18602:	eba0 0001 	sub.w	r0, r0, r1
   18606:	4770      	bx	lr
   18608:	ea4f 04c4 	mov.w	r4, r4, lsl #3
   1860c:	f020 0003 	bic.w	r0, r0, #3
   18610:	f850 2b08 	ldr.w	r2, [r0], #8
   18614:	f021 0103 	bic.w	r1, r1, #3
   18618:	f851 3b08 	ldr.w	r3, [r1], #8
   1861c:	fa0c f404 	lsl.w	r4, ip, r4
   18620:	ea62 0204 	orn	r2, r2, r4
   18624:	ea63 0304 	orn	r3, r3, r4
   18628:	e7c9      	b.n	185be <strcmp+0x116>
   1862a:	f010 0403 	ands.w	r4, r0, #3
   1862e:	d01a      	beq.n	18666 <strcmp+0x1be>
   18630:	eba1 0104 	sub.w	r1, r1, r4
   18634:	f020 0003 	bic.w	r0, r0, #3
   18638:	07e4      	lsls	r4, r4, #31
   1863a:	f850 2b04 	ldr.w	r2, [r0], #4
   1863e:	d006      	beq.n	1864e <strcmp+0x1a6>
   18640:	d20f      	bcs.n	18662 <strcmp+0x1ba>
   18642:	788b      	ldrb	r3, [r1, #2]
   18644:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
   18648:	1ae4      	subs	r4, r4, r3
   1864a:	d106      	bne.n	1865a <strcmp+0x1b2>
   1864c:	b12b      	cbz	r3, 1865a <strcmp+0x1b2>
   1864e:	78cb      	ldrb	r3, [r1, #3]
   18650:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
   18654:	1ae4      	subs	r4, r4, r3
   18656:	d100      	bne.n	1865a <strcmp+0x1b2>
   18658:	b91b      	cbnz	r3, 18662 <strcmp+0x1ba>
   1865a:	4620      	mov	r0, r4
   1865c:	f85d 4b10 	ldr.w	r4, [sp], #16
   18660:	4770      	bx	lr
   18662:	f101 0104 	add.w	r1, r1, #4
   18666:	f850 2b04 	ldr.w	r2, [r0], #4
   1866a:	07cc      	lsls	r4, r1, #31
   1866c:	f021 0103 	bic.w	r1, r1, #3
   18670:	f851 3b04 	ldr.w	r3, [r1], #4
   18674:	d848      	bhi.n	18708 <strcmp+0x260>
   18676:	d224      	bcs.n	186c2 <strcmp+0x21a>
   18678:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
   1867c:	fa82 f54c 	uadd8	r5, r2, ip
   18680:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
   18684:	faa5 f58c 	sel	r5, r5, ip
   18688:	d10a      	bne.n	186a0 <strcmp+0x1f8>
   1868a:	b965      	cbnz	r5, 186a6 <strcmp+0x1fe>
   1868c:	f851 3b04 	ldr.w	r3, [r1], #4
   18690:	ea84 0402 	eor.w	r4, r4, r2
   18694:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
   18698:	d10e      	bne.n	186b8 <strcmp+0x210>
   1869a:	f850 2b04 	ldr.w	r2, [r0], #4
   1869e:	e7eb      	b.n	18678 <strcmp+0x1d0>
   186a0:	ea4f 2313 	mov.w	r3, r3, lsr #8
   186a4:	e055      	b.n	18752 <strcmp+0x2aa>
   186a6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
   186aa:	d14d      	bne.n	18748 <strcmp+0x2a0>
   186ac:	7808      	ldrb	r0, [r1, #0]
   186ae:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   186b2:	f1c0 0000 	rsb	r0, r0, #0
   186b6:	4770      	bx	lr
   186b8:	ea4f 6212 	mov.w	r2, r2, lsr #24
   186bc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   186c0:	e047      	b.n	18752 <strcmp+0x2aa>
   186c2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
   186c6:	fa82 f54c 	uadd8	r5, r2, ip
   186ca:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
   186ce:	faa5 f58c 	sel	r5, r5, ip
   186d2:	d10a      	bne.n	186ea <strcmp+0x242>
   186d4:	b965      	cbnz	r5, 186f0 <strcmp+0x248>
   186d6:	f851 3b04 	ldr.w	r3, [r1], #4
   186da:	ea84 0402 	eor.w	r4, r4, r2
   186de:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
   186e2:	d10c      	bne.n	186fe <strcmp+0x256>
   186e4:	f850 2b04 	ldr.w	r2, [r0], #4
   186e8:	e7eb      	b.n	186c2 <strcmp+0x21a>
   186ea:	ea4f 4313 	mov.w	r3, r3, lsr #16
   186ee:	e030      	b.n	18752 <strcmp+0x2aa>
   186f0:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
   186f4:	d128      	bne.n	18748 <strcmp+0x2a0>
   186f6:	880b      	ldrh	r3, [r1, #0]
   186f8:	ea4f 4212 	mov.w	r2, r2, lsr #16
   186fc:	e029      	b.n	18752 <strcmp+0x2aa>
   186fe:	ea4f 4212 	mov.w	r2, r2, lsr #16
   18702:	ea03 431c 	and.w	r3, r3, ip, lsr #16
   18706:	e024      	b.n	18752 <strcmp+0x2aa>
   18708:	f002 04ff 	and.w	r4, r2, #255	; 0xff
   1870c:	fa82 f54c 	uadd8	r5, r2, ip
   18710:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
   18714:	faa5 f58c 	sel	r5, r5, ip
   18718:	d10a      	bne.n	18730 <strcmp+0x288>
   1871a:	b965      	cbnz	r5, 18736 <strcmp+0x28e>
   1871c:	f851 3b04 	ldr.w	r3, [r1], #4
   18720:	ea84 0402 	eor.w	r4, r4, r2
   18724:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
   18728:	d109      	bne.n	1873e <strcmp+0x296>
   1872a:	f850 2b04 	ldr.w	r2, [r0], #4
   1872e:	e7eb      	b.n	18708 <strcmp+0x260>
   18730:	ea4f 6313 	mov.w	r3, r3, lsr #24
   18734:	e00d      	b.n	18752 <strcmp+0x2aa>
   18736:	f015 0fff 	tst.w	r5, #255	; 0xff
   1873a:	d105      	bne.n	18748 <strcmp+0x2a0>
   1873c:	680b      	ldr	r3, [r1, #0]
   1873e:	ea4f 2212 	mov.w	r2, r2, lsr #8
   18742:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   18746:	e004      	b.n	18752 <strcmp+0x2aa>
   18748:	f04f 0000 	mov.w	r0, #0
   1874c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   18750:	4770      	bx	lr
   18752:	ba12      	rev	r2, r2
   18754:	ba1b      	rev	r3, r3
   18756:	fa82 f44c 	uadd8	r4, r2, ip
   1875a:	ea82 0403 	eor.w	r4, r2, r3
   1875e:	faa4 f58c 	sel	r5, r4, ip
   18762:	fab5 f485 	clz	r4, r5
   18766:	fa02 f204 	lsl.w	r2, r2, r4
   1876a:	fa03 f304 	lsl.w	r3, r3, r4
   1876e:	ea4f 6012 	mov.w	r0, r2, lsr #24
   18772:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   18776:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
   1877a:	4770      	bx	lr

0001877c <__aeabi_d2f>:
   1877c:	ea4f 0241 	mov.w	r2, r1, lsl #1
   18780:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
   18784:	bf24      	itt	cs
   18786:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
   1878a:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
   1878e:	d90d      	bls.n	187ac <__aeabi_d2f+0x30>
   18790:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   18794:	ea4f 02c0 	mov.w	r2, r0, lsl #3
   18798:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
   1879c:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
   187a0:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
   187a4:	bf08      	it	eq
   187a6:	f020 0001 	biceq.w	r0, r0, #1
   187aa:	4770      	bx	lr
   187ac:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
   187b0:	d121      	bne.n	187f6 <__aeabi_d2f+0x7a>
   187b2:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
   187b6:	bfbc      	itt	lt
   187b8:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
   187bc:	4770      	bxlt	lr
   187be:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   187c2:	ea4f 5252 	mov.w	r2, r2, lsr #21
   187c6:	f1c2 0218 	rsb	r2, r2, #24
   187ca:	f1c2 0c20 	rsb	ip, r2, #32
   187ce:	fa10 f30c 	lsls.w	r3, r0, ip
   187d2:	fa20 f002 	lsr.w	r0, r0, r2
   187d6:	bf18      	it	ne
   187d8:	f040 0001 	orrne.w	r0, r0, #1
   187dc:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   187e0:	ea4f 23d3 	mov.w	r3, r3, lsr #11
   187e4:	fa03 fc0c 	lsl.w	ip, r3, ip
   187e8:	ea40 000c 	orr.w	r0, r0, ip
   187ec:	fa23 f302 	lsr.w	r3, r3, r2
   187f0:	ea4f 0343 	mov.w	r3, r3, lsl #1
   187f4:	e7cc      	b.n	18790 <__aeabi_d2f+0x14>
   187f6:	ea7f 5362 	mvns.w	r3, r2, asr #21
   187fa:	d107      	bne.n	1880c <__aeabi_d2f+0x90>
   187fc:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
   18800:	bf1e      	ittt	ne
   18802:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
   18806:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
   1880a:	4770      	bxne	lr
   1880c:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
   18810:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   18814:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   18818:	4770      	bx	lr
   1881a:	bf00      	nop

0001881c <__aeabi_ldivmod>:
   1881c:	b97b      	cbnz	r3, 1883e <__aeabi_ldivmod+0x22>
   1881e:	b972      	cbnz	r2, 1883e <__aeabi_ldivmod+0x22>
   18820:	2900      	cmp	r1, #0
   18822:	bfbe      	ittt	lt
   18824:	2000      	movlt	r0, #0
   18826:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
   1882a:	e006      	blt.n	1883a <__aeabi_ldivmod+0x1e>
   1882c:	bf08      	it	eq
   1882e:	2800      	cmpeq	r0, #0
   18830:	bf1c      	itt	ne
   18832:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
   18836:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   1883a:	f000 b9b9 	b.w	18bb0 <__aeabi_idiv0>
   1883e:	f1ad 0c08 	sub.w	ip, sp, #8
   18842:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   18846:	2900      	cmp	r1, #0
   18848:	db09      	blt.n	1885e <__aeabi_ldivmod+0x42>
   1884a:	2b00      	cmp	r3, #0
   1884c:	db1a      	blt.n	18884 <__aeabi_ldivmod+0x68>
   1884e:	f000 f84d 	bl	188ec <__udivmoddi4>
   18852:	f8dd e004 	ldr.w	lr, [sp, #4]
   18856:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   1885a:	b004      	add	sp, #16
   1885c:	4770      	bx	lr
   1885e:	4240      	negs	r0, r0
   18860:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   18864:	2b00      	cmp	r3, #0
   18866:	db1b      	blt.n	188a0 <__aeabi_ldivmod+0x84>
   18868:	f000 f840 	bl	188ec <__udivmoddi4>
   1886c:	f8dd e004 	ldr.w	lr, [sp, #4]
   18870:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   18874:	b004      	add	sp, #16
   18876:	4240      	negs	r0, r0
   18878:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1887c:	4252      	negs	r2, r2
   1887e:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   18882:	4770      	bx	lr
   18884:	4252      	negs	r2, r2
   18886:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1888a:	f000 f82f 	bl	188ec <__udivmoddi4>
   1888e:	f8dd e004 	ldr.w	lr, [sp, #4]
   18892:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   18896:	b004      	add	sp, #16
   18898:	4240      	negs	r0, r0
   1889a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1889e:	4770      	bx	lr
   188a0:	4252      	negs	r2, r2
   188a2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   188a6:	f000 f821 	bl	188ec <__udivmoddi4>
   188aa:	f8dd e004 	ldr.w	lr, [sp, #4]
   188ae:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   188b2:	b004      	add	sp, #16
   188b4:	4252      	negs	r2, r2
   188b6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   188ba:	4770      	bx	lr

000188bc <__aeabi_uldivmod>:
   188bc:	b953      	cbnz	r3, 188d4 <__aeabi_uldivmod+0x18>
   188be:	b94a      	cbnz	r2, 188d4 <__aeabi_uldivmod+0x18>
   188c0:	2900      	cmp	r1, #0
   188c2:	bf08      	it	eq
   188c4:	2800      	cmpeq	r0, #0
   188c6:	bf1c      	itt	ne
   188c8:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
   188cc:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   188d0:	f000 b96e 	b.w	18bb0 <__aeabi_idiv0>
   188d4:	f1ad 0c08 	sub.w	ip, sp, #8
   188d8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
   188dc:	f000 f806 	bl	188ec <__udivmoddi4>
   188e0:	f8dd e004 	ldr.w	lr, [sp, #4]
   188e4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   188e8:	b004      	add	sp, #16
   188ea:	4770      	bx	lr

000188ec <__udivmoddi4>:
   188ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   188f0:	9d08      	ldr	r5, [sp, #32]
   188f2:	4604      	mov	r4, r0
   188f4:	468c      	mov	ip, r1
   188f6:	2b00      	cmp	r3, #0
   188f8:	f040 8083 	bne.w	18a02 <__udivmoddi4+0x116>
   188fc:	428a      	cmp	r2, r1
   188fe:	4617      	mov	r7, r2
   18900:	d947      	bls.n	18992 <__udivmoddi4+0xa6>
   18902:	fab2 f282 	clz	r2, r2
   18906:	b142      	cbz	r2, 1891a <__udivmoddi4+0x2e>
   18908:	f1c2 0020 	rsb	r0, r2, #32
   1890c:	fa24 f000 	lsr.w	r0, r4, r0
   18910:	4091      	lsls	r1, r2
   18912:	4097      	lsls	r7, r2
   18914:	ea40 0c01 	orr.w	ip, r0, r1
   18918:	4094      	lsls	r4, r2
   1891a:	ea4f 4817 	mov.w	r8, r7, lsr #16
   1891e:	0c23      	lsrs	r3, r4, #16
   18920:	fbbc f6f8 	udiv	r6, ip, r8
   18924:	fa1f fe87 	uxth.w	lr, r7
   18928:	fb08 c116 	mls	r1, r8, r6, ip
   1892c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   18930:	fb06 f10e 	mul.w	r1, r6, lr
   18934:	4299      	cmp	r1, r3
   18936:	d909      	bls.n	1894c <__udivmoddi4+0x60>
   18938:	18fb      	adds	r3, r7, r3
   1893a:	f106 30ff 	add.w	r0, r6, #4294967295	; 0xffffffff
   1893e:	f080 8119 	bcs.w	18b74 <__udivmoddi4+0x288>
   18942:	4299      	cmp	r1, r3
   18944:	f240 8116 	bls.w	18b74 <__udivmoddi4+0x288>
   18948:	3e02      	subs	r6, #2
   1894a:	443b      	add	r3, r7
   1894c:	1a5b      	subs	r3, r3, r1
   1894e:	b2a4      	uxth	r4, r4
   18950:	fbb3 f0f8 	udiv	r0, r3, r8
   18954:	fb08 3310 	mls	r3, r8, r0, r3
   18958:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
   1895c:	fb00 fe0e 	mul.w	lr, r0, lr
   18960:	45a6      	cmp	lr, r4
   18962:	d909      	bls.n	18978 <__udivmoddi4+0x8c>
   18964:	193c      	adds	r4, r7, r4
   18966:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   1896a:	f080 8105 	bcs.w	18b78 <__udivmoddi4+0x28c>
   1896e:	45a6      	cmp	lr, r4
   18970:	f240 8102 	bls.w	18b78 <__udivmoddi4+0x28c>
   18974:	3802      	subs	r0, #2
   18976:	443c      	add	r4, r7
   18978:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
   1897c:	eba4 040e 	sub.w	r4, r4, lr
   18980:	2600      	movs	r6, #0
   18982:	b11d      	cbz	r5, 1898c <__udivmoddi4+0xa0>
   18984:	40d4      	lsrs	r4, r2
   18986:	2300      	movs	r3, #0
   18988:	e9c5 4300 	strd	r4, r3, [r5]
   1898c:	4631      	mov	r1, r6
   1898e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18992:	b902      	cbnz	r2, 18996 <__udivmoddi4+0xaa>
   18994:	deff      	udf	#255	; 0xff
   18996:	fab2 f282 	clz	r2, r2
   1899a:	2a00      	cmp	r2, #0
   1899c:	d150      	bne.n	18a40 <__udivmoddi4+0x154>
   1899e:	1bcb      	subs	r3, r1, r7
   189a0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   189a4:	fa1f f887 	uxth.w	r8, r7
   189a8:	2601      	movs	r6, #1
   189aa:	fbb3 fcfe 	udiv	ip, r3, lr
   189ae:	0c21      	lsrs	r1, r4, #16
   189b0:	fb0e 331c 	mls	r3, lr, ip, r3
   189b4:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   189b8:	fb08 f30c 	mul.w	r3, r8, ip
   189bc:	428b      	cmp	r3, r1
   189be:	d907      	bls.n	189d0 <__udivmoddi4+0xe4>
   189c0:	1879      	adds	r1, r7, r1
   189c2:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
   189c6:	d202      	bcs.n	189ce <__udivmoddi4+0xe2>
   189c8:	428b      	cmp	r3, r1
   189ca:	f200 80e9 	bhi.w	18ba0 <__udivmoddi4+0x2b4>
   189ce:	4684      	mov	ip, r0
   189d0:	1ac9      	subs	r1, r1, r3
   189d2:	b2a3      	uxth	r3, r4
   189d4:	fbb1 f0fe 	udiv	r0, r1, lr
   189d8:	fb0e 1110 	mls	r1, lr, r0, r1
   189dc:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
   189e0:	fb08 f800 	mul.w	r8, r8, r0
   189e4:	45a0      	cmp	r8, r4
   189e6:	d907      	bls.n	189f8 <__udivmoddi4+0x10c>
   189e8:	193c      	adds	r4, r7, r4
   189ea:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   189ee:	d202      	bcs.n	189f6 <__udivmoddi4+0x10a>
   189f0:	45a0      	cmp	r8, r4
   189f2:	f200 80d9 	bhi.w	18ba8 <__udivmoddi4+0x2bc>
   189f6:	4618      	mov	r0, r3
   189f8:	eba4 0408 	sub.w	r4, r4, r8
   189fc:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
   18a00:	e7bf      	b.n	18982 <__udivmoddi4+0x96>
   18a02:	428b      	cmp	r3, r1
   18a04:	d909      	bls.n	18a1a <__udivmoddi4+0x12e>
   18a06:	2d00      	cmp	r5, #0
   18a08:	f000 80b1 	beq.w	18b6e <__udivmoddi4+0x282>
   18a0c:	2600      	movs	r6, #0
   18a0e:	e9c5 0100 	strd	r0, r1, [r5]
   18a12:	4630      	mov	r0, r6
   18a14:	4631      	mov	r1, r6
   18a16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18a1a:	fab3 f683 	clz	r6, r3
   18a1e:	2e00      	cmp	r6, #0
   18a20:	d14a      	bne.n	18ab8 <__udivmoddi4+0x1cc>
   18a22:	428b      	cmp	r3, r1
   18a24:	d302      	bcc.n	18a2c <__udivmoddi4+0x140>
   18a26:	4282      	cmp	r2, r0
   18a28:	f200 80b8 	bhi.w	18b9c <__udivmoddi4+0x2b0>
   18a2c:	1a84      	subs	r4, r0, r2
   18a2e:	eb61 0103 	sbc.w	r1, r1, r3
   18a32:	2001      	movs	r0, #1
   18a34:	468c      	mov	ip, r1
   18a36:	2d00      	cmp	r5, #0
   18a38:	d0a8      	beq.n	1898c <__udivmoddi4+0xa0>
   18a3a:	e9c5 4c00 	strd	r4, ip, [r5]
   18a3e:	e7a5      	b.n	1898c <__udivmoddi4+0xa0>
   18a40:	f1c2 0320 	rsb	r3, r2, #32
   18a44:	fa20 f603 	lsr.w	r6, r0, r3
   18a48:	4097      	lsls	r7, r2
   18a4a:	fa01 f002 	lsl.w	r0, r1, r2
   18a4e:	ea4f 4e17 	mov.w	lr, r7, lsr #16
   18a52:	40d9      	lsrs	r1, r3
   18a54:	4330      	orrs	r0, r6
   18a56:	0c03      	lsrs	r3, r0, #16
   18a58:	fbb1 f6fe 	udiv	r6, r1, lr
   18a5c:	fa1f f887 	uxth.w	r8, r7
   18a60:	fb0e 1116 	mls	r1, lr, r6, r1
   18a64:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
   18a68:	fb06 f108 	mul.w	r1, r6, r8
   18a6c:	4299      	cmp	r1, r3
   18a6e:	fa04 f402 	lsl.w	r4, r4, r2
   18a72:	d909      	bls.n	18a88 <__udivmoddi4+0x19c>
   18a74:	18fb      	adds	r3, r7, r3
   18a76:	f106 3cff 	add.w	ip, r6, #4294967295	; 0xffffffff
   18a7a:	f080 808d 	bcs.w	18b98 <__udivmoddi4+0x2ac>
   18a7e:	4299      	cmp	r1, r3
   18a80:	f240 808a 	bls.w	18b98 <__udivmoddi4+0x2ac>
   18a84:	3e02      	subs	r6, #2
   18a86:	443b      	add	r3, r7
   18a88:	1a5b      	subs	r3, r3, r1
   18a8a:	b281      	uxth	r1, r0
   18a8c:	fbb3 f0fe 	udiv	r0, r3, lr
   18a90:	fb0e 3310 	mls	r3, lr, r0, r3
   18a94:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
   18a98:	fb00 f308 	mul.w	r3, r0, r8
   18a9c:	428b      	cmp	r3, r1
   18a9e:	d907      	bls.n	18ab0 <__udivmoddi4+0x1c4>
   18aa0:	1879      	adds	r1, r7, r1
   18aa2:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
   18aa6:	d273      	bcs.n	18b90 <__udivmoddi4+0x2a4>
   18aa8:	428b      	cmp	r3, r1
   18aaa:	d971      	bls.n	18b90 <__udivmoddi4+0x2a4>
   18aac:	3802      	subs	r0, #2
   18aae:	4439      	add	r1, r7
   18ab0:	1acb      	subs	r3, r1, r3
   18ab2:	ea40 4606 	orr.w	r6, r0, r6, lsl #16
   18ab6:	e778      	b.n	189aa <__udivmoddi4+0xbe>
   18ab8:	f1c6 0c20 	rsb	ip, r6, #32
   18abc:	fa03 f406 	lsl.w	r4, r3, r6
   18ac0:	fa22 f30c 	lsr.w	r3, r2, ip
   18ac4:	431c      	orrs	r4, r3
   18ac6:	fa20 f70c 	lsr.w	r7, r0, ip
   18aca:	fa01 f306 	lsl.w	r3, r1, r6
   18ace:	ea4f 4e14 	mov.w	lr, r4, lsr #16
   18ad2:	fa21 f10c 	lsr.w	r1, r1, ip
   18ad6:	431f      	orrs	r7, r3
   18ad8:	0c3b      	lsrs	r3, r7, #16
   18ada:	fbb1 f9fe 	udiv	r9, r1, lr
   18ade:	fa1f f884 	uxth.w	r8, r4
   18ae2:	fb0e 1119 	mls	r1, lr, r9, r1
   18ae6:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
   18aea:	fb09 fa08 	mul.w	sl, r9, r8
   18aee:	458a      	cmp	sl, r1
   18af0:	fa02 f206 	lsl.w	r2, r2, r6
   18af4:	fa00 f306 	lsl.w	r3, r0, r6
   18af8:	d908      	bls.n	18b0c <__udivmoddi4+0x220>
   18afa:	1861      	adds	r1, r4, r1
   18afc:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
   18b00:	d248      	bcs.n	18b94 <__udivmoddi4+0x2a8>
   18b02:	458a      	cmp	sl, r1
   18b04:	d946      	bls.n	18b94 <__udivmoddi4+0x2a8>
   18b06:	f1a9 0902 	sub.w	r9, r9, #2
   18b0a:	4421      	add	r1, r4
   18b0c:	eba1 010a 	sub.w	r1, r1, sl
   18b10:	b2bf      	uxth	r7, r7
   18b12:	fbb1 f0fe 	udiv	r0, r1, lr
   18b16:	fb0e 1110 	mls	r1, lr, r0, r1
   18b1a:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
   18b1e:	fb00 f808 	mul.w	r8, r0, r8
   18b22:	45b8      	cmp	r8, r7
   18b24:	d907      	bls.n	18b36 <__udivmoddi4+0x24a>
   18b26:	19e7      	adds	r7, r4, r7
   18b28:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
   18b2c:	d22e      	bcs.n	18b8c <__udivmoddi4+0x2a0>
   18b2e:	45b8      	cmp	r8, r7
   18b30:	d92c      	bls.n	18b8c <__udivmoddi4+0x2a0>
   18b32:	3802      	subs	r0, #2
   18b34:	4427      	add	r7, r4
   18b36:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
   18b3a:	eba7 0708 	sub.w	r7, r7, r8
   18b3e:	fba0 8902 	umull	r8, r9, r0, r2
   18b42:	454f      	cmp	r7, r9
   18b44:	46c6      	mov	lr, r8
   18b46:	4649      	mov	r1, r9
   18b48:	d31a      	bcc.n	18b80 <__udivmoddi4+0x294>
   18b4a:	d017      	beq.n	18b7c <__udivmoddi4+0x290>
   18b4c:	b15d      	cbz	r5, 18b66 <__udivmoddi4+0x27a>
   18b4e:	ebb3 020e 	subs.w	r2, r3, lr
   18b52:	eb67 0701 	sbc.w	r7, r7, r1
   18b56:	fa07 fc0c 	lsl.w	ip, r7, ip
   18b5a:	40f2      	lsrs	r2, r6
   18b5c:	ea4c 0202 	orr.w	r2, ip, r2
   18b60:	40f7      	lsrs	r7, r6
   18b62:	e9c5 2700 	strd	r2, r7, [r5]
   18b66:	2600      	movs	r6, #0
   18b68:	4631      	mov	r1, r6
   18b6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   18b6e:	462e      	mov	r6, r5
   18b70:	4628      	mov	r0, r5
   18b72:	e70b      	b.n	1898c <__udivmoddi4+0xa0>
   18b74:	4606      	mov	r6, r0
   18b76:	e6e9      	b.n	1894c <__udivmoddi4+0x60>
   18b78:	4618      	mov	r0, r3
   18b7a:	e6fd      	b.n	18978 <__udivmoddi4+0x8c>
   18b7c:	4543      	cmp	r3, r8
   18b7e:	d2e5      	bcs.n	18b4c <__udivmoddi4+0x260>
   18b80:	ebb8 0e02 	subs.w	lr, r8, r2
   18b84:	eb69 0104 	sbc.w	r1, r9, r4
   18b88:	3801      	subs	r0, #1
   18b8a:	e7df      	b.n	18b4c <__udivmoddi4+0x260>
   18b8c:	4608      	mov	r0, r1
   18b8e:	e7d2      	b.n	18b36 <__udivmoddi4+0x24a>
   18b90:	4660      	mov	r0, ip
   18b92:	e78d      	b.n	18ab0 <__udivmoddi4+0x1c4>
   18b94:	4681      	mov	r9, r0
   18b96:	e7b9      	b.n	18b0c <__udivmoddi4+0x220>
   18b98:	4666      	mov	r6, ip
   18b9a:	e775      	b.n	18a88 <__udivmoddi4+0x19c>
   18b9c:	4630      	mov	r0, r6
   18b9e:	e74a      	b.n	18a36 <__udivmoddi4+0x14a>
   18ba0:	f1ac 0c02 	sub.w	ip, ip, #2
   18ba4:	4439      	add	r1, r7
   18ba6:	e713      	b.n	189d0 <__udivmoddi4+0xe4>
   18ba8:	3802      	subs	r0, #2
   18baa:	443c      	add	r4, r7
   18bac:	e724      	b.n	189f8 <__udivmoddi4+0x10c>
   18bae:	bf00      	nop

00018bb0 <__aeabi_idiv0>:
   18bb0:	4770      	bx	lr
   18bb2:	bf00      	nop

00018bb4 <am_devices_cooper_pins_enable>:
// This function configures SPI, IRQ, SCK pins for Cooper
//
//*****************************************************************************
void
am_devices_cooper_pins_enable(void)
{
   18bb4:	b580      	push	{r7, lr}
   18bb6:	af00      	add	r7, sp, #0
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_RESET_PIN, am_hal_gpio_pincfg_output);
   18bb8:	4b15      	ldr	r3, [pc, #84]	; (18c10 <am_devices_cooper_pins_enable+0x5c>)
   18bba:	6819      	ldr	r1, [r3, #0]
   18bbc:	202a      	movs	r0, #42	; 0x2a
   18bbe:	f01c ffbb 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_IRQ_PIN, am_hal_gpio_pincfg_input);
   18bc2:	4b14      	ldr	r3, [pc, #80]	; (18c14 <am_devices_cooper_pins_enable+0x60>)
   18bc4:	6819      	ldr	r1, [r3, #0]
   18bc6:	2027      	movs	r0, #39	; 0x27
   18bc8:	f01c ffb6 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_CLKREQ_PIN, g_AM_DEVICES_COOPER_CLKREQ);
   18bcc:	4b12      	ldr	r3, [pc, #72]	; (18c18 <am_devices_cooper_pins_enable+0x64>)
   18bce:	6819      	ldr	r1, [r3, #0]
   18bd0:	2028      	movs	r0, #40	; 0x28
   18bd2:	f01c ffb1 	bl	35b38 <am_hal_gpio_pinconfig>
#if (!AM_DEVICES_COOPER_QFN_PART)
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SWDIO, am_hal_gpio_pincfg_output);
   18bd6:	4b0e      	ldr	r3, [pc, #56]	; (18c10 <am_devices_cooper_pins_enable+0x5c>)
   18bd8:	6819      	ldr	r1, [r3, #0]
   18bda:	2061      	movs	r0, #97	; 0x61
   18bdc:	f01c ffac 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SWCLK, am_hal_gpio_pincfg_output);
   18be0:	4b0b      	ldr	r3, [pc, #44]	; (18c10 <am_devices_cooper_pins_enable+0x5c>)
   18be2:	6819      	ldr	r1, [r3, #0]
   18be4:	2062      	movs	r0, #98	; 0x62
   18be6:	f01c ffa7 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_SWDIO);
   18bea:	4b0c      	ldr	r3, [pc, #48]	; (18c1c <am_devices_cooper_pins_enable+0x68>)
   18bec:	2202      	movs	r2, #2
   18bee:	601a      	str	r2, [r3, #0]
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_SWCLK);
   18bf0:	4b0a      	ldr	r3, [pc, #40]	; (18c1c <am_devices_cooper_pins_enable+0x68>)
   18bf2:	2204      	movs	r2, #4
   18bf4:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32M_CLK, g_AM_DEVICES_COOPER_32M_CLK);
   18bf6:	4b0a      	ldr	r3, [pc, #40]	; (18c20 <am_devices_cooper_pins_enable+0x6c>)
   18bf8:	6819      	ldr	r1, [r3, #0]
   18bfa:	202e      	movs	r0, #46	; 0x2e
   18bfc:	f01c ff9c 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32K_CLK, g_AM_DEVICES_COOPER_32K_CLK);
   18c00:	4b08      	ldr	r3, [pc, #32]	; (18c24 <am_devices_cooper_pins_enable+0x70>)
   18c02:	6819      	ldr	r1, [r3, #0]
   18c04:	202d      	movs	r0, #45	; 0x2d
   18c06:	f01c ff97 	bl	35b38 <am_hal_gpio_pinconfig>
#else
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32M_OSCEN_PIN, am_hal_gpio_pincfg_output);
    am_hal_gpio_output_set(AM_DEVICES_COOPER_32M_OSCEN_PIN);
    am_util_stdio_printf("\nThe Cooper QFN board is attached for debug\n");
#endif
}
   18c0a:	bf00      	nop
   18c0c:	bd80      	pop	{r7, pc}
   18c0e:	bf00      	nop
   18c10:	00046808 	.word	0x00046808
   18c14:	00046804 	.word	0x00046804
   18c18:	10002b28 	.word	0x10002b28
   18c1c:	40010240 	.word	0x40010240
   18c20:	10002b20 	.word	0x10002b20
   18c24:	10002b24 	.word	0x10002b24

00018c28 <am_devices_cooper_pins_disable>:
// This function configures SPI, IRQ, SCK pins for Cooper
//
//*****************************************************************************
void
am_devices_cooper_pins_disable(void)
{
   18c28:	b580      	push	{r7, lr}
   18c2a:	af00      	add	r7, sp, #0
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_RESET_PIN);
   18c2c:	4b14      	ldr	r3, [pc, #80]	; (18c80 <am_devices_cooper_pins_disable+0x58>)
   18c2e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   18c32:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_IRQ_PIN, am_hal_gpio_pincfg_disabled);
   18c34:	4b13      	ldr	r3, [pc, #76]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c36:	6819      	ldr	r1, [r3, #0]
   18c38:	2027      	movs	r0, #39	; 0x27
   18c3a:	f01c ff7d 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_CLKREQ_PIN, am_hal_gpio_pincfg_disabled);
   18c3e:	4b11      	ldr	r3, [pc, #68]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c40:	6819      	ldr	r1, [r3, #0]
   18c42:	2028      	movs	r0, #40	; 0x28
   18c44:	f01c ff78 	bl	35b38 <am_hal_gpio_pinconfig>
#if (!AM_DEVICES_COOPER_QFN_PART)
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_SWDIO);
   18c48:	4b0f      	ldr	r3, [pc, #60]	; (18c88 <am_devices_cooper_pins_disable+0x60>)
   18c4a:	2202      	movs	r2, #2
   18c4c:	601a      	str	r2, [r3, #0]
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_SWCLK);
   18c4e:	4b0e      	ldr	r3, [pc, #56]	; (18c88 <am_devices_cooper_pins_disable+0x60>)
   18c50:	2204      	movs	r2, #4
   18c52:	601a      	str	r2, [r3, #0]
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SWDIO, am_hal_gpio_pincfg_disabled);
   18c54:	4b0b      	ldr	r3, [pc, #44]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c56:	6819      	ldr	r1, [r3, #0]
   18c58:	2061      	movs	r0, #97	; 0x61
   18c5a:	f01c ff6d 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SWCLK, am_hal_gpio_pincfg_disabled);
   18c5e:	4b09      	ldr	r3, [pc, #36]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c60:	6819      	ldr	r1, [r3, #0]
   18c62:	2062      	movs	r0, #98	; 0x62
   18c64:	f01c ff68 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32M_CLK, am_hal_gpio_pincfg_disabled);
   18c68:	4b06      	ldr	r3, [pc, #24]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c6a:	6819      	ldr	r1, [r3, #0]
   18c6c:	202e      	movs	r0, #46	; 0x2e
   18c6e:	f01c ff63 	bl	35b38 <am_hal_gpio_pinconfig>
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32K_CLK, am_hal_gpio_pincfg_disabled);
   18c72:	4b04      	ldr	r3, [pc, #16]	; (18c84 <am_devices_cooper_pins_disable+0x5c>)
   18c74:	6819      	ldr	r1, [r3, #0]
   18c76:	202d      	movs	r0, #45	; 0x2d
   18c78:	f01c ff5e 	bl	35b38 <am_hal_gpio_pinconfig>
#else
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_32M_OSCEN_PIN);
    am_hal_gpio_pinconfig(AM_DEVICES_COOPER_32M_OSCEN_PIN, am_hal_gpio_pincfg_disabled);
#endif
}
   18c7c:	bf00      	nop
   18c7e:	bd80      	pop	{r7, pc}
   18c80:	40010238 	.word	0x40010238
   18c84:	00046800 	.word	0x00046800
   18c88:	40010240 	.word	0x40010240

00018c8c <am_devices_cooper_init>:
// @return Status.
//
//*****************************************************************************
uint32_t
am_devices_cooper_init(uint32_t ui32Module, am_devices_cooper_config_t* pDevConfig, void** ppHandle, void** ppBleHandle)
{
   18c8c:	b580      	push	{r7, lr}
   18c8e:	b094      	sub	sp, #80	; 0x50
   18c90:	af00      	add	r7, sp, #0
   18c92:	60f8      	str	r0, [r7, #12]
   18c94:	60b9      	str	r1, [r7, #8]
   18c96:	607a      	str	r2, [r7, #4]
   18c98:	603b      	str	r3, [r7, #0]
    void* pBleHandle;
    am_hal_iom_config_t     stIOMCOOPERSettings;
    uint32_t      ui32Index = 0;
   18c9a:	2300      	movs	r3, #0
   18c9c:	64fb      	str	r3, [r7, #76]	; 0x4c
    uint32_t g_CS[AM_REG_IOM_NUM_MODULES] =
   18c9e:	f107 0314 	add.w	r3, r7, #20
   18ca2:	2220      	movs	r2, #32
   18ca4:	2100      	movs	r1, #0
   18ca6:	4618      	mov	r0, r3
   18ca8:	f017 fa22 	bl	300f0 <memset>
    {
        0, 0, 0, 0, 0, 0, 0, 0
    };
    // Allocate a vacant device handle
    for ( ui32Index = 0; ui32Index < AM_DEVICES_COOPER_MAX_DEVICE_NUM; ui32Index++ )
   18cac:	2300      	movs	r3, #0
   18cae:	64fb      	str	r3, [r7, #76]	; 0x4c
   18cb0:	e010      	b.n	18cd4 <am_devices_cooper_init+0x48>
    {
        if ( gAmCooper[ui32Index].bOccupied == false )
   18cb2:	49a9      	ldr	r1, [pc, #676]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18cb4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18cb6:	4613      	mov	r3, r2
   18cb8:	00db      	lsls	r3, r3, #3
   18cba:	4413      	add	r3, r2
   18cbc:	009b      	lsls	r3, r3, #2
   18cbe:	440b      	add	r3, r1
   18cc0:	331c      	adds	r3, #28
   18cc2:	781b      	ldrb	r3, [r3, #0]
   18cc4:	f083 0301 	eor.w	r3, r3, #1
   18cc8:	b2db      	uxtb	r3, r3
   18cca:	2b00      	cmp	r3, #0
   18ccc:	d106      	bne.n	18cdc <am_devices_cooper_init+0x50>
    for ( ui32Index = 0; ui32Index < AM_DEVICES_COOPER_MAX_DEVICE_NUM; ui32Index++ )
   18cce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   18cd0:	3301      	adds	r3, #1
   18cd2:	64fb      	str	r3, [r7, #76]	; 0x4c
   18cd4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   18cd6:	2b00      	cmp	r3, #0
   18cd8:	d0eb      	beq.n	18cb2 <am_devices_cooper_init+0x26>
   18cda:	e000      	b.n	18cde <am_devices_cooper_init+0x52>
        {
            break;
   18cdc:	bf00      	nop
        }
    }
    if ( ui32Index == AM_DEVICES_COOPER_MAX_DEVICE_NUM )
   18cde:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   18ce0:	2b01      	cmp	r3, #1
   18ce2:	d101      	bne.n	18ce8 <am_devices_cooper_init+0x5c>
    {
        return AM_DEVICES_COOPER_STATUS_ERROR;
   18ce4:	2301      	movs	r3, #1
   18ce6:	e133      	b.n	18f50 <am_devices_cooper_init+0x2c4>
    }
    if ( (ui32Module > AM_REG_IOM_NUM_MODULES)  || (pDevConfig == NULL) )
   18ce8:	68fb      	ldr	r3, [r7, #12]
   18cea:	2b08      	cmp	r3, #8
   18cec:	d802      	bhi.n	18cf4 <am_devices_cooper_init+0x68>
   18cee:	68bb      	ldr	r3, [r7, #8]
   18cf0:	2b00      	cmp	r3, #0
   18cf2:	d101      	bne.n	18cf8 <am_devices_cooper_init+0x6c>
    {
        return AM_DEVICES_COOPER_STATUS_ERROR;
   18cf4:	2301      	movs	r3, #1
   18cf6:	e12b      	b.n	18f50 <am_devices_cooper_init+0x2c4>
    }
    //
    // Enable fault detection.
    //
    am_hal_fault_capture_enable();
   18cf8:	f01b f876 	bl	33de8 <am_hal_fault_capture_enable>
    stIOMCOOPERSettings.ui32ClockFreq        = COOPER_IOM_FREQ;
   18cfc:	4b97      	ldr	r3, [pc, #604]	; (18f5c <am_devices_cooper_init+0x2d0>)
   18cfe:	63bb      	str	r3, [r7, #56]	; 0x38
    stIOMCOOPERSettings.eInterfaceMode       = AM_HAL_IOM_SPI_MODE,
   18d00:	2300      	movs	r3, #0
   18d02:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
    stIOMCOOPERSettings.eSpiMode             = AM_HAL_IOM_SPI_MODE_3,
   18d06:	2303      	movs	r3, #3
   18d08:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
    stIOMCOOPERSettings.ui32NBTxnBufLength   = pDevConfig->ui32NBTxnBufLength;
   18d0c:	68bb      	ldr	r3, [r7, #8]
   18d0e:	685b      	ldr	r3, [r3, #4]
   18d10:	647b      	str	r3, [r7, #68]	; 0x44
    stIOMCOOPERSettings.pNBTxnBuf            = pDevConfig->pNBTxnBuf;
   18d12:	68bb      	ldr	r3, [r7, #8]
   18d14:	681b      	ldr	r3, [r3, #0]
   18d16:	643b      	str	r3, [r7, #64]	; 0x40
    // Enable power to the IOM instance.
    // Configure the IOM for Serial operation during initialization.
    // Enable the IOM.
    // HAL Success return is 0
    //
    if (am_hal_iom_initialize(ui32Module, &pBleHandle) ||
   18d18:	f107 0348 	add.w	r3, r7, #72	; 0x48
   18d1c:	4619      	mov	r1, r3
   18d1e:	68f8      	ldr	r0, [r7, #12]
   18d20:	f01b f932 	bl	33f88 <am_hal_iom_initialize>
   18d24:	4603      	mov	r3, r0
   18d26:	2b00      	cmp	r3, #0
   18d28:	d119      	bne.n	18d5e <am_devices_cooper_init+0xd2>
            am_hal_iom_power_ctrl(pBleHandle, AM_HAL_SYSCTRL_WAKE, false) ||
   18d2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   18d2c:	2200      	movs	r2, #0
   18d2e:	2100      	movs	r1, #0
   18d30:	4618      	mov	r0, r3
   18d32:	f01b f9ff 	bl	34134 <am_hal_iom_power_ctrl>
   18d36:	4603      	mov	r3, r0
    if (am_hal_iom_initialize(ui32Module, &pBleHandle) ||
   18d38:	2b00      	cmp	r3, #0
   18d3a:	d110      	bne.n	18d5e <am_devices_cooper_init+0xd2>
            am_hal_iom_configure(pBleHandle, &stIOMCOOPERSettings) ||
   18d3c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   18d3e:	f107 0234 	add.w	r2, r7, #52	; 0x34
   18d42:	4611      	mov	r1, r2
   18d44:	4618      	mov	r0, r3
   18d46:	f01b fae5 	bl	34314 <am_hal_iom_configure>
   18d4a:	4603      	mov	r3, r0
            am_hal_iom_power_ctrl(pBleHandle, AM_HAL_SYSCTRL_WAKE, false) ||
   18d4c:	2b00      	cmp	r3, #0
   18d4e:	d106      	bne.n	18d5e <am_devices_cooper_init+0xd2>
            am_hal_iom_enable(pBleHandle))
   18d50:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   18d52:	4618      	mov	r0, r3
   18d54:	f01b f940 	bl	33fd8 <am_hal_iom_enable>
   18d58:	4603      	mov	r3, r0
            am_hal_iom_configure(pBleHandle, &stIOMCOOPERSettings) ||
   18d5a:	2b00      	cmp	r3, #0
   18d5c:	d001      	beq.n	18d62 <am_devices_cooper_init+0xd6>
    {
        return AM_DEVICES_COOPER_STATUS_ERROR;
   18d5e:	2301      	movs	r3, #1
   18d60:	e0f6      	b.n	18f50 <am_devices_cooper_init+0x2c4>
#if defined(AM_BSP_GPIO_IOM2_CS)
#undef AM_BSP_GPIO_IOM2_CS
#define AM_BSP_GPIO_IOM2_CS  AM_DEVICES_COOPER_SPI_CS // BGA&SIP share the same CS pin(NCE72) on the QFN shiled board
#endif
#endif
        am_bsp_iom_pins_enable(ui32Module, AM_HAL_IOM_SPI_MODE);
   18d62:	2100      	movs	r1, #0
   18d64:	68f8      	ldr	r0, [r7, #12]
   18d66:	f01a fcab 	bl	336c0 <am_bsp_iom_pins_enable>
        am_devices_cooper_pins_enable();
   18d6a:	f7ff ff23 	bl	18bb4 <am_devices_cooper_pins_enable>
#if (!AM_DEVICES_COOPER_QFN_PART)
        // Enable crystals for Cooper
        am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32K_ENABLE, 0);
   18d6e:	2100      	movs	r1, #0
   18d70:	2000      	movs	r0, #0
   18d72:	f01b fe45 	bl	34a00 <am_hal_mcuctrl_control>

        am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32M_KICK_START, 0);
   18d76:	2100      	movs	r1, #0
   18d78:	2002      	movs	r0, #2
   18d7a:	f01b fe41 	bl	34a00 <am_hal_mcuctrl_control>
#endif
        am_devices_cooper_reset();
   18d7e:	f000 f937 	bl	18ff0 <am_devices_cooper_reset>

        gAmCooper[ui32Index].pfnCallback = NULL;
   18d82:	4975      	ldr	r1, [pc, #468]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18d84:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18d86:	4613      	mov	r3, r2
   18d88:	00db      	lsls	r3, r3, #3
   18d8a:	4413      	add	r3, r2
   18d8c:	009b      	lsls	r3, r3, #2
   18d8e:	440b      	add	r3, r1
   18d90:	3310      	adds	r3, #16
   18d92:	2200      	movs	r2, #0
   18d94:	601a      	str	r2, [r3, #0]
        gAmCooper[ui32Index].pCallbackCtxt = NULL;
   18d96:	4970      	ldr	r1, [pc, #448]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18d98:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18d9a:	4613      	mov	r3, r2
   18d9c:	00db      	lsls	r3, r3, #3
   18d9e:	4413      	add	r3, r2
   18da0:	009b      	lsls	r3, r3, #2
   18da2:	440b      	add	r3, r1
   18da4:	3314      	adds	r3, #20
   18da6:	2200      	movs	r2, #0
   18da8:	601a      	str	r2, [r3, #0]
        gAmCooper[ui32Index].bBusy = false;
   18daa:	496b      	ldr	r1, [pc, #428]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18dac:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18dae:	4613      	mov	r3, r2
   18db0:	00db      	lsls	r3, r3, #3
   18db2:	4413      	add	r3, r2
   18db4:	009b      	lsls	r3, r3, #2
   18db6:	440b      	add	r3, r1
   18db8:	331d      	adds	r3, #29
   18dba:	2200      	movs	r2, #0
   18dbc:	701a      	strb	r2, [r3, #0]
        gAmCooper[ui32Index].bOccupied = true;
   18dbe:	4966      	ldr	r1, [pc, #408]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18dc0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18dc2:	4613      	mov	r3, r2
   18dc4:	00db      	lsls	r3, r3, #3
   18dc6:	4413      	add	r3, r2
   18dc8:	009b      	lsls	r3, r3, #2
   18dca:	440b      	add	r3, r1
   18dcc:	331c      	adds	r3, #28
   18dce:	2201      	movs	r2, #1
   18dd0:	701a      	strb	r2, [r3, #0]
        gAmCooper[ui32Index].bNeedCallback = true;
   18dd2:	4961      	ldr	r1, [pc, #388]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18dd4:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18dd6:	4613      	mov	r3, r2
   18dd8:	00db      	lsls	r3, r3, #3
   18dda:	4413      	add	r3, r2
   18ddc:	009b      	lsls	r3, r3, #2
   18dde:	440b      	add	r3, r1
   18de0:	331e      	adds	r3, #30
   18de2:	2201      	movs	r2, #1
   18de4:	701a      	strb	r2, [r3, #0]
        gAmCooper[ui32Index].bDMAComplete = false;
   18de6:	495c      	ldr	r1, [pc, #368]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18de8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18dea:	4613      	mov	r3, r2
   18dec:	00db      	lsls	r3, r3, #3
   18dee:	4413      	add	r3, r2
   18df0:	009b      	lsls	r3, r3, #2
   18df2:	440b      	add	r3, r1
   18df4:	331f      	adds	r3, #31
   18df6:	2200      	movs	r2, #0
   18df8:	701a      	strb	r2, [r3, #0]
        gAmCooper[ui32Index].bWakingUp = false;
   18dfa:	4957      	ldr	r1, [pc, #348]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18dfc:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18dfe:	4613      	mov	r3, r2
   18e00:	00db      	lsls	r3, r3, #3
   18e02:	4413      	add	r3, r2
   18e04:	009b      	lsls	r3, r3, #2
   18e06:	440b      	add	r3, r1
   18e08:	3320      	adds	r3, #32
   18e0a:	2200      	movs	r2, #0
   18e0c:	701a      	strb	r2, [r3, #0]
        gAmCooper[ui32Index].ui32CS = g_CS[ui32Module];
   18e0e:	68fb      	ldr	r3, [r7, #12]
   18e10:	009b      	lsls	r3, r3, #2
   18e12:	f107 0250 	add.w	r2, r7, #80	; 0x50
   18e16:	4413      	add	r3, r2
   18e18:	f853 1c3c 	ldr.w	r1, [r3, #-60]
   18e1c:	484e      	ldr	r0, [pc, #312]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e1e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e20:	4613      	mov	r3, r2
   18e22:	00db      	lsls	r3, r3, #3
   18e24:	4413      	add	r3, r2
   18e26:	009b      	lsls	r3, r3, #2
   18e28:	4403      	add	r3, r0
   18e2a:	3304      	adds	r3, #4
   18e2c:	6019      	str	r1, [r3, #0]
        gAmCooper[ui32Index].ui32Module = ui32Module;
   18e2e:	494a      	ldr	r1, [pc, #296]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e30:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e32:	4613      	mov	r3, r2
   18e34:	00db      	lsls	r3, r3, #3
   18e36:	4413      	add	r3, r2
   18e38:	009b      	lsls	r3, r3, #2
   18e3a:	440b      	add	r3, r1
   18e3c:	68fa      	ldr	r2, [r7, #12]
   18e3e:	601a      	str	r2, [r3, #0]
        gAmCooper[ui32Index].ui32CSDuration = 100;
   18e40:	4945      	ldr	r1, [pc, #276]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e42:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e44:	4613      	mov	r3, r2
   18e46:	00db      	lsls	r3, r3, #3
   18e48:	4413      	add	r3, r2
   18e4a:	009b      	lsls	r3, r3, #2
   18e4c:	440b      	add	r3, r1
   18e4e:	3308      	adds	r3, #8
   18e50:	2264      	movs	r2, #100	; 0x64
   18e52:	601a      	str	r2, [r3, #0]
        *ppBleHandle = gAmCooper[ui32Index].pBleHandle = pBleHandle;
   18e54:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   18e56:	4840      	ldr	r0, [pc, #256]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e58:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e5a:	4613      	mov	r3, r2
   18e5c:	00db      	lsls	r3, r3, #3
   18e5e:	4413      	add	r3, r2
   18e60:	009b      	lsls	r3, r3, #2
   18e62:	4403      	add	r3, r0
   18e64:	3318      	adds	r3, #24
   18e66:	6019      	str	r1, [r3, #0]
   18e68:	493b      	ldr	r1, [pc, #236]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e6a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e6c:	4613      	mov	r3, r2
   18e6e:	00db      	lsls	r3, r3, #3
   18e70:	4413      	add	r3, r2
   18e72:	009b      	lsls	r3, r3, #2
   18e74:	440b      	add	r3, r1
   18e76:	3318      	adds	r3, #24
   18e78:	681a      	ldr	r2, [r3, #0]
   18e7a:	683b      	ldr	r3, [r7, #0]
   18e7c:	601a      	str	r2, [r3, #0]
        *ppHandle = (void*)&gAmCooper[ui32Index];
   18e7e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18e80:	4613      	mov	r3, r2
   18e82:	00db      	lsls	r3, r3, #3
   18e84:	4413      	add	r3, r2
   18e86:	009b      	lsls	r3, r3, #2
   18e88:	4a33      	ldr	r2, [pc, #204]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18e8a:	441a      	add	r2, r3
   18e8c:	687b      	ldr	r3, [r7, #4]
   18e8e:	601a      	str	r2, [r3, #0]
        // SBL checking
        am_devices_cooper_image_update_init(*ppHandle, pDevConfig->pNBTxnBuf);
   18e90:	687b      	ldr	r3, [r7, #4]
   18e92:	681a      	ldr	r2, [r3, #0]
   18e94:	68bb      	ldr	r3, [r7, #8]
   18e96:	681b      	ldr	r3, [r3, #0]
   18e98:	4619      	mov	r1, r3
   18e9a:	4610      	mov	r0, r2
   18e9c:	f000 fc26 	bl	196ec <am_devices_cooper_image_update_init>
        sbl_status = AM_DEVICES_COOPER_SBL_STATUS_INIT;
   18ea0:	4b2f      	ldr	r3, [pc, #188]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18ea2:	2200      	movs	r2, #0
   18ea4:	601a      	str	r2, [r3, #0]
        sbl_status = am_devices_cooper_update_image();
   18ea6:	f000 fc53 	bl	19750 <am_devices_cooper_update_image>
   18eaa:	4603      	mov	r3, r0
   18eac:	4a2c      	ldr	r2, [pc, #176]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18eae:	6013      	str	r3, [r2, #0]

        while ( (sbl_status != AM_DEVICES_COOPER_SBL_STATUS_OK) &&
   18eb0:	e00c      	b.n	18ecc <am_devices_cooper_init+0x240>
                ( sbl_status != AM_DEVICES_COOPER_SBL_STATUS_FAIL) )
        {
            while (am_devices_cooper_irq_read() == 0)
            {
                am_hal_delay_us(50);
   18eb2:	2032      	movs	r0, #50	; 0x32
   18eb4:	f01c fa08 	bl	352c8 <am_hal_delay_us>
            while (am_devices_cooper_irq_read() == 0)
   18eb8:	f000 fab2 	bl	19420 <am_devices_cooper_irq_read>
   18ebc:	4603      	mov	r3, r0
   18ebe:	2b00      	cmp	r3, #0
   18ec0:	d0f7      	beq.n	18eb2 <am_devices_cooper_init+0x226>
            }
            sbl_status = am_devices_cooper_update_image();
   18ec2:	f000 fc45 	bl	19750 <am_devices_cooper_update_image>
   18ec6:	4603      	mov	r3, r0
   18ec8:	4a25      	ldr	r2, [pc, #148]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18eca:	6013      	str	r3, [r2, #0]
        while ( (sbl_status != AM_DEVICES_COOPER_SBL_STATUS_OK) &&
   18ecc:	4b24      	ldr	r3, [pc, #144]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18ece:	681b      	ldr	r3, [r3, #0]
   18ed0:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   18ed4:	d004      	beq.n	18ee0 <am_devices_cooper_init+0x254>
                ( sbl_status != AM_DEVICES_COOPER_SBL_STATUS_FAIL) )
   18ed6:	4b22      	ldr	r3, [pc, #136]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18ed8:	681b      	ldr	r3, [r3, #0]
        while ( (sbl_status != AM_DEVICES_COOPER_SBL_STATUS_OK) &&
   18eda:	f1b3 3fa1 	cmp.w	r3, #2711724449	; 0xa1a1a1a1
   18ede:	d1eb      	bne.n	18eb8 <am_devices_cooper_init+0x22c>
        }
        //
        // Return the status.
        //
        if (sbl_status == AM_DEVICES_COOPER_SBL_STATUS_OK)
   18ee0:	4b1f      	ldr	r3, [pc, #124]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18ee2:	681b      	ldr	r3, [r3, #0]
   18ee4:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   18ee8:	d122      	bne.n	18f30 <am_devices_cooper_init+0x2a4>
        {
            // The CS assertation duration optimization only takes effect after V1.14
            if ( gsSblUpdateState.ui32CooperFWImageVersion < 0x10E )
   18eea:	4b1e      	ldr	r3, [pc, #120]	; (18f64 <am_devices_cooper_init+0x2d8>)
   18eec:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   18eee:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
   18ef2:	d20a      	bcs.n	18f0a <am_devices_cooper_init+0x27e>
            {
                gAmCooper[ui32Index].ui32CSDuration = 300;
   18ef4:	4918      	ldr	r1, [pc, #96]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18ef6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18ef8:	4613      	mov	r3, r2
   18efa:	00db      	lsls	r3, r3, #3
   18efc:	4413      	add	r3, r2
   18efe:	009b      	lsls	r3, r3, #2
   18f00:	440b      	add	r3, r1
   18f02:	3308      	adds	r3, #8
   18f04:	f44f 7296 	mov.w	r2, #300	; 0x12c
   18f08:	601a      	str	r2, [r3, #0]
            }
            gAmCooper[ui32Index].ui32Firmver = gsSblUpdateState.ui32CooperFWImageVersion;
   18f0a:	4b16      	ldr	r3, [pc, #88]	; (18f64 <am_devices_cooper_init+0x2d8>)
   18f0c:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   18f0e:	4812      	ldr	r0, [pc, #72]	; (18f58 <am_devices_cooper_init+0x2cc>)
   18f10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
   18f12:	4613      	mov	r3, r2
   18f14:	00db      	lsls	r3, r3, #3
   18f16:	4413      	add	r3, r2
   18f18:	009b      	lsls	r3, r3, #2
   18f1a:	4403      	add	r3, r0
   18f1c:	330c      	adds	r3, #12
   18f1e:	6019      	str	r1, [r3, #0]
            // need to wait a bit to jump from SBL to Cooper application firmware
            am_util_delay_ms(10);
   18f20:	200a      	movs	r0, #10
   18f22:	f000 ff78 	bl	19e16 <am_util_delay_ms>
            am_util_stdio_printf("BLE Controller Init Done\r\n");
   18f26:	4810      	ldr	r0, [pc, #64]	; (18f68 <am_devices_cooper_init+0x2dc>)
   18f28:	f001 fe3a 	bl	1aba0 <am_util_stdio_printf>
            return AM_DEVICES_COOPER_STATUS_SUCCESS;
   18f2c:	2300      	movs	r3, #0
   18f2e:	e00f      	b.n	18f50 <am_devices_cooper_init+0x2c4>
        }
        else
        {
            // free up resource that won't be used.
            am_devices_cooper_term(*ppHandle);
   18f30:	687b      	ldr	r3, [r7, #4]
   18f32:	681b      	ldr	r3, [r3, #0]
   18f34:	4618      	mov	r0, r3
   18f36:	f000 f81b 	bl	18f70 <am_devices_cooper_term>
            *ppHandle = NULL;
   18f3a:	687b      	ldr	r3, [r7, #4]
   18f3c:	2200      	movs	r2, #0
   18f3e:	601a      	str	r2, [r3, #0]
            am_util_stdio_printf("BLE Controller SBL Error 0x%x\r\n", sbl_status);
   18f40:	4b07      	ldr	r3, [pc, #28]	; (18f60 <am_devices_cooper_init+0x2d4>)
   18f42:	681b      	ldr	r3, [r3, #0]
   18f44:	4619      	mov	r1, r3
   18f46:	4809      	ldr	r0, [pc, #36]	; (18f6c <am_devices_cooper_init+0x2e0>)
   18f48:	f001 fe2a 	bl	1aba0 <am_util_stdio_printf>
            return gsSblUpdateState.ui32CooperSblStatus;
   18f4c:	4b05      	ldr	r3, [pc, #20]	; (18f64 <am_devices_cooper_init+0x2d8>)
   18f4e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
        }
    }
}
   18f50:	4618      	mov	r0, r3
   18f52:	3750      	adds	r7, #80	; 0x50
   18f54:	46bd      	mov	sp, r7
   18f56:	bd80      	pop	{r7, pc}
   18f58:	10010e68 	.word	0x10010e68
   18f5c:	016e3600 	.word	0x016e3600
   18f60:	100038b8 	.word	0x100038b8
   18f64:	10003868 	.word	0x10003868
   18f68:	000443f8 	.word	0x000443f8
   18f6c:	00044414 	.word	0x00044414

00018f70 <am_devices_cooper_term>:
// @return Status.
//
//*****************************************************************************
uint32_t
am_devices_cooper_term(void* pHandle)
{
   18f70:	b580      	push	{r7, lr}
   18f72:	b084      	sub	sp, #16
   18f74:	af00      	add	r7, sp, #0
   18f76:	6078      	str	r0, [r7, #4]
    am_devices_cooper_t* pBle = (am_devices_cooper_t*)pHandle;
   18f78:	687b      	ldr	r3, [r7, #4]
   18f7a:	60fb      	str	r3, [r7, #12]
    if ( pBle->ui32Module > AM_REG_IOM_NUM_MODULES )
   18f7c:	68fb      	ldr	r3, [r7, #12]
   18f7e:	681b      	ldr	r3, [r3, #0]
   18f80:	2b08      	cmp	r3, #8
   18f82:	d901      	bls.n	18f88 <am_devices_cooper_term+0x18>
    {
        return AM_DEVICES_COOPER_STATUS_ERROR;
   18f84:	2301      	movs	r3, #1
   18f86:	e02f      	b.n	18fe8 <am_devices_cooper_term+0x78>
    }
#if (!AM_DEVICES_COOPER_QFN_PART)
    // Disable crystals
    am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32K_DISABLE, 0);
   18f88:	2100      	movs	r1, #0
   18f8a:	2001      	movs	r0, #1
   18f8c:	f01b fd38 	bl	34a00 <am_hal_mcuctrl_control>
    am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32M_DISABLE, 0);
   18f90:	2100      	movs	r1, #0
   18f92:	2004      	movs	r0, #4
   18f94:	f01b fd34 	bl	34a00 <am_hal_mcuctrl_control>
#endif
    // Disable the pins
    am_bsp_iom_pins_disable(pBle->ui32Module, AM_HAL_IOM_SPI_MODE);
   18f98:	68fb      	ldr	r3, [r7, #12]
   18f9a:	681b      	ldr	r3, [r3, #0]
   18f9c:	2100      	movs	r1, #0
   18f9e:	4618      	mov	r0, r3
   18fa0:	f01a fd18 	bl	339d4 <am_bsp_iom_pins_disable>
    am_devices_cooper_pins_disable();
   18fa4:	f7ff fe40 	bl	18c28 <am_devices_cooper_pins_disable>
    //
    // Disable the IOM.
    //
    am_hal_iom_disable(pBle->pBleHandle);
   18fa8:	68fb      	ldr	r3, [r7, #12]
   18faa:	699b      	ldr	r3, [r3, #24]
   18fac:	4618      	mov	r0, r3
   18fae:	f01b f88b 	bl	340c8 <am_hal_iom_disable>
    //
    // Disable power to and uninitialize the IOM instance.
    //
    // Clear local register values first
    am_hal_iom_power_ctrl(pBle->pBleHandle, AM_HAL_SYSCTRL_WAKE, true);
   18fb2:	68fb      	ldr	r3, [r7, #12]
   18fb4:	699b      	ldr	r3, [r3, #24]
   18fb6:	2201      	movs	r2, #1
   18fb8:	2100      	movs	r1, #0
   18fba:	4618      	mov	r0, r3
   18fbc:	f01b f8ba 	bl	34134 <am_hal_iom_power_ctrl>
    am_hal_iom_power_ctrl(pBle->pBleHandle, AM_HAL_SYSCTRL_DEEPSLEEP, false);
   18fc0:	68fb      	ldr	r3, [r7, #12]
   18fc2:	699b      	ldr	r3, [r3, #24]
   18fc4:	2200      	movs	r2, #0
   18fc6:	2102      	movs	r1, #2
   18fc8:	4618      	mov	r0, r3
   18fca:	f01b f8b3 	bl	34134 <am_hal_iom_power_ctrl>
    am_hal_iom_uninitialize(pBle->pBleHandle);
   18fce:	68fb      	ldr	r3, [r7, #12]
   18fd0:	699b      	ldr	r3, [r3, #24]
   18fd2:	4618      	mov	r0, r3
   18fd4:	f01a ff9e 	bl	33f14 <am_hal_iom_uninitialize>
    // Free this device handle
    pBle->bOccupied = false;
   18fd8:	68fb      	ldr	r3, [r7, #12]
   18fda:	2200      	movs	r2, #0
   18fdc:	771a      	strb	r2, [r3, #28]
    // Not in waking up state
    pBle->bWakingUp = false;
   18fde:	68fb      	ldr	r3, [r7, #12]
   18fe0:	2200      	movs	r2, #0
   18fe2:	f883 2020 	strb.w	r2, [r3, #32]
    //
    // Return the status.
    //
    return AM_DEVICES_COOPER_STATUS_SUCCESS;
   18fe6:	2300      	movs	r3, #0
}
   18fe8:	4618      	mov	r0, r3
   18fea:	3710      	adds	r7, #16
   18fec:	46bd      	mov	sp, r7
   18fee:	bd80      	pop	{r7, pc}

00018ff0 <am_devices_cooper_reset>:
// This function asserts reset pin to reset the BLE controller
//
//*****************************************************************************
void
am_devices_cooper_reset(void)
{
   18ff0:	b580      	push	{r7, lr}
   18ff2:	af00      	add	r7, sp, #0
    am_hal_gpio_output_set(AM_DEVICES_COOPER_RESET_PIN);
   18ff4:	4b0b      	ldr	r3, [pc, #44]	; (19024 <am_devices_cooper_reset+0x34>)
   18ff6:	f44f 6280 	mov.w	r2, #1024	; 0x400
   18ffa:	601a      	str	r2, [r3, #0]
    am_util_delay_ms(20);
   18ffc:	2014      	movs	r0, #20
   18ffe:	f000 ff0a 	bl	19e16 <am_util_delay_ms>
    am_hal_gpio_output_clear(AM_DEVICES_COOPER_RESET_PIN);
   19002:	4b09      	ldr	r3, [pc, #36]	; (19028 <am_devices_cooper_reset+0x38>)
   19004:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19008:	601a      	str	r2, [r3, #0]
    am_util_delay_ms(20);
   1900a:	2014      	movs	r0, #20
   1900c:	f000 ff03 	bl	19e16 <am_util_delay_ms>
    am_hal_gpio_output_set(AM_DEVICES_COOPER_RESET_PIN);
   19010:	4b04      	ldr	r3, [pc, #16]	; (19024 <am_devices_cooper_reset+0x34>)
   19012:	f44f 6280 	mov.w	r2, #1024	; 0x400
   19016:	601a      	str	r2, [r3, #0]
    // Give some delay for the 32K clock stablization
    am_util_delay_ms(700);
   19018:	f44f 702f 	mov.w	r0, #700	; 0x2bc
   1901c:	f000 fefb 	bl	19e16 <am_util_delay_ms>
}
   19020:	bf00      	nop
   19022:	bd80      	pop	{r7, pc}
   19024:	40010228 	.word	0x40010228
   19028:	40010238 	.word	0x40010238

0001902c <am_devices_cooper_bus_enable>:
// @return Status.
//
//*****************************************************************************
uint32_t
am_devices_cooper_bus_enable(void* pHandle)
{
   1902c:	b580      	push	{r7, lr}
   1902e:	b084      	sub	sp, #16
   19030:	af00      	add	r7, sp, #0
   19032:	6078      	str	r0, [r7, #4]
    am_devices_cooper_t* pBle = (am_devices_cooper_t*)pHandle;
   19034:	687b      	ldr	r3, [r7, #4]
   19036:	60fb      	str	r3, [r7, #12]
    if ( pBle->bOccupied != true )
   19038:	68fb      	ldr	r3, [r7, #12]
   1903a:	7f1b      	ldrb	r3, [r3, #28]
   1903c:	f083 0301 	eor.w	r3, r3, #1
   19040:	b2db      	uxtb	r3, r3
   19042:	2b00      	cmp	r3, #0
   19044:	d001      	beq.n	1904a <am_devices_cooper_bus_enable+0x1e>
    {
        return AM_DEVICES_COOPER_STATUS_INVALID_OPERATION;
   19046:	2308      	movs	r3, #8
   19048:	e018      	b.n	1907c <am_devices_cooper_bus_enable+0x50>
    }
    // Mark the BLE interface busy so it doesn't get used by more than one
    // interface.
    if (pBle->bBusy == false)
   1904a:	68fb      	ldr	r3, [r7, #12]
   1904c:	7f5b      	ldrb	r3, [r3, #29]
   1904e:	f083 0301 	eor.w	r3, r3, #1
   19052:	b2db      	uxtb	r3, r3
   19054:	2b00      	cmp	r3, #0
   19056:	d010      	beq.n	1907a <am_devices_cooper_bus_enable+0x4e>
    {
        pBle->bBusy = true;
   19058:	68fb      	ldr	r3, [r7, #12]
   1905a:	2201      	movs	r2, #1
   1905c:	775a      	strb	r2, [r3, #29]
    }
    else
    {
        return AM_DEVICES_COOPER_STATUS_BUS_BUSY;
    }
    am_hal_iom_power_ctrl(pBle->pBleHandle, AM_HAL_SYSCTRL_WAKE, true);
   1905e:	68fb      	ldr	r3, [r7, #12]
   19060:	699b      	ldr	r3, [r3, #24]
   19062:	2201      	movs	r2, #1
   19064:	2100      	movs	r1, #0
   19066:	4618      	mov	r0, r3
   19068:	f01b f864 	bl	34134 <am_hal_iom_power_ctrl>
    am_hal_iom_enable(pBle->pBleHandle);
   1906c:	68fb      	ldr	r3, [r7, #12]
   1906e:	699b      	ldr	r3, [r3, #24]
   19070:	4618      	mov	r0, r3
   19072:	f01a ffb1 	bl	33fd8 <am_hal_iom_enable>
    return AM_DEVICES_COOPER_STATUS_SUCCESS;
   19076:	2300      	movs	r3, #0
   19078:	e000      	b.n	1907c <am_devices_cooper_bus_enable+0x50>
        return AM_DEVICES_COOPER_STATUS_BUS_BUSY;
   1907a:	2302      	movs	r3, #2
}
   1907c:	4618      	mov	r0, r3
   1907e:	3710      	adds	r7, #16
   19080:	46bd      	mov	sp, r7
   19082:	bd80      	pop	{r7, pc}

00019084 <am_devices_cooper_bus_disable>:
// @return Status.
//
//*****************************************************************************
uint32_t
am_devices_cooper_bus_disable(void* pHandle)
{
   19084:	b580      	push	{r7, lr}
   19086:	b084      	sub	sp, #16
   19088:	af00      	add	r7, sp, #0
   1908a:	6078      	str	r0, [r7, #4]
    am_devices_cooper_t* pBle = (am_devices_cooper_t*)pHandle;
   1908c:	687b      	ldr	r3, [r7, #4]
   1908e:	60fb      	str	r3, [r7, #12]
    if ( pBle->bOccupied != true )
   19090:	68fb      	ldr	r3, [r7, #12]
   19092:	7f1b      	ldrb	r3, [r3, #28]
   19094:	f083 0301 	eor.w	r3, r3, #1
   19098:	b2db      	uxtb	r3, r3
   1909a:	2b00      	cmp	r3, #0
   1909c:	d001      	beq.n	190a2 <am_devices_cooper_bus_disable+0x1e>
    {
        return AM_DEVICES_COOPER_STATUS_INVALID_OPERATION;
   1909e:	2308      	movs	r3, #8
   190a0:	e00f      	b.n	190c2 <am_devices_cooper_bus_disable+0x3e>
    }
    //
    // Disable the IOM.
    //
    am_hal_iom_disable(pBle->pBleHandle);
   190a2:	68fb      	ldr	r3, [r7, #12]
   190a4:	699b      	ldr	r3, [r3, #24]
   190a6:	4618      	mov	r0, r3
   190a8:	f01b f80e 	bl	340c8 <am_hal_iom_disable>
    //
    // Disable power.
    //
    am_hal_iom_power_ctrl(pBle->pBleHandle, AM_HAL_SYSCTRL_DEEPSLEEP, true);
   190ac:	68fb      	ldr	r3, [r7, #12]
   190ae:	699b      	ldr	r3, [r3, #24]
   190b0:	2201      	movs	r2, #1
   190b2:	2102      	movs	r1, #2
   190b4:	4618      	mov	r0, r3
   190b6:	f01b f83d 	bl	34134 <am_hal_iom_power_ctrl>
    // Release the bus so someone else can use it.
    pBle->bBusy = false;
   190ba:	68fb      	ldr	r3, [r7, #12]
   190bc:	2200      	movs	r2, #0
   190be:	775a      	strb	r2, [r3, #29]
    return AM_DEVICES_COOPER_STATUS_SUCCESS;
   190c0:	2300      	movs	r3, #0
}
   190c2:	4618      	mov	r0, r3
   190c4:	3710      	adds	r7, #16
   190c6:	46bd      	mov	sp, r7
   190c8:	bd80      	pop	{r7, pc}
	...

000190cc <am_devices_cooper_blocking_write>:
//
//*****************************************************************************
uint32_t
am_devices_cooper_blocking_write(void* pHandle, uint8_t ui8Type, uint32_t* pui32Data,
                                 uint32_t ui32NumBytes, bool bWaitReady)
{
   190cc:	b580      	push	{r7, lr}
   190ce:	b094      	sub	sp, #80	; 0x50
   190d0:	af00      	add	r7, sp, #0
   190d2:	60f8      	str	r0, [r7, #12]
   190d4:	607a      	str	r2, [r7, #4]
   190d6:	603b      	str	r3, [r7, #0]
   190d8:	460b      	mov	r3, r1
   190da:	72fb      	strb	r3, [r7, #11]
    uint32_t ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_SUCCESS;
   190dc:	2300      	movs	r3, #0
   190de:	64fb      	str	r3, [r7, #76]	; 0x4c
    uint32_t ui32WaitReadyCount = 0;
   190e0:	2300      	movs	r3, #0
   190e2:	64bb      	str	r3, [r7, #72]	; 0x48
    memset(&sLengthBytes.bytes, 0, 2);
   190e4:	2202      	movs	r2, #2
   190e6:	2100      	movs	r1, #0
   190e8:	4857      	ldr	r0, [pc, #348]	; (19248 <am_devices_cooper_blocking_write+0x17c>)
   190ea:	f017 f801 	bl	300f0 <memset>
    //
    // Make a structure for the IOM transfer.
    //
    am_hal_iom_transfer_t sIOMTransfer;
    am_devices_cooper_t *pBle = (am_devices_cooper_t *)pHandle;
   190ee:	68fb      	ldr	r3, [r7, #12]
   190f0:	647b      	str	r3, [r7, #68]	; 0x44

    if ( pBle->bWakingUp )
   190f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   190f4:	f893 3020 	ldrb.w	r3, [r3, #32]
   190f8:	2b00      	cmp	r3, #0
   190fa:	d003      	beq.n	19104 <am_devices_cooper_blocking_write+0x38>
    {
        ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_CONTROLLER_NOT_READY;
   190fc:	2303      	movs	r3, #3
   190fe:	64fb      	str	r3, [r7, #76]	; 0x4c
        return ui32ErrorStatus;
   19100:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   19102:	e09c      	b.n	1923e <am_devices_cooper_blocking_write+0x172>
    }

    // Awake IOM and lock the bus
    ui32ErrorStatus = am_devices_cooper_bus_enable(pHandle);
   19104:	68f8      	ldr	r0, [r7, #12]
   19106:	f7ff ff91 	bl	1902c <am_devices_cooper_bus_enable>
   1910a:	64f8      	str	r0, [r7, #76]	; 0x4c
    if (ui32ErrorStatus != AM_DEVICES_COOPER_STATUS_SUCCESS)
   1910c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1910e:	2b00      	cmp	r3, #0
   19110:	d001      	beq.n	19116 <am_devices_cooper_blocking_write+0x4a>
    {
        return ui32ErrorStatus;
   19112:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   19114:	e093      	b.n	1923e <am_devices_cooper_blocking_write+0x172>
    }

#if defined(AM_PART_APOLLO4B) || defined(AM_PART_APOLLO4L) || defined(AM_PART_APOLLO4P)
    sIOMTransfer.ui64Instr = OPCODE_H2WRITE_HANDSHAKE;
   19116:	f04f 0280 	mov.w	r2, #128	; 0x80
   1911a:	f04f 0300 	mov.w	r3, #0
   1911e:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
    sIOMTransfer.ui32Instr = OPCODE_H2WRITE_HANDSHAKE;
#endif
    sIOMTransfer.ui32InstrLen = 1;
   19122:	2301      	movs	r3, #1
   19124:	617b      	str	r3, [r7, #20]
    sIOMTransfer.eDirection = AM_HAL_IOM_RX;
   19126:	2301      	movs	r3, #1
   19128:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
    sIOMTransfer.ui32NumBytes = 2;
   1912c:	2302      	movs	r3, #2
   1912e:	623b      	str	r3, [r7, #32]
    sIOMTransfer.bContinue = true;
   19130:	2301      	movs	r3, #1
   19132:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    sIOMTransfer.uPeerInfo.ui32SpiChipSelect = pBle->ui32CS;
   19136:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19138:	685b      	ldr	r3, [r3, #4]
   1913a:	613b      	str	r3, [r7, #16]
    sIOMTransfer.pui32RxBuffer = sLengthBytes.words;
   1913c:	4b42      	ldr	r3, [pc, #264]	; (19248 <am_devices_cooper_blocking_write+0x17c>)
   1913e:	62fb      	str	r3, [r7, #44]	; 0x2c
    sIOMTransfer.ui8RepeatCount = 0;
   19140:	2300      	movs	r3, #0
   19142:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    sIOMTransfer.ui32PauseCondition = 0;
   19146:	2300      	movs	r3, #0
   19148:	637b      	str	r3, [r7, #52]	; 0x34
    sIOMTransfer.ui32StatusSetClr = 0;
   1914a:	2300      	movs	r3, #0
   1914c:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        if (am_hal_iom_blocking_transfer(pBle->pBleHandle, &sIOMTransfer))
   1914e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19150:	699b      	ldr	r3, [r3, #24]
   19152:	f107 0210 	add.w	r2, r7, #16
   19156:	4611      	mov	r1, r2
   19158:	4618      	mov	r0, r3
   1915a:	f01b fa47 	bl	345ec <am_hal_iom_blocking_transfer>
   1915e:	4603      	mov	r3, r0
   19160:	2b00      	cmp	r3, #0
   19162:	d002      	beq.n	1916a <am_devices_cooper_blocking_write+0x9e>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_PACKET_INCOMPLETE;
   19164:	2306      	movs	r3, #6
   19166:	64fb      	str	r3, [r7, #76]	; 0x4c
            break;
   19168:	e065      	b.n	19236 <am_devices_cooper_blocking_write+0x16a>
        }
        // Cooper is not ready now
        if ((sLengthBytes.bytes[0] != 0x68) || (sLengthBytes.bytes[1] != 0xA8))
   1916a:	4b37      	ldr	r3, [pc, #220]	; (19248 <am_devices_cooper_blocking_write+0x17c>)
   1916c:	781b      	ldrb	r3, [r3, #0]
   1916e:	2b68      	cmp	r3, #104	; 0x68
   19170:	d103      	bne.n	1917a <am_devices_cooper_blocking_write+0xae>
   19172:	4b35      	ldr	r3, [pc, #212]	; (19248 <am_devices_cooper_blocking_write+0x17c>)
   19174:	785b      	ldrb	r3, [r3, #1]
   19176:	2ba8      	cmp	r3, #168	; 0xa8
   19178:	d02e      	beq.n	191d8 <am_devices_cooper_blocking_write+0x10c>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_CONTROLLER_NOT_READY;
   1917a:	2303      	movs	r3, #3
   1917c:	64fb      	str	r3, [r7, #76]	; 0x4c
            //
            // Cooper needs CS to low/asserted for 100us to detect wakeup request,
            // and it takes about 2ms for Cooper to be ready to accept packet by asserting
            // IRQ pin.
            //
            am_util_delay_us(pBle->ui32CSDuration);
   1917e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19180:	689b      	ldr	r3, [r3, #8]
   19182:	4618      	mov	r0, r3
   19184:	f000 fe57 	bl	19e36 <am_util_delay_us>
            // For the applications which do not enable IRQ interrupt, we need to do continuous try here
            if ( bWaitReady )
   19188:	f897 3058 	ldrb.w	r3, [r7, #88]	; 0x58
   1918c:	2b00      	cmp	r3, #0
   1918e:	d01e      	beq.n	191ce <am_devices_cooper_blocking_write+0x102>
            {
                //
                // We need to set CS pin (first configured as GPIO) high to trigger Cooper to start wakeup process,
                // after that we reconfigure CS pin back to IOM mode for next transfer.
                //
                am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SPI_CS, am_hal_gpio_pincfg_output);
   19190:	4b2e      	ldr	r3, [pc, #184]	; (1924c <am_devices_cooper_blocking_write+0x180>)
   19192:	6819      	ldr	r1, [r3, #0]
   19194:	202b      	movs	r0, #43	; 0x2b
   19196:	f01c fccf 	bl	35b38 <am_hal_gpio_pinconfig>
                am_hal_gpio_output_set(AM_DEVICES_COOPER_SPI_CS);
   1919a:	4b2d      	ldr	r3, [pc, #180]	; (19250 <am_devices_cooper_blocking_write+0x184>)
   1919c:	f44f 6200 	mov.w	r2, #2048	; 0x800
   191a0:	601a      	str	r2, [r3, #0]
                am_hal_gpio_pinconfig(AM_DEVICES_COOPER_SPI_CS, g_AM_DEVICES_COOPER_SPI_CS);
   191a2:	4b2c      	ldr	r3, [pc, #176]	; (19254 <am_devices_cooper_blocking_write+0x188>)
   191a4:	6819      	ldr	r1, [r3, #0]
   191a6:	202b      	movs	r0, #43	; 0x2b
   191a8:	f01c fcc6 	bl	35b38 <am_hal_gpio_pinconfig>
                am_util_delay_us(1700);
   191ac:	f240 60a4 	movw	r0, #1700	; 0x6a4
   191b0:	f000 fe41 	bl	19e36 <am_util_delay_us>
                //
                // One count is about 2ms, if Cooper is not available to receive HCI packets
                // in configured timeout, need to return the error status and jump out
                // from the infinite trying.
                //
                if (ui32WaitReadyCount == AM_DEVICES_COOPER_RETRY_TIMES)
   191b4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   191b6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   191ba:	d104      	bne.n	191c6 <am_devices_cooper_blocking_write+0xfa>
                {
                    ui32WaitReadyCount = 0;
   191bc:	2300      	movs	r3, #0
   191be:	64bb      	str	r3, [r7, #72]	; 0x48
                    ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_TIMEOUT;
   191c0:	2307      	movs	r3, #7
   191c2:	64fb      	str	r3, [r7, #76]	; 0x4c
                    break;
   191c4:	e037      	b.n	19236 <am_devices_cooper_blocking_write+0x16a>
                }
                ui32WaitReadyCount ++;
   191c6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
   191c8:	3301      	adds	r3, #1
   191ca:	64bb      	str	r3, [r7, #72]	; 0x48
        if (am_hal_iom_blocking_transfer(pBle->pBleHandle, &sIOMTransfer))
   191cc:	e7bf      	b.n	1914e <am_devices_cooper_blocking_write+0x82>
                continue;
            }
            else
            {
                pBle->bWakingUp = true;
   191ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   191d0:	2201      	movs	r2, #1
   191d2:	f883 2020 	strb.w	r2, [r3, #32]
                break;
   191d6:	e02e      	b.n	19236 <am_devices_cooper_blocking_write+0x16a>
            }
        }
        ui32WaitReadyCount = 0;
   191d8:	2300      	movs	r3, #0
   191da:	64bb      	str	r3, [r7, #72]	; 0x48
        //
        // If this isn't a "raw" transaction, we need to make sure the "type" byte
        // gets through to the interface.
        //
        if (ui8Type != AM_DEVICES_COOPER_RAW)
   191dc:	7afb      	ldrb	r3, [r7, #11]
   191de:	2b00      	cmp	r3, #0
   191e0:	d007      	beq.n	191f2 <am_devices_cooper_blocking_write+0x126>
        {
#if defined(AM_PART_APOLLO4B) || defined(AM_PART_APOLLO4L) || defined(AM_PART_APOLLO4P)
            sIOMTransfer.ui64Instr = ui8Type;
   191e2:	7afa      	ldrb	r2, [r7, #11]
   191e4:	f04f 0300 	mov.w	r3, #0
   191e8:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
            sIOMTransfer.ui32Instr = ui8Type;
#endif
            sIOMTransfer.ui32InstrLen = 1;
   191ec:	2301      	movs	r3, #1
   191ee:	617b      	str	r3, [r7, #20]
   191f0:	e007      	b.n	19202 <am_devices_cooper_blocking_write+0x136>
        }
        else
        {
#if defined(AM_PART_APOLLO4B) || defined(AM_PART_APOLLO4L) || defined(AM_PART_APOLLO4P)
            sIOMTransfer.ui64Instr = 0;
   191f2:	f04f 0200 	mov.w	r2, #0
   191f6:	f04f 0300 	mov.w	r3, #0
   191fa:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
            sIOMTransfer.ui32Instr = 0;
#endif
            sIOMTransfer.ui32InstrLen = 0;
   191fe:	2300      	movs	r3, #0
   19200:	617b      	str	r3, [r7, #20]
        }
        sIOMTransfer.eDirection = AM_HAL_IOM_TX;
   19202:	2300      	movs	r3, #0
   19204:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        sIOMTransfer.ui32NumBytes = ui32NumBytes;
   19208:	683b      	ldr	r3, [r7, #0]
   1920a:	623b      	str	r3, [r7, #32]
        sIOMTransfer.pui32TxBuffer = pui32Data;
   1920c:	687b      	ldr	r3, [r7, #4]
   1920e:	62bb      	str	r3, [r7, #40]	; 0x28
        sIOMTransfer.bContinue = false;
   19210:	2300      	movs	r3, #0
   19212:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
        //
        // If the previous step succeeded, we can go ahead and send the data.
        //
        ui32ErrorStatus = am_hal_iom_blocking_transfer(pBle->pBleHandle, &sIOMTransfer);
   19216:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19218:	699b      	ldr	r3, [r3, #24]
   1921a:	f107 0210 	add.w	r2, r7, #16
   1921e:	4611      	mov	r1, r2
   19220:	4618      	mov	r0, r3
   19222:	f01b f9e3 	bl	345ec <am_hal_iom_blocking_transfer>
   19226:	64f8      	str	r0, [r7, #76]	; 0x4c
        if (ui32ErrorStatus != AM_DEVICES_COOPER_STATUS_SUCCESS)
   19228:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
   1922a:	2b00      	cmp	r3, #0
   1922c:	d002      	beq.n	19234 <am_devices_cooper_blocking_write+0x168>
        {
            //
            // The layer above this one doesn't understand IOM errors, so we
            // will intercept and rename it here.
            //
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_PACKET_INCOMPLETE;
   1922e:	2306      	movs	r3, #6
   19230:	64fb      	str	r3, [r7, #76]	; 0x4c
            break;
   19232:	e000      	b.n	19236 <am_devices_cooper_blocking_write+0x16a>
        }
        break;
   19234:	bf00      	nop
    }
    while (1);

    // Disable IOM to save power
    am_devices_cooper_bus_disable(pHandle);
   19236:	68f8      	ldr	r0, [r7, #12]
   19238:	f7ff ff24 	bl	19084 <am_devices_cooper_bus_disable>

    return ui32ErrorStatus;
   1923c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
}
   1923e:	4618      	mov	r0, r3
   19240:	3750      	adds	r7, #80	; 0x50
   19242:	46bd      	mov	sp, r7
   19244:	bd80      	pop	{r7, pc}
   19246:	bf00      	nop
   19248:	10010e8c 	.word	0x10010e8c
   1924c:	00046808 	.word	0x00046808
   19250:	40010228 	.word	0x40010228
   19254:	100037dc 	.word	0x100037dc

00019258 <am_devices_cooper_blocking_read>:
//
//*****************************************************************************
uint32_t
am_devices_cooper_blocking_read(void* pHandle, uint32_t* pui32Data,
                                uint32_t* pui32BytesReceived)
{
   19258:	b580      	push	{r7, lr}
   1925a:	b092      	sub	sp, #72	; 0x48
   1925c:	af00      	add	r7, sp, #0
   1925e:	60f8      	str	r0, [r7, #12]
   19260:	60b9      	str	r1, [r7, #8]
   19262:	607a      	str	r2, [r7, #4]
    uint32_t ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_SUCCESS;
   19264:	2300      	movs	r3, #0
   19266:	647b      	str	r3, [r7, #68]	; 0x44
    memset(&sLengthBytes.bytes, 0, 2);
   19268:	2202      	movs	r2, #2
   1926a:	2100      	movs	r1, #0
   1926c:	4845      	ldr	r0, [pc, #276]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   1926e:	f016 ff3f 	bl	300f0 <memset>
    am_devices_cooper_t* pBle = (am_devices_cooper_t*)pHandle;
   19272:	68fb      	ldr	r3, [r7, #12]
   19274:	643b      	str	r3, [r7, #64]	; 0x40

    // Skip if IRQ pin is low -- no pending incoimng packet from Cooper.
    if (!am_devices_cooper_irq_read())
   19276:	f000 f8d3 	bl	19420 <am_devices_cooper_irq_read>
   1927a:	4603      	mov	r3, r0
   1927c:	2b00      	cmp	r3, #0
   1927e:	d104      	bne.n	1928a <am_devices_cooper_blocking_read+0x32>
    {
        *pui32BytesReceived = 0;
   19280:	687b      	ldr	r3, [r7, #4]
   19282:	2200      	movs	r2, #0
   19284:	601a      	str	r2, [r3, #0]
        return AM_DEVICES_COOPER_STATUS_SUCCESS;
   19286:	2300      	movs	r3, #0
   19288:	e078      	b.n	1937c <am_devices_cooper_blocking_read+0x124>
    //
    // Make a structure for the IOM transfer.
    //
    am_hal_iom_transfer_t sIOMTransfer;
    // Awake IOM and lock the bus
    ui32ErrorStatus = am_devices_cooper_bus_enable(pHandle);
   1928a:	68f8      	ldr	r0, [r7, #12]
   1928c:	f7ff fece 	bl	1902c <am_devices_cooper_bus_enable>
   19290:	6478      	str	r0, [r7, #68]	; 0x44
    if (ui32ErrorStatus != AM_DEVICES_COOPER_STATUS_SUCCESS)
   19292:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19294:	2b00      	cmp	r3, #0
   19296:	d001      	beq.n	1929c <am_devices_cooper_blocking_read+0x44>
    {
        return ui32ErrorStatus;
   19298:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1929a:	e06f      	b.n	1937c <am_devices_cooper_blocking_read+0x124>
    }
    do
    {
        sIOMTransfer.uPeerInfo.ui32SpiChipSelect = pBle->ui32CS;
   1929c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1929e:	685b      	ldr	r3, [r3, #4]
   192a0:	613b      	str	r3, [r7, #16]
#if defined(AM_PART_APOLLO4B) || defined(AM_PART_APOLLO4L) || defined(AM_PART_APOLLO4P)
        sIOMTransfer.ui64Instr = OPCODE_H2READ_HANDSHAKE;
   192a2:	f04f 0204 	mov.w	r2, #4
   192a6:	f04f 0300 	mov.w	r3, #0
   192aa:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
        sIOMTransfer.ui32Instr = OPCODE_H2READ_HANDSHAKE;
#endif
        sIOMTransfer.ui32InstrLen = 1;
   192ae:	2301      	movs	r3, #1
   192b0:	617b      	str	r3, [r7, #20]
        sIOMTransfer.eDirection = AM_HAL_IOM_RX;
   192b2:	2301      	movs	r3, #1
   192b4:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
        sIOMTransfer.ui32NumBytes = 2;
   192b8:	2302      	movs	r3, #2
   192ba:	623b      	str	r3, [r7, #32]
        sIOMTransfer.pui32RxBuffer = sLengthBytes.words;
   192bc:	4b31      	ldr	r3, [pc, #196]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   192be:	62fb      	str	r3, [r7, #44]	; 0x2c
        sIOMTransfer.bContinue = true;
   192c0:	2301      	movs	r3, #1
   192c2:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
        sIOMTransfer.ui8RepeatCount = 0;
   192c6:	2300      	movs	r3, #0
   192c8:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
        sIOMTransfer.ui32PauseCondition = 0;
   192cc:	2300      	movs	r3, #0
   192ce:	637b      	str	r3, [r7, #52]	; 0x34
        sIOMTransfer.ui32StatusSetClr = 0;
   192d0:	2300      	movs	r3, #0
   192d2:	63bb      	str	r3, [r7, #56]	; 0x38
        //
        // First we should get the byte available back
        //
        if (am_hal_iom_blocking_transfer(pBle->pBleHandle, &sIOMTransfer))
   192d4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   192d6:	699b      	ldr	r3, [r3, #24]
   192d8:	f107 0210 	add.w	r2, r7, #16
   192dc:	4611      	mov	r1, r2
   192de:	4618      	mov	r0, r3
   192e0:	f01b f984 	bl	345ec <am_hal_iom_blocking_transfer>
   192e4:	4603      	mov	r3, r0
   192e6:	2b00      	cmp	r3, #0
   192e8:	d002      	beq.n	192f0 <am_devices_cooper_blocking_read+0x98>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_PACKET_INCOMPLETE;
   192ea:	2306      	movs	r3, #6
   192ec:	647b      	str	r3, [r7, #68]	; 0x44
            break;
   192ee:	e041      	b.n	19374 <am_devices_cooper_blocking_read+0x11c>
        }
        if ((sLengthBytes.bytes[0] == 0) && (sLengthBytes.bytes[1] == 0))
   192f0:	4b24      	ldr	r3, [pc, #144]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   192f2:	781b      	ldrb	r3, [r3, #0]
   192f4:	2b00      	cmp	r3, #0
   192f6:	d109      	bne.n	1930c <am_devices_cooper_blocking_read+0xb4>
   192f8:	4b22      	ldr	r3, [pc, #136]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   192fa:	785b      	ldrb	r3, [r3, #1]
   192fc:	2b00      	cmp	r3, #0
   192fe:	d105      	bne.n	1930c <am_devices_cooper_blocking_read+0xb4>
        {
            *pui32BytesReceived = 0;
   19300:	687b      	ldr	r3, [r7, #4]
   19302:	2200      	movs	r2, #0
   19304:	601a      	str	r2, [r3, #0]
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_SUCCESS;
   19306:	2300      	movs	r3, #0
   19308:	647b      	str	r3, [r7, #68]	; 0x44
            break;
   1930a:	e033      	b.n	19374 <am_devices_cooper_blocking_read+0x11c>
        //
        // This is the second frame of the read, which contains the actual HCI
        // data.
        //
#if defined(AM_PART_APOLLO4B) || defined(AM_PART_APOLLO4L) || defined(AM_PART_APOLLO4P)
        sIOMTransfer.ui64Instr = 0;
   1930c:	f04f 0200 	mov.w	r2, #0
   19310:	f04f 0300 	mov.w	r3, #0
   19314:	e9c7 2306 	strd	r2, r3, [r7, #24]
#else
        sIOMTransfer.ui32Instr = 0;
#endif
        sIOMTransfer.ui32InstrLen = 0;
   19318:	2300      	movs	r3, #0
   1931a:	617b      	str	r3, [r7, #20]
        sIOMTransfer.pui32RxBuffer = pui32Data;
   1931c:	68bb      	ldr	r3, [r7, #8]
   1931e:	62fb      	str	r3, [r7, #44]	; 0x2c
        sIOMTransfer.ui32NumBytes = (sLengthBytes.bytes[0] +
   19320:	4b18      	ldr	r3, [pc, #96]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   19322:	781b      	ldrb	r3, [r3, #0]
   19324:	461a      	mov	r2, r3
                                     (sLengthBytes.bytes[1] << 8));
   19326:	4b17      	ldr	r3, [pc, #92]	; (19384 <am_devices_cooper_blocking_read+0x12c>)
   19328:	785b      	ldrb	r3, [r3, #1]
   1932a:	021b      	lsls	r3, r3, #8
        sIOMTransfer.ui32NumBytes = (sLengthBytes.bytes[0] +
   1932c:	4413      	add	r3, r2
   1932e:	623b      	str	r3, [r7, #32]
        sIOMTransfer.bContinue = false;
   19330:	2300      	movs	r3, #0
   19332:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
        // check ui32NumBytes
        if (sIOMTransfer.ui32NumBytes > AM_DEVICES_COOPER_MAX_RX_PACKET)
   19336:	6a3b      	ldr	r3, [r7, #32]
   19338:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
   1933c:	d905      	bls.n	1934a <am_devices_cooper_blocking_read+0xf2>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_WRONG_DATA_LENGTH;
   1933e:	2304      	movs	r3, #4
   19340:	647b      	str	r3, [r7, #68]	; 0x44
            *pui32BytesReceived = 0;
   19342:	687b      	ldr	r3, [r7, #4]
   19344:	2200      	movs	r2, #0
   19346:	601a      	str	r2, [r3, #0]
            break;
   19348:	e014      	b.n	19374 <am_devices_cooper_blocking_read+0x11c>
        }
        //
        // Make sure the caller knows how many bytes we got.
        //
        *pui32BytesReceived = sIOMTransfer.ui32NumBytes;
   1934a:	6a3a      	ldr	r2, [r7, #32]
   1934c:	687b      	ldr	r3, [r7, #4]
   1934e:	601a      	str	r2, [r3, #0]
        //
        // Execute the second part of the transfer.
        //
        ui32ErrorStatus = am_hal_iom_blocking_transfer(pBle->pBleHandle, &sIOMTransfer);
   19350:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   19352:	699b      	ldr	r3, [r3, #24]
   19354:	f107 0210 	add.w	r2, r7, #16
   19358:	4611      	mov	r1, r2
   1935a:	4618      	mov	r0, r3
   1935c:	f01b f946 	bl	345ec <am_hal_iom_blocking_transfer>
   19360:	6478      	str	r0, [r7, #68]	; 0x44
        //
        // A failure here indicates that the second part of the read was bad.
        //
        if (ui32ErrorStatus)
   19362:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   19364:	2b00      	cmp	r3, #0
   19366:	d005      	beq.n	19374 <am_devices_cooper_blocking_read+0x11c>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_PACKET_INCOMPLETE;
   19368:	2306      	movs	r3, #6
   1936a:	647b      	str	r3, [r7, #68]	; 0x44
            *pui32BytesReceived = 0;
   1936c:	687b      	ldr	r3, [r7, #4]
   1936e:	2200      	movs	r2, #0
   19370:	601a      	str	r2, [r3, #0]
            break;
   19372:	bf00      	nop
        }
    }
    while (0);

    // Disable IOM to save power
    am_devices_cooper_bus_disable(pHandle);
   19374:	68f8      	ldr	r0, [r7, #12]
   19376:	f7ff fe85 	bl	19084 <am_devices_cooper_bus_disable>

    return ui32ErrorStatus;
   1937a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
   1937c:	4618      	mov	r0, r3
   1937e:	3748      	adds	r7, #72	; 0x48
   19380:	46bd      	mov	sp, r7
   19382:	bd80      	pop	{r7, pc}
   19384:	10010e8c 	.word	0x10010e8c

00019388 <am_devices_cooper_command_write>:
// @return 32-bit status
//
//*****************************************************************************
uint32_t
am_devices_cooper_command_write(void* pHandle, uint32_t* pui32Cmd, uint32_t ui32Length, uint32_t* pui32Response, uint32_t* pui32BytesReceived)
{
   19388:	b580      	push	{r7, lr}
   1938a:	b088      	sub	sp, #32
   1938c:	af02      	add	r7, sp, #8
   1938e:	60f8      	str	r0, [r7, #12]
   19390:	60b9      	str	r1, [r7, #8]
   19392:	607a      	str	r2, [r7, #4]
   19394:	603b      	str	r3, [r7, #0]
    uint32_t ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_SUCCESS;
   19396:	2300      	movs	r3, #0
   19398:	617b      	str	r3, [r7, #20]
    if ( !pui32Cmd || !pui32Response || !pui32BytesReceived )
   1939a:	68bb      	ldr	r3, [r7, #8]
   1939c:	2b00      	cmp	r3, #0
   1939e:	d005      	beq.n	193ac <am_devices_cooper_command_write+0x24>
   193a0:	683b      	ldr	r3, [r7, #0]
   193a2:	2b00      	cmp	r3, #0
   193a4:	d002      	beq.n	193ac <am_devices_cooper_command_write+0x24>
   193a6:	6a3b      	ldr	r3, [r7, #32]
   193a8:	2b00      	cmp	r3, #0
   193aa:	d101      	bne.n	193b0 <am_devices_cooper_command_write+0x28>
    {
        return AM_DEVICES_COOPER_STATUS_INVALID_OPERATION;
   193ac:	2308      	movs	r3, #8
   193ae:	e031      	b.n	19414 <am_devices_cooper_command_write+0x8c>
    }
    do
    {
        ui32ErrorStatus = am_devices_cooper_blocking_write(pHandle,
   193b0:	2301      	movs	r3, #1
   193b2:	9300      	str	r3, [sp, #0]
   193b4:	687b      	ldr	r3, [r7, #4]
   193b6:	68ba      	ldr	r2, [r7, #8]
   193b8:	2100      	movs	r1, #0
   193ba:	68f8      	ldr	r0, [r7, #12]
   193bc:	f7ff fe86 	bl	190cc <am_devices_cooper_blocking_write>
   193c0:	6178      	str	r0, [r7, #20]
                          AM_DEVICES_COOPER_RAW,
                          pui32Cmd,
                          ui32Length, true);
        if (ui32ErrorStatus)
   193c2:	697b      	ldr	r3, [r7, #20]
   193c4:	2b00      	cmp	r3, #0
   193c6:	d123      	bne.n	19410 <am_devices_cooper_command_write+0x88>
            break;
        }
        //
        // Wait for the response, and return it to the caller via our variable.
        //
        WHILE_TIMEOUT_MS ( am_devices_cooper_irq_read() == 0, 5000, ui32ErrorStatus );
   193c8:	2300      	movs	r3, #0
   193ca:	613b      	str	r3, [r7, #16]
   193cc:	e00c      	b.n	193e8 <am_devices_cooper_command_write+0x60>
   193ce:	693b      	ldr	r3, [r7, #16]
   193d0:	4a12      	ldr	r2, [pc, #72]	; (1941c <am_devices_cooper_command_write+0x94>)
   193d2:	4293      	cmp	r3, r2
   193d4:	d102      	bne.n	193dc <am_devices_cooper_command_write+0x54>
   193d6:	2301      	movs	r3, #1
   193d8:	617b      	str	r3, [r7, #20]
   193da:	e00a      	b.n	193f2 <am_devices_cooper_command_write+0x6a>
   193dc:	2001      	movs	r0, #1
   193de:	f000 fd2a 	bl	19e36 <am_util_delay_us>
   193e2:	693b      	ldr	r3, [r7, #16]
   193e4:	3301      	adds	r3, #1
   193e6:	613b      	str	r3, [r7, #16]
   193e8:	f000 f81a 	bl	19420 <am_devices_cooper_irq_read>
   193ec:	4603      	mov	r3, r0
   193ee:	2b00      	cmp	r3, #0
   193f0:	d0ed      	beq.n	193ce <am_devices_cooper_command_write+0x46>
        if (ui32ErrorStatus)
   193f2:	697b      	ldr	r3, [r7, #20]
   193f4:	2b00      	cmp	r3, #0
   193f6:	d002      	beq.n	193fe <am_devices_cooper_command_write+0x76>
        {
            ui32ErrorStatus = AM_DEVICES_COOPER_STATUS_NO_RESPONSE;
   193f8:	2305      	movs	r3, #5
   193fa:	617b      	str	r3, [r7, #20]
            break;
   193fc:	e009      	b.n	19412 <am_devices_cooper_command_write+0x8a>
        }
        ui32ErrorStatus = am_devices_cooper_blocking_read(pHandle, pui32Response, pui32BytesReceived);
   193fe:	6a3a      	ldr	r2, [r7, #32]
   19400:	6839      	ldr	r1, [r7, #0]
   19402:	68f8      	ldr	r0, [r7, #12]
   19404:	f7ff ff28 	bl	19258 <am_devices_cooper_blocking_read>
   19408:	6178      	str	r0, [r7, #20]
        if (ui32ErrorStatus)
   1940a:	697b      	ldr	r3, [r7, #20]
   1940c:	2b00      	cmp	r3, #0
   1940e:	e000      	b.n	19412 <am_devices_cooper_command_write+0x8a>
            break;
   19410:	bf00      	nop
        }
    } while (0);
    //
    // Return the status.
    //
    return ui32ErrorStatus;
   19412:	697b      	ldr	r3, [r7, #20]
}
   19414:	4618      	mov	r0, r3
   19416:	3718      	adds	r7, #24
   19418:	46bd      	mov	sp, r7
   1941a:	bd80      	pop	{r7, pc}
   1941c:	004c4b40 	.word	0x004c4b40

00019420 <am_devices_cooper_irq_read>:
// Check the state of the IRQ pin.
//
//*****************************************************************************
uint32_t
am_devices_cooper_irq_read(void)
{
   19420:	b480      	push	{r7}
   19422:	af00      	add	r7, sp, #0
    return am_hal_gpio_input_read(AM_DEVICES_COOPER_IRQ_PIN);
   19424:	4b04      	ldr	r3, [pc, #16]	; (19438 <am_devices_cooper_irq_read+0x18>)
   19426:	681b      	ldr	r3, [r3, #0]
   19428:	09db      	lsrs	r3, r3, #7
   1942a:	f003 0301 	and.w	r3, r3, #1
}
   1942e:	4618      	mov	r0, r3
   19430:	46bd      	mov	sp, r7
   19432:	f85d 7b04 	ldr.w	r7, [sp], #4
   19436:	4770      	bx	lr
   19438:	40010208 	.word	0x40010208

0001943c <am_devices_cooper_clkreq_read>:
// Check the state of the CLKREQ pin.
//
//*****************************************************************************
uint32_t
am_devices_cooper_clkreq_read(void* pHandle)
{
   1943c:	b480      	push	{r7}
   1943e:	b083      	sub	sp, #12
   19440:	af00      	add	r7, sp, #0
   19442:	6078      	str	r0, [r7, #4]
    return am_hal_gpio_input_read(AM_DEVICES_COOPER_CLKREQ_PIN);
   19444:	4b05      	ldr	r3, [pc, #20]	; (1945c <am_devices_cooper_clkreq_read+0x20>)
   19446:	681b      	ldr	r3, [r3, #0]
   19448:	0a1b      	lsrs	r3, r3, #8
   1944a:	f003 0301 	and.w	r3, r3, #1
}
   1944e:	4618      	mov	r0, r3
   19450:	370c      	adds	r7, #12
   19452:	46bd      	mov	sp, r7
   19454:	f85d 7b04 	ldr.w	r7, [sp], #4
   19458:	4770      	bx	lr
   1945a:	bf00      	nop
   1945c:	40010208 	.word	0x40010208

00019460 <iom_slave_read>:
//
// Read a packet from the SBL IOS.
//
//*****************************************************************************
bool iom_slave_read(void* pHandle, uint32_t* pBuf, uint32_t* psize)
{
   19460:	b580      	push	{r7, lr}
   19462:	b086      	sub	sp, #24
   19464:	af00      	add	r7, sp, #0
   19466:	60f8      	str	r0, [r7, #12]
   19468:	60b9      	str	r1, [r7, #8]
   1946a:	607a      	str	r2, [r7, #4]
    am_secboot_wired_msghdr_t* msg;
    uint32_t crc32;
    am_devices_cooper_blocking_read(pHandle, pBuf, psize);
   1946c:	687a      	ldr	r2, [r7, #4]
   1946e:	68b9      	ldr	r1, [r7, #8]
   19470:	68f8      	ldr	r0, [r7, #12]
   19472:	f7ff fef1 	bl	19258 <am_devices_cooper_blocking_read>
    // Verify the received data CRC
    msg = (am_secboot_wired_msghdr_t*)pBuf;
   19476:	68bb      	ldr	r3, [r7, #8]
   19478:	617b      	str	r3, [r7, #20]
    am_hal_crc32((uint32_t)&msg->msgType, msg->length - sizeof(uint32_t), &crc32);
   1947a:	697b      	ldr	r3, [r7, #20]
   1947c:	3304      	adds	r3, #4
   1947e:	4618      	mov	r0, r3
   19480:	697b      	ldr	r3, [r7, #20]
   19482:	88db      	ldrh	r3, [r3, #6]
   19484:	3b04      	subs	r3, #4
   19486:	f107 0210 	add.w	r2, r7, #16
   1948a:	4619      	mov	r1, r3
   1948c:	f01d fa96 	bl	369bc <am_hal_crc32>


    return (crc32 == msg->crc32);
   19490:	697b      	ldr	r3, [r7, #20]
   19492:	681a      	ldr	r2, [r3, #0]
   19494:	693b      	ldr	r3, [r7, #16]
   19496:	429a      	cmp	r2, r3
   19498:	bf0c      	ite	eq
   1949a:	2301      	moveq	r3, #1
   1949c:	2300      	movne	r3, #0
   1949e:	b2db      	uxtb	r3, r3
}
   194a0:	4618      	mov	r0, r3
   194a2:	3718      	adds	r7, #24
   194a4:	46bd      	mov	sp, r7
   194a6:	bd80      	pop	{r7, pc}

000194a8 <send_hello>:
//
// Send a "HELLO" packet.
//
//*****************************************************************************
void send_hello(void* pHandle)
{
   194a8:	b580      	push	{r7, lr}
   194aa:	b086      	sub	sp, #24
   194ac:	af02      	add	r7, sp, #8
   194ae:	6078      	str	r0, [r7, #4]
    am_secboot_wired_msghdr_t msg;
    msg.msgType = AM_SBL_HOST_MSG_HELLO;
   194b0:	2300      	movs	r3, #0
   194b2:	81bb      	strh	r3, [r7, #12]
    msg.length = sizeof(am_secboot_wired_msghdr_t);
   194b4:	2308      	movs	r3, #8
   194b6:	81fb      	strh	r3, [r7, #14]
    //
    // Compute CRC
    //
    //PRT_INFO("send_hello: sending bytes: %d.\n", msg.length );
    am_hal_crc32((uint32_t)&msg.msgType, msg.length - sizeof(uint32_t), &msg.crc32);
   194b8:	f107 0308 	add.w	r3, r7, #8
   194bc:	3304      	adds	r3, #4
   194be:	89fa      	ldrh	r2, [r7, #14]
   194c0:	1f11      	subs	r1, r2, #4
   194c2:	f107 0208 	add.w	r2, r7, #8
   194c6:	4618      	mov	r0, r3
   194c8:	f01d fa78 	bl	369bc <am_hal_crc32>
    am_devices_cooper_blocking_write(pHandle, AM_DEVICES_COOPER_RAW, (uint32_t*)&msg, sizeof(msg), true);
   194cc:	f107 0208 	add.w	r2, r7, #8
   194d0:	2301      	movs	r3, #1
   194d2:	9300      	str	r3, [sp, #0]
   194d4:	2308      	movs	r3, #8
   194d6:	2100      	movs	r1, #0
   194d8:	6878      	ldr	r0, [r7, #4]
   194da:	f7ff fdf7 	bl	190cc <am_devices_cooper_blocking_write>
}
   194de:	bf00      	nop
   194e0:	3710      	adds	r7, #16
   194e2:	46bd      	mov	sp, r7
   194e4:	bd80      	pop	{r7, pc}
	...

000194e8 <send_update>:
//
// Send a "UPDATE" packet.
//
//*****************************************************************************
void send_update(void* pHandle, uint32_t imgBlobSize)
{
   194e8:	b580      	push	{r7, lr}
   194ea:	b08a      	sub	sp, #40	; 0x28
   194ec:	af02      	add	r7, sp, #8
   194ee:	6078      	str	r0, [r7, #4]
   194f0:	6039      	str	r1, [r7, #0]
    am_sbl_host_msg_update_t msg;
    msg.msgHdr.msgType = AM_SBL_HOST_MSG_UPDATE;
   194f2:	2303      	movs	r3, #3
   194f4:	81bb      	strh	r3, [r7, #12]
    msg.msgHdr.msgLength = sizeof(am_sbl_host_msg_update_t);
   194f6:	2318      	movs	r3, #24
   194f8:	81fb      	strh	r3, [r7, #14]
    msg.imageSize = imgBlobSize;
   194fa:	683b      	ldr	r3, [r7, #0]
   194fc:	613b      	str	r3, [r7, #16]
    // Check if we are downloading a newer FW versiion
    if ((gsSblUpdateState.ui32CooperFWImageVersion < g_sFwImage.version)
   194fe:	4b1c      	ldr	r3, [pc, #112]	; (19570 <send_update+0x88>)
   19500:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   19502:	4b1c      	ldr	r3, [pc, #112]	; (19574 <send_update+0x8c>)
   19504:	68db      	ldr	r3, [r3, #12]
   19506:	429a      	cmp	r2, r3
   19508:	d305      	bcc.n	19516 <send_update+0x2e>
         || (gsSblUpdateState.ui32CooperVerRollBackConfig & 0x00000001))
   1950a:	4b19      	ldr	r3, [pc, #100]	; (19570 <send_update+0x88>)
   1950c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   1950e:	f003 0301 	and.w	r3, r3, #1
   19512:	2b00      	cmp	r3, #0
   19514:	d003      	beq.n	1951e <send_update+0x36>
    {
        msg.versionNumber = g_sFwImage.version;
   19516:	4b17      	ldr	r3, [pc, #92]	; (19574 <send_update+0x8c>)
   19518:	68db      	ldr	r3, [r3, #12]
   1951a:	61fb      	str	r3, [r7, #28]
   1951c:	e002      	b.n	19524 <send_update+0x3c>
    }
    else
    {
        msg.versionNumber = gsSblUpdateState.ui32CooperFWImageVersion;
   1951e:	4b14      	ldr	r3, [pc, #80]	; (19570 <send_update+0x88>)
   19520:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   19522:	61fb      	str	r3, [r7, #28]
    }
    msg.NumPackets = gsSblUpdateState.ui32TotalPackets + 1; // One addition packet as header will be a seperate packet
   19524:	4b12      	ldr	r3, [pc, #72]	; (19570 <send_update+0x88>)
   19526:	699b      	ldr	r3, [r3, #24]
   19528:	3301      	adds	r3, #1
   1952a:	61bb      	str	r3, [r7, #24]

    // imageSize will be zero if Apollo4 has no available image/patch for Cooper to load
    // set maxPacketSize to invalid parameter to let Cooper to reply NACK and clear signature
    if ( msg.imageSize == 0 )
   1952c:	693b      	ldr	r3, [r7, #16]
   1952e:	2b00      	cmp	r3, #0
   19530:	d103      	bne.n	1953a <send_update+0x52>
    {
        msg.maxPacketSize = AM_DEVICES_COOPER_SBL_UPADTE_INVALID_PSI_PKT_SIZE;
   19532:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   19536:	617b      	str	r3, [r7, #20]
   19538:	e002      	b.n	19540 <send_update+0x58>
    }
    else
    {
        msg.maxPacketSize = AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   1953a:	f44f 7300 	mov.w	r3, #512	; 0x200
   1953e:	617b      	str	r3, [r7, #20]
    }
    //
    // Compute CRC
    //
    am_hal_crc32((uint32_t)&msg.msgHdr.msgType, msg.msgHdr.msgLength - sizeof(uint32_t), &msg.msgHdr.msgCrc);
   19540:	f107 0308 	add.w	r3, r7, #8
   19544:	3304      	adds	r3, #4
   19546:	89fa      	ldrh	r2, [r7, #14]
   19548:	1f11      	subs	r1, r2, #4
   1954a:	f107 0208 	add.w	r2, r7, #8
   1954e:	4618      	mov	r0, r3
   19550:	f01d fa34 	bl	369bc <am_hal_crc32>
    am_devices_cooper_blocking_write(pHandle, AM_DEVICES_COOPER_RAW, (uint32_t*)&msg, sizeof(msg), true);
   19554:	f107 0208 	add.w	r2, r7, #8
   19558:	2301      	movs	r3, #1
   1955a:	9300      	str	r3, [sp, #0]
   1955c:	2318      	movs	r3, #24
   1955e:	2100      	movs	r1, #0
   19560:	6878      	ldr	r0, [r7, #4]
   19562:	f7ff fdb3 	bl	190cc <am_devices_cooper_blocking_write>
}
   19566:	bf00      	nop
   19568:	3720      	adds	r7, #32
   1956a:	46bd      	mov	sp, r7
   1956c:	bd80      	pop	{r7, pc}
   1956e:	bf00      	nop
   19570:	10003868 	.word	0x10003868
   19574:	100038a8 	.word	0x100038a8

00019578 <send_data>:
//
// Send a "Data" packet.
//
//*****************************************************************************
void send_data(void* pHandle, uint32_t address, uint32_t size, uint32_t pktNumber)
{
   19578:	b580      	push	{r7, lr}
   1957a:	b088      	sub	sp, #32
   1957c:	af02      	add	r7, sp, #8
   1957e:	60f8      	str	r0, [r7, #12]
   19580:	60b9      	str	r1, [r7, #8]
   19582:	607a      	str	r2, [r7, #4]
   19584:	603b      	str	r3, [r7, #0]
    // reuse same buffer for receiving
    am_sbl_host_msg_data_t* msg = (am_sbl_host_msg_data_t*)gsSblUpdateState.pWorkBuf;
   19586:	4b16      	ldr	r3, [pc, #88]	; (195e0 <send_data+0x68>)
   19588:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   1958a:	617b      	str	r3, [r7, #20]
    msg->msgHdr.msgType = AM_SBL_HOST_MSG_DATA;
   1958c:	697b      	ldr	r3, [r7, #20]
   1958e:	2208      	movs	r2, #8
   19590:	809a      	strh	r2, [r3, #4]
    msg->msgHdr.msgLength = sizeof(am_sbl_host_msg_data_t) + size;
   19592:	687b      	ldr	r3, [r7, #4]
   19594:	b29b      	uxth	r3, r3
   19596:	330c      	adds	r3, #12
   19598:	b29a      	uxth	r2, r3
   1959a:	697b      	ldr	r3, [r7, #20]
   1959c:	80da      	strh	r2, [r3, #6]
    msg->packetNumber = pktNumber;
   1959e:	697b      	ldr	r3, [r7, #20]
   195a0:	683a      	ldr	r2, [r7, #0]
   195a2:	609a      	str	r2, [r3, #8]
    memcpy((uint8_t*)msg->data, (uint8_t*)address, size);
   195a4:	697b      	ldr	r3, [r7, #20]
   195a6:	330c      	adds	r3, #12
   195a8:	68b9      	ldr	r1, [r7, #8]
   195aa:	687a      	ldr	r2, [r7, #4]
   195ac:	4618      	mov	r0, r3
   195ae:	f7fe fe51 	bl	18254 <memcpy>
    //
    // Compute CRC
    //
    am_hal_crc32((uint32_t) & (msg->msgHdr.msgType), msg->msgHdr.msgLength - sizeof(uint32_t), &msg->msgHdr.msgCrc);
   195b2:	697b      	ldr	r3, [r7, #20]
   195b4:	3304      	adds	r3, #4
   195b6:	4618      	mov	r0, r3
   195b8:	697b      	ldr	r3, [r7, #20]
   195ba:	88db      	ldrh	r3, [r3, #6]
   195bc:	3b04      	subs	r3, #4
   195be:	697a      	ldr	r2, [r7, #20]
   195c0:	4619      	mov	r1, r3
   195c2:	f01d f9fb 	bl	369bc <am_hal_crc32>
    am_devices_cooper_blocking_write(pHandle, AM_DEVICES_COOPER_RAW, (uint32_t*)msg, (sizeof(am_sbl_host_msg_data_t) + size), true);
   195c6:	687b      	ldr	r3, [r7, #4]
   195c8:	330c      	adds	r3, #12
   195ca:	2201      	movs	r2, #1
   195cc:	9200      	str	r2, [sp, #0]
   195ce:	697a      	ldr	r2, [r7, #20]
   195d0:	2100      	movs	r1, #0
   195d2:	68f8      	ldr	r0, [r7, #12]
   195d4:	f7ff fd7a 	bl	190cc <am_devices_cooper_blocking_write>
}
   195d8:	bf00      	nop
   195da:	3718      	adds	r7, #24
   195dc:	46bd      	mov	sp, r7
   195de:	bd80      	pop	{r7, pc}
   195e0:	10003868 	.word	0x10003868

000195e4 <send_fwContinue>:
//
// Send a "FW Continue  packet.
//
//*****************************************************************************
void send_fwContinue(void* pHandle)
{
   195e4:	b580      	push	{r7, lr}
   195e6:	b088      	sub	sp, #32
   195e8:	af02      	add	r7, sp, #8
   195ea:	6078      	str	r0, [r7, #4]
    am_sbl_host_msg_fw_continue_t msg;
    msg.msgHdr.msgType = AM_SBL_HOST_MSG_FW_CONTINUE;
   195ec:	2304      	movs	r3, #4
   195ee:	823b      	strh	r3, [r7, #16]
    msg.msgHdr.msgLength = sizeof(am_sbl_host_msg_fw_continue_t);
   195f0:	230c      	movs	r3, #12
   195f2:	827b      	strh	r3, [r7, #18]
    //
    // Compute CRC
    //
    am_hal_crc32((uint32_t)&msg.msgHdr.msgType, msg.msgHdr.msgLength - sizeof(uint32_t), &msg.msgHdr.msgCrc);
   195f4:	f107 030c 	add.w	r3, r7, #12
   195f8:	3304      	adds	r3, #4
   195fa:	8a7a      	ldrh	r2, [r7, #18]
   195fc:	1f11      	subs	r1, r2, #4
   195fe:	f107 020c 	add.w	r2, r7, #12
   19602:	4618      	mov	r0, r3
   19604:	f01d f9da 	bl	369bc <am_hal_crc32>
    am_devices_cooper_blocking_write(pHandle, AM_DEVICES_COOPER_RAW, (uint32_t*)&msg, sizeof(msg), true);
   19608:	f107 020c 	add.w	r2, r7, #12
   1960c:	2301      	movs	r3, #1
   1960e:	9300      	str	r3, [sp, #0]
   19610:	230c      	movs	r3, #12
   19612:	2100      	movs	r1, #0
   19614:	6878      	ldr	r0, [r7, #4]
   19616:	f7ff fd59 	bl	190cc <am_devices_cooper_blocking_write>
}
   1961a:	bf00      	nop
   1961c:	3718      	adds	r7, #24
   1961e:	46bd      	mov	sp, r7
   19620:	bd80      	pop	{r7, pc}
	...

00019624 <am_devices_cooper_sbl_update_state_data>:
//
// Update the state machine based on the image to download
//
//*****************************************************************************
static bool am_devices_cooper_sbl_update_state_data(uint32_t ui32updateType)
{
   19624:	b480      	push	{r7}
   19626:	b085      	sub	sp, #20
   19628:	af00      	add	r7, sp, #0
   1962a:	6078      	str	r0, [r7, #4]
    // Pointer to the data to be updated
    am_devices_cooper_sbl_update_data_t* p_sUpdateImageData = NULL;
   1962c:	2300      	movs	r3, #0
   1962e:	60fb      	str	r3, [r7, #12]
    if ( ui32updateType == AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_FW )
   19630:	687b      	ldr	r3, [r7, #4]
   19632:	2b00      	cmp	r3, #0
   19634:	d102      	bne.n	1963c <am_devices_cooper_sbl_update_state_data+0x18>
    {
        p_sUpdateImageData = &g_sFwImage;
   19636:	4b29      	ldr	r3, [pc, #164]	; (196dc <am_devices_cooper_sbl_update_state_data+0xb8>)
   19638:	60fb      	str	r3, [r7, #12]
   1963a:	e00d      	b.n	19658 <am_devices_cooper_sbl_update_state_data+0x34>
    }
    else if ( ui32updateType == AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_INFO_0 )
   1963c:	687b      	ldr	r3, [r7, #4]
   1963e:	2b01      	cmp	r3, #1
   19640:	d102      	bne.n	19648 <am_devices_cooper_sbl_update_state_data+0x24>
    {
        p_sUpdateImageData = &g_sInfo0PatchImage;
   19642:	4b27      	ldr	r3, [pc, #156]	; (196e0 <am_devices_cooper_sbl_update_state_data+0xbc>)
   19644:	60fb      	str	r3, [r7, #12]
   19646:	e007      	b.n	19658 <am_devices_cooper_sbl_update_state_data+0x34>
    }
    else if ( ui32updateType == AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_INFO_1 )
   19648:	687b      	ldr	r3, [r7, #4]
   1964a:	2b02      	cmp	r3, #2
   1964c:	d102      	bne.n	19654 <am_devices_cooper_sbl_update_state_data+0x30>
    {
        p_sUpdateImageData = &g_sInfo1PatchImage;
   1964e:	4b25      	ldr	r3, [pc, #148]	; (196e4 <am_devices_cooper_sbl_update_state_data+0xc0>)
   19650:	60fb      	str	r3, [r7, #12]
   19652:	e001      	b.n	19658 <am_devices_cooper_sbl_update_state_data+0x34>
    }
    else
    {
        return false;
   19654:	2300      	movs	r3, #0
   19656:	e03b      	b.n	196d0 <am_devices_cooper_sbl_update_state_data+0xac>
    }
    // Check if the data is valid
    if (    (p_sUpdateImageData != NULL)                &&
   19658:	68fb      	ldr	r3, [r7, #12]
   1965a:	2b00      	cmp	r3, #0
   1965c:	d037      	beq.n	196ce <am_devices_cooper_sbl_update_state_data+0xaa>
            (p_sUpdateImageData->pImageAddress != 0 )    &&
   1965e:	68fb      	ldr	r3, [r7, #12]
   19660:	681b      	ldr	r3, [r3, #0]
    if (    (p_sUpdateImageData != NULL)                &&
   19662:	2b00      	cmp	r3, #0
   19664:	d033      	beq.n	196ce <am_devices_cooper_sbl_update_state_data+0xaa>
            (p_sUpdateImageData->imageSize != 0 )       &&
   19666:	68fb      	ldr	r3, [r7, #12]
   19668:	685b      	ldr	r3, [r3, #4]
            (p_sUpdateImageData->pImageAddress != 0 )    &&
   1966a:	2b00      	cmp	r3, #0
   1966c:	d02f      	beq.n	196ce <am_devices_cooper_sbl_update_state_data+0xaa>
            (p_sUpdateImageData->imageType == ui32updateType) )
   1966e:	68fb      	ldr	r3, [r7, #12]
   19670:	689b      	ldr	r3, [r3, #8]
            (p_sUpdateImageData->imageSize != 0 )       &&
   19672:	687a      	ldr	r2, [r7, #4]
   19674:	429a      	cmp	r2, r3
   19676:	d12a      	bne.n	196ce <am_devices_cooper_sbl_update_state_data+0xaa>
    {
        // Load the INFO 0 Patch address
        gsSblUpdateState.pImageBuf          = p_sUpdateImageData->pImageAddress;
   19678:	68fb      	ldr	r3, [r7, #12]
   1967a:	681b      	ldr	r3, [r3, #0]
   1967c:	4a1a      	ldr	r2, [pc, #104]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   1967e:	6053      	str	r3, [r2, #4]
        // Image size
        gsSblUpdateState.ui32ImageSize      = p_sUpdateImageData->imageSize;
   19680:	68fb      	ldr	r3, [r7, #12]
   19682:	685b      	ldr	r3, [r3, #4]
   19684:	4a18      	ldr	r2, [pc, #96]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   19686:	6093      	str	r3, [r2, #8]
        // image type
        gsSblUpdateState.ui32ImageType      = p_sUpdateImageData->imageType;
   19688:	68fb      	ldr	r3, [r7, #12]
   1968a:	689b      	ldr	r3, [r3, #8]
   1968c:	4a16      	ldr	r2, [pc, #88]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   1968e:	61d3      	str	r3, [r2, #28]
        // Get the size of the data without headers
        gsSblUpdateState.ui32DataSize       = gsSblUpdateState.ui32ImageSize - AM_DEVICES_COOPER_SBL_UPADTE_IMAGE_HDR_SIZE;
   19690:	4b15      	ldr	r3, [pc, #84]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   19692:	689b      	ldr	r3, [r3, #8]
   19694:	3b40      	subs	r3, #64	; 0x40
   19696:	4a14      	ldr	r2, [pc, #80]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   19698:	6113      	str	r3, [r2, #16]
        // Get the start address of the data without headers
        gsSblUpdateState.pDataBuf           = gsSblUpdateState.pImageBuf + AM_DEVICES_COOPER_SBL_UPADTE_IMAGE_HDR_SIZE;
   1969a:	4b13      	ldr	r3, [pc, #76]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   1969c:	685b      	ldr	r3, [r3, #4]
   1969e:	3340      	adds	r3, #64	; 0x40
   196a0:	4a11      	ldr	r2, [pc, #68]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196a2:	60d3      	str	r3, [r2, #12]
        // Calculate number of packets
        gsSblUpdateState.ui32TotalPackets   = gsSblUpdateState.ui32DataSize / AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   196a4:	4b10      	ldr	r3, [pc, #64]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196a6:	691b      	ldr	r3, [r3, #16]
   196a8:	0a5b      	lsrs	r3, r3, #9
   196aa:	4a0f      	ldr	r2, [pc, #60]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196ac:	6193      	str	r3, [r2, #24]
        if (  (gsSblUpdateState.ui32DataSize % AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE) != 0 )
   196ae:	4b0e      	ldr	r3, [pc, #56]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196b0:	691b      	ldr	r3, [r3, #16]
   196b2:	f3c3 0308 	ubfx	r3, r3, #0, #9
   196b6:	2b00      	cmp	r3, #0
   196b8:	d004      	beq.n	196c4 <am_devices_cooper_sbl_update_state_data+0xa0>
        {
            gsSblUpdateState.ui32TotalPackets++;
   196ba:	4b0b      	ldr	r3, [pc, #44]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196bc:	699b      	ldr	r3, [r3, #24]
   196be:	3301      	adds	r3, #1
   196c0:	4a09      	ldr	r2, [pc, #36]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196c2:	6193      	str	r3, [r2, #24]
        }
        gsSblUpdateState.ui32PacketNumber = 0;
   196c4:	4b08      	ldr	r3, [pc, #32]	; (196e8 <am_devices_cooper_sbl_update_state_data+0xc4>)
   196c6:	2200      	movs	r2, #0
   196c8:	615a      	str	r2, [r3, #20]
        return true;
   196ca:	2301      	movs	r3, #1
   196cc:	e000      	b.n	196d0 <am_devices_cooper_sbl_update_state_data+0xac>
    }

    return false;
   196ce:	2300      	movs	r3, #0
}
   196d0:	4618      	mov	r0, r3
   196d2:	3714      	adds	r7, #20
   196d4:	46bd      	mov	sp, r7
   196d6:	f85d 7b04 	ldr.w	r7, [sp], #4
   196da:	4770      	bx	lr
   196dc:	100038a8 	.word	0x100038a8
   196e0:	10002b00 	.word	0x10002b00
   196e4:	10002b10 	.word	0x10002b10
   196e8:	10003868 	.word	0x10003868

000196ec <am_devices_cooper_image_update_init>:
// @param pWorkBuf
// @return 0 is success
//
//*****************************************************************************
uint32_t am_devices_cooper_image_update_init(void* pHandle, uint32_t* pWorkBuf)
{
   196ec:	b480      	push	{r7}
   196ee:	b083      	sub	sp, #12
   196f0:	af00      	add	r7, sp, #0
   196f2:	6078      	str	r0, [r7, #4]
   196f4:	6039      	str	r1, [r7, #0]
    // Check for the input data validity
    if (pHandle != NULL)
   196f6:	687b      	ldr	r3, [r7, #4]
   196f8:	2b00      	cmp	r3, #0
   196fa:	d01f      	beq.n	1973c <am_devices_cooper_image_update_init+0x50>
    {
        // Initialize state machine
        gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_INIT;
   196fc:	4b13      	ldr	r3, [pc, #76]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   196fe:	2200      	movs	r2, #0
   19700:	601a      	str	r2, [r3, #0]
        // Load the image address
        gsSblUpdateState.pImageBuf          = NULL;
   19702:	4b12      	ldr	r3, [pc, #72]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19704:	2200      	movs	r2, #0
   19706:	605a      	str	r2, [r3, #4]
        // Image size
        gsSblUpdateState.ui32ImageSize      = 0;
   19708:	4b10      	ldr	r3, [pc, #64]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   1970a:	2200      	movs	r2, #0
   1970c:	609a      	str	r2, [r3, #8]
        // image type
        gsSblUpdateState.ui32ImageType      = AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_NONE;
   1970e:	4b0f      	ldr	r3, [pc, #60]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19710:	2203      	movs	r2, #3
   19712:	61da      	str	r2, [r3, #28]
        // Get the size of the data without headers
        gsSblUpdateState.ui32DataSize       = 0;
   19714:	4b0d      	ldr	r3, [pc, #52]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19716:	2200      	movs	r2, #0
   19718:	611a      	str	r2, [r3, #16]
        // Get the start address of the data without headers
        gsSblUpdateState.pDataBuf           = NULL;
   1971a:	4b0c      	ldr	r3, [pc, #48]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   1971c:	2200      	movs	r2, #0
   1971e:	60da      	str	r2, [r3, #12]
        // Calculate number of packets
        gsSblUpdateState.ui32TotalPackets   = 0;
   19720:	4b0a      	ldr	r3, [pc, #40]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19722:	2200      	movs	r2, #0
   19724:	619a      	str	r2, [r3, #24]
        // Initialize Packet number in progress
        gsSblUpdateState.ui32PacketNumber = 0;
   19726:	4b09      	ldr	r3, [pc, #36]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19728:	2200      	movs	r2, #0
   1972a:	615a      	str	r2, [r3, #20]
        //
        // Save cooper device handle
        //
        gsSblUpdateState.pHandle = pHandle;
   1972c:	4a07      	ldr	r2, [pc, #28]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   1972e:	687b      	ldr	r3, [r7, #4]
   19730:	6253      	str	r3, [r2, #36]	; 0x24
        //
        // Work buffer reuse non-blocking work buffer.
        //
        gsSblUpdateState.pWorkBuf = pWorkBuf;
   19732:	4a06      	ldr	r2, [pc, #24]	; (1974c <am_devices_cooper_image_update_init+0x60>)
   19734:	683b      	ldr	r3, [r7, #0]
   19736:	6293      	str	r3, [r2, #40]	; 0x28
        // State is ready to go. Reset the cooper device
        return 0;
   19738:	2300      	movs	r3, #0
   1973a:	e000      	b.n	1973e <am_devices_cooper_image_update_init+0x52>
    }
    else
    {
        // Return with error
        return 1;
   1973c:	2301      	movs	r3, #1
    }
}
   1973e:	4618      	mov	r0, r3
   19740:	370c      	adds	r7, #12
   19742:	46bd      	mov	sp, r7
   19744:	f85d 7b04 	ldr.w	r7, [sp], #4
   19748:	4770      	bx	lr
   1974a:	bf00      	nop
   1974c:	10003868 	.word	0x10003868

00019750 <am_devices_cooper_update_image>:
// @breif Update Image
// @return uint32_t
//
//*****************************************************************************
uint32_t am_devices_cooper_update_image(void)
{
   19750:	b580      	push	{r7, lr}
   19752:	b088      	sub	sp, #32
   19754:	af02      	add	r7, sp, #8
    uint32_t     ui32dataPktSize = 0;
   19756:	2300      	movs	r3, #0
   19758:	617b      	str	r3, [r7, #20]
    uint32_t     ui32Size        = 0;
   1975a:	2300      	movs	r3, #0
   1975c:	607b      	str	r3, [r7, #4]
    uint32_t     ui32Ret         = AM_DEVICES_COOPER_SBL_STATUS_INIT;
   1975e:	2300      	movs	r3, #0
   19760:	613b      	str	r3, [r7, #16]
    am_sbl_host_msg_status_t*    psStatusMsg;
    am_sbl_host_msg_ack_nack_t*  psAckMsg;
    switch (gsSblUpdateState.ui32SblUpdateState)
   19762:	4b96      	ldr	r3, [pc, #600]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19764:	681b      	ldr	r3, [r3, #0]
   19766:	2b04      	cmp	r3, #4
   19768:	f200 8315 	bhi.w	19d96 <am_devices_cooper_update_image+0x646>
   1976c:	a201      	add	r2, pc, #4	; (adr r2, 19774 <am_devices_cooper_update_image+0x24>)
   1976e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   19772:	bf00      	nop
   19774:	00019789 	.word	0x00019789
   19778:	0001979f 	.word	0x0001979f
   1977c:	00019a4b 	.word	0x00019a4b
   19780:	00019b5b 	.word	0x00019b5b
   19784:	00019d1d 	.word	0x00019d1d
    {
        case AM_DEVICES_COOPER_SBL_UPDATE_STATE_INIT:
            //
            // Send the "HELLO" message to connect to the interface.
            //
            send_hello(gsSblUpdateState.pHandle);
   19788:	4b8c      	ldr	r3, [pc, #560]	; (199bc <am_devices_cooper_update_image+0x26c>)
   1978a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   1978c:	4618      	mov	r0, r3
   1978e:	f7ff fe8b 	bl	194a8 <send_hello>
            gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_HELLO;
   19792:	4b8a      	ldr	r3, [pc, #552]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19794:	2201      	movs	r2, #1
   19796:	601a      	str	r2, [r3, #0]
            // Tell application that we are not done with SBL
            ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19798:	4b89      	ldr	r3, [pc, #548]	; (199c0 <am_devices_cooper_update_image+0x270>)
   1979a:	613b      	str	r3, [r7, #16]
            break;
   1979c:	e2fe      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
        case AM_DEVICES_COOPER_SBL_UPDATE_STATE_HELLO:
            // Read the "STATUS" response from the IOS and check for CRC Error
            if ( iom_slave_read(gsSblUpdateState.pHandle, (uint32_t*)gsSblUpdateState.pWorkBuf, &ui32Size) == false )
   1979e:	4b87      	ldr	r3, [pc, #540]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   197a2:	4a86      	ldr	r2, [pc, #536]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197a4:	6a91      	ldr	r1, [r2, #40]	; 0x28
   197a6:	1d3a      	adds	r2, r7, #4
   197a8:	4618      	mov	r0, r3
   197aa:	f7ff fe59 	bl	19460 <iom_slave_read>
   197ae:	4603      	mov	r3, r0
   197b0:	f083 0301 	eor.w	r3, r3, #1
   197b4:	b2db      	uxtb	r3, r3
   197b6:	2b00      	cmp	r3, #0
   197b8:	d014      	beq.n	197e4 <am_devices_cooper_update_image+0x94>
            {
                // Increment the Error Counter
                gsSblUpdateState.ui32ErrorCounter++;
   197ba:	4b80      	ldr	r3, [pc, #512]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197bc:	6a1b      	ldr	r3, [r3, #32]
   197be:	3301      	adds	r3, #1
   197c0:	4a7e      	ldr	r2, [pc, #504]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197c2:	6213      	str	r3, [r2, #32]
                // Check if the Error has happened more than the limit
                if ( gsSblUpdateState.ui32ErrorCounter > AM_DEVICES_COOPER_SBL_MAX_COMM_ERR_COUNT )
   197c4:	4b7d      	ldr	r3, [pc, #500]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197c6:	6a1b      	ldr	r3, [r3, #32]
   197c8:	2b03      	cmp	r3, #3
   197ca:	d903      	bls.n	197d4 <am_devices_cooper_update_image+0x84>
                {
                    // Return fail
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   197cc:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   197d0:	613b      	str	r3, [r7, #16]
   197d2:	e11d      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                }
                else
                {
                    // Resend the previous message
                    send_hello(gsSblUpdateState.pHandle);
   197d4:	4b79      	ldr	r3, [pc, #484]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   197d8:	4618      	mov	r0, r3
   197da:	f7ff fe65 	bl	194a8 <send_hello>
                    // Tell application that we are not done with SBL
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   197de:	4b78      	ldr	r3, [pc, #480]	; (199c0 <am_devices_cooper_update_image+0x270>)
   197e0:	613b      	str	r3, [r7, #16]
   197e2:	e115      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                }
            }
            else
            {
                // No CRC error and if there was one, then reset the error counter
                if ( gsSblUpdateState.ui32ErrorCounter )
   197e4:	4b75      	ldr	r3, [pc, #468]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197e6:	6a1b      	ldr	r3, [r3, #32]
   197e8:	2b00      	cmp	r3, #0
   197ea:	d002      	beq.n	197f2 <am_devices_cooper_update_image+0xa2>
                {
                    gsSblUpdateState.ui32ErrorCounter = 0;
   197ec:	4b73      	ldr	r3, [pc, #460]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197ee:	2200      	movs	r2, #0
   197f0:	621a      	str	r2, [r3, #32]
                }
                // Check the status
                psStatusMsg = (am_sbl_host_msg_status_t*) (gsSblUpdateState.pWorkBuf);
   197f2:	4b72      	ldr	r3, [pc, #456]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197f4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   197f6:	60bb      	str	r3, [r7, #8]
                gsSblUpdateState.ui32CooperSblStatus = psStatusMsg->bootStatus;
   197f8:	68bb      	ldr	r3, [r7, #8]
   197fa:	691b      	ldr	r3, [r3, #16]
   197fc:	4a6f      	ldr	r2, [pc, #444]	; (199bc <am_devices_cooper_update_image+0x26c>)
   197fe:	6313      	str	r3, [r2, #48]	; 0x30
                // Get the Cooper FW version
                if ( psStatusMsg->versionNumber == AM_DEVICES_COOPER_SBL_DEFAULT_FW_VERSION )
   19800:	68bb      	ldr	r3, [r7, #8]
   19802:	689b      	ldr	r3, [r3, #8]
   19804:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   19808:	d103      	bne.n	19812 <am_devices_cooper_update_image+0xc2>
                {
                    gsSblUpdateState.ui32CooperFWImageVersion = 0;
   1980a:	4b6c      	ldr	r3, [pc, #432]	; (199bc <am_devices_cooper_update_image+0x26c>)
   1980c:	2200      	movs	r2, #0
   1980e:	62da      	str	r2, [r3, #44]	; 0x2c
   19810:	e003      	b.n	1981a <am_devices_cooper_update_image+0xca>
                }
                else
                {
                    gsSblUpdateState.ui32CooperFWImageVersion = psStatusMsg->versionNumber;
   19812:	68bb      	ldr	r3, [r7, #8]
   19814:	689b      	ldr	r3, [r3, #8]
   19816:	4a69      	ldr	r2, [pc, #420]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19818:	62d3      	str	r3, [r2, #44]	; 0x2c
                }
                am_util_stdio_printf("BLE Controller Info:\n");
   1981a:	486a      	ldr	r0, [pc, #424]	; (199c4 <am_devices_cooper_update_image+0x274>)
   1981c:	f001 f9c0 	bl	1aba0 <am_util_stdio_printf>
                 * The higher 16-bit is used to identify the major and minor version of based release firmware.
                 * The lower 16-bit is used to identify the version for testing before next release.
                 * Originally the code only prints the lower 16-bit of FW version, need to print all the bytes
                 * based on new structure of firmware version now.
                 */
                if ((psStatusMsg->versionNumber & 0xFFFF0000) == 0)
   19820:	68bb      	ldr	r3, [r7, #8]
   19822:	689b      	ldr	r3, [r3, #8]
   19824:	0c1b      	lsrs	r3, r3, #16
   19826:	041b      	lsls	r3, r3, #16
   19828:	2b00      	cmp	r3, #0
   1982a:	d10c      	bne.n	19846 <am_devices_cooper_update_image+0xf6>
                {
                    am_util_stdio_printf("\tFW Ver:      %d.%d\n", (psStatusMsg->versionNumber & 0xF00) >> 8, psStatusMsg->versionNumber & 0xFF);
   1982c:	68bb      	ldr	r3, [r7, #8]
   1982e:	689b      	ldr	r3, [r3, #8]
   19830:	0a1b      	lsrs	r3, r3, #8
   19832:	f003 010f 	and.w	r1, r3, #15
   19836:	68bb      	ldr	r3, [r7, #8]
   19838:	689b      	ldr	r3, [r3, #8]
   1983a:	b2db      	uxtb	r3, r3
   1983c:	461a      	mov	r2, r3
   1983e:	4862      	ldr	r0, [pc, #392]	; (199c8 <am_devices_cooper_update_image+0x278>)
   19840:	f001 f9ae 	bl	1aba0 <am_util_stdio_printf>
   19844:	e012      	b.n	1986c <am_devices_cooper_update_image+0x11c>
                }
                else
                {
                    am_util_stdio_printf("\tFW Ver:      %d.%d.%d.%d\n", (psStatusMsg->versionNumber & 0xFF000000) >> 24, (psStatusMsg->versionNumber & 0xFF0000) >> 16,
   19846:	68bb      	ldr	r3, [r7, #8]
   19848:	689b      	ldr	r3, [r3, #8]
   1984a:	0e19      	lsrs	r1, r3, #24
   1984c:	68bb      	ldr	r3, [r7, #8]
   1984e:	689b      	ldr	r3, [r3, #8]
   19850:	0c1b      	lsrs	r3, r3, #16
   19852:	b2da      	uxtb	r2, r3
                                                                        (psStatusMsg->versionNumber & 0xFF00) >> 8, psStatusMsg->versionNumber & 0xFF);
   19854:	68bb      	ldr	r3, [r7, #8]
   19856:	689b      	ldr	r3, [r3, #8]
   19858:	0a1b      	lsrs	r3, r3, #8
                    am_util_stdio_printf("\tFW Ver:      %d.%d.%d.%d\n", (psStatusMsg->versionNumber & 0xFF000000) >> 24, (psStatusMsg->versionNumber & 0xFF0000) >> 16,
   1985a:	b2d8      	uxtb	r0, r3
                                                                        (psStatusMsg->versionNumber & 0xFF00) >> 8, psStatusMsg->versionNumber & 0xFF);
   1985c:	68bb      	ldr	r3, [r7, #8]
   1985e:	689b      	ldr	r3, [r3, #8]
                    am_util_stdio_printf("\tFW Ver:      %d.%d.%d.%d\n", (psStatusMsg->versionNumber & 0xFF000000) >> 24, (psStatusMsg->versionNumber & 0xFF0000) >> 16,
   19860:	b2db      	uxtb	r3, r3
   19862:	9300      	str	r3, [sp, #0]
   19864:	4603      	mov	r3, r0
   19866:	4859      	ldr	r0, [pc, #356]	; (199cc <am_devices_cooper_update_image+0x27c>)
   19868:	f001 f99a 	bl	1aba0 <am_util_stdio_printf>
                }
                if (ui32Size == sizeof(am_sbl_host_msg_status_t))
   1986c:	687b      	ldr	r3, [r7, #4]
   1986e:	2b20      	cmp	r3, #32
   19870:	d118      	bne.n	198a4 <am_devices_cooper_update_image+0x154>
                {
                    // Get the version rollback configuration
                    gsSblUpdateState.ui32CooperVerRollBackConfig = psStatusMsg->verRollBackStatus;
   19872:	68bb      	ldr	r3, [r7, #8]
   19874:	695b      	ldr	r3, [r3, #20]
   19876:	4a51      	ldr	r2, [pc, #324]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19878:	6353      	str	r3, [r2, #52]	; 0x34
                    else
                    {
                        am_util_stdio_printf("Version RollBack Config invalid !!! \n");
                    }
#endif
                    am_util_stdio_printf("\tChip ID0:    0x%x\n", psStatusMsg->copperChipIdWord0);
   1987a:	68bb      	ldr	r3, [r7, #8]
   1987c:	699b      	ldr	r3, [r3, #24]
   1987e:	4619      	mov	r1, r3
   19880:	4853      	ldr	r0, [pc, #332]	; (199d0 <am_devices_cooper_update_image+0x280>)
   19882:	f001 f98d 	bl	1aba0 <am_util_stdio_printf>
                    am_util_stdio_printf("\tChip ID1:    0x%x\n\n", psStatusMsg->copperChipIdWord1);
   19886:	68bb      	ldr	r3, [r7, #8]
   19888:	69db      	ldr	r3, [r3, #28]
   1988a:	4619      	mov	r1, r3
   1988c:	4851      	ldr	r0, [pc, #324]	; (199d4 <am_devices_cooper_update_image+0x284>)
   1988e:	f001 f987 	bl	1aba0 <am_util_stdio_printf>

                    gsSblUpdateState.ui32copperChipIdWord0 = psStatusMsg->copperChipIdWord0;
   19892:	68bb      	ldr	r3, [r7, #8]
   19894:	699b      	ldr	r3, [r3, #24]
   19896:	4a49      	ldr	r2, [pc, #292]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19898:	6393      	str	r3, [r2, #56]	; 0x38
                    gsSblUpdateState.ui32copperChipIdWord1 = psStatusMsg->copperChipIdWord1;
   1989a:	68bb      	ldr	r3, [r7, #8]
   1989c:	69db      	ldr	r3, [r3, #28]
   1989e:	4a47      	ldr	r2, [pc, #284]	; (199bc <am_devices_cooper_update_image+0x26c>)
   198a0:	63d3      	str	r3, [r2, #60]	; 0x3c
   198a2:	e002      	b.n	198aa <am_devices_cooper_update_image+0x15a>

                }
                else
                {
                    gsSblUpdateState.ui32CooperVerRollBackConfig = 0x0;
   198a4:	4b45      	ldr	r3, [pc, #276]	; (199bc <am_devices_cooper_update_image+0x26c>)
   198a6:	2200      	movs	r2, #0
   198a8:	635a      	str	r2, [r3, #52]	; 0x34
                #if (SBL_DEBUG_LOG_ON == 1)
                am_util_stdio_printf("BLE Controller SBL Status:  0x%x\n", sbl_status);
                am_util_stdio_printf("bootStatus 0x%x\n", psStatusMsg->bootStatus);
                #endif
                // check if the Boot Status is success
                if ( psStatusMsg->bootStatus == AM_DEVICES_COOPER_SBL_STAT_RESP_SUCCESS )
   198aa:	68bb      	ldr	r3, [r7, #8]
   198ac:	691b      	ldr	r3, [r3, #16]
   198ae:	2b00      	cmp	r3, #0
   198b0:	d148      	bne.n	19944 <am_devices_cooper_update_image+0x1f4>
                {
                    // Check if we have some FW available
                    if (  am_devices_cooper_sbl_update_state_data(AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_FW) == true )
   198b2:	2000      	movs	r0, #0
   198b4:	f7ff feb6 	bl	19624 <am_devices_cooper_sbl_update_state_data>
   198b8:	4603      	mov	r3, r0
   198ba:	2b00      	cmp	r3, #0
   198bc:	d02d      	beq.n	1991a <am_devices_cooper_update_image+0x1ca>
                    {
                        // Check if we have a newer FW version
                        if ( psStatusMsg->versionNumber < g_sFwImage.version )
   198be:	68bb      	ldr	r3, [r7, #8]
   198c0:	689a      	ldr	r2, [r3, #8]
   198c2:	4b45      	ldr	r3, [pc, #276]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198c4:	68db      	ldr	r3, [r3, #12]
   198c6:	429a      	cmp	r2, r3
   198c8:	d227      	bcs.n	1991a <am_devices_cooper_update_image+0x1ca>
                        {
                            // We have newer FW available, Letus upgrade
                            ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_FW;
   198ca:	4b44      	ldr	r3, [pc, #272]	; (199dc <am_devices_cooper_update_image+0x28c>)
   198cc:	613b      	str	r3, [r7, #16]
                            if ((g_sFwImage.version & 0xFFFF0000) == 0)
   198ce:	4b42      	ldr	r3, [pc, #264]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198d0:	68db      	ldr	r3, [r3, #12]
   198d2:	0c1b      	lsrs	r3, r3, #16
   198d4:	041b      	lsls	r3, r3, #16
   198d6:	2b00      	cmp	r3, #0
   198d8:	d10c      	bne.n	198f4 <am_devices_cooper_update_image+0x1a4>
                            {
                                am_util_stdio_printf("Received new BLE Controller FW version = %d.%d Going for upgrade\n", (g_sFwImage.version & 0xF00) >> 8, g_sFwImage.version & 0xFF);
   198da:	4b3f      	ldr	r3, [pc, #252]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198dc:	68db      	ldr	r3, [r3, #12]
   198de:	0a1b      	lsrs	r3, r3, #8
   198e0:	f003 030f 	and.w	r3, r3, #15
   198e4:	4a3c      	ldr	r2, [pc, #240]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198e6:	68d2      	ldr	r2, [r2, #12]
   198e8:	b2d2      	uxtb	r2, r2
   198ea:	4619      	mov	r1, r3
   198ec:	483c      	ldr	r0, [pc, #240]	; (199e0 <am_devices_cooper_update_image+0x290>)
   198ee:	f001 f957 	bl	1aba0 <am_util_stdio_printf>
   198f2:	e012      	b.n	1991a <am_devices_cooper_update_image+0x1ca>
                            }
                            else
                            {
                                am_util_stdio_printf("Received new BLE Controller FW version = %d.%d.%d.%d Going for upgrade\n", (g_sFwImage.version & 0xFF000000) >> 24, (g_sFwImage.version & 0xFF0000) >> 16,
   198f4:	4b38      	ldr	r3, [pc, #224]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198f6:	68db      	ldr	r3, [r3, #12]
   198f8:	0e19      	lsrs	r1, r3, #24
   198fa:	4b37      	ldr	r3, [pc, #220]	; (199d8 <am_devices_cooper_update_image+0x288>)
   198fc:	68db      	ldr	r3, [r3, #12]
   198fe:	0c1b      	lsrs	r3, r3, #16
   19900:	b2da      	uxtb	r2, r3
                                                                                                                            (g_sFwImage.version & 0xFF00) >> 8, g_sFwImage.version & 0xFF);
   19902:	4b35      	ldr	r3, [pc, #212]	; (199d8 <am_devices_cooper_update_image+0x288>)
   19904:	68db      	ldr	r3, [r3, #12]
   19906:	0a1b      	lsrs	r3, r3, #8
                                am_util_stdio_printf("Received new BLE Controller FW version = %d.%d.%d.%d Going for upgrade\n", (g_sFwImage.version & 0xFF000000) >> 24, (g_sFwImage.version & 0xFF0000) >> 16,
   19908:	b2d8      	uxtb	r0, r3
                                                                                                                            (g_sFwImage.version & 0xFF00) >> 8, g_sFwImage.version & 0xFF);
   1990a:	4b33      	ldr	r3, [pc, #204]	; (199d8 <am_devices_cooper_update_image+0x288>)
   1990c:	68db      	ldr	r3, [r3, #12]
                                am_util_stdio_printf("Received new BLE Controller FW version = %d.%d.%d.%d Going for upgrade\n", (g_sFwImage.version & 0xFF000000) >> 24, (g_sFwImage.version & 0xFF0000) >> 16,
   1990e:	b2db      	uxtb	r3, r3
   19910:	9300      	str	r3, [sp, #0]
   19912:	4603      	mov	r3, r0
   19914:	4833      	ldr	r0, [pc, #204]	; (199e4 <am_devices_cooper_update_image+0x294>)
   19916:	f001 f943 	bl	1aba0 <am_util_stdio_printf>
                            }
                        }
                    }
                    // If we don't have any FW or any newer FW then continue with the current FW in Cooper
                    if ( ui32Ret != AM_DEVICES_COOPER_SBL_STATUS_UPDATE_FW )
   1991a:	693b      	ldr	r3, [r7, #16]
   1991c:	4a2f      	ldr	r2, [pc, #188]	; (199dc <am_devices_cooper_update_image+0x28c>)
   1991e:	4293      	cmp	r3, r2
   19920:	d076      	beq.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    {
                        // We don't have any other FW, so continue with one already there is Cooper device
                        gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_IMAGE_OK;
   19922:	4b26      	ldr	r3, [pc, #152]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19924:	2204      	movs	r2, #4
   19926:	601a      	str	r2, [r3, #0]
                        // Not done yet
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19928:	4b25      	ldr	r3, [pc, #148]	; (199c0 <am_devices_cooper_update_image+0x270>)
   1992a:	613b      	str	r3, [r7, #16]
                        am_util_stdio_printf("No new image to upgrade\n");
   1992c:	482e      	ldr	r0, [pc, #184]	; (199e8 <am_devices_cooper_update_image+0x298>)
   1992e:	f001 f937 	bl	1aba0 <am_util_stdio_printf>
                        // Send the command to continue to FW
                        send_fwContinue(gsSblUpdateState.pHandle);
   19932:	4b22      	ldr	r3, [pc, #136]	; (199bc <am_devices_cooper_update_image+0x26c>)
   19934:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19936:	4618      	mov	r0, r3
   19938:	f7ff fe54 	bl	195e4 <send_fwContinue>
                        am_util_stdio_printf("BLE Controller FW Auth Passed, Continue with FW\n");
   1993c:	482b      	ldr	r0, [pc, #172]	; (199ec <am_devices_cooper_update_image+0x29c>)
   1993e:	f001 f92f 	bl	1aba0 <am_util_stdio_printf>
   19942:	e065      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                }
                else if ( psStatusMsg->bootStatus == AM_DEVICES_COOPER_SBL_STAT_RESP_FW_UPDATE_REQ )
   19944:	68bb      	ldr	r3, [r7, #8]
   19946:	691b      	ldr	r3, [r3, #16]
   19948:	2b07      	cmp	r3, #7
   1994a:	d10f      	bne.n	1996c <am_devices_cooper_update_image+0x21c>
                {
                    am_util_stdio_printf("BLE Controller Requires FW\n");
   1994c:	4828      	ldr	r0, [pc, #160]	; (199f0 <am_devices_cooper_update_image+0x2a0>)
   1994e:	f001 f927 	bl	1aba0 <am_util_stdio_printf>
                    if (  am_devices_cooper_sbl_update_state_data(AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_FW) == true )
   19952:	2000      	movs	r0, #0
   19954:	f7ff fe66 	bl	19624 <am_devices_cooper_sbl_update_state_data>
   19958:	4603      	mov	r3, r0
   1995a:	2b00      	cmp	r3, #0
   1995c:	d002      	beq.n	19964 <am_devices_cooper_update_image+0x214>
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_FW;
   1995e:	4b1f      	ldr	r3, [pc, #124]	; (199dc <am_devices_cooper_update_image+0x28c>)
   19960:	613b      	str	r3, [r7, #16]
   19962:	e055      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                    else
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_IMAGE_FAIL;
   19964:	f04f 33a3 	mov.w	r3, #2745410467	; 0xa3a3a3a3
   19968:	613b      	str	r3, [r7, #16]
   1996a:	e051      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                }
                else if ( psStatusMsg->bootStatus == AM_DEVICES_COOPER_SBL_STAT_RESP_INFO0_UPDATE_REQ )
   1996c:	68bb      	ldr	r3, [r7, #8]
   1996e:	691b      	ldr	r3, [r3, #16]
   19970:	2b08      	cmp	r3, #8
   19972:	d10f      	bne.n	19994 <am_devices_cooper_update_image+0x244>
                {
                    am_util_stdio_printf("BLE Controller Requires INFO 0\n");
   19974:	481f      	ldr	r0, [pc, #124]	; (199f4 <am_devices_cooper_update_image+0x2a4>)
   19976:	f001 f913 	bl	1aba0 <am_util_stdio_printf>
                    if ( am_devices_cooper_sbl_update_state_data(AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_INFO_0) == true )
   1997a:	2001      	movs	r0, #1
   1997c:	f7ff fe52 	bl	19624 <am_devices_cooper_sbl_update_state_data>
   19980:	4603      	mov	r3, r0
   19982:	2b00      	cmp	r3, #0
   19984:	d002      	beq.n	1998c <am_devices_cooper_update_image+0x23c>
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_INFO_0;
   19986:	4b1c      	ldr	r3, [pc, #112]	; (199f8 <am_devices_cooper_update_image+0x2a8>)
   19988:	613b      	str	r3, [r7, #16]
   1998a:	e041      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                    else
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_IMAGE_FAIL;
   1998c:	f04f 33a3 	mov.w	r3, #2745410467	; 0xa3a3a3a3
   19990:	613b      	str	r3, [r7, #16]
   19992:	e03d      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                }
                else if ( psStatusMsg->bootStatus == AM_DEVICES_COOPER_SBL_STAT_RESP_INFO1_UPDATE_REQ )
   19994:	68bb      	ldr	r3, [r7, #8]
   19996:	691b      	ldr	r3, [r3, #16]
   19998:	2b09      	cmp	r3, #9
   1999a:	d133      	bne.n	19a04 <am_devices_cooper_update_image+0x2b4>
                {
                    am_util_stdio_printf("BLE Controller Requires INFO 1\n");
   1999c:	4817      	ldr	r0, [pc, #92]	; (199fc <am_devices_cooper_update_image+0x2ac>)
   1999e:	f001 f8ff 	bl	1aba0 <am_util_stdio_printf>
                    if ( am_devices_cooper_sbl_update_state_data(AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_INFO_1) == true )
   199a2:	2002      	movs	r0, #2
   199a4:	f7ff fe3e 	bl	19624 <am_devices_cooper_sbl_update_state_data>
   199a8:	4603      	mov	r3, r0
   199aa:	2b00      	cmp	r3, #0
   199ac:	d002      	beq.n	199b4 <am_devices_cooper_update_image+0x264>
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_INFO_1;
   199ae:	4b14      	ldr	r3, [pc, #80]	; (19a00 <am_devices_cooper_update_image+0x2b0>)
   199b0:	613b      	str	r3, [r7, #16]
   199b2:	e02d      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
                    }
                    else
                    {
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_UPDATE_IMAGE_FAIL;
   199b4:	f04f 33a3 	mov.w	r3, #2745410467	; 0xa3a3a3a3
   199b8:	613b      	str	r3, [r7, #16]
   199ba:	e029      	b.n	19a10 <am_devices_cooper_update_image+0x2c0>
   199bc:	10003868 	.word	0x10003868
   199c0:	a78bd32c 	.word	0xa78bd32c
   199c4:	00044434 	.word	0x00044434
   199c8:	0004444c 	.word	0x0004444c
   199cc:	00044464 	.word	0x00044464
   199d0:	00044480 	.word	0x00044480
   199d4:	00044494 	.word	0x00044494
   199d8:	100038a8 	.word	0x100038a8
   199dc:	4598f231 	.word	0x4598f231
   199e0:	000444ac 	.word	0x000444ac
   199e4:	000444f0 	.word	0x000444f0
   199e8:	00044538 	.word	0x00044538
   199ec:	00044554 	.word	0x00044554
   199f0:	00044588 	.word	0x00044588
   199f4:	000445a4 	.word	0x000445a4
   199f8:	8730da5b 	.word	0x8730da5b
   199fc:	000445c4 	.word	0x000445c4
   19a00:	09fa3725 	.word	0x09fa3725
                    }
                }
                else
                {
                    am_util_stdio_printf("BLE Controller Wrong Response\n");
   19a04:	4895      	ldr	r0, [pc, #596]	; (19c5c <am_devices_cooper_update_image+0x50c>)
   19a06:	f001 f8cb 	bl	1aba0 <am_util_stdio_printf>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19a0a:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19a0e:	613b      	str	r3, [r7, #16]
                }
            }
            if (  (ui32Ret == AM_DEVICES_COOPER_SBL_STATUS_OK) || (ui32Ret == AM_DEVICES_COOPER_SBL_STATUS_FAIL) ||
   19a10:	693b      	ldr	r3, [r7, #16]
   19a12:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   19a16:	f000 81c0 	beq.w	19d9a <am_devices_cooper_update_image+0x64a>
   19a1a:	693b      	ldr	r3, [r7, #16]
   19a1c:	f1b3 3fa1 	cmp.w	r3, #2711724449	; 0xa1a1a1a1
   19a20:	f000 81bb 	beq.w	19d9a <am_devices_cooper_update_image+0x64a>
                  (gsSblUpdateState.ui32SblUpdateState == AM_DEVICES_COOPER_SBL_UPDATE_STATE_IMAGE_OK) )
   19a24:	4b8e      	ldr	r3, [pc, #568]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a26:	681b      	ldr	r3, [r3, #0]
            if (  (ui32Ret == AM_DEVICES_COOPER_SBL_STATUS_OK) || (ui32Ret == AM_DEVICES_COOPER_SBL_STATUS_FAIL) ||
   19a28:	2b04      	cmp	r3, #4
   19a2a:	f000 81b6 	beq.w	19d9a <am_devices_cooper_update_image+0x64a>
                // it indicates Cooper has available FW/Info0/Info1 signature and requests update,
                // but Apollo4 does not have such image/patch at this moment, gsSblUpdateState.ui32ImageSize should be zero.
                // Need to send_update with invalid parameter to let Cooper reply NACK and clear signature

                // Update the state machine
                gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_UPDATE;
   19a2e:	4b8c      	ldr	r3, [pc, #560]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a30:	2202      	movs	r2, #2
   19a32:	601a      	str	r2, [r3, #0]
                // Send the update message
                send_update(gsSblUpdateState.pHandle, gsSblUpdateState.ui32ImageSize);
   19a34:	4b8a      	ldr	r3, [pc, #552]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19a38:	4a89      	ldr	r2, [pc, #548]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a3a:	6892      	ldr	r2, [r2, #8]
   19a3c:	4611      	mov	r1, r2
   19a3e:	4618      	mov	r0, r3
   19a40:	f7ff fd52 	bl	194e8 <send_update>
                ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19a44:	4b87      	ldr	r3, [pc, #540]	; (19c64 <am_devices_cooper_update_image+0x514>)
   19a46:	613b      	str	r3, [r7, #16]
            }
            break;
   19a48:	e1a7      	b.n	19d9a <am_devices_cooper_update_image+0x64a>
        case AM_DEVICES_COOPER_SBL_UPDATE_STATE_UPDATE:
            // Read the "ACK/NACK" response from the IOS and check for CRC Error
            if ( iom_slave_read(gsSblUpdateState.pHandle, (uint32_t*)gsSblUpdateState.pWorkBuf, &ui32Size) == false )
   19a4a:	4b85      	ldr	r3, [pc, #532]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19a4e:	4a84      	ldr	r2, [pc, #528]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a50:	6a91      	ldr	r1, [r2, #40]	; 0x28
   19a52:	1d3a      	adds	r2, r7, #4
   19a54:	4618      	mov	r0, r3
   19a56:	f7ff fd03 	bl	19460 <iom_slave_read>
   19a5a:	4603      	mov	r3, r0
   19a5c:	f083 0301 	eor.w	r3, r3, #1
   19a60:	b2db      	uxtb	r3, r3
   19a62:	2b00      	cmp	r3, #0
   19a64:	d017      	beq.n	19a96 <am_devices_cooper_update_image+0x346>
            {
                // Increment the Error Counter
                gsSblUpdateState.ui32ErrorCounter++;
   19a66:	4b7e      	ldr	r3, [pc, #504]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a68:	6a1b      	ldr	r3, [r3, #32]
   19a6a:	3301      	adds	r3, #1
   19a6c:	4a7c      	ldr	r2, [pc, #496]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a6e:	6213      	str	r3, [r2, #32]
                // Check if the Error has happened more than the limit
                if ( gsSblUpdateState.ui32ErrorCounter > AM_DEVICES_COOPER_SBL_MAX_COMM_ERR_COUNT )
   19a70:	4b7b      	ldr	r3, [pc, #492]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a72:	6a1b      	ldr	r3, [r3, #32]
   19a74:	2b03      	cmp	r3, #3
   19a76:	d903      	bls.n	19a80 <am_devices_cooper_update_image+0x330>
                {
                    // Return fail
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19a78:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19a7c:	613b      	str	r3, [r7, #16]
                {
                    am_util_stdio_printf("Update Failed !!!\n");
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
                }
            }
            break;
   19a7e:	e18d      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
                    send_update(gsSblUpdateState.pHandle, gsSblUpdateState.ui32ImageSize);
   19a80:	4b77      	ldr	r3, [pc, #476]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19a84:	4a76      	ldr	r2, [pc, #472]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a86:	6892      	ldr	r2, [r2, #8]
   19a88:	4611      	mov	r1, r2
   19a8a:	4618      	mov	r0, r3
   19a8c:	f7ff fd2c 	bl	194e8 <send_update>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19a90:	4b74      	ldr	r3, [pc, #464]	; (19c64 <am_devices_cooper_update_image+0x514>)
   19a92:	613b      	str	r3, [r7, #16]
            break;
   19a94:	e182      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
                if ( gsSblUpdateState.ui32ErrorCounter )
   19a96:	4b72      	ldr	r3, [pc, #456]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19a98:	6a1b      	ldr	r3, [r3, #32]
   19a9a:	2b00      	cmp	r3, #0
   19a9c:	d002      	beq.n	19aa4 <am_devices_cooper_update_image+0x354>
                    gsSblUpdateState.ui32ErrorCounter = 0;
   19a9e:	4b70      	ldr	r3, [pc, #448]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19aa0:	2200      	movs	r2, #0
   19aa2:	621a      	str	r2, [r3, #32]
                psAckMsg = (am_sbl_host_msg_ack_nack_t*)(gsSblUpdateState.pWorkBuf);
   19aa4:	4b6e      	ldr	r3, [pc, #440]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19aa6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19aa8:	60fb      	str	r3, [r7, #12]
                if ( (psAckMsg->msgHdr.msgType == AM_SBL_HOST_MSG_ACK) && (NULL != gsSblUpdateState.pImageBuf))
   19aaa:	68fb      	ldr	r3, [r7, #12]
   19aac:	889b      	ldrh	r3, [r3, #4]
   19aae:	2b07      	cmp	r3, #7
   19ab0:	d11a      	bne.n	19ae8 <am_devices_cooper_update_image+0x398>
   19ab2:	4b6b      	ldr	r3, [pc, #428]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ab4:	685b      	ldr	r3, [r3, #4]
   19ab6:	2b00      	cmp	r3, #0
   19ab8:	d016      	beq.n	19ae8 <am_devices_cooper_update_image+0x398>
                    gsSblUpdateState.ui32CooperSblStatus = psAckMsg->status;
   19aba:	68fb      	ldr	r3, [r7, #12]
   19abc:	68db      	ldr	r3, [r3, #12]
   19abe:	4a68      	ldr	r2, [pc, #416]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ac0:	6313      	str	r3, [r2, #48]	; 0x30
                    gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_DATA;
   19ac2:	4b67      	ldr	r3, [pc, #412]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ac4:	2203      	movs	r2, #3
   19ac6:	601a      	str	r2, [r3, #0]
                    send_data(gsSblUpdateState.pHandle, (uint32_t)gsSblUpdateState.pImageBuf,
   19ac8:	4b65      	ldr	r3, [pc, #404]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19aca:	6a58      	ldr	r0, [r3, #36]	; 0x24
   19acc:	4b64      	ldr	r3, [pc, #400]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ace:	685b      	ldr	r3, [r3, #4]
   19ad0:	4619      	mov	r1, r3
   19ad2:	4b63      	ldr	r3, [pc, #396]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ad4:	695b      	ldr	r3, [r3, #20]
   19ad6:	2240      	movs	r2, #64	; 0x40
   19ad8:	f7ff fd4e 	bl	19578 <send_data>
                    am_util_stdio_printf("BLE controller upgrade in progress, wait...\n");
   19adc:	4862      	ldr	r0, [pc, #392]	; (19c68 <am_devices_cooper_update_image+0x518>)
   19ade:	f001 f85f 	bl	1aba0 <am_util_stdio_printf>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19ae2:	4b60      	ldr	r3, [pc, #384]	; (19c64 <am_devices_cooper_update_image+0x514>)
   19ae4:	613b      	str	r3, [r7, #16]
   19ae6:	e037      	b.n	19b58 <am_devices_cooper_update_image+0x408>
                else if ( (psAckMsg->msgHdr.msgType == AM_SBL_HOST_MSG_NACK) && (psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_INVALID_PARAM) )
   19ae8:	68fb      	ldr	r3, [r7, #12]
   19aea:	889b      	ldrh	r3, [r3, #4]
   19aec:	2b05      	cmp	r3, #5
   19aee:	d12c      	bne.n	19b4a <am_devices_cooper_update_image+0x3fa>
   19af0:	68fb      	ldr	r3, [r7, #12]
   19af2:	68db      	ldr	r3, [r3, #12]
   19af4:	2b09      	cmp	r3, #9
   19af6:	d128      	bne.n	19b4a <am_devices_cooper_update_image+0x3fa>
                    am_util_stdio_printf("Clear Cooper Signature, reset Cooper and talk with SBL again\n");
   19af8:	485c      	ldr	r0, [pc, #368]	; (19c6c <am_devices_cooper_update_image+0x51c>)
   19afa:	f001 f851 	bl	1aba0 <am_util_stdio_printf>
                    am_util_delay_ms(1200);
   19afe:	f44f 6096 	mov.w	r0, #1200	; 0x4b0
   19b02:	f000 f988 	bl	19e16 <am_util_delay_ms>
                    am_devices_cooper_reset();
   19b06:	f7ff fa73 	bl	18ff0 <am_devices_cooper_reset>
                    gsSblUpdateState.pImageBuf        = NULL;
   19b0a:	4b55      	ldr	r3, [pc, #340]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b0c:	2200      	movs	r2, #0
   19b0e:	605a      	str	r2, [r3, #4]
                    gsSblUpdateState.ui32ImageSize    = 0;
   19b10:	4b53      	ldr	r3, [pc, #332]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b12:	2200      	movs	r2, #0
   19b14:	609a      	str	r2, [r3, #8]
                    gsSblUpdateState.ui32ImageType    = AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_NONE;
   19b16:	4b52      	ldr	r3, [pc, #328]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b18:	2203      	movs	r2, #3
   19b1a:	61da      	str	r2, [r3, #28]
                    gsSblUpdateState.ui32DataSize     = 0;
   19b1c:	4b50      	ldr	r3, [pc, #320]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b1e:	2200      	movs	r2, #0
   19b20:	611a      	str	r2, [r3, #16]
                    gsSblUpdateState.pDataBuf         = NULL;
   19b22:	4b4f      	ldr	r3, [pc, #316]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b24:	2200      	movs	r2, #0
   19b26:	60da      	str	r2, [r3, #12]
                    gsSblUpdateState.ui32TotalPackets = 0;
   19b28:	4b4d      	ldr	r3, [pc, #308]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b2a:	2200      	movs	r2, #0
   19b2c:	619a      	str	r2, [r3, #24]
                    gsSblUpdateState.ui32PacketNumber = 0;
   19b2e:	4b4c      	ldr	r3, [pc, #304]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b30:	2200      	movs	r2, #0
   19b32:	615a      	str	r2, [r3, #20]
                    send_hello(gsSblUpdateState.pHandle);
   19b34:	4b4a      	ldr	r3, [pc, #296]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19b38:	4618      	mov	r0, r3
   19b3a:	f7ff fcb5 	bl	194a8 <send_hello>
                    gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_HELLO;
   19b3e:	4b48      	ldr	r3, [pc, #288]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b40:	2201      	movs	r2, #1
   19b42:	601a      	str	r2, [r3, #0]
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19b44:	4b47      	ldr	r3, [pc, #284]	; (19c64 <am_devices_cooper_update_image+0x514>)
   19b46:	613b      	str	r3, [r7, #16]
   19b48:	e006      	b.n	19b58 <am_devices_cooper_update_image+0x408>
                    am_util_stdio_printf("Update Failed !!!\n");
   19b4a:	4849      	ldr	r0, [pc, #292]	; (19c70 <am_devices_cooper_update_image+0x520>)
   19b4c:	f001 f828 	bl	1aba0 <am_util_stdio_printf>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19b50:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19b54:	613b      	str	r3, [r7, #16]
            break;
   19b56:	e121      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
   19b58:	e120      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
        case AM_DEVICES_COOPER_SBL_UPDATE_STATE_DATA:
            // Read the "ACK/NACK" response from the IOS.
            if ( iom_slave_read(gsSblUpdateState.pHandle, (uint32_t*)gsSblUpdateState.pWorkBuf, &ui32Size) == false )
   19b5a:	4b41      	ldr	r3, [pc, #260]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b5c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19b5e:	4a40      	ldr	r2, [pc, #256]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b60:	6a91      	ldr	r1, [r2, #40]	; 0x28
   19b62:	1d3a      	adds	r2, r7, #4
   19b64:	4618      	mov	r0, r3
   19b66:	f7ff fc7b 	bl	19460 <iom_slave_read>
   19b6a:	4603      	mov	r3, r0
   19b6c:	f083 0301 	eor.w	r3, r3, #1
   19b70:	b2db      	uxtb	r3, r3
   19b72:	2b00      	cmp	r3, #0
   19b74:	d040      	beq.n	19bf8 <am_devices_cooper_update_image+0x4a8>
            {
                // Increment the Error Counter
                gsSblUpdateState.ui32ErrorCounter++;
   19b76:	4b3a      	ldr	r3, [pc, #232]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b78:	6a1b      	ldr	r3, [r3, #32]
   19b7a:	3301      	adds	r3, #1
   19b7c:	4a38      	ldr	r2, [pc, #224]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b7e:	6213      	str	r3, [r2, #32]
                // Check if the Error has happened more than the limit
                if ( gsSblUpdateState.ui32ErrorCounter > AM_DEVICES_COOPER_SBL_MAX_COMM_ERR_COUNT )
   19b80:	4b37      	ldr	r3, [pc, #220]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b82:	6a1b      	ldr	r3, [r3, #32]
   19b84:	2b03      	cmp	r3, #3
   19b86:	d903      	bls.n	19b90 <am_devices_cooper_update_image+0x440>
                {
                    // Return fail
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19b88:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19b8c:	613b      	str	r3, [r7, #16]
                {
                    // Wrong Response type
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
                }
            }
            break;
   19b8e:	e105      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
                    if ( gsSblUpdateState.ui32PacketNumber == 0 )
   19b90:	4b33      	ldr	r3, [pc, #204]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b92:	695b      	ldr	r3, [r3, #20]
   19b94:	2b00      	cmp	r3, #0
   19b96:	d10a      	bne.n	19bae <am_devices_cooper_update_image+0x45e>
                        send_data(gsSblUpdateState.pHandle, (uint32_t)gsSblUpdateState.pImageBuf,
   19b98:	4b31      	ldr	r3, [pc, #196]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b9a:	6a58      	ldr	r0, [r3, #36]	; 0x24
   19b9c:	4b30      	ldr	r3, [pc, #192]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19b9e:	685b      	ldr	r3, [r3, #4]
   19ba0:	4619      	mov	r1, r3
   19ba2:	4b2f      	ldr	r3, [pc, #188]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19ba4:	695b      	ldr	r3, [r3, #20]
   19ba6:	2240      	movs	r2, #64	; 0x40
   19ba8:	f7ff fce6 	bl	19578 <send_data>
   19bac:	e021      	b.n	19bf2 <am_devices_cooper_update_image+0x4a2>
                        if (  (gsSblUpdateState.ui32TotalPackets + 1) == 1 )
   19bae:	4b2c      	ldr	r3, [pc, #176]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bb0:	699b      	ldr	r3, [r3, #24]
   19bb2:	2b00      	cmp	r3, #0
   19bb4:	d10b      	bne.n	19bce <am_devices_cooper_update_image+0x47e>
                            ui32dataPktSize = gsSblUpdateState.ui32DataSize % AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19bb6:	4b2a      	ldr	r3, [pc, #168]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bb8:	691b      	ldr	r3, [r3, #16]
   19bba:	f3c3 0308 	ubfx	r3, r3, #0, #9
   19bbe:	617b      	str	r3, [r7, #20]
                            if (ui32dataPktSize == 0)
   19bc0:	697b      	ldr	r3, [r7, #20]
   19bc2:	2b00      	cmp	r3, #0
   19bc4:	d106      	bne.n	19bd4 <am_devices_cooper_update_image+0x484>
                                ui32dataPktSize = AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19bc6:	f44f 7300 	mov.w	r3, #512	; 0x200
   19bca:	617b      	str	r3, [r7, #20]
   19bcc:	e002      	b.n	19bd4 <am_devices_cooper_update_image+0x484>
                            ui32dataPktSize = AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19bce:	f44f 7300 	mov.w	r3, #512	; 0x200
   19bd2:	617b      	str	r3, [r7, #20]
                        send_data(gsSblUpdateState.pHandle, (uint32_t) gsSblUpdateState.pDataBuf + ( (gsSblUpdateState.ui32PacketNumber - 1) * AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE),
   19bd4:	4b22      	ldr	r3, [pc, #136]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bd6:	6a58      	ldr	r0, [r3, #36]	; 0x24
   19bd8:	4b21      	ldr	r3, [pc, #132]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bda:	68db      	ldr	r3, [r3, #12]
   19bdc:	461a      	mov	r2, r3
   19bde:	4b20      	ldr	r3, [pc, #128]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19be0:	695b      	ldr	r3, [r3, #20]
   19be2:	3b01      	subs	r3, #1
   19be4:	025b      	lsls	r3, r3, #9
   19be6:	18d1      	adds	r1, r2, r3
   19be8:	4b1d      	ldr	r3, [pc, #116]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bea:	695b      	ldr	r3, [r3, #20]
   19bec:	697a      	ldr	r2, [r7, #20]
   19bee:	f7ff fcc3 	bl	19578 <send_data>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19bf2:	4b1c      	ldr	r3, [pc, #112]	; (19c64 <am_devices_cooper_update_image+0x514>)
   19bf4:	613b      	str	r3, [r7, #16]
            break;
   19bf6:	e0d1      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
                if ( gsSblUpdateState.ui32ErrorCounter )
   19bf8:	4b19      	ldr	r3, [pc, #100]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19bfa:	6a1b      	ldr	r3, [r3, #32]
   19bfc:	2b00      	cmp	r3, #0
   19bfe:	d002      	beq.n	19c06 <am_devices_cooper_update_image+0x4b6>
                    gsSblUpdateState.ui32ErrorCounter = 0;
   19c00:	4b17      	ldr	r3, [pc, #92]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c02:	2200      	movs	r2, #0
   19c04:	621a      	str	r2, [r3, #32]
                psAckMsg = (am_sbl_host_msg_ack_nack_t*)(gsSblUpdateState.pWorkBuf);
   19c06:	4b16      	ldr	r3, [pc, #88]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c08:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19c0a:	60fb      	str	r3, [r7, #12]
                gsSblUpdateState.ui32CooperSblStatus = psAckMsg->status;
   19c0c:	68fb      	ldr	r3, [r7, #12]
   19c0e:	68db      	ldr	r3, [r3, #12]
   19c10:	4a13      	ldr	r2, [pc, #76]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c12:	6313      	str	r3, [r2, #48]	; 0x30
                if (  (psAckMsg->srcMsgType == AM_SBL_HOST_MSG_DATA ) || (psAckMsg->srcMsgType == AM_SBL_HOST_MSG_UPDATE_STATUS) )
   19c14:	68fb      	ldr	r3, [r7, #12]
   19c16:	689b      	ldr	r3, [r3, #8]
   19c18:	2b08      	cmp	r3, #8
   19c1a:	d003      	beq.n	19c24 <am_devices_cooper_update_image+0x4d4>
   19c1c:	68fb      	ldr	r3, [r7, #12]
   19c1e:	689b      	ldr	r3, [r3, #8]
   19c20:	2b02      	cmp	r3, #2
   19c22:	d176      	bne.n	19d12 <am_devices_cooper_update_image+0x5c2>
                    if (  (psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SUCCESS) || (psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SEQ) )
   19c24:	68fb      	ldr	r3, [r7, #12]
   19c26:	68db      	ldr	r3, [r3, #12]
   19c28:	2b00      	cmp	r3, #0
   19c2a:	d003      	beq.n	19c34 <am_devices_cooper_update_image+0x4e4>
   19c2c:	68fb      	ldr	r3, [r7, #12]
   19c2e:	68db      	ldr	r3, [r3, #12]
   19c30:	2b0b      	cmp	r3, #11
   19c32:	d163      	bne.n	19cfc <am_devices_cooper_update_image+0x5ac>
                        if ( gsSblUpdateState.ui32TotalPackets > 0 )
   19c34:	4b0a      	ldr	r3, [pc, #40]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c36:	699b      	ldr	r3, [r3, #24]
   19c38:	2b00      	cmp	r3, #0
   19c3a:	d03a      	beq.n	19cb2 <am_devices_cooper_update_image+0x562>
                            if ( gsSblUpdateState.ui32TotalPackets == 1 )
   19c3c:	4b08      	ldr	r3, [pc, #32]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c3e:	699b      	ldr	r3, [r3, #24]
   19c40:	2b01      	cmp	r3, #1
   19c42:	d117      	bne.n	19c74 <am_devices_cooper_update_image+0x524>
                                ui32dataPktSize = gsSblUpdateState.ui32DataSize % AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19c44:	4b06      	ldr	r3, [pc, #24]	; (19c60 <am_devices_cooper_update_image+0x510>)
   19c46:	691b      	ldr	r3, [r3, #16]
   19c48:	f3c3 0308 	ubfx	r3, r3, #0, #9
   19c4c:	617b      	str	r3, [r7, #20]
                                if (ui32dataPktSize == 0)
   19c4e:	697b      	ldr	r3, [r7, #20]
   19c50:	2b00      	cmp	r3, #0
   19c52:	d112      	bne.n	19c7a <am_devices_cooper_update_image+0x52a>
                                    ui32dataPktSize = AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19c54:	f44f 7300 	mov.w	r3, #512	; 0x200
   19c58:	617b      	str	r3, [r7, #20]
   19c5a:	e00e      	b.n	19c7a <am_devices_cooper_update_image+0x52a>
   19c5c:	000445e4 	.word	0x000445e4
   19c60:	10003868 	.word	0x10003868
   19c64:	a78bd32c 	.word	0xa78bd32c
   19c68:	00044604 	.word	0x00044604
   19c6c:	00044634 	.word	0x00044634
   19c70:	00044674 	.word	0x00044674
                                ui32dataPktSize = AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE;
   19c74:	f44f 7300 	mov.w	r3, #512	; 0x200
   19c78:	617b      	str	r3, [r7, #20]
                            send_data(gsSblUpdateState.pHandle, (uint32_t) gsSblUpdateState.pDataBuf + (gsSblUpdateState.ui32PacketNumber * AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE),
   19c7a:	4b4b      	ldr	r3, [pc, #300]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19c7c:	6a58      	ldr	r0, [r3, #36]	; 0x24
   19c7e:	4b4a      	ldr	r3, [pc, #296]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19c80:	68db      	ldr	r3, [r3, #12]
   19c82:	461a      	mov	r2, r3
   19c84:	4b48      	ldr	r3, [pc, #288]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19c86:	695b      	ldr	r3, [r3, #20]
   19c88:	025b      	lsls	r3, r3, #9
   19c8a:	18d1      	adds	r1, r2, r3
                                      ui32dataPktSize, gsSblUpdateState.ui32PacketNumber + 1);
   19c8c:	4b46      	ldr	r3, [pc, #280]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19c8e:	695b      	ldr	r3, [r3, #20]
                            send_data(gsSblUpdateState.pHandle, (uint32_t) gsSblUpdateState.pDataBuf + (gsSblUpdateState.ui32PacketNumber * AM_DEVICES_COOPER_SBL_UPADTE_MAX_SPI_PKT_SIZE),
   19c90:	3301      	adds	r3, #1
   19c92:	697a      	ldr	r2, [r7, #20]
   19c94:	f7ff fc70 	bl	19578 <send_data>
                            gsSblUpdateState.ui32TotalPackets--;
   19c98:	4b43      	ldr	r3, [pc, #268]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19c9a:	699b      	ldr	r3, [r3, #24]
   19c9c:	3b01      	subs	r3, #1
   19c9e:	4a42      	ldr	r2, [pc, #264]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19ca0:	6193      	str	r3, [r2, #24]
                            gsSblUpdateState.ui32PacketNumber++;
   19ca2:	4b41      	ldr	r3, [pc, #260]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19ca4:	695b      	ldr	r3, [r3, #20]
   19ca6:	3301      	adds	r3, #1
   19ca8:	4a3f      	ldr	r2, [pc, #252]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19caa:	6153      	str	r3, [r2, #20]
                            ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19cac:	4b3f      	ldr	r3, [pc, #252]	; (19dac <am_devices_cooper_update_image+0x65c>)
   19cae:	613b      	str	r3, [r7, #16]
                        if ( gsSblUpdateState.ui32TotalPackets > 0 )
   19cb0:	e02e      	b.n	19d10 <am_devices_cooper_update_image+0x5c0>
                            if ( psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SUCCESS )
   19cb2:	68fb      	ldr	r3, [r7, #12]
   19cb4:	68db      	ldr	r3, [r3, #12]
   19cb6:	2b00      	cmp	r3, #0
   19cb8:	d116      	bne.n	19ce8 <am_devices_cooper_update_image+0x598>
                                if ( gsSblUpdateState.ui32ImageType == AM_DEVICES_COOPER_SBL_UPDATE_IMAGE_TYPE_FW )
   19cba:	4b3b      	ldr	r3, [pc, #236]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19cbc:	69db      	ldr	r3, [r3, #28]
   19cbe:	2b00      	cmp	r3, #0
   19cc0:	d10e      	bne.n	19ce0 <am_devices_cooper_update_image+0x590>
                                    gsSblUpdateState.ui32SblUpdateState = AM_DEVICES_COOPER_SBL_UPDATE_STATE_IMAGE_OK;
   19cc2:	4b39      	ldr	r3, [pc, #228]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19cc4:	2204      	movs	r2, #4
   19cc6:	601a      	str	r2, [r3, #0]
                                    gsSblUpdateState.ui32CooperFWImageVersion = g_sFwImage.version;
   19cc8:	4b39      	ldr	r3, [pc, #228]	; (19db0 <am_devices_cooper_update_image+0x660>)
   19cca:	68db      	ldr	r3, [r3, #12]
   19ccc:	4a36      	ldr	r2, [pc, #216]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19cce:	62d3      	str	r3, [r2, #44]	; 0x2c
                                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19cd0:	4b36      	ldr	r3, [pc, #216]	; (19dac <am_devices_cooper_update_image+0x65c>)
   19cd2:	613b      	str	r3, [r7, #16]
                                    send_fwContinue(gsSblUpdateState.pHandle);
   19cd4:	4b34      	ldr	r3, [pc, #208]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19cd6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19cd8:	4618      	mov	r0, r3
   19cda:	f7ff fc83 	bl	195e4 <send_fwContinue>
                        if ( gsSblUpdateState.ui32TotalPackets > 0 )
   19cde:	e017      	b.n	19d10 <am_devices_cooper_update_image+0x5c0>
                                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_OK;
   19ce0:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
   19ce4:	613b      	str	r3, [r7, #16]
                        if ( gsSblUpdateState.ui32TotalPackets > 0 )
   19ce6:	e013      	b.n	19d10 <am_devices_cooper_update_image+0x5c0>
                                am_util_stdio_printf("Update fails status = 0x%x\n", psAckMsg->status);
   19ce8:	68fb      	ldr	r3, [r7, #12]
   19cea:	68db      	ldr	r3, [r3, #12]
   19cec:	4619      	mov	r1, r3
   19cee:	4831      	ldr	r0, [pc, #196]	; (19db4 <am_devices_cooper_update_image+0x664>)
   19cf0:	f000 ff56 	bl	1aba0 <am_util_stdio_printf>
                                ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19cf4:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19cf8:	613b      	str	r3, [r7, #16]
                        if ( gsSblUpdateState.ui32TotalPackets > 0 )
   19cfa:	e009      	b.n	19d10 <am_devices_cooper_update_image+0x5c0>
                        am_util_stdio_printf("Update fails status = 0x%x\n", psAckMsg->status);
   19cfc:	68fb      	ldr	r3, [r7, #12]
   19cfe:	68db      	ldr	r3, [r3, #12]
   19d00:	4619      	mov	r1, r3
   19d02:	482c      	ldr	r0, [pc, #176]	; (19db4 <am_devices_cooper_update_image+0x664>)
   19d04:	f000 ff4c 	bl	1aba0 <am_util_stdio_printf>
                        ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19d08:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19d0c:	613b      	str	r3, [r7, #16]
                    if (  (psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SUCCESS) || (psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SEQ) )
   19d0e:	e004      	b.n	19d1a <am_devices_cooper_update_image+0x5ca>
   19d10:	e003      	b.n	19d1a <am_devices_cooper_update_image+0x5ca>
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19d12:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19d16:	613b      	str	r3, [r7, #16]
            break;
   19d18:	e040      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
   19d1a:	e03f      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
        case AM_DEVICES_COOPER_SBL_UPDATE_STATE_IMAGE_OK:
        {
            // Read the "ACK/NACK" response from the IOS and check for CRC Error
            if ( iom_slave_read(gsSblUpdateState.pHandle, (uint32_t*)gsSblUpdateState.pWorkBuf, &ui32Size) == false )
   19d1c:	4b22      	ldr	r3, [pc, #136]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19d20:	4a21      	ldr	r2, [pc, #132]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d22:	6a91      	ldr	r1, [r2, #40]	; 0x28
   19d24:	1d3a      	adds	r2, r7, #4
   19d26:	4618      	mov	r0, r3
   19d28:	f7ff fb9a 	bl	19460 <iom_slave_read>
   19d2c:	4603      	mov	r3, r0
   19d2e:	f083 0301 	eor.w	r3, r3, #1
   19d32:	b2db      	uxtb	r3, r3
   19d34:	2b00      	cmp	r3, #0
   19d36:	d014      	beq.n	19d62 <am_devices_cooper_update_image+0x612>
            {
                // Increment the Error Counter
                gsSblUpdateState.ui32ErrorCounter++;
   19d38:	4b1b      	ldr	r3, [pc, #108]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d3a:	6a1b      	ldr	r3, [r3, #32]
   19d3c:	3301      	adds	r3, #1
   19d3e:	4a1a      	ldr	r2, [pc, #104]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d40:	6213      	str	r3, [r2, #32]
                // Check if the Error has happened more than the limit
                if ( gsSblUpdateState.ui32ErrorCounter > AM_DEVICES_COOPER_SBL_MAX_COMM_ERR_COUNT )
   19d42:	4b19      	ldr	r3, [pc, #100]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d44:	6a1b      	ldr	r3, [r3, #32]
   19d46:	2b03      	cmp	r3, #3
   19d48:	d903      	bls.n	19d52 <am_devices_cooper_update_image+0x602>
                {
                    // Return fail
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19d4a:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19d4e:	613b      	str	r3, [r7, #16]
   19d50:	e00e      	b.n	19d70 <am_devices_cooper_update_image+0x620>
                }
                else
                {
                    // Resend the previous message
                    send_fwContinue(gsSblUpdateState.pHandle);
   19d52:	4b15      	ldr	r3, [pc, #84]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d54:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   19d56:	4618      	mov	r0, r3
   19d58:	f7ff fc44 	bl	195e4 <send_fwContinue>
                    // Tell application that we are not done with SBL
                    ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_IN_PROGRESS;
   19d5c:	4b13      	ldr	r3, [pc, #76]	; (19dac <am_devices_cooper_update_image+0x65c>)
   19d5e:	613b      	str	r3, [r7, #16]
   19d60:	e006      	b.n	19d70 <am_devices_cooper_update_image+0x620>
                }
            }
            else
            {
                // No CRC error and if there was one, then reset the error counter
                if ( gsSblUpdateState.ui32ErrorCounter )
   19d62:	4b11      	ldr	r3, [pc, #68]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d64:	6a1b      	ldr	r3, [r3, #32]
   19d66:	2b00      	cmp	r3, #0
   19d68:	d002      	beq.n	19d70 <am_devices_cooper_update_image+0x620>
                {
                    gsSblUpdateState.ui32ErrorCounter = 0;
   19d6a:	4b0f      	ldr	r3, [pc, #60]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d6c:	2200      	movs	r2, #0
   19d6e:	621a      	str	r2, [r3, #32]
                }
            }
            // Get the response status
            psAckMsg = (am_sbl_host_msg_ack_nack_t*)(gsSblUpdateState.pWorkBuf);
   19d70:	4b0d      	ldr	r3, [pc, #52]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   19d74:	60fb      	str	r3, [r7, #12]
            // Save the status
            gsSblUpdateState.ui32CooperSblStatus = psAckMsg->status;
   19d76:	68fb      	ldr	r3, [r7, #12]
   19d78:	68db      	ldr	r3, [r3, #12]
   19d7a:	4a0b      	ldr	r2, [pc, #44]	; (19da8 <am_devices_cooper_update_image+0x658>)
   19d7c:	6313      	str	r3, [r2, #48]	; 0x30
            if ( psAckMsg->status == AM_DEVICES_COOPER_SBL_ACK_RESP_SUCCESS )
   19d7e:	68fb      	ldr	r3, [r7, #12]
   19d80:	68db      	ldr	r3, [r3, #12]
   19d82:	2b00      	cmp	r3, #0
   19d84:	d103      	bne.n	19d8e <am_devices_cooper_update_image+0x63e>
            {
                // FW has gone to BLE, end the SBL driver state machine
                ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_OK;
   19d86:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
   19d8a:	613b      	str	r3, [r7, #16]
            else
            {
                ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
            }
        }
        break;
   19d8c:	e006      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
                ui32Ret = AM_DEVICES_COOPER_SBL_STATUS_FAIL;
   19d8e:	f04f 33a1 	mov.w	r3, #2711724449	; 0xa1a1a1a1
   19d92:	613b      	str	r3, [r7, #16]
        break;
   19d94:	e002      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
        default:
            // Bad state, update the state machine
            break;
   19d96:	bf00      	nop
   19d98:	e000      	b.n	19d9c <am_devices_cooper_update_image+0x64c>
            break;
   19d9a:	bf00      	nop
    }
    return ui32Ret;
   19d9c:	693b      	ldr	r3, [r7, #16]
}
   19d9e:	4618      	mov	r0, r3
   19da0:	3718      	adds	r7, #24
   19da2:	46bd      	mov	sp, r7
   19da4:	bd80      	pop	{r7, pc}
   19da6:	bf00      	nop
   19da8:	10003868 	.word	0x10003868
   19dac:	a78bd32c 	.word	0xa78bd32c
   19db0:	100038a8 	.word	0x100038a8
   19db4:	00044688 	.word	0x00044688

00019db8 <am_util_ble_tx_power_set>:
// ui32TxPower: enum txPowerLevel_t defined in hci_drv_cooper.h
//
//*****************************************************************************
uint32_t
am_util_ble_tx_power_set(void* pHandle, uint8_t ui32TxPower)
{
   19db8:	b580      	push	{r7, lr}
   19dba:	b08c      	sub	sp, #48	; 0x30
   19dbc:	af02      	add	r7, sp, #8
   19dbe:	6078      	str	r0, [r7, #4]
   19dc0:	460b      	mov	r3, r1
   19dc2:	70fb      	strb	r3, [r7, #3]
    //
    // Fill the buffer with the specific command we want to write, and send it.
    //
    uint8_t write_cmd[HCI_VSC_CMD_LENGTH(HCI_VSC_SET_TX_POWER_LEVEL_CFG_CMD_LENGTH)] = HCI_VSC_CMD(HCI_VSC_SET_TX_POWER_LEVEL_CFG, ui32TxPower);
   19dc4:	2301      	movs	r3, #1
   19dc6:	f887 3020 	strb.w	r3, [r7, #32]
   19dca:	2370      	movs	r3, #112	; 0x70
   19dcc:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
   19dd0:	23fc      	movs	r3, #252	; 0xfc
   19dd2:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   19dd6:	2301      	movs	r3, #1
   19dd8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   19ddc:	78fb      	ldrb	r3, [r7, #3]
   19dde:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24

    //
    // Make a buffer big enough to hold the register write command, and a
    // second one big enough to hold the response.
    //
    uint32_t ui32BytesNum = 0;
   19de2:	2300      	movs	r3, #0
   19de4:	61fb      	str	r3, [r7, #28]
    am_devices_cooper_buffer(16) sResponse = {0};
   19de6:	f107 030c 	add.w	r3, r7, #12
   19dea:	2200      	movs	r2, #0
   19dec:	601a      	str	r2, [r3, #0]
   19dee:	605a      	str	r2, [r3, #4]
   19df0:	609a      	str	r2, [r3, #8]
   19df2:	60da      	str	r2, [r3, #12]
    return (am_devices_cooper_command_write(pHandle, (uint32_t*)write_cmd, sizeof(write_cmd), sResponse.words, &ui32BytesNum));
   19df4:	f107 020c 	add.w	r2, r7, #12
   19df8:	f107 0120 	add.w	r1, r7, #32
   19dfc:	f107 031c 	add.w	r3, r7, #28
   19e00:	9300      	str	r3, [sp, #0]
   19e02:	4613      	mov	r3, r2
   19e04:	2205      	movs	r2, #5
   19e06:	6878      	ldr	r0, [r7, #4]
   19e08:	f7ff fabe 	bl	19388 <am_devices_cooper_command_write>
   19e0c:	4603      	mov	r3, r0
}
   19e0e:	4618      	mov	r0, r3
   19e10:	3728      	adds	r7, #40	; 0x28
   19e12:	46bd      	mov	sp, r7
   19e14:	bd80      	pop	{r7, pc}

00019e16 <am_util_delay_ms>:
// Delays for a desired amount of milliseconds.
//
//*****************************************************************************
void
am_util_delay_ms(uint32_t ui32MilliSeconds)
{
   19e16:	b580      	push	{r7, lr}
   19e18:	b082      	sub	sp, #8
   19e1a:	af00      	add	r7, sp, #0
   19e1c:	6078      	str	r0, [r7, #4]
#if defined(AM_PART_APOLLO4_API)
    am_hal_delay_us( ui32MilliSeconds * 1000);
   19e1e:	687b      	ldr	r3, [r7, #4]
   19e20:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   19e24:	fb02 f303 	mul.w	r3, r2, r3
   19e28:	4618      	mov	r0, r3
   19e2a:	f01b fa4d 	bl	352c8 <am_hal_delay_us>
    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
#endif // AM_PART_APOLLO4_API
}
   19e2e:	bf00      	nop
   19e30:	3708      	adds	r7, #8
   19e32:	46bd      	mov	sp, r7
   19e34:	bd80      	pop	{r7, pc}

00019e36 <am_util_delay_us>:
// Delays for a desired amount of microseconds.
//
//*****************************************************************************
void
am_util_delay_us(uint32_t ui32MicroSeconds)
{
   19e36:	b580      	push	{r7, lr}
   19e38:	b082      	sub	sp, #8
   19e3a:	af00      	add	r7, sp, #0
   19e3c:	6078      	str	r0, [r7, #4]
#if defined(AM_PART_APOLLO4_API)
    am_hal_delay_us( ui32MicroSeconds );
   19e3e:	6878      	ldr	r0, [r7, #4]
   19e40:	f01b fa42 	bl	352c8 <am_hal_delay_us>
    //
    // Call the BOOTROM cycle delay function
    //
    am_hal_flash_delay(ui32Loops);
#endif // AM_PART_APOLLO4_API
}
   19e44:	bf00      	nop
   19e46:	3708      	adds	r7, #8
   19e48:	46bd      	mov	sp, r7
   19e4a:	bd80      	pop	{r7, pc}

00019e4c <am_util_stdio_printf_init>:
// Sets the interface for printf calls.
//
//*****************************************************************************
void
am_util_stdio_printf_init(am_util_stdio_print_char_t pfnCharPrint)
{
   19e4c:	b480      	push	{r7}
   19e4e:	b083      	sub	sp, #12
   19e50:	af00      	add	r7, sp, #0
   19e52:	6078      	str	r0, [r7, #4]
    g_pfnCharPrint = pfnCharPrint;
   19e54:	4a04      	ldr	r2, [pc, #16]	; (19e68 <am_util_stdio_printf_init+0x1c>)
   19e56:	687b      	ldr	r3, [r7, #4]
   19e58:	6013      	str	r3, [r2, #0]
}
   19e5a:	bf00      	nop
   19e5c:	370c      	adds	r7, #12
   19e5e:	46bd      	mov	sp, r7
   19e60:	f85d 7b04 	ldr.w	r7, [sp], #4
   19e64:	4770      	bx	lr
   19e66:	bf00      	nop
   19e68:	10010e90 	.word	0x10010e90

00019e6c <divu64_10>:
//  Note: Adapted from Ch10 of Hackers Delight (hackersdelight.org).
//
//*****************************************************************************
static uint64_t
divu64_10(uint64_t ui64Val)
{
   19e6c:	e92d 0fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp}
   19e70:	b099      	sub	sp, #100	; 0x64
   19e72:	af00      	add	r7, sp, #0
   19e74:	e9c7 010e 	strd	r0, r1, [r7, #56]	; 0x38
    uint32_t q32, r32, ui32Val;

    //
    // If a 32-bit value, use the more optimal 32-bit routine.
    //
    if ( ui64Val >> 32 )
   19e78:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
   19e7c:	f04f 0000 	mov.w	r0, #0
   19e80:	f04f 0100 	mov.w	r1, #0
   19e84:	0018      	movs	r0, r3
   19e86:	2100      	movs	r1, #0
   19e88:	ea50 0301 	orrs.w	r3, r0, r1
   19e8c:	f000 80b0 	beq.w	19ff0 <divu64_10+0x184>
    {
        q64 = (ui64Val>>1) + (ui64Val>>2);
   19e90:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
   19e94:	f04f 0400 	mov.w	r4, #0
   19e98:	f04f 0500 	mov.w	r5, #0
   19e9c:	0854      	lsrs	r4, r2, #1
   19e9e:	ea44 74c3 	orr.w	r4, r4, r3, lsl #31
   19ea2:	085d      	lsrs	r5, r3, #1
   19ea4:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
   19ea8:	f04f 0000 	mov.w	r0, #0
   19eac:	f04f 0100 	mov.w	r1, #0
   19eb0:	0890      	lsrs	r0, r2, #2
   19eb2:	ea40 7083 	orr.w	r0, r0, r3, lsl #30
   19eb6:	0899      	lsrs	r1, r3, #2
   19eb8:	eb14 0a00 	adds.w	sl, r4, r0
   19ebc:	eb45 0b01 	adc.w	fp, r5, r1
   19ec0:	e9c7 ab12 	strd	sl, fp, [r7, #72]	; 0x48
        q64 += (q64 >> 4);
   19ec4:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19ec8:	f04f 0000 	mov.w	r0, #0
   19ecc:	f04f 0100 	mov.w	r1, #0
   19ed0:	0910      	lsrs	r0, r2, #4
   19ed2:	ea40 7003 	orr.w	r0, r0, r3, lsl #28
   19ed6:	0919      	lsrs	r1, r3, #4
   19ed8:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19edc:	1814      	adds	r4, r2, r0
   19ede:	62bc      	str	r4, [r7, #40]	; 0x28
   19ee0:	414b      	adcs	r3, r1
   19ee2:	62fb      	str	r3, [r7, #44]	; 0x2c
   19ee4:	e9d7 340a 	ldrd	r3, r4, [r7, #40]	; 0x28
   19ee8:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        q64 += (q64 >> 8);
   19eec:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19ef0:	f04f 0000 	mov.w	r0, #0
   19ef4:	f04f 0100 	mov.w	r1, #0
   19ef8:	0a10      	lsrs	r0, r2, #8
   19efa:	ea40 6003 	orr.w	r0, r0, r3, lsl #24
   19efe:	0a19      	lsrs	r1, r3, #8
   19f00:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19f04:	1814      	adds	r4, r2, r0
   19f06:	623c      	str	r4, [r7, #32]
   19f08:	414b      	adcs	r3, r1
   19f0a:	627b      	str	r3, [r7, #36]	; 0x24
   19f0c:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
   19f10:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        q64 += (q64 >> 16);
   19f14:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19f18:	f04f 0000 	mov.w	r0, #0
   19f1c:	f04f 0100 	mov.w	r1, #0
   19f20:	0c10      	lsrs	r0, r2, #16
   19f22:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
   19f26:	0c19      	lsrs	r1, r3, #16
   19f28:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   19f2c:	1814      	adds	r4, r2, r0
   19f2e:	61bc      	str	r4, [r7, #24]
   19f30:	414b      	adcs	r3, r1
   19f32:	61fb      	str	r3, [r7, #28]
   19f34:	e9d7 3406 	ldrd	r3, r4, [r7, #24]
   19f38:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        q64 += (q64 >> 32);
   19f3c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   19f40:	f04f 0200 	mov.w	r2, #0
   19f44:	f04f 0300 	mov.w	r3, #0
   19f48:	000a      	movs	r2, r1
   19f4a:	2300      	movs	r3, #0
   19f4c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   19f50:	1884      	adds	r4, r0, r2
   19f52:	613c      	str	r4, [r7, #16]
   19f54:	eb41 0303 	adc.w	r3, r1, r3
   19f58:	617b      	str	r3, [r7, #20]
   19f5a:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
   19f5e:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
        q64 >>= 3;
   19f62:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   19f66:	f04f 0200 	mov.w	r2, #0
   19f6a:	f04f 0300 	mov.w	r3, #0
   19f6e:	08c2      	lsrs	r2, r0, #3
   19f70:	ea42 7241 	orr.w	r2, r2, r1, lsl #29
   19f74:	08cb      	lsrs	r3, r1, #3
   19f76:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
        r64 = ui64Val - q64*10;
   19f7a:	e9d7 4512 	ldrd	r4, r5, [r7, #72]	; 0x48
   19f7e:	4622      	mov	r2, r4
   19f80:	462b      	mov	r3, r5
   19f82:	f04f 0000 	mov.w	r0, #0
   19f86:	f04f 0100 	mov.w	r1, #0
   19f8a:	0099      	lsls	r1, r3, #2
   19f8c:	ea41 7192 	orr.w	r1, r1, r2, lsr #30
   19f90:	0090      	lsls	r0, r2, #2
   19f92:	4602      	mov	r2, r0
   19f94:	460b      	mov	r3, r1
   19f96:	1912      	adds	r2, r2, r4
   19f98:	eb45 0303 	adc.w	r3, r5, r3
   19f9c:	1891      	adds	r1, r2, r2
   19f9e:	60b9      	str	r1, [r7, #8]
   19fa0:	415b      	adcs	r3, r3
   19fa2:	60fb      	str	r3, [r7, #12]
   19fa4:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   19fa8:	4610      	mov	r0, r2
   19faa:	4619      	mov	r1, r3
   19fac:	e9d7 230e 	ldrd	r2, r3, [r7, #56]	; 0x38
   19fb0:	1a14      	subs	r4, r2, r0
   19fb2:	603c      	str	r4, [r7, #0]
   19fb4:	eb63 0301 	sbc.w	r3, r3, r1
   19fb8:	607b      	str	r3, [r7, #4]
   19fba:	e9d7 3400 	ldrd	r3, r4, [r7]
   19fbe:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
        return q64 + ((r64 + 6) >> 4);
   19fc2:	e9d7 2310 	ldrd	r2, r3, [r7, #64]	; 0x40
   19fc6:	f112 0806 	adds.w	r8, r2, #6
   19fca:	f143 0900 	adc.w	r9, r3, #0
   19fce:	f04f 0200 	mov.w	r2, #0
   19fd2:	f04f 0300 	mov.w	r3, #0
   19fd6:	ea4f 1218 	mov.w	r2, r8, lsr #4
   19fda:	ea42 7209 	orr.w	r2, r2, r9, lsl #28
   19fde:	ea4f 1319 	mov.w	r3, r9, lsr #4
   19fe2:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   19fe6:	1814      	adds	r4, r2, r0
   19fe8:	633c      	str	r4, [r7, #48]	; 0x30
   19fea:	414b      	adcs	r3, r1
   19fec:	637b      	str	r3, [r7, #52]	; 0x34
   19fee:	e02c      	b.n	1a04a <divu64_10+0x1de>
    }
    else
    {
        ui32Val = (uint32_t)(ui64Val & 0xffffffff);
   19ff0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   19ff2:	65fb      	str	r3, [r7, #92]	; 0x5c
        q32 = (ui32Val>>1) + (ui32Val>>2);
   19ff4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   19ff6:	085a      	lsrs	r2, r3, #1
   19ff8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   19ffa:	089b      	lsrs	r3, r3, #2
   19ffc:	4413      	add	r3, r2
   19ffe:	65bb      	str	r3, [r7, #88]	; 0x58
        q32 += (q32 >> 4);
   1a000:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1a002:	091b      	lsrs	r3, r3, #4
   1a004:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1a006:	4413      	add	r3, r2
   1a008:	65bb      	str	r3, [r7, #88]	; 0x58
        q32 += (q32 >> 8);
   1a00a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1a00c:	0a1b      	lsrs	r3, r3, #8
   1a00e:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1a010:	4413      	add	r3, r2
   1a012:	65bb      	str	r3, [r7, #88]	; 0x58
        q32 += (q32 >> 16);
   1a014:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1a016:	0c1b      	lsrs	r3, r3, #16
   1a018:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1a01a:	4413      	add	r3, r2
   1a01c:	65bb      	str	r3, [r7, #88]	; 0x58
        q32 >>= 3;
   1a01e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1a020:	08db      	lsrs	r3, r3, #3
   1a022:	65bb      	str	r3, [r7, #88]	; 0x58
        r32 = ui32Val - q32*10;
   1a024:	6dba      	ldr	r2, [r7, #88]	; 0x58
   1a026:	4613      	mov	r3, r2
   1a028:	009b      	lsls	r3, r3, #2
   1a02a:	4413      	add	r3, r2
   1a02c:	005b      	lsls	r3, r3, #1
   1a02e:	461a      	mov	r2, r3
   1a030:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
   1a032:	1a9b      	subs	r3, r3, r2
   1a034:	657b      	str	r3, [r7, #84]	; 0x54
        return (uint64_t)(q32 + ((r32 + 6) >> 4));
   1a036:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1a038:	3306      	adds	r3, #6
   1a03a:	091a      	lsrs	r2, r3, #4
   1a03c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
   1a03e:	4413      	add	r3, r2
   1a040:	4619      	mov	r1, r3
   1a042:	f04f 0200 	mov.w	r2, #0
   1a046:	e9c7 120c 	strd	r1, r2, [r7, #48]	; 0x30
   1a04a:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
    }
}
   1a04e:	4610      	mov	r0, r2
   1a050:	4619      	mov	r1, r3
   1a052:	3764      	adds	r7, #100	; 0x64
   1a054:	46bd      	mov	sp, r7
   1a056:	e8bd 0fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp}
   1a05a:	4770      	bx	lr

0001a05c <ndigits_in_u64>:
// example: 10000 return 5, 123 returns 3.
//
//*****************************************************************************
static int
ndigits_in_u64(uint64_t ui64Val)
{
   1a05c:	b580      	push	{r7, lr}
   1a05e:	b084      	sub	sp, #16
   1a060:	af00      	add	r7, sp, #0
   1a062:	e9c7 0100 	strd	r0, r1, [r7]
    int iNDigits = ui64Val ? 0 : 1;
   1a066:	683a      	ldr	r2, [r7, #0]
   1a068:	687b      	ldr	r3, [r7, #4]
   1a06a:	4313      	orrs	r3, r2
   1a06c:	2b00      	cmp	r3, #0
   1a06e:	bf0c      	ite	eq
   1a070:	2301      	moveq	r3, #1
   1a072:	2300      	movne	r3, #0
   1a074:	b2db      	uxtb	r3, r3
   1a076:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
   1a078:	e008      	b.n	1a08c <ndigits_in_u64+0x30>
    {
        //
        // ui32Val /= 10;
        //
        ui64Val = divu64_10(ui64Val);
   1a07a:	e9d7 0100 	ldrd	r0, r1, [r7]
   1a07e:	f7ff fef5 	bl	19e6c <divu64_10>
   1a082:	e9c7 0100 	strd	r0, r1, [r7]
        ++iNDigits;
   1a086:	68fb      	ldr	r3, [r7, #12]
   1a088:	3301      	adds	r3, #1
   1a08a:	60fb      	str	r3, [r7, #12]
    while ( ui64Val )
   1a08c:	e9d7 2300 	ldrd	r2, r3, [r7]
   1a090:	4313      	orrs	r3, r2
   1a092:	d1f2      	bne.n	1a07a <ndigits_in_u64+0x1e>
    }

    return iNDigits;
   1a094:	68fb      	ldr	r3, [r7, #12]
}
   1a096:	4618      	mov	r0, r3
   1a098:	3710      	adds	r7, #16
   1a09a:	46bd      	mov	sp, r7
   1a09c:	bd80      	pop	{r7, pc}

0001a09e <ndigits_in_i64>:
// example: -3 returns 1, 3 returns 1, 15 returns 2, -15 returns 2, ...
//
//*****************************************************************************
static int
ndigits_in_i64(int64_t i64Val)
{
   1a09e:	b580      	push	{r7, lr}
   1a0a0:	b082      	sub	sp, #8
   1a0a2:	af00      	add	r7, sp, #0
   1a0a4:	e9c7 0100 	strd	r0, r1, [r7]
    if ( i64Val < 0 )
   1a0a8:	e9d7 2300 	ldrd	r2, r3, [r7]
   1a0ac:	2a00      	cmp	r2, #0
   1a0ae:	f173 0300 	sbcs.w	r3, r3, #0
   1a0b2:	da06      	bge.n	1a0c2 <ndigits_in_i64+0x24>
    {
        //
        // Get absolute value
        //
        i64Val = -i64Val;
   1a0b4:	e9d7 2300 	ldrd	r2, r3, [r7]
   1a0b8:	4252      	negs	r2, r2
   1a0ba:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1a0be:	e9c7 2300 	strd	r2, r3, [r7]
    }

    return ndigits_in_u64((uint64_t) i64Val);
   1a0c2:	e9d7 2300 	ldrd	r2, r3, [r7]
   1a0c6:	4610      	mov	r0, r2
   1a0c8:	4619      	mov	r1, r3
   1a0ca:	f7ff ffc7 	bl	1a05c <ndigits_in_u64>
   1a0ce:	4603      	mov	r3, r0
}
   1a0d0:	4618      	mov	r0, r3
   1a0d2:	3708      	adds	r7, #8
   1a0d4:	46bd      	mov	sp, r7
   1a0d6:	bd80      	pop	{r7, pc}

0001a0d8 <ndigits_in_hex>:
// Return the number of hex digits in an uint64_t.
//
//*****************************************************************************
static int
ndigits_in_hex(uint64_t ui64Val)
{
   1a0d8:	b480      	push	{r7}
   1a0da:	b085      	sub	sp, #20
   1a0dc:	af00      	add	r7, sp, #0
   1a0de:	e9c7 0100 	strd	r0, r1, [r7]
    int iDigits = ui64Val ? 0 : 1;
   1a0e2:	683a      	ldr	r2, [r7, #0]
   1a0e4:	687b      	ldr	r3, [r7, #4]
   1a0e6:	4313      	orrs	r3, r2
   1a0e8:	2b00      	cmp	r3, #0
   1a0ea:	bf0c      	ite	eq
   1a0ec:	2301      	moveq	r3, #1
   1a0ee:	2300      	movne	r3, #0
   1a0f0:	b2db      	uxtb	r3, r3
   1a0f2:	60fb      	str	r3, [r7, #12]

    while ( ui64Val )
   1a0f4:	e00e      	b.n	1a114 <ndigits_in_hex+0x3c>
    {
        ui64Val >>= 4;
   1a0f6:	e9d7 0100 	ldrd	r0, r1, [r7]
   1a0fa:	f04f 0200 	mov.w	r2, #0
   1a0fe:	f04f 0300 	mov.w	r3, #0
   1a102:	0902      	lsrs	r2, r0, #4
   1a104:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
   1a108:	090b      	lsrs	r3, r1, #4
   1a10a:	e9c7 2300 	strd	r2, r3, [r7]
        ++iDigits;
   1a10e:	68fb      	ldr	r3, [r7, #12]
   1a110:	3301      	adds	r3, #1
   1a112:	60fb      	str	r3, [r7, #12]
    while ( ui64Val )
   1a114:	e9d7 2300 	ldrd	r2, r3, [r7]
   1a118:	4313      	orrs	r3, r2
   1a11a:	d1ec      	bne.n	1a0f6 <ndigits_in_hex+0x1e>
    }

    return iDigits;
   1a11c:	68fb      	ldr	r3, [r7, #12]
}
   1a11e:	4618      	mov	r0, r3
   1a120:	3714      	adds	r7, #20
   1a122:	46bd      	mov	sp, r7
   1a124:	f85d 7b04 	ldr.w	r7, [sp], #4
   1a128:	4770      	bx	lr

0001a12a <decstr_to_int>:
// pui32CharCnt.
//
//*****************************************************************************
static uint32_t
decstr_to_int(const char *pcStr, uint32_t *pui32CharCnt)
{
   1a12a:	b480      	push	{r7}
   1a12c:	b087      	sub	sp, #28
   1a12e:	af00      	add	r7, sp, #0
   1a130:	6078      	str	r0, [r7, #4]
   1a132:	6039      	str	r1, [r7, #0]
    bool bNeg = false;
   1a134:	2300      	movs	r3, #0
   1a136:	75fb      	strb	r3, [r7, #23]
    uint32_t ui32Val = 0, uCnt = 0;
   1a138:	2300      	movs	r3, #0
   1a13a:	613b      	str	r3, [r7, #16]
   1a13c:	2300      	movs	r3, #0
   1a13e:	60fb      	str	r3, [r7, #12]

    if ( *pcStr == '-')
   1a140:	687b      	ldr	r3, [r7, #4]
   1a142:	781b      	ldrb	r3, [r3, #0]
   1a144:	2b2d      	cmp	r3, #45	; 0x2d
   1a146:	d11b      	bne.n	1a180 <decstr_to_int+0x56>
    {
        bNeg = true;
   1a148:	2301      	movs	r3, #1
   1a14a:	75fb      	strb	r3, [r7, #23]
        pcStr++;
   1a14c:	687b      	ldr	r3, [r7, #4]
   1a14e:	3301      	adds	r3, #1
   1a150:	607b      	str	r3, [r7, #4]
        uCnt++;
   1a152:	68fb      	ldr	r3, [r7, #12]
   1a154:	3301      	adds	r3, #1
   1a156:	60fb      	str	r3, [r7, #12]
    }

    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1a158:	e012      	b.n	1a180 <decstr_to_int+0x56>
    {
        ++uCnt;
   1a15a:	68fb      	ldr	r3, [r7, #12]
   1a15c:	3301      	adds	r3, #1
   1a15e:	60fb      	str	r3, [r7, #12]

        //
        // Multiply accumulated value by 10.
        //
        ui32Val *= 10;
   1a160:	693a      	ldr	r2, [r7, #16]
   1a162:	4613      	mov	r3, r2
   1a164:	009b      	lsls	r3, r3, #2
   1a166:	4413      	add	r3, r2
   1a168:	005b      	lsls	r3, r3, #1
   1a16a:	613b      	str	r3, [r7, #16]

        //
        // Add in the new low digit.
        //
        ui32Val += (*pcStr - '0');
   1a16c:	687b      	ldr	r3, [r7, #4]
   1a16e:	781b      	ldrb	r3, [r3, #0]
   1a170:	461a      	mov	r2, r3
   1a172:	693b      	ldr	r3, [r7, #16]
   1a174:	4413      	add	r3, r2
   1a176:	3b30      	subs	r3, #48	; 0x30
   1a178:	613b      	str	r3, [r7, #16]
        pcStr++;
   1a17a:	687b      	ldr	r3, [r7, #4]
   1a17c:	3301      	adds	r3, #1
   1a17e:	607b      	str	r3, [r7, #4]
    while ( *pcStr >= '0'  &&  *pcStr <= '9' )
   1a180:	687b      	ldr	r3, [r7, #4]
   1a182:	781b      	ldrb	r3, [r3, #0]
   1a184:	2b2f      	cmp	r3, #47	; 0x2f
   1a186:	d903      	bls.n	1a190 <decstr_to_int+0x66>
   1a188:	687b      	ldr	r3, [r7, #4]
   1a18a:	781b      	ldrb	r3, [r3, #0]
   1a18c:	2b39      	cmp	r3, #57	; 0x39
   1a18e:	d9e4      	bls.n	1a15a <decstr_to_int+0x30>
    }

    if ( pui32CharCnt )
   1a190:	683b      	ldr	r3, [r7, #0]
   1a192:	2b00      	cmp	r3, #0
   1a194:	d002      	beq.n	1a19c <decstr_to_int+0x72>
    {
        *pui32CharCnt = uCnt;
   1a196:	683b      	ldr	r3, [r7, #0]
   1a198:	68fa      	ldr	r2, [r7, #12]
   1a19a:	601a      	str	r2, [r3, #0]
    }

    return bNeg ? -ui32Val : ui32Val;
   1a19c:	7dfb      	ldrb	r3, [r7, #23]
   1a19e:	2b00      	cmp	r3, #0
   1a1a0:	d002      	beq.n	1a1a8 <decstr_to_int+0x7e>
   1a1a2:	693b      	ldr	r3, [r7, #16]
   1a1a4:	425b      	negs	r3, r3
   1a1a6:	e000      	b.n	1a1aa <decstr_to_int+0x80>
   1a1a8:	693b      	ldr	r3, [r7, #16]
}
   1a1aa:	4618      	mov	r0, r3
   1a1ac:	371c      	adds	r7, #28
   1a1ae:	46bd      	mov	sp, r7
   1a1b0:	f85d 7b04 	ldr.w	r7, [sp], #4
   1a1b4:	4770      	bx	lr

0001a1b6 <uint64_to_str>:
// written).
//
//*****************************************************************************
static int
uint64_to_str(uint64_t ui64Val, char *pcBuf)
{
   1a1b6:	b580      	push	{r7, lr}
   1a1b8:	b090      	sub	sp, #64	; 0x40
   1a1ba:	af00      	add	r7, sp, #0
   1a1bc:	e9c7 0102 	strd	r0, r1, [r7, #8]
   1a1c0:	607a      	str	r2, [r7, #4]
    char tbuf[25];
    int ix = 0, iNumDig = 0;
   1a1c2:	2300      	movs	r3, #0
   1a1c4:	63fb      	str	r3, [r7, #60]	; 0x3c
   1a1c6:	2300      	movs	r3, #0
   1a1c8:	63bb      	str	r3, [r7, #56]	; 0x38
    do
    {
        //
        // Divide by 10
        //
        u64Tmp = divu64_10(ui64Val);
   1a1ca:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
   1a1ce:	f7ff fe4d 	bl	19e6c <divu64_10>
   1a1d2:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30

        //
        // Get modulus
        //
        uMod = ui64Val - (u64Tmp * 10);
   1a1d6:	68b9      	ldr	r1, [r7, #8]
   1a1d8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1a1da:	4613      	mov	r3, r2
   1a1dc:	009b      	lsls	r3, r3, #2
   1a1de:	4413      	add	r3, r2
   1a1e0:	005b      	lsls	r3, r3, #1
   1a1e2:	1acb      	subs	r3, r1, r3
   1a1e4:	62fb      	str	r3, [r7, #44]	; 0x2c

        tbuf[ix++] = uMod + '0';
   1a1e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a1e8:	b2da      	uxtb	r2, r3
   1a1ea:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a1ec:	1c59      	adds	r1, r3, #1
   1a1ee:	63f9      	str	r1, [r7, #60]	; 0x3c
   1a1f0:	3230      	adds	r2, #48	; 0x30
   1a1f2:	b2d2      	uxtb	r2, r2
   1a1f4:	f107 0140 	add.w	r1, r7, #64	; 0x40
   1a1f8:	440b      	add	r3, r1
   1a1fa:	f803 2c30 	strb.w	r2, [r3, #-48]
        ui64Val = u64Tmp;
   1a1fe:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
   1a202:	e9c7 2302 	strd	r2, r3, [r7, #8]
    } while ( ui64Val );
   1a206:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   1a20a:	4313      	orrs	r3, r2
   1a20c:	d1dd      	bne.n	1a1ca <uint64_to_str+0x14>

    //
    // Save the total number of digits
    //
    iNumDig = ix;
   1a20e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a210:	63bb      	str	r3, [r7, #56]	; 0x38

    //
    // Now, reverse the buffer when saving to the caller's buffer.
    //
    if ( pcBuf )
   1a212:	687b      	ldr	r3, [r7, #4]
   1a214:	2b00      	cmp	r3, #0
   1a216:	d011      	beq.n	1a23c <uint64_to_str+0x86>
    {
        while ( ix-- )
   1a218:	e008      	b.n	1a22c <uint64_to_str+0x76>
        {
            *pcBuf++ = tbuf[ix];
   1a21a:	687b      	ldr	r3, [r7, #4]
   1a21c:	1c5a      	adds	r2, r3, #1
   1a21e:	607a      	str	r2, [r7, #4]
   1a220:	f107 0110 	add.w	r1, r7, #16
   1a224:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
   1a226:	440a      	add	r2, r1
   1a228:	7812      	ldrb	r2, [r2, #0]
   1a22a:	701a      	strb	r2, [r3, #0]
        while ( ix-- )
   1a22c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a22e:	1e5a      	subs	r2, r3, #1
   1a230:	63fa      	str	r2, [r7, #60]	; 0x3c
   1a232:	2b00      	cmp	r3, #0
   1a234:	d1f1      	bne.n	1a21a <uint64_to_str+0x64>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0x00;
   1a236:	687b      	ldr	r3, [r7, #4]
   1a238:	2200      	movs	r2, #0
   1a23a:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
   1a23c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
}
   1a23e:	4618      	mov	r0, r3
   1a240:	3740      	adds	r7, #64	; 0x40
   1a242:	46bd      	mov	sp, r7
   1a244:	bd80      	pop	{r7, pc}

0001a246 <uint64_to_hexstr>:
// written).
//
//*****************************************************************************
static int
uint64_to_hexstr(uint64_t ui64Val, char *pcBuf, bool bLower)
{
   1a246:	b480      	push	{r7}
   1a248:	b08d      	sub	sp, #52	; 0x34
   1a24a:	af00      	add	r7, sp, #0
   1a24c:	e9c7 0102 	strd	r0, r1, [r7, #8]
   1a250:	607a      	str	r2, [r7, #4]
   1a252:	70fb      	strb	r3, [r7, #3]
    int iNumDig, ix = 0;
   1a254:	2300      	movs	r3, #0
   1a256:	62fb      	str	r3, [r7, #44]	; 0x2c
    char cCh, tbuf[20];

    if ( ui64Val == 0 )
   1a258:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   1a25c:	4313      	orrs	r3, r2
   1a25e:	d135      	bne.n	1a2cc <uint64_to_hexstr+0x86>
    {
        tbuf[ix++] = '0';   // Print a '0'
   1a260:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a262:	1c5a      	adds	r2, r3, #1
   1a264:	62fa      	str	r2, [r7, #44]	; 0x2c
   1a266:	f107 0230 	add.w	r2, r7, #48	; 0x30
   1a26a:	4413      	add	r3, r2
   1a26c:	2230      	movs	r2, #48	; 0x30
   1a26e:	f803 2c20 	strb.w	r2, [r3, #-32]
    }

    while ( ui64Val )
   1a272:	e02b      	b.n	1a2cc <uint64_to_hexstr+0x86>
    {
        cCh = ui64Val & 0xf;
   1a274:	7a3b      	ldrb	r3, [r7, #8]
   1a276:	f003 030f 	and.w	r3, r3, #15
   1a27a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

        //
        // Alpha character
        //
        if ( cCh > 9 )
   1a27e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   1a282:	2b09      	cmp	r3, #9
   1a284:	d90a      	bls.n	1a29c <uint64_to_hexstr+0x56>
        {
            cCh += bLower ? 0x27 : 0x7;
   1a286:	78fb      	ldrb	r3, [r7, #3]
   1a288:	2b00      	cmp	r3, #0
   1a28a:	d001      	beq.n	1a290 <uint64_to_hexstr+0x4a>
   1a28c:	2227      	movs	r2, #39	; 0x27
   1a28e:	e000      	b.n	1a292 <uint64_to_hexstr+0x4c>
   1a290:	2207      	movs	r2, #7
   1a292:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   1a296:	4413      	add	r3, r2
   1a298:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        }

        tbuf[ix++] = cCh + '0';
   1a29c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a29e:	1c5a      	adds	r2, r3, #1
   1a2a0:	62fa      	str	r2, [r7, #44]	; 0x2c
   1a2a2:	f897 202b 	ldrb.w	r2, [r7, #43]	; 0x2b
   1a2a6:	3230      	adds	r2, #48	; 0x30
   1a2a8:	b2d2      	uxtb	r2, r2
   1a2aa:	f107 0130 	add.w	r1, r7, #48	; 0x30
   1a2ae:	440b      	add	r3, r1
   1a2b0:	f803 2c20 	strb.w	r2, [r3, #-32]
        ui64Val >>= 4;
   1a2b4:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
   1a2b8:	f04f 0200 	mov.w	r2, #0
   1a2bc:	f04f 0300 	mov.w	r3, #0
   1a2c0:	0902      	lsrs	r2, r0, #4
   1a2c2:	ea42 7201 	orr.w	r2, r2, r1, lsl #28
   1a2c6:	090b      	lsrs	r3, r1, #4
   1a2c8:	e9c7 2302 	strd	r2, r3, [r7, #8]
    while ( ui64Val )
   1a2cc:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
   1a2d0:	4313      	orrs	r3, r2
   1a2d2:	d1cf      	bne.n	1a274 <uint64_to_hexstr+0x2e>
    }

    //
    // Save the total number of digits
    //
    iNumDig = ix;
   1a2d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a2d6:	627b      	str	r3, [r7, #36]	; 0x24

    //
    // Now, reverse the buffer when saving to the callers buffer.
    //
    if (pcBuf)
   1a2d8:	687b      	ldr	r3, [r7, #4]
   1a2da:	2b00      	cmp	r3, #0
   1a2dc:	d011      	beq.n	1a302 <uint64_to_hexstr+0xbc>
    {
        while (ix--)
   1a2de:	e008      	b.n	1a2f2 <uint64_to_hexstr+0xac>
        {
            *pcBuf++ = tbuf[ix];
   1a2e0:	687b      	ldr	r3, [r7, #4]
   1a2e2:	1c5a      	adds	r2, r3, #1
   1a2e4:	607a      	str	r2, [r7, #4]
   1a2e6:	f107 0110 	add.w	r1, r7, #16
   1a2ea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1a2ec:	440a      	add	r2, r1
   1a2ee:	7812      	ldrb	r2, [r2, #0]
   1a2f0:	701a      	strb	r2, [r3, #0]
        while (ix--)
   1a2f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a2f4:	1e5a      	subs	r2, r3, #1
   1a2f6:	62fa      	str	r2, [r7, #44]	; 0x2c
   1a2f8:	2b00      	cmp	r3, #0
   1a2fa:	d1f1      	bne.n	1a2e0 <uint64_to_hexstr+0x9a>
        }

        //
        // Terminate the caller's buffer
        //
        *pcBuf = 0;
   1a2fc:	687b      	ldr	r3, [r7, #4]
   1a2fe:	2200      	movs	r2, #0
   1a300:	701a      	strb	r2, [r3, #0]
    }

    return iNumDig;
   1a302:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
   1a304:	4618      	mov	r0, r3
   1a306:	3734      	adds	r7, #52	; 0x34
   1a308:	46bd      	mov	sp, r7
   1a30a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1a30e:	4770      	bx	lr

0001a310 <simple_strlen>:
// Return length of the given string.
//
//*****************************************************************************
static uint32_t
simple_strlen(char *pcBuf)
{
   1a310:	b480      	push	{r7}
   1a312:	b085      	sub	sp, #20
   1a314:	af00      	add	r7, sp, #0
   1a316:	6078      	str	r0, [r7, #4]
    uint32_t ui32RetVal = 0;
   1a318:	2300      	movs	r3, #0
   1a31a:	60fb      	str	r3, [r7, #12]
    if ( !pcBuf )
   1a31c:	687b      	ldr	r3, [r7, #4]
   1a31e:	2b00      	cmp	r3, #0
   1a320:	d104      	bne.n	1a32c <simple_strlen+0x1c>
    {
        return ui32RetVal;
   1a322:	68fb      	ldr	r3, [r7, #12]
   1a324:	e009      	b.n	1a33a <simple_strlen+0x2a>
    }

    while ( *pcBuf++ )
    {
        ui32RetVal++;
   1a326:	68fb      	ldr	r3, [r7, #12]
   1a328:	3301      	adds	r3, #1
   1a32a:	60fb      	str	r3, [r7, #12]
    while ( *pcBuf++ )
   1a32c:	687b      	ldr	r3, [r7, #4]
   1a32e:	1c5a      	adds	r2, r3, #1
   1a330:	607a      	str	r2, [r7, #4]
   1a332:	781b      	ldrb	r3, [r3, #0]
   1a334:	2b00      	cmp	r3, #0
   1a336:	d1f6      	bne.n	1a326 <simple_strlen+0x16>
    }
    return ui32RetVal;
   1a338:	68fb      	ldr	r3, [r7, #12]
}
   1a33a:	4618      	mov	r0, r3
   1a33c:	3714      	adds	r7, #20
   1a33e:	46bd      	mov	sp, r7
   1a340:	f85d 7b04 	ldr.w	r7, [sp], #4
   1a344:	4770      	bx	lr

0001a346 <padbuffer>:
// Pad a string buffer with pad characters.
//
//*****************************************************************************
static int32_t
padbuffer(char *pcBuf, uint8_t cPadChar, int32_t i32NumChars)
{
   1a346:	b480      	push	{r7}
   1a348:	b087      	sub	sp, #28
   1a34a:	af00      	add	r7, sp, #0
   1a34c:	60f8      	str	r0, [r7, #12]
   1a34e:	460b      	mov	r3, r1
   1a350:	607a      	str	r2, [r7, #4]
   1a352:	72fb      	strb	r3, [r7, #11]
    int32_t i32Cnt = 0;
   1a354:	2300      	movs	r3, #0
   1a356:	617b      	str	r3, [r7, #20]

    if ( i32NumChars <= 0 )
   1a358:	687b      	ldr	r3, [r7, #4]
   1a35a:	2b00      	cmp	r3, #0
   1a35c:	dc0c      	bgt.n	1a378 <padbuffer+0x32>
    {
        return i32Cnt;
   1a35e:	697b      	ldr	r3, [r7, #20]
   1a360:	e010      	b.n	1a384 <padbuffer+0x3e>
    }

    while ( i32NumChars-- )
    {
        if ( pcBuf )
   1a362:	68fb      	ldr	r3, [r7, #12]
   1a364:	2b00      	cmp	r3, #0
   1a366:	d004      	beq.n	1a372 <padbuffer+0x2c>
        {
            *pcBuf++ = cPadChar;
   1a368:	68fb      	ldr	r3, [r7, #12]
   1a36a:	1c5a      	adds	r2, r3, #1
   1a36c:	60fa      	str	r2, [r7, #12]
   1a36e:	7afa      	ldrb	r2, [r7, #11]
   1a370:	701a      	strb	r2, [r3, #0]
        }
        i32Cnt++;
   1a372:	697b      	ldr	r3, [r7, #20]
   1a374:	3301      	adds	r3, #1
   1a376:	617b      	str	r3, [r7, #20]
    while ( i32NumChars-- )
   1a378:	687b      	ldr	r3, [r7, #4]
   1a37a:	1e5a      	subs	r2, r3, #1
   1a37c:	607a      	str	r2, [r7, #4]
   1a37e:	2b00      	cmp	r3, #0
   1a380:	d1ef      	bne.n	1a362 <padbuffer+0x1c>
    }

    return i32Cnt;
   1a382:	697b      	ldr	r3, [r7, #20]
}
   1a384:	4618      	mov	r0, r3
   1a386:	371c      	adds	r7, #28
   1a388:	46bd      	mov	sp, r7
   1a38a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1a38e:	4770      	bx	lr

0001a390 <ftoa>:
    int32_t I32;
    float F;
} i32fl_t;

static int ftoa(float fValue, char *pcBuf, int iPrecision)
{
   1a390:	b580      	push	{r7, lr}
   1a392:	b08e      	sub	sp, #56	; 0x38
   1a394:	af00      	add	r7, sp, #0
   1a396:	ed87 0a03 	vstr	s0, [r7, #12]
   1a39a:	60b8      	str	r0, [r7, #8]
   1a39c:	6079      	str	r1, [r7, #4]
    i32fl_t unFloatValue;
    int iExp2, iBufSize;
    int32_t i32Significand, i32IntPart, i32FracPart;
    char *pcBufInitial, *pcBuftmp;

    iBufSize = *(uint32_t*)pcBuf;
   1a39e:	68bb      	ldr	r3, [r7, #8]
   1a3a0:	681b      	ldr	r3, [r3, #0]
   1a3a2:	627b      	str	r3, [r7, #36]	; 0x24
    if (iBufSize < 4)
   1a3a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1a3a6:	2b03      	cmp	r3, #3
   1a3a8:	dc02      	bgt.n	1a3b0 <ftoa+0x20>
    {
        return AM_FTOA_ERR_BUFSIZE;
   1a3aa:	f06f 0302 	mvn.w	r3, #2
   1a3ae:	e0e5      	b.n	1a57c <ftoa+0x1ec>
    }

    if (fValue == 0.0f)
   1a3b0:	edd7 7a03 	vldr	s15, [r7, #12]
   1a3b4:	eef5 7a40 	vcmp.f32	s15, #0.0
   1a3b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
   1a3bc:	d104      	bne.n	1a3c8 <ftoa+0x38>
    {
        // "0.0"
        *(uint32_t*)pcBuf = 0x00 << 24 | ('0' << 16) | ('.' << 8) | ('0' << 0);
   1a3be:	68bb      	ldr	r3, [r7, #8]
   1a3c0:	4a70      	ldr	r2, [pc, #448]	; (1a584 <ftoa+0x1f4>)
   1a3c2:	601a      	str	r2, [r3, #0]
        return 3;
   1a3c4:	2303      	movs	r3, #3
   1a3c6:	e0d9      	b.n	1a57c <ftoa+0x1ec>
    }

    pcBufInitial = pcBuf;
   1a3c8:	68bb      	ldr	r3, [r7, #8]
   1a3ca:	623b      	str	r3, [r7, #32]

    unFloatValue.F = fValue;
   1a3cc:	68fb      	ldr	r3, [r7, #12]
   1a3ce:	613b      	str	r3, [r7, #16]

    iExp2 = ((unFloatValue.I32 >> 23) & 0x000000FF) - 127;
   1a3d0:	693b      	ldr	r3, [r7, #16]
   1a3d2:	15db      	asrs	r3, r3, #23
   1a3d4:	b2db      	uxtb	r3, r3
   1a3d6:	3b7f      	subs	r3, #127	; 0x7f
   1a3d8:	61fb      	str	r3, [r7, #28]
    i32Significand = (unFloatValue.I32 & 0x00FFFFFF) | 0x00800000;
   1a3da:	693b      	ldr	r3, [r7, #16]
   1a3dc:	f3c3 0316 	ubfx	r3, r3, #0, #23
   1a3e0:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
   1a3e4:	61bb      	str	r3, [r7, #24]
    i32FracPart = 0;
   1a3e6:	2300      	movs	r3, #0
   1a3e8:	633b      	str	r3, [r7, #48]	; 0x30
    i32IntPart = 0;
   1a3ea:	2300      	movs	r3, #0
   1a3ec:	637b      	str	r3, [r7, #52]	; 0x34

    if (iExp2 >= 31)
   1a3ee:	69fb      	ldr	r3, [r7, #28]
   1a3f0:	2b1e      	cmp	r3, #30
   1a3f2:	dd02      	ble.n	1a3fa <ftoa+0x6a>
    {
        return AM_FTOA_ERR_VAL_TOO_LARGE;
   1a3f4:	f06f 0301 	mvn.w	r3, #1
   1a3f8:	e0c0      	b.n	1a57c <ftoa+0x1ec>
    }
    else if (iExp2 < -23)
   1a3fa:	69fb      	ldr	r3, [r7, #28]
   1a3fc:	f113 0f17 	cmn.w	r3, #23
   1a400:	da02      	bge.n	1a408 <ftoa+0x78>
    {
        return AM_FTOA_ERR_VAL_TOO_SMALL;
   1a402:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   1a406:	e0b9      	b.n	1a57c <ftoa+0x1ec>
    }
    else if (iExp2 >= 23)
   1a408:	69fb      	ldr	r3, [r7, #28]
   1a40a:	2b16      	cmp	r3, #22
   1a40c:	dd06      	ble.n	1a41c <ftoa+0x8c>
    {
        i32IntPart = i32Significand << (iExp2 - 23);
   1a40e:	69fb      	ldr	r3, [r7, #28]
   1a410:	3b17      	subs	r3, #23
   1a412:	69ba      	ldr	r2, [r7, #24]
   1a414:	fa02 f303 	lsl.w	r3, r2, r3
   1a418:	637b      	str	r3, [r7, #52]	; 0x34
   1a41a:	e01a      	b.n	1a452 <ftoa+0xc2>
    }
    else if (iExp2 >= 0)
   1a41c:	69fb      	ldr	r3, [r7, #28]
   1a41e:	2b00      	cmp	r3, #0
   1a420:	db0f      	blt.n	1a442 <ftoa+0xb2>
    {
        i32IntPart = i32Significand >> (23 - iExp2);
   1a422:	69fb      	ldr	r3, [r7, #28]
   1a424:	f1c3 0317 	rsb	r3, r3, #23
   1a428:	69ba      	ldr	r2, [r7, #24]
   1a42a:	fa42 f303 	asr.w	r3, r2, r3
   1a42e:	637b      	str	r3, [r7, #52]	; 0x34
        i32FracPart = (i32Significand << (iExp2 + 1)) & 0x00FFFFFF;
   1a430:	69fb      	ldr	r3, [r7, #28]
   1a432:	3301      	adds	r3, #1
   1a434:	69ba      	ldr	r2, [r7, #24]
   1a436:	fa02 f303 	lsl.w	r3, r2, r3
   1a43a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1a43e:	633b      	str	r3, [r7, #48]	; 0x30
   1a440:	e007      	b.n	1a452 <ftoa+0xc2>
    }
    else // if (iExp2 < 0)
    {
        i32FracPart = (i32Significand & 0x00FFFFFF) >> -(iExp2 + 1);
   1a442:	69bb      	ldr	r3, [r7, #24]
   1a444:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
   1a448:	69fb      	ldr	r3, [r7, #28]
   1a44a:	43db      	mvns	r3, r3
   1a44c:	fa42 f303 	asr.w	r3, r2, r3
   1a450:	633b      	str	r3, [r7, #48]	; 0x30
    }

    if (unFloatValue.I32 < 0)
   1a452:	693b      	ldr	r3, [r7, #16]
   1a454:	2b00      	cmp	r3, #0
   1a456:	da04      	bge.n	1a462 <ftoa+0xd2>
    {
        *pcBuf++ = '-';
   1a458:	68bb      	ldr	r3, [r7, #8]
   1a45a:	1c5a      	adds	r2, r3, #1
   1a45c:	60ba      	str	r2, [r7, #8]
   1a45e:	222d      	movs	r2, #45	; 0x2d
   1a460:	701a      	strb	r2, [r3, #0]
    }

    if (i32IntPart == 0)
   1a462:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1a464:	2b00      	cmp	r3, #0
   1a466:	d105      	bne.n	1a474 <ftoa+0xe4>
    {
        *pcBuf++ = '0';
   1a468:	68bb      	ldr	r3, [r7, #8]
   1a46a:	1c5a      	adds	r2, r3, #1
   1a46c:	60ba      	str	r2, [r7, #8]
   1a46e:	2230      	movs	r2, #48	; 0x30
   1a470:	701a      	strb	r2, [r3, #0]
   1a472:	e01f      	b.n	1a4b4 <ftoa+0x124>
    }
    else
    {
        if (i32IntPart > 0)
   1a474:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1a476:	2b00      	cmp	r3, #0
   1a478:	dd07      	ble.n	1a48a <ftoa+0xfa>
        {
            uint64_to_str(i32IntPart, pcBuf);
   1a47a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1a47c:	4618      	mov	r0, r3
   1a47e:	ea4f 71e0 	mov.w	r1, r0, asr #31
   1a482:	68ba      	ldr	r2, [r7, #8]
   1a484:	f7ff fe97 	bl	1a1b6 <uint64_to_str>
   1a488:	e010      	b.n	1a4ac <ftoa+0x11c>
        }
        else
        {
            *pcBuf++ = '-';
   1a48a:	68bb      	ldr	r3, [r7, #8]
   1a48c:	1c5a      	adds	r2, r3, #1
   1a48e:	60ba      	str	r2, [r7, #8]
   1a490:	222d      	movs	r2, #45	; 0x2d
   1a492:	701a      	strb	r2, [r3, #0]
            uint64_to_str(-i32IntPart, pcBuf);
   1a494:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   1a496:	425b      	negs	r3, r3
   1a498:	4618      	mov	r0, r3
   1a49a:	ea4f 71e0 	mov.w	r1, r0, asr #31
   1a49e:	68ba      	ldr	r2, [r7, #8]
   1a4a0:	f7ff fe89 	bl	1a1b6 <uint64_to_str>
        }
        while (*pcBuf)    // Get to end of new string
   1a4a4:	e002      	b.n	1a4ac <ftoa+0x11c>
        {
            pcBuf++;
   1a4a6:	68bb      	ldr	r3, [r7, #8]
   1a4a8:	3301      	adds	r3, #1
   1a4aa:	60bb      	str	r3, [r7, #8]
        while (*pcBuf)    // Get to end of new string
   1a4ac:	68bb      	ldr	r3, [r7, #8]
   1a4ae:	781b      	ldrb	r3, [r3, #0]
   1a4b0:	2b00      	cmp	r3, #0
   1a4b2:	d1f8      	bne.n	1a4a6 <ftoa+0x116>
    }

    //
    // Now, begin the fractional part
    //
    *pcBuf++ = '.';
   1a4b4:	68bb      	ldr	r3, [r7, #8]
   1a4b6:	1c5a      	adds	r2, r3, #1
   1a4b8:	60ba      	str	r2, [r7, #8]
   1a4ba:	222e      	movs	r2, #46	; 0x2e
   1a4bc:	701a      	strb	r2, [r3, #0]

    if (i32FracPart == 0)
   1a4be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1a4c0:	2b00      	cmp	r3, #0
   1a4c2:	d105      	bne.n	1a4d0 <ftoa+0x140>
    {
        *pcBuf++ = '0';
   1a4c4:	68bb      	ldr	r3, [r7, #8]
   1a4c6:	1c5a      	adds	r2, r3, #1
   1a4c8:	60ba      	str	r2, [r7, #8]
   1a4ca:	2230      	movs	r2, #48	; 0x30
   1a4cc:	701a      	strb	r2, [r3, #0]
   1a4ce:	e04f      	b.n	1a570 <ftoa+0x1e0>
    }
    else
    {
        int jx, iMax;

        iMax = iBufSize - (pcBuf - pcBufInitial) - 1;
   1a4d0:	68ba      	ldr	r2, [r7, #8]
   1a4d2:	6a3b      	ldr	r3, [r7, #32]
   1a4d4:	1ad3      	subs	r3, r2, r3
   1a4d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1a4d8:	1ad3      	subs	r3, r2, r3
   1a4da:	3b01      	subs	r3, #1
   1a4dc:	617b      	str	r3, [r7, #20]
        iMax = (iMax > iPrecision) ? iPrecision : iMax;
   1a4de:	697a      	ldr	r2, [r7, #20]
   1a4e0:	687b      	ldr	r3, [r7, #4]
   1a4e2:	4293      	cmp	r3, r2
   1a4e4:	bfa8      	it	ge
   1a4e6:	4613      	movge	r3, r2
   1a4e8:	617b      	str	r3, [r7, #20]

        for (jx = 0; jx < iMax; jx++)
   1a4ea:	2300      	movs	r3, #0
   1a4ec:	62bb      	str	r3, [r7, #40]	; 0x28
   1a4ee:	e015      	b.n	1a51c <ftoa+0x18c>
        {
            i32FracPart *= 10;
   1a4f0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1a4f2:	4613      	mov	r3, r2
   1a4f4:	009b      	lsls	r3, r3, #2
   1a4f6:	4413      	add	r3, r2
   1a4f8:	005b      	lsls	r3, r3, #1
   1a4fa:	633b      	str	r3, [r7, #48]	; 0x30
            *pcBuf++ = (i32FracPart >> 24) + '0';
   1a4fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1a4fe:	161b      	asrs	r3, r3, #24
   1a500:	b2da      	uxtb	r2, r3
   1a502:	68bb      	ldr	r3, [r7, #8]
   1a504:	1c59      	adds	r1, r3, #1
   1a506:	60b9      	str	r1, [r7, #8]
   1a508:	3230      	adds	r2, #48	; 0x30
   1a50a:	b2d2      	uxtb	r2, r2
   1a50c:	701a      	strb	r2, [r3, #0]
            i32FracPart &= 0x00FFFFFF;
   1a50e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1a510:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   1a514:	633b      	str	r3, [r7, #48]	; 0x30
        for (jx = 0; jx < iMax; jx++)
   1a516:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1a518:	3301      	adds	r3, #1
   1a51a:	62bb      	str	r3, [r7, #40]	; 0x28
   1a51c:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1a51e:	697b      	ldr	r3, [r7, #20]
   1a520:	429a      	cmp	r2, r3
   1a522:	dbe5      	blt.n	1a4f0 <ftoa+0x160>
        // 1.996        4                   1.9960
        //
        // To determine whether to round up, we'll look at what the next
        // decimal value would have been.
        //
        if ( ((i32FracPart * 10) >> 24) >= 5 )
   1a524:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1a526:	4613      	mov	r3, r2
   1a528:	009b      	lsls	r3, r3, #2
   1a52a:	4413      	add	r3, r2
   1a52c:	005b      	lsls	r3, r3, #1
   1a52e:	161b      	asrs	r3, r3, #24
   1a530:	2b04      	cmp	r3, #4
   1a532:	dd1d      	ble.n	1a570 <ftoa+0x1e0>
        {
            //
            // Yes, we need to round up.
            // Go back through the string and make adjustments as necessary.
            //
            pcBuftmp = pcBuf - 1;
   1a534:	68bb      	ldr	r3, [r7, #8]
   1a536:	3b01      	subs	r3, #1
   1a538:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
   1a53a:	e015      	b.n	1a568 <ftoa+0x1d8>
            {
                if ( *pcBuftmp == '.' )
   1a53c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a53e:	781b      	ldrb	r3, [r3, #0]
   1a540:	2b2e      	cmp	r3, #46	; 0x2e
   1a542:	d00e      	beq.n	1a562 <ftoa+0x1d2>
                {
                }
                else if ( *pcBuftmp == '9' )
   1a544:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a546:	781b      	ldrb	r3, [r3, #0]
   1a548:	2b39      	cmp	r3, #57	; 0x39
   1a54a:	d103      	bne.n	1a554 <ftoa+0x1c4>
                {
                    *pcBuftmp = '0';
   1a54c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a54e:	2230      	movs	r2, #48	; 0x30
   1a550:	701a      	strb	r2, [r3, #0]
   1a552:	e006      	b.n	1a562 <ftoa+0x1d2>
                }
                else
                {
                    *pcBuftmp += 1;
   1a554:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a556:	781b      	ldrb	r3, [r3, #0]
   1a558:	3301      	adds	r3, #1
   1a55a:	b2da      	uxtb	r2, r3
   1a55c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a55e:	701a      	strb	r2, [r3, #0]
                    break;
   1a560:	e006      	b.n	1a570 <ftoa+0x1e0>
                }
                pcBuftmp--;
   1a562:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a564:	3b01      	subs	r3, #1
   1a566:	62fb      	str	r3, [r7, #44]	; 0x2c
            while ( pcBuftmp >= pcBufInitial )
   1a568:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1a56a:	6a3b      	ldr	r3, [r7, #32]
   1a56c:	429a      	cmp	r2, r3
   1a56e:	d2e5      	bcs.n	1a53c <ftoa+0x1ac>
    }

    //
    // Terminate the string and we're done
    //
    *pcBuf = 0x00;
   1a570:	68bb      	ldr	r3, [r7, #8]
   1a572:	2200      	movs	r2, #0
   1a574:	701a      	strb	r2, [r3, #0]

    return (pcBuf - pcBufInitial);
   1a576:	68ba      	ldr	r2, [r7, #8]
   1a578:	6a3b      	ldr	r3, [r7, #32]
   1a57a:	1ad3      	subs	r3, r2, r3
} // ftoa()
   1a57c:	4618      	mov	r0, r3
   1a57e:	3738      	adds	r7, #56	; 0x38
   1a580:	46bd      	mov	sp, r7
   1a582:	bd80      	pop	{r7, pc}
   1a584:	00302e30 	.word	0x00302e30

0001a588 <am_util_stdio_vsprintf>:
// Format data into string. (va_list implementation)
//
//******************************************************************************
uint32_t
am_util_stdio_vsprintf(char *pcBuf, const char *pcFmt, va_list pArgs)
{
   1a588:	b580      	push	{r7, lr}
   1a58a:	b096      	sub	sp, #88	; 0x58
   1a58c:	af00      	add	r7, sp, #0
   1a58e:	60f8      	str	r0, [r7, #12]
   1a590:	60b9      	str	r1, [r7, #8]
   1a592:	607a      	str	r2, [r7, #4]
    char *pcStr;
    uint64_t ui64Val;
    int64_t i64Val;
    uint32_t ui32NumChars, ui32CharCnt = 0;
   1a594:	2300      	movs	r3, #0
   1a596:	647b      	str	r3, [r7, #68]	; 0x44
    int iWidth, iVal, iPrecision;
    uint8_t ui8CharSpecifier, ui8PadChar;
    bool bLower, bLongLong, bNeg;
    uint32_t ui32strlen = 0;
   1a598:	2300      	movs	r3, #0
   1a59a:	62fb      	str	r3, [r7, #44]	; 0x2c

    while ( *pcFmt != 0x0 )
   1a59c:	e2ea      	b.n	1ab74 <am_util_stdio_vsprintf+0x5ec>
    {
        iPrecision = 6;             // printf() default precision for %f is 6
   1a59e:	2306      	movs	r3, #6
   1a5a0:	63bb      	str	r3, [r7, #56]	; 0x38

        if ( *pcFmt != '%' )
   1a5a2:	68bb      	ldr	r3, [r7, #8]
   1a5a4:	781b      	ldrb	r3, [r3, #0]
   1a5a6:	2b25      	cmp	r3, #37	; 0x25
   1a5a8:	d01f      	beq.n	1a5ea <am_util_stdio_vsprintf+0x62>
        {
            //
            // Accumulate the string portion of the format specification.
            //
            if ( pcBuf )
   1a5aa:	68fb      	ldr	r3, [r7, #12]
   1a5ac:	2b00      	cmp	r3, #0
   1a5ae:	d015      	beq.n	1a5dc <am_util_stdio_vsprintf+0x54>
            {
                // If '\n', convert to '\r\n'
                if ( *pcFmt == '\n'  &&  g_bTxtXlate )
   1a5b0:	68bb      	ldr	r3, [r7, #8]
   1a5b2:	781b      	ldrb	r3, [r3, #0]
   1a5b4:	2b0a      	cmp	r3, #10
   1a5b6:	d10b      	bne.n	1a5d0 <am_util_stdio_vsprintf+0x48>
   1a5b8:	4bb1      	ldr	r3, [pc, #708]	; (1a880 <am_util_stdio_vsprintf+0x2f8>)
   1a5ba:	781b      	ldrb	r3, [r3, #0]
   1a5bc:	2b00      	cmp	r3, #0
   1a5be:	d007      	beq.n	1a5d0 <am_util_stdio_vsprintf+0x48>
                {
                    *pcBuf++ = '\r';
   1a5c0:	68fb      	ldr	r3, [r7, #12]
   1a5c2:	1c5a      	adds	r2, r3, #1
   1a5c4:	60fa      	str	r2, [r7, #12]
   1a5c6:	220d      	movs	r2, #13
   1a5c8:	701a      	strb	r2, [r3, #0]
                    ++ui32CharCnt;
   1a5ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1a5cc:	3301      	adds	r3, #1
   1a5ce:	647b      	str	r3, [r7, #68]	; 0x44
                }
                *pcBuf++ = *pcFmt;
   1a5d0:	68fb      	ldr	r3, [r7, #12]
   1a5d2:	1c5a      	adds	r2, r3, #1
   1a5d4:	60fa      	str	r2, [r7, #12]
   1a5d6:	68ba      	ldr	r2, [r7, #8]
   1a5d8:	7812      	ldrb	r2, [r2, #0]
   1a5da:	701a      	strb	r2, [r3, #0]
            }

            ++pcFmt;
   1a5dc:	68bb      	ldr	r3, [r7, #8]
   1a5de:	3301      	adds	r3, #1
   1a5e0:	60bb      	str	r3, [r7, #8]
            ++ui32CharCnt;
   1a5e2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1a5e4:	3301      	adds	r3, #1
   1a5e6:	647b      	str	r3, [r7, #68]	; 0x44
            continue;
   1a5e8:	e2c4      	b.n	1ab74 <am_util_stdio_vsprintf+0x5ec>
        }

        //
        // Handle the specifier.
        //
        ++pcFmt;
   1a5ea:	68bb      	ldr	r3, [r7, #8]
   1a5ec:	3301      	adds	r3, #1
   1a5ee:	60bb      	str	r3, [r7, #8]
        bLower = bLongLong = false;
   1a5f0:	2300      	movs	r3, #0
   1a5f2:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
   1a5f6:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
   1a5fa:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36

        //
        // Default to space as ui8PadChar
        //
        ui8PadChar = ' ';
   1a5fe:	2320      	movs	r3, #32
   1a600:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

        if ( *pcFmt == '0' )
   1a604:	68bb      	ldr	r3, [r7, #8]
   1a606:	781b      	ldrb	r3, [r3, #0]
   1a608:	2b30      	cmp	r3, #48	; 0x30
   1a60a:	d105      	bne.n	1a618 <am_util_stdio_vsprintf+0x90>
        {
            ui8PadChar = '0';
   1a60c:	2330      	movs	r3, #48	; 0x30
   1a60e:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
            ++pcFmt;
   1a612:	68bb      	ldr	r3, [r7, #8]
   1a614:	3301      	adds	r3, #1
   1a616:	60bb      	str	r3, [r7, #8]
        }

        //
        // Width specifier
        //
        iWidth = decstr_to_int(pcFmt, &ui32NumChars);
   1a618:	f107 0314 	add.w	r3, r7, #20
   1a61c:	4619      	mov	r1, r3
   1a61e:	68b8      	ldr	r0, [r7, #8]
   1a620:	f7ff fd83 	bl	1a12a <decstr_to_int>
   1a624:	4603      	mov	r3, r0
   1a626:	643b      	str	r3, [r7, #64]	; 0x40
        pcFmt += ui32NumChars;
   1a628:	697b      	ldr	r3, [r7, #20]
   1a62a:	68ba      	ldr	r2, [r7, #8]
   1a62c:	4413      	add	r3, r2
   1a62e:	60bb      	str	r3, [r7, #8]

        //
        // For now, only support a negative width specifier for %s
        //
        if ( ( *pcFmt != 's' )  &&  ( iWidth < 0 ) )
   1a630:	68bb      	ldr	r3, [r7, #8]
   1a632:	781b      	ldrb	r3, [r3, #0]
   1a634:	2b73      	cmp	r3, #115	; 0x73
   1a636:	d005      	beq.n	1a644 <am_util_stdio_vsprintf+0xbc>
   1a638:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a63a:	2b00      	cmp	r3, #0
   1a63c:	da02      	bge.n	1a644 <am_util_stdio_vsprintf+0xbc>
        {
            iWidth = -iWidth;
   1a63e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a640:	425b      	negs	r3, r3
   1a642:	643b      	str	r3, [r7, #64]	; 0x40
        }

        //
        // Check for precision specifier
        //
        if (*pcFmt == '.')
   1a644:	68bb      	ldr	r3, [r7, #8]
   1a646:	781b      	ldrb	r3, [r3, #0]
   1a648:	2b2e      	cmp	r3, #46	; 0x2e
   1a64a:	d10e      	bne.n	1a66a <am_util_stdio_vsprintf+0xe2>
        {
            ++pcFmt;
   1a64c:	68bb      	ldr	r3, [r7, #8]
   1a64e:	3301      	adds	r3, #1
   1a650:	60bb      	str	r3, [r7, #8]
            iPrecision = decstr_to_int(pcFmt, &ui32NumChars);
   1a652:	f107 0314 	add.w	r3, r7, #20
   1a656:	4619      	mov	r1, r3
   1a658:	68b8      	ldr	r0, [r7, #8]
   1a65a:	f7ff fd66 	bl	1a12a <decstr_to_int>
   1a65e:	4603      	mov	r3, r0
   1a660:	63bb      	str	r3, [r7, #56]	; 0x38
            pcFmt += ui32NumChars;
   1a662:	697b      	ldr	r3, [r7, #20]
   1a664:	68ba      	ldr	r2, [r7, #8]
   1a666:	4413      	add	r3, r2
   1a668:	60bb      	str	r3, [r7, #8]
        // 'll', which must be a modifier for either 'd', 'i', 'u', 'x', or 'X'
        // (or even 'o', which is not currently supported). Other sub-specifiers
        // like 'hh','h', etc. are not currently handled.
        // Note - 'l' is used in Coremark, a primary reason it's supported here.
        //
        if ( *pcFmt == 'l' )
   1a66a:	68bb      	ldr	r3, [r7, #8]
   1a66c:	781b      	ldrb	r3, [r3, #0]
   1a66e:	2b6c      	cmp	r3, #108	; 0x6c
   1a670:	d10c      	bne.n	1a68c <am_util_stdio_vsprintf+0x104>
        {
            pcFmt++;
   1a672:	68bb      	ldr	r3, [r7, #8]
   1a674:	3301      	adds	r3, #1
   1a676:	60bb      	str	r3, [r7, #8]
            if ( *pcFmt == 'l' )    // "ll" (long long)
   1a678:	68bb      	ldr	r3, [r7, #8]
   1a67a:	781b      	ldrb	r3, [r3, #0]
   1a67c:	2b6c      	cmp	r3, #108	; 0x6c
   1a67e:	d105      	bne.n	1a68c <am_util_stdio_vsprintf+0x104>
            {
                pcFmt++;
   1a680:	68bb      	ldr	r3, [r7, #8]
   1a682:	3301      	adds	r3, #1
   1a684:	60bb      	str	r3, [r7, #8]
                bLongLong = true;
   1a686:	2301      	movs	r3, #1
   1a688:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
            }
        }

        switch ( *pcFmt )
   1a68c:	68bb      	ldr	r3, [r7, #8]
   1a68e:	781b      	ldrb	r3, [r3, #0]
   1a690:	3b46      	subs	r3, #70	; 0x46
   1a692:	2b32      	cmp	r3, #50	; 0x32
   1a694:	f200 825b 	bhi.w	1ab4e <am_util_stdio_vsprintf+0x5c6>
   1a698:	a201      	add	r2, pc, #4	; (adr r2, 1a6a0 <am_util_stdio_vsprintf+0x118>)
   1a69a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1a69e:	bf00      	nop
   1a6a0:	0001aad5 	.word	0x0001aad5
   1a6a4:	0001ab4f 	.word	0x0001ab4f
   1a6a8:	0001ab4f 	.word	0x0001ab4f
   1a6ac:	0001ab4f 	.word	0x0001ab4f
   1a6b0:	0001ab4f 	.word	0x0001ab4f
   1a6b4:	0001ab4f 	.word	0x0001ab4f
   1a6b8:	0001ab4f 	.word	0x0001ab4f
   1a6bc:	0001ab4f 	.word	0x0001ab4f
   1a6c0:	0001ab4f 	.word	0x0001ab4f
   1a6c4:	0001ab4f 	.word	0x0001ab4f
   1a6c8:	0001ab4f 	.word	0x0001ab4f
   1a6cc:	0001ab4f 	.word	0x0001ab4f
   1a6d0:	0001ab4f 	.word	0x0001ab4f
   1a6d4:	0001ab4f 	.word	0x0001ab4f
   1a6d8:	0001ab4f 	.word	0x0001ab4f
   1a6dc:	0001ab4f 	.word	0x0001ab4f
   1a6e0:	0001ab4f 	.word	0x0001ab4f
   1a6e4:	0001ab4f 	.word	0x0001ab4f
   1a6e8:	0001a863 	.word	0x0001a863
   1a6ec:	0001ab4f 	.word	0x0001ab4f
   1a6f0:	0001ab4f 	.word	0x0001ab4f
   1a6f4:	0001ab4f 	.word	0x0001ab4f
   1a6f8:	0001ab4f 	.word	0x0001ab4f
   1a6fc:	0001ab4f 	.word	0x0001ab4f
   1a700:	0001ab4f 	.word	0x0001ab4f
   1a704:	0001ab4f 	.word	0x0001ab4f
   1a708:	0001ab4f 	.word	0x0001ab4f
   1a70c:	0001ab4f 	.word	0x0001ab4f
   1a710:	0001ab4f 	.word	0x0001ab4f
   1a714:	0001a76d 	.word	0x0001a76d
   1a718:	0001a999 	.word	0x0001a999
   1a71c:	0001ab4f 	.word	0x0001ab4f
   1a720:	0001aad5 	.word	0x0001aad5
   1a724:	0001ab4f 	.word	0x0001ab4f
   1a728:	0001ab4f 	.word	0x0001ab4f
   1a72c:	0001a999 	.word	0x0001a999
   1a730:	0001ab4f 	.word	0x0001ab4f
   1a734:	0001ab4f 	.word	0x0001ab4f
   1a738:	0001ab4f 	.word	0x0001ab4f
   1a73c:	0001ab4f 	.word	0x0001ab4f
   1a740:	0001ab4f 	.word	0x0001ab4f
   1a744:	0001ab4f 	.word	0x0001ab4f
   1a748:	0001ab4f 	.word	0x0001ab4f
   1a74c:	0001ab4f 	.word	0x0001ab4f
   1a750:	0001ab4f 	.word	0x0001ab4f
   1a754:	0001a78f 	.word	0x0001a78f
   1a758:	0001ab4f 	.word	0x0001ab4f
   1a75c:	0001a903 	.word	0x0001a903
   1a760:	0001ab4f 	.word	0x0001ab4f
   1a764:	0001ab4f 	.word	0x0001ab4f
   1a768:	0001a85d 	.word	0x0001a85d
        {
            case 'c':
                ui8CharSpecifier = va_arg(pArgs, uint32_t);
   1a76c:	687b      	ldr	r3, [r7, #4]
   1a76e:	1d1a      	adds	r2, r3, #4
   1a770:	607a      	str	r2, [r7, #4]
   1a772:	681b      	ldr	r3, [r3, #0]
   1a774:	77fb      	strb	r3, [r7, #31]

                if ( pcBuf )
   1a776:	68fb      	ldr	r3, [r7, #12]
   1a778:	2b00      	cmp	r3, #0
   1a77a:	d004      	beq.n	1a786 <am_util_stdio_vsprintf+0x1fe>
                {
                    *pcBuf++ = ui8CharSpecifier;
   1a77c:	68fb      	ldr	r3, [r7, #12]
   1a77e:	1c5a      	adds	r2, r3, #1
   1a780:	60fa      	str	r2, [r7, #12]
   1a782:	7ffa      	ldrb	r2, [r7, #31]
   1a784:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
   1a786:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1a788:	3301      	adds	r3, #1
   1a78a:	647b      	str	r3, [r7, #68]	; 0x44
                break;
   1a78c:	e1ef      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>

            case 's':
                pcStr = va_arg(pArgs, char *);
   1a78e:	687b      	ldr	r3, [r7, #4]
   1a790:	1d1a      	adds	r2, r3, #4
   1a792:	607a      	str	r2, [r7, #4]
   1a794:	681b      	ldr	r3, [r3, #0]
   1a796:	657b      	str	r3, [r7, #84]	; 0x54
                //
                // For %s, we support the width specifier. If iWidth is negative
                // the string is left-aligned (padding on the right).  Otherwise
                // the string is padded at the beginning with spaces.
                //
                ui32strlen = simple_strlen(pcStr);
   1a798:	6d78      	ldr	r0, [r7, #84]	; 0x54
   1a79a:	f7ff fdb9 	bl	1a310 <simple_strlen>
   1a79e:	62f8      	str	r0, [r7, #44]	; 0x2c
                if ( iWidth > 0 )
   1a7a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a7a2:	2b00      	cmp	r3, #0
   1a7a4:	dd2e      	ble.n	1a804 <am_util_stdio_vsprintf+0x27c>
                {
                    // Pad the beginning of the string (right-aligned).
                    if ( ui32strlen < iWidth )
   1a7a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a7a8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1a7aa:	429a      	cmp	r2, r3
   1a7ac:	d22a      	bcs.n	1a804 <am_util_stdio_vsprintf+0x27c>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
   1a7ae:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a7b0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a7b2:	1ad3      	subs	r3, r2, r3
   1a7b4:	643b      	str	r3, [r7, #64]	; 0x40
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1a7b6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1a7ba:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a7bc:	4619      	mov	r1, r3
   1a7be:	68f8      	ldr	r0, [r7, #12]
   1a7c0:	f7ff fdc1 	bl	1a346 <padbuffer>
   1a7c4:	6438      	str	r0, [r7, #64]	; 0x40
                        pcBuf += pcBuf ? iWidth : 0;
   1a7c6:	68fb      	ldr	r3, [r7, #12]
   1a7c8:	2b00      	cmp	r3, #0
   1a7ca:	d001      	beq.n	1a7d0 <am_util_stdio_vsprintf+0x248>
   1a7cc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a7ce:	e000      	b.n	1a7d2 <am_util_stdio_vsprintf+0x24a>
   1a7d0:	2300      	movs	r3, #0
   1a7d2:	68fa      	ldr	r2, [r7, #12]
   1a7d4:	4413      	add	r3, r2
   1a7d6:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
   1a7d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a7da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a7dc:	4413      	add	r3, r2
   1a7de:	647b      	str	r3, [r7, #68]	; 0x44
                        iWidth = 0;
   1a7e0:	2300      	movs	r3, #0
   1a7e2:	643b      	str	r3, [r7, #64]	; 0x40
                    }
                }

                while (*pcStr != 0x0)
   1a7e4:	e00e      	b.n	1a804 <am_util_stdio_vsprintf+0x27c>
                {
                    if ( pcBuf )
   1a7e6:	68fb      	ldr	r3, [r7, #12]
   1a7e8:	2b00      	cmp	r3, #0
   1a7ea:	d005      	beq.n	1a7f8 <am_util_stdio_vsprintf+0x270>
                    {
                        *pcBuf++ = *pcStr;
   1a7ec:	68fb      	ldr	r3, [r7, #12]
   1a7ee:	1c5a      	adds	r2, r3, #1
   1a7f0:	60fa      	str	r2, [r7, #12]
   1a7f2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
   1a7f4:	7812      	ldrb	r2, [r2, #0]
   1a7f6:	701a      	strb	r2, [r3, #0]
                    }

                    ++pcStr;
   1a7f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1a7fa:	3301      	adds	r3, #1
   1a7fc:	657b      	str	r3, [r7, #84]	; 0x54
                    ++ui32CharCnt;
   1a7fe:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1a800:	3301      	adds	r3, #1
   1a802:	647b      	str	r3, [r7, #68]	; 0x44
                while (*pcStr != 0x0)
   1a804:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   1a806:	781b      	ldrb	r3, [r3, #0]
   1a808:	2b00      	cmp	r3, #0
   1a80a:	d1ec      	bne.n	1a7e6 <am_util_stdio_vsprintf+0x25e>
                }

                if ( iWidth )
   1a80c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a80e:	2b00      	cmp	r3, #0
   1a810:	f000 81aa 	beq.w	1ab68 <am_util_stdio_vsprintf+0x5e0>
                {
                    iWidth = -iWidth;
   1a814:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a816:	425b      	negs	r3, r3
   1a818:	643b      	str	r3, [r7, #64]	; 0x40

                    // Pad the end of the string (left-aligned).
                    if ( ui32strlen < iWidth )
   1a81a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a81c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   1a81e:	429a      	cmp	r2, r3
   1a820:	f080 81a2 	bcs.w	1ab68 <am_util_stdio_vsprintf+0x5e0>
                    {
                        // String needs some padding.
                        iWidth -= ui32strlen;
   1a824:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a826:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1a828:	1ad3      	subs	r3, r2, r3
   1a82a:	643b      	str	r3, [r7, #64]	; 0x40
                        iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1a82c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1a830:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a832:	4619      	mov	r1, r3
   1a834:	68f8      	ldr	r0, [r7, #12]
   1a836:	f7ff fd86 	bl	1a346 <padbuffer>
   1a83a:	6438      	str	r0, [r7, #64]	; 0x40
                        pcBuf += pcBuf ? iWidth : 0;
   1a83c:	68fb      	ldr	r3, [r7, #12]
   1a83e:	2b00      	cmp	r3, #0
   1a840:	d001      	beq.n	1a846 <am_util_stdio_vsprintf+0x2be>
   1a842:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a844:	e000      	b.n	1a848 <am_util_stdio_vsprintf+0x2c0>
   1a846:	2300      	movs	r3, #0
   1a848:	68fa      	ldr	r2, [r7, #12]
   1a84a:	4413      	add	r3, r2
   1a84c:	60fb      	str	r3, [r7, #12]
                        ui32CharCnt += iWidth;
   1a84e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a850:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a852:	4413      	add	r3, r2
   1a854:	647b      	str	r3, [r7, #68]	; 0x44
                        iWidth = 0;
   1a856:	2300      	movs	r3, #0
   1a858:	643b      	str	r3, [r7, #64]	; 0x40
                    }
                }
                break;
   1a85a:	e185      	b.n	1ab68 <am_util_stdio_vsprintf+0x5e0>

            case 'x':
                bLower = true;
   1a85c:	2301      	movs	r3, #1
   1a85e:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
                /* no break */
            case 'X':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   1a862:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
   1a866:	2b00      	cmp	r3, #0
   1a868:	d00c      	beq.n	1a884 <am_util_stdio_vsprintf+0x2fc>
   1a86a:	687b      	ldr	r3, [r7, #4]
   1a86c:	3307      	adds	r3, #7
   1a86e:	f023 0307 	bic.w	r3, r3, #7
   1a872:	f103 0208 	add.w	r2, r3, #8
   1a876:	607a      	str	r2, [r7, #4]
   1a878:	e9d3 2300 	ldrd	r2, r3, [r3]
   1a87c:	e009      	b.n	1a892 <am_util_stdio_vsprintf+0x30a>
   1a87e:	bf00      	nop
   1a880:	10003cbc 	.word	0x10003cbc
                                      va_arg(pArgs, uint32_t);
   1a884:	687b      	ldr	r3, [r7, #4]
   1a886:	1d1a      	adds	r2, r3, #4
   1a888:	607a      	str	r2, [r7, #4]
   1a88a:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   1a88c:	461a      	mov	r2, r3
   1a88e:	f04f 0300 	mov.w	r3, #0
   1a892:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48

                if ( iWidth )
   1a896:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a898:	2b00      	cmp	r3, #0
   1a89a:	d01e      	beq.n	1a8da <am_util_stdio_vsprintf+0x352>
                {
                    //
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_hex(ui64Val);
   1a89c:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   1a8a0:	f7ff fc1a 	bl	1a0d8 <ndigits_in_hex>
   1a8a4:	4602      	mov	r2, r0
   1a8a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a8a8:	1a9b      	subs	r3, r3, r2
   1a8aa:	643b      	str	r3, [r7, #64]	; 0x40

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1a8ac:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1a8b0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a8b2:	4619      	mov	r1, r3
   1a8b4:	68f8      	ldr	r0, [r7, #12]
   1a8b6:	f7ff fd46 	bl	1a346 <padbuffer>
   1a8ba:	6438      	str	r0, [r7, #64]	; 0x40
                    pcBuf += pcBuf ? iWidth : 0;
   1a8bc:	68fb      	ldr	r3, [r7, #12]
   1a8be:	2b00      	cmp	r3, #0
   1a8c0:	d001      	beq.n	1a8c6 <am_util_stdio_vsprintf+0x33e>
   1a8c2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a8c4:	e000      	b.n	1a8c8 <am_util_stdio_vsprintf+0x340>
   1a8c6:	2300      	movs	r3, #0
   1a8c8:	68fa      	ldr	r2, [r7, #12]
   1a8ca:	4413      	add	r3, r2
   1a8cc:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
   1a8ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a8d0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a8d2:	4413      	add	r3, r2
   1a8d4:	647b      	str	r3, [r7, #68]	; 0x44
                    iWidth = 0;
   1a8d6:	2300      	movs	r3, #0
   1a8d8:	643b      	str	r3, [r7, #64]	; 0x40
                }

                iVal = uint64_to_hexstr(ui64Val, pcBuf, bLower);
   1a8da:	f897 3036 	ldrb.w	r3, [r7, #54]	; 0x36
   1a8de:	68fa      	ldr	r2, [r7, #12]
   1a8e0:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   1a8e4:	f7ff fcaf 	bl	1a246 <uint64_to_hexstr>
   1a8e8:	63f8      	str	r0, [r7, #60]	; 0x3c

                if ( pcBuf )
   1a8ea:	68fb      	ldr	r3, [r7, #12]
   1a8ec:	2b00      	cmp	r3, #0
   1a8ee:	d003      	beq.n	1a8f8 <am_util_stdio_vsprintf+0x370>
                {
                    pcBuf += iVal;
   1a8f0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a8f2:	68fa      	ldr	r2, [r7, #12]
   1a8f4:	4413      	add	r3, r2
   1a8f6:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
   1a8f8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a8fa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a8fc:	4413      	add	r3, r2
   1a8fe:	647b      	str	r3, [r7, #68]	; 0x44
                break;
   1a900:	e135      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>

            case 'u':
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   1a902:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
   1a906:	2b00      	cmp	r3, #0
   1a908:	d009      	beq.n	1a91e <am_util_stdio_vsprintf+0x396>
   1a90a:	687b      	ldr	r3, [r7, #4]
   1a90c:	3307      	adds	r3, #7
   1a90e:	f023 0307 	bic.w	r3, r3, #7
   1a912:	f103 0208 	add.w	r2, r3, #8
   1a916:	607a      	str	r2, [r7, #4]
   1a918:	e9d3 2300 	ldrd	r2, r3, [r3]
   1a91c:	e006      	b.n	1a92c <am_util_stdio_vsprintf+0x3a4>
                                      va_arg(pArgs, uint32_t);
   1a91e:	687b      	ldr	r3, [r7, #4]
   1a920:	1d1a      	adds	r2, r3, #4
   1a922:	607a      	str	r2, [r7, #4]
   1a924:	681b      	ldr	r3, [r3, #0]
                ui64Val = bLongLong ? va_arg(pArgs, uint64_t) :
   1a926:	461a      	mov	r2, r3
   1a928:	f04f 0300 	mov.w	r3, #0
   1a92c:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48

                if ( iWidth )
   1a930:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a932:	2b00      	cmp	r3, #0
   1a934:	d01e      	beq.n	1a974 <am_util_stdio_vsprintf+0x3ec>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_u64(ui64Val);
   1a936:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   1a93a:	f7ff fb8f 	bl	1a05c <ndigits_in_u64>
   1a93e:	4602      	mov	r2, r0
   1a940:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a942:	1a9b      	subs	r3, r3, r2
   1a944:	643b      	str	r3, [r7, #64]	; 0x40

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1a946:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1a94a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1a94c:	4619      	mov	r1, r3
   1a94e:	68f8      	ldr	r0, [r7, #12]
   1a950:	f7ff fcf9 	bl	1a346 <padbuffer>
   1a954:	6438      	str	r0, [r7, #64]	; 0x40
                    pcBuf += pcBuf ? iWidth : 0;
   1a956:	68fb      	ldr	r3, [r7, #12]
   1a958:	2b00      	cmp	r3, #0
   1a95a:	d001      	beq.n	1a960 <am_util_stdio_vsprintf+0x3d8>
   1a95c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a95e:	e000      	b.n	1a962 <am_util_stdio_vsprintf+0x3da>
   1a960:	2300      	movs	r3, #0
   1a962:	68fa      	ldr	r2, [r7, #12]
   1a964:	4413      	add	r3, r2
   1a966:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
   1a968:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a96a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a96c:	4413      	add	r3, r2
   1a96e:	647b      	str	r3, [r7, #68]	; 0x44
                    iWidth = 0;
   1a970:	2300      	movs	r3, #0
   1a972:	643b      	str	r3, [r7, #64]	; 0x40
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
   1a974:	68fa      	ldr	r2, [r7, #12]
   1a976:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   1a97a:	f7ff fc1c 	bl	1a1b6 <uint64_to_str>
   1a97e:	63f8      	str	r0, [r7, #60]	; 0x3c

                if ( pcBuf )
   1a980:	68fb      	ldr	r3, [r7, #12]
   1a982:	2b00      	cmp	r3, #0
   1a984:	d003      	beq.n	1a98e <am_util_stdio_vsprintf+0x406>
                {
                    pcBuf += iVal;
   1a986:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a988:	68fa      	ldr	r2, [r7, #12]
   1a98a:	4413      	add	r3, r2
   1a98c:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
   1a98e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1a990:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1a992:	4413      	add	r3, r2
   1a994:	647b      	str	r3, [r7, #68]	; 0x44
                break;
   1a996:	e0ea      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>
                // Output for a negative number, for example, -5:
                //   %d:-5
                //  %5d:   -5
                // %05d:-0005
                //
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1a998:	f897 3035 	ldrb.w	r3, [r7, #53]	; 0x35
   1a99c:	2b00      	cmp	r3, #0
   1a99e:	d009      	beq.n	1a9b4 <am_util_stdio_vsprintf+0x42c>
   1a9a0:	687b      	ldr	r3, [r7, #4]
   1a9a2:	3307      	adds	r3, #7
   1a9a4:	f023 0307 	bic.w	r3, r3, #7
   1a9a8:	f103 0208 	add.w	r2, r3, #8
   1a9ac:	607a      	str	r2, [r7, #4]
   1a9ae:	e9d3 2300 	ldrd	r2, r3, [r3]
   1a9b2:	e006      	b.n	1a9c2 <am_util_stdio_vsprintf+0x43a>
                                     va_arg(pArgs, int32_t);
   1a9b4:	687b      	ldr	r3, [r7, #4]
   1a9b6:	1d1a      	adds	r2, r3, #4
   1a9b8:	607a      	str	r2, [r7, #4]
   1a9ba:	681b      	ldr	r3, [r3, #0]
                i64Val = bLongLong ? va_arg(pArgs, int64_t) :
   1a9bc:	461a      	mov	r2, r3
   1a9be:	ea4f 73e2 	mov.w	r3, r2, asr #31
   1a9c2:	e9c7 2308 	strd	r2, r3, [r7, #32]

                //
                // Get absolute value
                //
                if ( i64Val < 0 )
   1a9c6:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
   1a9ca:	2a00      	cmp	r2, #0
   1a9cc:	f173 0300 	sbcs.w	r3, r3, #0
   1a9d0:	da0a      	bge.n	1a9e8 <am_util_stdio_vsprintf+0x460>
                {
                    ui64Val = -i64Val;          // Get absolute value
   1a9d2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
   1a9d6:	4252      	negs	r2, r2
   1a9d8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1a9dc:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
                    bNeg = true;
   1a9e0:	2301      	movs	r3, #1
   1a9e2:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
   1a9e6:	e006      	b.n	1a9f6 <am_util_stdio_vsprintf+0x46e>
                }
                else
                {
                    ui64Val = i64Val;
   1a9e8:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
   1a9ec:	e9c7 2312 	strd	r2, r3, [r7, #72]	; 0x48
                    bNeg = false;
   1a9f0:	2300      	movs	r3, #0
   1a9f2:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
                }

                if ( iWidth )
   1a9f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1a9f8:	2b00      	cmp	r3, #0
   1a9fa:	d04a      	beq.n	1aa92 <am_util_stdio_vsprintf+0x50a>
                {
                    //
                    // We need to pad the beginning of the value.
                    // Compute # of leading chars
                    //
                    iWidth -= ndigits_in_i64(ui64Val);
   1a9fc:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   1aa00:	4610      	mov	r0, r2
   1aa02:	4619      	mov	r1, r3
   1aa04:	f7ff fb4b 	bl	1a09e <ndigits_in_i64>
   1aa08:	4602      	mov	r2, r0
   1aa0a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1aa0c:	1a9b      	subs	r3, r3, r2
   1aa0e:	643b      	str	r3, [r7, #64]	; 0x40

                    if ( bNeg )
   1aa10:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
   1aa14:	2b00      	cmp	r3, #0
   1aa16:	d011      	beq.n	1aa3c <am_util_stdio_vsprintf+0x4b4>
                    {
                        --iWidth;
   1aa18:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1aa1a:	3b01      	subs	r3, #1
   1aa1c:	643b      	str	r3, [r7, #64]	; 0x40

                        //
                        // Allow for the negative sign
                        //
                        if ( ui8PadChar == '0' )
   1aa1e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1aa22:	2b30      	cmp	r3, #48	; 0x30
   1aa24:	d10a      	bne.n	1aa3c <am_util_stdio_vsprintf+0x4b4>
                        {
                            //
                            // Print the neg sign BEFORE the leading zeros
                            //
                            if ( pcBuf )
   1aa26:	68fb      	ldr	r3, [r7, #12]
   1aa28:	2b00      	cmp	r3, #0
   1aa2a:	d004      	beq.n	1aa36 <am_util_stdio_vsprintf+0x4ae>
                            {
                                *pcBuf++ = '-';
   1aa2c:	68fb      	ldr	r3, [r7, #12]
   1aa2e:	1c5a      	adds	r2, r3, #1
   1aa30:	60fa      	str	r2, [r7, #12]
   1aa32:	222d      	movs	r2, #45	; 0x2d
   1aa34:	701a      	strb	r2, [r3, #0]
                            }

                            ++ui32CharCnt;
   1aa36:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1aa38:	3301      	adds	r3, #1
   1aa3a:	647b      	str	r3, [r7, #68]	; 0x44
                        }
                    }

                    iWidth = padbuffer(pcBuf, ui8PadChar, iWidth);
   1aa3c:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1aa40:	6c3a      	ldr	r2, [r7, #64]	; 0x40
   1aa42:	4619      	mov	r1, r3
   1aa44:	68f8      	ldr	r0, [r7, #12]
   1aa46:	f7ff fc7e 	bl	1a346 <padbuffer>
   1aa4a:	6438      	str	r0, [r7, #64]	; 0x40
                    pcBuf += pcBuf ? iWidth : 0;
   1aa4c:	68fb      	ldr	r3, [r7, #12]
   1aa4e:	2b00      	cmp	r3, #0
   1aa50:	d001      	beq.n	1aa56 <am_util_stdio_vsprintf+0x4ce>
   1aa52:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1aa54:	e000      	b.n	1aa58 <am_util_stdio_vsprintf+0x4d0>
   1aa56:	2300      	movs	r3, #0
   1aa58:	68fa      	ldr	r2, [r7, #12]
   1aa5a:	4413      	add	r3, r2
   1aa5c:	60fb      	str	r3, [r7, #12]
                    ui32CharCnt += iWidth;
   1aa5e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   1aa60:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1aa62:	4413      	add	r3, r2
   1aa64:	647b      	str	r3, [r7, #68]	; 0x44
                    iWidth = 0;
   1aa66:	2300      	movs	r3, #0
   1aa68:	643b      	str	r3, [r7, #64]	; 0x40

                    if ( bNeg  &&  (ui8PadChar == ' ') )
   1aa6a:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
   1aa6e:	2b00      	cmp	r3, #0
   1aa70:	d01e      	beq.n	1aab0 <am_util_stdio_vsprintf+0x528>
   1aa72:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   1aa76:	2b20      	cmp	r3, #32
   1aa78:	d11a      	bne.n	1aab0 <am_util_stdio_vsprintf+0x528>
                    {
                        //
                        // Print the neg sign AFTER the leading blanks
                        //
                        if ( pcBuf )
   1aa7a:	68fb      	ldr	r3, [r7, #12]
   1aa7c:	2b00      	cmp	r3, #0
   1aa7e:	d004      	beq.n	1aa8a <am_util_stdio_vsprintf+0x502>
                        {
                            *pcBuf++ = '-';
   1aa80:	68fb      	ldr	r3, [r7, #12]
   1aa82:	1c5a      	adds	r2, r3, #1
   1aa84:	60fa      	str	r2, [r7, #12]
   1aa86:	222d      	movs	r2, #45	; 0x2d
   1aa88:	701a      	strb	r2, [r3, #0]
                        }

                        ++ui32CharCnt;
   1aa8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1aa8c:	3301      	adds	r3, #1
   1aa8e:	647b      	str	r3, [r7, #68]	; 0x44
   1aa90:	e00e      	b.n	1aab0 <am_util_stdio_vsprintf+0x528>
                    }
                }
                else
                {
                    if ( bNeg )
   1aa92:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
   1aa96:	2b00      	cmp	r3, #0
   1aa98:	d00a      	beq.n	1aab0 <am_util_stdio_vsprintf+0x528>
                    {
                        if ( pcBuf )
   1aa9a:	68fb      	ldr	r3, [r7, #12]
   1aa9c:	2b00      	cmp	r3, #0
   1aa9e:	d004      	beq.n	1aaaa <am_util_stdio_vsprintf+0x522>
                        {
                            *pcBuf++ = '-';
   1aaa0:	68fb      	ldr	r3, [r7, #12]
   1aaa2:	1c5a      	adds	r2, r3, #1
   1aaa4:	60fa      	str	r2, [r7, #12]
   1aaa6:	222d      	movs	r2, #45	; 0x2d
   1aaa8:	701a      	strb	r2, [r3, #0]
                        }
                        ++ui32CharCnt;
   1aaaa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1aaac:	3301      	adds	r3, #1
   1aaae:	647b      	str	r3, [r7, #68]	; 0x44
                    }
                }

                iVal = uint64_to_str(ui64Val, pcBuf);
   1aab0:	68fa      	ldr	r2, [r7, #12]
   1aab2:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
   1aab6:	f7ff fb7e 	bl	1a1b6 <uint64_to_str>
   1aaba:	63f8      	str	r0, [r7, #60]	; 0x3c

                if ( pcBuf )
   1aabc:	68fb      	ldr	r3, [r7, #12]
   1aabe:	2b00      	cmp	r3, #0
   1aac0:	d003      	beq.n	1aaca <am_util_stdio_vsprintf+0x542>
                {
                    pcBuf += iVal;
   1aac2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1aac4:	68fa      	ldr	r2, [r7, #12]
   1aac6:	4413      	add	r3, r2
   1aac8:	60fb      	str	r3, [r7, #12]
                }

                ui32CharCnt += iVal;
   1aaca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1aacc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1aace:	4413      	add	r3, r2
   1aad0:	647b      	str	r3, [r7, #68]	; 0x44
                break;
   1aad2:	e04c      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>


            case 'f':
            case 'F':
                if ( pcBuf )
   1aad4:	68fb      	ldr	r3, [r7, #12]
   1aad6:	2b00      	cmp	r3, #0
   1aad8:	d048      	beq.n	1ab6c <am_util_stdio_vsprintf+0x5e4>
                {
                    float fValue = va_arg(pArgs, double);
   1aada:	687b      	ldr	r3, [r7, #4]
   1aadc:	3307      	adds	r3, #7
   1aade:	f023 0307 	bic.w	r3, r3, #7
   1aae2:	f103 0208 	add.w	r2, r3, #8
   1aae6:	607a      	str	r2, [r7, #4]
   1aae8:	e9d3 2300 	ldrd	r2, r3, [r3]
   1aaec:	4610      	mov	r0, r2
   1aaee:	4619      	mov	r1, r3
   1aaf0:	f7fd fe44 	bl	1877c <__aeabi_d2f>
   1aaf4:	4603      	mov	r3, r0
   1aaf6:	61bb      	str	r3, [r7, #24]

                    //
                    // pcBuf is an input (size of buffer) and also an output of ftoa()
                    //
                    *(uint32_t*)pcBuf = 20;
   1aaf8:	68fb      	ldr	r3, [r7, #12]
   1aafa:	2214      	movs	r2, #20
   1aafc:	601a      	str	r2, [r3, #0]

                    iVal = ftoa(fValue, pcBuf, iPrecision);
   1aafe:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   1ab00:	68f8      	ldr	r0, [r7, #12]
   1ab02:	ed97 0a06 	vldr	s0, [r7, #24]
   1ab06:	f7ff fc43 	bl	1a390 <ftoa>
   1ab0a:	63f8      	str	r0, [r7, #60]	; 0x3c
                    if ( iVal < 0 )
   1ab0c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab0e:	2b00      	cmp	r3, #0
   1ab10:	da14      	bge.n	1ab3c <am_util_stdio_vsprintf+0x5b4>
                    {
                        uint32_t u32PrntErrVal;
                        if ( iVal == AM_FTOA_ERR_VAL_TOO_SMALL )
   1ab12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab14:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   1ab18:	d102      	bne.n	1ab20 <am_util_stdio_vsprintf+0x598>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('0' << 16) |
   1ab1a:	4b1e      	ldr	r3, [pc, #120]	; (1ab94 <am_util_stdio_vsprintf+0x60c>)
   1ab1c:	633b      	str	r3, [r7, #48]	; 0x30
   1ab1e:	e008      	b.n	1ab32 <am_util_stdio_vsprintf+0x5aa>
                                            ('.' << 8)   | ('0' << 0);  // "0.0"
                        }
                        else if ( iVal == AM_FTOA_ERR_VAL_TOO_LARGE )
   1ab20:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab22:	f113 0f02 	cmn.w	r3, #2
   1ab26:	d102      	bne.n	1ab2e <am_util_stdio_vsprintf+0x5a6>
                        {
                            u32PrntErrVal = (0x00 << 24) | ('#' << 16) |
   1ab28:	4b1b      	ldr	r3, [pc, #108]	; (1ab98 <am_util_stdio_vsprintf+0x610>)
   1ab2a:	633b      	str	r3, [r7, #48]	; 0x30
   1ab2c:	e001      	b.n	1ab32 <am_util_stdio_vsprintf+0x5aa>
                                            ('.' << 8)   | ('#' << 0);  // "#.#"
                        }
                        else
                        {
                            u32PrntErrVal = (0x00 << 24) | ('?' << 16) |
   1ab2e:	4b1b      	ldr	r3, [pc, #108]	; (1ab9c <am_util_stdio_vsprintf+0x614>)
   1ab30:	633b      	str	r3, [r7, #48]	; 0x30
                                            ('.' << 8)   | ('?' << 0);  // "?.?"
                        }
                        *(uint32_t*)pcBuf = u32PrntErrVal;
   1ab32:	68fb      	ldr	r3, [r7, #12]
   1ab34:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   1ab36:	601a      	str	r2, [r3, #0]
                        iVal = 3;
   1ab38:	2303      	movs	r3, #3
   1ab3a:	63fb      	str	r3, [r7, #60]	; 0x3c
                    }
                    ui32CharCnt += iVal;
   1ab3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab3e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
   1ab40:	4413      	add	r3, r2
   1ab42:	647b      	str	r3, [r7, #68]	; 0x44
                    pcBuf += iVal;
   1ab44:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   1ab46:	68fa      	ldr	r2, [r7, #12]
   1ab48:	4413      	add	r3, r2
   1ab4a:	60fb      	str	r3, [r7, #12]
                }
                break;
   1ab4c:	e00e      	b.n	1ab6c <am_util_stdio_vsprintf+0x5e4>
            // For non-handled specifiers, we'll just print the character.
            // e.g. this will allow the normal printing of a '%' using
            // "%%".
            //
            default:
                if ( pcBuf )
   1ab4e:	68fb      	ldr	r3, [r7, #12]
   1ab50:	2b00      	cmp	r3, #0
   1ab52:	d005      	beq.n	1ab60 <am_util_stdio_vsprintf+0x5d8>
                {
                    *pcBuf++ = *pcFmt;
   1ab54:	68fb      	ldr	r3, [r7, #12]
   1ab56:	1c5a      	adds	r2, r3, #1
   1ab58:	60fa      	str	r2, [r7, #12]
   1ab5a:	68ba      	ldr	r2, [r7, #8]
   1ab5c:	7812      	ldrb	r2, [r2, #0]
   1ab5e:	701a      	strb	r2, [r3, #0]
                }

                ++ui32CharCnt;
   1ab60:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   1ab62:	3301      	adds	r3, #1
   1ab64:	647b      	str	r3, [r7, #68]	; 0x44
                break;
   1ab66:	e002      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>
                break;
   1ab68:	bf00      	nop
   1ab6a:	e000      	b.n	1ab6e <am_util_stdio_vsprintf+0x5e6>
                break;
   1ab6c:	bf00      	nop
        } // switch ()

        //
        // Bump the format specification to the next character
        //
        ++pcFmt;
   1ab6e:	68bb      	ldr	r3, [r7, #8]
   1ab70:	3301      	adds	r3, #1
   1ab72:	60bb      	str	r3, [r7, #8]
    while ( *pcFmt != 0x0 )
   1ab74:	68bb      	ldr	r3, [r7, #8]
   1ab76:	781b      	ldrb	r3, [r3, #0]
   1ab78:	2b00      	cmp	r3, #0
   1ab7a:	f47f ad10 	bne.w	1a59e <am_util_stdio_vsprintf+0x16>
    } // while ()

    //
    // Terminate the string
    //
    if ( pcBuf )
   1ab7e:	68fb      	ldr	r3, [r7, #12]
   1ab80:	2b00      	cmp	r3, #0
   1ab82:	d002      	beq.n	1ab8a <am_util_stdio_vsprintf+0x602>
    {
        *pcBuf = 0x0;
   1ab84:	68fb      	ldr	r3, [r7, #12]
   1ab86:	2200      	movs	r2, #0
   1ab88:	701a      	strb	r2, [r3, #0]
    }

    return (ui32CharCnt);
   1ab8a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
}
   1ab8c:	4618      	mov	r0, r3
   1ab8e:	3758      	adds	r7, #88	; 0x58
   1ab90:	46bd      	mov	sp, r7
   1ab92:	bd80      	pop	{r7, pc}
   1ab94:	00302e30 	.word	0x00302e30
   1ab98:	00232e23 	.word	0x00232e23
   1ab9c:	003f2e3f 	.word	0x003f2e3f

0001aba0 <am_util_stdio_printf>:
// A lite version of printf()
//
//*****************************************************************************
uint32_t
am_util_stdio_printf(const char *pcFmt, ...)
{
   1aba0:	b40f      	push	{r0, r1, r2, r3}
   1aba2:	b580      	push	{r7, lr}
   1aba4:	b082      	sub	sp, #8
   1aba6:	af00      	add	r7, sp, #0
    uint32_t ui32NumChars;

    if (!g_pfnCharPrint)
   1aba8:	4b0d      	ldr	r3, [pc, #52]	; (1abe0 <am_util_stdio_printf+0x40>)
   1abaa:	681b      	ldr	r3, [r3, #0]
   1abac:	2b00      	cmp	r3, #0
   1abae:	d101      	bne.n	1abb4 <am_util_stdio_printf+0x14>
    {
        return 0;
   1abb0:	2300      	movs	r3, #0
   1abb2:	e00d      	b.n	1abd0 <am_util_stdio_printf+0x30>

    //
    // Convert to the desired string.
    //
    va_list pArgs;
    va_start(pArgs, pcFmt);
   1abb4:	f107 0314 	add.w	r3, r7, #20
   1abb8:	603b      	str	r3, [r7, #0]
    ui32NumChars = am_util_stdio_vsprintf(g_prfbuf, pcFmt, pArgs);
   1abba:	683a      	ldr	r2, [r7, #0]
   1abbc:	6939      	ldr	r1, [r7, #16]
   1abbe:	4809      	ldr	r0, [pc, #36]	; (1abe4 <am_util_stdio_printf+0x44>)
   1abc0:	f7ff fce2 	bl	1a588 <am_util_stdio_vsprintf>
   1abc4:	6078      	str	r0, [r7, #4]
    va_end(pArgs);

    //
    // This is where we print the buffer to the configured interface.
    //
    g_pfnCharPrint(g_prfbuf);
   1abc6:	4b06      	ldr	r3, [pc, #24]	; (1abe0 <am_util_stdio_printf+0x40>)
   1abc8:	681b      	ldr	r3, [r3, #0]
   1abca:	4806      	ldr	r0, [pc, #24]	; (1abe4 <am_util_stdio_printf+0x44>)
   1abcc:	4798      	blx	r3

    //
    // return the number of characters printed.
    //
    return ui32NumChars;
   1abce:	687b      	ldr	r3, [r7, #4]
}
   1abd0:	4618      	mov	r0, r3
   1abd2:	3708      	adds	r7, #8
   1abd4:	46bd      	mov	sp, r7
   1abd6:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   1abda:	b004      	add	sp, #16
   1abdc:	4770      	bx	lr
   1abde:	bf00      	nop
   1abe0:	10010e90 	.word	0x10010e90
   1abe4:	100038bc 	.word	0x100038bc

0001abe8 <AppDbInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbInit(void)
{
   1abe8:	b480      	push	{r7}
   1abea:	af00      	add	r7, sp, #0
#ifdef AM_BLE_USE_NVM
    AppCopyRecListInNvm(pAppDbNewRec);
#endif
  return;
   1abec:	bf00      	nop
}
   1abee:	46bd      	mov	sp, r7
   1abf0:	f85d 7b04 	ldr.w	r7, [sp], #4
   1abf4:	4770      	bx	lr
	...

0001abf8 <AppDbNewRecord>:
 *
 *  \return Database record handle.
 */
/*************************************************************************************************/
appDbHdl_t AppDbNewRecord(uint8_t addrType, uint8_t *pAddr, bool_t master_role)
{
   1abf8:	b580      	push	{r7, lr}
   1abfa:	b084      	sub	sp, #16
   1abfc:	af00      	add	r7, sp, #0
   1abfe:	4603      	mov	r3, r0
   1ac00:	6039      	str	r1, [r7, #0]
   1ac02:	71fb      	strb	r3, [r7, #7]
   1ac04:	4613      	mov	r3, r2
   1ac06:	71bb      	strb	r3, [r7, #6]
  appDbRec_t  *pRec = appDb.rec;
   1ac08:	4b24      	ldr	r3, [pc, #144]	; (1ac9c <AppDbNewRecord+0xa4>)
   1ac0a:	60fb      	str	r3, [r7, #12]
  uint8_t     i;

  /* find a free record */
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ac0c:	2303      	movs	r3, #3
   1ac0e:	72fb      	strb	r3, [r7, #11]
   1ac10:	e00a      	b.n	1ac28 <AppDbNewRecord+0x30>
  {
    if (!pRec->inUse)
   1ac12:	68fb      	ldr	r3, [r7, #12]
   1ac14:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1ac18:	2b00      	cmp	r3, #0
   1ac1a:	d009      	beq.n	1ac30 <AppDbNewRecord+0x38>
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ac1c:	7afb      	ldrb	r3, [r7, #11]
   1ac1e:	3b01      	subs	r3, #1
   1ac20:	72fb      	strb	r3, [r7, #11]
   1ac22:	68fb      	ldr	r3, [r7, #12]
   1ac24:	33c4      	adds	r3, #196	; 0xc4
   1ac26:	60fb      	str	r3, [r7, #12]
   1ac28:	7afb      	ldrb	r3, [r7, #11]
   1ac2a:	2b00      	cmp	r3, #0
   1ac2c:	d1f1      	bne.n	1ac12 <AppDbNewRecord+0x1a>
   1ac2e:	e000      	b.n	1ac32 <AppDbNewRecord+0x3a>
    {
      break;
   1ac30:	bf00      	nop
    }
  }

  /* if all records were allocated */
  if (i == 0)
   1ac32:	7afb      	ldrb	r3, [r7, #11]
   1ac34:	2b00      	cmp	r3, #0
   1ac36:	d10f      	bne.n	1ac58 <AppDbNewRecord+0x60>
  {
    /* overwrite a record */
    pRec = pAppDbNewRec;
   1ac38:	4b19      	ldr	r3, [pc, #100]	; (1aca0 <AppDbNewRecord+0xa8>)
   1ac3a:	681b      	ldr	r3, [r3, #0]
   1ac3c:	60fb      	str	r3, [r7, #12]

    /* get next record to overwrite */
    pAppDbNewRec++;
   1ac3e:	4b18      	ldr	r3, [pc, #96]	; (1aca0 <AppDbNewRecord+0xa8>)
   1ac40:	681b      	ldr	r3, [r3, #0]
   1ac42:	33c4      	adds	r3, #196	; 0xc4
   1ac44:	4a16      	ldr	r2, [pc, #88]	; (1aca0 <AppDbNewRecord+0xa8>)
   1ac46:	6013      	str	r3, [r2, #0]
    if (pAppDbNewRec == &appDb.rec[APP_DB_NUM_RECS])
   1ac48:	4b15      	ldr	r3, [pc, #84]	; (1aca0 <AppDbNewRecord+0xa8>)
   1ac4a:	681b      	ldr	r3, [r3, #0]
   1ac4c:	4a15      	ldr	r2, [pc, #84]	; (1aca4 <AppDbNewRecord+0xac>)
   1ac4e:	4293      	cmp	r3, r2
   1ac50:	d102      	bne.n	1ac58 <AppDbNewRecord+0x60>
    {
      pAppDbNewRec = appDb.rec;
   1ac52:	4b13      	ldr	r3, [pc, #76]	; (1aca0 <AppDbNewRecord+0xa8>)
   1ac54:	4a11      	ldr	r2, [pc, #68]	; (1ac9c <AppDbNewRecord+0xa4>)
   1ac56:	601a      	str	r2, [r3, #0]
    }
  }

  /* initialize record */
  memset(pRec, 0, sizeof(appDbRec_t));
   1ac58:	22c4      	movs	r2, #196	; 0xc4
   1ac5a:	2100      	movs	r1, #0
   1ac5c:	68f8      	ldr	r0, [r7, #12]
   1ac5e:	f015 fa47 	bl	300f0 <memset>
  pRec->inUse = TRUE;
   1ac62:	68fb      	ldr	r3, [r7, #12]
   1ac64:	2201      	movs	r2, #1
   1ac66:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  pRec->addrType = addrType;
   1ac6a:	68fb      	ldr	r3, [r7, #12]
   1ac6c:	79fa      	ldrb	r2, [r7, #7]
   1ac6e:	719a      	strb	r2, [r3, #6]
  BdaCpy(pRec->peerAddr, pAddr);
   1ac70:	68fb      	ldr	r3, [r7, #12]
   1ac72:	6839      	ldr	r1, [r7, #0]
   1ac74:	4618      	mov	r0, r3
   1ac76:	f006 ff86 	bl	21b86 <BdaCpy>
  pRec->peerAddedToRl = FALSE;
   1ac7a:	68fb      	ldr	r3, [r7, #12]
   1ac7c:	2200      	movs	r2, #0
   1ac7e:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
  pRec->peerRpao = FALSE;
   1ac82:	68fb      	ldr	r3, [r7, #12]
   1ac84:	2200      	movs	r2, #0
   1ac86:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
  pRec->master_role = master_role;
   1ac8a:	68fb      	ldr	r3, [r7, #12]
   1ac8c:	79ba      	ldrb	r2, [r7, #6]
   1ac8e:	f883 20c3 	strb.w	r2, [r3, #195]	; 0xc3

  return (appDbHdl_t) pRec;
   1ac92:	68fb      	ldr	r3, [r7, #12]
}
   1ac94:	4618      	mov	r0, r3
   1ac96:	3710      	adds	r7, #16
   1ac98:	46bd      	mov	sp, r7
   1ac9a:	bd80      	pop	{r7, pc}
   1ac9c:	10003cc0 	.word	0x10003cc0
   1aca0:	10002b2c 	.word	0x10002b2c
   1aca4:	10003f0c 	.word	0x10003f0c

0001aca8 <AppDbGetNextRecord>:
*
*  \return Next record handle found. APP_DB_HDL_NONE, otherwise.
*/
/*************************************************************************************************/
appDbHdl_t AppDbGetNextRecord(appDbHdl_t hdl)
{
   1aca8:	b580      	push	{r7, lr}
   1acaa:	b084      	sub	sp, #16
   1acac:	af00      	add	r7, sp, #0
   1acae:	6078      	str	r0, [r7, #4]
  appDbRec_t  *pRec;

  /* if first record is requested */
  if (hdl == APP_DB_HDL_NONE)
   1acb0:	687b      	ldr	r3, [r7, #4]
   1acb2:	2b00      	cmp	r3, #0
   1acb4:	d102      	bne.n	1acbc <AppDbGetNextRecord+0x14>
  {
    pRec = appDb.rec;
   1acb6:	4b14      	ldr	r3, [pc, #80]	; (1ad08 <AppDbGetNextRecord+0x60>)
   1acb8:	60fb      	str	r3, [r7, #12]
   1acba:	e01c      	b.n	1acf6 <AppDbGetNextRecord+0x4e>
  }
  /* if valid record passed in */
  else if (AppDbRecordInUse(hdl))
   1acbc:	6878      	ldr	r0, [r7, #4]
   1acbe:	f000 f859 	bl	1ad74 <AppDbRecordInUse>
   1acc2:	4603      	mov	r3, r0
   1acc4:	2b00      	cmp	r3, #0
   1acc6:	d005      	beq.n	1acd4 <AppDbGetNextRecord+0x2c>
  {
    pRec = (appDbRec_t *)hdl;
   1acc8:	687b      	ldr	r3, [r7, #4]
   1acca:	60fb      	str	r3, [r7, #12]
    pRec++;
   1accc:	68fb      	ldr	r3, [r7, #12]
   1acce:	33c4      	adds	r3, #196	; 0xc4
   1acd0:	60fb      	str	r3, [r7, #12]
   1acd2:	e010      	b.n	1acf6 <AppDbGetNextRecord+0x4e>
  }
  /* invalid record passed in */
  else
  {
    return APP_DB_HDL_NONE;
   1acd4:	2300      	movs	r3, #0
   1acd6:	e013      	b.n	1ad00 <AppDbGetNextRecord+0x58>

  /* look for next valid record */
  while (pRec < &appDb.rec[APP_DB_NUM_RECS])
  {
    /* if record is in use */
    if (pRec->inUse && pRec->valid)
   1acd8:	68fb      	ldr	r3, [r7, #12]
   1acda:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1acde:	2b00      	cmp	r3, #0
   1ace0:	d006      	beq.n	1acf0 <AppDbGetNextRecord+0x48>
   1ace2:	68fb      	ldr	r3, [r7, #12]
   1ace4:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1ace8:	2b00      	cmp	r3, #0
   1acea:	d001      	beq.n	1acf0 <AppDbGetNextRecord+0x48>
    {
      /* record found */
      return (appDbHdl_t)pRec;
   1acec:	68fb      	ldr	r3, [r7, #12]
   1acee:	e007      	b.n	1ad00 <AppDbGetNextRecord+0x58>
    }

    /* look for next record */
    pRec++;
   1acf0:	68fb      	ldr	r3, [r7, #12]
   1acf2:	33c4      	adds	r3, #196	; 0xc4
   1acf4:	60fb      	str	r3, [r7, #12]
  while (pRec < &appDb.rec[APP_DB_NUM_RECS])
   1acf6:	68fb      	ldr	r3, [r7, #12]
   1acf8:	4a04      	ldr	r2, [pc, #16]	; (1ad0c <AppDbGetNextRecord+0x64>)
   1acfa:	4293      	cmp	r3, r2
   1acfc:	d3ec      	bcc.n	1acd8 <AppDbGetNextRecord+0x30>
  }

  /* end of records */
  return APP_DB_HDL_NONE;
   1acfe:	2300      	movs	r3, #0
}
   1ad00:	4618      	mov	r0, r3
   1ad02:	3710      	adds	r7, #16
   1ad04:	46bd      	mov	sp, r7
   1ad06:	bd80      	pop	{r7, pc}
   1ad08:	10003cc0 	.word	0x10003cc0
   1ad0c:	10003f0c 	.word	0x10003f0c

0001ad10 <AppDbDeleteRecord>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbDeleteRecord(appDbHdl_t hdl)
{
   1ad10:	b480      	push	{r7}
   1ad12:	b083      	sub	sp, #12
   1ad14:	af00      	add	r7, sp, #0
   1ad16:	6078      	str	r0, [r7, #4]
  ((appDbRec_t *) hdl)->inUse = FALSE;
   1ad18:	687b      	ldr	r3, [r7, #4]
   1ad1a:	2200      	movs	r2, #0
   1ad1c:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
}
   1ad20:	bf00      	nop
   1ad22:	370c      	adds	r7, #12
   1ad24:	46bd      	mov	sp, r7
   1ad26:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ad2a:	4770      	bx	lr

0001ad2c <AppDbValidateRecord>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbValidateRecord(appDbHdl_t hdl, uint8_t keyMask)
{
   1ad2c:	b480      	push	{r7}
   1ad2e:	b083      	sub	sp, #12
   1ad30:	af00      	add	r7, sp, #0
   1ad32:	6078      	str	r0, [r7, #4]
   1ad34:	460b      	mov	r3, r1
   1ad36:	70fb      	strb	r3, [r7, #3]
  ((appDbRec_t *) hdl)->valid = TRUE;
   1ad38:	687b      	ldr	r3, [r7, #4]
   1ad3a:	2201      	movs	r2, #1
   1ad3c:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  ((appDbRec_t *) hdl)->keyValidMask = keyMask;
   1ad40:	687b      	ldr	r3, [r7, #4]
   1ad42:	78fa      	ldrb	r2, [r7, #3]
   1ad44:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

#ifdef AM_BLE_USE_NVM
  AppStorePairingInfoInNVM(hdl);
#endif
}
   1ad48:	bf00      	nop
   1ad4a:	370c      	adds	r7, #12
   1ad4c:	46bd      	mov	sp, r7
   1ad4e:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ad52:	4770      	bx	lr

0001ad54 <AppDbCheckValidRecord>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbCheckValidRecord(appDbHdl_t hdl)
{
   1ad54:	b580      	push	{r7, lr}
   1ad56:	b082      	sub	sp, #8
   1ad58:	af00      	add	r7, sp, #0
   1ad5a:	6078      	str	r0, [r7, #4]
  if (((appDbRec_t *) hdl)->valid == FALSE)
   1ad5c:	687b      	ldr	r3, [r7, #4]
   1ad5e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1ad62:	2b00      	cmp	r3, #0
   1ad64:	d102      	bne.n	1ad6c <AppDbCheckValidRecord+0x18>
  {
    AppDbDeleteRecord(hdl);
   1ad66:	6878      	ldr	r0, [r7, #4]
   1ad68:	f7ff ffd2 	bl	1ad10 <AppDbDeleteRecord>
  }
}
   1ad6c:	bf00      	nop
   1ad6e:	3708      	adds	r7, #8
   1ad70:	46bd      	mov	sp, r7
   1ad72:	bd80      	pop	{r7, pc}

0001ad74 <AppDbRecordInUse>:
*
*  \return TURE if record in use. FALSE, otherwise.
*/
/*************************************************************************************************/
bool_t AppDbRecordInUse(appDbHdl_t hdl)
{
   1ad74:	b480      	push	{r7}
   1ad76:	b085      	sub	sp, #20
   1ad78:	af00      	add	r7, sp, #0
   1ad7a:	6078      	str	r0, [r7, #4]
  appDbRec_t  *pRec = appDb.rec;
   1ad7c:	4b12      	ldr	r3, [pc, #72]	; (1adc8 <AppDbRecordInUse+0x54>)
   1ad7e:	60fb      	str	r3, [r7, #12]
  uint8_t     i;

  /* see if record is in database record list */
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ad80:	2303      	movs	r3, #3
   1ad82:	72fb      	strb	r3, [r7, #11]
   1ad84:	e015      	b.n	1adb2 <AppDbRecordInUse+0x3e>
  {
    if (pRec->inUse && pRec->valid && (pRec == ((appDbRec_t *)hdl)))
   1ad86:	68fb      	ldr	r3, [r7, #12]
   1ad88:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1ad8c:	2b00      	cmp	r3, #0
   1ad8e:	d00a      	beq.n	1ada6 <AppDbRecordInUse+0x32>
   1ad90:	68fb      	ldr	r3, [r7, #12]
   1ad92:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
   1ad96:	2b00      	cmp	r3, #0
   1ad98:	d005      	beq.n	1ada6 <AppDbRecordInUse+0x32>
   1ad9a:	68fa      	ldr	r2, [r7, #12]
   1ad9c:	687b      	ldr	r3, [r7, #4]
   1ad9e:	429a      	cmp	r2, r3
   1ada0:	d101      	bne.n	1ada6 <AppDbRecordInUse+0x32>
    {
      return TRUE;
   1ada2:	2301      	movs	r3, #1
   1ada4:	e009      	b.n	1adba <AppDbRecordInUse+0x46>
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ada6:	7afb      	ldrb	r3, [r7, #11]
   1ada8:	3b01      	subs	r3, #1
   1adaa:	72fb      	strb	r3, [r7, #11]
   1adac:	68fb      	ldr	r3, [r7, #12]
   1adae:	33c4      	adds	r3, #196	; 0xc4
   1adb0:	60fb      	str	r3, [r7, #12]
   1adb2:	7afb      	ldrb	r3, [r7, #11]
   1adb4:	2b00      	cmp	r3, #0
   1adb6:	d1e6      	bne.n	1ad86 <AppDbRecordInUse+0x12>
    }
  }

  return FALSE;
   1adb8:	2300      	movs	r3, #0
}
   1adba:	4618      	mov	r0, r3
   1adbc:	3714      	adds	r7, #20
   1adbe:	46bd      	mov	sp, r7
   1adc0:	f85d 7b04 	ldr.w	r7, [sp], #4
   1adc4:	4770      	bx	lr
   1adc6:	bf00      	nop
   1adc8:	10003cc0 	.word	0x10003cc0

0001adcc <AppDbCheckBonded>:
 *
 *  \return TRUE if a bonded device is found, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t AppDbCheckBonded(void)
{
   1adcc:	b480      	push	{r7}
   1adce:	b083      	sub	sp, #12
   1add0:	af00      	add	r7, sp, #0
  appDbRec_t  *pRec = appDb.rec;
   1add2:	4b10      	ldr	r3, [pc, #64]	; (1ae14 <AppDbCheckBonded+0x48>)
   1add4:	607b      	str	r3, [r7, #4]
  uint8_t     i;

  /* find a record */
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1add6:	2303      	movs	r3, #3
   1add8:	70fb      	strb	r3, [r7, #3]
   1adda:	e011      	b.n	1ae00 <AppDbCheckBonded+0x34>
  {
    if (pRec->inUse && !pRec->master_role)
   1addc:	687b      	ldr	r3, [r7, #4]
   1adde:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1ade2:	2b00      	cmp	r3, #0
   1ade4:	d006      	beq.n	1adf4 <AppDbCheckBonded+0x28>
   1ade6:	687b      	ldr	r3, [r7, #4]
   1ade8:	f893 30c3 	ldrb.w	r3, [r3, #195]	; 0xc3
   1adec:	2b00      	cmp	r3, #0
   1adee:	d101      	bne.n	1adf4 <AppDbCheckBonded+0x28>
    {
      return TRUE;
   1adf0:	2301      	movs	r3, #1
   1adf2:	e009      	b.n	1ae08 <AppDbCheckBonded+0x3c>
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1adf4:	78fb      	ldrb	r3, [r7, #3]
   1adf6:	3b01      	subs	r3, #1
   1adf8:	70fb      	strb	r3, [r7, #3]
   1adfa:	687b      	ldr	r3, [r7, #4]
   1adfc:	33c4      	adds	r3, #196	; 0xc4
   1adfe:	607b      	str	r3, [r7, #4]
   1ae00:	78fb      	ldrb	r3, [r7, #3]
   1ae02:	2b00      	cmp	r3, #0
   1ae04:	d1ea      	bne.n	1addc <AppDbCheckBonded+0x10>
    }
  }

  return FALSE;
   1ae06:	2300      	movs	r3, #0
}
   1ae08:	4618      	mov	r0, r3
   1ae0a:	370c      	adds	r7, #12
   1ae0c:	46bd      	mov	sp, r7
   1ae0e:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ae12:	4770      	bx	lr
   1ae14:	10003cc0 	.word	0x10003cc0

0001ae18 <AppDbFindByAddr>:
 *
 *  \return Database record handle or APP_DB_HDL_NONE if not found.
 */
/*************************************************************************************************/
appDbHdl_t AppDbFindByAddr(uint8_t addrType, uint8_t *pAddr)
{
   1ae18:	b580      	push	{r7, lr}
   1ae1a:	b084      	sub	sp, #16
   1ae1c:	af00      	add	r7, sp, #0
   1ae1e:	4603      	mov	r3, r0
   1ae20:	6039      	str	r1, [r7, #0]
   1ae22:	71fb      	strb	r3, [r7, #7]
  appDbRec_t  *pRec = appDb.rec;
   1ae24:	4b16      	ldr	r3, [pc, #88]	; (1ae80 <AppDbFindByAddr+0x68>)
   1ae26:	60fb      	str	r3, [r7, #12]
  uint8_t     peerAddrType = DmHostAddrType(addrType);
   1ae28:	79fb      	ldrb	r3, [r7, #7]
   1ae2a:	4618      	mov	r0, r3
   1ae2c:	f009 f87a 	bl	23f24 <DmHostAddrType>
   1ae30:	4603      	mov	r3, r0
   1ae32:	72bb      	strb	r3, [r7, #10]
  uint8_t     i;

  /* find matching record */
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ae34:	2303      	movs	r3, #3
   1ae36:	72fb      	strb	r3, [r7, #11]
   1ae38:	e019      	b.n	1ae6e <AppDbFindByAddr+0x56>
  {
    if (pRec->inUse && (pRec->addrType == peerAddrType) && BdaCmp(pRec->peerAddr, pAddr))
   1ae3a:	68fb      	ldr	r3, [r7, #12]
   1ae3c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1ae40:	2b00      	cmp	r3, #0
   1ae42:	d00e      	beq.n	1ae62 <AppDbFindByAddr+0x4a>
   1ae44:	68fb      	ldr	r3, [r7, #12]
   1ae46:	799b      	ldrb	r3, [r3, #6]
   1ae48:	7aba      	ldrb	r2, [r7, #10]
   1ae4a:	429a      	cmp	r2, r3
   1ae4c:	d109      	bne.n	1ae62 <AppDbFindByAddr+0x4a>
   1ae4e:	68fb      	ldr	r3, [r7, #12]
   1ae50:	6839      	ldr	r1, [r7, #0]
   1ae52:	4618      	mov	r0, r3
   1ae54:	f006 fea5 	bl	21ba2 <BdaCmp>
   1ae58:	4603      	mov	r3, r0
   1ae5a:	2b00      	cmp	r3, #0
   1ae5c:	d001      	beq.n	1ae62 <AppDbFindByAddr+0x4a>
    {
      return (appDbHdl_t) pRec;
   1ae5e:	68fb      	ldr	r3, [r7, #12]
   1ae60:	e009      	b.n	1ae76 <AppDbFindByAddr+0x5e>
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ae62:	7afb      	ldrb	r3, [r7, #11]
   1ae64:	3b01      	subs	r3, #1
   1ae66:	72fb      	strb	r3, [r7, #11]
   1ae68:	68fb      	ldr	r3, [r7, #12]
   1ae6a:	33c4      	adds	r3, #196	; 0xc4
   1ae6c:	60fb      	str	r3, [r7, #12]
   1ae6e:	7afb      	ldrb	r3, [r7, #11]
   1ae70:	2b00      	cmp	r3, #0
   1ae72:	d1e2      	bne.n	1ae3a <AppDbFindByAddr+0x22>
    }
  }

  return APP_DB_HDL_NONE;
   1ae74:	2300      	movs	r3, #0
}
   1ae76:	4618      	mov	r0, r3
   1ae78:	3710      	adds	r7, #16
   1ae7a:	46bd      	mov	sp, r7
   1ae7c:	bd80      	pop	{r7, pc}
   1ae7e:	bf00      	nop
   1ae80:	10003cc0 	.word	0x10003cc0

0001ae84 <AppDbFindByLtkReq>:
 *
 *  \return Database record handle or APP_DB_HDL_NONE if not found.
 */
/*************************************************************************************************/
appDbHdl_t AppDbFindByLtkReq(uint16_t encDiversifier, uint8_t *pRandNum)
{
   1ae84:	b580      	push	{r7, lr}
   1ae86:	b084      	sub	sp, #16
   1ae88:	af00      	add	r7, sp, #0
   1ae8a:	4603      	mov	r3, r0
   1ae8c:	6039      	str	r1, [r7, #0]
   1ae8e:	80fb      	strh	r3, [r7, #6]
  appDbRec_t  *pRec = appDb.rec;
   1ae90:	4b14      	ldr	r3, [pc, #80]	; (1aee4 <AppDbFindByLtkReq+0x60>)
   1ae92:	60fb      	str	r3, [r7, #12]
  uint8_t     i;

  /* find matching record */
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1ae94:	2303      	movs	r3, #3
   1ae96:	72fb      	strb	r3, [r7, #11]
   1ae98:	e01c      	b.n	1aed4 <AppDbFindByLtkReq+0x50>
  {
    if (pRec->inUse && (pRec->localLtk.ediv == encDiversifier) &&
   1ae9a:	68fb      	ldr	r3, [r7, #12]
   1ae9c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1aea0:	2b00      	cmp	r3, #0
   1aea2:	d011      	beq.n	1aec8 <AppDbFindByLtkReq+0x44>
   1aea4:	68fb      	ldr	r3, [r7, #12]
   1aea6:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
   1aeaa:	88fa      	ldrh	r2, [r7, #6]
   1aeac:	429a      	cmp	r2, r3
   1aeae:	d10b      	bne.n	1aec8 <AppDbFindByLtkReq+0x44>
        (memcmp(pRec->localLtk.rand, pRandNum, SMP_RAND8_LEN) == 0))
   1aeb0:	68fb      	ldr	r3, [r7, #12]
   1aeb2:	3344      	adds	r3, #68	; 0x44
   1aeb4:	2208      	movs	r2, #8
   1aeb6:	6839      	ldr	r1, [r7, #0]
   1aeb8:	4618      	mov	r0, r3
   1aeba:	f015 f87d 	bl	2ffb8 <memcmp>
   1aebe:	4603      	mov	r3, r0
    if (pRec->inUse && (pRec->localLtk.ediv == encDiversifier) &&
   1aec0:	2b00      	cmp	r3, #0
   1aec2:	d101      	bne.n	1aec8 <AppDbFindByLtkReq+0x44>
    {
      return (appDbHdl_t) pRec;
   1aec4:	68fb      	ldr	r3, [r7, #12]
   1aec6:	e009      	b.n	1aedc <AppDbFindByLtkReq+0x58>
  for (i = APP_DB_NUM_RECS; i > 0; i--, pRec++)
   1aec8:	7afb      	ldrb	r3, [r7, #11]
   1aeca:	3b01      	subs	r3, #1
   1aecc:	72fb      	strb	r3, [r7, #11]
   1aece:	68fb      	ldr	r3, [r7, #12]
   1aed0:	33c4      	adds	r3, #196	; 0xc4
   1aed2:	60fb      	str	r3, [r7, #12]
   1aed4:	7afb      	ldrb	r3, [r7, #11]
   1aed6:	2b00      	cmp	r3, #0
   1aed8:	d1df      	bne.n	1ae9a <AppDbFindByLtkReq+0x16>
    }
  }

  return APP_DB_HDL_NONE;
   1aeda:	2300      	movs	r3, #0
}
   1aedc:	4618      	mov	r0, r3
   1aede:	3710      	adds	r7, #16
   1aee0:	46bd      	mov	sp, r7
   1aee2:	bd80      	pop	{r7, pc}
   1aee4:	10003cc0 	.word	0x10003cc0

0001aee8 <AppDbGetKey>:
 *
 *  \return Pointer to key if key is valid or NULL if not valid.
 */
/*************************************************************************************************/
dmSecKey_t *AppDbGetKey(appDbHdl_t hdl, uint8_t type, uint8_t *pSecLevel)
{
   1aee8:	b480      	push	{r7}
   1aeea:	b087      	sub	sp, #28
   1aeec:	af00      	add	r7, sp, #0
   1aeee:	60f8      	str	r0, [r7, #12]
   1aef0:	460b      	mov	r3, r1
   1aef2:	607a      	str	r2, [r7, #4]
   1aef4:	72fb      	strb	r3, [r7, #11]
  dmSecKey_t *pKey = NULL;
   1aef6:	2300      	movs	r3, #0
   1aef8:	617b      	str	r3, [r7, #20]

  /* if key valid */
  if ((type & ((appDbRec_t *) hdl)->keyValidMask) != 0)
   1aefa:	68fb      	ldr	r3, [r7, #12]
   1aefc:	f893 202e 	ldrb.w	r2, [r3, #46]	; 0x2e
   1af00:	7afb      	ldrb	r3, [r7, #11]
   1af02:	4013      	ands	r3, r2
   1af04:	b2db      	uxtb	r3, r3
   1af06:	2b00      	cmp	r3, #0
   1af08:	d030      	beq.n	1af6c <AppDbGetKey+0x84>
  {
    switch(type)
   1af0a:	7afb      	ldrb	r3, [r7, #11]
   1af0c:	3b01      	subs	r3, #1
   1af0e:	2b07      	cmp	r3, #7
   1af10:	d82e      	bhi.n	1af70 <AppDbGetKey+0x88>
   1af12:	a201      	add	r2, pc, #4	; (adr r2, 1af18 <AppDbGetKey+0x30>)
   1af14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1af18:	0001af39 	.word	0x0001af39
   1af1c:	0001af4b 	.word	0x0001af4b
   1af20:	0001af71 	.word	0x0001af71
   1af24:	0001af5d 	.word	0x0001af5d
   1af28:	0001af71 	.word	0x0001af71
   1af2c:	0001af71 	.word	0x0001af71
   1af30:	0001af71 	.word	0x0001af71
   1af34:	0001af65 	.word	0x0001af65
    {
      case DM_KEY_LOCAL_LTK:
        *pSecLevel = ((appDbRec_t *) hdl)->localLtkSecLevel;
   1af38:	68fb      	ldr	r3, [r7, #12]
   1af3a:	f893 204e 	ldrb.w	r2, [r3, #78]	; 0x4e
   1af3e:	687b      	ldr	r3, [r7, #4]
   1af40:	701a      	strb	r2, [r3, #0]
        pKey = (dmSecKey_t *) &((appDbRec_t *) hdl)->localLtk;
   1af42:	68fb      	ldr	r3, [r7, #12]
   1af44:	3334      	adds	r3, #52	; 0x34
   1af46:	617b      	str	r3, [r7, #20]
        break;
   1af48:	e013      	b.n	1af72 <AppDbGetKey+0x8a>

      case DM_KEY_PEER_LTK:
        *pSecLevel = ((appDbRec_t *) hdl)->peerLtkSecLevel;
   1af4a:	68fb      	ldr	r3, [r7, #12]
   1af4c:	f893 206a 	ldrb.w	r2, [r3, #106]	; 0x6a
   1af50:	687b      	ldr	r3, [r7, #4]
   1af52:	701a      	strb	r2, [r3, #0]
        pKey = (dmSecKey_t *) &((appDbRec_t *) hdl)->peerLtk;
   1af54:	68fb      	ldr	r3, [r7, #12]
   1af56:	3350      	adds	r3, #80	; 0x50
   1af58:	617b      	str	r3, [r7, #20]
        break;
   1af5a:	e00a      	b.n	1af72 <AppDbGetKey+0x8a>

      case DM_KEY_IRK:
        pKey = (dmSecKey_t *)&((appDbRec_t *)hdl)->peerIrk;
   1af5c:	68fb      	ldr	r3, [r7, #12]
   1af5e:	3307      	adds	r3, #7
   1af60:	617b      	str	r3, [r7, #20]
        break;
   1af62:	e006      	b.n	1af72 <AppDbGetKey+0x8a>

      case DM_KEY_CSRK:
        pKey = (dmSecKey_t *)&((appDbRec_t *)hdl)->peerCsrk;
   1af64:	68fb      	ldr	r3, [r7, #12]
   1af66:	331e      	adds	r3, #30
   1af68:	617b      	str	r3, [r7, #20]
        break;
   1af6a:	e002      	b.n	1af72 <AppDbGetKey+0x8a>

      default:
        break;
    }
  }
   1af6c:	bf00      	nop
   1af6e:	e000      	b.n	1af72 <AppDbGetKey+0x8a>
        break;
   1af70:	bf00      	nop

  return pKey;
   1af72:	697b      	ldr	r3, [r7, #20]
}
   1af74:	4618      	mov	r0, r3
   1af76:	371c      	adds	r7, #28
   1af78:	46bd      	mov	sp, r7
   1af7a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1af7e:	4770      	bx	lr

0001af80 <AppDbSetKey>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbSetKey(appDbHdl_t hdl, dmSecKeyIndEvt_t *pKey)
{
   1af80:	b5b0      	push	{r4, r5, r7, lr}
   1af82:	b082      	sub	sp, #8
   1af84:	af00      	add	r7, sp, #0
   1af86:	6078      	str	r0, [r7, #4]
   1af88:	6039      	str	r1, [r7, #0]
  switch(pKey->type)
   1af8a:	683b      	ldr	r3, [r7, #0]
   1af8c:	7f9b      	ldrb	r3, [r3, #30]
   1af8e:	3b01      	subs	r3, #1
   1af90:	2b07      	cmp	r3, #7
   1af92:	d86c      	bhi.n	1b06e <AppDbSetKey+0xee>
   1af94:	a201      	add	r2, pc, #4	; (adr r2, 1af9c <AppDbSetKey+0x1c>)
   1af96:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1af9a:	bf00      	nop
   1af9c:	0001afbd 	.word	0x0001afbd
   1afa0:	0001afe7 	.word	0x0001afe7
   1afa4:	0001b06f 	.word	0x0001b06f
   1afa8:	0001b011 	.word	0x0001b011
   1afac:	0001b06f 	.word	0x0001b06f
   1afb0:	0001b06f 	.word	0x0001b06f
   1afb4:	0001b06f 	.word	0x0001b06f
   1afb8:	0001b04d 	.word	0x0001b04d
  {
    case DM_KEY_LOCAL_LTK:
      ((appDbRec_t *) hdl)->localLtkSecLevel = pKey->secLevel;
   1afbc:	683b      	ldr	r3, [r7, #0]
   1afbe:	7fda      	ldrb	r2, [r3, #31]
   1afc0:	687b      	ldr	r3, [r7, #4]
   1afc2:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
      ((appDbRec_t *) hdl)->localLtk = pKey->keyData.ltk;
   1afc6:	687a      	ldr	r2, [r7, #4]
   1afc8:	683b      	ldr	r3, [r7, #0]
   1afca:	f102 0434 	add.w	r4, r2, #52	; 0x34
   1afce:	1d1d      	adds	r5, r3, #4
   1afd0:	6828      	ldr	r0, [r5, #0]
   1afd2:	6869      	ldr	r1, [r5, #4]
   1afd4:	68aa      	ldr	r2, [r5, #8]
   1afd6:	68eb      	ldr	r3, [r5, #12]
   1afd8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1afda:	6928      	ldr	r0, [r5, #16]
   1afdc:	6969      	ldr	r1, [r5, #20]
   1afde:	c403      	stmia	r4!, {r0, r1}
   1afe0:	8b2b      	ldrh	r3, [r5, #24]
   1afe2:	8023      	strh	r3, [r4, #0]
      break;
   1afe4:	e044      	b.n	1b070 <AppDbSetKey+0xf0>

    case DM_KEY_PEER_LTK:
      ((appDbRec_t *) hdl)->peerLtkSecLevel = pKey->secLevel;
   1afe6:	683b      	ldr	r3, [r7, #0]
   1afe8:	7fda      	ldrb	r2, [r3, #31]
   1afea:	687b      	ldr	r3, [r7, #4]
   1afec:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
      ((appDbRec_t *) hdl)->peerLtk = pKey->keyData.ltk;
   1aff0:	687a      	ldr	r2, [r7, #4]
   1aff2:	683b      	ldr	r3, [r7, #0]
   1aff4:	f102 0450 	add.w	r4, r2, #80	; 0x50
   1aff8:	1d1d      	adds	r5, r3, #4
   1affa:	6828      	ldr	r0, [r5, #0]
   1affc:	6869      	ldr	r1, [r5, #4]
   1affe:	68aa      	ldr	r2, [r5, #8]
   1b000:	68eb      	ldr	r3, [r5, #12]
   1b002:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1b004:	6928      	ldr	r0, [r5, #16]
   1b006:	6969      	ldr	r1, [r5, #20]
   1b008:	c403      	stmia	r4!, {r0, r1}
   1b00a:	8b2b      	ldrh	r3, [r5, #24]
   1b00c:	8023      	strh	r3, [r4, #0]
      break;
   1b00e:	e02f      	b.n	1b070 <AppDbSetKey+0xf0>

    case DM_KEY_IRK:
      ((appDbRec_t *)hdl)->peerIrk = pKey->keyData.irk;
   1b010:	687b      	ldr	r3, [r7, #4]
   1b012:	683a      	ldr	r2, [r7, #0]
   1b014:	3307      	adds	r3, #7
   1b016:	3204      	adds	r2, #4
   1b018:	6811      	ldr	r1, [r2, #0]
   1b01a:	6855      	ldr	r5, [r2, #4]
   1b01c:	6894      	ldr	r4, [r2, #8]
   1b01e:	68d0      	ldr	r0, [r2, #12]
   1b020:	6019      	str	r1, [r3, #0]
   1b022:	605d      	str	r5, [r3, #4]
   1b024:	609c      	str	r4, [r3, #8]
   1b026:	60d8      	str	r0, [r3, #12]
   1b028:	6911      	ldr	r1, [r2, #16]
   1b02a:	6119      	str	r1, [r3, #16]
   1b02c:	8a91      	ldrh	r1, [r2, #20]
   1b02e:	7d92      	ldrb	r2, [r2, #22]
   1b030:	8299      	strh	r1, [r3, #20]
   1b032:	759a      	strb	r2, [r3, #22]

      /* make sure peer record is stored using its identity address */
      ((appDbRec_t *)hdl)->addrType = pKey->keyData.irk.addrType;
   1b034:	683b      	ldr	r3, [r7, #0]
   1b036:	7e9a      	ldrb	r2, [r3, #26]
   1b038:	687b      	ldr	r3, [r7, #4]
   1b03a:	719a      	strb	r2, [r3, #6]
      BdaCpy(((appDbRec_t *)hdl)->peerAddr, pKey->keyData.irk.bdAddr);
   1b03c:	687a      	ldr	r2, [r7, #4]
   1b03e:	683b      	ldr	r3, [r7, #0]
   1b040:	3314      	adds	r3, #20
   1b042:	4619      	mov	r1, r3
   1b044:	4610      	mov	r0, r2
   1b046:	f006 fd9e 	bl	21b86 <BdaCpy>
      break;
   1b04a:	e011      	b.n	1b070 <AppDbSetKey+0xf0>

    case DM_KEY_CSRK:
      ((appDbRec_t *)hdl)->peerCsrk = pKey->keyData.csrk;
   1b04c:	687b      	ldr	r3, [r7, #4]
   1b04e:	683a      	ldr	r2, [r7, #0]
   1b050:	331e      	adds	r3, #30
   1b052:	3204      	adds	r2, #4
   1b054:	6814      	ldr	r4, [r2, #0]
   1b056:	6850      	ldr	r0, [r2, #4]
   1b058:	6891      	ldr	r1, [r2, #8]
   1b05a:	68d2      	ldr	r2, [r2, #12]
   1b05c:	601c      	str	r4, [r3, #0]
   1b05e:	6058      	str	r0, [r3, #4]
   1b060:	6099      	str	r1, [r3, #8]
   1b062:	60da      	str	r2, [r3, #12]

      /* sign counter must be initialized to zero when CSRK is generated */
      ((appDbRec_t *)hdl)->peerSignCounter = 0;
   1b064:	687b      	ldr	r3, [r7, #4]
   1b066:	2200      	movs	r2, #0
   1b068:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      break;
   1b06c:	e000      	b.n	1b070 <AppDbSetKey+0xf0>

    default:
      break;
   1b06e:	bf00      	nop
  }
}
   1b070:	bf00      	nop
   1b072:	3708      	adds	r7, #8
   1b074:	46bd      	mov	sp, r7
   1b076:	bdb0      	pop	{r4, r5, r7, pc}

0001b078 <AppDbGetPeerAddedToRl>:
 *
 *  \return TRUE if peer device's been added to resolving list. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t AppDbGetPeerAddedToRl(appDbHdl_t hdl)
{
   1b078:	b480      	push	{r7}
   1b07a:	b083      	sub	sp, #12
   1b07c:	af00      	add	r7, sp, #0
   1b07e:	6078      	str	r0, [r7, #4]
  return ((appDbRec_t *)hdl)->peerAddedToRl;
   1b080:	687b      	ldr	r3, [r7, #4]
   1b082:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
}
   1b086:	4618      	mov	r0, r3
   1b088:	370c      	adds	r7, #12
   1b08a:	46bd      	mov	sp, r7
   1b08c:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b090:	4770      	bx	lr

0001b092 <AppDbSetPeerAddedToRl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppDbSetPeerAddedToRl(appDbHdl_t hdl, bool_t peerAddedToRl)
{
   1b092:	b480      	push	{r7}
   1b094:	b083      	sub	sp, #12
   1b096:	af00      	add	r7, sp, #0
   1b098:	6078      	str	r0, [r7, #4]
   1b09a:	460b      	mov	r3, r1
   1b09c:	70fb      	strb	r3, [r7, #3]
  ((appDbRec_t *)hdl)->peerAddedToRl = peerAddedToRl;
   1b09e:	687b      	ldr	r3, [r7, #4]
   1b0a0:	78fa      	ldrb	r2, [r7, #3]
   1b0a2:	f883 2031 	strb.w	r2, [r3, #49]	; 0x31
}
   1b0a6:	bf00      	nop
   1b0a8:	370c      	adds	r7, #12
   1b0aa:	46bd      	mov	sp, r7
   1b0ac:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b0b0:	4770      	bx	lr

0001b0b2 <AppDbGetPeerRpao>:
 *
 *  \return TRUE if RPA Only attribute is present on peer device. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t AppDbGetPeerRpao(appDbHdl_t hdl)
{
   1b0b2:	b480      	push	{r7}
   1b0b4:	b083      	sub	sp, #12
   1b0b6:	af00      	add	r7, sp, #0
   1b0b8:	6078      	str	r0, [r7, #4]
  return ((appDbRec_t *)hdl)->peerRpao;
   1b0ba:	687b      	ldr	r3, [r7, #4]
   1b0bc:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
}
   1b0c0:	4618      	mov	r0, r3
   1b0c2:	370c      	adds	r7, #12
   1b0c4:	46bd      	mov	sp, r7
   1b0c6:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b0ca:	4770      	bx	lr

0001b0cc <appProcMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appProcMsg(wsfMsgHdr_t *pMsg)
{
   1b0cc:	b580      	push	{r7, lr}
   1b0ce:	b082      	sub	sp, #8
   1b0d0:	af00      	add	r7, sp, #0
   1b0d2:	6078      	str	r0, [r7, #4]
  switch(pMsg->event)
   1b0d4:	687b      	ldr	r3, [r7, #4]
   1b0d6:	789b      	ldrb	r3, [r3, #2]
   1b0d8:	2b02      	cmp	r3, #2
   1b0da:	d00d      	beq.n	1b0f8 <appProcMsg+0x2c>
   1b0dc:	2b02      	cmp	r3, #2
   1b0de:	dc12      	bgt.n	1b106 <appProcMsg+0x3a>
   1b0e0:	2b00      	cmp	r3, #0
   1b0e2:	d002      	beq.n	1b0ea <appProcMsg+0x1e>
   1b0e4:	2b01      	cmp	r3, #1
   1b0e6:	d003      	beq.n	1b0f0 <appProcMsg+0x24>
    case APP_HCI_READ_REMOTE_FEAT:
      DmReadRemoteFeatures((dmConnId_t) pMsg->param);
      break;

    default:
      break;
   1b0e8:	e00d      	b.n	1b106 <appProcMsg+0x3a>
      appUiBtnPoll();
   1b0ea:	f012 feb1 	bl	2de50 <appUiBtnPoll>
      break;
   1b0ee:	e00b      	b.n	1b108 <appProcMsg+0x3c>
      appUiTimerExpired(pMsg);
   1b0f0:	6878      	ldr	r0, [r7, #4]
   1b0f2:	f012 fea3 	bl	2de3c <appUiTimerExpired>
      break;
   1b0f6:	e007      	b.n	1b108 <appProcMsg+0x3c>
      DmReadRemoteFeatures((dmConnId_t) pMsg->param);
   1b0f8:	687b      	ldr	r3, [r7, #4]
   1b0fa:	881b      	ldrh	r3, [r3, #0]
   1b0fc:	b2db      	uxtb	r3, r3
   1b0fe:	4618      	mov	r0, r3
   1b100:	f008 f8bc 	bl	2327c <DmReadRemoteFeatures>
      break;
   1b104:	e000      	b.n	1b108 <appProcMsg+0x3c>
      break;
   1b106:	bf00      	nop
  }
}
   1b108:	bf00      	nop
   1b10a:	3708      	adds	r7, #8
   1b10c:	46bd      	mov	sp, r7
   1b10e:	bd80      	pop	{r7, pc}

0001b110 <appNumConns>:
 *
 *  \return Number of connections.
 */
/*************************************************************************************************/
uint8_t appNumConns(uint8_t role)
{
   1b110:	b580      	push	{r7, lr}
   1b112:	b084      	sub	sp, #16
   1b114:	af00      	add	r7, sp, #0
   1b116:	4603      	mov	r3, r0
   1b118:	71fb      	strb	r3, [r7, #7]
  appConnCb_t   *pCcb = appConnCb;
   1b11a:	4b13      	ldr	r3, [pc, #76]	; (1b168 <appNumConns+0x58>)
   1b11c:	60fb      	str	r3, [r7, #12]
  uint8_t       i, j;

  for (i = DM_CONN_MAX, j = 0; i > 0; i--, pCcb++)
   1b11e:	2303      	movs	r3, #3
   1b120:	72fb      	strb	r3, [r7, #11]
   1b122:	2300      	movs	r3, #0
   1b124:	72bb      	strb	r3, [r7, #10]
   1b126:	e016      	b.n	1b156 <appNumConns+0x46>
  {
    if ((pCcb->connId != DM_CONN_ID_NONE) && (DmConnRole(pCcb->connId) == role))
   1b128:	68fb      	ldr	r3, [r7, #12]
   1b12a:	791b      	ldrb	r3, [r3, #4]
   1b12c:	2b00      	cmp	r3, #0
   1b12e:	d00c      	beq.n	1b14a <appNumConns+0x3a>
   1b130:	68fb      	ldr	r3, [r7, #12]
   1b132:	791b      	ldrb	r3, [r3, #4]
   1b134:	4618      	mov	r0, r3
   1b136:	f008 faa5 	bl	23684 <DmConnRole>
   1b13a:	4603      	mov	r3, r0
   1b13c:	461a      	mov	r2, r3
   1b13e:	79fb      	ldrb	r3, [r7, #7]
   1b140:	4293      	cmp	r3, r2
   1b142:	d102      	bne.n	1b14a <appNumConns+0x3a>
    {
      j++;
   1b144:	7abb      	ldrb	r3, [r7, #10]
   1b146:	3301      	adds	r3, #1
   1b148:	72bb      	strb	r3, [r7, #10]
  for (i = DM_CONN_MAX, j = 0; i > 0; i--, pCcb++)
   1b14a:	7afb      	ldrb	r3, [r7, #11]
   1b14c:	3b01      	subs	r3, #1
   1b14e:	72fb      	strb	r3, [r7, #11]
   1b150:	68fb      	ldr	r3, [r7, #12]
   1b152:	3330      	adds	r3, #48	; 0x30
   1b154:	60fb      	str	r3, [r7, #12]
   1b156:	7afb      	ldrb	r3, [r7, #11]
   1b158:	2b00      	cmp	r3, #0
   1b15a:	d1e5      	bne.n	1b128 <appNumConns+0x18>
    }
  }

  return j;
   1b15c:	7abb      	ldrb	r3, [r7, #10]
}
   1b15e:	4618      	mov	r0, r3
   1b160:	3710      	adds	r7, #16
   1b162:	46bd      	mov	sp, r7
   1b164:	bd80      	pop	{r7, pc}
   1b166:	bf00      	nop
   1b168:	10010ed0 	.word	0x10010ed0

0001b16c <AppHandlerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppHandlerInit(wsfHandlerId_t handlerId)
{
   1b16c:	b580      	push	{r7, lr}
   1b16e:	b082      	sub	sp, #8
   1b170:	af00      	add	r7, sp, #0
   1b172:	4603      	mov	r3, r0
   1b174:	71fb      	strb	r3, [r7, #7]
  appHandlerId = handlerId;
   1b176:	4a04      	ldr	r2, [pc, #16]	; (1b188 <AppHandlerInit+0x1c>)
   1b178:	79fb      	ldrb	r3, [r7, #7]
   1b17a:	7013      	strb	r3, [r2, #0]

  AppDbInit();
   1b17c:	f7ff fd34 	bl	1abe8 <AppDbInit>
}
   1b180:	bf00      	nop
   1b182:	3708      	adds	r7, #8
   1b184:	46bd      	mov	sp, r7
   1b186:	bd80      	pop	{r7, pc}
   1b188:	10010ebc 	.word	0x10010ebc

0001b18c <AppHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   1b18c:	b580      	push	{r7, lr}
   1b18e:	b082      	sub	sp, #8
   1b190:	af00      	add	r7, sp, #0
   1b192:	4603      	mov	r3, r0
   1b194:	6039      	str	r1, [r7, #0]
   1b196:	71fb      	strb	r3, [r7, #7]
  if (pMsg != NULL)
   1b198:	683b      	ldr	r3, [r7, #0]
   1b19a:	2b00      	cmp	r3, #0
   1b19c:	d01b      	beq.n	1b1d6 <AppHandler+0x4a>
  {
    APP_TRACE_INFO1("App got evt %d", pMsg->event);
   1b19e:	683b      	ldr	r3, [r7, #0]
   1b1a0:	789b      	ldrb	r3, [r3, #2]
   1b1a2:	4619      	mov	r1, r3
   1b1a4:	4811      	ldr	r0, [pc, #68]	; (1b1ec <AppHandler+0x60>)
   1b1a6:	f012 fbf3 	bl	2d990 <WsfTrace>

    if (pMsg->event >= APP_MASTER_MSG_START)
   1b1aa:	683b      	ldr	r3, [r7, #0]
   1b1ac:	789b      	ldrb	r3, [r3, #2]
   1b1ae:	2b1f      	cmp	r3, #31
   1b1b0:	d904      	bls.n	1b1bc <AppHandler+0x30>
    {
      /* pass event to master handler */
      (*appCb.masterCback)(pMsg);
   1b1b2:	4b0f      	ldr	r3, [pc, #60]	; (1b1f0 <AppHandler+0x64>)
   1b1b4:	685b      	ldr	r3, [r3, #4]
   1b1b6:	6838      	ldr	r0, [r7, #0]
   1b1b8:	4798      	blx	r3
    if (event & APP_BTN_DOWN_EVT)
    {
      AppUiBtnPressed();
    }
  }
}
   1b1ba:	e013      	b.n	1b1e4 <AppHandler+0x58>
    else if (pMsg->event >= APP_SLAVE_MSG_START)
   1b1bc:	683b      	ldr	r3, [r7, #0]
   1b1be:	789b      	ldrb	r3, [r3, #2]
   1b1c0:	2b0f      	cmp	r3, #15
   1b1c2:	d904      	bls.n	1b1ce <AppHandler+0x42>
      (*appCb.slaveCback)(pMsg);
   1b1c4:	4b0a      	ldr	r3, [pc, #40]	; (1b1f0 <AppHandler+0x64>)
   1b1c6:	681b      	ldr	r3, [r3, #0]
   1b1c8:	6838      	ldr	r0, [r7, #0]
   1b1ca:	4798      	blx	r3
}
   1b1cc:	e00a      	b.n	1b1e4 <AppHandler+0x58>
      appProcMsg(pMsg);
   1b1ce:	6838      	ldr	r0, [r7, #0]
   1b1d0:	f7ff ff7c 	bl	1b0cc <appProcMsg>
}
   1b1d4:	e006      	b.n	1b1e4 <AppHandler+0x58>
    if (event & APP_BTN_DOWN_EVT)
   1b1d6:	79fb      	ldrb	r3, [r7, #7]
   1b1d8:	f003 0310 	and.w	r3, r3, #16
   1b1dc:	2b00      	cmp	r3, #0
   1b1de:	d001      	beq.n	1b1e4 <AppHandler+0x58>
      AppUiBtnPressed();
   1b1e0:	f012 fe25 	bl	2de2e <AppUiBtnPressed>
}
   1b1e4:	bf00      	nop
   1b1e6:	3708      	adds	r7, #8
   1b1e8:	46bd      	mov	sp, r7
   1b1ea:	bd80      	pop	{r7, pc}
   1b1ec:	000446b4 	.word	0x000446b4
   1b1f0:	10010ea0 	.word	0x10010ea0

0001b1f4 <AppConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppConnClose(dmConnId_t connId)
{
   1b1f4:	b580      	push	{r7, lr}
   1b1f6:	b082      	sub	sp, #8
   1b1f8:	af00      	add	r7, sp, #0
   1b1fa:	4603      	mov	r3, r0
   1b1fc:	71fb      	strb	r3, [r7, #7]
  DmConnClose(DM_CLIENT_ID_APP, connId, HCI_ERR_REMOTE_TERMINATED);
   1b1fe:	79fb      	ldrb	r3, [r7, #7]
   1b200:	2213      	movs	r2, #19
   1b202:	4619      	mov	r1, r3
   1b204:	2003      	movs	r0, #3
   1b206:	f008 f80b 	bl	23220 <DmConnClose>
}
   1b20a:	bf00      	nop
   1b20c:	3708      	adds	r7, #8
   1b20e:	46bd      	mov	sp, r7
   1b210:	bd80      	pop	{r7, pc}
	...

0001b214 <AppAddDevToResList>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppAddDevToResList(dmEvt_t *pMsg, dmConnId_t connId)
{
   1b214:	b5f0      	push	{r4, r5, r6, r7, lr}
   1b216:	b087      	sub	sp, #28
   1b218:	af02      	add	r7, sp, #8
   1b21a:	6078      	str	r0, [r7, #4]
   1b21c:	460b      	mov	r3, r1
   1b21e:	70fb      	strb	r3, [r7, #3]
  dmSecKey_t *pPeerKey;
  appDbHdl_t hdl = appConnCb[connId - 1].dbHdl;
   1b220:	78fb      	ldrb	r3, [r7, #3]
   1b222:	1e5a      	subs	r2, r3, #1
   1b224:	4916      	ldr	r1, [pc, #88]	; (1b280 <AppAddDevToResList+0x6c>)
   1b226:	4613      	mov	r3, r2
   1b228:	005b      	lsls	r3, r3, #1
   1b22a:	4413      	add	r3, r2
   1b22c:	011b      	lsls	r3, r3, #4
   1b22e:	440b      	add	r3, r1
   1b230:	681b      	ldr	r3, [r3, #0]
   1b232:	60fb      	str	r3, [r7, #12]

  /* if LL Privacy is supported and the peer device has distributed its IRK */
  if (HciLlPrivacySupported() && ((pPeerKey = AppDbGetKey(hdl, DM_KEY_IRK, NULL))!= NULL))
   1b234:	f00b f924 	bl	26480 <HciLlPrivacySupported>
   1b238:	4603      	mov	r3, r0
   1b23a:	2b00      	cmp	r3, #0
   1b23c:	d01c      	beq.n	1b278 <AppAddDevToResList+0x64>
   1b23e:	2200      	movs	r2, #0
   1b240:	2104      	movs	r1, #4
   1b242:	68f8      	ldr	r0, [r7, #12]
   1b244:	f7ff fe50 	bl	1aee8 <AppDbGetKey>
   1b248:	60b8      	str	r0, [r7, #8]
   1b24a:	68bb      	ldr	r3, [r7, #8]
   1b24c:	2b00      	cmp	r3, #0
   1b24e:	d013      	beq.n	1b278 <AppAddDevToResList+0x64>
  {
    /* add peer device to resolving list. If all-zero local or peer IRK is used then
       LL will only use or accept local or peer identity address respectively. */
    DmPrivAddDevToResList(pPeerKey->irk.addrType, pPeerKey->irk.bdAddr, pPeerKey->irk.key,
   1b250:	68bb      	ldr	r3, [r7, #8]
   1b252:	7d9c      	ldrb	r4, [r3, #22]
   1b254:	68bb      	ldr	r3, [r7, #8]
   1b256:	f103 0510 	add.w	r5, r3, #16
   1b25a:	68be      	ldr	r6, [r7, #8]
   1b25c:	f009 fa88 	bl	24770 <DmSecGetLocalIrk>
   1b260:	4602      	mov	r2, r0
   1b262:	687b      	ldr	r3, [r7, #4]
   1b264:	881b      	ldrh	r3, [r3, #0]
   1b266:	9301      	str	r3, [sp, #4]
   1b268:	2301      	movs	r3, #1
   1b26a:	9300      	str	r3, [sp, #0]
   1b26c:	4613      	mov	r3, r2
   1b26e:	4632      	mov	r2, r6
   1b270:	4629      	mov	r1, r5
   1b272:	4620      	mov	r0, r4
   1b274:	f008 ff78 	bl	24168 <DmPrivAddDevToResList>
                          DmSecGetLocalIrk(), TRUE, pMsg->hdr.param);
  }
}
   1b278:	bf00      	nop
   1b27a:	3714      	adds	r7, #20
   1b27c:	46bd      	mov	sp, r7
   1b27e:	bdf0      	pop	{r4, r5, r6, r7, pc}
   1b280:	10010ed0 	.word	0x10010ed0

0001b284 <AppUpdatePrivacyMode>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppUpdatePrivacyMode(appDbHdl_t hdl)
{
   1b284:	b580      	push	{r7, lr}
   1b286:	b084      	sub	sp, #16
   1b288:	af00      	add	r7, sp, #0
   1b28a:	6078      	str	r0, [r7, #4]
  /* if peer device's been added to resolving list but RPA Only attribute not found on peer device */
  if ((hdl != APP_DB_HDL_NONE) && AppDbGetPeerAddedToRl(hdl) && !AppDbGetPeerRpao(hdl))
   1b28c:	687b      	ldr	r3, [r7, #4]
   1b28e:	2b00      	cmp	r3, #0
   1b290:	d020      	beq.n	1b2d4 <AppUpdatePrivacyMode+0x50>
   1b292:	6878      	ldr	r0, [r7, #4]
   1b294:	f7ff fef0 	bl	1b078 <AppDbGetPeerAddedToRl>
   1b298:	4603      	mov	r3, r0
   1b29a:	2b00      	cmp	r3, #0
   1b29c:	d01a      	beq.n	1b2d4 <AppUpdatePrivacyMode+0x50>
   1b29e:	6878      	ldr	r0, [r7, #4]
   1b2a0:	f7ff ff07 	bl	1b0b2 <AppDbGetPeerRpao>
   1b2a4:	4603      	mov	r3, r0
   1b2a6:	2b00      	cmp	r3, #0
   1b2a8:	d114      	bne.n	1b2d4 <AppUpdatePrivacyMode+0x50>
  {
    dmSecKey_t *pPeerKey = AppDbGetKey(hdl, DM_KEY_IRK, NULL);
   1b2aa:	2200      	movs	r2, #0
   1b2ac:	2104      	movs	r1, #4
   1b2ae:	6878      	ldr	r0, [r7, #4]
   1b2b0:	f7ff fe1a 	bl	1aee8 <AppDbGetKey>
   1b2b4:	60f8      	str	r0, [r7, #12]
    if (pPeerKey != NULL)
   1b2b6:	68fb      	ldr	r3, [r7, #12]
   1b2b8:	2b00      	cmp	r3, #0
   1b2ba:	d00b      	beq.n	1b2d4 <AppUpdatePrivacyMode+0x50>
    {
      /* set device privacy mode for this peer device */
      DmPrivSetPrivacyMode(pPeerKey->irk.addrType, pPeerKey->irk.bdAddr, DM_PRIV_MODE_DEVICE);
   1b2bc:	68fb      	ldr	r3, [r7, #12]
   1b2be:	7d98      	ldrb	r0, [r3, #22]
   1b2c0:	68fb      	ldr	r3, [r7, #12]
   1b2c2:	3310      	adds	r3, #16
   1b2c4:	2201      	movs	r2, #1
   1b2c6:	4619      	mov	r1, r3
   1b2c8:	f008 ff8a 	bl	241e0 <DmPrivSetPrivacyMode>

      /* make sure resolving list flag cleared */
      AppDbSetPeerAddedToRl(hdl, FALSE);
   1b2cc:	2100      	movs	r1, #0
   1b2ce:	6878      	ldr	r0, [r7, #4]
   1b2d0:	f7ff fedf 	bl	1b092 <AppDbSetPeerAddedToRl>
    }
  }
}
   1b2d4:	bf00      	nop
   1b2d6:	3710      	adds	r7, #16
   1b2d8:	46bd      	mov	sp, r7
   1b2da:	bd80      	pop	{r7, pc}

0001b2dc <appConnReadRemoteFeatTimerStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appConnReadRemoteFeatTimerStart(dmConnId_t connId)
{
   1b2dc:	b580      	push	{r7, lr}
   1b2de:	b084      	sub	sp, #16
   1b2e0:	af00      	add	r7, sp, #0
   1b2e2:	4603      	mov	r3, r0
   1b2e4:	71fb      	strb	r3, [r7, #7]
  /* look up app connection control block from DM connection ID */
  appConnCb_t *pCb = &appConnCb[connId - 1];
   1b2e6:	79fb      	ldrb	r3, [r7, #7]
   1b2e8:	1e5a      	subs	r2, r3, #1
   1b2ea:	4613      	mov	r3, r2
   1b2ec:	005b      	lsls	r3, r3, #1
   1b2ee:	4413      	add	r3, r2
   1b2f0:	011b      	lsls	r3, r3, #4
   1b2f2:	4a0d      	ldr	r2, [pc, #52]	; (1b328 <appConnReadRemoteFeatTimerStart+0x4c>)
   1b2f4:	4413      	add	r3, r2
   1b2f6:	60fb      	str	r3, [r7, #12]

  pCb->readRemoteFeatTimer.handlerId = appHandlerId;
   1b2f8:	4b0c      	ldr	r3, [pc, #48]	; (1b32c <appConnReadRemoteFeatTimerStart+0x50>)
   1b2fa:	781a      	ldrb	r2, [r3, #0]
   1b2fc:	68fb      	ldr	r3, [r7, #12]
   1b2fe:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  pCb->readRemoteFeatTimer.msg.event = APP_HCI_READ_REMOTE_FEAT;
   1b302:	68fb      	ldr	r3, [r7, #12]
   1b304:	2202      	movs	r2, #2
   1b306:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  pCb->readRemoteFeatTimer.msg.param = connId;
   1b30a:	79fb      	ldrb	r3, [r7, #7]
   1b30c:	b29a      	uxth	r2, r3
   1b30e:	68fb      	ldr	r3, [r7, #12]
   1b310:	851a      	strh	r2, [r3, #40]	; 0x28
  WsfTimerStartMs(&pCb->readRemoteFeatTimer, APP_TIME_READ_REMOTE_FEAT_MS);
   1b312:	68fb      	ldr	r3, [r7, #12]
   1b314:	3320      	adds	r3, #32
   1b316:	211e      	movs	r1, #30
   1b318:	4618      	mov	r0, r3
   1b31a:	f012 fa79 	bl	2d810 <WsfTimerStartMs>
}
   1b31e:	bf00      	nop
   1b320:	3710      	adds	r7, #16
   1b322:	46bd      	mov	sp, r7
   1b324:	bd80      	pop	{r7, pc}
   1b326:	bf00      	nop
   1b328:	10010ed0 	.word	0x10010ed0
   1b32c:	10010ebc 	.word	0x10010ebc

0001b330 <appMasterInitiateSec>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterInitiateSec(dmConnId_t connId, bool_t initiatePairing, appConnCb_t *pCb)
{
   1b330:	b590      	push	{r4, r7, lr}
   1b332:	b089      	sub	sp, #36	; 0x24
   1b334:	af02      	add	r7, sp, #8
   1b336:	4603      	mov	r3, r0
   1b338:	603a      	str	r2, [r7, #0]
   1b33a:	71fb      	strb	r3, [r7, #7]
   1b33c:	460b      	mov	r3, r1
   1b33e:	71bb      	strb	r3, [r7, #6]
  uint8_t     rKeyDist;
  uint8_t     secLevel;
  dmSecKey_t  *pKey;

  /* if we have an LTK for peer device */
  if ((pCb->dbHdl != APP_DB_HDL_NONE) &&
   1b340:	683b      	ldr	r3, [r7, #0]
   1b342:	681b      	ldr	r3, [r3, #0]
   1b344:	2b00      	cmp	r3, #0
   1b346:	d018      	beq.n	1b37a <appMasterInitiateSec+0x4a>
      ((pKey = AppDbGetKey(pCb->dbHdl, DM_KEY_PEER_LTK, &secLevel)) != NULL))
   1b348:	683b      	ldr	r3, [r7, #0]
   1b34a:	681b      	ldr	r3, [r3, #0]
   1b34c:	f107 020f 	add.w	r2, r7, #15
   1b350:	2102      	movs	r1, #2
   1b352:	4618      	mov	r0, r3
   1b354:	f7ff fdc8 	bl	1aee8 <AppDbGetKey>
   1b358:	6138      	str	r0, [r7, #16]
  if ((pCb->dbHdl != APP_DB_HDL_NONE) &&
   1b35a:	693b      	ldr	r3, [r7, #16]
   1b35c:	2b00      	cmp	r3, #0
   1b35e:	d00c      	beq.n	1b37a <appMasterInitiateSec+0x4a>
  {
    pCb->bondByLtk = TRUE;
   1b360:	683b      	ldr	r3, [r7, #0]
   1b362:	2201      	movs	r2, #1
   1b364:	719a      	strb	r2, [r3, #6]
    pCb->initiatingSec = TRUE;
   1b366:	683b      	ldr	r3, [r7, #0]
   1b368:	2201      	movs	r2, #1
   1b36a:	721a      	strb	r2, [r3, #8]

    /* encrypt with LTK */
    DmSecEncryptReq(connId, secLevel, &pKey->ltk);
   1b36c:	7bf9      	ldrb	r1, [r7, #15]
   1b36e:	693a      	ldr	r2, [r7, #16]
   1b370:	79fb      	ldrb	r3, [r7, #7]
   1b372:	4618      	mov	r0, r3
   1b374:	f009 fa40 	bl	247f8 <DmSecEncryptReq>
    pCb->initiatingSec = TRUE;

    /* initiate pairing */
    DmSecPairReq(connId, pAppSecCfg->oob, pAppSecCfg->auth, pAppSecCfg->iKeyDist, rKeyDist);
  }
}
   1b378:	e04e      	b.n	1b418 <appMasterInitiateSec+0xe8>
  else if (initiatePairing)
   1b37a:	79bb      	ldrb	r3, [r7, #6]
   1b37c:	2b00      	cmp	r3, #0
   1b37e:	d04b      	beq.n	1b418 <appMasterInitiateSec+0xe8>
    pCb->bondByPairing = (pAppSecCfg->auth & DM_AUTH_BOND_FLAG) == DM_AUTH_BOND_FLAG;
   1b380:	4b27      	ldr	r3, [pc, #156]	; (1b420 <appMasterInitiateSec+0xf0>)
   1b382:	681b      	ldr	r3, [r3, #0]
   1b384:	781b      	ldrb	r3, [r3, #0]
   1b386:	f003 0301 	and.w	r3, r3, #1
   1b38a:	2b00      	cmp	r3, #0
   1b38c:	bf14      	ite	ne
   1b38e:	2301      	movne	r3, #1
   1b390:	2300      	moveq	r3, #0
   1b392:	b2db      	uxtb	r3, r3
   1b394:	461a      	mov	r2, r3
   1b396:	683b      	ldr	r3, [r7, #0]
   1b398:	71da      	strb	r2, [r3, #7]
    if (pCb->bondByPairing && pCb->dbHdl == APP_DB_HDL_NONE)
   1b39a:	683b      	ldr	r3, [r7, #0]
   1b39c:	79db      	ldrb	r3, [r3, #7]
   1b39e:	2b00      	cmp	r3, #0
   1b3a0:	d016      	beq.n	1b3d0 <appMasterInitiateSec+0xa0>
   1b3a2:	683b      	ldr	r3, [r7, #0]
   1b3a4:	681b      	ldr	r3, [r3, #0]
   1b3a6:	2b00      	cmp	r3, #0
   1b3a8:	d112      	bne.n	1b3d0 <appMasterInitiateSec+0xa0>
      pCb->dbHdl = AppDbNewRecord(DmConnPeerAddrType(connId), DmConnPeerAddr(connId), TRUE);
   1b3aa:	79fb      	ldrb	r3, [r7, #7]
   1b3ac:	4618      	mov	r0, r3
   1b3ae:	f008 f8a3 	bl	234f8 <DmConnPeerAddrType>
   1b3b2:	4603      	mov	r3, r0
   1b3b4:	461c      	mov	r4, r3
   1b3b6:	79fb      	ldrb	r3, [r7, #7]
   1b3b8:	4618      	mov	r0, r3
   1b3ba:	f008 f8b5 	bl	23528 <DmConnPeerAddr>
   1b3be:	4603      	mov	r3, r0
   1b3c0:	2201      	movs	r2, #1
   1b3c2:	4619      	mov	r1, r3
   1b3c4:	4620      	mov	r0, r4
   1b3c6:	f7ff fc17 	bl	1abf8 <AppDbNewRecord>
   1b3ca:	4602      	mov	r2, r0
   1b3cc:	683b      	ldr	r3, [r7, #0]
   1b3ce:	601a      	str	r2, [r3, #0]
    pCb->rcvdKeys = 0;
   1b3d0:	683b      	ldr	r3, [r7, #0]
   1b3d2:	2200      	movs	r2, #0
   1b3d4:	72da      	strb	r2, [r3, #11]
    rKeyDist = pAppSecCfg->rKeyDist;
   1b3d6:	4b12      	ldr	r3, [pc, #72]	; (1b420 <appMasterInitiateSec+0xf0>)
   1b3d8:	681b      	ldr	r3, [r3, #0]
   1b3da:	789b      	ldrb	r3, [r3, #2]
   1b3dc:	75fb      	strb	r3, [r7, #23]
    if (DmConnPeerAddrType(connId) == DM_ADDR_RANDOM)
   1b3de:	79fb      	ldrb	r3, [r7, #7]
   1b3e0:	4618      	mov	r0, r3
   1b3e2:	f008 f889 	bl	234f8 <DmConnPeerAddrType>
   1b3e6:	4603      	mov	r3, r0
   1b3e8:	2b01      	cmp	r3, #1
   1b3ea:	d103      	bne.n	1b3f4 <appMasterInitiateSec+0xc4>
      rKeyDist |= DM_KEY_DIST_IRK;
   1b3ec:	7dfb      	ldrb	r3, [r7, #23]
   1b3ee:	f043 0302 	orr.w	r3, r3, #2
   1b3f2:	75fb      	strb	r3, [r7, #23]
    pCb->initiatingSec = TRUE;
   1b3f4:	683b      	ldr	r3, [r7, #0]
   1b3f6:	2201      	movs	r2, #1
   1b3f8:	721a      	strb	r2, [r3, #8]
    DmSecPairReq(connId, pAppSecCfg->oob, pAppSecCfg->auth, pAppSecCfg->iKeyDist, rKeyDist);
   1b3fa:	4b09      	ldr	r3, [pc, #36]	; (1b420 <appMasterInitiateSec+0xf0>)
   1b3fc:	681b      	ldr	r3, [r3, #0]
   1b3fe:	78d9      	ldrb	r1, [r3, #3]
   1b400:	4b07      	ldr	r3, [pc, #28]	; (1b420 <appMasterInitiateSec+0xf0>)
   1b402:	681b      	ldr	r3, [r3, #0]
   1b404:	781a      	ldrb	r2, [r3, #0]
   1b406:	4b06      	ldr	r3, [pc, #24]	; (1b420 <appMasterInitiateSec+0xf0>)
   1b408:	681b      	ldr	r3, [r3, #0]
   1b40a:	785c      	ldrb	r4, [r3, #1]
   1b40c:	79f8      	ldrb	r0, [r7, #7]
   1b40e:	7dfb      	ldrb	r3, [r7, #23]
   1b410:	9300      	str	r3, [sp, #0]
   1b412:	4623      	mov	r3, r4
   1b414:	f009 f9b8 	bl	24788 <DmSecPairReq>
}
   1b418:	bf00      	nop
   1b41a:	371c      	adds	r7, #28
   1b41c:	46bd      	mov	sp, r7
   1b41e:	bd90      	pop	{r4, r7, pc}
   1b420:	10010ec0 	.word	0x10010ec0

0001b424 <appScanResultsClear>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appScanResultsClear(void)
{
   1b424:	b480      	push	{r7}
   1b426:	b083      	sub	sp, #12
   1b428:	af00      	add	r7, sp, #0
  uint8_t       i;
  appDevInfo_t  *pDev = appMasterCb.scanResults;
   1b42a:	4b0f      	ldr	r3, [pc, #60]	; (1b468 <appScanResultsClear+0x44>)
   1b42c:	603b      	str	r3, [r7, #0]

  appMasterCb.numScanResults = 0;
   1b42e:	4b0e      	ldr	r3, [pc, #56]	; (1b468 <appScanResultsClear+0x44>)
   1b430:	2200      	movs	r2, #0
   1b432:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
  for (i = APP_SCAN_RESULT_MAX; i > 0; i--, pDev++)
   1b436:	230a      	movs	r3, #10
   1b438:	71fb      	strb	r3, [r7, #7]
   1b43a:	e008      	b.n	1b44e <appScanResultsClear+0x2a>
  {
    pDev->addrType = APP_ADDR_NONE;
   1b43c:	683b      	ldr	r3, [r7, #0]
   1b43e:	22ff      	movs	r2, #255	; 0xff
   1b440:	719a      	strb	r2, [r3, #6]
  for (i = APP_SCAN_RESULT_MAX; i > 0; i--, pDev++)
   1b442:	79fb      	ldrb	r3, [r7, #7]
   1b444:	3b01      	subs	r3, #1
   1b446:	71fb      	strb	r3, [r7, #7]
   1b448:	683b      	ldr	r3, [r7, #0]
   1b44a:	330f      	adds	r3, #15
   1b44c:	603b      	str	r3, [r7, #0]
   1b44e:	79fb      	ldrb	r3, [r7, #7]
   1b450:	2b00      	cmp	r3, #0
   1b452:	d1f3      	bne.n	1b43c <appScanResultsClear+0x18>
  }

  /* end address resolution */
  appMasterCb.inProgress = FALSE;
   1b454:	4b04      	ldr	r3, [pc, #16]	; (1b468 <appScanResultsClear+0x44>)
   1b456:	2200      	movs	r2, #0
   1b458:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
}
   1b45c:	bf00      	nop
   1b45e:	370c      	adds	r7, #12
   1b460:	46bd      	mov	sp, r7
   1b462:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b466:	4770      	bx	lr
   1b468:	10010f60 	.word	0x10010f60

0001b46c <appScanResultAdd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appScanResultAdd(dmEvt_t *pMsg)
{
   1b46c:	b580      	push	{r7, lr}
   1b46e:	b084      	sub	sp, #16
   1b470:	af00      	add	r7, sp, #0
   1b472:	6078      	str	r0, [r7, #4]
  uint8_t       i;
  appDevInfo_t  *pDev = appMasterCb.scanResults;
   1b474:	4b42      	ldr	r3, [pc, #264]	; (1b580 <appScanResultAdd+0x114>)
   1b476:	60bb      	str	r3, [r7, #8]

  /* see if device is in list already */
  for (i = 0; i < APP_SCAN_RESULT_MAX; i++, pDev++)
   1b478:	2300      	movs	r3, #0
   1b47a:	73fb      	strb	r3, [r7, #15]
   1b47c:	e078      	b.n	1b570 <appScanResultAdd+0x104>
  {
    if(DmScanModeLeg())
   1b47e:	f009 f943 	bl	24708 <DmScanModeLeg>
   1b482:	4603      	mov	r3, r0
   1b484:	2b00      	cmp	r3, #0
   1b486:	d034      	beq.n	1b4f2 <appScanResultAdd+0x86>
    {
        /* if address matches list entry */
        if ((pDev->addrType == pMsg->scanReport.addrType) &&
   1b488:	68bb      	ldr	r3, [r7, #8]
   1b48a:	799a      	ldrb	r2, [r3, #6]
   1b48c:	687b      	ldr	r3, [r7, #4]
   1b48e:	7adb      	ldrb	r3, [r3, #11]
   1b490:	429a      	cmp	r2, r3
   1b492:	d109      	bne.n	1b4a8 <appScanResultAdd+0x3c>
            BdaCmp(pDev->addr, pMsg->scanReport.addr))
   1b494:	68ba      	ldr	r2, [r7, #8]
   1b496:	687b      	ldr	r3, [r7, #4]
   1b498:	330c      	adds	r3, #12
   1b49a:	4619      	mov	r1, r3
   1b49c:	4610      	mov	r0, r2
   1b49e:	f006 fb80 	bl	21ba2 <BdaCmp>
   1b4a2:	4603      	mov	r3, r0
        if ((pDev->addrType == pMsg->scanReport.addrType) &&
   1b4a4:	2b00      	cmp	r3, #0
   1b4a6:	d167      	bne.n	1b578 <appScanResultAdd+0x10c>
        {
          /* device already exists in list; we are done */
          break;
        }
        /* if entry is free end then of list has been reached */
        else if (pDev->addrType == APP_ADDR_NONE)
   1b4a8:	68bb      	ldr	r3, [r7, #8]
   1b4aa:	799b      	ldrb	r3, [r3, #6]
   1b4ac:	2bff      	cmp	r3, #255	; 0xff
   1b4ae:	d159      	bne.n	1b564 <appScanResultAdd+0xf8>
        {
          /* add device to list */
          pDev->addrType = pMsg->scanReport.addrType;
   1b4b0:	687b      	ldr	r3, [r7, #4]
   1b4b2:	7ada      	ldrb	r2, [r3, #11]
   1b4b4:	68bb      	ldr	r3, [r7, #8]
   1b4b6:	719a      	strb	r2, [r3, #6]
          BdaCpy(pDev->addr, pMsg->scanReport.addr);
   1b4b8:	68ba      	ldr	r2, [r7, #8]
   1b4ba:	687b      	ldr	r3, [r7, #4]
   1b4bc:	330c      	adds	r3, #12
   1b4be:	4619      	mov	r1, r3
   1b4c0:	4610      	mov	r0, r2
   1b4c2:	f006 fb60 	bl	21b86 <BdaCpy>
          pDev->directAddrType = pMsg->scanReport.directAddrType;
   1b4c6:	687b      	ldr	r3, [r7, #4]
   1b4c8:	7c9a      	ldrb	r2, [r3, #18]
   1b4ca:	68bb      	ldr	r3, [r7, #8]
   1b4cc:	71da      	strb	r2, [r3, #7]
          BdaCpy(pDev->directAddr, pMsg->scanReport.directAddr);
   1b4ce:	68bb      	ldr	r3, [r7, #8]
   1b4d0:	f103 0208 	add.w	r2, r3, #8
   1b4d4:	687b      	ldr	r3, [r7, #4]
   1b4d6:	3313      	adds	r3, #19
   1b4d8:	4619      	mov	r1, r3
   1b4da:	4610      	mov	r0, r2
   1b4dc:	f006 fb53 	bl	21b86 <BdaCpy>
          appMasterCb.numScanResults++;
   1b4e0:	4b27      	ldr	r3, [pc, #156]	; (1b580 <appScanResultAdd+0x114>)
   1b4e2:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
   1b4e6:	3301      	adds	r3, #1
   1b4e8:	b2da      	uxtb	r2, r3
   1b4ea:	4b25      	ldr	r3, [pc, #148]	; (1b580 <appScanResultAdd+0x114>)
   1b4ec:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
          break;
   1b4f0:	e042      	b.n	1b578 <appScanResultAdd+0x10c>
        }
    }
    else
    {
        /* if address matches list entry */
        if ((pDev->addrType == pMsg->extScanReport.addrType) &&
   1b4f2:	68bb      	ldr	r3, [r7, #8]
   1b4f4:	799a      	ldrb	r2, [r3, #6]
   1b4f6:	687b      	ldr	r3, [r7, #4]
   1b4f8:	799b      	ldrb	r3, [r3, #6]
   1b4fa:	429a      	cmp	r2, r3
   1b4fc:	d109      	bne.n	1b512 <appScanResultAdd+0xa6>
            BdaCmp(pDev->addr, pMsg->extScanReport.addr))
   1b4fe:	68ba      	ldr	r2, [r7, #8]
   1b500:	687b      	ldr	r3, [r7, #4]
   1b502:	3307      	adds	r3, #7
   1b504:	4619      	mov	r1, r3
   1b506:	4610      	mov	r0, r2
   1b508:	f006 fb4b 	bl	21ba2 <BdaCmp>
   1b50c:	4603      	mov	r3, r0
        if ((pDev->addrType == pMsg->extScanReport.addrType) &&
   1b50e:	2b00      	cmp	r3, #0
   1b510:	d132      	bne.n	1b578 <appScanResultAdd+0x10c>
        {
          /* device already exists in list; we are done */
          break;
        }
        /* if entry is free end then of list has been reached */
        else if (pDev->addrType == APP_ADDR_NONE)
   1b512:	68bb      	ldr	r3, [r7, #8]
   1b514:	799b      	ldrb	r3, [r3, #6]
   1b516:	2bff      	cmp	r3, #255	; 0xff
   1b518:	d124      	bne.n	1b564 <appScanResultAdd+0xf8>
        {
          /* add device to list */
          pDev->addrType = pMsg->extScanReport.addrType;
   1b51a:	687b      	ldr	r3, [r7, #4]
   1b51c:	799a      	ldrb	r2, [r3, #6]
   1b51e:	68bb      	ldr	r3, [r7, #8]
   1b520:	719a      	strb	r2, [r3, #6]
          pDev->secPhy = pMsg->extScanReport.secPhy;
   1b522:	687b      	ldr	r3, [r7, #4]
   1b524:	7b9a      	ldrb	r2, [r3, #14]
   1b526:	68bb      	ldr	r3, [r7, #8]
   1b528:	739a      	strb	r2, [r3, #14]
          BdaCpy(pDev->addr, pMsg->extScanReport.addr);
   1b52a:	68ba      	ldr	r2, [r7, #8]
   1b52c:	687b      	ldr	r3, [r7, #4]
   1b52e:	3307      	adds	r3, #7
   1b530:	4619      	mov	r1, r3
   1b532:	4610      	mov	r0, r2
   1b534:	f006 fb27 	bl	21b86 <BdaCpy>
          pDev->directAddrType = pMsg->extScanReport.directAddrType;
   1b538:	687b      	ldr	r3, [r7, #4]
   1b53a:	7d1a      	ldrb	r2, [r3, #20]
   1b53c:	68bb      	ldr	r3, [r7, #8]
   1b53e:	71da      	strb	r2, [r3, #7]
          BdaCpy(pDev->directAddr, pMsg->extScanReport.directAddr);
   1b540:	68bb      	ldr	r3, [r7, #8]
   1b542:	f103 0208 	add.w	r2, r3, #8
   1b546:	687b      	ldr	r3, [r7, #4]
   1b548:	3315      	adds	r3, #21
   1b54a:	4619      	mov	r1, r3
   1b54c:	4610      	mov	r0, r2
   1b54e:	f006 fb1a 	bl	21b86 <BdaCpy>
          appMasterCb.numScanResults++;
   1b552:	4b0b      	ldr	r3, [pc, #44]	; (1b580 <appScanResultAdd+0x114>)
   1b554:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
   1b558:	3301      	adds	r3, #1
   1b55a:	b2da      	uxtb	r2, r3
   1b55c:	4b08      	ldr	r3, [pc, #32]	; (1b580 <appScanResultAdd+0x114>)
   1b55e:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
          break;
   1b562:	e009      	b.n	1b578 <appScanResultAdd+0x10c>
  for (i = 0; i < APP_SCAN_RESULT_MAX; i++, pDev++)
   1b564:	7bfb      	ldrb	r3, [r7, #15]
   1b566:	3301      	adds	r3, #1
   1b568:	73fb      	strb	r3, [r7, #15]
   1b56a:	68bb      	ldr	r3, [r7, #8]
   1b56c:	330f      	adds	r3, #15
   1b56e:	60bb      	str	r3, [r7, #8]
   1b570:	7bfb      	ldrb	r3, [r7, #15]
   1b572:	2b09      	cmp	r3, #9
   1b574:	d983      	bls.n	1b47e <appScanResultAdd+0x12>
        }
    }
  }
}
   1b576:	e7ff      	b.n	1b578 <appScanResultAdd+0x10c>
   1b578:	bf00      	nop
   1b57a:	3710      	adds	r7, #16
   1b57c:	46bd      	mov	sp, r7
   1b57e:	bd80      	pop	{r7, pc}
   1b580:	10010f60 	.word	0x10010f60

0001b584 <appMasterScanStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterScanStart(dmEvt_t *pMsg)
{
   1b584:	b580      	push	{r7, lr}
   1b586:	b082      	sub	sp, #8
   1b588:	af00      	add	r7, sp, #0
   1b58a:	6078      	str	r0, [r7, #4]
  if (pMsg->hdr.status == HCI_SUCCESS)
   1b58c:	687b      	ldr	r3, [r7, #4]
   1b58e:	78db      	ldrb	r3, [r3, #3]
   1b590:	2b00      	cmp	r3, #0
   1b592:	d101      	bne.n	1b598 <appMasterScanStart+0x14>
  {
    /* clear current scan results */
    appScanResultsClear();
   1b594:	f7ff ff46 	bl	1b424 <appScanResultsClear>
  }
}
   1b598:	bf00      	nop
   1b59a:	3708      	adds	r7, #8
   1b59c:	46bd      	mov	sp, r7
   1b59e:	bd80      	pop	{r7, pc}

0001b5a0 <appMasterScanStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterScanStop(dmEvt_t *pMsg)
{
   1b5a0:	b580      	push	{r7, lr}
   1b5a2:	b082      	sub	sp, #8
   1b5a4:	af00      	add	r7, sp, #0
   1b5a6:	6078      	str	r0, [r7, #4]
  if (pMsg->hdr.status == HCI_SUCCESS)
   1b5a8:	687b      	ldr	r3, [r7, #4]
   1b5aa:	78db      	ldrb	r3, [r3, #3]
   1b5ac:	2b00      	cmp	r3, #0
   1b5ae:	d106      	bne.n	1b5be <appMasterScanStop+0x1e>
  {
    APP_TRACE_INFO1("Scan results: %d", AppScanGetNumResults());
   1b5b0:	f000 fbbe 	bl	1bd30 <AppScanGetNumResults>
   1b5b4:	4603      	mov	r3, r0
   1b5b6:	4619      	mov	r1, r3
   1b5b8:	4803      	ldr	r0, [pc, #12]	; (1b5c8 <appMasterScanStop+0x28>)
   1b5ba:	f012 f9e9 	bl	2d990 <WsfTrace>
  }
}
   1b5be:	bf00      	nop
   1b5c0:	3708      	adds	r7, #8
   1b5c2:	46bd      	mov	sp, r7
   1b5c4:	bd80      	pop	{r7, pc}
   1b5c6:	bf00      	nop
   1b5c8:	000446d8 	.word	0x000446d8

0001b5cc <appMasterScanReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterScanReport(dmEvt_t *pMsg)
{
   1b5cc:	b580      	push	{r7, lr}
   1b5ce:	b082      	sub	sp, #8
   1b5d0:	af00      	add	r7, sp, #0
   1b5d2:	6078      	str	r0, [r7, #4]
  /* add to scan result list */
  appScanResultAdd(pMsg);
   1b5d4:	6878      	ldr	r0, [r7, #4]
   1b5d6:	f7ff ff49 	bl	1b46c <appScanResultAdd>
}
   1b5da:	bf00      	nop
   1b5dc:	3708      	adds	r7, #8
   1b5de:	46bd      	mov	sp, r7
   1b5e0:	bd80      	pop	{r7, pc}

0001b5e2 <appMasterConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterConnOpen(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b5e2:	b580      	push	{r7, lr}
   1b5e4:	b082      	sub	sp, #8
   1b5e6:	af00      	add	r7, sp, #0
   1b5e8:	6078      	str	r0, [r7, #4]
   1b5ea:	6039      	str	r1, [r7, #0]
  appConnReadRemoteFeatTimerStart((dmConnId_t) pMsg->hdr.param);
   1b5ec:	687b      	ldr	r3, [r7, #4]
   1b5ee:	881b      	ldrh	r3, [r3, #0]
   1b5f0:	b2db      	uxtb	r3, r3
   1b5f2:	4618      	mov	r0, r3
   1b5f4:	f7ff fe72 	bl	1b2dc <appConnReadRemoteFeatTimerStart>
}
   1b5f8:	bf00      	nop
   1b5fa:	3708      	adds	r7, #8
   1b5fc:	46bd      	mov	sp, r7
   1b5fe:	bd80      	pop	{r7, pc}

0001b600 <appMasterConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterConnClose(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b600:	b580      	push	{r7, lr}
   1b602:	b082      	sub	sp, #8
   1b604:	af00      	add	r7, sp, #0
   1b606:	6078      	str	r0, [r7, #4]
   1b608:	6039      	str	r1, [r7, #0]
  /* update privacy mode for peer device */
  AppUpdatePrivacyMode(pCb->dbHdl);
   1b60a:	683b      	ldr	r3, [r7, #0]
   1b60c:	681b      	ldr	r3, [r3, #0]
   1b60e:	4618      	mov	r0, r3
   1b610:	f7ff fe38 	bl	1b284 <AppUpdatePrivacyMode>

  /* clear connection ID */
  pCb->connId = DM_CONN_ID_NONE;
   1b614:	683b      	ldr	r3, [r7, #0]
   1b616:	2200      	movs	r2, #0
   1b618:	711a      	strb	r2, [r3, #4]

  /* cancel any address resolution in progress */
  appMasterCb.inProgress = FALSE;
   1b61a:	4b04      	ldr	r3, [pc, #16]	; (1b62c <appMasterConnClose+0x2c>)
   1b61c:	2200      	movs	r2, #0
   1b61e:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
}
   1b622:	bf00      	nop
   1b624:	3708      	adds	r7, #8
   1b626:	46bd      	mov	sp, r7
   1b628:	bd80      	pop	{r7, pc}
   1b62a:	bf00      	nop
   1b62c:	10010f60 	.word	0x10010f60

0001b630 <appMasterSecConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecConnOpen(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b630:	b580      	push	{r7, lr}
   1b632:	b082      	sub	sp, #8
   1b634:	af00      	add	r7, sp, #0
   1b636:	6078      	str	r0, [r7, #4]
   1b638:	6039      	str	r1, [r7, #0]
  /* initialize state variables */
  pCb->bonded = FALSE;
   1b63a:	683b      	ldr	r3, [r7, #0]
   1b63c:	2200      	movs	r2, #0
   1b63e:	715a      	strb	r2, [r3, #5]
  pCb->bondByLtk = FALSE;
   1b640:	683b      	ldr	r3, [r7, #0]
   1b642:	2200      	movs	r2, #0
   1b644:	719a      	strb	r2, [r3, #6]
  pCb->bondByPairing = FALSE;
   1b646:	683b      	ldr	r3, [r7, #0]
   1b648:	2200      	movs	r2, #0
   1b64a:	71da      	strb	r2, [r3, #7]
  pCb->initiatingSec = FALSE;
   1b64c:	683b      	ldr	r3, [r7, #0]
   1b64e:	2200      	movs	r2, #0
   1b650:	721a      	strb	r2, [r3, #8]

  /* if master initiates security on connection open */
  appMasterInitiateSec((dmConnId_t) pMsg->hdr.param, pAppSecCfg->initiateSec, pCb);
   1b652:	687b      	ldr	r3, [r7, #4]
   1b654:	881b      	ldrh	r3, [r3, #0]
   1b656:	b2d8      	uxtb	r0, r3
   1b658:	4b05      	ldr	r3, [pc, #20]	; (1b670 <appMasterSecConnOpen+0x40>)
   1b65a:	681b      	ldr	r3, [r3, #0]
   1b65c:	791b      	ldrb	r3, [r3, #4]
   1b65e:	683a      	ldr	r2, [r7, #0]
   1b660:	4619      	mov	r1, r3
   1b662:	f7ff fe65 	bl	1b330 <appMasterInitiateSec>
}
   1b666:	bf00      	nop
   1b668:	3708      	adds	r7, #8
   1b66a:	46bd      	mov	sp, r7
   1b66c:	bd80      	pop	{r7, pc}
   1b66e:	bf00      	nop
   1b670:	10010ec0 	.word	0x10010ec0

0001b674 <appMasterSecConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecConnClose(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b674:	b580      	push	{r7, lr}
   1b676:	b082      	sub	sp, #8
   1b678:	af00      	add	r7, sp, #0
   1b67a:	6078      	str	r0, [r7, #4]
   1b67c:	6039      	str	r1, [r7, #0]
  /* if a device record was created check if it is valid */
  if (pCb->dbHdl != APP_DB_HDL_NONE)
   1b67e:	683b      	ldr	r3, [r7, #0]
   1b680:	681b      	ldr	r3, [r3, #0]
   1b682:	2b00      	cmp	r3, #0
   1b684:	d004      	beq.n	1b690 <appMasterSecConnClose+0x1c>
  {
    AppDbCheckValidRecord(pCb->dbHdl);
   1b686:	683b      	ldr	r3, [r7, #0]
   1b688:	681b      	ldr	r3, [r3, #0]
   1b68a:	4618      	mov	r0, r3
   1b68c:	f7ff fb62 	bl	1ad54 <AppDbCheckValidRecord>
  }
}
   1b690:	bf00      	nop
   1b692:	3708      	adds	r7, #8
   1b694:	46bd      	mov	sp, r7
   1b696:	bd80      	pop	{r7, pc}

0001b698 <appMasterSecSlaveReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecSlaveReq(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b698:	b580      	push	{r7, lr}
   1b69a:	b082      	sub	sp, #8
   1b69c:	af00      	add	r7, sp, #0
   1b69e:	6078      	str	r0, [r7, #4]
   1b6a0:	6039      	str	r1, [r7, #0]
  /* if master is not initiating security and not already secure */
  if (!pAppSecCfg->initiateSec && !pCb->initiatingSec &&
   1b6a2:	4b0f      	ldr	r3, [pc, #60]	; (1b6e0 <appMasterSecSlaveReq+0x48>)
   1b6a4:	681b      	ldr	r3, [r3, #0]
   1b6a6:	791b      	ldrb	r3, [r3, #4]
   1b6a8:	2b00      	cmp	r3, #0
   1b6aa:	d114      	bne.n	1b6d6 <appMasterSecSlaveReq+0x3e>
   1b6ac:	683b      	ldr	r3, [r7, #0]
   1b6ae:	7a1b      	ldrb	r3, [r3, #8]
   1b6b0:	2b00      	cmp	r3, #0
   1b6b2:	d110      	bne.n	1b6d6 <appMasterSecSlaveReq+0x3e>
      (DmConnSecLevel((dmConnId_t) pMsg->hdr.param) == DM_SEC_LEVEL_NONE))
   1b6b4:	687b      	ldr	r3, [r7, #4]
   1b6b6:	881b      	ldrh	r3, [r3, #0]
   1b6b8:	b2db      	uxtb	r3, r3
   1b6ba:	4618      	mov	r0, r3
   1b6bc:	f007 ff4a 	bl	23554 <DmConnSecLevel>
   1b6c0:	4603      	mov	r3, r0
  if (!pAppSecCfg->initiateSec && !pCb->initiatingSec &&
   1b6c2:	2b00      	cmp	r3, #0
   1b6c4:	d107      	bne.n	1b6d6 <appMasterSecSlaveReq+0x3e>
  {
    appMasterInitiateSec((dmConnId_t) pMsg->hdr.param, TRUE, pCb);
   1b6c6:	687b      	ldr	r3, [r7, #4]
   1b6c8:	881b      	ldrh	r3, [r3, #0]
   1b6ca:	b2db      	uxtb	r3, r3
   1b6cc:	683a      	ldr	r2, [r7, #0]
   1b6ce:	2101      	movs	r1, #1
   1b6d0:	4618      	mov	r0, r3
   1b6d2:	f7ff fe2d 	bl	1b330 <appMasterInitiateSec>
  }
}
   1b6d6:	bf00      	nop
   1b6d8:	3708      	adds	r7, #8
   1b6da:	46bd      	mov	sp, r7
   1b6dc:	bd80      	pop	{r7, pc}
   1b6de:	bf00      	nop
   1b6e0:	10010ec0 	.word	0x10010ec0

0001b6e4 <appPrivSetAddrResEnableInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appPrivSetAddrResEnableInd(dmEvt_t *pMsg)
{
   1b6e4:	b580      	push	{r7, lr}
   1b6e6:	b082      	sub	sp, #8
   1b6e8:	af00      	add	r7, sp, #0
   1b6ea:	6078      	str	r0, [r7, #4]
  if (pMsg->hdr.status == HCI_SUCCESS)
   1b6ec:	687b      	ldr	r3, [r7, #4]
   1b6ee:	78db      	ldrb	r3, [r3, #3]
   1b6f0:	2b00      	cmp	r3, #0
   1b6f2:	d105      	bne.n	1b700 <appPrivSetAddrResEnableInd+0x1c>
  {
    SvcCoreGapCentAddrResUpdate(DmLlPrivEnabled());
   1b6f4:	f008 fbea 	bl	23ecc <DmLlPrivEnabled>
   1b6f8:	4603      	mov	r3, r0
   1b6fa:	4618      	mov	r0, r3
   1b6fc:	f013 ffe4 	bl	2f6c8 <SvcCoreGapCentAddrResUpdate>
  }
}
   1b700:	bf00      	nop
   1b702:	3708      	adds	r7, #8
   1b704:	46bd      	mov	sp, r7
   1b706:	bd80      	pop	{r7, pc}

0001b708 <appPrivAddDevToResListInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appPrivAddDevToResListInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b708:	b580      	push	{r7, lr}
   1b70a:	b082      	sub	sp, #8
   1b70c:	af00      	add	r7, sp, #0
   1b70e:	6078      	str	r0, [r7, #4]
   1b710:	6039      	str	r1, [r7, #0]
  if ((pMsg->hdr.status == HCI_SUCCESS) && (pCb->dbHdl != APP_DB_HDL_NONE))
   1b712:	687b      	ldr	r3, [r7, #4]
   1b714:	78db      	ldrb	r3, [r3, #3]
   1b716:	2b00      	cmp	r3, #0
   1b718:	d109      	bne.n	1b72e <appPrivAddDevToResListInd+0x26>
   1b71a:	683b      	ldr	r3, [r7, #0]
   1b71c:	681b      	ldr	r3, [r3, #0]
   1b71e:	2b00      	cmp	r3, #0
   1b720:	d005      	beq.n	1b72e <appPrivAddDevToResListInd+0x26>
  {
    /* peer device's been added to resolving list */
    AppDbSetPeerAddedToRl(pCb->dbHdl, TRUE);
   1b722:	683b      	ldr	r3, [r7, #0]
   1b724:	681b      	ldr	r3, [r3, #0]
   1b726:	2101      	movs	r1, #1
   1b728:	4618      	mov	r0, r3
   1b72a:	f7ff fcb2 	bl	1b092 <AppDbSetPeerAddedToRl>
  }
}
   1b72e:	bf00      	nop
   1b730:	3708      	adds	r7, #8
   1b732:	46bd      	mov	sp, r7
   1b734:	bd80      	pop	{r7, pc}

0001b736 <appPrivRemDevFromResListInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appPrivRemDevFromResListInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b736:	b580      	push	{r7, lr}
   1b738:	b082      	sub	sp, #8
   1b73a:	af00      	add	r7, sp, #0
   1b73c:	6078      	str	r0, [r7, #4]
   1b73e:	6039      	str	r1, [r7, #0]
  if ((pMsg->hdr.status == HCI_SUCCESS) && (pCb->dbHdl != APP_DB_HDL_NONE))
   1b740:	687b      	ldr	r3, [r7, #4]
   1b742:	78db      	ldrb	r3, [r3, #3]
   1b744:	2b00      	cmp	r3, #0
   1b746:	d109      	bne.n	1b75c <appPrivRemDevFromResListInd+0x26>
   1b748:	683b      	ldr	r3, [r7, #0]
   1b74a:	681b      	ldr	r3, [r3, #0]
   1b74c:	2b00      	cmp	r3, #0
   1b74e:	d005      	beq.n	1b75c <appPrivRemDevFromResListInd+0x26>
  {
    /* peer device's been removed from resolving list */
    AppDbSetPeerAddedToRl(pCb->dbHdl, FALSE);
   1b750:	683b      	ldr	r3, [r7, #0]
   1b752:	681b      	ldr	r3, [r3, #0]
   1b754:	2100      	movs	r1, #0
   1b756:	4618      	mov	r0, r3
   1b758:	f7ff fc9b 	bl	1b092 <AppDbSetPeerAddedToRl>
  }
}
   1b75c:	bf00      	nop
   1b75e:	3708      	adds	r7, #8
   1b760:	46bd      	mov	sp, r7
   1b762:	bd80      	pop	{r7, pc}

0001b764 <appMasterSecStoreKey>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecStoreKey(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b764:	b580      	push	{r7, lr}
   1b766:	b082      	sub	sp, #8
   1b768:	af00      	add	r7, sp, #0
   1b76a:	6078      	str	r0, [r7, #4]
   1b76c:	6039      	str	r1, [r7, #0]
  if (pCb->bondByPairing && pCb->dbHdl != APP_DB_HDL_NONE)
   1b76e:	683b      	ldr	r3, [r7, #0]
   1b770:	79db      	ldrb	r3, [r3, #7]
   1b772:	2b00      	cmp	r3, #0
   1b774:	d012      	beq.n	1b79c <appMasterSecStoreKey+0x38>
   1b776:	683b      	ldr	r3, [r7, #0]
   1b778:	681b      	ldr	r3, [r3, #0]
   1b77a:	2b00      	cmp	r3, #0
   1b77c:	d00e      	beq.n	1b79c <appMasterSecStoreKey+0x38>
  {
    /* key was received */
    pCb->rcvdKeys |= pMsg->keyInd.type;
   1b77e:	683b      	ldr	r3, [r7, #0]
   1b780:	7ada      	ldrb	r2, [r3, #11]
   1b782:	687b      	ldr	r3, [r7, #4]
   1b784:	7f9b      	ldrb	r3, [r3, #30]
   1b786:	4313      	orrs	r3, r2
   1b788:	b2da      	uxtb	r2, r3
   1b78a:	683b      	ldr	r3, [r7, #0]
   1b78c:	72da      	strb	r2, [r3, #11]

    /* store key in record */
    AppDbSetKey(pCb->dbHdl, &pMsg->keyInd);
   1b78e:	683b      	ldr	r3, [r7, #0]
   1b790:	681b      	ldr	r3, [r3, #0]
   1b792:	687a      	ldr	r2, [r7, #4]
   1b794:	4611      	mov	r1, r2
   1b796:	4618      	mov	r0, r3
   1b798:	f7ff fbf2 	bl	1af80 <AppDbSetKey>
  }
}
   1b79c:	bf00      	nop
   1b79e:	3708      	adds	r7, #8
   1b7a0:	46bd      	mov	sp, r7
   1b7a2:	bd80      	pop	{r7, pc}

0001b7a4 <appMasterSecPairCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecPairCmpl(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b7a4:	b580      	push	{r7, lr}
   1b7a6:	b082      	sub	sp, #8
   1b7a8:	af00      	add	r7, sp, #0
   1b7aa:	6078      	str	r0, [r7, #4]
   1b7ac:	6039      	str	r1, [r7, #0]
  /* if bonding */
  if (pMsg->pairCmpl.auth & DM_AUTH_BOND_FLAG)
   1b7ae:	687b      	ldr	r3, [r7, #4]
   1b7b0:	791b      	ldrb	r3, [r3, #4]
   1b7b2:	f003 0301 	and.w	r3, r3, #1
   1b7b6:	2b00      	cmp	r3, #0
   1b7b8:	d018      	beq.n	1b7ec <appMasterSecPairCmpl+0x48>
  {
    /* set bonded state */
    pCb->bonded = TRUE;
   1b7ba:	683b      	ldr	r3, [r7, #0]
   1b7bc:	2201      	movs	r2, #1
   1b7be:	715a      	strb	r2, [r3, #5]

    /* validate record and received keys */
    if (pCb->dbHdl != APP_DB_HDL_NONE)
   1b7c0:	683b      	ldr	r3, [r7, #0]
   1b7c2:	681b      	ldr	r3, [r3, #0]
   1b7c4:	2b00      	cmp	r3, #0
   1b7c6:	d007      	beq.n	1b7d8 <appMasterSecPairCmpl+0x34>
    {
      AppDbValidateRecord(pCb->dbHdl, pCb->rcvdKeys);
   1b7c8:	683b      	ldr	r3, [r7, #0]
   1b7ca:	681a      	ldr	r2, [r3, #0]
   1b7cc:	683b      	ldr	r3, [r7, #0]
   1b7ce:	7adb      	ldrb	r3, [r3, #11]
   1b7d0:	4619      	mov	r1, r3
   1b7d2:	4610      	mov	r0, r2
   1b7d4:	f7ff faaa 	bl	1ad2c <AppDbValidateRecord>
    }

    /* if bonded, add device to resolving list */
    if (pCb->dbHdl != APP_DB_HDL_NONE)
   1b7d8:	683b      	ldr	r3, [r7, #0]
   1b7da:	681b      	ldr	r3, [r3, #0]
   1b7dc:	2b00      	cmp	r3, #0
   1b7de:	d005      	beq.n	1b7ec <appMasterSecPairCmpl+0x48>
    {
      AppAddDevToResList(pMsg, pCb->connId);
   1b7e0:	683b      	ldr	r3, [r7, #0]
   1b7e2:	791b      	ldrb	r3, [r3, #4]
   1b7e4:	4619      	mov	r1, r3
   1b7e6:	6878      	ldr	r0, [r7, #4]
   1b7e8:	f7ff fd14 	bl	1b214 <AppAddDevToResList>
    }
  }

  pCb->initiatingSec = FALSE;
   1b7ec:	683b      	ldr	r3, [r7, #0]
   1b7ee:	2200      	movs	r2, #0
   1b7f0:	721a      	strb	r2, [r3, #8]
}
   1b7f2:	bf00      	nop
   1b7f4:	3708      	adds	r7, #8
   1b7f6:	46bd      	mov	sp, r7
   1b7f8:	bd80      	pop	{r7, pc}

0001b7fa <appMasterSecPairFailed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecPairFailed(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b7fa:	b580      	push	{r7, lr}
   1b7fc:	b082      	sub	sp, #8
   1b7fe:	af00      	add	r7, sp, #0
   1b800:	6078      	str	r0, [r7, #4]
   1b802:	6039      	str	r1, [r7, #0]
  pCb->initiatingSec = FALSE;
   1b804:	683b      	ldr	r3, [r7, #0]
   1b806:	2200      	movs	r2, #0
   1b808:	721a      	strb	r2, [r3, #8]
  // disconnect the connection when paired failed to avoid spoofing reported by https://nvd.nist.gov/vuln/detail/CVE-2020-9770
  AppConnClose(pMsg->hdr.param);
   1b80a:	687b      	ldr	r3, [r7, #4]
   1b80c:	881b      	ldrh	r3, [r3, #0]
   1b80e:	b2db      	uxtb	r3, r3
   1b810:	4618      	mov	r0, r3
   1b812:	f7ff fcef 	bl	1b1f4 <AppConnClose>
  return;
   1b816:	bf00      	nop
}
   1b818:	3708      	adds	r7, #8
   1b81a:	46bd      	mov	sp, r7
   1b81c:	bd80      	pop	{r7, pc}

0001b81e <appMasterSecEncryptInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterSecEncryptInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b81e:	b480      	push	{r7}
   1b820:	b083      	sub	sp, #12
   1b822:	af00      	add	r7, sp, #0
   1b824:	6078      	str	r0, [r7, #4]
   1b826:	6039      	str	r1, [r7, #0]
  /* check if bonding state should be set */
  if (pCb->bondByLtk && pMsg->encryptInd.usingLtk)
   1b828:	683b      	ldr	r3, [r7, #0]
   1b82a:	799b      	ldrb	r3, [r3, #6]
   1b82c:	2b00      	cmp	r3, #0
   1b82e:	d00c      	beq.n	1b84a <appMasterSecEncryptInd+0x2c>
   1b830:	687b      	ldr	r3, [r7, #4]
   1b832:	791b      	ldrb	r3, [r3, #4]
   1b834:	2b00      	cmp	r3, #0
   1b836:	d008      	beq.n	1b84a <appMasterSecEncryptInd+0x2c>
  {
    pCb->bonded = TRUE;
   1b838:	683b      	ldr	r3, [r7, #0]
   1b83a:	2201      	movs	r2, #1
   1b83c:	715a      	strb	r2, [r3, #5]
    pCb->bondByLtk = FALSE;
   1b83e:	683b      	ldr	r3, [r7, #0]
   1b840:	2200      	movs	r2, #0
   1b842:	719a      	strb	r2, [r3, #6]
    pCb->initiatingSec = FALSE;
   1b844:	683b      	ldr	r3, [r7, #0]
   1b846:	2200      	movs	r2, #0
   1b848:	721a      	strb	r2, [r3, #8]
  }
}
   1b84a:	bf00      	nop
   1b84c:	370c      	adds	r7, #12
   1b84e:	46bd      	mov	sp, r7
   1b850:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b854:	4770      	bx	lr

0001b856 <appMasterProcMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appMasterProcMsg(wsfMsgHdr_t *pMsg)
{
   1b856:	b480      	push	{r7}
   1b858:	b083      	sub	sp, #12
   1b85a:	af00      	add	r7, sp, #0
   1b85c:	6078      	str	r0, [r7, #4]
  switch(pMsg->event)
   1b85e:	687b      	ldr	r3, [r7, #4]
   1b860:	789b      	ldrb	r3, [r3, #2]
   1b862:	2b10      	cmp	r3, #16
  {
    case APP_CONN_UPDATE_TIMEOUT_IND:
      break;

    default:
      break;
   1b864:	bf00      	nop
  }
}
   1b866:	bf00      	nop
   1b868:	370c      	adds	r7, #12
   1b86a:	46bd      	mov	sp, r7
   1b86c:	f85d 7b04 	ldr.w	r7, [sp], #4
   1b870:	4770      	bx	lr
	...

0001b874 <appMasterResolvedAddrInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterResolvedAddrInd(dmEvt_t *pMsg)
{
   1b874:	b590      	push	{r4, r7, lr}
   1b876:	b085      	sub	sp, #20
   1b878:	af00      	add	r7, sp, #0
   1b87a:	6078      	str	r0, [r7, #4]
  appDevInfo_t *pDev;
  dmSecKey_t *pPeerKey;

  /* if address resolution is not in progress */
  if (!appMasterCb.inProgress)
   1b87c:	4b3f      	ldr	r3, [pc, #252]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b87e:	f893 309c 	ldrb.w	r3, [r3, #156]	; 0x9c
   1b882:	2b00      	cmp	r3, #0
   1b884:	d075      	beq.n	1b972 <appMasterResolvedAddrInd+0xfe>
  {
    return;
  }

  /* get device record */
  pDev = &appMasterCb.scanResults[appMasterCb.idx];
   1b886:	4b3d      	ldr	r3, [pc, #244]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b888:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
   1b88c:	461a      	mov	r2, r3
   1b88e:	4613      	mov	r3, r2
   1b890:	011b      	lsls	r3, r3, #4
   1b892:	1a9b      	subs	r3, r3, r2
   1b894:	4a39      	ldr	r2, [pc, #228]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b896:	4413      	add	r3, r2
   1b898:	60fb      	str	r3, [r7, #12]

  /* if RPA resolved */
  if (pMsg->hdr.status == HCI_SUCCESS)
   1b89a:	687b      	ldr	r3, [r7, #4]
   1b89c:	78db      	ldrb	r3, [r3, #3]
   1b89e:	2b00      	cmp	r3, #0
   1b8a0:	d137      	bne.n	1b912 <appMasterResolvedAddrInd+0x9e>
  {
    /* if resolved advertising was directed with an RPA initiator address */
    if ((pMsg->hdr.param == APP_RESOLVE_ADV_RPA) && DM_RAND_ADDR_RPA(pDev->directAddr, pDev->directAddrType))
   1b8a2:	687b      	ldr	r3, [r7, #4]
   1b8a4:	881b      	ldrh	r3, [r3, #0]
   1b8a6:	2b00      	cmp	r3, #0
   1b8a8:	d115      	bne.n	1b8d6 <appMasterResolvedAddrInd+0x62>
   1b8aa:	68fb      	ldr	r3, [r7, #12]
   1b8ac:	79db      	ldrb	r3, [r3, #7]
   1b8ae:	2b01      	cmp	r3, #1
   1b8b0:	d111      	bne.n	1b8d6 <appMasterResolvedAddrInd+0x62>
   1b8b2:	68fb      	ldr	r3, [r7, #12]
   1b8b4:	7b5b      	ldrb	r3, [r3, #13]
   1b8b6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1b8ba:	2b40      	cmp	r3, #64	; 0x40
   1b8bc:	d10b      	bne.n	1b8d6 <appMasterResolvedAddrInd+0x62>
    {
      /* resolve initiator's RPA to see if directed advertisement was addressed to us */
      DmPrivResolveAddr(pDev->directAddr, DmSecGetLocalIrk(), APP_RESOLVE_DIRECT_RPA);
   1b8be:	68fb      	ldr	r3, [r7, #12]
   1b8c0:	f103 0408 	add.w	r4, r3, #8
   1b8c4:	f008 ff54 	bl	24770 <DmSecGetLocalIrk>
   1b8c8:	4603      	mov	r3, r0
   1b8ca:	2201      	movs	r2, #1
   1b8cc:	4619      	mov	r1, r3
   1b8ce:	4620      	mov	r0, r4
   1b8d0:	f008 fc1e 	bl	24110 <DmPrivResolveAddr>

      /* not done yet */
      return;
   1b8d4:	e04e      	b.n	1b974 <appMasterResolvedAddrInd+0x100>
    }

    if(DmScanModeLeg())
   1b8d6:	f008 ff17 	bl	24708 <DmScanModeLeg>
   1b8da:	4603      	mov	r3, r0
   1b8dc:	2b00      	cmp	r3, #0
   1b8de:	d00b      	beq.n	1b8f8 <appMasterResolvedAddrInd+0x84>
    {
        /* stop scanning */
        AppScanStop();
   1b8e0:	f000 fab4 	bl	1be4c <AppScanStop>

        /* connect to peer device using its advertising address */
        AppConnOpen(pDev->addrType, pDev->addr, appMasterCb.dbHdl);
   1b8e4:	68fb      	ldr	r3, [r7, #12]
   1b8e6:	799b      	ldrb	r3, [r3, #6]
   1b8e8:	68f9      	ldr	r1, [r7, #12]
   1b8ea:	4a24      	ldr	r2, [pc, #144]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b8ec:	f8d2 2098 	ldr.w	r2, [r2, #152]	; 0x98
   1b8f0:	4618      	mov	r0, r3
   1b8f2:	f000 fabd 	bl	1be70 <AppConnOpen>
   1b8f6:	e037      	b.n	1b968 <appMasterResolvedAddrInd+0xf4>
    }
    else
    {
        AppExtScanStop();
   1b8f8:	f012 fa82 	bl	2de00 <AppExtScanStop>
        AppExtConnOpen(pDev->secPhy, pDev->addrType, pDev->addr, appMasterCb.dbHdl);
   1b8fc:	68fb      	ldr	r3, [r7, #12]
   1b8fe:	7b98      	ldrb	r0, [r3, #14]
   1b900:	68fb      	ldr	r3, [r7, #12]
   1b902:	7999      	ldrb	r1, [r3, #6]
   1b904:	68fa      	ldr	r2, [r7, #12]
   1b906:	4b1d      	ldr	r3, [pc, #116]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b908:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   1b90c:	f012 fa7f 	bl	2de0e <AppExtConnOpen>
   1b910:	e02a      	b.n	1b968 <appMasterResolvedAddrInd+0xf4>
    }
  }
  /* if RPA did not resolve and there're more bonded records to go through */
  else if ((pMsg->hdr.status == HCI_ERR_AUTH_FAILURE) && (appMasterCb.dbHdl != APP_DB_HDL_NONE))
   1b912:	687b      	ldr	r3, [r7, #4]
   1b914:	78db      	ldrb	r3, [r3, #3]
   1b916:	2b05      	cmp	r3, #5
   1b918:	d126      	bne.n	1b968 <appMasterResolvedAddrInd+0xf4>
   1b91a:	4b18      	ldr	r3, [pc, #96]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b91c:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   1b920:	2b00      	cmp	r3, #0
   1b922:	d021      	beq.n	1b968 <appMasterResolvedAddrInd+0xf4>
  {
    /* get the next database record */
    appMasterCb.dbHdl = AppDbGetNextRecord(appMasterCb.dbHdl);
   1b924:	4b15      	ldr	r3, [pc, #84]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b926:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   1b92a:	4618      	mov	r0, r3
   1b92c:	f7ff f9bc 	bl	1aca8 <AppDbGetNextRecord>
   1b930:	4603      	mov	r3, r0
   1b932:	4a12      	ldr	r2, [pc, #72]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b934:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

    /* if there's another bond record */
    if ((appMasterCb.dbHdl != APP_DB_HDL_NONE) &&
   1b938:	4b10      	ldr	r3, [pc, #64]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b93a:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   1b93e:	2b00      	cmp	r3, #0
   1b940:	d012      	beq.n	1b968 <appMasterResolvedAddrInd+0xf4>
        ((pPeerKey = AppDbGetKey(appMasterCb.dbHdl, DM_KEY_IRK, NULL)) != NULL))
   1b942:	4b0e      	ldr	r3, [pc, #56]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b944:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
   1b948:	2200      	movs	r2, #0
   1b94a:	2104      	movs	r1, #4
   1b94c:	4618      	mov	r0, r3
   1b94e:	f7ff facb 	bl	1aee8 <AppDbGetKey>
   1b952:	60b8      	str	r0, [r7, #8]
    if ((appMasterCb.dbHdl != APP_DB_HDL_NONE) &&
   1b954:	68bb      	ldr	r3, [r7, #8]
   1b956:	2b00      	cmp	r3, #0
   1b958:	d006      	beq.n	1b968 <appMasterResolvedAddrInd+0xf4>
    {
      /* resolve RPA using the next stored IRK */
      DmPrivResolveAddr(pDev->addr, pPeerKey->irk.key, APP_RESOLVE_ADV_RPA);
   1b95a:	68fb      	ldr	r3, [r7, #12]
   1b95c:	68b9      	ldr	r1, [r7, #8]
   1b95e:	2200      	movs	r2, #0
   1b960:	4618      	mov	r0, r3
   1b962:	f008 fbd5 	bl	24110 <DmPrivResolveAddr>

      /* not done yet */
      return;
   1b966:	e005      	b.n	1b974 <appMasterResolvedAddrInd+0x100>
    }
  }

  /* done with this address resolution */
  appMasterCb.inProgress = FALSE;
   1b968:	4b04      	ldr	r3, [pc, #16]	; (1b97c <appMasterResolvedAddrInd+0x108>)
   1b96a:	2200      	movs	r2, #0
   1b96c:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c
   1b970:	e000      	b.n	1b974 <appMasterResolvedAddrInd+0x100>
    return;
   1b972:	bf00      	nop
}
   1b974:	3714      	adds	r7, #20
   1b976:	46bd      	mov	sp, r7
   1b978:	bd90      	pop	{r4, r7, pc}
   1b97a:	bf00      	nop
   1b97c:	10010f60 	.word	0x10010f60

0001b980 <appMasterRemoteConnParamReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appMasterRemoteConnParamReq(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1b980:	b580      	push	{r7, lr}
   1b982:	b086      	sub	sp, #24
   1b984:	af00      	add	r7, sp, #0
   1b986:	6078      	str	r0, [r7, #4]
   1b988:	6039      	str	r1, [r7, #0]
  /* if configured to accept the remote connection parameter request */
  if (pAppMasterReqActCfg->remConnParamReqAct == APP_ACT_ACCEPT)
   1b98a:	4b16      	ldr	r3, [pc, #88]	; (1b9e4 <appMasterRemoteConnParamReq+0x64>)
   1b98c:	681b      	ldr	r3, [r3, #0]
   1b98e:	781b      	ldrb	r3, [r3, #0]
   1b990:	2b00      	cmp	r3, #0
   1b992:	d118      	bne.n	1b9c6 <appMasterRemoteConnParamReq+0x46>
  {
    hciConnSpec_t connSpec;

    connSpec.connIntervalMin = pMsg->remConnParamReq.intervalMin;
   1b994:	687b      	ldr	r3, [r7, #4]
   1b996:	88db      	ldrh	r3, [r3, #6]
   1b998:	81bb      	strh	r3, [r7, #12]
    connSpec.connIntervalMax = pMsg->remConnParamReq.intervalMax;
   1b99a:	687b      	ldr	r3, [r7, #4]
   1b99c:	891b      	ldrh	r3, [r3, #8]
   1b99e:	81fb      	strh	r3, [r7, #14]
    connSpec.connLatency = pMsg->remConnParamReq.latency;
   1b9a0:	687b      	ldr	r3, [r7, #4]
   1b9a2:	895b      	ldrh	r3, [r3, #10]
   1b9a4:	823b      	strh	r3, [r7, #16]
    connSpec.supTimeout = pMsg->remConnParamReq.timeout;
   1b9a6:	687b      	ldr	r3, [r7, #4]
   1b9a8:	899b      	ldrh	r3, [r3, #12]
   1b9aa:	827b      	strh	r3, [r7, #18]
    connSpec.minCeLen = connSpec.maxCeLen = 0;
   1b9ac:	2300      	movs	r3, #0
   1b9ae:	82fb      	strh	r3, [r7, #22]
   1b9b0:	8afb      	ldrh	r3, [r7, #22]
   1b9b2:	82bb      	strh	r3, [r7, #20]

    /* accept the remote device's request to change connection parameters */
    DmRemoteConnParamReqReply(pCb->connId, &connSpec);
   1b9b4:	683b      	ldr	r3, [r7, #0]
   1b9b6:	791b      	ldrb	r3, [r3, #4]
   1b9b8:	f107 020c 	add.w	r2, r7, #12
   1b9bc:	4611      	mov	r1, r2
   1b9be:	4618      	mov	r0, r3
   1b9c0:	f007 fce2 	bl	23388 <DmRemoteConnParamReqReply>
  {
    /* reject the remote device's request to change connection parameters */
    DmRemoteConnParamReqNegReply(pCb->connId, HCI_ERR_UNSUP_FEAT);
  }
  /* else - app will handle the remote connection parameter request */
}
   1b9c4:	e00a      	b.n	1b9dc <appMasterRemoteConnParamReq+0x5c>
  else if (pAppMasterReqActCfg->remConnParamReqAct == APP_ACT_REJECT)
   1b9c6:	4b07      	ldr	r3, [pc, #28]	; (1b9e4 <appMasterRemoteConnParamReq+0x64>)
   1b9c8:	681b      	ldr	r3, [r3, #0]
   1b9ca:	781b      	ldrb	r3, [r3, #0]
   1b9cc:	2b01      	cmp	r3, #1
   1b9ce:	d105      	bne.n	1b9dc <appMasterRemoteConnParamReq+0x5c>
    DmRemoteConnParamReqNegReply(pCb->connId, HCI_ERR_UNSUP_FEAT);
   1b9d0:	683b      	ldr	r3, [r7, #0]
   1b9d2:	791b      	ldrb	r3, [r3, #4]
   1b9d4:	2111      	movs	r1, #17
   1b9d6:	4618      	mov	r0, r3
   1b9d8:	f007 fcfe 	bl	233d8 <DmRemoteConnParamReqNegReply>
}
   1b9dc:	bf00      	nop
   1b9de:	3718      	adds	r7, #24
   1b9e0:	46bd      	mov	sp, r7
   1b9e2:	bd80      	pop	{r7, pc}
   1b9e4:	10002b30 	.word	0x10002b30

0001b9e8 <AppMasterInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppMasterInit(void)
{
   1b9e8:	b480      	push	{r7}
   1b9ea:	af00      	add	r7, sp, #0
  appMasterCb.inProgress = FALSE;
   1b9ec:	4b07      	ldr	r3, [pc, #28]	; (1ba0c <AppMasterInit+0x24>)
   1b9ee:	2200      	movs	r2, #0
   1b9f0:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c

  /* initialize scan mode */
  appMasterCb.scanMode = APP_SCAN_MODE_NONE;
   1b9f4:	4b05      	ldr	r3, [pc, #20]	; (1ba0c <AppMasterInit+0x24>)
   1b9f6:	22ff      	movs	r2, #255	; 0xff
   1b9f8:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d

  /* set up callback from main */
  appCb.masterCback = appMasterProcMsg;
   1b9fc:	4b04      	ldr	r3, [pc, #16]	; (1ba10 <AppMasterInit+0x28>)
   1b9fe:	4a05      	ldr	r2, [pc, #20]	; (1ba14 <AppMasterInit+0x2c>)
   1ba00:	605a      	str	r2, [r3, #4]
}
   1ba02:	bf00      	nop
   1ba04:	46bd      	mov	sp, r7
   1ba06:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ba0a:	4770      	bx	lr
   1ba0c:	10010f60 	.word	0x10010f60
   1ba10:	10010ea0 	.word	0x10010ea0
   1ba14:	0001b857 	.word	0x0001b857

0001ba18 <AppMasterProcDmMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppMasterProcDmMsg(dmEvt_t *pMsg)
{
   1ba18:	b580      	push	{r7, lr}
   1ba1a:	b084      	sub	sp, #16
   1ba1c:	af00      	add	r7, sp, #0
   1ba1e:	6078      	str	r0, [r7, #4]
  appConnCb_t *pCb = NULL;
   1ba20:	2300      	movs	r3, #0
   1ba22:	60fb      	str	r3, [r7, #12]

  /* look up app connection control block from DM connection ID */
  if (pMsg->hdr.event == DM_CONN_OPEN_IND  ||
   1ba24:	687b      	ldr	r3, [r7, #4]
   1ba26:	789b      	ldrb	r3, [r3, #2]
   1ba28:	2b27      	cmp	r3, #39	; 0x27
   1ba2a:	d007      	beq.n	1ba3c <AppMasterProcDmMsg+0x24>
      pMsg->hdr.event == DM_CONN_CLOSE_IND ||
   1ba2c:	687b      	ldr	r3, [r7, #4]
   1ba2e:	789b      	ldrb	r3, [r3, #2]
  if (pMsg->hdr.event == DM_CONN_OPEN_IND  ||
   1ba30:	2b28      	cmp	r3, #40	; 0x28
   1ba32:	d003      	beq.n	1ba3c <AppMasterProcDmMsg+0x24>
      pMsg->hdr.event == DM_REM_CONN_PARAM_REQ_IND)
   1ba34:	687b      	ldr	r3, [r7, #4]
   1ba36:	789b      	ldrb	r3, [r3, #2]
      pMsg->hdr.event == DM_CONN_CLOSE_IND ||
   1ba38:	2b40      	cmp	r3, #64	; 0x40
   1ba3a:	d109      	bne.n	1ba50 <AppMasterProcDmMsg+0x38>
  {
    pCb = &appConnCb[pMsg->hdr.param - 1];
   1ba3c:	687b      	ldr	r3, [r7, #4]
   1ba3e:	881b      	ldrh	r3, [r3, #0]
   1ba40:	1e5a      	subs	r2, r3, #1
   1ba42:	4613      	mov	r3, r2
   1ba44:	005b      	lsls	r3, r3, #1
   1ba46:	4413      	add	r3, r2
   1ba48:	011b      	lsls	r3, r3, #4
   1ba4a:	4a48      	ldr	r2, [pc, #288]	; (1bb6c <AppMasterProcDmMsg+0x154>)
   1ba4c:	4413      	add	r3, r2
   1ba4e:	60fb      	str	r3, [r7, #12]
  }

  switch(pMsg->hdr.event)
   1ba50:	687b      	ldr	r3, [r7, #4]
   1ba52:	789b      	ldrb	r3, [r3, #2]
   1ba54:	3b20      	subs	r3, #32
   1ba56:	2b2c      	cmp	r3, #44	; 0x2c
   1ba58:	f200 8082 	bhi.w	1bb60 <AppMasterProcDmMsg+0x148>
   1ba5c:	a201      	add	r2, pc, #4	; (adr r2, 1ba64 <AppMasterProcDmMsg+0x4c>)
   1ba5e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1ba62:	bf00      	nop
   1ba64:	0001bb19 	.word	0x0001bb19
   1ba68:	0001bb61 	.word	0x0001bb61
   1ba6c:	0001bb61 	.word	0x0001bb61
   1ba70:	0001bb61 	.word	0x0001bb61
   1ba74:	0001bb23 	.word	0x0001bb23
   1ba78:	0001bb2b 	.word	0x0001bb2b
   1ba7c:	0001bb33 	.word	0x0001bb33
   1ba80:	0001bb3b 	.word	0x0001bb3b
   1ba84:	0001bb45 	.word	0x0001bb45
   1ba88:	0001bb61 	.word	0x0001bb61
   1ba8c:	0001bb61 	.word	0x0001bb61
   1ba90:	0001bb61 	.word	0x0001bb61
   1ba94:	0001bb61 	.word	0x0001bb61
   1ba98:	0001bb61 	.word	0x0001bb61
   1ba9c:	0001bb61 	.word	0x0001bb61
   1baa0:	0001bb61 	.word	0x0001bb61
   1baa4:	0001bb61 	.word	0x0001bb61
   1baa8:	0001bb61 	.word	0x0001bb61
   1baac:	0001bb61 	.word	0x0001bb61
   1bab0:	0001bb61 	.word	0x0001bb61
   1bab4:	0001bb61 	.word	0x0001bb61
   1bab8:	0001bb61 	.word	0x0001bb61
   1babc:	0001bb61 	.word	0x0001bb61
   1bac0:	0001bb4f 	.word	0x0001bb4f
   1bac4:	0001bb61 	.word	0x0001bb61
   1bac8:	0001bb61 	.word	0x0001bb61
   1bacc:	0001bb61 	.word	0x0001bb61
   1bad0:	0001bb61 	.word	0x0001bb61
   1bad4:	0001bb61 	.word	0x0001bb61
   1bad8:	0001bb61 	.word	0x0001bb61
   1badc:	0001bb61 	.word	0x0001bb61
   1bae0:	0001bb61 	.word	0x0001bb61
   1bae4:	0001bb57 	.word	0x0001bb57
   1bae8:	0001bb61 	.word	0x0001bb61
   1baec:	0001bb61 	.word	0x0001bb61
   1baf0:	0001bb61 	.word	0x0001bb61
   1baf4:	0001bb61 	.word	0x0001bb61
   1baf8:	0001bb61 	.word	0x0001bb61
   1bafc:	0001bb61 	.word	0x0001bb61
   1bb00:	0001bb61 	.word	0x0001bb61
   1bb04:	0001bb61 	.word	0x0001bb61
   1bb08:	0001bb61 	.word	0x0001bb61
   1bb0c:	0001bb23 	.word	0x0001bb23
   1bb10:	0001bb2b 	.word	0x0001bb2b
   1bb14:	0001bb33 	.word	0x0001bb33
  {
    case DM_RESET_CMPL_IND:
      /* reset scan mode */
      appMasterCb.scanMode = APP_SCAN_MODE_NONE;
   1bb18:	4b15      	ldr	r3, [pc, #84]	; (1bb70 <AppMasterProcDmMsg+0x158>)
   1bb1a:	22ff      	movs	r2, #255	; 0xff
   1bb1c:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d
      break;
   1bb20:	e01f      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_EXT_SCAN_START_IND:
    case DM_SCAN_START_IND:
      appMasterScanStart(pMsg);
   1bb22:	6878      	ldr	r0, [r7, #4]
   1bb24:	f7ff fd2e 	bl	1b584 <appMasterScanStart>
      break;
   1bb28:	e01b      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_EXT_SCAN_STOP_IND:
    case DM_SCAN_STOP_IND:
      appMasterScanStop(pMsg);
   1bb2a:	6878      	ldr	r0, [r7, #4]
   1bb2c:	f7ff fd38 	bl	1b5a0 <appMasterScanStop>
      break;
   1bb30:	e017      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_EXT_SCAN_REPORT_IND:
    case DM_SCAN_REPORT_IND:
      appMasterScanReport(pMsg);
   1bb32:	6878      	ldr	r0, [r7, #4]
   1bb34:	f7ff fd4a 	bl	1b5cc <appMasterScanReport>
      break;
   1bb38:	e013      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_CONN_OPEN_IND:
      appMasterConnOpen(pMsg, pCb);
   1bb3a:	68f9      	ldr	r1, [r7, #12]
   1bb3c:	6878      	ldr	r0, [r7, #4]
   1bb3e:	f7ff fd50 	bl	1b5e2 <appMasterConnOpen>
      break;
   1bb42:	e00e      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_CONN_CLOSE_IND:
      appMasterConnClose(pMsg, pCb);
   1bb44:	68f9      	ldr	r1, [r7, #12]
   1bb46:	6878      	ldr	r0, [r7, #4]
   1bb48:	f7ff fd5a 	bl	1b600 <appMasterConnClose>
      break;
   1bb4c:	e009      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_PRIV_RESOLVED_ADDR_IND:
      appMasterResolvedAddrInd(pMsg);
   1bb4e:	6878      	ldr	r0, [r7, #4]
   1bb50:	f7ff fe90 	bl	1b874 <appMasterResolvedAddrInd>
      break;
   1bb54:	e005      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    case DM_REM_CONN_PARAM_REQ_IND:
      appMasterRemoteConnParamReq(pMsg, pCb);
   1bb56:	68f9      	ldr	r1, [r7, #12]
   1bb58:	6878      	ldr	r0, [r7, #4]
   1bb5a:	f7ff ff11 	bl	1b980 <appMasterRemoteConnParamReq>
      break;
   1bb5e:	e000      	b.n	1bb62 <AppMasterProcDmMsg+0x14a>

    default:
      break;
   1bb60:	bf00      	nop
  }
}
   1bb62:	bf00      	nop
   1bb64:	3710      	adds	r7, #16
   1bb66:	46bd      	mov	sp, r7
   1bb68:	bd80      	pop	{r7, pc}
   1bb6a:	bf00      	nop
   1bb6c:	10010ed0 	.word	0x10010ed0
   1bb70:	10010f60 	.word	0x10010f60

0001bb74 <AppMasterSecProcDmMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppMasterSecProcDmMsg(dmEvt_t *pMsg)
{
   1bb74:	b580      	push	{r7, lr}
   1bb76:	b084      	sub	sp, #16
   1bb78:	af00      	add	r7, sp, #0
   1bb7a:	6078      	str	r0, [r7, #4]
  appConnCb_t *pCb;

  /* look up app connection control block from DM connection ID */
  pCb = &appConnCb[pMsg->hdr.param - 1];
   1bb7c:	687b      	ldr	r3, [r7, #4]
   1bb7e:	881b      	ldrh	r3, [r3, #0]
   1bb80:	1e5a      	subs	r2, r3, #1
   1bb82:	4613      	mov	r3, r2
   1bb84:	005b      	lsls	r3, r3, #1
   1bb86:	4413      	add	r3, r2
   1bb88:	011b      	lsls	r3, r3, #4
   1bb8a:	4a68      	ldr	r2, [pc, #416]	; (1bd2c <AppMasterSecProcDmMsg+0x1b8>)
   1bb8c:	4413      	add	r3, r2
   1bb8e:	60fb      	str	r3, [r7, #12]

  switch(pMsg->hdr.event)
   1bb90:	687b      	ldr	r3, [r7, #4]
   1bb92:	789b      	ldrb	r3, [r3, #2]
   1bb94:	3b27      	subs	r3, #39	; 0x27
   1bb96:	2b3f      	cmp	r3, #63	; 0x3f
   1bb98:	f200 80c2 	bhi.w	1bd20 <AppMasterSecProcDmMsg+0x1ac>
   1bb9c:	a201      	add	r2, pc, #4	; (adr r2, 1bba4 <AppMasterSecProcDmMsg+0x30>)
   1bb9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1bba2:	bf00      	nop
   1bba4:	0001bca5 	.word	0x0001bca5
   1bba8:	0001bcaf 	.word	0x0001bcaf
   1bbac:	0001bd21 	.word	0x0001bd21
   1bbb0:	0001bcb9 	.word	0x0001bcb9
   1bbb4:	0001bcc3 	.word	0x0001bcc3
   1bbb8:	0001bccd 	.word	0x0001bccd
   1bbbc:	0001bcd7 	.word	0x0001bcd7
   1bbc0:	0001bd21 	.word	0x0001bd21
   1bbc4:	0001bce5 	.word	0x0001bce5
   1bbc8:	0001bd21 	.word	0x0001bd21
   1bbcc:	0001bd21 	.word	0x0001bd21
   1bbd0:	0001bcef 	.word	0x0001bcef
   1bbd4:	0001bd21 	.word	0x0001bd21
   1bbd8:	0001bd21 	.word	0x0001bd21
   1bbdc:	0001bd21 	.word	0x0001bd21
   1bbe0:	0001bd21 	.word	0x0001bd21
   1bbe4:	0001bd21 	.word	0x0001bd21
   1bbe8:	0001bd21 	.word	0x0001bd21
   1bbec:	0001bd21 	.word	0x0001bd21
   1bbf0:	0001bd01 	.word	0x0001bd01
   1bbf4:	0001bd0b 	.word	0x0001bd0b
   1bbf8:	0001bd21 	.word	0x0001bd21
   1bbfc:	0001bd21 	.word	0x0001bd21
   1bc00:	0001bd21 	.word	0x0001bd21
   1bc04:	0001bcf9 	.word	0x0001bcf9
   1bc08:	0001bd21 	.word	0x0001bd21
   1bc0c:	0001bd21 	.word	0x0001bd21
   1bc10:	0001bd21 	.word	0x0001bd21
   1bc14:	0001bd21 	.word	0x0001bd21
   1bc18:	0001bd21 	.word	0x0001bd21
   1bc1c:	0001bd21 	.word	0x0001bd21
   1bc20:	0001bd21 	.word	0x0001bd21
   1bc24:	0001bd21 	.word	0x0001bd21
   1bc28:	0001bd21 	.word	0x0001bd21
   1bc2c:	0001bd21 	.word	0x0001bd21
   1bc30:	0001bd21 	.word	0x0001bd21
   1bc34:	0001bd21 	.word	0x0001bd21
   1bc38:	0001bd21 	.word	0x0001bd21
   1bc3c:	0001bd21 	.word	0x0001bd21
   1bc40:	0001bd21 	.word	0x0001bd21
   1bc44:	0001bd21 	.word	0x0001bd21
   1bc48:	0001bd21 	.word	0x0001bd21
   1bc4c:	0001bd21 	.word	0x0001bd21
   1bc50:	0001bd21 	.word	0x0001bd21
   1bc54:	0001bd21 	.word	0x0001bd21
   1bc58:	0001bd21 	.word	0x0001bd21
   1bc5c:	0001bd21 	.word	0x0001bd21
   1bc60:	0001bd21 	.word	0x0001bd21
   1bc64:	0001bd21 	.word	0x0001bd21
   1bc68:	0001bd21 	.word	0x0001bd21
   1bc6c:	0001bd21 	.word	0x0001bd21
   1bc70:	0001bd21 	.word	0x0001bd21
   1bc74:	0001bd21 	.word	0x0001bd21
   1bc78:	0001bd21 	.word	0x0001bd21
   1bc7c:	0001bd21 	.word	0x0001bd21
   1bc80:	0001bd21 	.word	0x0001bd21
   1bc84:	0001bd21 	.word	0x0001bd21
   1bc88:	0001bd21 	.word	0x0001bd21
   1bc8c:	0001bd21 	.word	0x0001bd21
   1bc90:	0001bd21 	.word	0x0001bd21
   1bc94:	0001bd21 	.word	0x0001bd21
   1bc98:	0001bd21 	.word	0x0001bd21
   1bc9c:	0001bd21 	.word	0x0001bd21
   1bca0:	0001bd15 	.word	0x0001bd15
  {
    case DM_CONN_OPEN_IND:
      appMasterSecConnOpen(pMsg, pCb);
   1bca4:	68f9      	ldr	r1, [r7, #12]
   1bca6:	6878      	ldr	r0, [r7, #4]
   1bca8:	f7ff fcc2 	bl	1b630 <appMasterSecConnOpen>
      break;
   1bcac:	e039      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_CONN_CLOSE_IND:
      appMasterSecConnClose(pMsg, pCb);
   1bcae:	68f9      	ldr	r1, [r7, #12]
   1bcb0:	6878      	ldr	r0, [r7, #4]
   1bcb2:	f7ff fcdf 	bl	1b674 <appMasterSecConnClose>
      break;
   1bcb6:	e034      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_PAIR_CMPL_IND:
      appMasterSecPairCmpl(pMsg, pCb);
   1bcb8:	68f9      	ldr	r1, [r7, #12]
   1bcba:	6878      	ldr	r0, [r7, #4]
   1bcbc:	f7ff fd72 	bl	1b7a4 <appMasterSecPairCmpl>
      break;
   1bcc0:	e02f      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_PAIR_FAIL_IND:
      appMasterSecPairFailed(pMsg, pCb);
   1bcc2:	68f9      	ldr	r1, [r7, #12]
   1bcc4:	6878      	ldr	r0, [r7, #4]
   1bcc6:	f7ff fd98 	bl	1b7fa <appMasterSecPairFailed>
      break;
   1bcca:	e02a      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_ENCRYPT_IND:
      appMasterSecEncryptInd(pMsg, pCb);
   1bccc:	68f9      	ldr	r1, [r7, #12]
   1bcce:	6878      	ldr	r0, [r7, #4]
   1bcd0:	f7ff fda5 	bl	1b81e <appMasterSecEncryptInd>
      break;
   1bcd4:	e025      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_ENCRYPT_FAIL_IND:
      // disconnect the connection when paired failed to avoid spoofing reported by https://nvd.nist.gov/vuln/detail/CVE-2020-9770
      AppConnClose(pMsg->hdr.param);
   1bcd6:	687b      	ldr	r3, [r7, #4]
   1bcd8:	881b      	ldrh	r3, [r3, #0]
   1bcda:	b2db      	uxtb	r3, r3
   1bcdc:	4618      	mov	r0, r3
   1bcde:	f7ff fa89 	bl	1b1f4 <AppConnClose>
      break;
   1bce2:	e01e      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_KEY_IND:
      appMasterSecStoreKey(pMsg, pCb);
   1bce4:	68f9      	ldr	r1, [r7, #12]
   1bce6:	6878      	ldr	r0, [r7, #4]
   1bce8:	f7ff fd3c 	bl	1b764 <appMasterSecStoreKey>
      break;
   1bcec:	e019      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_SEC_SLAVE_REQ_IND:
      appMasterSecSlaveReq(pMsg, pCb);
   1bcee:	68f9      	ldr	r1, [r7, #12]
   1bcf0:	6878      	ldr	r0, [r7, #4]
   1bcf2:	f7ff fcd1 	bl	1b698 <appMasterSecSlaveReq>
      break;
   1bcf6:	e014      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_PRIV_SET_ADDR_RES_ENABLE_IND:
      appPrivSetAddrResEnableInd(pMsg);
   1bcf8:	6878      	ldr	r0, [r7, #4]
   1bcfa:	f7ff fcf3 	bl	1b6e4 <appPrivSetAddrResEnableInd>
      break;
   1bcfe:	e010      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_PRIV_ADD_DEV_TO_RES_LIST_IND:
      appPrivAddDevToResListInd(pMsg, pCb);
   1bd00:	68f9      	ldr	r1, [r7, #12]
   1bd02:	6878      	ldr	r0, [r7, #4]
   1bd04:	f7ff fd00 	bl	1b708 <appPrivAddDevToResListInd>
      break;
   1bd08:	e00b      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_PRIV_REM_DEV_FROM_RES_LIST_IND:
      appPrivRemDevFromResListInd(pMsg, pCb);
   1bd0a:	68f9      	ldr	r1, [r7, #12]
   1bd0c:	6878      	ldr	r0, [r7, #4]
   1bd0e:	f7ff fd12 	bl	1b736 <appPrivRemDevFromResListInd>
      break;
   1bd12:	e006      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    case DM_HW_ERROR_IND:
      HciDrvRadioBoot(0);
   1bd14:	2000      	movs	r0, #0
   1bd16:	f00a fe27 	bl	26968 <HciDrvRadioBoot>
      DmDevReset();
   1bd1a:	f007 ffcf 	bl	23cbc <DmDevReset>
      break;
   1bd1e:	e000      	b.n	1bd22 <AppMasterSecProcDmMsg+0x1ae>

    default:
      break;
   1bd20:	bf00      	nop
  }
}
   1bd22:	bf00      	nop
   1bd24:	3710      	adds	r7, #16
   1bd26:	46bd      	mov	sp, r7
   1bd28:	bd80      	pop	{r7, pc}
   1bd2a:	bf00      	nop
   1bd2c:	10010ed0 	.word	0x10010ed0

0001bd30 <AppScanGetNumResults>:
 *
 *  \return Number of stored scan results.
 */
/*************************************************************************************************/
uint8_t AppScanGetNumResults(void)
{
   1bd30:	b480      	push	{r7}
   1bd32:	af00      	add	r7, sp, #0
  return appMasterCb.numScanResults;
   1bd34:	4b03      	ldr	r3, [pc, #12]	; (1bd44 <AppScanGetNumResults+0x14>)
   1bd36:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
}
   1bd3a:	4618      	mov	r0, r3
   1bd3c:	46bd      	mov	sp, r7
   1bd3e:	f85d 7b04 	ldr.w	r7, [sp], #4
   1bd42:	4770      	bx	lr
   1bd44:	10010f60 	.word	0x10010f60

0001bd48 <appConnOpen>:
 *
 *  \return Connection identifier.
 */
/*************************************************************************************************/
dmConnId_t appConnOpen(uint8_t initPhys, uint8_t addrType, uint8_t *pAddr, appDbHdl_t dbHdl)
{
   1bd48:	b580      	push	{r7, lr}
   1bd4a:	b086      	sub	sp, #24
   1bd4c:	af00      	add	r7, sp, #0
   1bd4e:	60ba      	str	r2, [r7, #8]
   1bd50:	607b      	str	r3, [r7, #4]
   1bd52:	4603      	mov	r3, r0
   1bd54:	73fb      	strb	r3, [r7, #15]
   1bd56:	460b      	mov	r3, r1
   1bd58:	73bb      	strb	r3, [r7, #14]
  dmConnId_t  connId;
  appConnCb_t *pCb;

  /* open connection */
  connId = DmConnOpen(DM_CLIENT_ID_APP, initPhys, addrType, pAddr);
   1bd5a:	7bba      	ldrb	r2, [r7, #14]
   1bd5c:	7bf9      	ldrb	r1, [r7, #15]
   1bd5e:	68bb      	ldr	r3, [r7, #8]
   1bd60:	2003      	movs	r0, #3
   1bd62:	f007 fd02 	bl	2376a <DmConnOpen>
   1bd66:	4603      	mov	r3, r0
   1bd68:	75fb      	strb	r3, [r7, #23]

  if (connId != DM_CONN_ID_NONE)
   1bd6a:	7dfb      	ldrb	r3, [r7, #23]
   1bd6c:	2b00      	cmp	r3, #0
   1bd6e:	d020      	beq.n	1bdb2 <appConnOpen+0x6a>
  {
    /* set up conn. control block */
    pCb = &appConnCb[connId - 1];
   1bd70:	7dfb      	ldrb	r3, [r7, #23]
   1bd72:	1e5a      	subs	r2, r3, #1
   1bd74:	4613      	mov	r3, r2
   1bd76:	005b      	lsls	r3, r3, #1
   1bd78:	4413      	add	r3, r2
   1bd7a:	011b      	lsls	r3, r3, #4
   1bd7c:	4a0f      	ldr	r2, [pc, #60]	; (1bdbc <appConnOpen+0x74>)
   1bd7e:	4413      	add	r3, r2
   1bd80:	613b      	str	r3, [r7, #16]

    pCb->connId = connId;
   1bd82:	693b      	ldr	r3, [r7, #16]
   1bd84:	7dfa      	ldrb	r2, [r7, #23]
   1bd86:	711a      	strb	r2, [r3, #4]

    /* if database record handle is in use */
    if ((dbHdl != APP_DB_HDL_NONE) && AppDbRecordInUse(dbHdl))
   1bd88:	687b      	ldr	r3, [r7, #4]
   1bd8a:	2b00      	cmp	r3, #0
   1bd8c:	d009      	beq.n	1bda2 <appConnOpen+0x5a>
   1bd8e:	6878      	ldr	r0, [r7, #4]
   1bd90:	f7fe fff0 	bl	1ad74 <AppDbRecordInUse>
   1bd94:	4603      	mov	r3, r0
   1bd96:	2b00      	cmp	r3, #0
   1bd98:	d003      	beq.n	1bda2 <appConnOpen+0x5a>
    {
      pCb->dbHdl = dbHdl;
   1bd9a:	693b      	ldr	r3, [r7, #16]
   1bd9c:	687a      	ldr	r2, [r7, #4]
   1bd9e:	601a      	str	r2, [r3, #0]
   1bda0:	e007      	b.n	1bdb2 <appConnOpen+0x6a>
    }
    else
    {
      pCb->dbHdl = AppDbFindByAddr(addrType, pAddr);
   1bda2:	7bbb      	ldrb	r3, [r7, #14]
   1bda4:	68b9      	ldr	r1, [r7, #8]
   1bda6:	4618      	mov	r0, r3
   1bda8:	f7ff f836 	bl	1ae18 <AppDbFindByAddr>
   1bdac:	4602      	mov	r2, r0
   1bdae:	693b      	ldr	r3, [r7, #16]
   1bdb0:	601a      	str	r2, [r3, #0]
    }
  }

  return connId;
   1bdb2:	7dfb      	ldrb	r3, [r7, #23]
}
   1bdb4:	4618      	mov	r0, r3
   1bdb6:	3718      	adds	r7, #24
   1bdb8:	46bd      	mov	sp, r7
   1bdba:	bd80      	pop	{r7, pc}
   1bdbc:	10010ed0 	.word	0x10010ed0

0001bdc0 <appMasterScanMode>:
 *
 *  \return TRUE if legacy scanning mode. FALSE, otherwise.
 */
/*************************************************************************************************/
static bool_t appMasterScanMode(void)
{
   1bdc0:	b580      	push	{r7, lr}
   1bdc2:	af00      	add	r7, sp, #0
  /* legacy master app works with both DM legacy and extended scanning */

  /* if first time since last power-on or reset */
  if (appMasterCb.scanMode == APP_SCAN_MODE_NONE)
   1bdc4:	4b0b      	ldr	r3, [pc, #44]	; (1bdf4 <appMasterScanMode+0x34>)
   1bdc6:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
   1bdca:	2bff      	cmp	r3, #255	; 0xff
   1bdcc:	d105      	bne.n	1bdda <appMasterScanMode+0x1a>
  {
    /* set scanning mode to legacy */
    appMasterCb.scanMode = APP_SCAN_MODE_LEG;
   1bdce:	4b09      	ldr	r3, [pc, #36]	; (1bdf4 <appMasterScanMode+0x34>)
   1bdd0:	2200      	movs	r2, #0
   1bdd2:	f883 209d 	strb.w	r2, [r3, #157]	; 0x9d

    return TRUE;
   1bdd6:	2301      	movs	r3, #1
   1bdd8:	e00a      	b.n	1bdf0 <appMasterScanMode+0x30>
  }

  if (appMasterCb.scanMode == APP_SCAN_MODE_LEG)
   1bdda:	4b06      	ldr	r3, [pc, #24]	; (1bdf4 <appMasterScanMode+0x34>)
   1bddc:	f893 309d 	ldrb.w	r3, [r3, #157]	; 0x9d
   1bde0:	2b00      	cmp	r3, #0
   1bde2:	d101      	bne.n	1bde8 <appMasterScanMode+0x28>
  {
    return TRUE;
   1bde4:	2301      	movs	r3, #1
   1bde6:	e003      	b.n	1bdf0 <appMasterScanMode+0x30>
  }

  APP_TRACE_WARN0("Invalid DM scanning mode; mode configured as extended");
   1bde8:	4803      	ldr	r0, [pc, #12]	; (1bdf8 <appMasterScanMode+0x38>)
   1bdea:	f011 fdd1 	bl	2d990 <WsfTrace>

  return FALSE;
   1bdee:	2300      	movs	r3, #0
}
   1bdf0:	4618      	mov	r0, r3
   1bdf2:	bd80      	pop	{r7, pc}
   1bdf4:	10010f60 	.word	0x10010f60
   1bdf8:	000446ec 	.word	0x000446ec

0001bdfc <AppScanStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppScanStart(uint8_t mode, uint8_t scanType, uint16_t duration)
{
   1bdfc:	b580      	push	{r7, lr}
   1bdfe:	b084      	sub	sp, #16
   1be00:	af02      	add	r7, sp, #8
   1be02:	4603      	mov	r3, r0
   1be04:	71fb      	strb	r3, [r7, #7]
   1be06:	460b      	mov	r3, r1
   1be08:	71bb      	strb	r3, [r7, #6]
   1be0a:	4613      	mov	r3, r2
   1be0c:	80bb      	strh	r3, [r7, #4]
  if (appMasterScanMode())
   1be0e:	f7ff ffd7 	bl	1bdc0 <appMasterScanMode>
   1be12:	4603      	mov	r3, r0
   1be14:	2b00      	cmp	r3, #0
   1be16:	d013      	beq.n	1be40 <AppScanStart+0x44>
  {
    DmScanSetInterval(HCI_SCAN_PHY_LE_1M_BIT, &pAppMasterCfg->scanInterval, &pAppMasterCfg->scanWindow);
   1be18:	4b0b      	ldr	r3, [pc, #44]	; (1be48 <AppScanStart+0x4c>)
   1be1a:	681b      	ldr	r3, [r3, #0]
   1be1c:	4619      	mov	r1, r3
   1be1e:	4b0a      	ldr	r3, [pc, #40]	; (1be48 <AppScanStart+0x4c>)
   1be20:	681b      	ldr	r3, [r3, #0]
   1be22:	3302      	adds	r3, #2
   1be24:	461a      	mov	r2, r3
   1be26:	2001      	movs	r0, #1
   1be28:	f008 fac6 	bl	243b8 <DmScanSetInterval>

    DmScanStart(HCI_SCAN_PHY_LE_1M_BIT, mode, &scanType, TRUE, duration, 0);
   1be2c:	1dba      	adds	r2, r7, #6
   1be2e:	79f9      	ldrb	r1, [r7, #7]
   1be30:	2300      	movs	r3, #0
   1be32:	9301      	str	r3, [sp, #4]
   1be34:	88bb      	ldrh	r3, [r7, #4]
   1be36:	9300      	str	r3, [sp, #0]
   1be38:	2301      	movs	r3, #1
   1be3a:	2001      	movs	r0, #1
   1be3c:	f008 fa2a 	bl	24294 <DmScanStart>
  }
}
   1be40:	bf00      	nop
   1be42:	3708      	adds	r7, #8
   1be44:	46bd      	mov	sp, r7
   1be46:	bd80      	pop	{r7, pc}
   1be48:	10010e94 	.word	0x10010e94

0001be4c <AppScanStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppScanStop(void)
{
   1be4c:	b580      	push	{r7, lr}
   1be4e:	af00      	add	r7, sp, #0
  if (appMasterScanMode())
   1be50:	f7ff ffb6 	bl	1bdc0 <appMasterScanMode>
   1be54:	4603      	mov	r3, r0
   1be56:	2b00      	cmp	r3, #0
   1be58:	d005      	beq.n	1be66 <AppScanStop+0x1a>
  {
    /* stop address resolution */
    appMasterCb.inProgress = FALSE;
   1be5a:	4b04      	ldr	r3, [pc, #16]	; (1be6c <AppScanStop+0x20>)
   1be5c:	2200      	movs	r2, #0
   1be5e:	f883 209c 	strb.w	r2, [r3, #156]	; 0x9c

    DmScanStop();
   1be62:	f008 fa69 	bl	24338 <DmScanStop>
  }
}
   1be66:	bf00      	nop
   1be68:	bd80      	pop	{r7, pc}
   1be6a:	bf00      	nop
   1be6c:	10010f60 	.word	0x10010f60

0001be70 <AppConnOpen>:
 *
 *  \return Connection identifier.
 */
/*************************************************************************************************/
dmConnId_t AppConnOpen(uint8_t addrType, uint8_t *pAddr, appDbHdl_t dbHdl)
{
   1be70:	b580      	push	{r7, lr}
   1be72:	b084      	sub	sp, #16
   1be74:	af00      	add	r7, sp, #0
   1be76:	4603      	mov	r3, r0
   1be78:	60b9      	str	r1, [r7, #8]
   1be7a:	607a      	str	r2, [r7, #4]
   1be7c:	73fb      	strb	r3, [r7, #15]
  if (appMasterScanMode())
   1be7e:	f7ff ff9f 	bl	1bdc0 <appMasterScanMode>
   1be82:	4603      	mov	r3, r0
   1be84:	2b00      	cmp	r3, #0
   1be86:	d007      	beq.n	1be98 <AppConnOpen+0x28>
  {
    return appConnOpen(HCI_INIT_PHY_LE_1M_BIT, addrType, pAddr, dbHdl);
   1be88:	7bf9      	ldrb	r1, [r7, #15]
   1be8a:	687b      	ldr	r3, [r7, #4]
   1be8c:	68ba      	ldr	r2, [r7, #8]
   1be8e:	2001      	movs	r0, #1
   1be90:	f7ff ff5a 	bl	1bd48 <appConnOpen>
   1be94:	4603      	mov	r3, r0
   1be96:	e000      	b.n	1be9a <AppConnOpen+0x2a>
  }

  /* wrong connect mode */
  return DM_CONN_ID_NONE;
   1be98:	2300      	movs	r3, #0
}
   1be9a:	4618      	mov	r0, r3
   1be9c:	3710      	adds	r7, #16
   1be9e:	46bd      	mov	sp, r7
   1bea0:	bd80      	pop	{r7, pc}
	...

0001bea4 <appSlaveAdvModeInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveAdvModeInit(void)
{
   1bea4:	b480      	push	{r7}
   1bea6:	af00      	add	r7, sp, #0
  /* initialize advertising callbacks */
  appSlaveCb.advStopCback = NULL;
   1bea8:	4b05      	ldr	r3, [pc, #20]	; (1bec0 <appSlaveAdvModeInit+0x1c>)
   1beaa:	2200      	movs	r2, #0
   1beac:	641a      	str	r2, [r3, #64]	; 0x40
  appSlaveCb.advRestartCback = NULL;
   1beae:	4b04      	ldr	r3, [pc, #16]	; (1bec0 <appSlaveAdvModeInit+0x1c>)
   1beb0:	2200      	movs	r2, #0
   1beb2:	645a      	str	r2, [r3, #68]	; 0x44
}
   1beb4:	bf00      	nop
   1beb6:	46bd      	mov	sp, r7
   1beb8:	f85d 7b04 	ldr.w	r7, [sp], #4
   1bebc:	4770      	bx	lr
   1bebe:	bf00      	nop
   1bec0:	10011000 	.word	0x10011000

0001bec4 <appSlaveConnectableAdv>:
 *
 *  \return TRUE if connectable advertising enabled. FALSE, otherwise.
 */
/*************************************************************************************************/
static bool_t appSlaveConnectableAdv(uint8_t numSets, uint8_t *pAdvHandles)
{
   1bec4:	b480      	push	{r7}
   1bec6:	b085      	sub	sp, #20
   1bec8:	af00      	add	r7, sp, #0
   1beca:	4603      	mov	r3, r0
   1becc:	6039      	str	r1, [r7, #0]
   1bece:	71fb      	strb	r3, [r7, #7]
  uint8_t i, j;

  /* for each advertising set in advHandle */
  for (i = 0; i < numSets; i++)
   1bed0:	2300      	movs	r3, #0
   1bed2:	73fb      	strb	r3, [r7, #15]
   1bed4:	e029      	b.n	1bf2a <appSlaveConnectableAdv+0x66>
  {
    /* for each advertising set */
    for (j = 0; j < DM_NUM_ADV_SETS; j++)
   1bed6:	2300      	movs	r3, #0
   1bed8:	73bb      	strb	r3, [r7, #14]
   1beda:	e020      	b.n	1bf1e <appSlaveConnectableAdv+0x5a>
    {
      /* if connectable advertising */
      if ((pAdvHandles[i] == j)                                  &&
   1bedc:	7bfb      	ldrb	r3, [r7, #15]
   1bede:	683a      	ldr	r2, [r7, #0]
   1bee0:	4413      	add	r3, r2
   1bee2:	781b      	ldrb	r3, [r3, #0]
   1bee4:	7bba      	ldrb	r2, [r7, #14]
   1bee6:	429a      	cmp	r2, r3
   1bee8:	d116      	bne.n	1bf18 <appSlaveConnectableAdv+0x54>
          ((appSlaveCb.advType[j] == DM_ADV_CONN_UNDIRECT)       ||
   1beea:	7bbb      	ldrb	r3, [r7, #14]
   1beec:	4a14      	ldr	r2, [pc, #80]	; (1bf40 <appSlaveConnectableAdv+0x7c>)
   1beee:	4413      	add	r3, r2
   1bef0:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
      if ((pAdvHandles[i] == j)                                  &&
   1bef4:	2b00      	cmp	r3, #0
   1bef6:	d00d      	beq.n	1bf14 <appSlaveConnectableAdv+0x50>
           (appSlaveCb.advType[j] == DM_ADV_CONN_DIRECT_LO_DUTY) ||
   1bef8:	7bbb      	ldrb	r3, [r7, #14]
   1befa:	4a11      	ldr	r2, [pc, #68]	; (1bf40 <appSlaveConnectableAdv+0x7c>)
   1befc:	4413      	add	r3, r2
   1befe:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
          ((appSlaveCb.advType[j] == DM_ADV_CONN_UNDIRECT)       ||
   1bf02:	2b04      	cmp	r3, #4
   1bf04:	d006      	beq.n	1bf14 <appSlaveConnectableAdv+0x50>
           (appSlaveCb.advType[j] == DM_EXT_ADV_CONN_UNDIRECT)))
   1bf06:	7bbb      	ldrb	r3, [r7, #14]
   1bf08:	4a0d      	ldr	r2, [pc, #52]	; (1bf40 <appSlaveConnectableAdv+0x7c>)
   1bf0a:	4413      	add	r3, r2
   1bf0c:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
           (appSlaveCb.advType[j] == DM_ADV_CONN_DIRECT_LO_DUTY) ||
   1bf10:	2b05      	cmp	r3, #5
   1bf12:	d101      	bne.n	1bf18 <appSlaveConnectableAdv+0x54>
      {
        return TRUE;
   1bf14:	2301      	movs	r3, #1
   1bf16:	e00d      	b.n	1bf34 <appSlaveConnectableAdv+0x70>
    for (j = 0; j < DM_NUM_ADV_SETS; j++)
   1bf18:	7bbb      	ldrb	r3, [r7, #14]
   1bf1a:	3301      	adds	r3, #1
   1bf1c:	73bb      	strb	r3, [r7, #14]
   1bf1e:	7bbb      	ldrb	r3, [r7, #14]
   1bf20:	2b00      	cmp	r3, #0
   1bf22:	d0db      	beq.n	1bedc <appSlaveConnectableAdv+0x18>
  for (i = 0; i < numSets; i++)
   1bf24:	7bfb      	ldrb	r3, [r7, #15]
   1bf26:	3301      	adds	r3, #1
   1bf28:	73fb      	strb	r3, [r7, #15]
   1bf2a:	7bfa      	ldrb	r2, [r7, #15]
   1bf2c:	79fb      	ldrb	r3, [r7, #7]
   1bf2e:	429a      	cmp	r2, r3
   1bf30:	d3d1      	bcc.n	1bed6 <appSlaveConnectableAdv+0x12>
      }
    }
  }

  return FALSE;
   1bf32:	2300      	movs	r3, #0
}
   1bf34:	4618      	mov	r0, r3
   1bf36:	3714      	adds	r7, #20
   1bf38:	46bd      	mov	sp, r7
   1bf3a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1bf3e:	4770      	bx	lr
   1bf40:	10011000 	.word	0x10011000

0001bf44 <appSlaveResetAdvDataOffset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appSlaveResetAdvDataOffset(uint8_t advHandle)
{
   1bf44:	b480      	push	{r7}
   1bf46:	b085      	sub	sp, #20
   1bf48:	af00      	add	r7, sp, #0
   1bf4a:	4603      	mov	r3, r0
   1bf4c:	71fb      	strb	r3, [r7, #7]
  uint8_t advLoc;
  uint8_t scanLoc;
  bool_t syncData = FALSE;
   1bf4e:	2300      	movs	r3, #0
   1bf50:	73fb      	strb	r3, [r7, #15]

  /* get advertising/scan data location based on mode */
  advLoc = APP_MODE_2_ADV_LOC(appSlaveCb.discMode);
   1bf52:	4b22      	ldr	r3, [pc, #136]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bf54:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1bf58:	005b      	lsls	r3, r3, #1
   1bf5a:	73bb      	strb	r3, [r7, #14]
  scanLoc = APP_MODE_2_SCAN_LOC(appSlaveCb.discMode);
   1bf5c:	4b1f      	ldr	r3, [pc, #124]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bf5e:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1bf62:	005b      	lsls	r3, r3, #1
   1bf64:	b2db      	uxtb	r3, r3
   1bf66:	3301      	adds	r3, #1
   1bf68:	737b      	strb	r3, [r7, #13]

  /* if adv data was fragmented when being sent to LL */
  if (appSlaveCb.advDataOffset[advHandle][advLoc] > 0)
   1bf6a:	79fa      	ldrb	r2, [r7, #7]
   1bf6c:	7bbb      	ldrb	r3, [r7, #14]
   1bf6e:	491b      	ldr	r1, [pc, #108]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bf70:	0092      	lsls	r2, r2, #2
   1bf72:	4413      	add	r3, r2
   1bf74:	3310      	adds	r3, #16
   1bf76:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1bf7a:	2b00      	cmp	r3, #0
   1bf7c:	d00a      	beq.n	1bf94 <appSlaveResetAdvDataOffset+0x50>
  {
    appSlaveCb.advDataOffset[advHandle][advLoc] = 0;
   1bf7e:	79fa      	ldrb	r2, [r7, #7]
   1bf80:	7bbb      	ldrb	r3, [r7, #14]
   1bf82:	4916      	ldr	r1, [pc, #88]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bf84:	0092      	lsls	r2, r2, #2
   1bf86:	4413      	add	r3, r2
   1bf88:	3310      	adds	r3, #16
   1bf8a:	2200      	movs	r2, #0
   1bf8c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    syncData = TRUE;
   1bf90:	2301      	movs	r3, #1
   1bf92:	73fb      	strb	r3, [r7, #15]
  }

  /* if scan data was fragmented when being sent to LL */
  if (appSlaveCb.advDataOffset[advHandle][scanLoc] > 0)
   1bf94:	79fa      	ldrb	r2, [r7, #7]
   1bf96:	7b7b      	ldrb	r3, [r7, #13]
   1bf98:	4910      	ldr	r1, [pc, #64]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bf9a:	0092      	lsls	r2, r2, #2
   1bf9c:	4413      	add	r3, r2
   1bf9e:	3310      	adds	r3, #16
   1bfa0:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1bfa4:	2b00      	cmp	r3, #0
   1bfa6:	d00a      	beq.n	1bfbe <appSlaveResetAdvDataOffset+0x7a>
  {
    appSlaveCb.advDataOffset[advHandle][scanLoc] = 0;
   1bfa8:	79fa      	ldrb	r2, [r7, #7]
   1bfaa:	7b7b      	ldrb	r3, [r7, #13]
   1bfac:	490b      	ldr	r1, [pc, #44]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bfae:	0092      	lsls	r2, r2, #2
   1bfb0:	4413      	add	r3, r2
   1bfb2:	3310      	adds	r3, #16
   1bfb4:	2200      	movs	r2, #0
   1bfb6:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    syncData = TRUE;
   1bfba:	2301      	movs	r3, #1
   1bfbc:	73fb      	strb	r3, [r7, #15]
  }

  if (syncData)
   1bfbe:	7bfb      	ldrb	r3, [r7, #15]
   1bfc0:	2b00      	cmp	r3, #0
   1bfc2:	d005      	beq.n	1bfd0 <appSlaveResetAdvDataOffset+0x8c>
  {
    /* force update of advertising data */
    appSlaveCb.advDataSynced[advHandle] = FALSE;
   1bfc4:	79fb      	ldrb	r3, [r7, #7]
   1bfc6:	4a05      	ldr	r2, [pc, #20]	; (1bfdc <appSlaveResetAdvDataOffset+0x98>)
   1bfc8:	4413      	add	r3, r2
   1bfca:	2200      	movs	r2, #0
   1bfcc:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  }
}
   1bfd0:	bf00      	nop
   1bfd2:	3714      	adds	r7, #20
   1bfd4:	46bd      	mov	sp, r7
   1bfd6:	f85d 7b04 	ldr.w	r7, [sp], #4
   1bfda:	4770      	bx	lr
   1bfdc:	10011000 	.word	0x10011000

0001bfe0 <appSlaveForceAdvDataSync>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveForceAdvDataSync(uint8_t advHandle, uint8_t mode)
{
   1bfe0:	b480      	push	{r7}
   1bfe2:	b085      	sub	sp, #20
   1bfe4:	af00      	add	r7, sp, #0
   1bfe6:	4603      	mov	r3, r0
   1bfe8:	460a      	mov	r2, r1
   1bfea:	71fb      	strb	r3, [r7, #7]
   1bfec:	4613      	mov	r3, r2
   1bfee:	71bb      	strb	r3, [r7, #6]
  uint8_t advLoc;
  uint8_t scanLoc;

  /* get advertising/scan data location based on mode */
  advLoc = APP_MODE_2_ADV_LOC(mode);
   1bff0:	79bb      	ldrb	r3, [r7, #6]
   1bff2:	005b      	lsls	r3, r3, #1
   1bff4:	73fb      	strb	r3, [r7, #15]
  scanLoc = APP_MODE_2_SCAN_LOC(mode);
   1bff6:	79bb      	ldrb	r3, [r7, #6]
   1bff8:	005b      	lsls	r3, r3, #1
   1bffa:	b2db      	uxtb	r3, r3
   1bffc:	3301      	adds	r3, #1
   1bffe:	73bb      	strb	r3, [r7, #14]

  /* force update of advertising data */
  appSlaveCb.advDataOffset[advHandle][advLoc] = 0;
   1c000:	79fa      	ldrb	r2, [r7, #7]
   1c002:	7bfb      	ldrb	r3, [r7, #15]
   1c004:	490d      	ldr	r1, [pc, #52]	; (1c03c <appSlaveForceAdvDataSync+0x5c>)
   1c006:	0092      	lsls	r2, r2, #2
   1c008:	4413      	add	r3, r2
   1c00a:	3310      	adds	r3, #16
   1c00c:	2200      	movs	r2, #0
   1c00e:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
  appSlaveCb.advDataOffset[advHandle][scanLoc] = 0;
   1c012:	79fa      	ldrb	r2, [r7, #7]
   1c014:	7bbb      	ldrb	r3, [r7, #14]
   1c016:	4909      	ldr	r1, [pc, #36]	; (1c03c <appSlaveForceAdvDataSync+0x5c>)
   1c018:	0092      	lsls	r2, r2, #2
   1c01a:	4413      	add	r3, r2
   1c01c:	3310      	adds	r3, #16
   1c01e:	2200      	movs	r2, #0
   1c020:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
  appSlaveCb.advDataSynced[advHandle] = FALSE;
   1c024:	79fb      	ldrb	r3, [r7, #7]
   1c026:	4a05      	ldr	r2, [pc, #20]	; (1c03c <appSlaveForceAdvDataSync+0x5c>)
   1c028:	4413      	add	r3, r2
   1c02a:	2200      	movs	r2, #0
   1c02c:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
}
   1c030:	bf00      	nop
   1c032:	3714      	adds	r7, #20
   1c034:	46bd      	mov	sp, r7
   1c036:	f85d 7b04 	ldr.w	r7, [sp], #4
   1c03a:	4770      	bx	lr
   1c03c:	10011000 	.word	0x10011000

0001c040 <appSetAdvScanDataFrag>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSetAdvScanDataFrag(uint8_t advHandle, uint8_t location)
{
   1c040:	b5b0      	push	{r4, r5, r7, lr}
   1c042:	b088      	sub	sp, #32
   1c044:	af02      	add	r7, sp, #8
   1c046:	4603      	mov	r3, r0
   1c048:	460a      	mov	r2, r1
   1c04a:	71fb      	strb	r3, [r7, #7]
   1c04c:	4613      	mov	r3, r2
   1c04e:	71bb      	strb	r3, [r7, #6]
  uint8_t  op;
  uint16_t fragLen;
  uint16_t remainLen;
  uint8_t  *pAdvData;
  bool_t   firstFrag = TRUE;
   1c050:	2301      	movs	r3, #1
   1c052:	747b      	strb	r3, [r7, #17]

  /* get data pointer and remaining data length */
  pAdvData = appSlaveCb.pAdvData[advHandle][location];
   1c054:	79fa      	ldrb	r2, [r7, #7]
   1c056:	79bb      	ldrb	r3, [r7, #6]
   1c058:	493b      	ldr	r1, [pc, #236]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c05a:	0092      	lsls	r2, r2, #2
   1c05c:	4413      	add	r3, r2
   1c05e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1c062:	60fb      	str	r3, [r7, #12]
  remainLen = appSlaveCb.advDataLen[advHandle][location] - appSlaveCb.advDataOffset[advHandle][location];
   1c064:	79fa      	ldrb	r2, [r7, #7]
   1c066:	79bb      	ldrb	r3, [r7, #6]
   1c068:	4937      	ldr	r1, [pc, #220]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c06a:	0092      	lsls	r2, r2, #2
   1c06c:	4413      	add	r3, r2
   1c06e:	3308      	adds	r3, #8
   1c070:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1c074:	79f9      	ldrb	r1, [r7, #7]
   1c076:	79bb      	ldrb	r3, [r7, #6]
   1c078:	4833      	ldr	r0, [pc, #204]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c07a:	0089      	lsls	r1, r1, #2
   1c07c:	440b      	add	r3, r1
   1c07e:	3310      	adds	r3, #16
   1c080:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
   1c084:	1ad3      	subs	r3, r2, r3
   1c086:	827b      	strh	r3, [r7, #18]

  /* if remaing data length > max adv data length supported by Controller */
  if (remainLen > appSlaveCb.maxAdvDataLen[advHandle])
   1c088:	79fb      	ldrb	r3, [r7, #7]
   1c08a:	4a2f      	ldr	r2, [pc, #188]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c08c:	3314      	adds	r3, #20
   1c08e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   1c092:	8a7a      	ldrh	r2, [r7, #18]
   1c094:	429a      	cmp	r2, r3
   1c096:	d94e      	bls.n	1c136 <appSetAdvScanDataFrag+0xf6>
  {
    remainLen = appSlaveCb.maxAdvDataLen[advHandle];
   1c098:	79fb      	ldrb	r3, [r7, #7]
   1c09a:	4a2b      	ldr	r2, [pc, #172]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c09c:	3314      	adds	r3, #20
   1c09e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
   1c0a2:	827b      	strh	r3, [r7, #18]
  }

  /* while there remains data to be sent */
  while (remainLen > 0)
   1c0a4:	e047      	b.n	1c136 <appSetAdvScanDataFrag+0xf6>
  {
    /* if remaing data length > max length of extended advertising data (per set adv data command) */
    if (remainLen > HCI_EXT_ADV_DATA_LEN)
   1c0a6:	8a7b      	ldrh	r3, [r7, #18]
   1c0a8:	2bfb      	cmp	r3, #251	; 0xfb
   1c0aa:	d909      	bls.n	1c0c0 <appSetAdvScanDataFrag+0x80>
    {
      /* data needs to be fragmented */
      fragLen = HCI_EXT_ADV_DATA_LEN;
   1c0ac:	23fb      	movs	r3, #251	; 0xfb
   1c0ae:	82bb      	strh	r3, [r7, #20]
      op = firstFrag ? HCI_ADV_DATA_OP_FRAG_FIRST : HCI_ADV_DATA_OP_FRAG_INTER;
   1c0b0:	7c7b      	ldrb	r3, [r7, #17]
   1c0b2:	2b00      	cmp	r3, #0
   1c0b4:	bf14      	ite	ne
   1c0b6:	2301      	movne	r3, #1
   1c0b8:	2300      	moveq	r3, #0
   1c0ba:	b2db      	uxtb	r3, r3
   1c0bc:	75fb      	strb	r3, [r7, #23]
   1c0be:	e008      	b.n	1c0d2 <appSetAdvScanDataFrag+0x92>

    }
    else
    {
      /* no fragmentation needed */
      fragLen = remainLen;
   1c0c0:	8a7b      	ldrh	r3, [r7, #18]
   1c0c2:	82bb      	strh	r3, [r7, #20]
      op = firstFrag ? HCI_ADV_DATA_OP_COMP_FRAG : HCI_ADV_DATA_OP_FRAG_LAST;
   1c0c4:	7c7b      	ldrb	r3, [r7, #17]
   1c0c6:	2b00      	cmp	r3, #0
   1c0c8:	d001      	beq.n	1c0ce <appSetAdvScanDataFrag+0x8e>
   1c0ca:	2303      	movs	r3, #3
   1c0cc:	e000      	b.n	1c0d0 <appSetAdvScanDataFrag+0x90>
   1c0ce:	2302      	movs	r3, #2
   1c0d0:	75fb      	strb	r3, [r7, #23]
    }

    /* send adv data */
    DmAdvSetData(advHandle, op, APP_LOC_2_DM_LOC(location), (uint8_t)fragLen,
   1c0d2:	79bb      	ldrb	r3, [r7, #6]
   1c0d4:	f003 0301 	and.w	r3, r3, #1
   1c0d8:	b2dc      	uxtb	r4, r3
   1c0da:	8abb      	ldrh	r3, [r7, #20]
   1c0dc:	b2dd      	uxtb	r5, r3
                 &(pAdvData[appSlaveCb.advDataOffset[advHandle][location]]));
   1c0de:	79fa      	ldrb	r2, [r7, #7]
   1c0e0:	79bb      	ldrb	r3, [r7, #6]
   1c0e2:	4919      	ldr	r1, [pc, #100]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c0e4:	0092      	lsls	r2, r2, #2
   1c0e6:	4413      	add	r3, r2
   1c0e8:	3310      	adds	r3, #16
   1c0ea:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1c0ee:	461a      	mov	r2, r3
    DmAdvSetData(advHandle, op, APP_LOC_2_DM_LOC(location), (uint8_t)fragLen,
   1c0f0:	68fb      	ldr	r3, [r7, #12]
   1c0f2:	4413      	add	r3, r2
   1c0f4:	7df9      	ldrb	r1, [r7, #23]
   1c0f6:	79f8      	ldrb	r0, [r7, #7]
   1c0f8:	9300      	str	r3, [sp, #0]
   1c0fa:	462b      	mov	r3, r5
   1c0fc:	4622      	mov	r2, r4
   1c0fe:	f005 fe5b 	bl	21db8 <DmAdvSetData>

    /* store adv data offset */
    appSlaveCb.advDataOffset[advHandle][location] += fragLen;
   1c102:	79fa      	ldrb	r2, [r7, #7]
   1c104:	79bb      	ldrb	r3, [r7, #6]
   1c106:	4910      	ldr	r1, [pc, #64]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c108:	0092      	lsls	r2, r2, #2
   1c10a:	4413      	add	r3, r2
   1c10c:	3310      	adds	r3, #16
   1c10e:	f831 0013 	ldrh.w	r0, [r1, r3, lsl #1]
   1c112:	79fa      	ldrb	r2, [r7, #7]
   1c114:	79bb      	ldrb	r3, [r7, #6]
   1c116:	8ab9      	ldrh	r1, [r7, #20]
   1c118:	4401      	add	r1, r0
   1c11a:	b288      	uxth	r0, r1
   1c11c:	490a      	ldr	r1, [pc, #40]	; (1c148 <appSetAdvScanDataFrag+0x108>)
   1c11e:	0092      	lsls	r2, r2, #2
   1c120:	4413      	add	r3, r2
   1c122:	3310      	adds	r3, #16
   1c124:	4602      	mov	r2, r0
   1c126:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]

    /* update remaining data length */
    remainLen -= fragLen;
   1c12a:	8a7a      	ldrh	r2, [r7, #18]
   1c12c:	8abb      	ldrh	r3, [r7, #20]
   1c12e:	1ad3      	subs	r3, r2, r3
   1c130:	827b      	strh	r3, [r7, #18]
    firstFrag = FALSE;
   1c132:	2300      	movs	r3, #0
   1c134:	747b      	strb	r3, [r7, #17]
  while (remainLen > 0)
   1c136:	8a7b      	ldrh	r3, [r7, #18]
   1c138:	2b00      	cmp	r3, #0
   1c13a:	d1b4      	bne.n	1c0a6 <appSetAdvScanDataFrag+0x66>
  }
}
   1c13c:	bf00      	nop
   1c13e:	bf00      	nop
   1c140:	3718      	adds	r7, #24
   1c142:	46bd      	mov	sp, r7
   1c144:	bdb0      	pop	{r4, r5, r7, pc}
   1c146:	bf00      	nop
   1c148:	10011000 	.word	0x10011000

0001c14c <appSetAdvScanData>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSetAdvScanData(uint8_t advHandle, uint8_t mode)
{
   1c14c:	b580      	push	{r7, lr}
   1c14e:	b084      	sub	sp, #16
   1c150:	af00      	add	r7, sp, #0
   1c152:	4603      	mov	r3, r0
   1c154:	460a      	mov	r2, r1
   1c156:	71fb      	strb	r3, [r7, #7]
   1c158:	4613      	mov	r3, r2
   1c15a:	71bb      	strb	r3, [r7, #6]
  uint8_t advLoc;
  uint8_t scanLoc;

  /* get advertising/scan data location based on mode */
  advLoc = APP_MODE_2_ADV_LOC(mode);
   1c15c:	79bb      	ldrb	r3, [r7, #6]
   1c15e:	005b      	lsls	r3, r3, #1
   1c160:	73fb      	strb	r3, [r7, #15]
  scanLoc = APP_MODE_2_SCAN_LOC(mode);
   1c162:	79bb      	ldrb	r3, [r7, #6]
   1c164:	005b      	lsls	r3, r3, #1
   1c166:	b2db      	uxtb	r3, r3
   1c168:	3301      	adds	r3, #1
   1c16a:	73bb      	strb	r3, [r7, #14]

  /* set advertising data */
  if (appSlaveCb.advDataOffset[advHandle][advLoc] < appSlaveCb.advDataLen[advHandle][advLoc])
   1c16c:	79fa      	ldrb	r2, [r7, #7]
   1c16e:	7bfb      	ldrb	r3, [r7, #15]
   1c170:	492d      	ldr	r1, [pc, #180]	; (1c228 <appSetAdvScanData+0xdc>)
   1c172:	0092      	lsls	r2, r2, #2
   1c174:	4413      	add	r3, r2
   1c176:	3310      	adds	r3, #16
   1c178:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1c17c:	79f9      	ldrb	r1, [r7, #7]
   1c17e:	7bfb      	ldrb	r3, [r7, #15]
   1c180:	4829      	ldr	r0, [pc, #164]	; (1c228 <appSetAdvScanData+0xdc>)
   1c182:	0089      	lsls	r1, r1, #2
   1c184:	440b      	add	r3, r1
   1c186:	3308      	adds	r3, #8
   1c188:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
   1c18c:	429a      	cmp	r2, r3
   1c18e:	d205      	bcs.n	1c19c <appSetAdvScanData+0x50>
  {
    appSetAdvScanDataFrag(advHandle, advLoc);
   1c190:	7bfa      	ldrb	r2, [r7, #15]
   1c192:	79fb      	ldrb	r3, [r7, #7]
   1c194:	4611      	mov	r1, r2
   1c196:	4618      	mov	r0, r3
   1c198:	f7ff ff52 	bl	1c040 <appSetAdvScanDataFrag>
  }

  /* set scan data */
  if (appSlaveCb.advDataOffset[advHandle][scanLoc] < appSlaveCb.advDataLen[advHandle][scanLoc])
   1c19c:	79fa      	ldrb	r2, [r7, #7]
   1c19e:	7bbb      	ldrb	r3, [r7, #14]
   1c1a0:	4921      	ldr	r1, [pc, #132]	; (1c228 <appSetAdvScanData+0xdc>)
   1c1a2:	0092      	lsls	r2, r2, #2
   1c1a4:	4413      	add	r3, r2
   1c1a6:	3310      	adds	r3, #16
   1c1a8:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1c1ac:	79f9      	ldrb	r1, [r7, #7]
   1c1ae:	7bbb      	ldrb	r3, [r7, #14]
   1c1b0:	481d      	ldr	r0, [pc, #116]	; (1c228 <appSetAdvScanData+0xdc>)
   1c1b2:	0089      	lsls	r1, r1, #2
   1c1b4:	440b      	add	r3, r1
   1c1b6:	3308      	adds	r3, #8
   1c1b8:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
   1c1bc:	429a      	cmp	r2, r3
   1c1be:	d205      	bcs.n	1c1cc <appSetAdvScanData+0x80>
  {
    appSetAdvScanDataFrag(advHandle, scanLoc);
   1c1c0:	7bba      	ldrb	r2, [r7, #14]
   1c1c2:	79fb      	ldrb	r3, [r7, #7]
   1c1c4:	4611      	mov	r1, r2
   1c1c6:	4618      	mov	r0, r3
   1c1c8:	f7ff ff3a 	bl	1c040 <appSetAdvScanDataFrag>
  }

  /* if all advertising/scan data have been sent */
  if ((appSlaveCb.advDataOffset[advHandle][advLoc] >= appSlaveCb.advDataLen[advHandle][advLoc]) &&
   1c1cc:	79fa      	ldrb	r2, [r7, #7]
   1c1ce:	7bfb      	ldrb	r3, [r7, #15]
   1c1d0:	4915      	ldr	r1, [pc, #84]	; (1c228 <appSetAdvScanData+0xdc>)
   1c1d2:	0092      	lsls	r2, r2, #2
   1c1d4:	4413      	add	r3, r2
   1c1d6:	3310      	adds	r3, #16
   1c1d8:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1c1dc:	79f9      	ldrb	r1, [r7, #7]
   1c1de:	7bfb      	ldrb	r3, [r7, #15]
   1c1e0:	4811      	ldr	r0, [pc, #68]	; (1c228 <appSetAdvScanData+0xdc>)
   1c1e2:	0089      	lsls	r1, r1, #2
   1c1e4:	440b      	add	r3, r1
   1c1e6:	3308      	adds	r3, #8
   1c1e8:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
   1c1ec:	429a      	cmp	r2, r3
   1c1ee:	d317      	bcc.n	1c220 <appSetAdvScanData+0xd4>
      (appSlaveCb.advDataOffset[advHandle][scanLoc] >= appSlaveCb.advDataLen[advHandle][scanLoc]))
   1c1f0:	79fa      	ldrb	r2, [r7, #7]
   1c1f2:	7bbb      	ldrb	r3, [r7, #14]
   1c1f4:	490c      	ldr	r1, [pc, #48]	; (1c228 <appSetAdvScanData+0xdc>)
   1c1f6:	0092      	lsls	r2, r2, #2
   1c1f8:	4413      	add	r3, r2
   1c1fa:	3310      	adds	r3, #16
   1c1fc:	f831 2013 	ldrh.w	r2, [r1, r3, lsl #1]
   1c200:	79f9      	ldrb	r1, [r7, #7]
   1c202:	7bbb      	ldrb	r3, [r7, #14]
   1c204:	4808      	ldr	r0, [pc, #32]	; (1c228 <appSetAdvScanData+0xdc>)
   1c206:	0089      	lsls	r1, r1, #2
   1c208:	440b      	add	r3, r1
   1c20a:	3308      	adds	r3, #8
   1c20c:	f830 3013 	ldrh.w	r3, [r0, r3, lsl #1]
  if ((appSlaveCb.advDataOffset[advHandle][advLoc] >= appSlaveCb.advDataLen[advHandle][advLoc]) &&
   1c210:	429a      	cmp	r2, r3
   1c212:	d305      	bcc.n	1c220 <appSetAdvScanData+0xd4>
  {
    appSlaveCb.advDataSynced[advHandle] = TRUE;
   1c214:	79fb      	ldrb	r3, [r7, #7]
   1c216:	4a04      	ldr	r2, [pc, #16]	; (1c228 <appSetAdvScanData+0xdc>)
   1c218:	4413      	add	r3, r2
   1c21a:	2201      	movs	r2, #1
   1c21c:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  }
}
   1c220:	bf00      	nop
   1c222:	3710      	adds	r7, #16
   1c224:	46bd      	mov	sp, r7
   1c226:	bd80      	pop	{r7, pc}
   1c228:	10011000 	.word	0x10011000

0001c22c <appConnUpdateTimerStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appConnUpdateTimerStart(dmConnId_t connId)
{
   1c22c:	b580      	push	{r7, lr}
   1c22e:	b084      	sub	sp, #16
   1c230:	af00      	add	r7, sp, #0
   1c232:	4603      	mov	r3, r0
   1c234:	71fb      	strb	r3, [r7, #7]
  /* look up app connection control block from DM connection ID */
  appConnCb_t *pCb = &appConnCb[connId - 1];
   1c236:	79fb      	ldrb	r3, [r7, #7]
   1c238:	1e5a      	subs	r2, r3, #1
   1c23a:	4613      	mov	r3, r2
   1c23c:	005b      	lsls	r3, r3, #1
   1c23e:	4413      	add	r3, r2
   1c240:	011b      	lsls	r3, r3, #4
   1c242:	4a0e      	ldr	r2, [pc, #56]	; (1c27c <appConnUpdateTimerStart+0x50>)
   1c244:	4413      	add	r3, r2
   1c246:	60fb      	str	r3, [r7, #12]

  pCb->updateTimer.handlerId = appHandlerId;
   1c248:	4b0d      	ldr	r3, [pc, #52]	; (1c280 <appConnUpdateTimerStart+0x54>)
   1c24a:	781a      	ldrb	r2, [r3, #0]
   1c24c:	68fb      	ldr	r3, [r7, #12]
   1c24e:	771a      	strb	r2, [r3, #28]
  pCb->updateTimer.msg.event = APP_CONN_UPDATE_TIMEOUT_IND;
   1c250:	68fb      	ldr	r3, [r7, #12]
   1c252:	2210      	movs	r2, #16
   1c254:	769a      	strb	r2, [r3, #26]
  pCb->updateTimer.msg.param = connId;
   1c256:	79fb      	ldrb	r3, [r7, #7]
   1c258:	b29a      	uxth	r2, r3
   1c25a:	68fb      	ldr	r3, [r7, #12]
   1c25c:	831a      	strh	r2, [r3, #24]
  WsfTimerStartMs(&pCb->updateTimer, pAppUpdateCfg->idlePeriod);
   1c25e:	68fb      	ldr	r3, [r7, #12]
   1c260:	f103 0210 	add.w	r2, r3, #16
   1c264:	4b07      	ldr	r3, [pc, #28]	; (1c284 <appConnUpdateTimerStart+0x58>)
   1c266:	681b      	ldr	r3, [r3, #0]
   1c268:	681b      	ldr	r3, [r3, #0]
   1c26a:	4619      	mov	r1, r3
   1c26c:	4610      	mov	r0, r2
   1c26e:	f011 facf 	bl	2d810 <WsfTimerStartMs>
}
   1c272:	bf00      	nop
   1c274:	3710      	adds	r7, #16
   1c276:	46bd      	mov	sp, r7
   1c278:	bd80      	pop	{r7, pc}
   1c27a:	bf00      	nop
   1c27c:	10010ed0 	.word	0x10010ed0
   1c280:	10010ebc 	.word	0x10010ebc
   1c284:	10010e98 	.word	0x10010e98

0001c288 <appConnUpdateTimerStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appConnUpdateTimerStop(appConnCb_t *pCb)
{
   1c288:	b580      	push	{r7, lr}
   1c28a:	b082      	sub	sp, #8
   1c28c:	af00      	add	r7, sp, #0
   1c28e:	6078      	str	r0, [r7, #4]
  /* stop connection update timer */
  if (pAppUpdateCfg->idlePeriod != 0)
   1c290:	4b06      	ldr	r3, [pc, #24]	; (1c2ac <appConnUpdateTimerStop+0x24>)
   1c292:	681b      	ldr	r3, [r3, #0]
   1c294:	681b      	ldr	r3, [r3, #0]
   1c296:	2b00      	cmp	r3, #0
   1c298:	d004      	beq.n	1c2a4 <appConnUpdateTimerStop+0x1c>
  {
    WsfTimerStop(&pCb->updateTimer);
   1c29a:	687b      	ldr	r3, [r7, #4]
   1c29c:	3310      	adds	r3, #16
   1c29e:	4618      	mov	r0, r3
   1c2a0:	f011 faca 	bl	2d838 <WsfTimerStop>
  }
}
   1c2a4:	bf00      	nop
   1c2a6:	3708      	adds	r7, #8
   1c2a8:	46bd      	mov	sp, r7
   1c2aa:	bd80      	pop	{r7, pc}
   1c2ac:	10010e98 	.word	0x10010e98

0001c2b0 <appSlaveResolveAddr>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveResolveAddr(dmEvt_t *pMsg)
{
   1c2b0:	b580      	push	{r7, lr}
   1c2b2:	b084      	sub	sp, #16
   1c2b4:	af00      	add	r7, sp, #0
   1c2b6:	6078      	str	r0, [r7, #4]
  appDbHdl_t hdl;
  dmSecKey_t *pPeerKey;

  /* if address resolution's in progress */
  if (appSlaveCb.inProgress)
   1c2b8:	4b16      	ldr	r3, [pc, #88]	; (1c314 <appSlaveResolveAddr+0x64>)
   1c2ba:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1c2be:	2b00      	cmp	r3, #0
   1c2c0:	d124      	bne.n	1c30c <appSlaveResolveAddr+0x5c>
  {
    return;
  }

  /* get the first database record */
  hdl = AppDbGetNextRecord(APP_DB_HDL_NONE);
   1c2c2:	2000      	movs	r0, #0
   1c2c4:	f7fe fcf0 	bl	1aca8 <AppDbGetNextRecord>
   1c2c8:	60f8      	str	r0, [r7, #12]

  /* if we have any bond records */
  if ((hdl != APP_DB_HDL_NONE) && ((pPeerKey = AppDbGetKey(hdl, DM_KEY_IRK, NULL)) != NULL))
   1c2ca:	68fb      	ldr	r3, [r7, #12]
   1c2cc:	2b00      	cmp	r3, #0
   1c2ce:	d01e      	beq.n	1c30e <appSlaveResolveAddr+0x5e>
   1c2d0:	2200      	movs	r2, #0
   1c2d2:	2104      	movs	r1, #4
   1c2d4:	68f8      	ldr	r0, [r7, #12]
   1c2d6:	f7fe fe07 	bl	1aee8 <AppDbGetKey>
   1c2da:	60b8      	str	r0, [r7, #8]
   1c2dc:	68bb      	ldr	r3, [r7, #8]
   1c2de:	2b00      	cmp	r3, #0
   1c2e0:	d015      	beq.n	1c30e <appSlaveResolveAddr+0x5e>
  {
    /* resolve advertiser's RPA to see if we already have a bond with this device */
    DmPrivResolveAddr(pMsg->connOpen.peerAddr, pPeerKey->irk.key, pMsg->hdr.param);
   1c2e2:	687b      	ldr	r3, [r7, #4]
   1c2e4:	f103 000a 	add.w	r0, r3, #10
   1c2e8:	68b9      	ldr	r1, [r7, #8]
   1c2ea:	687b      	ldr	r3, [r7, #4]
   1c2ec:	881b      	ldrh	r3, [r3, #0]
   1c2ee:	461a      	mov	r2, r3
   1c2f0:	f007 ff0e 	bl	24110 <DmPrivResolveAddr>

    /* store database record handle for later */
    appSlaveCb.dbHdl = hdl;
   1c2f4:	4a07      	ldr	r2, [pc, #28]	; (1c314 <appSlaveResolveAddr+0x64>)
   1c2f6:	68fb      	ldr	r3, [r7, #12]
   1c2f8:	6393      	str	r3, [r2, #56]	; 0x38
    appSlaveCb.inProgress = TRUE;
   1c2fa:	4b06      	ldr	r3, [pc, #24]	; (1c314 <appSlaveResolveAddr+0x64>)
   1c2fc:	2201      	movs	r2, #1
   1c2fe:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    appSlaveCb.findLtk = FALSE;
   1c302:	4b04      	ldr	r3, [pc, #16]	; (1c314 <appSlaveResolveAddr+0x64>)
   1c304:	2200      	movs	r2, #0
   1c306:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
   1c30a:	e000      	b.n	1c30e <appSlaveResolveAddr+0x5e>
    return;
   1c30c:	bf00      	nop
  }
}
   1c30e:	3710      	adds	r7, #16
   1c310:	46bd      	mov	sp, r7
   1c312:	bd80      	pop	{r7, pc}
   1c314:	10011000 	.word	0x10011000

0001c318 <appSecRspLtk>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecRspLtk(appConnCb_t *pCb)
{
   1c318:	b580      	push	{r7, lr}
   1c31a:	b084      	sub	sp, #16
   1c31c:	af00      	add	r7, sp, #0
   1c31e:	6078      	str	r0, [r7, #4]
  dmSecKey_t  *pKey = NULL;
   1c320:	2300      	movs	r3, #0
   1c322:	60fb      	str	r3, [r7, #12]
  uint8_t     secLevel;

  /* if there is a record */
  if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c324:	687b      	ldr	r3, [r7, #4]
   1c326:	681b      	ldr	r3, [r3, #0]
   1c328:	2b00      	cmp	r3, #0
   1c32a:	d008      	beq.n	1c33e <appSecRspLtk+0x26>
  {
    /* get ltk */
    pKey = AppDbGetKey(pCb->dbHdl, DM_KEY_LOCAL_LTK, &secLevel);
   1c32c:	687b      	ldr	r3, [r7, #4]
   1c32e:	681b      	ldr	r3, [r3, #0]
   1c330:	f107 020b 	add.w	r2, r7, #11
   1c334:	2101      	movs	r1, #1
   1c336:	4618      	mov	r0, r3
   1c338:	f7fe fdd6 	bl	1aee8 <AppDbGetKey>
   1c33c:	60f8      	str	r0, [r7, #12]
  }

  if (pKey != NULL)
   1c33e:	68fb      	ldr	r3, [r7, #12]
   1c340:	2b00      	cmp	r3, #0
   1c342:	d011      	beq.n	1c368 <appSecRspLtk+0x50>
  {
    /* if not bonded we need to update bonding state when encrypted */
    pCb->bondByLtk = !pCb->bonded;
   1c344:	687b      	ldr	r3, [r7, #4]
   1c346:	795b      	ldrb	r3, [r3, #5]
   1c348:	2b00      	cmp	r3, #0
   1c34a:	bf0c      	ite	eq
   1c34c:	2301      	moveq	r3, #1
   1c34e:	2300      	movne	r3, #0
   1c350:	b2db      	uxtb	r3, r3
   1c352:	461a      	mov	r2, r3
   1c354:	687b      	ldr	r3, [r7, #4]
   1c356:	719a      	strb	r2, [r3, #6]

    /* we found the key */
    DmSecLtkRsp(pCb->connId, TRUE, secLevel, pKey->ltk.key);
   1c358:	687b      	ldr	r3, [r7, #4]
   1c35a:	7918      	ldrb	r0, [r3, #4]
   1c35c:	7afa      	ldrb	r2, [r7, #11]
   1c35e:	68fb      	ldr	r3, [r7, #12]
   1c360:	2101      	movs	r1, #1
   1c362:	f008 facd 	bl	24900 <DmSecLtkRsp>
    pCb->bondByLtk = FALSE;

    /* key not found */
    DmSecLtkRsp(pCb->connId, FALSE, 0, NULL);
  }
}
   1c366:	e009      	b.n	1c37c <appSecRspLtk+0x64>
    pCb->bondByLtk = FALSE;
   1c368:	687b      	ldr	r3, [r7, #4]
   1c36a:	2200      	movs	r2, #0
   1c36c:	719a      	strb	r2, [r3, #6]
    DmSecLtkRsp(pCb->connId, FALSE, 0, NULL);
   1c36e:	687b      	ldr	r3, [r7, #4]
   1c370:	7918      	ldrb	r0, [r3, #4]
   1c372:	2300      	movs	r3, #0
   1c374:	2200      	movs	r2, #0
   1c376:	2100      	movs	r1, #0
   1c378:	f008 fac2 	bl	24900 <DmSecLtkRsp>
}
   1c37c:	bf00      	nop
   1c37e:	3710      	adds	r7, #16
   1c380:	46bd      	mov	sp, r7
   1c382:	bd80      	pop	{r7, pc}

0001c384 <appSlaveConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveConnOpen(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c384:	b580      	push	{r7, lr}
   1c386:	b082      	sub	sp, #8
   1c388:	af00      	add	r7, sp, #0
   1c38a:	6078      	str	r0, [r7, #4]
   1c38c:	6039      	str	r1, [r7, #0]
  /* process connection open event */
  appSlaveProcConnOpen(pMsg, pCb);
   1c38e:	6839      	ldr	r1, [r7, #0]
   1c390:	6878      	ldr	r0, [r7, #4]
   1c392:	f000 f831 	bl	1c3f8 <appSlaveProcConnOpen>

  if (appSlaveCb.advRestartCback != NULL)
   1c396:	4b09      	ldr	r3, [pc, #36]	; (1c3bc <appSlaveConnOpen+0x38>)
   1c398:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1c39a:	2b00      	cmp	r3, #0
   1c39c:	d003      	beq.n	1c3a6 <appSlaveConnOpen+0x22>
  {
    /* restart advertising */
    (*appSlaveCb.advRestartCback)(pMsg);
   1c39e:	4b07      	ldr	r3, [pc, #28]	; (1c3bc <appSlaveConnOpen+0x38>)
   1c3a0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1c3a2:	6878      	ldr	r0, [r7, #4]
   1c3a4:	4798      	blx	r3
  }

  appConnReadRemoteFeatTimerStart((dmConnId_t) pMsg->hdr.param);
   1c3a6:	687b      	ldr	r3, [r7, #4]
   1c3a8:	881b      	ldrh	r3, [r3, #0]
   1c3aa:	b2db      	uxtb	r3, r3
   1c3ac:	4618      	mov	r0, r3
   1c3ae:	f7fe ff95 	bl	1b2dc <appConnReadRemoteFeatTimerStart>
}
   1c3b2:	bf00      	nop
   1c3b4:	3708      	adds	r7, #8
   1c3b6:	46bd      	mov	sp, r7
   1c3b8:	bd80      	pop	{r7, pc}
   1c3ba:	bf00      	nop
   1c3bc:	10011000 	.word	0x10011000

0001c3c0 <appSlaveConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveConnClose(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c3c0:	b580      	push	{r7, lr}
   1c3c2:	b082      	sub	sp, #8
   1c3c4:	af00      	add	r7, sp, #0
   1c3c6:	6078      	str	r0, [r7, #4]
   1c3c8:	6039      	str	r1, [r7, #0]
  /* update privacy mode for peer device */
  AppUpdatePrivacyMode(pCb->dbHdl);
   1c3ca:	683b      	ldr	r3, [r7, #0]
   1c3cc:	681b      	ldr	r3, [r3, #0]
   1c3ce:	4618      	mov	r0, r3
   1c3d0:	f7fe ff58 	bl	1b284 <AppUpdatePrivacyMode>

  /* process connection close event */
  appSlaveProcConnClose(pMsg, pCb);
   1c3d4:	6839      	ldr	r1, [r7, #0]
   1c3d6:	6878      	ldr	r0, [r7, #4]
   1c3d8:	f000 f84a 	bl	1c470 <appSlaveProcConnClose>

  if (appSlaveCb.advRestartCback != NULL)
   1c3dc:	4b05      	ldr	r3, [pc, #20]	; (1c3f4 <appSlaveConnClose+0x34>)
   1c3de:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1c3e0:	2b00      	cmp	r3, #0
   1c3e2:	d003      	beq.n	1c3ec <appSlaveConnClose+0x2c>
  {
    /* restart advertising */
    (*appSlaveCb.advRestartCback)(pMsg);
   1c3e4:	4b03      	ldr	r3, [pc, #12]	; (1c3f4 <appSlaveConnClose+0x34>)
   1c3e6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   1c3e8:	6878      	ldr	r0, [r7, #4]
   1c3ea:	4798      	blx	r3
  }
}
   1c3ec:	bf00      	nop
   1c3ee:	3708      	adds	r7, #8
   1c3f0:	46bd      	mov	sp, r7
   1c3f2:	bd80      	pop	{r7, pc}
   1c3f4:	10011000 	.word	0x10011000

0001c3f8 <appSlaveProcConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveProcConnOpen(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c3f8:	b580      	push	{r7, lr}
   1c3fa:	b082      	sub	sp, #8
   1c3fc:	af00      	add	r7, sp, #0
   1c3fe:	6078      	str	r0, [r7, #4]
   1c400:	6039      	str	r1, [r7, #0]
  /* store connection ID */
  pCb->connId = (dmConnId_t) pMsg->hdr.param;
   1c402:	687b      	ldr	r3, [r7, #4]
   1c404:	881b      	ldrh	r3, [r3, #0]
   1c406:	b2da      	uxtb	r2, r3
   1c408:	683b      	ldr	r3, [r7, #0]
   1c40a:	711a      	strb	r2, [r3, #4]

  /* check if we should do connection parameter update */
  if ((pAppUpdateCfg->idlePeriod != 0) &&
   1c40c:	4b17      	ldr	r3, [pc, #92]	; (1c46c <appSlaveProcConnOpen+0x74>)
   1c40e:	681b      	ldr	r3, [r3, #0]
   1c410:	681b      	ldr	r3, [r3, #0]
   1c412:	2b00      	cmp	r3, #0
   1c414:	d026      	beq.n	1c464 <appSlaveProcConnOpen+0x6c>
      ((pMsg->connOpen.connInterval < pAppUpdateCfg->connIntervalMin) ||
   1c416:	687b      	ldr	r3, [r7, #4]
   1c418:	8a1a      	ldrh	r2, [r3, #16]
   1c41a:	4b14      	ldr	r3, [pc, #80]	; (1c46c <appSlaveProcConnOpen+0x74>)
   1c41c:	681b      	ldr	r3, [r3, #0]
   1c41e:	889b      	ldrh	r3, [r3, #4]
  if ((pAppUpdateCfg->idlePeriod != 0) &&
   1c420:	429a      	cmp	r2, r3
   1c422:	d314      	bcc.n	1c44e <appSlaveProcConnOpen+0x56>
       (pMsg->connOpen.connInterval > pAppUpdateCfg->connIntervalMax) ||
   1c424:	687b      	ldr	r3, [r7, #4]
   1c426:	8a1a      	ldrh	r2, [r3, #16]
   1c428:	4b10      	ldr	r3, [pc, #64]	; (1c46c <appSlaveProcConnOpen+0x74>)
   1c42a:	681b      	ldr	r3, [r3, #0]
   1c42c:	88db      	ldrh	r3, [r3, #6]
      ((pMsg->connOpen.connInterval < pAppUpdateCfg->connIntervalMin) ||
   1c42e:	429a      	cmp	r2, r3
   1c430:	d80d      	bhi.n	1c44e <appSlaveProcConnOpen+0x56>
       (pMsg->connOpen.connLatency != pAppUpdateCfg->connLatency) ||
   1c432:	687b      	ldr	r3, [r7, #4]
   1c434:	8a5a      	ldrh	r2, [r3, #18]
   1c436:	4b0d      	ldr	r3, [pc, #52]	; (1c46c <appSlaveProcConnOpen+0x74>)
   1c438:	681b      	ldr	r3, [r3, #0]
   1c43a:	891b      	ldrh	r3, [r3, #8]
       (pMsg->connOpen.connInterval > pAppUpdateCfg->connIntervalMax) ||
   1c43c:	429a      	cmp	r2, r3
   1c43e:	d106      	bne.n	1c44e <appSlaveProcConnOpen+0x56>
       (pMsg->connOpen.supTimeout != pAppUpdateCfg->supTimeout)))
   1c440:	687b      	ldr	r3, [r7, #4]
   1c442:	8a9a      	ldrh	r2, [r3, #20]
   1c444:	4b09      	ldr	r3, [pc, #36]	; (1c46c <appSlaveProcConnOpen+0x74>)
   1c446:	681b      	ldr	r3, [r3, #0]
   1c448:	895b      	ldrh	r3, [r3, #10]
       (pMsg->connOpen.connLatency != pAppUpdateCfg->connLatency) ||
   1c44a:	429a      	cmp	r2, r3
   1c44c:	d00a      	beq.n	1c464 <appSlaveProcConnOpen+0x6c>
  {
    pCb->connWasIdle = FALSE;
   1c44e:	683b      	ldr	r3, [r7, #0]
   1c450:	2200      	movs	r2, #0
   1c452:	729a      	strb	r2, [r3, #10]
    pCb->attempts = 0;
   1c454:	683b      	ldr	r3, [r7, #0]
   1c456:	2200      	movs	r2, #0
   1c458:	731a      	strb	r2, [r3, #12]
    appConnUpdateTimerStart(pCb->connId);
   1c45a:	683b      	ldr	r3, [r7, #0]
   1c45c:	791b      	ldrb	r3, [r3, #4]
   1c45e:	4618      	mov	r0, r3
   1c460:	f7ff fee4 	bl	1c22c <appConnUpdateTimerStart>
  }
}
   1c464:	bf00      	nop
   1c466:	3708      	adds	r7, #8
   1c468:	46bd      	mov	sp, r7
   1c46a:	bd80      	pop	{r7, pc}
   1c46c:	10010e98 	.word	0x10010e98

0001c470 <appSlaveProcConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveProcConnClose(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c470:	b580      	push	{r7, lr}
   1c472:	b084      	sub	sp, #16
   1c474:	af00      	add	r7, sp, #0
   1c476:	6078      	str	r0, [r7, #4]
   1c478:	6039      	str	r1, [r7, #0]
  uint8_t i;

  /* stop connection update timer */
  appConnUpdateTimerStop(pCb);
   1c47a:	6838      	ldr	r0, [r7, #0]
   1c47c:	f7ff ff04 	bl	1c288 <appConnUpdateTimerStop>

  /* clear connection ID */
  pCb->connId = DM_CONN_ID_NONE;
   1c480:	683b      	ldr	r3, [r7, #0]
   1c482:	2200      	movs	r2, #0
   1c484:	711a      	strb	r2, [r3, #4]

  /* clear update state */
  pCb->updateState = APP_CU_STATE_NONE;
   1c486:	683b      	ldr	r3, [r7, #0]
   1c488:	2200      	movs	r2, #0
   1c48a:	735a      	strb	r2, [r3, #13]

  /* cancel any address resolution in progress */
  appSlaveCb.inProgress = FALSE;
   1c48c:	4b10      	ldr	r3, [pc, #64]	; (1c4d0 <appSlaveProcConnClose+0x60>)
   1c48e:	2200      	movs	r2, #0
   1c490:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* if switching to connectable mode then set it up */
  if (pCb->setConnectable)
   1c494:	683b      	ldr	r3, [r7, #0]
   1c496:	7a5b      	ldrb	r3, [r3, #9]
   1c498:	2b00      	cmp	r3, #0
   1c49a:	d014      	beq.n	1c4c6 <appSlaveProcConnClose+0x56>
  {
    pCb->setConnectable = FALSE;
   1c49c:	683b      	ldr	r3, [r7, #0]
   1c49e:	2200      	movs	r2, #0
   1c4a0:	725a      	strb	r2, [r3, #9]
    appSlaveCb.discMode = APP_MODE_CONNECTABLE;
   1c4a2:	4b0b      	ldr	r3, [pc, #44]	; (1c4d0 <appSlaveProcConnClose+0x60>)
   1c4a4:	2200      	movs	r2, #0
   1c4a6:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

    /* for each advertising set */
    for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1c4aa:	2300      	movs	r3, #0
   1c4ac:	73fb      	strb	r3, [r7, #15]
   1c4ae:	e007      	b.n	1c4c0 <appSlaveProcConnClose+0x50>
    {
      /* force update of advertising data */
      appSlaveForceAdvDataSync(i, APP_MODE_CONNECTABLE);
   1c4b0:	7bfb      	ldrb	r3, [r7, #15]
   1c4b2:	2100      	movs	r1, #0
   1c4b4:	4618      	mov	r0, r3
   1c4b6:	f7ff fd93 	bl	1bfe0 <appSlaveForceAdvDataSync>
    for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1c4ba:	7bfb      	ldrb	r3, [r7, #15]
   1c4bc:	3301      	adds	r3, #1
   1c4be:	73fb      	strb	r3, [r7, #15]
   1c4c0:	7bfb      	ldrb	r3, [r7, #15]
   1c4c2:	2b00      	cmp	r3, #0
   1c4c4:	d0f4      	beq.n	1c4b0 <appSlaveProcConnClose+0x40>
    }
  }
}
   1c4c6:	bf00      	nop
   1c4c8:	3710      	adds	r7, #16
   1c4ca:	46bd      	mov	sp, r7
   1c4cc:	bd80      	pop	{r7, pc}
   1c4ce:	bf00      	nop
   1c4d0:	10011000 	.word	0x10011000

0001c4d4 <appSlaveConnUpdate>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveConnUpdate(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c4d4:	b580      	push	{r7, lr}
   1c4d6:	b082      	sub	sp, #8
   1c4d8:	af00      	add	r7, sp, #0
   1c4da:	6078      	str	r0, [r7, #4]
   1c4dc:	6039      	str	r1, [r7, #0]
  if (pAppUpdateCfg->idlePeriod != 0)
   1c4de:	4b1a      	ldr	r3, [pc, #104]	; (1c548 <appSlaveConnUpdate+0x74>)
   1c4e0:	681b      	ldr	r3, [r3, #0]
   1c4e2:	681b      	ldr	r3, [r3, #0]
   1c4e4:	2b00      	cmp	r3, #0
   1c4e6:	d02b      	beq.n	1c540 <appSlaveConnUpdate+0x6c>
  {
    /* if successful */
    if (pMsg->hdr.status == HCI_SUCCESS)
   1c4e8:	687b      	ldr	r3, [r7, #4]
   1c4ea:	78db      	ldrb	r3, [r3, #3]
   1c4ec:	2b00      	cmp	r3, #0
   1c4ee:	d117      	bne.n	1c520 <appSlaveConnUpdate+0x4c>
      // so here we need to check if the connection parameter
      // meets slave's requirement, if not, we should not stop
      // the timer.

      // only check connection interval for now
      if ((pAppUpdateCfg->connIntervalMin <= ((hciLeConnUpdateCmplEvt_t*)pMsg)->connInterval)
   1c4f0:	4b15      	ldr	r3, [pc, #84]	; (1c548 <appSlaveConnUpdate+0x74>)
   1c4f2:	681b      	ldr	r3, [r3, #0]
   1c4f4:	889a      	ldrh	r2, [r3, #4]
   1c4f6:	687b      	ldr	r3, [r7, #4]
   1c4f8:	891b      	ldrh	r3, [r3, #8]
   1c4fa:	429a      	cmp	r2, r3
   1c4fc:	d80a      	bhi.n	1c514 <appSlaveConnUpdate+0x40>
        &&(pAppUpdateCfg->connIntervalMax >= ((hciLeConnUpdateCmplEvt_t*)pMsg)->connInterval))
   1c4fe:	4b12      	ldr	r3, [pc, #72]	; (1c548 <appSlaveConnUpdate+0x74>)
   1c500:	681b      	ldr	r3, [r3, #0]
   1c502:	88da      	ldrh	r2, [r3, #6]
   1c504:	687b      	ldr	r3, [r7, #4]
   1c506:	891b      	ldrh	r3, [r3, #8]
   1c508:	429a      	cmp	r2, r3
   1c50a:	d303      	bcc.n	1c514 <appSlaveConnUpdate+0x40>
      {
        appConnUpdateTimerStop(pCb);
   1c50c:	6838      	ldr	r0, [r7, #0]
   1c50e:	f7ff febb 	bl	1c288 <appConnUpdateTimerStop>
    {
      /* start timer and try again */
      appConnUpdateTimerStart(pCb->connId);
    }
  }
}
   1c512:	e015      	b.n	1c540 <appSlaveConnUpdate+0x6c>
        appConnUpdateTimerStart(pCb->connId);
   1c514:	683b      	ldr	r3, [r7, #0]
   1c516:	791b      	ldrb	r3, [r3, #4]
   1c518:	4618      	mov	r0, r3
   1c51a:	f7ff fe87 	bl	1c22c <appConnUpdateTimerStart>
}
   1c51e:	e00f      	b.n	1c540 <appSlaveConnUpdate+0x6c>
    else if ((pMsg->hdr.status != HCI_ERR_CMD_DISALLOWED) && (pCb->attempts < pAppUpdateCfg->maxAttempts))
   1c520:	687b      	ldr	r3, [r7, #4]
   1c522:	78db      	ldrb	r3, [r3, #3]
   1c524:	2b0c      	cmp	r3, #12
   1c526:	d00b      	beq.n	1c540 <appSlaveConnUpdate+0x6c>
   1c528:	683b      	ldr	r3, [r7, #0]
   1c52a:	7b1a      	ldrb	r2, [r3, #12]
   1c52c:	4b06      	ldr	r3, [pc, #24]	; (1c548 <appSlaveConnUpdate+0x74>)
   1c52e:	681b      	ldr	r3, [r3, #0]
   1c530:	7b1b      	ldrb	r3, [r3, #12]
   1c532:	429a      	cmp	r2, r3
   1c534:	d204      	bcs.n	1c540 <appSlaveConnUpdate+0x6c>
      appConnUpdateTimerStart(pCb->connId);
   1c536:	683b      	ldr	r3, [r7, #0]
   1c538:	791b      	ldrb	r3, [r3, #4]
   1c53a:	4618      	mov	r0, r3
   1c53c:	f7ff fe76 	bl	1c22c <appConnUpdateTimerStart>
}
   1c540:	bf00      	nop
   1c542:	3708      	adds	r7, #8
   1c544:	46bd      	mov	sp, r7
   1c546:	bd80      	pop	{r7, pc}
   1c548:	10010e98 	.word	0x10010e98

0001c54c <appSlaveResolvedAddrInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveResolvedAddrInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c54c:	b580      	push	{r7, lr}
   1c54e:	b084      	sub	sp, #16
   1c550:	af00      	add	r7, sp, #0
   1c552:	6078      	str	r0, [r7, #4]
   1c554:	6039      	str	r1, [r7, #0]
  dmSecKey_t *pPeerKey;

  /* if address resolution is not in progress */
  if (!appSlaveCb.inProgress)
   1c556:	4b27      	ldr	r3, [pc, #156]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c558:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1c55c:	2b00      	cmp	r3, #0
   1c55e:	d044      	beq.n	1c5ea <appSlaveResolvedAddrInd+0x9e>
  {
    return;
  }

  /* if RPA resolved */
  if (pMsg->hdr.status == HCI_SUCCESS)
   1c560:	687b      	ldr	r3, [r7, #4]
   1c562:	78db      	ldrb	r3, [r3, #3]
   1c564:	2b00      	cmp	r3, #0
   1c566:	d110      	bne.n	1c58a <appSlaveResolvedAddrInd+0x3e>
  {
#ifdef AM_BLE_USE_NVM
    devFoundInDb = TRUE;
#endif
    /* record found */
    pCb->dbHdl = appSlaveCb.dbHdl;
   1c568:	4b22      	ldr	r3, [pc, #136]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c56a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   1c56c:	683b      	ldr	r3, [r7, #0]
   1c56e:	601a      	str	r2, [r3, #0]

    /* if LTK was requested while resolving master's address */
    if (appSlaveCb.findLtk)
   1c570:	4b20      	ldr	r3, [pc, #128]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c572:	f893 3037 	ldrb.w	r3, [r3, #55]	; 0x37
   1c576:	2b00      	cmp	r3, #0
   1c578:	d032      	beq.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
    {
      /* respond to LTK request */
      appSecRspLtk(pCb);
   1c57a:	6838      	ldr	r0, [r7, #0]
   1c57c:	f7ff fecc 	bl	1c318 <appSecRspLtk>

      appSlaveCb.findLtk = FALSE;
   1c580:	4b1c      	ldr	r3, [pc, #112]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c582:	2200      	movs	r2, #0
   1c584:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
   1c588:	e02a      	b.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
    }
  }
  /* if RPA did not resolve and there're more bonded records to go through */
  else if ((pMsg->hdr.status == HCI_ERR_AUTH_FAILURE) && (appSlaveCb.dbHdl != APP_DB_HDL_NONE))
   1c58a:	687b      	ldr	r3, [r7, #4]
   1c58c:	78db      	ldrb	r3, [r3, #3]
   1c58e:	2b05      	cmp	r3, #5
   1c590:	d126      	bne.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
   1c592:	4b18      	ldr	r3, [pc, #96]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c594:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1c596:	2b00      	cmp	r3, #0
   1c598:	d022      	beq.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
  {
    /* get the next database record */
    appSlaveCb.dbHdl = AppDbGetNextRecord(appSlaveCb.dbHdl);
   1c59a:	4b16      	ldr	r3, [pc, #88]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c59c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1c59e:	4618      	mov	r0, r3
   1c5a0:	f7fe fb82 	bl	1aca8 <AppDbGetNextRecord>
   1c5a4:	4603      	mov	r3, r0
   1c5a6:	4a13      	ldr	r2, [pc, #76]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c5a8:	6393      	str	r3, [r2, #56]	; 0x38

    /* if there's another bond record */
    if ((appSlaveCb.dbHdl != APP_DB_HDL_NONE) &&
   1c5aa:	4b12      	ldr	r3, [pc, #72]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c5ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1c5ae:	2b00      	cmp	r3, #0
   1c5b0:	d016      	beq.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
        ((pPeerKey = AppDbGetKey(appSlaveCb.dbHdl, DM_KEY_IRK, NULL)) != NULL))
   1c5b2:	4b10      	ldr	r3, [pc, #64]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c5b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   1c5b6:	2200      	movs	r2, #0
   1c5b8:	2104      	movs	r1, #4
   1c5ba:	4618      	mov	r0, r3
   1c5bc:	f7fe fc94 	bl	1aee8 <AppDbGetKey>
   1c5c0:	60f8      	str	r0, [r7, #12]
    if ((appSlaveCb.dbHdl != APP_DB_HDL_NONE) &&
   1c5c2:	68fb      	ldr	r3, [r7, #12]
   1c5c4:	2b00      	cmp	r3, #0
   1c5c6:	d00b      	beq.n	1c5e0 <appSlaveResolvedAddrInd+0x94>
    {
      /* resolve RPA using the next stored IRK */
      DmPrivResolveAddr(DmConnPeerAddr(pCb->connId), pPeerKey->irk.key, pMsg->hdr.param);
   1c5c8:	683b      	ldr	r3, [r7, #0]
   1c5ca:	791b      	ldrb	r3, [r3, #4]
   1c5cc:	4618      	mov	r0, r3
   1c5ce:	f006 ffab 	bl	23528 <DmConnPeerAddr>
   1c5d2:	68f9      	ldr	r1, [r7, #12]
   1c5d4:	687b      	ldr	r3, [r7, #4]
   1c5d6:	881b      	ldrh	r3, [r3, #0]
   1c5d8:	461a      	mov	r2, r3
   1c5da:	f007 fd99 	bl	24110 <DmPrivResolveAddr>

      /* not done yet */
      return;
   1c5de:	e005      	b.n	1c5ec <appSlaveResolvedAddrInd+0xa0>
    }
  }

  /* done with this address resolution */
  appSlaveCb.inProgress = FALSE;
   1c5e0:	4b04      	ldr	r3, [pc, #16]	; (1c5f4 <appSlaveResolvedAddrInd+0xa8>)
   1c5e2:	2200      	movs	r2, #0
   1c5e4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
   1c5e8:	e000      	b.n	1c5ec <appSlaveResolvedAddrInd+0xa0>
    return;
   1c5ea:	bf00      	nop
}
   1c5ec:	3710      	adds	r7, #16
   1c5ee:	46bd      	mov	sp, r7
   1c5f0:	bd80      	pop	{r7, pc}
   1c5f2:	bf00      	nop
   1c5f4:	10011000 	.word	0x10011000

0001c5f8 <appSlaveRemoteConnParamReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveRemoteConnParamReq(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c5f8:	b580      	push	{r7, lr}
   1c5fa:	b086      	sub	sp, #24
   1c5fc:	af00      	add	r7, sp, #0
   1c5fe:	6078      	str	r0, [r7, #4]
   1c600:	6039      	str	r1, [r7, #0]
  /* if configured to accept the remote connection parameter request */
  if (pAppSlaveReqActCfg->remConnParamReqAct == APP_ACT_ACCEPT)
   1c602:	4b16      	ldr	r3, [pc, #88]	; (1c65c <appSlaveRemoteConnParamReq+0x64>)
   1c604:	681b      	ldr	r3, [r3, #0]
   1c606:	781b      	ldrb	r3, [r3, #0]
   1c608:	2b00      	cmp	r3, #0
   1c60a:	d118      	bne.n	1c63e <appSlaveRemoteConnParamReq+0x46>
  {
    hciConnSpec_t connSpec;

    connSpec.connIntervalMin = pMsg->remConnParamReq.intervalMin;
   1c60c:	687b      	ldr	r3, [r7, #4]
   1c60e:	88db      	ldrh	r3, [r3, #6]
   1c610:	81bb      	strh	r3, [r7, #12]
    connSpec.connIntervalMax = pMsg->remConnParamReq.intervalMax;
   1c612:	687b      	ldr	r3, [r7, #4]
   1c614:	891b      	ldrh	r3, [r3, #8]
   1c616:	81fb      	strh	r3, [r7, #14]
    connSpec.connLatency = pMsg->remConnParamReq.latency;
   1c618:	687b      	ldr	r3, [r7, #4]
   1c61a:	895b      	ldrh	r3, [r3, #10]
   1c61c:	823b      	strh	r3, [r7, #16]
    connSpec.supTimeout = pMsg->remConnParamReq.timeout;
   1c61e:	687b      	ldr	r3, [r7, #4]
   1c620:	899b      	ldrh	r3, [r3, #12]
   1c622:	827b      	strh	r3, [r7, #18]
    connSpec.minCeLen = connSpec.maxCeLen = 0;
   1c624:	2300      	movs	r3, #0
   1c626:	82fb      	strh	r3, [r7, #22]
   1c628:	8afb      	ldrh	r3, [r7, #22]
   1c62a:	82bb      	strh	r3, [r7, #20]

    /* accept the remote device's request to change connection parameters */
    DmRemoteConnParamReqReply(pCb->connId, &connSpec);
   1c62c:	683b      	ldr	r3, [r7, #0]
   1c62e:	791b      	ldrb	r3, [r3, #4]
   1c630:	f107 020c 	add.w	r2, r7, #12
   1c634:	4611      	mov	r1, r2
   1c636:	4618      	mov	r0, r3
   1c638:	f006 fea6 	bl	23388 <DmRemoteConnParamReqReply>
  {
    /* reject the remote device's request to change connection parameters */
    DmRemoteConnParamReqNegReply(pCb->connId, HCI_ERR_UNSUP_FEAT);
  }
  /* else - app will handle the remote connection parameter request */
}
   1c63c:	e00a      	b.n	1c654 <appSlaveRemoteConnParamReq+0x5c>
  else if (pAppSlaveReqActCfg->remConnParamReqAct == APP_ACT_REJECT)
   1c63e:	4b07      	ldr	r3, [pc, #28]	; (1c65c <appSlaveRemoteConnParamReq+0x64>)
   1c640:	681b      	ldr	r3, [r3, #0]
   1c642:	781b      	ldrb	r3, [r3, #0]
   1c644:	2b01      	cmp	r3, #1
   1c646:	d105      	bne.n	1c654 <appSlaveRemoteConnParamReq+0x5c>
    DmRemoteConnParamReqNegReply(pCb->connId, HCI_ERR_UNSUP_FEAT);
   1c648:	683b      	ldr	r3, [r7, #0]
   1c64a:	791b      	ldrb	r3, [r3, #4]
   1c64c:	2111      	movs	r1, #17
   1c64e:	4618      	mov	r0, r3
   1c650:	f006 fec2 	bl	233d8 <DmRemoteConnParamReqNegReply>
}
   1c654:	bf00      	nop
   1c656:	3718      	adds	r7, #24
   1c658:	46bd      	mov	sp, r7
   1c65a:	bd80      	pop	{r7, pc}
   1c65c:	10002b34 	.word	0x10002b34

0001c660 <appSlaveSecConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appSlaveSecConnOpen(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c660:	b580      	push	{r7, lr}
   1c662:	b082      	sub	sp, #8
   1c664:	af00      	add	r7, sp, #0
   1c666:	6078      	str	r0, [r7, #4]
   1c668:	6039      	str	r1, [r7, #0]
  /* initialize state variables */
  // don't reset bonded flag which will overwrite saved bonded status.
  // pCb->bonded = FALSE;
  pCb->bondByLtk = FALSE;
   1c66a:	683b      	ldr	r3, [r7, #0]
   1c66c:	2200      	movs	r2, #0
   1c66e:	719a      	strb	r2, [r3, #6]
  pCb->bondByPairing = FALSE;
   1c670:	683b      	ldr	r3, [r7, #0]
   1c672:	2200      	movs	r2, #0
   1c674:	71da      	strb	r2, [r3, #7]

  /* find record for peer device */
  pCb->dbHdl = AppDbFindByAddr(pMsg->connOpen.addrType, pMsg->connOpen.peerAddr);
   1c676:	687b      	ldr	r3, [r7, #4]
   1c678:	7a5a      	ldrb	r2, [r3, #9]
   1c67a:	687b      	ldr	r3, [r7, #4]
   1c67c:	330a      	adds	r3, #10
   1c67e:	4619      	mov	r1, r3
   1c680:	4610      	mov	r0, r2
   1c682:	f7fe fbc9 	bl	1ae18 <AppDbFindByAddr>
   1c686:	4602      	mov	r2, r0
   1c688:	683b      	ldr	r3, [r7, #0]
   1c68a:	601a      	str	r2, [r3, #0]

  /* if record not found and the peer device uses an RPA */
  if ((pCb->dbHdl == NULL) && DM_RAND_ADDR_RPA(pMsg->connOpen.peerAddr, pMsg->connOpen.addrType))
   1c68c:	683b      	ldr	r3, [r7, #0]
   1c68e:	681b      	ldr	r3, [r3, #0]
   1c690:	2b00      	cmp	r3, #0
   1c692:	d10c      	bne.n	1c6ae <appSlaveSecConnOpen+0x4e>
   1c694:	687b      	ldr	r3, [r7, #4]
   1c696:	7a5b      	ldrb	r3, [r3, #9]
   1c698:	2b01      	cmp	r3, #1
   1c69a:	d108      	bne.n	1c6ae <appSlaveSecConnOpen+0x4e>
   1c69c:	687b      	ldr	r3, [r7, #4]
   1c69e:	7bdb      	ldrb	r3, [r3, #15]
   1c6a0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1c6a4:	2b40      	cmp	r3, #64	; 0x40
   1c6a6:	d102      	bne.n	1c6ae <appSlaveSecConnOpen+0x4e>
  {
    /* resolve master's RPA to see if we already have a bond with this device */
    appSlaveResolveAddr(pMsg);
   1c6a8:	6878      	ldr	r0, [r7, #4]
   1c6aa:	f7ff fe01 	bl	1c2b0 <appSlaveResolveAddr>
    devFoundInDb = TRUE;
  }
#endif
  
  /* send slave security request if configured to do so */
  if (pAppSecCfg->initiateSec && AppDbCheckBonded())
   1c6ae:	4b0c      	ldr	r3, [pc, #48]	; (1c6e0 <appSlaveSecConnOpen+0x80>)
   1c6b0:	681b      	ldr	r3, [r3, #0]
   1c6b2:	791b      	ldrb	r3, [r3, #4]
   1c6b4:	2b00      	cmp	r3, #0
   1c6b6:	d00e      	beq.n	1c6d6 <appSlaveSecConnOpen+0x76>
   1c6b8:	f7fe fb88 	bl	1adcc <AppDbCheckBonded>
   1c6bc:	4603      	mov	r3, r0
   1c6be:	2b00      	cmp	r3, #0
   1c6c0:	d009      	beq.n	1c6d6 <appSlaveSecConnOpen+0x76>
  {
    DmSecSlaveReq((dmConnId_t) pMsg->hdr.param, pAppSecCfg->auth);
   1c6c2:	687b      	ldr	r3, [r7, #4]
   1c6c4:	881b      	ldrh	r3, [r3, #0]
   1c6c6:	b2da      	uxtb	r2, r3
   1c6c8:	4b05      	ldr	r3, [pc, #20]	; (1c6e0 <appSlaveSecConnOpen+0x80>)
   1c6ca:	681b      	ldr	r3, [r3, #0]
   1c6cc:	781b      	ldrb	r3, [r3, #0]
   1c6ce:	4619      	mov	r1, r3
   1c6d0:	4610      	mov	r0, r2
   1c6d2:	f008 f8f4 	bl	248be <DmSecSlaveReq>
  }
}
   1c6d6:	bf00      	nop
   1c6d8:	3708      	adds	r7, #8
   1c6da:	46bd      	mov	sp, r7
   1c6dc:	bd80      	pop	{r7, pc}
   1c6de:	bf00      	nop
   1c6e0:	10010ec0 	.word	0x10010ec0

0001c6e4 <appSecConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appSecConnClose(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c6e4:	b580      	push	{r7, lr}
   1c6e6:	b082      	sub	sp, #8
   1c6e8:	af00      	add	r7, sp, #0
   1c6ea:	6078      	str	r0, [r7, #4]
   1c6ec:	6039      	str	r1, [r7, #0]
  /* if a device record was created check if it is valid */
  if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c6ee:	683b      	ldr	r3, [r7, #0]
   1c6f0:	681b      	ldr	r3, [r3, #0]
   1c6f2:	2b00      	cmp	r3, #0
   1c6f4:	d004      	beq.n	1c700 <appSecConnClose+0x1c>
  {
    AppDbCheckValidRecord(pCb->dbHdl);
   1c6f6:	683b      	ldr	r3, [r7, #0]
   1c6f8:	681b      	ldr	r3, [r3, #0]
   1c6fa:	4618      	mov	r0, r3
   1c6fc:	f7fe fb2a 	bl	1ad54 <AppDbCheckValidRecord>
  }
#ifdef AM_BLE_USE_NVM
  devFoundInDb = FALSE;
#endif
}
   1c700:	bf00      	nop
   1c702:	3708      	adds	r7, #8
   1c704:	46bd      	mov	sp, r7
   1c706:	bd80      	pop	{r7, pc}

0001c708 <appSecPairInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecPairInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c708:	b590      	push	{r4, r7, lr}
   1c70a:	b087      	sub	sp, #28
   1c70c:	af02      	add	r7, sp, #8
   1c70e:	6078      	str	r0, [r7, #4]
   1c710:	6039      	str	r1, [r7, #0]
  uint8_t rKeyDist;

  /* if in bondable mode or if peer is not requesting bonding
   * or if already bonded with this device and link is encrypted
   */
  if (appSlaveCb.bondable ||
   1c712:	4b40      	ldr	r3, [pc, #256]	; (1c814 <appSecPairInd+0x10c>)
   1c714:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
   1c718:	2b00      	cmp	r3, #0
   1c71a:	d111      	bne.n	1c740 <appSecPairInd+0x38>
      ((pMsg->pairInd.auth & DM_AUTH_BOND_FLAG) != DM_AUTH_BOND_FLAG) ||
   1c71c:	687b      	ldr	r3, [r7, #4]
   1c71e:	791b      	ldrb	r3, [r3, #4]
   1c720:	f003 0301 	and.w	r3, r3, #1
  if (appSlaveCb.bondable ||
   1c724:	2b00      	cmp	r3, #0
   1c726:	d00b      	beq.n	1c740 <appSecPairInd+0x38>
      (pCb->bonded && (DmConnSecLevel(pCb->connId) == DM_SEC_LEVEL_NONE)))
   1c728:	683b      	ldr	r3, [r7, #0]
   1c72a:	795b      	ldrb	r3, [r3, #5]
      ((pMsg->pairInd.auth & DM_AUTH_BOND_FLAG) != DM_AUTH_BOND_FLAG) ||
   1c72c:	2b00      	cmp	r3, #0
   1c72e:	d065      	beq.n	1c7fc <appSecPairInd+0xf4>
      (pCb->bonded && (DmConnSecLevel(pCb->connId) == DM_SEC_LEVEL_NONE)))
   1c730:	683b      	ldr	r3, [r7, #0]
   1c732:	791b      	ldrb	r3, [r3, #4]
   1c734:	4618      	mov	r0, r3
   1c736:	f006 ff0d 	bl	23554 <DmConnSecLevel>
   1c73a:	4603      	mov	r3, r0
   1c73c:	2b00      	cmp	r3, #0
   1c73e:	d15d      	bne.n	1c7fc <appSecPairInd+0xf4>
  {
    /* store bonding state:  if peer is requesting bonding and we want bonding */
    pCb->bondByPairing = (pMsg->pairInd.auth & pAppSecCfg->auth & DM_AUTH_BOND_FLAG) == DM_AUTH_BOND_FLAG;
   1c740:	687b      	ldr	r3, [r7, #4]
   1c742:	791a      	ldrb	r2, [r3, #4]
   1c744:	4b34      	ldr	r3, [pc, #208]	; (1c818 <appSecPairInd+0x110>)
   1c746:	681b      	ldr	r3, [r3, #0]
   1c748:	781b      	ldrb	r3, [r3, #0]
   1c74a:	4013      	ands	r3, r2
   1c74c:	b2db      	uxtb	r3, r3
   1c74e:	f003 0301 	and.w	r3, r3, #1
   1c752:	2b00      	cmp	r3, #0
   1c754:	bf14      	ite	ne
   1c756:	2301      	movne	r3, #1
   1c758:	2300      	moveq	r3, #0
   1c75a:	b2db      	uxtb	r3, r3
   1c75c:	461a      	mov	r2, r3
   1c75e:	683b      	ldr	r3, [r7, #0]
   1c760:	71da      	strb	r2, [r3, #7]

    /* if bonding and no device record */
    if (pCb->bondByPairing && pCb->dbHdl == APP_DB_HDL_NONE)
   1c762:	683b      	ldr	r3, [r7, #0]
   1c764:	79db      	ldrb	r3, [r3, #7]
   1c766:	2b00      	cmp	r3, #0
   1c768:	d018      	beq.n	1c79c <appSecPairInd+0x94>
   1c76a:	683b      	ldr	r3, [r7, #0]
   1c76c:	681b      	ldr	r3, [r3, #0]
   1c76e:	2b00      	cmp	r3, #0
   1c770:	d114      	bne.n	1c79c <appSecPairInd+0x94>
    {
      /* create a device record if none exists */
      pCb->dbHdl = AppDbNewRecord(DmConnPeerAddrType(pCb->connId), DmConnPeerAddr(pCb->connId), FALSE);
   1c772:	683b      	ldr	r3, [r7, #0]
   1c774:	791b      	ldrb	r3, [r3, #4]
   1c776:	4618      	mov	r0, r3
   1c778:	f006 febe 	bl	234f8 <DmConnPeerAddrType>
   1c77c:	4603      	mov	r3, r0
   1c77e:	461c      	mov	r4, r3
   1c780:	683b      	ldr	r3, [r7, #0]
   1c782:	791b      	ldrb	r3, [r3, #4]
   1c784:	4618      	mov	r0, r3
   1c786:	f006 fecf 	bl	23528 <DmConnPeerAddr>
   1c78a:	4603      	mov	r3, r0
   1c78c:	2200      	movs	r2, #0
   1c78e:	4619      	mov	r1, r3
   1c790:	4620      	mov	r0, r4
   1c792:	f7fe fa31 	bl	1abf8 <AppDbNewRecord>
   1c796:	4602      	mov	r2, r0
   1c798:	683b      	ldr	r3, [r7, #0]
   1c79a:	601a      	str	r2, [r3, #0]
    }

    /* initialize stored keys */
    pCb->rcvdKeys = 0;
   1c79c:	683b      	ldr	r3, [r7, #0]
   1c79e:	2200      	movs	r2, #0
   1c7a0:	72da      	strb	r2, [r3, #11]

    /* initialize key distribution */
    rKeyDist = pAppSecCfg->rKeyDist;
   1c7a2:	4b1d      	ldr	r3, [pc, #116]	; (1c818 <appSecPairInd+0x110>)
   1c7a4:	681b      	ldr	r3, [r3, #0]
   1c7a6:	789b      	ldrb	r3, [r3, #2]
   1c7a8:	73bb      	strb	r3, [r7, #14]
    iKeyDist = pAppSecCfg->iKeyDist;
   1c7aa:	4b1b      	ldr	r3, [pc, #108]	; (1c818 <appSecPairInd+0x110>)
   1c7ac:	681b      	ldr	r3, [r3, #0]
   1c7ae:	785b      	ldrb	r3, [r3, #1]
   1c7b0:	73fb      	strb	r3, [r7, #15]

    /* if peer is using random address request IRK */
    if (DmConnPeerAddrType(pCb->connId) == DM_ADDR_RANDOM)
   1c7b2:	683b      	ldr	r3, [r7, #0]
   1c7b4:	791b      	ldrb	r3, [r3, #4]
   1c7b6:	4618      	mov	r0, r3
   1c7b8:	f006 fe9e 	bl	234f8 <DmConnPeerAddrType>
   1c7bc:	4603      	mov	r3, r0
   1c7be:	2b01      	cmp	r3, #1
   1c7c0:	d103      	bne.n	1c7ca <appSecPairInd+0xc2>
    {
      iKeyDist |= DM_KEY_DIST_IRK;
   1c7c2:	7bfb      	ldrb	r3, [r7, #15]
   1c7c4:	f043 0302 	orr.w	r3, r3, #2
   1c7c8:	73fb      	strb	r3, [r7, #15]
    }

    /* only distribute keys both sides have agreed to */
    rKeyDist &= pMsg->pairInd.rKeyDist;
   1c7ca:	687b      	ldr	r3, [r7, #4]
   1c7cc:	79da      	ldrb	r2, [r3, #7]
   1c7ce:	7bbb      	ldrb	r3, [r7, #14]
   1c7d0:	4013      	ands	r3, r2
   1c7d2:	73bb      	strb	r3, [r7, #14]
    iKeyDist &= pMsg->pairInd.iKeyDist;
   1c7d4:	687b      	ldr	r3, [r7, #4]
   1c7d6:	799a      	ldrb	r2, [r3, #6]
   1c7d8:	7bfb      	ldrb	r3, [r7, #15]
   1c7da:	4013      	ands	r3, r2
   1c7dc:	73fb      	strb	r3, [r7, #15]

    /* accept pairing request */
    DmSecPairRsp(pCb->connId, pAppSecCfg->oob, pAppSecCfg->auth, iKeyDist, rKeyDist);
   1c7de:	683b      	ldr	r3, [r7, #0]
   1c7e0:	7918      	ldrb	r0, [r3, #4]
   1c7e2:	4b0d      	ldr	r3, [pc, #52]	; (1c818 <appSecPairInd+0x110>)
   1c7e4:	681b      	ldr	r3, [r3, #0]
   1c7e6:	78d9      	ldrb	r1, [r3, #3]
   1c7e8:	4b0b      	ldr	r3, [pc, #44]	; (1c818 <appSecPairInd+0x110>)
   1c7ea:	681b      	ldr	r3, [r3, #0]
   1c7ec:	781a      	ldrb	r2, [r3, #0]
   1c7ee:	7bfc      	ldrb	r4, [r7, #15]
   1c7f0:	7bbb      	ldrb	r3, [r7, #14]
   1c7f2:	9300      	str	r3, [sp, #0]
   1c7f4:	4623      	mov	r3, r4
   1c7f6:	f008 f82b 	bl	24850 <DmSecPairRsp>
   1c7fa:	e006      	b.n	1c80a <appSecPairInd+0x102>
  }
  /* otherwise reject pairing request */
  else
  {
    DmSecCancelReq(pCb->connId, SMP_ERR_PAIRING_NOT_SUP);
   1c7fc:	683b      	ldr	r3, [r7, #0]
   1c7fe:	791b      	ldrb	r3, [r3, #4]
   1c800:	2105      	movs	r1, #5
   1c802:	4618      	mov	r0, r3
   1c804:	f007 ff94 	bl	24730 <DmSecCancelReq>
  }
}
   1c808:	bf00      	nop
   1c80a:	bf00      	nop
   1c80c:	3714      	adds	r7, #20
   1c80e:	46bd      	mov	sp, r7
   1c810:	bd90      	pop	{r4, r7, pc}
   1c812:	bf00      	nop
   1c814:	10011000 	.word	0x10011000
   1c818:	10010ec0 	.word	0x10010ec0

0001c81c <appSecStoreKey>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecStoreKey(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c81c:	b580      	push	{r7, lr}
   1c81e:	b082      	sub	sp, #8
   1c820:	af00      	add	r7, sp, #0
   1c822:	6078      	str	r0, [r7, #4]
   1c824:	6039      	str	r1, [r7, #0]
  if (pCb->bondByPairing && pCb->dbHdl != APP_DB_HDL_NONE)
   1c826:	683b      	ldr	r3, [r7, #0]
   1c828:	79db      	ldrb	r3, [r3, #7]
   1c82a:	2b00      	cmp	r3, #0
   1c82c:	d012      	beq.n	1c854 <appSecStoreKey+0x38>
   1c82e:	683b      	ldr	r3, [r7, #0]
   1c830:	681b      	ldr	r3, [r3, #0]
   1c832:	2b00      	cmp	r3, #0
   1c834:	d00e      	beq.n	1c854 <appSecStoreKey+0x38>
  {
    /* key was received */
    pCb->rcvdKeys |= pMsg->keyInd.type;
   1c836:	683b      	ldr	r3, [r7, #0]
   1c838:	7ada      	ldrb	r2, [r3, #11]
   1c83a:	687b      	ldr	r3, [r7, #4]
   1c83c:	7f9b      	ldrb	r3, [r3, #30]
   1c83e:	4313      	orrs	r3, r2
   1c840:	b2da      	uxtb	r2, r3
   1c842:	683b      	ldr	r3, [r7, #0]
   1c844:	72da      	strb	r2, [r3, #11]

    /* store key in record */
    AppDbSetKey(pCb->dbHdl, &pMsg->keyInd);
   1c846:	683b      	ldr	r3, [r7, #0]
   1c848:	681b      	ldr	r3, [r3, #0]
   1c84a:	687a      	ldr	r2, [r7, #4]
   1c84c:	4611      	mov	r1, r2
   1c84e:	4618      	mov	r0, r3
   1c850:	f7fe fb96 	bl	1af80 <AppDbSetKey>
  }
}
   1c854:	bf00      	nop
   1c856:	3708      	adds	r7, #8
   1c858:	46bd      	mov	sp, r7
   1c85a:	bd80      	pop	{r7, pc}

0001c85c <appSecPairCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecPairCmpl(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c85c:	b580      	push	{r7, lr}
   1c85e:	b082      	sub	sp, #8
   1c860:	af00      	add	r7, sp, #0
   1c862:	6078      	str	r0, [r7, #4]
   1c864:	6039      	str	r1, [r7, #0]
  /* if bonding */
  if (pCb->bondByPairing)
   1c866:	683b      	ldr	r3, [r7, #0]
   1c868:	79db      	ldrb	r3, [r3, #7]
   1c86a:	2b00      	cmp	r3, #0
   1c86c:	d023      	beq.n	1c8b6 <appSecPairCmpl+0x5a>
  {
    /* set bonded state */
    pCb->bonded = TRUE;
   1c86e:	683b      	ldr	r3, [r7, #0]
   1c870:	2201      	movs	r2, #1
   1c872:	715a      	strb	r2, [r3, #5]

    /* validate record and received keys */
    if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c874:	683b      	ldr	r3, [r7, #0]
   1c876:	681b      	ldr	r3, [r3, #0]
   1c878:	2b00      	cmp	r3, #0
   1c87a:	d007      	beq.n	1c88c <appSecPairCmpl+0x30>
    {
      AppDbValidateRecord(pCb->dbHdl, pCb->rcvdKeys);
   1c87c:	683b      	ldr	r3, [r7, #0]
   1c87e:	681a      	ldr	r2, [r3, #0]
   1c880:	683b      	ldr	r3, [r7, #0]
   1c882:	7adb      	ldrb	r3, [r3, #11]
   1c884:	4619      	mov	r1, r3
   1c886:	4610      	mov	r0, r2
   1c888:	f7fe fa50 	bl	1ad2c <AppDbValidateRecord>
    }

    /* if bonded clear bondable mode */
    AppSetBondable(FALSE);
   1c88c:	2000      	movs	r0, #0
   1c88e:	f000 fd7d 	bl	1d38c <AppSetBondable>

    /* if discoverable switch to connectable mode when connection closes */
    if (appSlaveCb.discMode == APP_MODE_DISCOVERABLE)
   1c892:	4b0b      	ldr	r3, [pc, #44]	; (1c8c0 <appSecPairCmpl+0x64>)
   1c894:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1c898:	2b01      	cmp	r3, #1
   1c89a:	d102      	bne.n	1c8a2 <appSecPairCmpl+0x46>
    {
      pCb->setConnectable = TRUE;
   1c89c:	683b      	ldr	r3, [r7, #0]
   1c89e:	2201      	movs	r2, #1
   1c8a0:	725a      	strb	r2, [r3, #9]
    }

    /*  if bonded and device is using static or public address add device to white list */

    /* if bonded, add device to resolving list */
    if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c8a2:	683b      	ldr	r3, [r7, #0]
   1c8a4:	681b      	ldr	r3, [r3, #0]
   1c8a6:	2b00      	cmp	r3, #0
   1c8a8:	d005      	beq.n	1c8b6 <appSecPairCmpl+0x5a>
    {
      AppAddDevToResList(pMsg, pCb->connId);
   1c8aa:	683b      	ldr	r3, [r7, #0]
   1c8ac:	791b      	ldrb	r3, [r3, #4]
   1c8ae:	4619      	mov	r1, r3
   1c8b0:	6878      	ldr	r0, [r7, #4]
   1c8b2:	f7fe fcaf 	bl	1b214 <AppAddDevToResList>
    }
  }
}
   1c8b6:	bf00      	nop
   1c8b8:	3708      	adds	r7, #8
   1c8ba:	46bd      	mov	sp, r7
   1c8bc:	bd80      	pop	{r7, pc}
   1c8be:	bf00      	nop
   1c8c0:	10011000 	.word	0x10011000

0001c8c4 <appSecPairFailed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecPairFailed(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c8c4:	b480      	push	{r7}
   1c8c6:	b083      	sub	sp, #12
   1c8c8:	af00      	add	r7, sp, #0
   1c8ca:	6078      	str	r0, [r7, #4]
   1c8cc:	6039      	str	r1, [r7, #0]
  return;
   1c8ce:	bf00      	nop
}
   1c8d0:	370c      	adds	r7, #12
   1c8d2:	46bd      	mov	sp, r7
   1c8d4:	f85d 7b04 	ldr.w	r7, [sp], #4
   1c8d8:	4770      	bx	lr

0001c8da <appSecEncryptInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecEncryptInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c8da:	b480      	push	{r7}
   1c8dc:	b083      	sub	sp, #12
   1c8de:	af00      	add	r7, sp, #0
   1c8e0:	6078      	str	r0, [r7, #4]
   1c8e2:	6039      	str	r1, [r7, #0]
  /* check if bonding state should be set */
  if (pCb->bondByLtk && pMsg->encryptInd.usingLtk)
   1c8e4:	683b      	ldr	r3, [r7, #0]
   1c8e6:	799b      	ldrb	r3, [r3, #6]
   1c8e8:	2b00      	cmp	r3, #0
   1c8ea:	d009      	beq.n	1c900 <appSecEncryptInd+0x26>
   1c8ec:	687b      	ldr	r3, [r7, #4]
   1c8ee:	791b      	ldrb	r3, [r3, #4]
   1c8f0:	2b00      	cmp	r3, #0
   1c8f2:	d005      	beq.n	1c900 <appSecEncryptInd+0x26>
  {
    pCb->bonded = TRUE;
   1c8f4:	683b      	ldr	r3, [r7, #0]
   1c8f6:	2201      	movs	r2, #1
   1c8f8:	715a      	strb	r2, [r3, #5]
    pCb->bondByLtk = FALSE;
   1c8fa:	683b      	ldr	r3, [r7, #0]
   1c8fc:	2200      	movs	r2, #0
   1c8fe:	719a      	strb	r2, [r3, #6]
            }
        }
    }
  }
#endif
}
   1c900:	bf00      	nop
   1c902:	370c      	adds	r7, #12
   1c904:	46bd      	mov	sp, r7
   1c906:	f85d 7b04 	ldr.w	r7, [sp], #4
   1c90a:	4770      	bx	lr

0001c90c <appSecFindLtk>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSecFindLtk(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c90c:	b580      	push	{r7, lr}
   1c90e:	b082      	sub	sp, #8
   1c910:	af00      	add	r7, sp, #0
   1c912:	6078      	str	r0, [r7, #4]
   1c914:	6039      	str	r1, [r7, #0]
  /* if device record is not in place */
  if (pCb->dbHdl == APP_DB_HDL_NONE)
   1c916:	683b      	ldr	r3, [r7, #0]
   1c918:	681b      	ldr	r3, [r3, #0]
   1c91a:	2b00      	cmp	r3, #0
   1c91c:	d12b      	bne.n	1c976 <appSecFindLtk+0x6a>
  {
    /* if ediv or rand is not zero */
    if ((pMsg->ltkReqInd.encDiversifier != 0) ||
   1c91e:	687b      	ldr	r3, [r7, #4]
   1c920:	89db      	ldrh	r3, [r3, #14]
   1c922:	2b00      	cmp	r3, #0
   1c924:	d109      	bne.n	1c93a <appSecFindLtk+0x2e>
        (memcmp(pMsg->ltkReqInd.randNum, calc128Zeros, SMP_RAND8_LEN) != 0))
   1c926:	687b      	ldr	r3, [r7, #4]
   1c928:	3306      	adds	r3, #6
   1c92a:	2208      	movs	r2, #8
   1c92c:	4915      	ldr	r1, [pc, #84]	; (1c984 <appSecFindLtk+0x78>)
   1c92e:	4618      	mov	r0, r3
   1c930:	f013 fb42 	bl	2ffb8 <memcmp>
   1c934:	4603      	mov	r3, r0
    if ((pMsg->ltkReqInd.encDiversifier != 0) ||
   1c936:	2b00      	cmp	r3, #0
   1c938:	d013      	beq.n	1c962 <appSecFindLtk+0x56>
    {
      /* find record */
      pCb->dbHdl = AppDbFindByLtkReq(pMsg->ltkReqInd.encDiversifier, pMsg->ltkReqInd.randNum);
   1c93a:	687b      	ldr	r3, [r7, #4]
   1c93c:	89da      	ldrh	r2, [r3, #14]
   1c93e:	687b      	ldr	r3, [r7, #4]
   1c940:	3306      	adds	r3, #6
   1c942:	4619      	mov	r1, r3
   1c944:	4610      	mov	r0, r2
   1c946:	f7fe fa9d 	bl	1ae84 <AppDbFindByLtkReq>
   1c94a:	4602      	mov	r2, r0
   1c94c:	683b      	ldr	r3, [r7, #0]
   1c94e:	601a      	str	r2, [r3, #0]
      if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c950:	683b      	ldr	r3, [r7, #0]
   1c952:	681b      	ldr	r3, [r3, #0]
   1c954:	2b00      	cmp	r3, #0
   1c956:	d00e      	beq.n	1c976 <appSecFindLtk+0x6a>
      {
        /* record found, cancel any address resolution in progress */
        appSlaveCb.inProgress = FALSE;
   1c958:	4b0b      	ldr	r3, [pc, #44]	; (1c988 <appSecFindLtk+0x7c>)
   1c95a:	2200      	movs	r2, #0
   1c95c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
      if (pCb->dbHdl != APP_DB_HDL_NONE)
   1c960:	e009      	b.n	1c976 <appSecFindLtk+0x6a>
      }
    }
    /* if address resolution in progress */
    else if (appSlaveCb.inProgress)
   1c962:	4b09      	ldr	r3, [pc, #36]	; (1c988 <appSecFindLtk+0x7c>)
   1c964:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
   1c968:	2b00      	cmp	r3, #0
   1c96a:	d004      	beq.n	1c976 <appSecFindLtk+0x6a>
    {
      /* postpone LTK look up till address resolution is completed */
      appSlaveCb.findLtk = TRUE;
   1c96c:	4b06      	ldr	r3, [pc, #24]	; (1c988 <appSecFindLtk+0x7c>)
   1c96e:	2201      	movs	r2, #1
   1c970:	f883 2037 	strb.w	r2, [r3, #55]	; 0x37
      return;
   1c974:	e002      	b.n	1c97c <appSecFindLtk+0x70>
    }
  }

  /* respond to LTK request */
  appSecRspLtk(pCb);
   1c976:	6838      	ldr	r0, [r7, #0]
   1c978:	f7ff fcce 	bl	1c318 <appSecRspLtk>
}
   1c97c:	3708      	adds	r7, #8
   1c97e:	46bd      	mov	sp, r7
   1c980:	bd80      	pop	{r7, pc}
   1c982:	bf00      	nop
   1c984:	00045bbc 	.word	0x00045bbc
   1c988:	10011000 	.word	0x10011000

0001c98c <appPrivSetAddrResEnableInd>:
*
*  \return None.
*/
/*************************************************************************************************/
static void appPrivSetAddrResEnableInd(dmEvt_t *pMsg)
{
   1c98c:	b580      	push	{r7, lr}
   1c98e:	b082      	sub	sp, #8
   1c990:	af00      	add	r7, sp, #0
   1c992:	6078      	str	r0, [r7, #4]
  if (pMsg->hdr.status == HCI_SUCCESS)
   1c994:	687b      	ldr	r3, [r7, #4]
   1c996:	78db      	ldrb	r3, [r3, #3]
   1c998:	2b00      	cmp	r3, #0
   1c99a:	d105      	bne.n	1c9a8 <appPrivSetAddrResEnableInd+0x1c>
  {
    SvcCoreGapCentAddrResUpdate(DmLlPrivEnabled());
   1c99c:	f007 fa96 	bl	23ecc <DmLlPrivEnabled>
   1c9a0:	4603      	mov	r3, r0
   1c9a2:	4618      	mov	r0, r3
   1c9a4:	f012 fe90 	bl	2f6c8 <SvcCoreGapCentAddrResUpdate>
  }
}
   1c9a8:	bf00      	nop
   1c9aa:	3708      	adds	r7, #8
   1c9ac:	46bd      	mov	sp, r7
   1c9ae:	bd80      	pop	{r7, pc}

0001c9b0 <appPrivAddDevToResListInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appPrivAddDevToResListInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c9b0:	b580      	push	{r7, lr}
   1c9b2:	b082      	sub	sp, #8
   1c9b4:	af00      	add	r7, sp, #0
   1c9b6:	6078      	str	r0, [r7, #4]
   1c9b8:	6039      	str	r1, [r7, #0]
  if ((pMsg->hdr.status == HCI_SUCCESS) && (pCb->dbHdl != APP_DB_HDL_NONE))
   1c9ba:	687b      	ldr	r3, [r7, #4]
   1c9bc:	78db      	ldrb	r3, [r3, #3]
   1c9be:	2b00      	cmp	r3, #0
   1c9c0:	d109      	bne.n	1c9d6 <appPrivAddDevToResListInd+0x26>
   1c9c2:	683b      	ldr	r3, [r7, #0]
   1c9c4:	681b      	ldr	r3, [r3, #0]
   1c9c6:	2b00      	cmp	r3, #0
   1c9c8:	d005      	beq.n	1c9d6 <appPrivAddDevToResListInd+0x26>
  {
    /* peer device's been added to resolving list */
    AppDbSetPeerAddedToRl(pCb->dbHdl, TRUE);
   1c9ca:	683b      	ldr	r3, [r7, #0]
   1c9cc:	681b      	ldr	r3, [r3, #0]
   1c9ce:	2101      	movs	r1, #1
   1c9d0:	4618      	mov	r0, r3
   1c9d2:	f7fe fb5e 	bl	1b092 <AppDbSetPeerAddedToRl>
  }
}
   1c9d6:	bf00      	nop
   1c9d8:	3708      	adds	r7, #8
   1c9da:	46bd      	mov	sp, r7
   1c9dc:	bd80      	pop	{r7, pc}

0001c9de <appPrivRemDevFromResListInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appPrivRemDevFromResListInd(dmEvt_t *pMsg, appConnCb_t *pCb)
{
   1c9de:	b580      	push	{r7, lr}
   1c9e0:	b082      	sub	sp, #8
   1c9e2:	af00      	add	r7, sp, #0
   1c9e4:	6078      	str	r0, [r7, #4]
   1c9e6:	6039      	str	r1, [r7, #0]
  if ((pMsg->hdr.status == HCI_SUCCESS) && (pCb->dbHdl != APP_DB_HDL_NONE))
   1c9e8:	687b      	ldr	r3, [r7, #4]
   1c9ea:	78db      	ldrb	r3, [r3, #3]
   1c9ec:	2b00      	cmp	r3, #0
   1c9ee:	d109      	bne.n	1ca04 <appPrivRemDevFromResListInd+0x26>
   1c9f0:	683b      	ldr	r3, [r7, #0]
   1c9f2:	681b      	ldr	r3, [r3, #0]
   1c9f4:	2b00      	cmp	r3, #0
   1c9f6:	d005      	beq.n	1ca04 <appPrivRemDevFromResListInd+0x26>
  {
    /* peer device's been removed from resolving list */
    AppDbSetPeerAddedToRl(pCb->dbHdl, FALSE);
   1c9f8:	683b      	ldr	r3, [r7, #0]
   1c9fa:	681b      	ldr	r3, [r3, #0]
   1c9fc:	2100      	movs	r1, #0
   1c9fe:	4618      	mov	r0, r3
   1ca00:	f7fe fb47 	bl	1b092 <AppDbSetPeerAddedToRl>
  }
}
   1ca04:	bf00      	nop
   1ca06:	3708      	adds	r7, #8
   1ca08:	46bd      	mov	sp, r7
   1ca0a:	bd80      	pop	{r7, pc}

0001ca0c <appSlaveConnUpdateTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveConnUpdateTimeout(wsfMsgHdr_t *pMsg, appConnCb_t *pCb)
{
   1ca0c:	b580      	push	{r7, lr}
   1ca0e:	b086      	sub	sp, #24
   1ca10:	af00      	add	r7, sp, #0
   1ca12:	6078      	str	r0, [r7, #4]
   1ca14:	6039      	str	r1, [r7, #0]
  hciConnSpec_t connSpec;
  bool_t        idle;

  /* Change state to updating */
  pCb->updateState = APP_CU_STATE_UPDATING;
   1ca16:	683b      	ldr	r3, [r7, #0]
   1ca18:	2202      	movs	r2, #2
   1ca1a:	735a      	strb	r2, [r3, #13]

  /* check if connection is idle */
  idle = (DmConnCheckIdle(pCb->connId) == 0);
   1ca1c:	683b      	ldr	r3, [r7, #0]
   1ca1e:	791b      	ldrb	r3, [r3, #4]
   1ca20:	4618      	mov	r0, r3
   1ca22:	f006 fe13 	bl	2364c <DmConnCheckIdle>
   1ca26:	4603      	mov	r3, r0
   1ca28:	2b00      	cmp	r3, #0
   1ca2a:	bf0c      	ite	eq
   1ca2c:	2301      	moveq	r3, #1
   1ca2e:	2300      	movne	r3, #0
   1ca30:	b2db      	uxtb	r3, r3
   1ca32:	75fb      	strb	r3, [r7, #23]

  /* if connection is idle and was also idle on last check */
  if (idle && pCb->connWasIdle)
   1ca34:	7dfb      	ldrb	r3, [r7, #23]
   1ca36:	2b00      	cmp	r3, #0
   1ca38:	d027      	beq.n	1ca8a <appSlaveConnUpdateTimeout+0x7e>
   1ca3a:	683b      	ldr	r3, [r7, #0]
   1ca3c:	7a9b      	ldrb	r3, [r3, #10]
   1ca3e:	2b00      	cmp	r3, #0
   1ca40:	d023      	beq.n	1ca8a <appSlaveConnUpdateTimeout+0x7e>
  {
    /* do update */
    pCb->attempts++;
   1ca42:	683b      	ldr	r3, [r7, #0]
   1ca44:	7b1b      	ldrb	r3, [r3, #12]
   1ca46:	3301      	adds	r3, #1
   1ca48:	b2da      	uxtb	r2, r3
   1ca4a:	683b      	ldr	r3, [r7, #0]
   1ca4c:	731a      	strb	r2, [r3, #12]
    connSpec.connIntervalMin = pAppUpdateCfg->connIntervalMin;
   1ca4e:	4b15      	ldr	r3, [pc, #84]	; (1caa4 <appSlaveConnUpdateTimeout+0x98>)
   1ca50:	681b      	ldr	r3, [r3, #0]
   1ca52:	889b      	ldrh	r3, [r3, #4]
   1ca54:	813b      	strh	r3, [r7, #8]
    connSpec.connIntervalMax = pAppUpdateCfg->connIntervalMax;
   1ca56:	4b13      	ldr	r3, [pc, #76]	; (1caa4 <appSlaveConnUpdateTimeout+0x98>)
   1ca58:	681b      	ldr	r3, [r3, #0]
   1ca5a:	88db      	ldrh	r3, [r3, #6]
   1ca5c:	817b      	strh	r3, [r7, #10]
    connSpec.connLatency = pAppUpdateCfg->connLatency;
   1ca5e:	4b11      	ldr	r3, [pc, #68]	; (1caa4 <appSlaveConnUpdateTimeout+0x98>)
   1ca60:	681b      	ldr	r3, [r3, #0]
   1ca62:	891b      	ldrh	r3, [r3, #8]
   1ca64:	81bb      	strh	r3, [r7, #12]
    connSpec.supTimeout = pAppUpdateCfg->supTimeout;
   1ca66:	4b0f      	ldr	r3, [pc, #60]	; (1caa4 <appSlaveConnUpdateTimeout+0x98>)
   1ca68:	681b      	ldr	r3, [r3, #0]
   1ca6a:	895b      	ldrh	r3, [r3, #10]
   1ca6c:	81fb      	strh	r3, [r7, #14]
    connSpec.minCeLen = 0;
   1ca6e:	2300      	movs	r3, #0
   1ca70:	823b      	strh	r3, [r7, #16]
    connSpec.maxCeLen = 0xffff;
   1ca72:	f64f 73ff 	movw	r3, #65535	; 0xffff
   1ca76:	827b      	strh	r3, [r7, #18]

    DmConnUpdate(pCb->connId, &connSpec);
   1ca78:	683b      	ldr	r3, [r7, #0]
   1ca7a:	791b      	ldrb	r3, [r3, #4]
   1ca7c:	f107 0208 	add.w	r2, r7, #8
   1ca80:	4611      	mov	r1, r2
   1ca82:	4618      	mov	r0, r3
   1ca84:	f006 fc50 	bl	23328 <DmConnUpdate>
   1ca88:	e008      	b.n	1ca9c <appSlaveConnUpdateTimeout+0x90>
  }
  else
  {
    pCb->connWasIdle = idle;
   1ca8a:	683b      	ldr	r3, [r7, #0]
   1ca8c:	7dfa      	ldrb	r2, [r7, #23]
   1ca8e:	729a      	strb	r2, [r3, #10]
    appConnUpdateTimerStart(pCb->connId);
   1ca90:	683b      	ldr	r3, [r7, #0]
   1ca92:	791b      	ldrb	r3, [r3, #4]
   1ca94:	4618      	mov	r0, r3
   1ca96:	f7ff fbc9 	bl	1c22c <appConnUpdateTimerStart>
  }
}
   1ca9a:	bf00      	nop
   1ca9c:	bf00      	nop
   1ca9e:	3718      	adds	r7, #24
   1caa0:	46bd      	mov	sp, r7
   1caa2:	bd80      	pop	{r7, pc}
   1caa4:	10010e98 	.word	0x10010e98

0001caa8 <appSlaveProcMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appSlaveProcMsg(wsfMsgHdr_t *pMsg)
{
   1caa8:	b580      	push	{r7, lr}
   1caaa:	b084      	sub	sp, #16
   1caac:	af00      	add	r7, sp, #0
   1caae:	6078      	str	r0, [r7, #4]
  appConnCb_t *pCb;

  /* look up app connection control block from DM connection ID */
  pCb = &appConnCb[pMsg->param - 1];
   1cab0:	687b      	ldr	r3, [r7, #4]
   1cab2:	881b      	ldrh	r3, [r3, #0]
   1cab4:	1e5a      	subs	r2, r3, #1
   1cab6:	4613      	mov	r3, r2
   1cab8:	005b      	lsls	r3, r3, #1
   1caba:	4413      	add	r3, r2
   1cabc:	011b      	lsls	r3, r3, #4
   1cabe:	4a0c      	ldr	r2, [pc, #48]	; (1caf0 <appSlaveProcMsg+0x48>)
   1cac0:	4413      	add	r3, r2
   1cac2:	60fb      	str	r3, [r7, #12]

  switch(pMsg->event)
   1cac4:	687b      	ldr	r3, [r7, #4]
   1cac6:	789b      	ldrb	r3, [r3, #2]
   1cac8:	2b10      	cmp	r3, #16
   1caca:	d10c      	bne.n	1cae6 <appSlaveProcMsg+0x3e>
  {
    case APP_CONN_UPDATE_TIMEOUT_IND:
      /* Check state to determine if read remote features is needed */
      if (pCb->updateState == APP_CU_STATE_UPDATING)
   1cacc:	68fb      	ldr	r3, [r7, #12]
   1cace:	7b5b      	ldrb	r3, [r3, #13]
   1cad0:	2b02      	cmp	r3, #2
   1cad2:	d104      	bne.n	1cade <appSlaveProcMsg+0x36>
      {
        appSlaveConnUpdateTimeout(pMsg, pCb);
   1cad4:	68f9      	ldr	r1, [r7, #12]
   1cad6:	6878      	ldr	r0, [r7, #4]
   1cad8:	f7ff ff98 	bl	1ca0c <appSlaveConnUpdateTimeout>
      }
      else
      {
        pCb->updateState = APP_CU_STATE_WAIT_FEATURES;
      }
      break;
   1cadc:	e004      	b.n	1cae8 <appSlaveProcMsg+0x40>
        pCb->updateState = APP_CU_STATE_WAIT_FEATURES;
   1cade:	68fb      	ldr	r3, [r7, #12]
   1cae0:	2201      	movs	r2, #1
   1cae2:	735a      	strb	r2, [r3, #13]
      break;
   1cae4:	e000      	b.n	1cae8 <appSlaveProcMsg+0x40>

    default:
      break;
   1cae6:	bf00      	nop
  }
}
   1cae8:	bf00      	nop
   1caea:	3710      	adds	r7, #16
   1caec:	46bd      	mov	sp, r7
   1caee:	bd80      	pop	{r7, pc}
   1caf0:	10010ed0 	.word	0x10010ed0

0001caf4 <AppSlaveInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppSlaveInit(void)
{
   1caf4:	b580      	push	{r7, lr}
   1caf6:	b082      	sub	sp, #8
   1caf8:	af00      	add	r7, sp, #0
  uint8_t i;

  /* for each advertising set */
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1cafa:	2300      	movs	r3, #0
   1cafc:	71fb      	strb	r3, [r7, #7]
   1cafe:	e027      	b.n	1cb50 <AppSlaveInit+0x5c>
  {
    /* initialize advertising state */
    appSlaveCb.advState[i] = APP_ADV_STOPPED;
   1cb00:	79fb      	ldrb	r3, [r7, #7]
   1cb02:	4a1d      	ldr	r2, [pc, #116]	; (1cb78 <AppSlaveInit+0x84>)
   1cb04:	4413      	add	r3, r2
   1cb06:	2203      	movs	r2, #3
   1cb08:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* initialize advertising type */
    appSlaveCb.advType[i] = DM_ADV_CONN_UNDIRECT;
   1cb0c:	79fb      	ldrb	r3, [r7, #7]
   1cb0e:	4a1a      	ldr	r2, [pc, #104]	; (1cb78 <AppSlaveInit+0x84>)
   1cb10:	4413      	add	r3, r2
   1cb12:	2200      	movs	r2, #0
   1cb14:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* initialize advertising type changed flag */
    appSlaveCb.advTypeChanged[i] = FALSE;
   1cb18:	79fb      	ldrb	r3, [r7, #7]
   1cb1a:	4a17      	ldr	r2, [pc, #92]	; (1cb78 <AppSlaveInit+0x84>)
   1cb1c:	4413      	add	r3, r2
   1cb1e:	2200      	movs	r2, #0
   1cb20:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

    /* initialize peer address */
    appSlaveCb.peerAddrType[i] = HCI_ADDR_TYPE_PUBLIC;
   1cb24:	79fb      	ldrb	r3, [r7, #7]
   1cb26:	4a14      	ldr	r2, [pc, #80]	; (1cb78 <AppSlaveInit+0x84>)
   1cb28:	4413      	add	r3, r2
   1cb2a:	2200      	movs	r2, #0
   1cb2c:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
    memset(appSlaveCb.peerAddr[i], 0, BDA_ADDR_LEN);
   1cb30:	79fa      	ldrb	r2, [r7, #7]
   1cb32:	4613      	mov	r3, r2
   1cb34:	005b      	lsls	r3, r3, #1
   1cb36:	4413      	add	r3, r2
   1cb38:	005b      	lsls	r3, r3, #1
   1cb3a:	3330      	adds	r3, #48	; 0x30
   1cb3c:	4a0e      	ldr	r2, [pc, #56]	; (1cb78 <AppSlaveInit+0x84>)
   1cb3e:	4413      	add	r3, r2
   1cb40:	2206      	movs	r2, #6
   1cb42:	2100      	movs	r1, #0
   1cb44:	4618      	mov	r0, r3
   1cb46:	f013 fad3 	bl	300f0 <memset>
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1cb4a:	79fb      	ldrb	r3, [r7, #7]
   1cb4c:	3301      	adds	r3, #1
   1cb4e:	71fb      	strb	r3, [r7, #7]
   1cb50:	79fb      	ldrb	r3, [r7, #7]
   1cb52:	2b00      	cmp	r3, #0
   1cb54:	d0d4      	beq.n	1cb00 <AppSlaveInit+0xc>
  }

  /* initialize discovery mode */
  appSlaveCb.discMode = APP_MODE_NONE;
   1cb56:	4b08      	ldr	r3, [pc, #32]	; (1cb78 <AppSlaveInit+0x84>)
   1cb58:	22ff      	movs	r2, #255	; 0xff
   1cb5a:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

  /* initialize advertising mode */
  appSlaveAdvModeInit();
   1cb5e:	f7ff f9a1 	bl	1bea4 <appSlaveAdvModeInit>

  /* initialize address resolution */
  appSlaveCb.inProgress = FALSE;
   1cb62:	4b05      	ldr	r3, [pc, #20]	; (1cb78 <AppSlaveInit+0x84>)
   1cb64:	2200      	movs	r2, #0
   1cb66:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* set up callback from main */
  appCb.slaveCback = appSlaveProcMsg;
   1cb6a:	4b04      	ldr	r3, [pc, #16]	; (1cb7c <AppSlaveInit+0x88>)
   1cb6c:	4a04      	ldr	r2, [pc, #16]	; (1cb80 <AppSlaveInit+0x8c>)
   1cb6e:	601a      	str	r2, [r3, #0]
}
   1cb70:	bf00      	nop
   1cb72:	3708      	adds	r7, #8
   1cb74:	46bd      	mov	sp, r7
   1cb76:	bd80      	pop	{r7, pc}
   1cb78:	10011000 	.word	0x10011000
   1cb7c:	10010ea0 	.word	0x10010ea0
   1cb80:	0001caa9 	.word	0x0001caa9

0001cb84 <AppSlaveProcDmMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppSlaveProcDmMsg(dmEvt_t *pMsg)
{
   1cb84:	b580      	push	{r7, lr}
   1cb86:	b086      	sub	sp, #24
   1cb88:	af00      	add	r7, sp, #0
   1cb8a:	6078      	str	r0, [r7, #4]
  appConnCb_t *pCb = NULL;
   1cb8c:	2300      	movs	r3, #0
   1cb8e:	617b      	str	r3, [r7, #20]

  /* look up app connection control block from DM connection ID */
  if ((pMsg->hdr.event != DM_ADV_STOP_IND) &&
   1cb90:	687b      	ldr	r3, [r7, #4]
   1cb92:	789b      	ldrb	r3, [r3, #2]
   1cb94:	2b22      	cmp	r3, #34	; 0x22
   1cb96:	d00d      	beq.n	1cbb4 <AppSlaveProcDmMsg+0x30>
      (pMsg->hdr.event != DM_ADV_SET_STOP_IND))
   1cb98:	687b      	ldr	r3, [r7, #4]
   1cb9a:	789b      	ldrb	r3, [r3, #2]
  if ((pMsg->hdr.event != DM_ADV_STOP_IND) &&
   1cb9c:	2b48      	cmp	r3, #72	; 0x48
   1cb9e:	d009      	beq.n	1cbb4 <AppSlaveProcDmMsg+0x30>
  {
    pCb = &appConnCb[pMsg->hdr.param - 1];
   1cba0:	687b      	ldr	r3, [r7, #4]
   1cba2:	881b      	ldrh	r3, [r3, #0]
   1cba4:	1e5a      	subs	r2, r3, #1
   1cba6:	4613      	mov	r3, r2
   1cba8:	005b      	lsls	r3, r3, #1
   1cbaa:	4413      	add	r3, r2
   1cbac:	011b      	lsls	r3, r3, #4
   1cbae:	4a84      	ldr	r2, [pc, #528]	; (1cdc0 <AppSlaveProcDmMsg+0x23c>)
   1cbb0:	4413      	add	r3, r2
   1cbb2:	617b      	str	r3, [r7, #20]
  }

  switch (pMsg->hdr.event)
   1cbb4:	687b      	ldr	r3, [r7, #4]
   1cbb6:	789b      	ldrb	r3, [r3, #2]
   1cbb8:	3b20      	subs	r3, #32
   1cbba:	2b46      	cmp	r3, #70	; 0x46
   1cbbc:	f200 80f8 	bhi.w	1cdb0 <AppSlaveProcDmMsg+0x22c>
   1cbc0:	a201      	add	r2, pc, #4	; (adr r2, 1cbc8 <AppSlaveProcDmMsg+0x44>)
   1cbc2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1cbc6:	bf00      	nop
   1cbc8:	0001cce5 	.word	0x0001cce5
   1cbcc:	0001cdb1 	.word	0x0001cdb1
   1cbd0:	0001cceb 	.word	0x0001cceb
   1cbd4:	0001cdb1 	.word	0x0001cdb1
   1cbd8:	0001cdb1 	.word	0x0001cdb1
   1cbdc:	0001cdb1 	.word	0x0001cdb1
   1cbe0:	0001cdb1 	.word	0x0001cdb1
   1cbe4:	0001ccfd 	.word	0x0001ccfd
   1cbe8:	0001cd07 	.word	0x0001cd07
   1cbec:	0001cd11 	.word	0x0001cd11
   1cbf0:	0001cdb1 	.word	0x0001cdb1
   1cbf4:	0001cdb1 	.word	0x0001cdb1
   1cbf8:	0001cdb1 	.word	0x0001cdb1
   1cbfc:	0001cdb1 	.word	0x0001cdb1
   1cc00:	0001cdb1 	.word	0x0001cdb1
   1cc04:	0001cdb1 	.word	0x0001cdb1
   1cc08:	0001cdb1 	.word	0x0001cdb1
   1cc0c:	0001cdb1 	.word	0x0001cdb1
   1cc10:	0001cdb1 	.word	0x0001cdb1
   1cc14:	0001cdb1 	.word	0x0001cdb1
   1cc18:	0001cdb1 	.word	0x0001cdb1
   1cc1c:	0001cdb1 	.word	0x0001cdb1
   1cc20:	0001cdb1 	.word	0x0001cdb1
   1cc24:	0001cd1b 	.word	0x0001cd1b
   1cc28:	0001cdb1 	.word	0x0001cdb1
   1cc2c:	0001cdb1 	.word	0x0001cdb1
   1cc30:	0001cdb1 	.word	0x0001cdb1
   1cc34:	0001cdb1 	.word	0x0001cdb1
   1cc38:	0001cdb1 	.word	0x0001cdb1
   1cc3c:	0001cdb1 	.word	0x0001cdb1
   1cc40:	0001cdb1 	.word	0x0001cdb1
   1cc44:	0001cdb1 	.word	0x0001cdb1
   1cc48:	0001cd25 	.word	0x0001cd25
   1cc4c:	0001cd8d 	.word	0x0001cd8d
   1cc50:	0001cdb1 	.word	0x0001cdb1
   1cc54:	0001cdb1 	.word	0x0001cdb1
   1cc58:	0001cdb1 	.word	0x0001cdb1
   1cc5c:	0001cdb1 	.word	0x0001cdb1
   1cc60:	0001cdb1 	.word	0x0001cdb1
   1cc64:	0001cdb1 	.word	0x0001cdb1
   1cc68:	0001cceb 	.word	0x0001cceb
   1cc6c:	0001cdb1 	.word	0x0001cdb1
   1cc70:	0001cdb1 	.word	0x0001cdb1
   1cc74:	0001cdb1 	.word	0x0001cdb1
   1cc78:	0001cdb1 	.word	0x0001cdb1
   1cc7c:	0001cdb1 	.word	0x0001cdb1
   1cc80:	0001cdb1 	.word	0x0001cdb1
   1cc84:	0001cdb1 	.word	0x0001cdb1
   1cc88:	0001cdb1 	.word	0x0001cdb1
   1cc8c:	0001cdb1 	.word	0x0001cdb1
   1cc90:	0001cdb1 	.word	0x0001cdb1
   1cc94:	0001cdb1 	.word	0x0001cdb1
   1cc98:	0001cdb1 	.word	0x0001cdb1
   1cc9c:	0001cdb1 	.word	0x0001cdb1
   1cca0:	0001cdb1 	.word	0x0001cdb1
   1cca4:	0001cd2f 	.word	0x0001cd2f
   1cca8:	0001cdb1 	.word	0x0001cdb1
   1ccac:	0001cdb1 	.word	0x0001cdb1
   1ccb0:	0001cdb1 	.word	0x0001cdb1
   1ccb4:	0001cdb1 	.word	0x0001cdb1
   1ccb8:	0001cdb1 	.word	0x0001cdb1
   1ccbc:	0001cdb1 	.word	0x0001cdb1
   1ccc0:	0001cdb1 	.word	0x0001cdb1
   1ccc4:	0001cdb1 	.word	0x0001cdb1
   1ccc8:	0001cdb1 	.word	0x0001cdb1
   1cccc:	0001cdb1 	.word	0x0001cdb1
   1ccd0:	0001cdb1 	.word	0x0001cdb1
   1ccd4:	0001cdb1 	.word	0x0001cdb1
   1ccd8:	0001cdb1 	.word	0x0001cdb1
   1ccdc:	0001cdb1 	.word	0x0001cdb1
   1cce0:	0001cda5 	.word	0x0001cda5
  {
    case DM_RESET_CMPL_IND:
      appSlaveAdvModeInit();
   1cce4:	f7ff f8de 	bl	1bea4 <appSlaveAdvModeInit>
      break;
   1cce8:	e065      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_ADV_SET_STOP_IND:
    case DM_ADV_STOP_IND:
      if (appSlaveCb.advStopCback != NULL)
   1ccea:	4b36      	ldr	r3, [pc, #216]	; (1cdc4 <AppSlaveProcDmMsg+0x240>)
   1ccec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1ccee:	2b00      	cmp	r3, #0
   1ccf0:	d060      	beq.n	1cdb4 <AppSlaveProcDmMsg+0x230>
      {
        (*appSlaveCb.advStopCback)(pMsg);
   1ccf2:	4b34      	ldr	r3, [pc, #208]	; (1cdc4 <AppSlaveProcDmMsg+0x240>)
   1ccf4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1ccf6:	6878      	ldr	r0, [r7, #4]
   1ccf8:	4798      	blx	r3
      }
      break;
   1ccfa:	e05b      	b.n	1cdb4 <AppSlaveProcDmMsg+0x230>

    case DM_CONN_OPEN_IND:
      appSlaveConnOpen(pMsg, pCb);
   1ccfc:	6979      	ldr	r1, [r7, #20]
   1ccfe:	6878      	ldr	r0, [r7, #4]
   1cd00:	f7ff fb40 	bl	1c384 <appSlaveConnOpen>
      break;
   1cd04:	e057      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_CONN_CLOSE_IND:
      appSlaveConnClose(pMsg, pCb);
   1cd06:	6979      	ldr	r1, [r7, #20]
   1cd08:	6878      	ldr	r0, [r7, #4]
   1cd0a:	f7ff fb59 	bl	1c3c0 <appSlaveConnClose>
      break;
   1cd0e:	e052      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_CONN_UPDATE_IND:
      appSlaveConnUpdate(pMsg, pCb);
   1cd10:	6979      	ldr	r1, [r7, #20]
   1cd12:	6878      	ldr	r0, [r7, #4]
   1cd14:	f7ff fbde 	bl	1c4d4 <appSlaveConnUpdate>
      break;
   1cd18:	e04d      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_PRIV_RESOLVED_ADDR_IND:
      appSlaveResolvedAddrInd(pMsg, pCb);
   1cd1a:	6979      	ldr	r1, [r7, #20]
   1cd1c:	6878      	ldr	r0, [r7, #4]
   1cd1e:	f7ff fc15 	bl	1c54c <appSlaveResolvedAddrInd>
      break;
   1cd22:	e048      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_REM_CONN_PARAM_REQ_IND:
      appSlaveRemoteConnParamReq(pMsg, pCb);
   1cd24:	6979      	ldr	r1, [r7, #20]
   1cd26:	6878      	ldr	r0, [r7, #4]
   1cd28:	f7ff fc66 	bl	1c5f8 <appSlaveRemoteConnParamReq>
      break;
   1cd2c:	e043      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_REMOTE_FEATURES_IND:
    {
        hciEvt_t *pEvent = (hciEvt_t *)pMsg;
   1cd2e:	687b      	ldr	r3, [r7, #4]
   1cd30:	613b      	str	r3, [r7, #16]
        uint8_t data_len_ext = pEvent->leReadRemoteFeatCmpl.features[0]&HCI_LE_SUP_FEAT_DATA_LEN_EXT;
   1cd32:	693b      	ldr	r3, [r7, #16]
   1cd34:	7a1b      	ldrb	r3, [r3, #8]
   1cd36:	f003 0320 	and.w	r3, r3, #32
   1cd3a:	73fb      	strb	r3, [r7, #15]
        APP_TRACE_INFO2("remote feature: 0x%x,  DLE:0x%x", pEvent->leReadRemoteFeatCmpl.features[0],data_len_ext);
   1cd3c:	693b      	ldr	r3, [r7, #16]
   1cd3e:	7a1b      	ldrb	r3, [r3, #8]
   1cd40:	4619      	mov	r1, r3
   1cd42:	7bfb      	ldrb	r3, [r7, #15]
   1cd44:	461a      	mov	r2, r3
   1cd46:	4820      	ldr	r0, [pc, #128]	; (1cdc8 <AppSlaveProcDmMsg+0x244>)
   1cd48:	f010 fe22 	bl	2d990 <WsfTrace>
		if(data_len_ext == HCI_LE_SUP_FEAT_DATA_LEN_EXT)
   1cd4c:	7bfb      	ldrb	r3, [r7, #15]
   1cd4e:	2b20      	cmp	r3, #32
   1cd50:	d10c      	bne.n	1cd6c <AppSlaveProcDmMsg+0x1e8>
		{
		    APP_TRACE_INFO0("Remote device support DLE");
   1cd52:	481e      	ldr	r0, [pc, #120]	; (1cdcc <AppSlaveProcDmMsg+0x248>)
   1cd54:	f010 fe1c 	bl	2d990 <WsfTrace>
			DmConnSetDataLen(pMsg->hdr.param, LE_MAX_TX_SIZE, LE_MAX_TX_TIME);
   1cd58:	687b      	ldr	r3, [r7, #4]
   1cd5a:	881b      	ldrh	r3, [r3, #0]
   1cd5c:	b2db      	uxtb	r3, r3
   1cd5e:	f640 0248 	movw	r2, #2120	; 0x848
   1cd62:	21fb      	movs	r1, #251	; 0xfb
   1cd64:	4618      	mov	r0, r3
   1cd66:	f006 fb5d 	bl	23424 <DmConnSetDataLen>
   1cd6a:	e002      	b.n	1cd72 <AppSlaveProcDmMsg+0x1ee>
		}
		else
		{
		   APP_TRACE_INFO0("Remote device doesn't support DLE"); 
   1cd6c:	4818      	ldr	r0, [pc, #96]	; (1cdd0 <AppSlaveProcDmMsg+0x24c>)
   1cd6e:	f010 fe0f 	bl	2d990 <WsfTrace>
		}	  
  	  /* If conn update is waiting for features, perform the conn update timeout action */
	  if (pCb->updateState == APP_CU_STATE_WAIT_FEATURES)
   1cd72:	697b      	ldr	r3, [r7, #20]
   1cd74:	7b5b      	ldrb	r3, [r3, #13]
   1cd76:	2b01      	cmp	r3, #1
   1cd78:	d104      	bne.n	1cd84 <AppSlaveProcDmMsg+0x200>
	  {
	    appSlaveConnUpdateTimeout((wsfMsgHdr_t*) pMsg, pCb);
   1cd7a:	6979      	ldr	r1, [r7, #20]
   1cd7c:	6878      	ldr	r0, [r7, #4]
   1cd7e:	f7ff fe45 	bl	1ca0c <appSlaveConnUpdateTimeout>
	  else
      {
        pCb->updateState = APP_CU_STATE_UPDATING;
      }
    }
    break;
   1cd82:	e018      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>
        pCb->updateState = APP_CU_STATE_UPDATING;
   1cd84:	697b      	ldr	r3, [r7, #20]
   1cd86:	2202      	movs	r2, #2
   1cd88:	735a      	strb	r2, [r3, #13]
    break;
   1cd8a:	e014      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>
      
    case DM_CONN_DATA_LEN_CHANGE_IND:
      APP_TRACE_INFO3("data length exchange, status= %d, maxRXLen= %d, maxTXlen= %d", pMsg->dataLenChange.hdr.status, pMsg->dataLenChange.maxRxOctets, pMsg->dataLenChange.maxTxOctets);
   1cd8c:	687b      	ldr	r3, [r7, #4]
   1cd8e:	78db      	ldrb	r3, [r3, #3]
   1cd90:	4619      	mov	r1, r3
   1cd92:	687b      	ldr	r3, [r7, #4]
   1cd94:	895b      	ldrh	r3, [r3, #10]
   1cd96:	461a      	mov	r2, r3
   1cd98:	687b      	ldr	r3, [r7, #4]
   1cd9a:	88db      	ldrh	r3, [r3, #6]
   1cd9c:	480d      	ldr	r0, [pc, #52]	; (1cdd4 <AppSlaveProcDmMsg+0x250>)
   1cd9e:	f010 fdf7 	bl	2d990 <WsfTrace>
	  break;
   1cda2:	e008      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>

    case DM_HW_ERROR_IND:
      HciDrvRadioBoot(0);
   1cda4:	2000      	movs	r0, #0
   1cda6:	f009 fddf 	bl	26968 <HciDrvRadioBoot>
      DmDevReset();
   1cdaa:	f006 ff87 	bl	23cbc <DmDevReset>
	  break;
   1cdae:	e002      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>
      
    default:
      break;
   1cdb0:	bf00      	nop
   1cdb2:	e000      	b.n	1cdb6 <AppSlaveProcDmMsg+0x232>
      break;
   1cdb4:	bf00      	nop
  }
}
   1cdb6:	bf00      	nop
   1cdb8:	3718      	adds	r7, #24
   1cdba:	46bd      	mov	sp, r7
   1cdbc:	bd80      	pop	{r7, pc}
   1cdbe:	bf00      	nop
   1cdc0:	10010ed0 	.word	0x10010ed0
   1cdc4:	10011000 	.word	0x10011000
   1cdc8:	00044724 	.word	0x00044724
   1cdcc:	00044744 	.word	0x00044744
   1cdd0:	00044760 	.word	0x00044760
   1cdd4:	00044784 	.word	0x00044784

0001cdd8 <appAdvSetData>:
 *  \return None.
 */
/*************************************************************************************************/
void appAdvSetData(uint8_t advHandle, uint8_t location, uint16_t len, uint8_t *pData, uint16_t bufLen,
                   uint16_t maxLen)
{
   1cdd8:	b580      	push	{r7, lr}
   1cdda:	b082      	sub	sp, #8
   1cddc:	af00      	add	r7, sp, #0
   1cdde:	603b      	str	r3, [r7, #0]
   1cde0:	4603      	mov	r3, r0
   1cde2:	71fb      	strb	r3, [r7, #7]
   1cde4:	460b      	mov	r3, r1
   1cde6:	71bb      	strb	r3, [r7, #6]
   1cde8:	4613      	mov	r3, r2
   1cdea:	80bb      	strh	r3, [r7, #4]
  /* store data for location */
  appSlaveCb.pAdvData[advHandle][location] = pData;
   1cdec:	79fa      	ldrb	r2, [r7, #7]
   1cdee:	79bb      	ldrb	r3, [r7, #6]
   1cdf0:	4927      	ldr	r1, [pc, #156]	; (1ce90 <appAdvSetData+0xb8>)
   1cdf2:	0092      	lsls	r2, r2, #2
   1cdf4:	4413      	add	r3, r2
   1cdf6:	683a      	ldr	r2, [r7, #0]
   1cdf8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  appSlaveCb.advDataLen[advHandle][location] = len;
   1cdfc:	79fa      	ldrb	r2, [r7, #7]
   1cdfe:	79bb      	ldrb	r3, [r7, #6]
   1ce00:	4923      	ldr	r1, [pc, #140]	; (1ce90 <appAdvSetData+0xb8>)
   1ce02:	0092      	lsls	r2, r2, #2
   1ce04:	4413      	add	r3, r2
   1ce06:	3308      	adds	r3, #8
   1ce08:	88ba      	ldrh	r2, [r7, #4]
   1ce0a:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]

  /* set length of advertising data buffer maintained by Application */
  appSlaveCb.advDataBufLen[advHandle][location] = bufLen;
   1ce0e:	79fa      	ldrb	r2, [r7, #7]
   1ce10:	79bb      	ldrb	r3, [r7, #6]
   1ce12:	491f      	ldr	r1, [pc, #124]	; (1ce90 <appAdvSetData+0xb8>)
   1ce14:	0092      	lsls	r2, r2, #2
   1ce16:	4413      	add	r3, r2
   1ce18:	330c      	adds	r3, #12
   1ce1a:	8a3a      	ldrh	r2, [r7, #16]
   1ce1c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]

  /* set maximum advertising data length supported by Controller */
  appSlaveCb.maxAdvDataLen[advHandle] = maxLen;
   1ce20:	79fb      	ldrb	r3, [r7, #7]
   1ce22:	491b      	ldr	r1, [pc, #108]	; (1ce90 <appAdvSetData+0xb8>)
   1ce24:	3314      	adds	r3, #20
   1ce26:	8aba      	ldrh	r2, [r7, #20]
   1ce28:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]

  /* reset data offset */
  appSlaveCb.advDataOffset[advHandle][location] = 0;
   1ce2c:	79fa      	ldrb	r2, [r7, #7]
   1ce2e:	79bb      	ldrb	r3, [r7, #6]
   1ce30:	4917      	ldr	r1, [pc, #92]	; (1ce90 <appAdvSetData+0xb8>)
   1ce32:	0092      	lsls	r2, r2, #2
   1ce34:	4413      	add	r3, r2
   1ce36:	3310      	adds	r3, #16
   1ce38:	2200      	movs	r2, #0
   1ce3a:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]

  /* Set the data now if we are in the right mode and the data is complete (no fragmentation's required) */
  if ((appSlaveCb.advState[advHandle] != APP_ADV_STOPPED) &&
   1ce3e:	79fb      	ldrb	r3, [r7, #7]
   1ce40:	4a13      	ldr	r2, [pc, #76]	; (1ce90 <appAdvSetData+0xb8>)
   1ce42:	4413      	add	r3, r2
   1ce44:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1ce48:	2b03      	cmp	r3, #3
   1ce4a:	d015      	beq.n	1ce78 <appAdvSetData+0xa0>
      (APP_LOC_2_MODE(location) == appSlaveCb.discMode)   &&
   1ce4c:	79bb      	ldrb	r3, [r7, #6]
   1ce4e:	085b      	lsrs	r3, r3, #1
   1ce50:	b2da      	uxtb	r2, r3
   1ce52:	4b0f      	ldr	r3, [pc, #60]	; (1ce90 <appAdvSetData+0xb8>)
   1ce54:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  if ((appSlaveCb.advState[advHandle] != APP_ADV_STOPPED) &&
   1ce58:	429a      	cmp	r2, r3
   1ce5a:	d10d      	bne.n	1ce78 <appAdvSetData+0xa0>
      (APP_LOC_2_MODE(location) == appSlaveCb.discMode)   &&
   1ce5c:	88bb      	ldrh	r3, [r7, #4]
   1ce5e:	2bfb      	cmp	r3, #251	; 0xfb
   1ce60:	d80a      	bhi.n	1ce78 <appAdvSetData+0xa0>
      (len <= HCI_EXT_ADV_DATA_LEN)                       &&
   1ce62:	88ba      	ldrh	r2, [r7, #4]
   1ce64:	8abb      	ldrh	r3, [r7, #20]
   1ce66:	429a      	cmp	r2, r3
   1ce68:	d806      	bhi.n	1ce78 <appAdvSetData+0xa0>
      (len <= maxLen))
  {
    appSetAdvScanDataFrag(advHandle, location);
   1ce6a:	79ba      	ldrb	r2, [r7, #6]
   1ce6c:	79fb      	ldrb	r3, [r7, #7]
   1ce6e:	4611      	mov	r1, r2
   1ce70:	4618      	mov	r0, r3
   1ce72:	f7ff f8e5 	bl	1c040 <appSetAdvScanDataFrag>
   1ce76:	e006      	b.n	1ce86 <appAdvSetData+0xae>
  }
  /* Otherwise set it when advertising is started or mode changes */
  else
  {
    appSlaveCb.advDataSynced[advHandle] = FALSE;
   1ce78:	79fb      	ldrb	r3, [r7, #7]
   1ce7a:	4a05      	ldr	r2, [pc, #20]	; (1ce90 <appAdvSetData+0xb8>)
   1ce7c:	4413      	add	r3, r2
   1ce7e:	2200      	movs	r2, #0
   1ce80:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
  }
}
   1ce84:	bf00      	nop
   1ce86:	bf00      	nop
   1ce88:	3708      	adds	r7, #8
   1ce8a:	46bd      	mov	sp, r7
   1ce8c:	bd80      	pop	{r7, pc}
   1ce8e:	bf00      	nop
   1ce90:	10011000 	.word	0x10011000

0001ce94 <appAdvStart>:
 *  \return None.
 */
/*************************************************************************************************/
void appAdvStart(uint8_t numSets, uint8_t *pAdvHandles, uint16_t *pInterval, uint16_t *pDuration,
                 uint8_t *pMaxEaEvents, bool_t cfgAdvParam)
{
   1ce94:	b590      	push	{r4, r7, lr}
   1ce96:	b087      	sub	sp, #28
   1ce98:	af00      	add	r7, sp, #0
   1ce9a:	60b9      	str	r1, [r7, #8]
   1ce9c:	607a      	str	r2, [r7, #4]
   1ce9e:	603b      	str	r3, [r7, #0]
   1cea0:	4603      	mov	r3, r0
   1cea2:	73fb      	strb	r3, [r7, #15]
  uint8_t i;

  /* start advertising if not connectable advertising or multiple connections supported */
  if (!appSlaveConnectableAdv(numSets, pAdvHandles) ||
   1cea4:	7bfb      	ldrb	r3, [r7, #15]
   1cea6:	68b9      	ldr	r1, [r7, #8]
   1cea8:	4618      	mov	r0, r3
   1ceaa:	f7ff f80b 	bl	1bec4 <appSlaveConnectableAdv>
   1ceae:	4603      	mov	r3, r0
   1ceb0:	2b00      	cmp	r3, #0
   1ceb2:	d009      	beq.n	1cec8 <appAdvStart+0x34>
      (appNumConns(DM_ROLE_SLAVE) < pAppSlaveCfg->connMax))
   1ceb4:	2001      	movs	r0, #1
   1ceb6:	f7fe f92b 	bl	1b110 <appNumConns>
   1ceba:	4603      	mov	r3, r0
   1cebc:	461a      	mov	r2, r3
   1cebe:	4b3e      	ldr	r3, [pc, #248]	; (1cfb8 <appAdvStart+0x124>)
   1cec0:	681b      	ldr	r3, [r3, #0]
   1cec2:	781b      	ldrb	r3, [r3, #0]
  if (!appSlaveConnectableAdv(numSets, pAdvHandles) ||
   1cec4:	429a      	cmp	r2, r3
   1cec6:	d260      	bcs.n	1cf8a <appAdvStart+0xf6>
  {
    /* for each advertising set */
    for (i = 0; i < numSets; i++)
   1cec8:	2300      	movs	r3, #0
   1ceca:	75fb      	strb	r3, [r7, #23]
   1cecc:	e052      	b.n	1cf74 <appAdvStart+0xe0>
    {
      /* if advertising parameters to be configured */
      if (cfgAdvParam)
   1cece:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   1ced2:	2b00      	cmp	r3, #0
   1ced4:	d035      	beq.n	1cf42 <appAdvStart+0xae>
      {
        /* set min and max interval */
        DmAdvSetInterval(pAdvHandles[i], pInterval[i], pInterval[i]);
   1ced6:	7dfb      	ldrb	r3, [r7, #23]
   1ced8:	68ba      	ldr	r2, [r7, #8]
   1ceda:	4413      	add	r3, r2
   1cedc:	7818      	ldrb	r0, [r3, #0]
   1cede:	7dfb      	ldrb	r3, [r7, #23]
   1cee0:	005b      	lsls	r3, r3, #1
   1cee2:	687a      	ldr	r2, [r7, #4]
   1cee4:	4413      	add	r3, r2
   1cee6:	8819      	ldrh	r1, [r3, #0]
   1cee8:	7dfb      	ldrb	r3, [r7, #23]
   1ceea:	005b      	lsls	r3, r3, #1
   1ceec:	687a      	ldr	r2, [r7, #4]
   1ceee:	4413      	add	r3, r2
   1cef0:	881b      	ldrh	r3, [r3, #0]
   1cef2:	461a      	mov	r2, r3
   1cef4:	f005 f816 	bl	21f24 <DmAdvSetInterval>

        /* set advertising parameters */
        DmAdvConfig(pAdvHandles[i], appSlaveCb.advType[pAdvHandles[i]],
   1cef8:	7dfb      	ldrb	r3, [r7, #23]
   1cefa:	68ba      	ldr	r2, [r7, #8]
   1cefc:	4413      	add	r3, r2
   1cefe:	7818      	ldrb	r0, [r3, #0]
   1cf00:	7dfb      	ldrb	r3, [r7, #23]
   1cf02:	68ba      	ldr	r2, [r7, #8]
   1cf04:	4413      	add	r3, r2
   1cf06:	781b      	ldrb	r3, [r3, #0]
   1cf08:	461a      	mov	r2, r3
   1cf0a:	4b2c      	ldr	r3, [pc, #176]	; (1cfbc <appAdvStart+0x128>)
   1cf0c:	4413      	add	r3, r2
   1cf0e:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
                    appSlaveCb.peerAddrType[pAdvHandles[i]], appSlaveCb.peerAddr[pAdvHandles[i]]);
   1cf12:	7dfb      	ldrb	r3, [r7, #23]
   1cf14:	68ba      	ldr	r2, [r7, #8]
   1cf16:	4413      	add	r3, r2
   1cf18:	781b      	ldrb	r3, [r3, #0]
   1cf1a:	461a      	mov	r2, r3
        DmAdvConfig(pAdvHandles[i], appSlaveCb.advType[pAdvHandles[i]],
   1cf1c:	4b27      	ldr	r3, [pc, #156]	; (1cfbc <appAdvStart+0x128>)
   1cf1e:	4413      	add	r3, r2
   1cf20:	f893 4036 	ldrb.w	r4, [r3, #54]	; 0x36
                    appSlaveCb.peerAddrType[pAdvHandles[i]], appSlaveCb.peerAddr[pAdvHandles[i]]);
   1cf24:	7dfb      	ldrb	r3, [r7, #23]
   1cf26:	68ba      	ldr	r2, [r7, #8]
   1cf28:	4413      	add	r3, r2
   1cf2a:	781b      	ldrb	r3, [r3, #0]
   1cf2c:	461a      	mov	r2, r3
   1cf2e:	4613      	mov	r3, r2
   1cf30:	005b      	lsls	r3, r3, #1
   1cf32:	4413      	add	r3, r2
   1cf34:	005b      	lsls	r3, r3, #1
   1cf36:	3330      	adds	r3, #48	; 0x30
   1cf38:	4a20      	ldr	r2, [pc, #128]	; (1cfbc <appAdvStart+0x128>)
   1cf3a:	4413      	add	r3, r2
        DmAdvConfig(pAdvHandles[i], appSlaveCb.advType[pAdvHandles[i]],
   1cf3c:	4622      	mov	r2, r4
   1cf3e:	f004 ff0b 	bl	21d58 <DmAdvConfig>
      }

      /* if adv data to be synced */
      if (!appSlaveCb.advDataSynced[pAdvHandles[i]])
   1cf42:	7dfb      	ldrb	r3, [r7, #23]
   1cf44:	68ba      	ldr	r2, [r7, #8]
   1cf46:	4413      	add	r3, r2
   1cf48:	781b      	ldrb	r3, [r3, #0]
   1cf4a:	461a      	mov	r2, r3
   1cf4c:	4b1b      	ldr	r3, [pc, #108]	; (1cfbc <appAdvStart+0x128>)
   1cf4e:	4413      	add	r3, r2
   1cf50:	f893 302b 	ldrb.w	r3, [r3, #43]	; 0x2b
   1cf54:	2b00      	cmp	r3, #0
   1cf56:	d10a      	bne.n	1cf6e <appAdvStart+0xda>
      {
        /* set advertising or scan response data */
        appSetAdvScanData(pAdvHandles[i], appSlaveCb.discMode);
   1cf58:	7dfb      	ldrb	r3, [r7, #23]
   1cf5a:	68ba      	ldr	r2, [r7, #8]
   1cf5c:	4413      	add	r3, r2
   1cf5e:	781b      	ldrb	r3, [r3, #0]
   1cf60:	4a16      	ldr	r2, [pc, #88]	; (1cfbc <appAdvStart+0x128>)
   1cf62:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
   1cf66:	4611      	mov	r1, r2
   1cf68:	4618      	mov	r0, r3
   1cf6a:	f7ff f8ef 	bl	1c14c <appSetAdvScanData>
    for (i = 0; i < numSets; i++)
   1cf6e:	7dfb      	ldrb	r3, [r7, #23]
   1cf70:	3301      	adds	r3, #1
   1cf72:	75fb      	strb	r3, [r7, #23]
   1cf74:	7dfa      	ldrb	r2, [r7, #23]
   1cf76:	7bfb      	ldrb	r3, [r7, #15]
   1cf78:	429a      	cmp	r2, r3
   1cf7a:	d3a8      	bcc.n	1cece <appAdvStart+0x3a>
      }
    }

    /* start advertising */
    DmAdvStart(numSets, pAdvHandles, pDuration, pMaxEaEvents);
   1cf7c:	7bf8      	ldrb	r0, [r7, #15]
   1cf7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   1cf80:	683a      	ldr	r2, [r7, #0]
   1cf82:	68b9      	ldr	r1, [r7, #8]
   1cf84:	f004 ff54 	bl	21e30 <DmAdvStart>

    return;
   1cf88:	e013      	b.n	1cfb2 <appAdvStart+0x11e>
  }

  /* done with all advertising states */
  for (i = 0; i < numSets; i++)
   1cf8a:	2300      	movs	r3, #0
   1cf8c:	75fb      	strb	r3, [r7, #23]
   1cf8e:	e00c      	b.n	1cfaa <appAdvStart+0x116>
  {
    appSlaveCb.advState[pAdvHandles[i]] = APP_ADV_STOPPED;
   1cf90:	7dfb      	ldrb	r3, [r7, #23]
   1cf92:	68ba      	ldr	r2, [r7, #8]
   1cf94:	4413      	add	r3, r2
   1cf96:	781b      	ldrb	r3, [r3, #0]
   1cf98:	461a      	mov	r2, r3
   1cf9a:	4b08      	ldr	r3, [pc, #32]	; (1cfbc <appAdvStart+0x128>)
   1cf9c:	4413      	add	r3, r2
   1cf9e:	2203      	movs	r2, #3
   1cfa0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  for (i = 0; i < numSets; i++)
   1cfa4:	7dfb      	ldrb	r3, [r7, #23]
   1cfa6:	3301      	adds	r3, #1
   1cfa8:	75fb      	strb	r3, [r7, #23]
   1cfaa:	7dfa      	ldrb	r2, [r7, #23]
   1cfac:	7bfb      	ldrb	r3, [r7, #15]
   1cfae:	429a      	cmp	r2, r3
   1cfb0:	d3ee      	bcc.n	1cf90 <appAdvStart+0xfc>
  }
}
   1cfb2:	371c      	adds	r7, #28
   1cfb4:	46bd      	mov	sp, r7
   1cfb6:	bd90      	pop	{r4, r7, pc}
   1cfb8:	10010e9c 	.word	0x10010e9c
   1cfbc:	10011000 	.word	0x10011000

0001cfc0 <appAdvStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void appAdvStop(uint8_t numSets, uint8_t *pAdvHandles)
{
   1cfc0:	b580      	push	{r7, lr}
   1cfc2:	b084      	sub	sp, #16
   1cfc4:	af00      	add	r7, sp, #0
   1cfc6:	4603      	mov	r3, r0
   1cfc8:	6039      	str	r1, [r7, #0]
   1cfca:	71fb      	strb	r3, [r7, #7]
  uint8_t i;

  /* if number of advertising sets is 0 */
  if (numSets == 0)
   1cfcc:	79fb      	ldrb	r3, [r7, #7]
   1cfce:	2b00      	cmp	r3, #0
   1cfd0:	d10f      	bne.n	1cff2 <appAdvStop+0x32>
  {
    /* stop all advertising sets */
    for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1cfd2:	2300      	movs	r3, #0
   1cfd4:	73fb      	strb	r3, [r7, #15]
   1cfd6:	e008      	b.n	1cfea <appAdvStop+0x2a>
    {
      appSlaveCb.advState[i] = APP_ADV_STOPPED;
   1cfd8:	7bfb      	ldrb	r3, [r7, #15]
   1cfda:	4a19      	ldr	r2, [pc, #100]	; (1d040 <appAdvStop+0x80>)
   1cfdc:	4413      	add	r3, r2
   1cfde:	2203      	movs	r2, #3
   1cfe0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1cfe4:	7bfb      	ldrb	r3, [r7, #15]
   1cfe6:	3301      	adds	r3, #1
   1cfe8:	73fb      	strb	r3, [r7, #15]
   1cfea:	7bfb      	ldrb	r3, [r7, #15]
   1cfec:	2b00      	cmp	r3, #0
   1cfee:	d0f3      	beq.n	1cfd8 <appAdvStop+0x18>
   1cff0:	e013      	b.n	1d01a <appAdvStop+0x5a>
    }
  }
  else
  {
    for (i = 0; i < numSets; i++)
   1cff2:	2300      	movs	r3, #0
   1cff4:	73fb      	strb	r3, [r7, #15]
   1cff6:	e00c      	b.n	1d012 <appAdvStop+0x52>
    {
      WSF_ASSERT(pAdvHandles[i] < DM_NUM_ADV_SETS);

      /* stop advertising */
      appSlaveCb.advState[pAdvHandles[i]] = APP_ADV_STOPPED;
   1cff8:	7bfb      	ldrb	r3, [r7, #15]
   1cffa:	683a      	ldr	r2, [r7, #0]
   1cffc:	4413      	add	r3, r2
   1cffe:	781b      	ldrb	r3, [r3, #0]
   1d000:	461a      	mov	r2, r3
   1d002:	4b0f      	ldr	r3, [pc, #60]	; (1d040 <appAdvStop+0x80>)
   1d004:	4413      	add	r3, r2
   1d006:	2203      	movs	r2, #3
   1d008:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    for (i = 0; i < numSets; i++)
   1d00c:	7bfb      	ldrb	r3, [r7, #15]
   1d00e:	3301      	adds	r3, #1
   1d010:	73fb      	strb	r3, [r7, #15]
   1d012:	7bfa      	ldrb	r2, [r7, #15]
   1d014:	79fb      	ldrb	r3, [r7, #7]
   1d016:	429a      	cmp	r2, r3
   1d018:	d3ee      	bcc.n	1cff8 <appAdvStop+0x38>
    }
  }

  /* if no advertising set is active */
  if (!AppSlaveIsAdvertising())
   1d01a:	f000 f9c9 	bl	1d3b0 <AppSlaveIsAdvertising>
   1d01e:	4603      	mov	r3, r0
   1d020:	2b00      	cmp	r3, #0
   1d022:	d103      	bne.n	1d02c <appAdvStop+0x6c>
  {
    appSlaveCb.discMode = APP_MODE_NONE;
   1d024:	4b06      	ldr	r3, [pc, #24]	; (1d040 <appAdvStop+0x80>)
   1d026:	22ff      	movs	r2, #255	; 0xff
   1d028:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
  }

  DmAdvStop(numSets, pAdvHandles);
   1d02c:	79fb      	ldrb	r3, [r7, #7]
   1d02e:	6839      	ldr	r1, [r7, #0]
   1d030:	4618      	mov	r0, r3
   1d032:	f004 ff45 	bl	21ec0 <DmAdvStop>
}
   1d036:	bf00      	nop
   1d038:	3710      	adds	r7, #16
   1d03a:	46bd      	mov	sp, r7
   1d03c:	bd80      	pop	{r7, pc}
   1d03e:	bf00      	nop
   1d040:	10011000 	.word	0x10011000

0001d044 <appSlaveAdvStart>:
 *  \return None.
 */
/*************************************************************************************************/
void appSlaveAdvStart(uint8_t numSets, uint8_t *pAdvHandles, uint16_t *pInterval, uint16_t *pDuration,
                      uint8_t *pMaxEaEvents, bool_t cfgAdvParam, uint8_t mode)
{
   1d044:	b580      	push	{r7, lr}
   1d046:	b088      	sub	sp, #32
   1d048:	af02      	add	r7, sp, #8
   1d04a:	60b9      	str	r1, [r7, #8]
   1d04c:	607a      	str	r2, [r7, #4]
   1d04e:	603b      	str	r3, [r7, #0]
   1d050:	4603      	mov	r3, r0
   1d052:	73fb      	strb	r3, [r7, #15]
  uint8_t i;
  uint8_t prevMode = appSlaveCb.discMode;
   1d054:	4b25      	ldr	r3, [pc, #148]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d056:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1d05a:	75bb      	strb	r3, [r7, #22]

  /* handle auto init mode */
  if (mode == APP_MODE_AUTO_INIT)
   1d05c:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   1d060:	2b02      	cmp	r3, #2
   1d062:	d114      	bne.n	1d08e <appSlaveAdvStart+0x4a>
  {
    if (AppDbCheckBonded() == FALSE)
   1d064:	f7fd feb2 	bl	1adcc <AppDbCheckBonded>
   1d068:	4603      	mov	r3, r0
   1d06a:	2b00      	cmp	r3, #0
   1d06c:	d107      	bne.n	1d07e <appSlaveAdvStart+0x3a>
    {
      AppSetBondable(TRUE);
   1d06e:	2001      	movs	r0, #1
   1d070:	f000 f98c 	bl	1d38c <AppSetBondable>
      appSlaveCb.discMode = APP_MODE_DISCOVERABLE;
   1d074:	4b1d      	ldr	r3, [pc, #116]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d076:	2201      	movs	r2, #1
   1d078:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
   1d07c:	e00c      	b.n	1d098 <appSlaveAdvStart+0x54>
    }
    else
    {
      AppSetBondable(FALSE);
   1d07e:	2000      	movs	r0, #0
   1d080:	f000 f984 	bl	1d38c <AppSetBondable>
      appSlaveCb.discMode = APP_MODE_CONNECTABLE;
   1d084:	4b19      	ldr	r3, [pc, #100]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d086:	2200      	movs	r2, #0
   1d088:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
   1d08c:	e004      	b.n	1d098 <appSlaveAdvStart+0x54>
      /* init white list with bonded device addresses */
    }
  }
  else
  {
    appSlaveCb.discMode = mode;
   1d08e:	4a17      	ldr	r2, [pc, #92]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d090:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   1d094:	f882 302f 	strb.w	r3, [r2, #47]	; 0x2f
  }

  /* if mode changed force update of advertising data */
  if (prevMode != appSlaveCb.discMode)
   1d098:	4b14      	ldr	r3, [pc, #80]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d09a:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1d09e:	7dba      	ldrb	r2, [r7, #22]
   1d0a0:	429a      	cmp	r2, r3
   1d0a2:	d014      	beq.n	1d0ce <appSlaveAdvStart+0x8a>
  {
    for (i = 0; i < numSets; i++)
   1d0a4:	2300      	movs	r3, #0
   1d0a6:	75fb      	strb	r3, [r7, #23]
   1d0a8:	e00d      	b.n	1d0c6 <appSlaveAdvStart+0x82>
    {
      /* force update of advertising data */
      appSlaveForceAdvDataSync(pAdvHandles[i], appSlaveCb.discMode);
   1d0aa:	7dfb      	ldrb	r3, [r7, #23]
   1d0ac:	68ba      	ldr	r2, [r7, #8]
   1d0ae:	4413      	add	r3, r2
   1d0b0:	781b      	ldrb	r3, [r3, #0]
   1d0b2:	4a0e      	ldr	r2, [pc, #56]	; (1d0ec <appSlaveAdvStart+0xa8>)
   1d0b4:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
   1d0b8:	4611      	mov	r1, r2
   1d0ba:	4618      	mov	r0, r3
   1d0bc:	f7fe ff90 	bl	1bfe0 <appSlaveForceAdvDataSync>
    for (i = 0; i < numSets; i++)
   1d0c0:	7dfb      	ldrb	r3, [r7, #23]
   1d0c2:	3301      	adds	r3, #1
   1d0c4:	75fb      	strb	r3, [r7, #23]
   1d0c6:	7dfa      	ldrb	r2, [r7, #23]
   1d0c8:	7bfb      	ldrb	r3, [r7, #15]
   1d0ca:	429a      	cmp	r2, r3
   1d0cc:	d3ed      	bcc.n	1d0aa <appSlaveAdvStart+0x66>
    }
  }

  /* start advertising */
  appAdvStart(numSets, pAdvHandles, pInterval, pDuration, pMaxEaEvents, TRUE);
   1d0ce:	7bf8      	ldrb	r0, [r7, #15]
   1d0d0:	2301      	movs	r3, #1
   1d0d2:	9301      	str	r3, [sp, #4]
   1d0d4:	6a3b      	ldr	r3, [r7, #32]
   1d0d6:	9300      	str	r3, [sp, #0]
   1d0d8:	683b      	ldr	r3, [r7, #0]
   1d0da:	687a      	ldr	r2, [r7, #4]
   1d0dc:	68b9      	ldr	r1, [r7, #8]
   1d0de:	f7ff fed9 	bl	1ce94 <appAdvStart>
}
   1d0e2:	bf00      	nop
   1d0e4:	3718      	adds	r7, #24
   1d0e6:	46bd      	mov	sp, r7
   1d0e8:	bd80      	pop	{r7, pc}
   1d0ea:	bf00      	nop
   1d0ec:	10011000 	.word	0x10011000

0001d0f0 <appAdvSetAdValue>:
 *  \return TRUE if the element was successfully added to the data, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t appAdvSetAdValue(uint8_t advHandle, uint8_t location, uint8_t adType, uint8_t len,
                        uint8_t *pValue)
{
   1d0f0:	b590      	push	{r4, r7, lr}
   1d0f2:	b089      	sub	sp, #36	; 0x24
   1d0f4:	af02      	add	r7, sp, #8
   1d0f6:	4604      	mov	r4, r0
   1d0f8:	4608      	mov	r0, r1
   1d0fa:	4611      	mov	r1, r2
   1d0fc:	461a      	mov	r2, r3
   1d0fe:	4623      	mov	r3, r4
   1d100:	71fb      	strb	r3, [r7, #7]
   1d102:	4603      	mov	r3, r0
   1d104:	71bb      	strb	r3, [r7, #6]
   1d106:	460b      	mov	r3, r1
   1d108:	717b      	strb	r3, [r7, #5]
   1d10a:	4613      	mov	r3, r2
   1d10c:	713b      	strb	r3, [r7, #4]
  bool_t  valueSet;

  WSF_ASSERT(location < APP_NUM_DATA_LOCATIONS);

  /* get pointer and length for location */
  pAdvData = appSlaveCb.pAdvData[advHandle][location];
   1d10e:	79fa      	ldrb	r2, [r7, #7]
   1d110:	79bb      	ldrb	r3, [r7, #6]
   1d112:	4928      	ldr	r1, [pc, #160]	; (1d1b4 <appAdvSetAdValue+0xc4>)
   1d114:	0092      	lsls	r2, r2, #2
   1d116:	4413      	add	r3, r2
   1d118:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
   1d11c:	613b      	str	r3, [r7, #16]
  advDataLen = appSlaveCb.advDataLen[advHandle][location];
   1d11e:	79fa      	ldrb	r2, [r7, #7]
   1d120:	79bb      	ldrb	r3, [r7, #6]
   1d122:	4924      	ldr	r1, [pc, #144]	; (1d1b4 <appAdvSetAdValue+0xc4>)
   1d124:	0092      	lsls	r2, r2, #2
   1d126:	4413      	add	r3, r2
   1d128:	3308      	adds	r3, #8
   1d12a:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1d12e:	81bb      	strh	r3, [r7, #12]
  advDataBufLen = appSlaveCb.advDataBufLen[advHandle][location];
   1d130:	79fa      	ldrb	r2, [r7, #7]
   1d132:	79bb      	ldrb	r3, [r7, #6]
   1d134:	491f      	ldr	r1, [pc, #124]	; (1d1b4 <appAdvSetAdValue+0xc4>)
   1d136:	0092      	lsls	r2, r2, #2
   1d138:	4413      	add	r3, r2
   1d13a:	330c      	adds	r3, #12
   1d13c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1d140:	81fb      	strh	r3, [r7, #14]

  if (pAdvData != NULL)
   1d142:	693b      	ldr	r3, [r7, #16]
   1d144:	2b00      	cmp	r3, #0
   1d146:	d02f      	beq.n	1d1a8 <appAdvSetAdValue+0xb8>
  {
    /* set the new element value in the advertising data */
    if (adType == DM_ADV_TYPE_LOCAL_NAME)
   1d148:	797b      	ldrb	r3, [r7, #5]
   1d14a:	2b09      	cmp	r3, #9
   1d14c:	d10b      	bne.n	1d166 <appAdvSetAdValue+0x76>
    {
      valueSet = DmAdvSetName(len, pValue, &advDataLen, pAdvData, advDataBufLen);
   1d14e:	f107 020c 	add.w	r2, r7, #12
   1d152:	7938      	ldrb	r0, [r7, #4]
   1d154:	89fb      	ldrh	r3, [r7, #14]
   1d156:	9300      	str	r3, [sp, #0]
   1d158:	693b      	ldr	r3, [r7, #16]
   1d15a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
   1d15c:	f004 ff8b 	bl	22076 <DmAdvSetName>
   1d160:	4603      	mov	r3, r0
   1d162:	75fb      	strb	r3, [r7, #23]
   1d164:	e00d      	b.n	1d182 <appAdvSetAdValue+0x92>
    }
    else
    {
      valueSet = DmAdvSetAdValue(adType, len, pValue, &advDataLen, pAdvData, advDataBufLen);
   1d166:	f107 020c 	add.w	r2, r7, #12
   1d16a:	7939      	ldrb	r1, [r7, #4]
   1d16c:	7978      	ldrb	r0, [r7, #5]
   1d16e:	89fb      	ldrh	r3, [r7, #14]
   1d170:	9301      	str	r3, [sp, #4]
   1d172:	693b      	ldr	r3, [r7, #16]
   1d174:	9300      	str	r3, [sp, #0]
   1d176:	4613      	mov	r3, r2
   1d178:	6aba      	ldr	r2, [r7, #40]	; 0x28
   1d17a:	f004 fef3 	bl	21f64 <DmAdvSetAdValue>
   1d17e:	4603      	mov	r3, r0
   1d180:	75fb      	strb	r3, [r7, #23]
    }

    if (valueSet)
   1d182:	7dfb      	ldrb	r3, [r7, #23]
   1d184:	2b00      	cmp	r3, #0
   1d186:	d00f      	beq.n	1d1a8 <appAdvSetAdValue+0xb8>
    {
      /* if new value set update advertising data */
      appAdvSetData(advHandle, location, advDataLen, pAdvData, advDataBufLen,
   1d188:	89ba      	ldrh	r2, [r7, #12]
   1d18a:	79fb      	ldrb	r3, [r7, #7]
   1d18c:	4909      	ldr	r1, [pc, #36]	; (1d1b4 <appAdvSetAdValue+0xc4>)
   1d18e:	3314      	adds	r3, #20
   1d190:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
   1d194:	79b9      	ldrb	r1, [r7, #6]
   1d196:	79f8      	ldrb	r0, [r7, #7]
   1d198:	9301      	str	r3, [sp, #4]
   1d19a:	89fb      	ldrh	r3, [r7, #14]
   1d19c:	9300      	str	r3, [sp, #0]
   1d19e:	693b      	ldr	r3, [r7, #16]
   1d1a0:	f7ff fe1a 	bl	1cdd8 <appAdvSetData>
                    appSlaveCb.maxAdvDataLen[advHandle]);

      return TRUE;
   1d1a4:	2301      	movs	r3, #1
   1d1a6:	e000      	b.n	1d1aa <appAdvSetAdValue+0xba>
    }
  }

  return FALSE;
   1d1a8:	2300      	movs	r3, #0
}
   1d1aa:	4618      	mov	r0, r3
   1d1ac:	371c      	adds	r7, #28
   1d1ae:	46bd      	mov	sp, r7
   1d1b0:	bd90      	pop	{r4, r7, pc}
   1d1b2:	bf00      	nop
   1d1b4:	10011000 	.word	0x10011000

0001d1b8 <appSetAdvType>:
 *  \return None.
 */
/*************************************************************************************************/
void appSetAdvType(uint8_t advHandle, uint8_t advType, uint16_t interval, uint16_t duration,
                   uint8_t maxEaEvents, bool_t cfgAdvParam)
{
   1d1b8:	b590      	push	{r4, r7, lr}
   1d1ba:	b085      	sub	sp, #20
   1d1bc:	af02      	add	r7, sp, #8
   1d1be:	4604      	mov	r4, r0
   1d1c0:	4608      	mov	r0, r1
   1d1c2:	4611      	mov	r1, r2
   1d1c4:	461a      	mov	r2, r3
   1d1c6:	4623      	mov	r3, r4
   1d1c8:	71fb      	strb	r3, [r7, #7]
   1d1ca:	4603      	mov	r3, r0
   1d1cc:	71bb      	strb	r3, [r7, #6]
   1d1ce:	460b      	mov	r3, r1
   1d1d0:	80bb      	strh	r3, [r7, #4]
   1d1d2:	4613      	mov	r3, r2
   1d1d4:	807b      	strh	r3, [r7, #2]
  /* if new advertising type isn't allowed */
  if ((advType == DM_ADV_CONN_DIRECT) || (advType == DM_ADV_CONN_DIRECT_LO_DUTY))
   1d1d6:	79bb      	ldrb	r3, [r7, #6]
   1d1d8:	2b01      	cmp	r3, #1
   1d1da:	d04b      	beq.n	1d274 <appSetAdvType+0xbc>
   1d1dc:	79bb      	ldrb	r3, [r7, #6]
   1d1de:	2b04      	cmp	r3, #4
   1d1e0:	d048      	beq.n	1d274 <appSetAdvType+0xbc>
  {
    return;
  }

  /* if advertising type is changed */
  if (appSlaveCb.advType[advHandle] != advType)
   1d1e2:	79fb      	ldrb	r3, [r7, #7]
   1d1e4:	461a      	mov	r2, r3
   1d1e6:	4b25      	ldr	r3, [pc, #148]	; (1d27c <appSetAdvType+0xc4>)
   1d1e8:	4413      	add	r3, r2
   1d1ea:	f893 302d 	ldrb.w	r3, [r3, #45]	; 0x2d
   1d1ee:	79ba      	ldrb	r2, [r7, #6]
   1d1f0:	429a      	cmp	r2, r3
   1d1f2:	d040      	beq.n	1d276 <appSetAdvType+0xbe>
  {
    /* set new advertising type */
    appSlaveCb.advType[advHandle] = advType;
   1d1f4:	79fb      	ldrb	r3, [r7, #7]
   1d1f6:	461a      	mov	r2, r3
   1d1f8:	4b20      	ldr	r3, [pc, #128]	; (1d27c <appSetAdvType+0xc4>)
   1d1fa:	4413      	add	r3, r2
   1d1fc:	79ba      	ldrb	r2, [r7, #6]
   1d1fe:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* if advertising has been started by the application */
    if (appSlaveCb.discMode != APP_MODE_NONE)
   1d202:	4b1e      	ldr	r3, [pc, #120]	; (1d27c <appSetAdvType+0xc4>)
   1d204:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
   1d208:	2bff      	cmp	r3, #255	; 0xff
   1d20a:	d034      	beq.n	1d276 <appSetAdvType+0xbe>
    {
      /* start advertising from beginning of advertising data */
      appSlaveResetAdvDataOffset(advHandle);
   1d20c:	79fb      	ldrb	r3, [r7, #7]
   1d20e:	4618      	mov	r0, r3
   1d210:	f7fe fe98 	bl	1bf44 <appSlaveResetAdvDataOffset>

      /* if not already advertising */
      if (appSlaveCb.advState[advHandle] == APP_ADV_STOPPED)
   1d214:	79fb      	ldrb	r3, [r7, #7]
   1d216:	461a      	mov	r2, r3
   1d218:	4b18      	ldr	r3, [pc, #96]	; (1d27c <appSetAdvType+0xc4>)
   1d21a:	4413      	add	r3, r2
   1d21c:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d220:	2b03      	cmp	r3, #3
   1d222:	d113      	bne.n	1d24c <appSetAdvType+0x94>
      {
        /* start advertising with new type */
        appSlaveCb.advState[advHandle] = APP_ADV_STATE1;
   1d224:	79fb      	ldrb	r3, [r7, #7]
   1d226:	461a      	mov	r2, r3
   1d228:	4b14      	ldr	r3, [pc, #80]	; (1d27c <appSetAdvType+0xc4>)
   1d22a:	4413      	add	r3, r2
   1d22c:	2200      	movs	r2, #0
   1d22e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

        appAdvStart(1, &advHandle, &interval, &duration, &maxEaEvents, cfgAdvParam);
   1d232:	1cb8      	adds	r0, r7, #2
   1d234:	1d3a      	adds	r2, r7, #4
   1d236:	1df9      	adds	r1, r7, #7
   1d238:	7f3b      	ldrb	r3, [r7, #28]
   1d23a:	9301      	str	r3, [sp, #4]
   1d23c:	f107 0318 	add.w	r3, r7, #24
   1d240:	9300      	str	r3, [sp, #0]
   1d242:	4603      	mov	r3, r0
   1d244:	2001      	movs	r0, #1
   1d246:	f7ff fe25 	bl	1ce94 <appAdvStart>
   1d24a:	e014      	b.n	1d276 <appSetAdvType+0xbe>
      }
      /* else advertising with old type */
      else
      {
        /* set advertising type changed flag */
        appSlaveCb.advTypeChanged[advHandle] = TRUE;
   1d24c:	79fb      	ldrb	r3, [r7, #7]
   1d24e:	461a      	mov	r2, r3
   1d250:	4b0a      	ldr	r3, [pc, #40]	; (1d27c <appSetAdvType+0xc4>)
   1d252:	4413      	add	r3, r2
   1d254:	2201      	movs	r2, #1
   1d256:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

        /* stop advertising before advertising with new type */
        appSlaveCb.advState[advHandle] = APP_ADV_STOPPED;
   1d25a:	79fb      	ldrb	r3, [r7, #7]
   1d25c:	461a      	mov	r2, r3
   1d25e:	4b07      	ldr	r3, [pc, #28]	; (1d27c <appSetAdvType+0xc4>)
   1d260:	4413      	add	r3, r2
   1d262:	2203      	movs	r2, #3
   1d264:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

        DmAdvStop(1, &advHandle);
   1d268:	1dfb      	adds	r3, r7, #7
   1d26a:	4619      	mov	r1, r3
   1d26c:	2001      	movs	r0, #1
   1d26e:	f004 fe27 	bl	21ec0 <DmAdvStop>
   1d272:	e000      	b.n	1d276 <appSetAdvType+0xbe>
    return;
   1d274:	bf00      	nop
      }
    }
  }
}
   1d276:	370c      	adds	r7, #12
   1d278:	46bd      	mov	sp, r7
   1d27a:	bd90      	pop	{r4, r7, pc}
   1d27c:	10011000 	.word	0x10011000

0001d280 <AppSlaveSecProcDmMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppSlaveSecProcDmMsg(dmEvt_t *pMsg)
{
   1d280:	b580      	push	{r7, lr}
   1d282:	b084      	sub	sp, #16
   1d284:	af00      	add	r7, sp, #0
   1d286:	6078      	str	r0, [r7, #4]
  appConnCb_t *pCb;

  /* look up app connection control block from DM connection ID */
  pCb = &appConnCb[pMsg->hdr.param - 1];
   1d288:	687b      	ldr	r3, [r7, #4]
   1d28a:	881b      	ldrh	r3, [r3, #0]
   1d28c:	1e5a      	subs	r2, r3, #1
   1d28e:	4613      	mov	r3, r2
   1d290:	005b      	lsls	r3, r3, #1
   1d292:	4413      	add	r3, r2
   1d294:	011b      	lsls	r3, r3, #4
   1d296:	4a3c      	ldr	r2, [pc, #240]	; (1d388 <AppSlaveSecProcDmMsg+0x108>)
   1d298:	4413      	add	r3, r2
   1d29a:	60fb      	str	r3, [r7, #12]

  switch(pMsg->hdr.event)
   1d29c:	687b      	ldr	r3, [r7, #4]
   1d29e:	789b      	ldrb	r3, [r3, #2]
   1d2a0:	3b27      	subs	r3, #39	; 0x27
   1d2a2:	2b18      	cmp	r3, #24
   1d2a4:	d86a      	bhi.n	1d37c <AppSlaveSecProcDmMsg+0xfc>
   1d2a6:	a201      	add	r2, pc, #4	; (adr r2, 1d2ac <AppSlaveSecProcDmMsg+0x2c>)
   1d2a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   1d2ac:	0001d311 	.word	0x0001d311
   1d2b0:	0001d31b 	.word	0x0001d31b
   1d2b4:	0001d37d 	.word	0x0001d37d
   1d2b8:	0001d325 	.word	0x0001d325
   1d2bc:	0001d32f 	.word	0x0001d32f
   1d2c0:	0001d339 	.word	0x0001d339
   1d2c4:	0001d37d 	.word	0x0001d37d
   1d2c8:	0001d37d 	.word	0x0001d37d
   1d2cc:	0001d343 	.word	0x0001d343
   1d2d0:	0001d357 	.word	0x0001d357
   1d2d4:	0001d34d 	.word	0x0001d34d
   1d2d8:	0001d37d 	.word	0x0001d37d
   1d2dc:	0001d37d 	.word	0x0001d37d
   1d2e0:	0001d37d 	.word	0x0001d37d
   1d2e4:	0001d37d 	.word	0x0001d37d
   1d2e8:	0001d37d 	.word	0x0001d37d
   1d2ec:	0001d37d 	.word	0x0001d37d
   1d2f0:	0001d37d 	.word	0x0001d37d
   1d2f4:	0001d37d 	.word	0x0001d37d
   1d2f8:	0001d369 	.word	0x0001d369
   1d2fc:	0001d373 	.word	0x0001d373
   1d300:	0001d37d 	.word	0x0001d37d
   1d304:	0001d37d 	.word	0x0001d37d
   1d308:	0001d37d 	.word	0x0001d37d
   1d30c:	0001d361 	.word	0x0001d361
  {
    case DM_CONN_OPEN_IND:
      appSlaveSecConnOpen(pMsg, pCb);
   1d310:	68f9      	ldr	r1, [r7, #12]
   1d312:	6878      	ldr	r0, [r7, #4]
   1d314:	f7ff f9a4 	bl	1c660 <appSlaveSecConnOpen>
      break;
   1d318:	e031      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_CONN_CLOSE_IND:
      appSecConnClose(pMsg, pCb);
   1d31a:	68f9      	ldr	r1, [r7, #12]
   1d31c:	6878      	ldr	r0, [r7, #4]
   1d31e:	f7ff f9e1 	bl	1c6e4 <appSecConnClose>
      break;
   1d322:	e02c      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_PAIR_CMPL_IND:
      appSecPairCmpl(pMsg, pCb);
   1d324:	68f9      	ldr	r1, [r7, #12]
   1d326:	6878      	ldr	r0, [r7, #4]
   1d328:	f7ff fa98 	bl	1c85c <appSecPairCmpl>
      break;
   1d32c:	e027      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_PAIR_FAIL_IND:
      appSecPairFailed(pMsg, pCb);
   1d32e:	68f9      	ldr	r1, [r7, #12]
   1d330:	6878      	ldr	r0, [r7, #4]
   1d332:	f7ff fac7 	bl	1c8c4 <appSecPairFailed>
      break;
   1d336:	e022      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_ENCRYPT_IND:
      appSecEncryptInd(pMsg, pCb);
   1d338:	68f9      	ldr	r1, [r7, #12]
   1d33a:	6878      	ldr	r0, [r7, #4]
   1d33c:	f7ff facd 	bl	1c8da <appSecEncryptInd>
      break;
   1d340:	e01d      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_ENCRYPT_FAIL_IND:
      break;

    case DM_SEC_KEY_IND:
      appSecStoreKey(pMsg, pCb);
   1d342:	68f9      	ldr	r1, [r7, #12]
   1d344:	6878      	ldr	r0, [r7, #4]
   1d346:	f7ff fa69 	bl	1c81c <appSecStoreKey>
      break;
   1d34a:	e018      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_PAIR_IND:
      appSecPairInd(pMsg, pCb);
   1d34c:	68f9      	ldr	r1, [r7, #12]
   1d34e:	6878      	ldr	r0, [r7, #4]
   1d350:	f7ff f9da 	bl	1c708 <appSecPairInd>
      break;
   1d354:	e013      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_SEC_LTK_REQ_IND:
      appSecFindLtk(pMsg, pCb);
   1d356:	68f9      	ldr	r1, [r7, #12]
   1d358:	6878      	ldr	r0, [r7, #4]
   1d35a:	f7ff fad7 	bl	1c90c <appSecFindLtk>
      break;
   1d35e:	e00e      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_PRIV_SET_ADDR_RES_ENABLE_IND:
      appPrivSetAddrResEnableInd(pMsg);
   1d360:	6878      	ldr	r0, [r7, #4]
   1d362:	f7ff fb13 	bl	1c98c <appPrivSetAddrResEnableInd>
      break;
   1d366:	e00a      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_PRIV_ADD_DEV_TO_RES_LIST_IND:
      appPrivAddDevToResListInd(pMsg, pCb);
   1d368:	68f9      	ldr	r1, [r7, #12]
   1d36a:	6878      	ldr	r0, [r7, #4]
   1d36c:	f7ff fb20 	bl	1c9b0 <appPrivAddDevToResListInd>
      break;
   1d370:	e005      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    case DM_PRIV_REM_DEV_FROM_RES_LIST_IND:
      appPrivRemDevFromResListInd(pMsg, pCb);
   1d372:	68f9      	ldr	r1, [r7, #12]
   1d374:	6878      	ldr	r0, [r7, #4]
   1d376:	f7ff fb32 	bl	1c9de <appPrivRemDevFromResListInd>
      break;
   1d37a:	e000      	b.n	1d37e <AppSlaveSecProcDmMsg+0xfe>

    default:
      break;
   1d37c:	bf00      	nop
  }
}
   1d37e:	bf00      	nop
   1d380:	3710      	adds	r7, #16
   1d382:	46bd      	mov	sp, r7
   1d384:	bd80      	pop	{r7, pc}
   1d386:	bf00      	nop
   1d388:	10010ed0 	.word	0x10010ed0

0001d38c <AppSetBondable>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppSetBondable(bool_t bondable)
{
   1d38c:	b480      	push	{r7}
   1d38e:	b083      	sub	sp, #12
   1d390:	af00      	add	r7, sp, #0
   1d392:	4603      	mov	r3, r0
   1d394:	71fb      	strb	r3, [r7, #7]
  appSlaveCb.bondable = bondable;
   1d396:	4a05      	ldr	r2, [pc, #20]	; (1d3ac <AppSetBondable+0x20>)
   1d398:	79fb      	ldrb	r3, [r7, #7]
   1d39a:	f882 302a 	strb.w	r3, [r2, #42]	; 0x2a
}
   1d39e:	bf00      	nop
   1d3a0:	370c      	adds	r7, #12
   1d3a2:	46bd      	mov	sp, r7
   1d3a4:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d3a8:	4770      	bx	lr
   1d3aa:	bf00      	nop
   1d3ac:	10011000 	.word	0x10011000

0001d3b0 <AppSlaveIsAdvertising>:
 *
 *  \return TRUE if device's advertising. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t AppSlaveIsAdvertising(void)
{
   1d3b0:	b480      	push	{r7}
   1d3b2:	b083      	sub	sp, #12
   1d3b4:	af00      	add	r7, sp, #0
  uint8_t i;

  /* for each advertising set */
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1d3b6:	2300      	movs	r3, #0
   1d3b8:	71fb      	strb	r3, [r7, #7]
   1d3ba:	e00b      	b.n	1d3d4 <AppSlaveIsAdvertising+0x24>
  {
    /* if advertising */
    if (appSlaveCb.advState[i] < APP_ADV_STOPPED)
   1d3bc:	79fb      	ldrb	r3, [r7, #7]
   1d3be:	4a0a      	ldr	r2, [pc, #40]	; (1d3e8 <AppSlaveIsAdvertising+0x38>)
   1d3c0:	4413      	add	r3, r2
   1d3c2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d3c6:	2b02      	cmp	r3, #2
   1d3c8:	d801      	bhi.n	1d3ce <AppSlaveIsAdvertising+0x1e>
    {
      return TRUE;
   1d3ca:	2301      	movs	r3, #1
   1d3cc:	e006      	b.n	1d3dc <AppSlaveIsAdvertising+0x2c>
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   1d3ce:	79fb      	ldrb	r3, [r7, #7]
   1d3d0:	3301      	adds	r3, #1
   1d3d2:	71fb      	strb	r3, [r7, #7]
   1d3d4:	79fb      	ldrb	r3, [r7, #7]
   1d3d6:	2b00      	cmp	r3, #0
   1d3d8:	d0f0      	beq.n	1d3bc <AppSlaveIsAdvertising+0xc>
    }
  }

  return FALSE;
   1d3da:	2300      	movs	r3, #0
}
   1d3dc:	4618      	mov	r0, r3
   1d3de:	370c      	adds	r7, #12
   1d3e0:	46bd      	mov	sp, r7
   1d3e2:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d3e6:	4770      	bx	lr
   1d3e8:	10011000 	.word	0x10011000

0001d3ec <appSlaveLegAdvStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveLegAdvStart(void)
{
   1d3ec:	b580      	push	{r7, lr}
   1d3ee:	b084      	sub	sp, #16
   1d3f0:	af02      	add	r7, sp, #8
  uint8_t  advHandle;
  uint8_t  maxEaEvents;
  uint16_t interval;

  interval = pAppAdvCfg->advInterval[appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT]];
   1d3f2:	4b15      	ldr	r3, [pc, #84]	; (1d448 <appSlaveLegAdvStart+0x5c>)
   1d3f4:	681a      	ldr	r2, [r3, #0]
   1d3f6:	4b15      	ldr	r3, [pc, #84]	; (1d44c <appSlaveLegAdvStart+0x60>)
   1d3f8:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d3fc:	005b      	lsls	r3, r3, #1
   1d3fe:	4413      	add	r3, r2
   1d400:	88db      	ldrh	r3, [r3, #6]
   1d402:	80bb      	strh	r3, [r7, #4]

  /* if this advertising state is being used */
  if (interval > 0)
   1d404:	88bb      	ldrh	r3, [r7, #4]
   1d406:	2b00      	cmp	r3, #0
   1d408:	d015      	beq.n	1d436 <appSlaveLegAdvStart+0x4a>
  {
    advHandle = DM_ADV_HANDLE_DEFAULT;
   1d40a:	2300      	movs	r3, #0
   1d40c:	71fb      	strb	r3, [r7, #7]
    maxEaEvents = 0;
   1d40e:	2300      	movs	r3, #0
   1d410:	71bb      	strb	r3, [r7, #6]

    appAdvStart(1, &advHandle, &interval,
                &(pAppAdvCfg->advDuration[appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT]]),
   1d412:	4b0d      	ldr	r3, [pc, #52]	; (1d448 <appSlaveLegAdvStart+0x5c>)
   1d414:	681a      	ldr	r2, [r3, #0]
   1d416:	4b0d      	ldr	r3, [pc, #52]	; (1d44c <appSlaveLegAdvStart+0x60>)
   1d418:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    appAdvStart(1, &advHandle, &interval,
   1d41c:	005b      	lsls	r3, r3, #1
   1d41e:	18d0      	adds	r0, r2, r3
   1d420:	1d3a      	adds	r2, r7, #4
   1d422:	1df9      	adds	r1, r7, #7
   1d424:	2301      	movs	r3, #1
   1d426:	9301      	str	r3, [sp, #4]
   1d428:	1dbb      	adds	r3, r7, #6
   1d42a:	9300      	str	r3, [sp, #0]
   1d42c:	4603      	mov	r3, r0
   1d42e:	2001      	movs	r0, #1
   1d430:	f7ff fd30 	bl	1ce94 <appAdvStart>
  else
  {
    /* done with all advertising states */
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STOPPED;
  }
}
   1d434:	e003      	b.n	1d43e <appSlaveLegAdvStart+0x52>
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STOPPED;
   1d436:	4b05      	ldr	r3, [pc, #20]	; (1d44c <appSlaveLegAdvStart+0x60>)
   1d438:	2203      	movs	r2, #3
   1d43a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
}
   1d43e:	bf00      	nop
   1d440:	3708      	adds	r7, #8
   1d442:	46bd      	mov	sp, r7
   1d444:	bd80      	pop	{r7, pc}
   1d446:	bf00      	nop
   1d448:	10010ecc 	.word	0x10010ecc
   1d44c:	10011000 	.word	0x10011000

0001d450 <appSlaveLegAdvTypeChanged>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveLegAdvTypeChanged(dmEvt_t *pMsg)
{
   1d450:	b580      	push	{r7, lr}
   1d452:	b082      	sub	sp, #8
   1d454:	af00      	add	r7, sp, #0
   1d456:	6078      	str	r0, [r7, #4]
  /* clear advertising type changed flag */
  appSlaveCb.advTypeChanged[DM_ADV_HANDLE_DEFAULT] = FALSE;
   1d458:	4b06      	ldr	r3, [pc, #24]	; (1d474 <appSlaveLegAdvTypeChanged+0x24>)
   1d45a:	2200      	movs	r2, #0
   1d45c:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

  /* set advertising state */
  appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STATE1;
   1d460:	4b04      	ldr	r3, [pc, #16]	; (1d474 <appSlaveLegAdvTypeChanged+0x24>)
   1d462:	2200      	movs	r2, #0
   1d464:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  /* start advertising */
  appSlaveLegAdvStart();
   1d468:	f7ff ffc0 	bl	1d3ec <appSlaveLegAdvStart>
}
   1d46c:	bf00      	nop
   1d46e:	3708      	adds	r7, #8
   1d470:	46bd      	mov	sp, r7
   1d472:	bd80      	pop	{r7, pc}
   1d474:	10011000 	.word	0x10011000

0001d478 <appSlaveNextLegAdvState>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveNextLegAdvState(dmEvt_t *pMsg)
{
   1d478:	b580      	push	{r7, lr}
   1d47a:	b082      	sub	sp, #8
   1d47c:	af00      	add	r7, sp, #0
   1d47e:	6078      	str	r0, [r7, #4]
  /* go to next advertising state */
  appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT]++;
   1d480:	4b09      	ldr	r3, [pc, #36]	; (1d4a8 <appSlaveNextLegAdvState+0x30>)
   1d482:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d486:	3301      	adds	r3, #1
   1d488:	b2da      	uxtb	r2, r3
   1d48a:	4b07      	ldr	r3, [pc, #28]	; (1d4a8 <appSlaveNextLegAdvState+0x30>)
   1d48c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  /* if haven't reached stopped state then start advertising */
  if (appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] < APP_ADV_STOPPED)
   1d490:	4b05      	ldr	r3, [pc, #20]	; (1d4a8 <appSlaveNextLegAdvState+0x30>)
   1d492:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d496:	2b02      	cmp	r3, #2
   1d498:	d801      	bhi.n	1d49e <appSlaveNextLegAdvState+0x26>
  {
    appSlaveLegAdvStart();
   1d49a:	f7ff ffa7 	bl	1d3ec <appSlaveLegAdvStart>
  }
}
   1d49e:	bf00      	nop
   1d4a0:	3708      	adds	r7, #8
   1d4a2:	46bd      	mov	sp, r7
   1d4a4:	bd80      	pop	{r7, pc}
   1d4a6:	bf00      	nop
   1d4a8:	10011000 	.word	0x10011000

0001d4ac <appSlaveLegAdvStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveLegAdvStop(dmEvt_t *pMsg)
{
   1d4ac:	b580      	push	{r7, lr}
   1d4ae:	b082      	sub	sp, #8
   1d4b0:	af00      	add	r7, sp, #0
   1d4b2:	6078      	str	r0, [r7, #4]
  /* if legacy advertising PDUs are used with advertising extensions feature */
  if (pMsg->hdr.event == DM_ADV_SET_STOP_IND)
   1d4b4:	687b      	ldr	r3, [r7, #4]
   1d4b6:	789b      	ldrb	r3, [r3, #2]
   1d4b8:	2b48      	cmp	r3, #72	; 0x48
   1d4ba:	d103      	bne.n	1d4c4 <appSlaveLegAdvStop+0x18>
  {
    /* if advertising successfully ended with connection being created */
    if (pMsg->advSetStop.status == HCI_SUCCESS)
   1d4bc:	687b      	ldr	r3, [r7, #4]
   1d4be:	791b      	ldrb	r3, [r3, #4]
   1d4c0:	2b00      	cmp	r3, #0
   1d4c2:	d00c      	beq.n	1d4de <appSlaveLegAdvStop+0x32>
      return;
    }
  }

  /* if advertising was stopped for change to advertising type */
  if (appSlaveCb.advTypeChanged[DM_ADV_HANDLE_DEFAULT])
   1d4c4:	4b08      	ldr	r3, [pc, #32]	; (1d4e8 <appSlaveLegAdvStop+0x3c>)
   1d4c6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
   1d4ca:	2b00      	cmp	r3, #0
   1d4cc:	d003      	beq.n	1d4d6 <appSlaveLegAdvStop+0x2a>
  {
    appSlaveLegAdvTypeChanged(pMsg);
   1d4ce:	6878      	ldr	r0, [r7, #4]
   1d4d0:	f7ff ffbe 	bl	1d450 <appSlaveLegAdvTypeChanged>
   1d4d4:	e004      	b.n	1d4e0 <appSlaveLegAdvStop+0x34>
  }
  /* else advertising ended for another reason */
  else
  {
    appSlaveNextLegAdvState(pMsg);
   1d4d6:	6878      	ldr	r0, [r7, #4]
   1d4d8:	f7ff ffce 	bl	1d478 <appSlaveNextLegAdvState>
   1d4dc:	e000      	b.n	1d4e0 <appSlaveLegAdvStop+0x34>
      return;
   1d4de:	bf00      	nop
  }
}
   1d4e0:	3708      	adds	r7, #8
   1d4e2:	46bd      	mov	sp, r7
   1d4e4:	bd80      	pop	{r7, pc}
   1d4e6:	bf00      	nop
   1d4e8:	10011000 	.word	0x10011000

0001d4ec <appSlaveLegAdvRestart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void appSlaveLegAdvRestart(dmEvt_t *pMsg)
{
   1d4ec:	b580      	push	{r7, lr}
   1d4ee:	b082      	sub	sp, #8
   1d4f0:	af00      	add	r7, sp, #0
   1d4f2:	6078      	str	r0, [r7, #4]
  /* if connection closed */
  if (pMsg->hdr.event == DM_CONN_CLOSE_IND)
   1d4f4:	687b      	ldr	r3, [r7, #4]
   1d4f6:	789b      	ldrb	r3, [r3, #2]
   1d4f8:	2b28      	cmp	r3, #40	; 0x28
   1d4fa:	d109      	bne.n	1d510 <appSlaveLegAdvRestart+0x24>
  {
    /* if connectable directed advertising failed to establish connection or was cancelled */
    if (appSlaveCb.advDirected)
   1d4fc:	4b14      	ldr	r3, [pc, #80]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d4fe:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
   1d502:	2b00      	cmp	r3, #0
   1d504:	d016      	beq.n	1d534 <appSlaveLegAdvRestart+0x48>
    {
      appSlaveCb.advDirected = FALSE;
   1d506:	4b12      	ldr	r3, [pc, #72]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d508:	2200      	movs	r2, #0
   1d50a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      return;
   1d50e:	e01c      	b.n	1d54a <appSlaveLegAdvRestart+0x5e>
    }
  }
  /* else if connection opened */
  else if (pMsg->hdr.event == DM_CONN_OPEN_IND)
   1d510:	687b      	ldr	r3, [r7, #4]
   1d512:	789b      	ldrb	r3, [r3, #2]
   1d514:	2b27      	cmp	r3, #39	; 0x27
   1d516:	d10d      	bne.n	1d534 <appSlaveLegAdvRestart+0x48>
  {
    /* if connectable directed advertising */
    if (appSlaveCb.advDirected)
   1d518:	4b0d      	ldr	r3, [pc, #52]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d51a:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
   1d51e:	2b00      	cmp	r3, #0
   1d520:	d004      	beq.n	1d52c <appSlaveLegAdvRestart+0x40>
    {
      appSlaveCb.advDirected = FALSE;
   1d522:	4b0b      	ldr	r3, [pc, #44]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d524:	2200      	movs	r2, #0
   1d526:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
      return;
   1d52a:	e00e      	b.n	1d54a <appSlaveLegAdvRestart+0x5e>
    }

    /* advertising is stopped once a connection is opened */
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STOPPED;
   1d52c:	4b08      	ldr	r3, [pc, #32]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d52e:	2203      	movs	r2, #3
   1d530:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }

  /* if advertising stopped restart advertising */
  if (appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] == APP_ADV_STOPPED)
   1d534:	4b06      	ldr	r3, [pc, #24]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d536:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   1d53a:	2b03      	cmp	r3, #3
   1d53c:	d105      	bne.n	1d54a <appSlaveLegAdvRestart+0x5e>
  {
    /* set advertising state */
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STATE1;
   1d53e:	4b04      	ldr	r3, [pc, #16]	; (1d550 <appSlaveLegAdvRestart+0x64>)
   1d540:	2200      	movs	r2, #0
   1d542:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    /* start advertising */
    appSlaveLegAdvStart();
   1d546:	f7ff ff51 	bl	1d3ec <appSlaveLegAdvStart>
  }
}
   1d54a:	3708      	adds	r7, #8
   1d54c:	46bd      	mov	sp, r7
   1d54e:	bd80      	pop	{r7, pc}
   1d550:	10011000 	.word	0x10011000

0001d554 <appSlaveAdvMode>:
 *
 *  \return TRUE if legacy advertising mode. FALSE, otherwise.
 */
/*************************************************************************************************/
static bool_t appSlaveAdvMode(void)
{
   1d554:	b580      	push	{r7, lr}
   1d556:	af00      	add	r7, sp, #0
  /* legacy app slave works with both DM legacy and extended advertising */

  /* if first time since last power-on or reset */
  if (appSlaveCb.advStopCback == NULL)
   1d558:	4b0c      	ldr	r3, [pc, #48]	; (1d58c <appSlaveAdvMode+0x38>)
   1d55a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1d55c:	2b00      	cmp	r3, #0
   1d55e:	d107      	bne.n	1d570 <appSlaveAdvMode+0x1c>
  {
    appSlaveCb.advStopCback = appSlaveLegAdvStop;
   1d560:	4b0a      	ldr	r3, [pc, #40]	; (1d58c <appSlaveAdvMode+0x38>)
   1d562:	4a0b      	ldr	r2, [pc, #44]	; (1d590 <appSlaveAdvMode+0x3c>)
   1d564:	641a      	str	r2, [r3, #64]	; 0x40
    appSlaveCb.advRestartCback = appSlaveLegAdvRestart;
   1d566:	4b09      	ldr	r3, [pc, #36]	; (1d58c <appSlaveAdvMode+0x38>)
   1d568:	4a0a      	ldr	r2, [pc, #40]	; (1d594 <appSlaveAdvMode+0x40>)
   1d56a:	645a      	str	r2, [r3, #68]	; 0x44

    return TRUE;
   1d56c:	2301      	movs	r3, #1
   1d56e:	e00a      	b.n	1d586 <appSlaveAdvMode+0x32>
  }

  if (appSlaveCb.advStopCback == appSlaveLegAdvStop)
   1d570:	4b06      	ldr	r3, [pc, #24]	; (1d58c <appSlaveAdvMode+0x38>)
   1d572:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   1d574:	4a06      	ldr	r2, [pc, #24]	; (1d590 <appSlaveAdvMode+0x3c>)
   1d576:	4293      	cmp	r3, r2
   1d578:	d101      	bne.n	1d57e <appSlaveAdvMode+0x2a>
  {
    return TRUE;
   1d57a:	2301      	movs	r3, #1
   1d57c:	e003      	b.n	1d586 <appSlaveAdvMode+0x32>
  }

  APP_TRACE_WARN0("Invalid DM advertising mode; mode configured as extended");
   1d57e:	4806      	ldr	r0, [pc, #24]	; (1d598 <appSlaveAdvMode+0x44>)
   1d580:	f010 fa06 	bl	2d990 <WsfTrace>

  return FALSE;
   1d584:	2300      	movs	r3, #0
}
   1d586:	4618      	mov	r0, r3
   1d588:	bd80      	pop	{r7, pc}
   1d58a:	bf00      	nop
   1d58c:	10011000 	.word	0x10011000
   1d590:	0001d4ad 	.word	0x0001d4ad
   1d594:	0001d4ed 	.word	0x0001d4ed
   1d598:	000447c4 	.word	0x000447c4

0001d59c <AppAdvSetData>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppAdvSetData(uint8_t location, uint8_t len, uint8_t *pData)
{
   1d59c:	b580      	push	{r7, lr}
   1d59e:	b084      	sub	sp, #16
   1d5a0:	af02      	add	r7, sp, #8
   1d5a2:	4603      	mov	r3, r0
   1d5a4:	603a      	str	r2, [r7, #0]
   1d5a6:	71fb      	strb	r3, [r7, #7]
   1d5a8:	460b      	mov	r3, r1
   1d5aa:	71bb      	strb	r3, [r7, #6]
  if (appSlaveAdvMode())
   1d5ac:	f7ff ffd2 	bl	1d554 <appSlaveAdvMode>
   1d5b0:	4603      	mov	r3, r0
   1d5b2:	2b00      	cmp	r3, #0
   1d5b4:	d00f      	beq.n	1d5d6 <AppAdvSetData+0x3a>
  {
    /* legacy advertising data length cannot exceed 31 bytes */
    if (len > HCI_ADV_DATA_LEN)
   1d5b6:	79bb      	ldrb	r3, [r7, #6]
   1d5b8:	2b1f      	cmp	r3, #31
   1d5ba:	d901      	bls.n	1d5c0 <AppAdvSetData+0x24>
    {
      len = HCI_ADV_DATA_LEN;
   1d5bc:	231f      	movs	r3, #31
   1d5be:	71bb      	strb	r3, [r7, #6]
    }

    /* maximum advertising data length supported by Controller is 31 bytes */
    appAdvSetData(DM_ADV_HANDLE_DEFAULT, location, len, pData, HCI_ADV_DATA_LEN, HCI_ADV_DATA_LEN);
   1d5c0:	79bb      	ldrb	r3, [r7, #6]
   1d5c2:	b29a      	uxth	r2, r3
   1d5c4:	79f9      	ldrb	r1, [r7, #7]
   1d5c6:	231f      	movs	r3, #31
   1d5c8:	9301      	str	r3, [sp, #4]
   1d5ca:	231f      	movs	r3, #31
   1d5cc:	9300      	str	r3, [sp, #0]
   1d5ce:	683b      	ldr	r3, [r7, #0]
   1d5d0:	2000      	movs	r0, #0
   1d5d2:	f7ff fc01 	bl	1cdd8 <appAdvSetData>
  }
}
   1d5d6:	bf00      	nop
   1d5d8:	3708      	adds	r7, #8
   1d5da:	46bd      	mov	sp, r7
   1d5dc:	bd80      	pop	{r7, pc}
	...

0001d5e0 <AppAdvStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppAdvStart(uint8_t mode)
{
   1d5e0:	b580      	push	{r7, lr}
   1d5e2:	b088      	sub	sp, #32
   1d5e4:	af04      	add	r7, sp, #16
   1d5e6:	4603      	mov	r3, r0
   1d5e8:	71fb      	strb	r3, [r7, #7]
  uint8_t advHandle;
  uint8_t maxEaEvents;

  if (appSlaveAdvMode())
   1d5ea:	f7ff ffb3 	bl	1d554 <appSlaveAdvMode>
   1d5ee:	4603      	mov	r3, r0
   1d5f0:	2b00      	cmp	r3, #0
   1d5f2:	d01a      	beq.n	1d62a <AppAdvStart+0x4a>
  {
    advHandle = DM_ADV_HANDLE_DEFAULT;
   1d5f4:	2300      	movs	r3, #0
   1d5f6:	73fb      	strb	r3, [r7, #15]
    maxEaEvents = 0;
   1d5f8:	2300      	movs	r3, #0
   1d5fa:	73bb      	strb	r3, [r7, #14]

    /* initialize advertising state */
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STATE1;
   1d5fc:	4b0d      	ldr	r3, [pc, #52]	; (1d634 <AppAdvStart+0x54>)
   1d5fe:	2200      	movs	r2, #0
   1d600:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

    appSlaveAdvStart(1, &advHandle, &(pAppAdvCfg->advInterval[APP_ADV_STATE1]),
   1d604:	4b0c      	ldr	r3, [pc, #48]	; (1d638 <AppAdvStart+0x58>)
   1d606:	681b      	ldr	r3, [r3, #0]
   1d608:	1d9a      	adds	r2, r3, #6
                     &(pAppAdvCfg->advDuration[APP_ADV_STATE1]), &maxEaEvents, TRUE, mode);
   1d60a:	4b0b      	ldr	r3, [pc, #44]	; (1d638 <AppAdvStart+0x58>)
   1d60c:	681b      	ldr	r3, [r3, #0]
    appSlaveAdvStart(1, &advHandle, &(pAppAdvCfg->advInterval[APP_ADV_STATE1]),
   1d60e:	4618      	mov	r0, r3
   1d610:	f107 010f 	add.w	r1, r7, #15
   1d614:	79fb      	ldrb	r3, [r7, #7]
   1d616:	9302      	str	r3, [sp, #8]
   1d618:	2301      	movs	r3, #1
   1d61a:	9301      	str	r3, [sp, #4]
   1d61c:	f107 030e 	add.w	r3, r7, #14
   1d620:	9300      	str	r3, [sp, #0]
   1d622:	4603      	mov	r3, r0
   1d624:	2001      	movs	r0, #1
   1d626:	f7ff fd0d 	bl	1d044 <appSlaveAdvStart>
  }
}
   1d62a:	bf00      	nop
   1d62c:	3710      	adds	r7, #16
   1d62e:	46bd      	mov	sp, r7
   1d630:	bd80      	pop	{r7, pc}
   1d632:	bf00      	nop
   1d634:	10011000 	.word	0x10011000
   1d638:	10010ecc 	.word	0x10010ecc

0001d63c <AppAdvStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppAdvStop(void)
{
   1d63c:	b580      	push	{r7, lr}
   1d63e:	b082      	sub	sp, #8
   1d640:	af00      	add	r7, sp, #0
  uint8_t advHandle;

  if (appSlaveAdvMode())
   1d642:	f7ff ff87 	bl	1d554 <appSlaveAdvMode>
   1d646:	4603      	mov	r3, r0
   1d648:	2b00      	cmp	r3, #0
   1d64a:	d006      	beq.n	1d65a <AppAdvStop+0x1e>
  {
    advHandle = DM_ADV_HANDLE_DEFAULT;
   1d64c:	2300      	movs	r3, #0
   1d64e:	71fb      	strb	r3, [r7, #7]

    appAdvStop(1, &advHandle);
   1d650:	1dfb      	adds	r3, r7, #7
   1d652:	4619      	mov	r1, r3
   1d654:	2001      	movs	r0, #1
   1d656:	f7ff fcb3 	bl	1cfc0 <appAdvStop>
  }
}
   1d65a:	bf00      	nop
   1d65c:	3708      	adds	r7, #8
   1d65e:	46bd      	mov	sp, r7
   1d660:	bd80      	pop	{r7, pc}

0001d662 <AppAdvSetAdValue>:
 *
 *  \return TRUE if the element was successfully added to the data, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t AppAdvSetAdValue(uint8_t location, uint8_t adType, uint8_t len, uint8_t *pValue)
{
   1d662:	b580      	push	{r7, lr}
   1d664:	b084      	sub	sp, #16
   1d666:	af02      	add	r7, sp, #8
   1d668:	603b      	str	r3, [r7, #0]
   1d66a:	4603      	mov	r3, r0
   1d66c:	71fb      	strb	r3, [r7, #7]
   1d66e:	460b      	mov	r3, r1
   1d670:	71bb      	strb	r3, [r7, #6]
   1d672:	4613      	mov	r3, r2
   1d674:	717b      	strb	r3, [r7, #5]
  if (appSlaveAdvMode())
   1d676:	f7ff ff6d 	bl	1d554 <appSlaveAdvMode>
   1d67a:	4603      	mov	r3, r0
   1d67c:	2b00      	cmp	r3, #0
   1d67e:	d00a      	beq.n	1d696 <AppAdvSetAdValue+0x34>
  {
    return appAdvSetAdValue(DM_ADV_HANDLE_DEFAULT, location, adType, len, pValue);
   1d680:	7978      	ldrb	r0, [r7, #5]
   1d682:	79ba      	ldrb	r2, [r7, #6]
   1d684:	79f9      	ldrb	r1, [r7, #7]
   1d686:	683b      	ldr	r3, [r7, #0]
   1d688:	9300      	str	r3, [sp, #0]
   1d68a:	4603      	mov	r3, r0
   1d68c:	2000      	movs	r0, #0
   1d68e:	f7ff fd2f 	bl	1d0f0 <appAdvSetAdValue>
   1d692:	4603      	mov	r3, r0
   1d694:	e000      	b.n	1d698 <AppAdvSetAdValue+0x36>
  }

  return FALSE;
   1d696:	2300      	movs	r3, #0
}
   1d698:	4618      	mov	r0, r3
   1d69a:	3708      	adds	r7, #8
   1d69c:	46bd      	mov	sp, r7
   1d69e:	bd80      	pop	{r7, pc}

0001d6a0 <AppSetAdvType>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AppSetAdvType(uint8_t advType)
{
   1d6a0:	b580      	push	{r7, lr}
   1d6a2:	b084      	sub	sp, #16
   1d6a4:	af02      	add	r7, sp, #8
   1d6a6:	4603      	mov	r3, r0
   1d6a8:	71fb      	strb	r3, [r7, #7]
  if (appSlaveAdvMode())
   1d6aa:	f7ff ff53 	bl	1d554 <appSlaveAdvMode>
   1d6ae:	4603      	mov	r3, r0
   1d6b0:	2b00      	cmp	r3, #0
   1d6b2:	d01a      	beq.n	1d6ea <AppSetAdvType+0x4a>
  {
    /* initialize advertising state */
    appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT] = APP_ADV_STATE1;
   1d6b4:	4b0f      	ldr	r3, [pc, #60]	; (1d6f4 <AppSetAdvType+0x54>)
   1d6b6:	2200      	movs	r2, #0
   1d6b8:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    appSetAdvType(DM_ADV_HANDLE_DEFAULT, advType,
                  pAppAdvCfg->advInterval[appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT]],
   1d6bc:	4b0e      	ldr	r3, [pc, #56]	; (1d6f8 <AppSetAdvType+0x58>)
   1d6be:	681a      	ldr	r2, [r3, #0]
   1d6c0:	4b0c      	ldr	r3, [pc, #48]	; (1d6f4 <AppSetAdvType+0x54>)
   1d6c2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
    appSetAdvType(DM_ADV_HANDLE_DEFAULT, advType,
   1d6c6:	005b      	lsls	r3, r3, #1
   1d6c8:	4413      	add	r3, r2
   1d6ca:	88da      	ldrh	r2, [r3, #6]
                  pAppAdvCfg->advDuration[appSlaveCb.advState[DM_ADV_HANDLE_DEFAULT]], 0, TRUE);
   1d6cc:	4b0a      	ldr	r3, [pc, #40]	; (1d6f8 <AppSetAdvType+0x58>)
   1d6ce:	681b      	ldr	r3, [r3, #0]
   1d6d0:	4908      	ldr	r1, [pc, #32]	; (1d6f4 <AppSetAdvType+0x54>)
   1d6d2:	f891 102c 	ldrb.w	r1, [r1, #44]	; 0x2c
    appSetAdvType(DM_ADV_HANDLE_DEFAULT, advType,
   1d6d6:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
   1d6da:	79f9      	ldrb	r1, [r7, #7]
   1d6dc:	2001      	movs	r0, #1
   1d6de:	9001      	str	r0, [sp, #4]
   1d6e0:	2000      	movs	r0, #0
   1d6e2:	9000      	str	r0, [sp, #0]
   1d6e4:	2000      	movs	r0, #0
   1d6e6:	f7ff fd67 	bl	1d1b8 <appSetAdvType>
  }
}
   1d6ea:	bf00      	nop
   1d6ec:	3708      	adds	r7, #8
   1d6ee:	46bd      	mov	sp, r7
   1d6f0:	bd80      	pop	{r7, pc}
   1d6f2:	bf00      	nop
   1d6f4:	10011000 	.word	0x10011000
   1d6f8:	10010ecc 	.word	0x10010ecc

0001d6fc <attL2cDataCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attL2cDataCback(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   1d6fc:	b580      	push	{r7, lr}
   1d6fe:	b084      	sub	sp, #16
   1d700:	af00      	add	r7, sp, #0
   1d702:	4603      	mov	r3, r0
   1d704:	603a      	str	r2, [r7, #0]
   1d706:	80fb      	strh	r3, [r7, #6]
   1d708:	460b      	mov	r3, r1
   1d70a:	80bb      	strh	r3, [r7, #4]
  uint8_t pduType;

  /* parse PDU type */
  pduType = *(pPacket + L2C_PAYLOAD_START);
   1d70c:	683b      	ldr	r3, [r7, #0]
   1d70e:	7a1b      	ldrb	r3, [r3, #8]
   1d710:	73fb      	strb	r3, [r7, #15]

  /* if from server */
  if ((pduType & ATT_PDU_MASK_SERVER) != 0)
   1d712:	7bfb      	ldrb	r3, [r7, #15]
   1d714:	f003 0301 	and.w	r3, r3, #1
   1d718:	2b00      	cmp	r3, #0
   1d71a:	d007      	beq.n	1d72c <attL2cDataCback+0x30>
  {
    /* call client data callback */
    (*attCb.pClient->dataCback)(handle, len, pPacket);
   1d71c:	4b09      	ldr	r3, [pc, #36]	; (1d744 <attL2cDataCback+0x48>)
   1d71e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   1d720:	681b      	ldr	r3, [r3, #0]
   1d722:	88b9      	ldrh	r1, [r7, #4]
   1d724:	88f8      	ldrh	r0, [r7, #6]
   1d726:	683a      	ldr	r2, [r7, #0]
   1d728:	4798      	blx	r3
  else
  {
    /* call server data callback */
    (*attCb.pServer->dataCback)(handle, len, pPacket);
  }
}
   1d72a:	e006      	b.n	1d73a <attL2cDataCback+0x3e>
    (*attCb.pServer->dataCback)(handle, len, pPacket);
   1d72c:	4b05      	ldr	r3, [pc, #20]	; (1d744 <attL2cDataCback+0x48>)
   1d72e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   1d730:	681b      	ldr	r3, [r3, #0]
   1d732:	88b9      	ldrh	r1, [r7, #4]
   1d734:	88f8      	ldrh	r0, [r7, #6]
   1d736:	683a      	ldr	r2, [r7, #0]
   1d738:	4798      	blx	r3
}
   1d73a:	bf00      	nop
   1d73c:	3710      	adds	r7, #16
   1d73e:	46bd      	mov	sp, r7
   1d740:	bd80      	pop	{r7, pc}
   1d742:	bf00      	nop
   1d744:	10011048 	.word	0x10011048

0001d748 <attL2cCtrlCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attL2cCtrlCback(wsfMsgHdr_t *pMsg)
{
   1d748:	b580      	push	{r7, lr}
   1d74a:	b084      	sub	sp, #16
   1d74c:	af00      	add	r7, sp, #0
   1d74e:	6078      	str	r0, [r7, #4]
  attCcb_t      *pCcb;

  /* get connection control block */
  pCcb = attCcbByConnId((dmConnId_t) pMsg->param);
   1d750:	687b      	ldr	r3, [r7, #4]
   1d752:	881b      	ldrh	r3, [r3, #0]
   1d754:	b2db      	uxtb	r3, r3
   1d756:	4618      	mov	r0, r3
   1d758:	f000 f8c0 	bl	1d8dc <attCcbByConnId>
   1d75c:	60f8      	str	r0, [r7, #12]

  /* verify connection is open */
  if (pCcb->connId != DM_CONN_ID_NONE)
   1d75e:	68fb      	ldr	r3, [r7, #12]
   1d760:	7f1b      	ldrb	r3, [r3, #28]
   1d762:	2b00      	cmp	r3, #0
   1d764:	d022      	beq.n	1d7ac <attL2cCtrlCback+0x64>
  {
    if (pMsg->event == L2C_CTRL_FLOW_DISABLE_IND)
   1d766:	687b      	ldr	r3, [r7, #4]
   1d768:	789b      	ldrb	r3, [r3, #2]
   1d76a:	2b01      	cmp	r3, #1
   1d76c:	d107      	bne.n	1d77e <attL2cCtrlCback+0x36>
    {
      /* flow disabled */
      pCcb->control |= ATT_CCB_STATUS_FLOW_DISABLED;
   1d76e:	68fb      	ldr	r3, [r7, #12]
   1d770:	7f5b      	ldrb	r3, [r3, #29]
   1d772:	f043 0302 	orr.w	r3, r3, #2
   1d776:	b2da      	uxtb	r2, r3
   1d778:	68fb      	ldr	r3, [r7, #12]
   1d77a:	775a      	strb	r2, [r3, #29]
        /* call client control callback */
        (*attCb.pClient->ctrlCback)(pMsg);
      }
    }
  }
}
   1d77c:	e016      	b.n	1d7ac <attL2cCtrlCback+0x64>
      pCcb->control &= ~ATT_CCB_STATUS_FLOW_DISABLED;
   1d77e:	68fb      	ldr	r3, [r7, #12]
   1d780:	7f5b      	ldrb	r3, [r3, #29]
   1d782:	f023 0302 	bic.w	r3, r3, #2
   1d786:	b2da      	uxtb	r2, r3
   1d788:	68fb      	ldr	r3, [r7, #12]
   1d78a:	775a      	strb	r2, [r3, #29]
      (*attCb.pServer->ctrlCback)(pMsg);
   1d78c:	4b09      	ldr	r3, [pc, #36]	; (1d7b4 <attL2cCtrlCback+0x6c>)
   1d78e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   1d790:	685b      	ldr	r3, [r3, #4]
   1d792:	6878      	ldr	r0, [r7, #4]
   1d794:	4798      	blx	r3
      if (!(pCcb->control & ATT_CCB_STATUS_FLOW_DISABLED))
   1d796:	68fb      	ldr	r3, [r7, #12]
   1d798:	7f5b      	ldrb	r3, [r3, #29]
   1d79a:	f003 0302 	and.w	r3, r3, #2
   1d79e:	2b00      	cmp	r3, #0
   1d7a0:	d104      	bne.n	1d7ac <attL2cCtrlCback+0x64>
        (*attCb.pClient->ctrlCback)(pMsg);
   1d7a2:	4b04      	ldr	r3, [pc, #16]	; (1d7b4 <attL2cCtrlCback+0x6c>)
   1d7a4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   1d7a6:	685b      	ldr	r3, [r3, #4]
   1d7a8:	6878      	ldr	r0, [r7, #4]
   1d7aa:	4798      	blx	r3
}
   1d7ac:	bf00      	nop
   1d7ae:	3710      	adds	r7, #16
   1d7b0:	46bd      	mov	sp, r7
   1d7b2:	bd80      	pop	{r7, pc}
   1d7b4:	10011048 	.word	0x10011048

0001d7b8 <attDmConnCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attDmConnCback(dmEvt_t *pDmEvt)
{
   1d7b8:	b580      	push	{r7, lr}
   1d7ba:	b084      	sub	sp, #16
   1d7bc:	af00      	add	r7, sp, #0
   1d7be:	6078      	str	r0, [r7, #4]
  attCcb_t  *pCcb;

  pCcb = attCcbByConnId((dmConnId_t) pDmEvt->hdr.param);
   1d7c0:	687b      	ldr	r3, [r7, #4]
   1d7c2:	881b      	ldrh	r3, [r3, #0]
   1d7c4:	b2db      	uxtb	r3, r3
   1d7c6:	4618      	mov	r0, r3
   1d7c8:	f000 f888 	bl	1d8dc <attCcbByConnId>
   1d7cc:	60f8      	str	r0, [r7, #12]

  /* if new connection created */
  if (pDmEvt->hdr.event == DM_CONN_OPEN_IND)
   1d7ce:	687b      	ldr	r3, [r7, #4]
   1d7d0:	789b      	ldrb	r3, [r3, #2]
   1d7d2:	2b27      	cmp	r3, #39	; 0x27
   1d7d4:	d111      	bne.n	1d7fa <attDmConnCback+0x42>
  {
    /* initialize control block before handling event */
    pCcb->handle = pDmEvt->connOpen.handle;
   1d7d6:	687b      	ldr	r3, [r7, #4]
   1d7d8:	88da      	ldrh	r2, [r3, #6]
   1d7da:	68fb      	ldr	r3, [r7, #12]
   1d7dc:	831a      	strh	r2, [r3, #24]
    pCcb->mtu = ATT_DEFAULT_MTU;
   1d7de:	68fb      	ldr	r3, [r7, #12]
   1d7e0:	2217      	movs	r2, #23
   1d7e2:	835a      	strh	r2, [r3, #26]
    pCcb->connId = (dmConnId_t) pDmEvt->hdr.param;
   1d7e4:	687b      	ldr	r3, [r7, #4]
   1d7e6:	881b      	ldrh	r3, [r3, #0]
   1d7e8:	b2da      	uxtb	r2, r3
   1d7ea:	68fb      	ldr	r3, [r7, #12]
   1d7ec:	771a      	strb	r2, [r3, #28]
    pCcb->control = 0;
   1d7ee:	68fb      	ldr	r3, [r7, #12]
   1d7f0:	2200      	movs	r2, #0
   1d7f2:	775a      	strb	r2, [r3, #29]
    pCcb->pPendDbHashRsp = NULL;
   1d7f4:	68fb      	ldr	r3, [r7, #12]
   1d7f6:	2200      	movs	r2, #0
   1d7f8:	621a      	str	r2, [r3, #32]
  }

  /* if connection has been opened */
  if (pCcb->connId != DM_CONN_ID_NONE)
   1d7fa:	68fb      	ldr	r3, [r7, #12]
   1d7fc:	7f1b      	ldrb	r3, [r3, #28]
   1d7fe:	2b00      	cmp	r3, #0
   1d800:	d01b      	beq.n	1d83a <attDmConnCback+0x82>
  {
    /* pass event to server */
    (*attCb.pServer->connCback)(pCcb, pDmEvt);
   1d802:	4b14      	ldr	r3, [pc, #80]	; (1d854 <attDmConnCback+0x9c>)
   1d804:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   1d806:	68db      	ldr	r3, [r3, #12]
   1d808:	6879      	ldr	r1, [r7, #4]
   1d80a:	68f8      	ldr	r0, [r7, #12]
   1d80c:	4798      	blx	r3

    /* pass event to client */
    (*attCb.pClient->connCback)(pCcb, pDmEvt);
   1d80e:	4b11      	ldr	r3, [pc, #68]	; (1d854 <attDmConnCback+0x9c>)
   1d810:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   1d812:	68db      	ldr	r3, [r3, #12]
   1d814:	6879      	ldr	r1, [r7, #4]
   1d816:	68f8      	ldr	r0, [r7, #12]
   1d818:	4798      	blx	r3

    /* if connection closed */
    if (pDmEvt->hdr.event == DM_CONN_CLOSE_IND)
   1d81a:	687b      	ldr	r3, [r7, #4]
   1d81c:	789b      	ldrb	r3, [r3, #2]
   1d81e:	2b28      	cmp	r3, #40	; 0x28
   1d820:	d10b      	bne.n	1d83a <attDmConnCback+0x82>
    {
      /* clear control block after handling event */
      pCcb->connId = DM_CONN_ID_NONE;
   1d822:	68fb      	ldr	r3, [r7, #12]
   1d824:	2200      	movs	r2, #0
   1d826:	771a      	strb	r2, [r3, #28]

      if (pCcb->pPendDbHashRsp)
   1d828:	68fb      	ldr	r3, [r7, #12]
   1d82a:	6a1b      	ldr	r3, [r3, #32]
   1d82c:	2b00      	cmp	r3, #0
   1d82e:	d004      	beq.n	1d83a <attDmConnCback+0x82>
      {
        WsfBufFree(pCcb->pPendDbHashRsp);
   1d830:	68fb      	ldr	r3, [r7, #12]
   1d832:	6a1b      	ldr	r3, [r3, #32]
   1d834:	4618      	mov	r0, r3
   1d836:	f00f fbeb 	bl	2d010 <WsfBufFree>
      }
    }
  }

  /* execute ATT connection callback */
  if (attCb.connCback != NULL)
   1d83a:	4b06      	ldr	r3, [pc, #24]	; (1d854 <attDmConnCback+0x9c>)
   1d83c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   1d83e:	2b00      	cmp	r3, #0
   1d840:	d003      	beq.n	1d84a <attDmConnCback+0x92>
  {
    (*attCb.connCback)(pDmEvt);
   1d842:	4b04      	ldr	r3, [pc, #16]	; (1d854 <attDmConnCback+0x9c>)
   1d844:	6f9b      	ldr	r3, [r3, #120]	; 0x78
   1d846:	6878      	ldr	r0, [r7, #4]
   1d848:	4798      	blx	r3
  }
}
   1d84a:	bf00      	nop
   1d84c:	3710      	adds	r7, #16
   1d84e:	46bd      	mov	sp, r7
   1d850:	bd80      	pop	{r7, pc}
   1d852:	bf00      	nop
   1d854:	10011048 	.word	0x10011048

0001d858 <attEmptyHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attEmptyHandler(wsfMsgHdr_t *pMsg)
{
   1d858:	b480      	push	{r7}
   1d85a:	b083      	sub	sp, #12
   1d85c:	af00      	add	r7, sp, #0
   1d85e:	6078      	str	r0, [r7, #4]
  return;
   1d860:	bf00      	nop
}
   1d862:	370c      	adds	r7, #12
   1d864:	46bd      	mov	sp, r7
   1d866:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d86a:	4770      	bx	lr

0001d86c <attEmptyConnCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attEmptyConnCback(attCcb_t *pCcb, dmEvt_t *pDmEvt)
{
   1d86c:	b480      	push	{r7}
   1d86e:	b083      	sub	sp, #12
   1d870:	af00      	add	r7, sp, #0
   1d872:	6078      	str	r0, [r7, #4]
   1d874:	6039      	str	r1, [r7, #0]
  return;
   1d876:	bf00      	nop
}
   1d878:	370c      	adds	r7, #12
   1d87a:	46bd      	mov	sp, r7
   1d87c:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d880:	4770      	bx	lr

0001d882 <attEmptyDataCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attEmptyDataCback(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   1d882:	b480      	push	{r7}
   1d884:	b083      	sub	sp, #12
   1d886:	af00      	add	r7, sp, #0
   1d888:	4603      	mov	r3, r0
   1d88a:	603a      	str	r2, [r7, #0]
   1d88c:	80fb      	strh	r3, [r7, #6]
   1d88e:	460b      	mov	r3, r1
   1d890:	80bb      	strh	r3, [r7, #4]
  return;
   1d892:	bf00      	nop
}
   1d894:	370c      	adds	r7, #12
   1d896:	46bd      	mov	sp, r7
   1d898:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d89c:	4770      	bx	lr
	...

0001d8a0 <attCcbByHandle>:
 *
 *  \return Pointer to connection control block or NULL if not found.
 */
/*************************************************************************************************/
attCcb_t *attCcbByHandle(uint16_t handle)
{
   1d8a0:	b580      	push	{r7, lr}
   1d8a2:	b084      	sub	sp, #16
   1d8a4:	af00      	add	r7, sp, #0
   1d8a6:	4603      	mov	r3, r0
   1d8a8:	80fb      	strh	r3, [r7, #6]
  dmConnId_t  connId;

  if ((connId = DmConnIdByHandle(handle)) != DM_CONN_ID_NONE)
   1d8aa:	88fb      	ldrh	r3, [r7, #6]
   1d8ac:	4618      	mov	r0, r3
   1d8ae:	f005 fde3 	bl	23478 <DmConnIdByHandle>
   1d8b2:	4603      	mov	r3, r0
   1d8b4:	73fb      	strb	r3, [r7, #15]
   1d8b6:	7bfb      	ldrb	r3, [r7, #15]
   1d8b8:	2b00      	cmp	r3, #0
   1d8ba:	d008      	beq.n	1d8ce <attCcbByHandle+0x2e>
  {
    return &attCb.ccb[connId - 1];
   1d8bc:	7bfb      	ldrb	r3, [r7, #15]
   1d8be:	1e5a      	subs	r2, r3, #1
   1d8c0:	4613      	mov	r3, r2
   1d8c2:	00db      	lsls	r3, r3, #3
   1d8c4:	4413      	add	r3, r2
   1d8c6:	009b      	lsls	r3, r3, #2
   1d8c8:	4a03      	ldr	r2, [pc, #12]	; (1d8d8 <attCcbByHandle+0x38>)
   1d8ca:	4413      	add	r3, r2
   1d8cc:	e000      	b.n	1d8d0 <attCcbByHandle+0x30>
  }

  return NULL;
   1d8ce:	2300      	movs	r3, #0
}
   1d8d0:	4618      	mov	r0, r3
   1d8d2:	3710      	adds	r7, #16
   1d8d4:	46bd      	mov	sp, r7
   1d8d6:	bd80      	pop	{r7, pc}
   1d8d8:	10011048 	.word	0x10011048

0001d8dc <attCcbByConnId>:
 *
 *  \return Pointer to connection control block.
 */
/*************************************************************************************************/
attCcb_t *attCcbByConnId(dmConnId_t connId)
{
   1d8dc:	b480      	push	{r7}
   1d8de:	b083      	sub	sp, #12
   1d8e0:	af00      	add	r7, sp, #0
   1d8e2:	4603      	mov	r3, r0
   1d8e4:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return &attCb.ccb[connId - 1];
   1d8e6:	79fb      	ldrb	r3, [r7, #7]
   1d8e8:	1e5a      	subs	r2, r3, #1
   1d8ea:	4613      	mov	r3, r2
   1d8ec:	00db      	lsls	r3, r3, #3
   1d8ee:	4413      	add	r3, r2
   1d8f0:	009b      	lsls	r3, r3, #2
   1d8f2:	4a04      	ldr	r2, [pc, #16]	; (1d904 <attCcbByConnId+0x28>)
   1d8f4:	4413      	add	r3, r2
}
   1d8f6:	4618      	mov	r0, r3
   1d8f8:	370c      	adds	r7, #12
   1d8fa:	46bd      	mov	sp, r7
   1d8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
   1d900:	4770      	bx	lr
   1d902:	bf00      	nop
   1d904:	10011048 	.word	0x10011048

0001d908 <attUuidCmp16to128>:
 *
 *  \return TRUE of UUIDs match, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t attUuidCmp16to128(const uint8_t *pUuid16, const uint8_t *pUuid128)
{
   1d908:	b580      	push	{r7, lr}
   1d90a:	b082      	sub	sp, #8
   1d90c:	af00      	add	r7, sp, #0
   1d90e:	6078      	str	r0, [r7, #4]
   1d910:	6039      	str	r1, [r7, #0]
  attBaseUuid[ATT_BASE_UUID_POS_0] = pUuid16[0];
   1d912:	687b      	ldr	r3, [r7, #4]
   1d914:	781a      	ldrb	r2, [r3, #0]
   1d916:	4b0a      	ldr	r3, [pc, #40]	; (1d940 <attUuidCmp16to128+0x38>)
   1d918:	731a      	strb	r2, [r3, #12]
  attBaseUuid[ATT_BASE_UUID_POS_1] = pUuid16[1];
   1d91a:	687b      	ldr	r3, [r7, #4]
   1d91c:	785a      	ldrb	r2, [r3, #1]
   1d91e:	4b08      	ldr	r3, [pc, #32]	; (1d940 <attUuidCmp16to128+0x38>)
   1d920:	735a      	strb	r2, [r3, #13]

  return (memcmp(attBaseUuid, pUuid128, ATT_128_UUID_LEN) == 0);
   1d922:	2210      	movs	r2, #16
   1d924:	6839      	ldr	r1, [r7, #0]
   1d926:	4806      	ldr	r0, [pc, #24]	; (1d940 <attUuidCmp16to128+0x38>)
   1d928:	f012 fb46 	bl	2ffb8 <memcmp>
   1d92c:	4603      	mov	r3, r0
   1d92e:	2b00      	cmp	r3, #0
   1d930:	bf0c      	ite	eq
   1d932:	2301      	moveq	r3, #1
   1d934:	2300      	movne	r3, #0
   1d936:	b2db      	uxtb	r3, r3
}
   1d938:	4618      	mov	r0, r3
   1d93a:	3708      	adds	r7, #8
   1d93c:	46bd      	mov	sp, r7
   1d93e:	bd80      	pop	{r7, pc}
   1d940:	10002b38 	.word	0x10002b38

0001d944 <attSetMtu>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attSetMtu(attCcb_t *pCcb, uint16_t peerMtu, uint16_t localMtu)
{
   1d944:	b580      	push	{r7, lr}
   1d946:	b086      	sub	sp, #24
   1d948:	af02      	add	r7, sp, #8
   1d94a:	6078      	str	r0, [r7, #4]
   1d94c:	460b      	mov	r3, r1
   1d94e:	807b      	strh	r3, [r7, #2]
   1d950:	4613      	mov	r3, r2
   1d952:	803b      	strh	r3, [r7, #0]
  uint16_t  mtu;

  /* set negotiated mtu for the connection to the lesser of ours and theirs */
  mtu = WSF_MIN(peerMtu, localMtu);
   1d954:	883a      	ldrh	r2, [r7, #0]
   1d956:	887b      	ldrh	r3, [r7, #2]
   1d958:	4293      	cmp	r3, r2
   1d95a:	bf28      	it	cs
   1d95c:	4613      	movcs	r3, r2
   1d95e:	81fb      	strh	r3, [r7, #14]

  /* if current mtu is not the same as the negotiated value */
  if (pCcb->mtu != mtu)
   1d960:	687b      	ldr	r3, [r7, #4]
   1d962:	8b5b      	ldrh	r3, [r3, #26]
   1d964:	89fa      	ldrh	r2, [r7, #14]
   1d966:	429a      	cmp	r2, r3
   1d968:	d00b      	beq.n	1d982 <attSetMtu+0x3e>
  {
    /* set mtu to the new value */
    pCcb->mtu = mtu;
   1d96a:	687b      	ldr	r3, [r7, #4]
   1d96c:	89fa      	ldrh	r2, [r7, #14]
   1d96e:	835a      	strh	r2, [r3, #26]

    /* notify app about the new value */
    attExecCallback(pCcb->connId, ATT_MTU_UPDATE_IND, 0, ATT_SUCCESS, mtu);
   1d970:	687b      	ldr	r3, [r7, #4]
   1d972:	7f18      	ldrb	r0, [r3, #28]
   1d974:	89fb      	ldrh	r3, [r7, #14]
   1d976:	9300      	str	r3, [sp, #0]
   1d978:	2300      	movs	r3, #0
   1d97a:	2200      	movs	r2, #0
   1d97c:	2112      	movs	r1, #18
   1d97e:	f000 f805 	bl	1d98c <attExecCallback>
  }
}
   1d982:	bf00      	nop
   1d984:	3710      	adds	r7, #16
   1d986:	46bd      	mov	sp, r7
   1d988:	bd80      	pop	{r7, pc}
	...

0001d98c <attExecCallback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attExecCallback(dmConnId_t connId, uint8_t event, uint16_t handle, uint8_t status, uint16_t mtu)
{
   1d98c:	b590      	push	{r4, r7, lr}
   1d98e:	b087      	sub	sp, #28
   1d990:	af00      	add	r7, sp, #0
   1d992:	4604      	mov	r4, r0
   1d994:	4608      	mov	r0, r1
   1d996:	4611      	mov	r1, r2
   1d998:	461a      	mov	r2, r3
   1d99a:	4623      	mov	r3, r4
   1d99c:	71fb      	strb	r3, [r7, #7]
   1d99e:	4603      	mov	r3, r0
   1d9a0:	71bb      	strb	r3, [r7, #6]
   1d9a2:	460b      	mov	r3, r1
   1d9a4:	80bb      	strh	r3, [r7, #4]
   1d9a6:	4613      	mov	r3, r2
   1d9a8:	70fb      	strb	r3, [r7, #3]
  if (attCb.cback)
   1d9aa:	4b0e      	ldr	r3, [pc, #56]	; (1d9e4 <attExecCallback+0x58>)
   1d9ac:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1d9ae:	2b00      	cmp	r3, #0
   1d9b0:	d014      	beq.n	1d9dc <attExecCallback+0x50>
  {
    attEvt_t evt;

    evt.hdr.param = connId;
   1d9b2:	79fb      	ldrb	r3, [r7, #7]
   1d9b4:	b29b      	uxth	r3, r3
   1d9b6:	813b      	strh	r3, [r7, #8]
    evt.hdr.event = event;
   1d9b8:	79bb      	ldrb	r3, [r7, #6]
   1d9ba:	72bb      	strb	r3, [r7, #10]
    evt.hdr.status = status;
   1d9bc:	78fb      	ldrb	r3, [r7, #3]
   1d9be:	72fb      	strb	r3, [r7, #11]
    evt.valueLen = 0;
   1d9c0:	2300      	movs	r3, #0
   1d9c2:	823b      	strh	r3, [r7, #16]
    evt.handle = handle;
   1d9c4:	88bb      	ldrh	r3, [r7, #4]
   1d9c6:	827b      	strh	r3, [r7, #18]
    evt.continuing = 0;
   1d9c8:	2300      	movs	r3, #0
   1d9ca:	753b      	strb	r3, [r7, #20]
    evt.mtu = mtu;
   1d9cc:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   1d9ce:	82fb      	strh	r3, [r7, #22]

    (*attCb.cback)(&evt);
   1d9d0:	4b04      	ldr	r3, [pc, #16]	; (1d9e4 <attExecCallback+0x58>)
   1d9d2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1d9d4:	f107 0208 	add.w	r2, r7, #8
   1d9d8:	4610      	mov	r0, r2
   1d9da:	4798      	blx	r3
  }
}
   1d9dc:	bf00      	nop
   1d9de:	371c      	adds	r7, #28
   1d9e0:	46bd      	mov	sp, r7
   1d9e2:	bd90      	pop	{r4, r7, pc}
   1d9e4:	10011048 	.word	0x10011048

0001d9e8 <attMsgAlloc>:
 *
 *  \return Pointer to data message buffer or NULL if allocation failed.
 */
/*************************************************************************************************/
void *attMsgAlloc(uint16_t len)
{
   1d9e8:	b580      	push	{r7, lr}
   1d9ea:	b082      	sub	sp, #8
   1d9ec:	af00      	add	r7, sp, #0
   1d9ee:	4603      	mov	r3, r0
   1d9f0:	80fb      	strh	r3, [r7, #6]
  return WsfMsgDataAlloc(len, HCI_TX_DATA_TAILROOM);
   1d9f2:	88fb      	ldrh	r3, [r7, #6]
   1d9f4:	2100      	movs	r1, #0
   1d9f6:	4618      	mov	r0, r3
   1d9f8:	f00f fb44 	bl	2d084 <WsfMsgDataAlloc>
   1d9fc:	4603      	mov	r3, r0
}
   1d9fe:	4618      	mov	r0, r3
   1da00:	3708      	adds	r7, #8
   1da02:	46bd      	mov	sp, r7
   1da04:	bd80      	pop	{r7, pc}
	...

0001da08 <AttHandlerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttHandlerInit(wsfHandlerId_t handlerId)
{
   1da08:	b580      	push	{r7, lr}
   1da0a:	b082      	sub	sp, #8
   1da0c:	af00      	add	r7, sp, #0
   1da0e:	4603      	mov	r3, r0
   1da10:	71fb      	strb	r3, [r7, #7]
  /* store handler ID */
  attCb.handlerId = handlerId;
   1da12:	4a0b      	ldr	r2, [pc, #44]	; (1da40 <AttHandlerInit+0x38>)
   1da14:	79fb      	ldrb	r3, [r7, #7]
   1da16:	f882 307c 	strb.w	r3, [r2, #124]	; 0x7c

  /* initialize control block */
  attCb.pClient = &attFcnDefault;
   1da1a:	4b09      	ldr	r3, [pc, #36]	; (1da40 <AttHandlerInit+0x38>)
   1da1c:	4a09      	ldr	r2, [pc, #36]	; (1da44 <AttHandlerInit+0x3c>)
   1da1e:	66da      	str	r2, [r3, #108]	; 0x6c
  attCb.pServer = &attFcnDefault;
   1da20:	4b07      	ldr	r3, [pc, #28]	; (1da40 <AttHandlerInit+0x38>)
   1da22:	4a08      	ldr	r2, [pc, #32]	; (1da44 <AttHandlerInit+0x3c>)
   1da24:	671a      	str	r2, [r3, #112]	; 0x70

  /* Register with L2C */
  L2cRegister(L2C_CID_ATT,  attL2cDataCback, attL2cCtrlCback);
   1da26:	4a08      	ldr	r2, [pc, #32]	; (1da48 <AttHandlerInit+0x40>)
   1da28:	4908      	ldr	r1, [pc, #32]	; (1da4c <AttHandlerInit+0x44>)
   1da2a:	2004      	movs	r0, #4
   1da2c:	f00c fa3c 	bl	29ea8 <L2cRegister>

  /* Register with DM */
  DmConnRegister(DM_CLIENT_ID_ATT, attDmConnCback);
   1da30:	4907      	ldr	r1, [pc, #28]	; (1da50 <AttHandlerInit+0x48>)
   1da32:	2000      	movs	r0, #0
   1da34:	f005 fbde 	bl	231f4 <DmConnRegister>

}
   1da38:	bf00      	nop
   1da3a:	3708      	adds	r7, #8
   1da3c:	46bd      	mov	sp, r7
   1da3e:	bd80      	pop	{r7, pc}
   1da40:	10011048 	.word	0x10011048
   1da44:	00045ab4 	.word	0x00045ab4
   1da48:	0001d749 	.word	0x0001d749
   1da4c:	0001d6fd 	.word	0x0001d6fd
   1da50:	0001d7b9 	.word	0x0001d7b9

0001da54 <AttHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   1da54:	b580      	push	{r7, lr}
   1da56:	b082      	sub	sp, #8
   1da58:	af00      	add	r7, sp, #0
   1da5a:	4603      	mov	r3, r0
   1da5c:	6039      	str	r1, [r7, #0]
   1da5e:	71fb      	strb	r3, [r7, #7]
  /* Handle message */
  if (pMsg != NULL)
   1da60:	683b      	ldr	r3, [r7, #0]
   1da62:	2b00      	cmp	r3, #0
   1da64:	d00e      	beq.n	1da84 <AttHandler+0x30>
  {
    if (pMsg->event >= ATTS_MSG_START)
   1da66:	683b      	ldr	r3, [r7, #0]
   1da68:	789b      	ldrb	r3, [r3, #2]
   1da6a:	2b1f      	cmp	r3, #31
   1da6c:	d905      	bls.n	1da7a <AttHandler+0x26>
    {
      /* pass event to server */
      (*attCb.pServer->msgCback)(pMsg);
   1da6e:	4b07      	ldr	r3, [pc, #28]	; (1da8c <AttHandler+0x38>)
   1da70:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   1da72:	689b      	ldr	r3, [r3, #8]
   1da74:	6838      	ldr	r0, [r7, #0]
   1da76:	4798      	blx	r3
  /* Handle events */
  else if (event)
  {

  }
}
   1da78:	e004      	b.n	1da84 <AttHandler+0x30>
      (*attCb.pClient->msgCback)(pMsg);
   1da7a:	4b04      	ldr	r3, [pc, #16]	; (1da8c <AttHandler+0x38>)
   1da7c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
   1da7e:	689b      	ldr	r3, [r3, #8]
   1da80:	6838      	ldr	r0, [r7, #0]
   1da82:	4798      	blx	r3
}
   1da84:	bf00      	nop
   1da86:	3708      	adds	r7, #8
   1da88:	46bd      	mov	sp, r7
   1da8a:	bd80      	pop	{r7, pc}
   1da8c:	10011048 	.word	0x10011048

0001da90 <AttRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttRegister(attCback_t cback)
{
   1da90:	b580      	push	{r7, lr}
   1da92:	b084      	sub	sp, #16
   1da94:	af02      	add	r7, sp, #8
   1da96:	6078      	str	r0, [r7, #4]
  attCb.cback = cback;
   1da98:	4a0b      	ldr	r2, [pc, #44]	; (1dac8 <AttRegister+0x38>)
   1da9a:	687b      	ldr	r3, [r7, #4]
   1da9c:	6753      	str	r3, [r2, #116]	; 0x74

  /* if configured MTU size is larger than maximum RX PDU length */
  if (pAttCfg->mtu > (HciGetMaxRxAclLen() - L2C_HDR_LEN))
   1da9e:	f008 fce3 	bl	26468 <HciGetMaxRxAclLen>
   1daa2:	4603      	mov	r3, r0
   1daa4:	3b03      	subs	r3, #3
   1daa6:	4a09      	ldr	r2, [pc, #36]	; (1dacc <AttRegister+0x3c>)
   1daa8:	6812      	ldr	r2, [r2, #0]
   1daaa:	8892      	ldrh	r2, [r2, #4]
   1daac:	4293      	cmp	r3, r2
   1daae:	dc07      	bgt.n	1dac0 <AttRegister+0x30>
  {
    /* notify app about MTU misconfiguration */
    attExecCallback(0, DM_ERROR_IND, 0, DM_ERR_ATT_RX_PDU_LEN_EXCEEDED, 0);
   1dab0:	2300      	movs	r3, #0
   1dab2:	9300      	str	r3, [sp, #0]
   1dab4:	2302      	movs	r3, #2
   1dab6:	2200      	movs	r2, #0
   1dab8:	2165      	movs	r1, #101	; 0x65
   1daba:	2000      	movs	r0, #0
   1dabc:	f7ff ff66 	bl	1d98c <attExecCallback>
  }
}
   1dac0:	bf00      	nop
   1dac2:	3708      	adds	r7, #8
   1dac4:	46bd      	mov	sp, r7
   1dac6:	bd80      	pop	{r7, pc}
   1dac8:	10011048 	.word	0x10011048
   1dacc:	10002b8c 	.word	0x10002b8c

0001dad0 <AttGetMtu>:
 *
 *  \return MTU of the connection.
 */
/*************************************************************************************************/
uint16_t AttGetMtu(dmConnId_t connId)
{
   1dad0:	b580      	push	{r7, lr}
   1dad2:	b082      	sub	sp, #8
   1dad4:	af00      	add	r7, sp, #0
   1dad6:	4603      	mov	r3, r0
   1dad8:	71fb      	strb	r3, [r7, #7]
  return (attCcbByConnId(connId)->mtu);
   1dada:	79fb      	ldrb	r3, [r7, #7]
   1dadc:	4618      	mov	r0, r3
   1dade:	f7ff fefd 	bl	1d8dc <attCcbByConnId>
   1dae2:	4603      	mov	r3, r0
   1dae4:	8b5b      	ldrh	r3, [r3, #26]
}
   1dae6:	4618      	mov	r0, r3
   1dae8:	3708      	adds	r7, #8
   1daea:	46bd      	mov	sp, r7
   1daec:	bd80      	pop	{r7, pc}

0001daee <AttMsgFree>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttMsgFree(void *pMsg, uint8_t opcode)
{
   1daee:	b580      	push	{r7, lr}
   1daf0:	b084      	sub	sp, #16
   1daf2:	af00      	add	r7, sp, #0
   1daf4:	6078      	str	r0, [r7, #4]
   1daf6:	460b      	mov	r3, r1
   1daf8:	70fb      	strb	r3, [r7, #3]
  uint8_t  hdrLen;

  WSF_ASSERT((opcode == ATT_PDU_VALUE_IND) || (opcode == ATT_PDU_VALUE_NTF));

  switch (opcode)
   1dafa:	78fb      	ldrb	r3, [r7, #3]
   1dafc:	2b1b      	cmp	r3, #27
   1dafe:	d001      	beq.n	1db04 <AttMsgFree+0x16>
   1db00:	2b1d      	cmp	r3, #29
   1db02:	d102      	bne.n	1db0a <AttMsgFree+0x1c>
  {
    case ATT_PDU_VALUE_IND:
    case ATT_PDU_VALUE_NTF:
      hdrLen = ATT_VALUE_IND_NTF_BUF_LEN;
   1db04:	230b      	movs	r3, #11
   1db06:	73fb      	strb	r3, [r7, #15]
      break;
   1db08:	e002      	b.n	1db10 <AttMsgFree+0x22>

    default:
      hdrLen = 0;
   1db0a:	2300      	movs	r3, #0
   1db0c:	73fb      	strb	r3, [r7, #15]
      break;
   1db0e:	bf00      	nop
  }

  WsfMsgFree(((uint8_t *)pMsg) - hdrLen);
   1db10:	7bfb      	ldrb	r3, [r7, #15]
   1db12:	425b      	negs	r3, r3
   1db14:	687a      	ldr	r2, [r7, #4]
   1db16:	4413      	add	r3, r2
   1db18:	4618      	mov	r0, r3
   1db1a:	f00f fadf 	bl	2d0dc <WsfMsgFree>
}
   1db1e:	bf00      	nop
   1db20:	3710      	adds	r7, #16
   1db22:	46bd      	mov	sp, r7
   1db24:	bd80      	pop	{r7, pc}

0001db26 <attcPendWriteCmd>:
 *  \return TRUE if app callback's pending or maximum number of simultaneous write commands reached.
 *          FALSE, otherwise.
 */
/*************************************************************************************************/
static bool_t attcPendWriteCmd(attcCcb_t *pCcb, attcApiMsg_t *pMsg)
{
   1db26:	b480      	push	{r7}
   1db28:	b085      	sub	sp, #20
   1db2a:	af00      	add	r7, sp, #0
   1db2c:	6078      	str	r0, [r7, #4]
   1db2e:	6039      	str	r1, [r7, #0]
  uint8_t     pendRsp;
  uint8_t     i;

  /* initialize number of response callbacks pending */
  pendRsp = 0;
   1db30:	2300      	movs	r3, #0
   1db32:	73fb      	strb	r3, [r7, #15]

  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1db34:	2300      	movs	r3, #0
   1db36:	73bb      	strb	r3, [r7, #14]
   1db38:	e019      	b.n	1db6e <attcPendWriteCmd+0x48>
  {
    /* if callback pending for write command */
    if (pCcb->pendWriteCmdHandle[i] != ATT_HANDLE_NONE)
   1db3a:	7bbb      	ldrb	r3, [r7, #14]
   1db3c:	687a      	ldr	r2, [r7, #4]
   1db3e:	3318      	adds	r3, #24
   1db40:	005b      	lsls	r3, r3, #1
   1db42:	4413      	add	r3, r2
   1db44:	88db      	ldrh	r3, [r3, #6]
   1db46:	2b00      	cmp	r3, #0
   1db48:	d00e      	beq.n	1db68 <attcPendWriteCmd+0x42>
    {
      /* if callback pending for this handle */
      if (pCcb->pendWriteCmdHandle[i] == pMsg->handle)
   1db4a:	7bbb      	ldrb	r3, [r7, #14]
   1db4c:	687a      	ldr	r2, [r7, #4]
   1db4e:	3318      	adds	r3, #24
   1db50:	005b      	lsls	r3, r3, #1
   1db52:	4413      	add	r3, r2
   1db54:	88da      	ldrh	r2, [r3, #6]
   1db56:	683b      	ldr	r3, [r7, #0]
   1db58:	891b      	ldrh	r3, [r3, #8]
   1db5a:	429a      	cmp	r2, r3
   1db5c:	d101      	bne.n	1db62 <attcPendWriteCmd+0x3c>
      {
        /* callback pending for this write command */
        return TRUE;
   1db5e:	2301      	movs	r3, #1
   1db60:	e00e      	b.n	1db80 <attcPendWriteCmd+0x5a>
      }

      pendRsp++;
   1db62:	7bfb      	ldrb	r3, [r7, #15]
   1db64:	3301      	adds	r3, #1
   1db66:	73fb      	strb	r3, [r7, #15]
  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1db68:	7bbb      	ldrb	r3, [r7, #14]
   1db6a:	3301      	adds	r3, #1
   1db6c:	73bb      	strb	r3, [r7, #14]
   1db6e:	7bbb      	ldrb	r3, [r7, #14]
   1db70:	2b00      	cmp	r3, #0
   1db72:	d0e2      	beq.n	1db3a <attcPendWriteCmd+0x14>
    }
  }

  /* no callback is pending for this write command but see if the maximum number of simultaneous
     write commands has been reached */
  return (pendRsp < ATT_NUM_SIMUL_WRITE_CMD) ? FALSE : TRUE;
   1db74:	7bfb      	ldrb	r3, [r7, #15]
   1db76:	2b00      	cmp	r3, #0
   1db78:	bf14      	ite	ne
   1db7a:	2301      	movne	r3, #1
   1db7c:	2300      	moveq	r3, #0
   1db7e:	b2db      	uxtb	r3, r3
}
   1db80:	4618      	mov	r0, r3
   1db82:	3714      	adds	r7, #20
   1db84:	46bd      	mov	sp, r7
   1db86:	f85d 7b04 	ldr.w	r7, [sp], #4
   1db8a:	4770      	bx	lr

0001db8c <attcSetPendWriteCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSetPendWriteCmd(attcCcb_t *pCcb)
{
   1db8c:	b480      	push	{r7}
   1db8e:	b085      	sub	sp, #20
   1db90:	af00      	add	r7, sp, #0
   1db92:	6078      	str	r0, [r7, #4]
  uint8_t     i;

  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1db94:	2300      	movs	r3, #0
   1db96:	73fb      	strb	r3, [r7, #15]
   1db98:	e014      	b.n	1dbc4 <attcSetPendWriteCmd+0x38>
  {
    /* if entry free */
    if (pCcb->pendWriteCmdHandle[i] == ATT_HANDLE_NONE)
   1db9a:	7bfb      	ldrb	r3, [r7, #15]
   1db9c:	687a      	ldr	r2, [r7, #4]
   1db9e:	3318      	adds	r3, #24
   1dba0:	005b      	lsls	r3, r3, #1
   1dba2:	4413      	add	r3, r2
   1dba4:	88db      	ldrh	r3, [r3, #6]
   1dba6:	2b00      	cmp	r3, #0
   1dba8:	d109      	bne.n	1dbbe <attcSetPendWriteCmd+0x32>
    {
      /* set pending write command handle */
      pCcb->pendWriteCmdHandle[i] = pCcb->outReq.handle;
   1dbaa:	7bfb      	ldrb	r3, [r7, #15]
   1dbac:	687a      	ldr	r2, [r7, #4]
   1dbae:	8b11      	ldrh	r1, [r2, #24]
   1dbb0:	687a      	ldr	r2, [r7, #4]
   1dbb2:	3318      	adds	r3, #24
   1dbb4:	005b      	lsls	r3, r3, #1
   1dbb6:	4413      	add	r3, r2
   1dbb8:	460a      	mov	r2, r1
   1dbba:	80da      	strh	r2, [r3, #6]
      break;
   1dbbc:	e006      	b.n	1dbcc <attcSetPendWriteCmd+0x40>
  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1dbbe:	7bfb      	ldrb	r3, [r7, #15]
   1dbc0:	3301      	adds	r3, #1
   1dbc2:	73fb      	strb	r3, [r7, #15]
   1dbc4:	7bfb      	ldrb	r3, [r7, #15]
   1dbc6:	2b00      	cmp	r3, #0
   1dbc8:	d0e7      	beq.n	1db9a <attcSetPendWriteCmd+0xe>
    }
  }
}
   1dbca:	bf00      	nop
   1dbcc:	bf00      	nop
   1dbce:	3714      	adds	r7, #20
   1dbd0:	46bd      	mov	sp, r7
   1dbd2:	f85d 7b04 	ldr.w	r7, [sp], #4
   1dbd6:	4770      	bx	lr

0001dbd8 <attcWriteCmdCallback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcWriteCmdCallback(dmConnId_t connId, attcCcb_t *pCcb, uint8_t status)
{
   1dbd8:	b580      	push	{r7, lr}
   1dbda:	b084      	sub	sp, #16
   1dbdc:	af00      	add	r7, sp, #0
   1dbde:	4603      	mov	r3, r0
   1dbe0:	6039      	str	r1, [r7, #0]
   1dbe2:	71fb      	strb	r3, [r7, #7]
   1dbe4:	4613      	mov	r3, r2
   1dbe6:	71bb      	strb	r3, [r7, #6]
  uint8_t     i;

  /* if any pending write command callback */
  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1dbe8:	2300      	movs	r3, #0
   1dbea:	73fb      	strb	r3, [r7, #15]
   1dbec:	e01c      	b.n	1dc28 <attcWriteCmdCallback+0x50>
  {
    if (pCcb->pendWriteCmdHandle[i] != ATT_HANDLE_NONE)
   1dbee:	7bfb      	ldrb	r3, [r7, #15]
   1dbf0:	683a      	ldr	r2, [r7, #0]
   1dbf2:	3318      	adds	r3, #24
   1dbf4:	005b      	lsls	r3, r3, #1
   1dbf6:	4413      	add	r3, r2
   1dbf8:	88db      	ldrh	r3, [r3, #6]
   1dbfa:	2b00      	cmp	r3, #0
   1dbfc:	d011      	beq.n	1dc22 <attcWriteCmdCallback+0x4a>
    {
      /* call callback with status */
      attcExecCallback(connId, ATTC_WRITE_CMD_RSP, pCcb->pendWriteCmdHandle[i], status);
   1dbfe:	7bfb      	ldrb	r3, [r7, #15]
   1dc00:	683a      	ldr	r2, [r7, #0]
   1dc02:	3318      	adds	r3, #24
   1dc04:	005b      	lsls	r3, r3, #1
   1dc06:	4413      	add	r3, r2
   1dc08:	88da      	ldrh	r2, [r3, #6]
   1dc0a:	79bb      	ldrb	r3, [r7, #6]
   1dc0c:	79f8      	ldrb	r0, [r7, #7]
   1dc0e:	210a      	movs	r1, #10
   1dc10:	f000 fba8 	bl	1e364 <attcExecCallback>
      pCcb->pendWriteCmdHandle[i] = ATT_HANDLE_NONE;
   1dc14:	7bfb      	ldrb	r3, [r7, #15]
   1dc16:	683a      	ldr	r2, [r7, #0]
   1dc18:	3318      	adds	r3, #24
   1dc1a:	005b      	lsls	r3, r3, #1
   1dc1c:	4413      	add	r3, r2
   1dc1e:	2200      	movs	r2, #0
   1dc20:	80da      	strh	r2, [r3, #6]
  for (i = 0; i < ATT_NUM_SIMUL_WRITE_CMD; i++)
   1dc22:	7bfb      	ldrb	r3, [r7, #15]
   1dc24:	3301      	adds	r3, #1
   1dc26:	73fb      	strb	r3, [r7, #15]
   1dc28:	7bfb      	ldrb	r3, [r7, #15]
   1dc2a:	2b00      	cmp	r3, #0
   1dc2c:	d0df      	beq.n	1dbee <attcWriteCmdCallback+0x16>
    }
  }
}
   1dc2e:	bf00      	nop
   1dc30:	bf00      	nop
   1dc32:	3710      	adds	r7, #16
   1dc34:	46bd      	mov	sp, r7
   1dc36:	bd80      	pop	{r7, pc}

0001dc38 <attcSendSimpleReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSendSimpleReq(attcCcb_t *pCcb)
{
   1dc38:	b580      	push	{r7, lr}
   1dc3a:	b084      	sub	sp, #16
   1dc3c:	af00      	add	r7, sp, #0
   1dc3e:	6078      	str	r0, [r7, #4]
  attcPktParam_t  *pPkt = pCcb->outReq.pPkt;
   1dc40:	687b      	ldr	r3, [r7, #4]
   1dc42:	695b      	ldr	r3, [r3, #20]
   1dc44:	60fb      	str	r3, [r7, #12]

  /* clear stored packet pointer */
  pCcb->outReq.pPkt = NULL;
   1dc46:	687b      	ldr	r3, [r7, #4]
   1dc48:	2200      	movs	r2, #0
   1dc4a:	615a      	str	r2, [r3, #20]

  /* start request timer (except for write command) */
  if (pCcb->outReq.hdr.event != ATTC_MSG_API_WRITE_CMD)
   1dc4c:	687b      	ldr	r3, [r7, #4]
   1dc4e:	7c9b      	ldrb	r3, [r3, #18]
   1dc50:	2b0a      	cmp	r3, #10
   1dc52:	d00d      	beq.n	1dc70 <attcSendSimpleReq+0x38>
  {
    pCcb->outReqTimer.msg.event = ATTC_MSG_REQ_TIMEOUT;
   1dc54:	687b      	ldr	r3, [r7, #4]
   1dc56:	2210      	movs	r2, #16
   1dc58:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
    WsfTimerStartSec(&pCcb->outReqTimer, pAttCfg->transTimeout);
   1dc5c:	687b      	ldr	r3, [r7, #4]
   1dc5e:	f103 0224 	add.w	r2, r3, #36	; 0x24
   1dc62:	4b0a      	ldr	r3, [pc, #40]	; (1dc8c <attcSendSimpleReq+0x54>)
   1dc64:	681b      	ldr	r3, [r3, #0]
   1dc66:	799b      	ldrb	r3, [r3, #6]
   1dc68:	4619      	mov	r1, r3
   1dc6a:	4610      	mov	r0, r2
   1dc6c:	f00f fdbe 	bl	2d7ec <WsfTimerStartSec>
  }

  /* send packet to L2CAP */
  L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, pPkt->len, (uint8_t *) pPkt);
   1dc70:	687b      	ldr	r3, [r7, #4]
   1dc72:	681b      	ldr	r3, [r3, #0]
   1dc74:	8b19      	ldrh	r1, [r3, #24]
   1dc76:	68fb      	ldr	r3, [r7, #12]
   1dc78:	881a      	ldrh	r2, [r3, #0]
   1dc7a:	68fb      	ldr	r3, [r7, #12]
   1dc7c:	2004      	movs	r0, #4
   1dc7e:	f00c f933 	bl	29ee8 <L2cDataReq>
}
   1dc82:	bf00      	nop
   1dc84:	3710      	adds	r7, #16
   1dc86:	46bd      	mov	sp, r7
   1dc88:	bd80      	pop	{r7, pc}
   1dc8a:	bf00      	nop
   1dc8c:	10002b8c 	.word	0x10002b8c

0001dc90 <attcSendContinuingReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSendContinuingReq(attcCcb_t *pCcb)
{
   1dc90:	b580      	push	{r7, lr}
   1dc92:	b084      	sub	sp, #16
   1dc94:	af00      	add	r7, sp, #0
   1dc96:	6078      	str	r0, [r7, #4]
  attcPktParam_t  *pPkt;
  uint8_t         *p;

  /* if continuing */
  if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1dc98:	687b      	ldr	r3, [r7, #4]
   1dc9a:	7cdb      	ldrb	r3, [r3, #19]
   1dc9c:	2b01      	cmp	r3, #1
   1dc9e:	d11e      	bne.n	1dcde <attcSendContinuingReq+0x4e>
  {
    /* allocate new buffer */
    if ((pPkt = attMsgAlloc(pCcb->outReq.pPkt->len + L2C_PAYLOAD_START)) != NULL)
   1dca0:	687b      	ldr	r3, [r7, #4]
   1dca2:	695b      	ldr	r3, [r3, #20]
   1dca4:	881b      	ldrh	r3, [r3, #0]
   1dca6:	3308      	adds	r3, #8
   1dca8:	b29b      	uxth	r3, r3
   1dcaa:	4618      	mov	r0, r3
   1dcac:	f7ff fe9c 	bl	1d9e8 <attMsgAlloc>
   1dcb0:	60f8      	str	r0, [r7, #12]
   1dcb2:	68fb      	ldr	r3, [r7, #12]
   1dcb4:	2b00      	cmp	r3, #0
   1dcb6:	d00a      	beq.n	1dcce <attcSendContinuingReq+0x3e>
    {
      /* copy stored packet to new */
      memcpy(pPkt, pCcb->outReq.pPkt, pCcb->outReq.pPkt->len + L2C_PAYLOAD_START);
   1dcb8:	687b      	ldr	r3, [r7, #4]
   1dcba:	6959      	ldr	r1, [r3, #20]
   1dcbc:	687b      	ldr	r3, [r7, #4]
   1dcbe:	695b      	ldr	r3, [r3, #20]
   1dcc0:	881b      	ldrh	r3, [r3, #0]
   1dcc2:	3308      	adds	r3, #8
   1dcc4:	461a      	mov	r2, r3
   1dcc6:	68f8      	ldr	r0, [r7, #12]
   1dcc8:	f7fa fac4 	bl	18254 <memcpy>
   1dccc:	e00d      	b.n	1dcea <attcSendContinuingReq+0x5a>
    }
    /* else handle error case of allocation failure */
    else
    {
      /* free stored packet and call callback with failure status */
      attcReqClear(pCcb, &pCcb->outReq, ATT_ERR_MEMORY);
   1dcce:	687b      	ldr	r3, [r7, #4]
   1dcd0:	3310      	adds	r3, #16
   1dcd2:	2270      	movs	r2, #112	; 0x70
   1dcd4:	4619      	mov	r1, r3
   1dcd6:	6878      	ldr	r0, [r7, #4]
   1dcd8:	f000 fb62 	bl	1e3a0 <attcReqClear>
      return;
   1dcdc:	e057      	b.n	1dd8e <attcSendContinuingReq+0xfe>
  }
  /* else not continuing */
  else
  {
    /* send the stored packet */
    pPkt = pCcb->outReq.pPkt;
   1dcde:	687b      	ldr	r3, [r7, #4]
   1dce0:	695b      	ldr	r3, [r3, #20]
   1dce2:	60fb      	str	r3, [r7, #12]

    /* clear stored packet pointer */
    pCcb->outReq.pPkt = NULL;
   1dce4:	687b      	ldr	r3, [r7, #4]
   1dce6:	2200      	movs	r2, #0
   1dce8:	615a      	str	r2, [r3, #20]
  }

  /* build remaining fields of packet from stored parameters */
  p = (uint8_t *) pPkt + L2C_PAYLOAD_START + ATT_HDR_LEN;
   1dcea:	68fb      	ldr	r3, [r7, #12]
   1dcec:	3309      	adds	r3, #9
   1dcee:	60bb      	str	r3, [r7, #8]
  if (pCcb->outReq.hdr.event == ATTC_MSG_API_READ_LONG)
   1dcf0:	687b      	ldr	r3, [r7, #4]
   1dcf2:	7c9b      	ldrb	r3, [r3, #18]
   1dcf4:	2b06      	cmp	r3, #6
   1dcf6:	d113      	bne.n	1dd20 <attcSendContinuingReq+0x90>
  {
    /* build offset field */
    p += sizeof(uint16_t);
   1dcf8:	68bb      	ldr	r3, [r7, #8]
   1dcfa:	3302      	adds	r3, #2
   1dcfc:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, pCcb->outReqParams.o.offset);
   1dcfe:	687b      	ldr	r3, [r7, #4]
   1dd00:	8bd9      	ldrh	r1, [r3, #30]
   1dd02:	68bb      	ldr	r3, [r7, #8]
   1dd04:	1c5a      	adds	r2, r3, #1
   1dd06:	60ba      	str	r2, [r7, #8]
   1dd08:	b2ca      	uxtb	r2, r1
   1dd0a:	701a      	strb	r2, [r3, #0]
   1dd0c:	687b      	ldr	r3, [r7, #4]
   1dd0e:	8bdb      	ldrh	r3, [r3, #30]
   1dd10:	0a1b      	lsrs	r3, r3, #8
   1dd12:	b299      	uxth	r1, r3
   1dd14:	68bb      	ldr	r3, [r7, #8]
   1dd16:	1c5a      	adds	r2, r3, #1
   1dd18:	60ba      	str	r2, [r7, #8]
   1dd1a:	b2ca      	uxtb	r2, r1
   1dd1c:	701a      	strb	r2, [r3, #0]
   1dd1e:	e01f      	b.n	1dd60 <attcSendContinuingReq+0xd0>
  {
    /*
     * Find Info, Find By Type Value, Read By Type, and Read By Group Type
     * request packets all begin with a start handle and end handle.
     */
    UINT16_TO_BSTREAM(p, pCcb->outReqParams.h.startHandle);
   1dd20:	687b      	ldr	r3, [r7, #4]
   1dd22:	8bd9      	ldrh	r1, [r3, #30]
   1dd24:	68bb      	ldr	r3, [r7, #8]
   1dd26:	1c5a      	adds	r2, r3, #1
   1dd28:	60ba      	str	r2, [r7, #8]
   1dd2a:	b2ca      	uxtb	r2, r1
   1dd2c:	701a      	strb	r2, [r3, #0]
   1dd2e:	687b      	ldr	r3, [r7, #4]
   1dd30:	8bdb      	ldrh	r3, [r3, #30]
   1dd32:	0a1b      	lsrs	r3, r3, #8
   1dd34:	b299      	uxth	r1, r3
   1dd36:	68bb      	ldr	r3, [r7, #8]
   1dd38:	1c5a      	adds	r2, r3, #1
   1dd3a:	60ba      	str	r2, [r7, #8]
   1dd3c:	b2ca      	uxtb	r2, r1
   1dd3e:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pCcb->outReqParams.h.endHandle);
   1dd40:	687b      	ldr	r3, [r7, #4]
   1dd42:	8c19      	ldrh	r1, [r3, #32]
   1dd44:	68bb      	ldr	r3, [r7, #8]
   1dd46:	1c5a      	adds	r2, r3, #1
   1dd48:	60ba      	str	r2, [r7, #8]
   1dd4a:	b2ca      	uxtb	r2, r1
   1dd4c:	701a      	strb	r2, [r3, #0]
   1dd4e:	687b      	ldr	r3, [r7, #4]
   1dd50:	8c1b      	ldrh	r3, [r3, #32]
   1dd52:	0a1b      	lsrs	r3, r3, #8
   1dd54:	b299      	uxth	r1, r3
   1dd56:	68bb      	ldr	r3, [r7, #8]
   1dd58:	1c5a      	adds	r2, r3, #1
   1dd5a:	60ba      	str	r2, [r7, #8]
   1dd5c:	b2ca      	uxtb	r2, r1
   1dd5e:	701a      	strb	r2, [r3, #0]
  }

  /* start request timer */
  pCcb->outReqTimer.msg.event = ATTC_MSG_REQ_TIMEOUT;
   1dd60:	687b      	ldr	r3, [r7, #4]
   1dd62:	2210      	movs	r2, #16
   1dd64:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  WsfTimerStartSec(&pCcb->outReqTimer, pAttCfg->transTimeout);
   1dd68:	687b      	ldr	r3, [r7, #4]
   1dd6a:	f103 0224 	add.w	r2, r3, #36	; 0x24
   1dd6e:	4b09      	ldr	r3, [pc, #36]	; (1dd94 <attcSendContinuingReq+0x104>)
   1dd70:	681b      	ldr	r3, [r3, #0]
   1dd72:	799b      	ldrb	r3, [r3, #6]
   1dd74:	4619      	mov	r1, r3
   1dd76:	4610      	mov	r0, r2
   1dd78:	f00f fd38 	bl	2d7ec <WsfTimerStartSec>

  /* send packet to L2CAP */
  L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, pPkt->len, (uint8_t *) pPkt);
   1dd7c:	687b      	ldr	r3, [r7, #4]
   1dd7e:	681b      	ldr	r3, [r3, #0]
   1dd80:	8b19      	ldrh	r1, [r3, #24]
   1dd82:	68fb      	ldr	r3, [r7, #12]
   1dd84:	881a      	ldrh	r2, [r3, #0]
   1dd86:	68fb      	ldr	r3, [r7, #12]
   1dd88:	2004      	movs	r0, #4
   1dd8a:	f00c f8ad 	bl	29ee8 <L2cDataReq>
}
   1dd8e:	3710      	adds	r7, #16
   1dd90:	46bd      	mov	sp, r7
   1dd92:	bd80      	pop	{r7, pc}
   1dd94:	10002b8c 	.word	0x10002b8c

0001dd98 <attcSendMtuReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSendMtuReq(attcCcb_t *pCcb)
{
   1dd98:	b580      	push	{r7, lr}
   1dd9a:	b082      	sub	sp, #8
   1dd9c:	af00      	add	r7, sp, #0
   1dd9e:	6078      	str	r0, [r7, #4]
  // mentions the MTU exchange request shall only be sent once during a connection by the client.
  // The bit of ATT_CCB_STATUS_MTU_SENT will set if the MTU exchange request had been executed during the connection,
  // it will only be cleared when the current connection closes.

  /* if MTU already exchanged */
  if (pCcb->pMainCcb->control & ATT_CCB_STATUS_MTU_SENT)
   1dda0:	687b      	ldr	r3, [r7, #4]
   1dda2:	681b      	ldr	r3, [r3, #0]
   1dda4:	7f5b      	ldrb	r3, [r3, #29]
   1dda6:	f003 0301 	and.w	r3, r3, #1
   1ddaa:	2b00      	cmp	r3, #0
   1ddac:	d00b      	beq.n	1ddc6 <attcSendMtuReq+0x2e>
  {
    /* discard request */
    attcFreePkt(&pCcb->outReq);
   1ddae:	687b      	ldr	r3, [r7, #4]
   1ddb0:	3310      	adds	r3, #16
   1ddb2:	4618      	mov	r0, r3
   1ddb4:	f000 fac2 	bl	1e33c <attcFreePkt>

    /* clear out req */
    pCcb->outReq.hdr.event = ATTC_MSG_API_NONE;
   1ddb8:	687b      	ldr	r3, [r7, #4]
   1ddba:	2200      	movs	r2, #0
   1ddbc:	749a      	strb	r2, [r3, #18]

    ATT_TRACE_WARN0("MTU req discarded");
   1ddbe:	480a      	ldr	r0, [pc, #40]	; (1dde8 <attcSendMtuReq+0x50>)
   1ddc0:	f00f fde6 	bl	2d990 <WsfTrace>
    pCcb->pMainCcb->control |= ATT_CCB_STATUS_MTU_SENT;

    /* send packet */
    attcSendSimpleReq(pCcb);
  }
}
   1ddc4:	e00b      	b.n	1ddde <attcSendMtuReq+0x46>
    pCcb->pMainCcb->control |= ATT_CCB_STATUS_MTU_SENT;
   1ddc6:	687b      	ldr	r3, [r7, #4]
   1ddc8:	681b      	ldr	r3, [r3, #0]
   1ddca:	7f5a      	ldrb	r2, [r3, #29]
   1ddcc:	687b      	ldr	r3, [r7, #4]
   1ddce:	681b      	ldr	r3, [r3, #0]
   1ddd0:	f042 0201 	orr.w	r2, r2, #1
   1ddd4:	b2d2      	uxtb	r2, r2
   1ddd6:	775a      	strb	r2, [r3, #29]
    attcSendSimpleReq(pCcb);
   1ddd8:	6878      	ldr	r0, [r7, #4]
   1ddda:	f7ff ff2d 	bl	1dc38 <attcSendSimpleReq>
}
   1ddde:	bf00      	nop
   1dde0:	3708      	adds	r7, #8
   1dde2:	46bd      	mov	sp, r7
   1dde4:	bd80      	pop	{r7, pc}
   1dde6:	bf00      	nop
   1dde8:	00044800 	.word	0x00044800

0001ddec <attcSendWriteCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSendWriteCmd(attcCcb_t *pCcb)
{
   1ddec:	b580      	push	{r7, lr}
   1ddee:	b082      	sub	sp, #8
   1ddf0:	af00      	add	r7, sp, #0
   1ddf2:	6078      	str	r0, [r7, #4]
  /* send packet */
  attcSendSimpleReq(pCcb);
   1ddf4:	6878      	ldr	r0, [r7, #4]
   1ddf6:	f7ff ff1f 	bl	1dc38 <attcSendSimpleReq>

  /* if flow not disabled */
  if (!(pCcb->pMainCcb->control & ATT_CCB_STATUS_FLOW_DISABLED))
   1ddfa:	687b      	ldr	r3, [r7, #4]
   1ddfc:	681b      	ldr	r3, [r3, #0]
   1ddfe:	7f5b      	ldrb	r3, [r3, #29]
   1de00:	f003 0302 	and.w	r3, r3, #2
   1de04:	2b00      	cmp	r3, #0
   1de06:	d109      	bne.n	1de1c <attcSendWriteCmd+0x30>
  {
    /* call callback */
    attcExecCallback(pCcb->pMainCcb->connId, ATTC_WRITE_CMD_RSP, pCcb->outReq.handle, ATT_SUCCESS);
   1de08:	687b      	ldr	r3, [r7, #4]
   1de0a:	681b      	ldr	r3, [r3, #0]
   1de0c:	7f18      	ldrb	r0, [r3, #28]
   1de0e:	687b      	ldr	r3, [r7, #4]
   1de10:	8b1a      	ldrh	r2, [r3, #24]
   1de12:	2300      	movs	r3, #0
   1de14:	210a      	movs	r1, #10
   1de16:	f000 faa5 	bl	1e364 <attcExecCallback>
   1de1a:	e002      	b.n	1de22 <attcSendWriteCmd+0x36>
  }
  else
  {
    /* set pending write command callback for this handle */
    attcSetPendWriteCmd(pCcb);
   1de1c:	6878      	ldr	r0, [r7, #4]
   1de1e:	f7ff feb5 	bl	1db8c <attcSetPendWriteCmd>
  }

  /* clear out req */
  pCcb->outReq.hdr.event = ATTC_MSG_API_NONE;
   1de22:	687b      	ldr	r3, [r7, #4]
   1de24:	2200      	movs	r2, #0
   1de26:	749a      	strb	r2, [r3, #18]
}
   1de28:	bf00      	nop
   1de2a:	3708      	adds	r7, #8
   1de2c:	46bd      	mov	sp, r7
   1de2e:	bd80      	pop	{r7, pc}

0001de30 <attcSendPrepWriteReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcSendPrepWriteReq(attcCcb_t *pCcb)
{
   1de30:	b580      	push	{r7, lr}
   1de32:	b086      	sub	sp, #24
   1de34:	af00      	add	r7, sp, #0
   1de36:	6078      	str	r0, [r7, #4]
  attcPktParam_t  *pPkt;
  uint8_t         *p;
  uint16_t        dataLen;

  /* if continuing */
  if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1de38:	687b      	ldr	r3, [r7, #4]
   1de3a:	7cdb      	ldrb	r3, [r3, #19]
   1de3c:	2b01      	cmp	r3, #1
   1de3e:	d141      	bne.n	1dec4 <attcSendPrepWriteReq+0x94>
  {
    /* determine size of buffer to allocate */
    if (pCcb->outReqParams.w.len < (pCcb->pMainCcb->mtu - ATT_PREP_WRITE_REQ_LEN))
   1de40:	687b      	ldr	r3, [r7, #4]
   1de42:	8b9b      	ldrh	r3, [r3, #28]
   1de44:	461a      	mov	r2, r3
   1de46:	687b      	ldr	r3, [r7, #4]
   1de48:	681b      	ldr	r3, [r3, #0]
   1de4a:	8b5b      	ldrh	r3, [r3, #26]
   1de4c:	3b05      	subs	r3, #5
   1de4e:	429a      	cmp	r2, r3
   1de50:	da03      	bge.n	1de5a <attcSendPrepWriteReq+0x2a>
    {
      dataLen = pCcb->outReqParams.w.len;
   1de52:	687b      	ldr	r3, [r7, #4]
   1de54:	8b9b      	ldrh	r3, [r3, #28]
   1de56:	827b      	strh	r3, [r7, #18]
   1de58:	e004      	b.n	1de64 <attcSendPrepWriteReq+0x34>
    }
    else
    {
      dataLen = pCcb->pMainCcb->mtu - ATT_PREP_WRITE_REQ_LEN;
   1de5a:	687b      	ldr	r3, [r7, #4]
   1de5c:	681b      	ldr	r3, [r3, #0]
   1de5e:	8b5b      	ldrh	r3, [r3, #26]
   1de60:	3b05      	subs	r3, #5
   1de62:	827b      	strh	r3, [r7, #18]
    }

    /* allocate new buffer */
    if ((pPkt = attMsgAlloc(dataLen + ATT_PREP_WRITE_REQ_LEN + L2C_PAYLOAD_START)) != NULL)
   1de64:	8a7b      	ldrh	r3, [r7, #18]
   1de66:	330d      	adds	r3, #13
   1de68:	b29b      	uxth	r3, r3
   1de6a:	4618      	mov	r0, r3
   1de6c:	f7ff fdbc 	bl	1d9e8 <attMsgAlloc>
   1de70:	6178      	str	r0, [r7, #20]
   1de72:	697b      	ldr	r3, [r7, #20]
   1de74:	2b00      	cmp	r3, #0
   1de76:	d01d      	beq.n	1deb4 <attcSendPrepWriteReq+0x84>
    {
      /* copy fixed fields */
      memcpy(pPkt, pCcb->outReq.pPkt, ATT_PREP_WRITE_REQ_LEN + L2C_PAYLOAD_START);
   1de78:	687b      	ldr	r3, [r7, #4]
   1de7a:	695b      	ldr	r3, [r3, #20]
   1de7c:	220d      	movs	r2, #13
   1de7e:	4619      	mov	r1, r3
   1de80:	6978      	ldr	r0, [r7, #20]
   1de82:	f7fa f9e7 	bl	18254 <memcpy>

      /* copy data */
      memcpy(((uint8_t *) pPkt + L2C_PAYLOAD_START + ATT_PREP_WRITE_REQ_LEN),
   1de86:	697b      	ldr	r3, [r7, #20]
   1de88:	f103 000d 	add.w	r0, r3, #13
             pCcb->outReqParams.w.pValue, dataLen);
   1de8c:	687b      	ldr	r3, [r7, #4]
   1de8e:	6a1b      	ldr	r3, [r3, #32]
      memcpy(((uint8_t *) pPkt + L2C_PAYLOAD_START + ATT_PREP_WRITE_REQ_LEN),
   1de90:	8a7a      	ldrh	r2, [r7, #18]
   1de92:	4619      	mov	r1, r3
   1de94:	f7fa f9de 	bl	18254 <memcpy>

      /* update length and data pointer */
      pCcb->outReqParams.w.pValue += dataLen;
   1de98:	687b      	ldr	r3, [r7, #4]
   1de9a:	6a1a      	ldr	r2, [r3, #32]
   1de9c:	8a7b      	ldrh	r3, [r7, #18]
   1de9e:	441a      	add	r2, r3
   1dea0:	687b      	ldr	r3, [r7, #4]
   1dea2:	621a      	str	r2, [r3, #32]
      pCcb->outReqParams.w.len -= dataLen;
   1dea4:	687b      	ldr	r3, [r7, #4]
   1dea6:	8b9a      	ldrh	r2, [r3, #28]
   1dea8:	8a7b      	ldrh	r3, [r7, #18]
   1deaa:	1ad3      	subs	r3, r2, r3
   1deac:	b29a      	uxth	r2, r3
   1deae:	687b      	ldr	r3, [r7, #4]
   1deb0:	839a      	strh	r2, [r3, #28]
   1deb2:	e010      	b.n	1ded6 <attcSendPrepWriteReq+0xa6>
    }
    /* else handle error case of allocation failure */
    else
    {
      /* free stored packet and call callback with failure status */
      attcReqClear(pCcb, &pCcb->outReq, ATT_ERR_MEMORY);
   1deb4:	687b      	ldr	r3, [r7, #4]
   1deb6:	3310      	adds	r3, #16
   1deb8:	2270      	movs	r2, #112	; 0x70
   1deba:	4619      	mov	r1, r3
   1debc:	6878      	ldr	r0, [r7, #4]
   1debe:	f000 fa6f 	bl	1e3a0 <attcReqClear>
      return;
   1dec2:	e03a      	b.n	1df3a <attcSendPrepWriteReq+0x10a>
    }
  }
  /* else not continuing */
  else
  {
    dataLen = pCcb->outReqParams.w.len;
   1dec4:	687b      	ldr	r3, [r7, #4]
   1dec6:	8b9b      	ldrh	r3, [r3, #28]
   1dec8:	827b      	strh	r3, [r7, #18]

    /* send the stored packet */
    pPkt = pCcb->outReq.pPkt;
   1deca:	687b      	ldr	r3, [r7, #4]
   1decc:	695b      	ldr	r3, [r3, #20]
   1dece:	617b      	str	r3, [r7, #20]

    /* clear stored packet pointer */
    pCcb->outReq.pPkt = NULL;
   1ded0:	687b      	ldr	r3, [r7, #4]
   1ded2:	2200      	movs	r2, #0
   1ded4:	615a      	str	r2, [r3, #20]
  }

  /* build remaining fields of packet from stored parameters */
  p = (uint8_t *) pPkt + L2C_PAYLOAD_START + ATT_HDR_LEN + sizeof(uint16_t);
   1ded6:	697b      	ldr	r3, [r7, #20]
   1ded8:	330b      	adds	r3, #11
   1deda:	60fb      	str	r3, [r7, #12]
  UINT16_TO_BSTREAM(p, pCcb->outReqParams.w.offset);
   1dedc:	687b      	ldr	r3, [r7, #4]
   1dede:	8bd9      	ldrh	r1, [r3, #30]
   1dee0:	68fb      	ldr	r3, [r7, #12]
   1dee2:	1c5a      	adds	r2, r3, #1
   1dee4:	60fa      	str	r2, [r7, #12]
   1dee6:	b2ca      	uxtb	r2, r1
   1dee8:	701a      	strb	r2, [r3, #0]
   1deea:	687b      	ldr	r3, [r7, #4]
   1deec:	8bdb      	ldrh	r3, [r3, #30]
   1deee:	0a1b      	lsrs	r3, r3, #8
   1def0:	b299      	uxth	r1, r3
   1def2:	68fb      	ldr	r3, [r7, #12]
   1def4:	1c5a      	adds	r2, r3, #1
   1def6:	60fa      	str	r2, [r7, #12]
   1def8:	b2ca      	uxtb	r2, r1
   1defa:	701a      	strb	r2, [r3, #0]

  /* update offset after building packet */
  pCcb->outReqParams.w.offset += dataLen;
   1defc:	687b      	ldr	r3, [r7, #4]
   1defe:	8bda      	ldrh	r2, [r3, #30]
   1df00:	8a7b      	ldrh	r3, [r7, #18]
   1df02:	4413      	add	r3, r2
   1df04:	b29a      	uxth	r2, r3
   1df06:	687b      	ldr	r3, [r7, #4]
   1df08:	83da      	strh	r2, [r3, #30]

  /* start request timer */
  pCcb->outReqTimer.msg.event = ATTC_MSG_REQ_TIMEOUT;
   1df0a:	687b      	ldr	r3, [r7, #4]
   1df0c:	2210      	movs	r2, #16
   1df0e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e
  WsfTimerStartSec(&pCcb->outReqTimer, pAttCfg->transTimeout);
   1df12:	687b      	ldr	r3, [r7, #4]
   1df14:	f103 0224 	add.w	r2, r3, #36	; 0x24
   1df18:	4b09      	ldr	r3, [pc, #36]	; (1df40 <attcSendPrepWriteReq+0x110>)
   1df1a:	681b      	ldr	r3, [r3, #0]
   1df1c:	799b      	ldrb	r3, [r3, #6]
   1df1e:	4619      	mov	r1, r3
   1df20:	4610      	mov	r0, r2
   1df22:	f00f fc63 	bl	2d7ec <WsfTimerStartSec>

  /* send packet to L2CAP */
  L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, dataLen + ATT_PREP_WRITE_REQ_LEN, (uint8_t *) pPkt);
   1df26:	687b      	ldr	r3, [r7, #4]
   1df28:	681b      	ldr	r3, [r3, #0]
   1df2a:	8b19      	ldrh	r1, [r3, #24]
   1df2c:	8a7b      	ldrh	r3, [r7, #18]
   1df2e:	3305      	adds	r3, #5
   1df30:	b29a      	uxth	r2, r3
   1df32:	697b      	ldr	r3, [r7, #20]
   1df34:	2004      	movs	r0, #4
   1df36:	f00b ffd7 	bl	29ee8 <L2cDataReq>
}
   1df3a:	3718      	adds	r7, #24
   1df3c:	46bd      	mov	sp, r7
   1df3e:	bd80      	pop	{r7, pc}
   1df40:	10002b8c 	.word	0x10002b8c

0001df44 <attcSendReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcSendReq(attcCcb_t *pCcb)
{
   1df44:	b580      	push	{r7, lr}
   1df46:	b082      	sub	sp, #8
   1df48:	af00      	add	r7, sp, #0
   1df4a:	6078      	str	r0, [r7, #4]
  (*attcSendReqTbl[pCcb->outReq.hdr.event])(pCcb);
   1df4c:	687b      	ldr	r3, [r7, #4]
   1df4e:	7c9b      	ldrb	r3, [r3, #18]
   1df50:	461a      	mov	r2, r3
   1df52:	4b04      	ldr	r3, [pc, #16]	; (1df64 <attcSendReq+0x20>)
   1df54:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1df58:	6878      	ldr	r0, [r7, #4]
   1df5a:	4798      	blx	r3
}
   1df5c:	bf00      	nop
   1df5e:	3708      	adds	r7, #8
   1df60:	46bd      	mov	sp, r7
   1df62:	bd80      	pop	{r7, pc}
   1df64:	00045b10 	.word	0x00045b10

0001df68 <attcSetupReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcSetupReq(attcCcb_t *pCcb, attcApiMsg_t *pMsg)
{
   1df68:	b580      	push	{r7, lr}
   1df6a:	b082      	sub	sp, #8
   1df6c:	af00      	add	r7, sp, #0
   1df6e:	6078      	str	r0, [r7, #4]
   1df70:	6039      	str	r1, [r7, #0]
  /* set out req to api message */
  pCcb->outReq = *pMsg;
   1df72:	687b      	ldr	r3, [r7, #4]
   1df74:	683a      	ldr	r2, [r7, #0]
   1df76:	3310      	adds	r3, #16
   1df78:	ca07      	ldmia	r2, {r0, r1, r2}
   1df7a:	e883 0007 	stmia.w	r3, {r0, r1, r2}

  /* store parameters */
  pCcb->outReqParams = *(pMsg->pPkt);
   1df7e:	683b      	ldr	r3, [r7, #0]
   1df80:	685a      	ldr	r2, [r3, #4]
   1df82:	687b      	ldr	r3, [r7, #4]
   1df84:	331c      	adds	r3, #28
   1df86:	e892 0003 	ldmia.w	r2, {r0, r1}
   1df8a:	e883 0003 	stmia.w	r3, {r0, r1}

  /* build and send request */
  attcSendReq(pCcb);
   1df8e:	6878      	ldr	r0, [r7, #4]
   1df90:	f7ff ffd8 	bl	1df44 <attcSendReq>
}
   1df94:	bf00      	nop
   1df96:	3708      	adds	r7, #8
   1df98:	46bd      	mov	sp, r7
   1df9a:	bd80      	pop	{r7, pc}

0001df9c <attcDataCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcDataCback(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   1df9c:	b580      	push	{r7, lr}
   1df9e:	b084      	sub	sp, #16
   1dfa0:	af00      	add	r7, sp, #0
   1dfa2:	4603      	mov	r3, r0
   1dfa4:	603a      	str	r2, [r7, #0]
   1dfa6:	80fb      	strh	r3, [r7, #6]
   1dfa8:	460b      	mov	r3, r1
   1dfaa:	80bb      	strh	r3, [r7, #4]
  uint8_t       opcode;
  attcCcb_t     *pCcb;

  /* get connection control block for this handle, ignore packet if not found */
  if ((pCcb = attcCcbByHandle(handle)) == NULL)
   1dfac:	88fb      	ldrh	r3, [r7, #6]
   1dfae:	4618      	mov	r0, r3
   1dfb0:	f000 f9a6 	bl	1e300 <attcCcbByHandle>
   1dfb4:	60f8      	str	r0, [r7, #12]
   1dfb6:	68fb      	ldr	r3, [r7, #12]
   1dfb8:	2b00      	cmp	r3, #0
   1dfba:	d022      	beq.n	1e002 <attcDataCback+0x66>
  {
    return;
  }

  /* check the validity of data length */
  ATT_CHECK_DATA_LENGTH(len, ATT_HDR_LEN);
   1dfbc:	88bb      	ldrh	r3, [r7, #4]
   1dfbe:	2b00      	cmp	r3, #0
   1dfc0:	d021      	beq.n	1e006 <attcDataCback+0x6a>

  /* parse opcode */
  opcode = *(pPacket + L2C_PAYLOAD_START);
   1dfc2:	683b      	ldr	r3, [r7, #0]
   1dfc4:	7a1b      	ldrb	r3, [r3, #8]
   1dfc6:	72fb      	strb	r3, [r7, #11]

  /* if response */
  if (opcode <= ATT_PDU_EXEC_WRITE_RSP)
   1dfc8:	7afb      	ldrb	r3, [r7, #11]
   1dfca:	2b19      	cmp	r3, #25
   1dfcc:	d806      	bhi.n	1dfdc <attcDataCback+0x40>
  {
    attcProcRsp(pCcb, len, pPacket);
   1dfce:	88bb      	ldrh	r3, [r7, #4]
   1dfd0:	683a      	ldr	r2, [r7, #0]
   1dfd2:	4619      	mov	r1, r3
   1dfd4:	68f8      	ldr	r0, [r7, #12]
   1dfd6:	f000 fb9d 	bl	1e714 <attcProcRsp>
   1dfda:	e015      	b.n	1e008 <attcDataCback+0x6c>
  }
  /* else if indication or notification */
  else if ((opcode == ATT_PDU_VALUE_NTF) || (opcode == ATT_PDU_VALUE_IND))
   1dfdc:	7afb      	ldrb	r3, [r7, #11]
   1dfde:	2b1b      	cmp	r3, #27
   1dfe0:	d002      	beq.n	1dfe8 <attcDataCback+0x4c>
   1dfe2:	7afb      	ldrb	r3, [r7, #11]
   1dfe4:	2b1d      	cmp	r3, #29
   1dfe6:	d106      	bne.n	1dff6 <attcDataCback+0x5a>
  {
    attcProcInd(pCcb, len, pPacket);
   1dfe8:	88bb      	ldrh	r3, [r7, #4]
   1dfea:	683a      	ldr	r2, [r7, #0]
   1dfec:	4619      	mov	r1, r3
   1dfee:	68f8      	ldr	r0, [r7, #12]
   1dff0:	f000 fc26 	bl	1e840 <attcProcInd>
   1dff4:	e008      	b.n	1e008 <attcDataCback+0x6c>
  }
  /* else unknown opcode */
  else
  {
    ATT_TRACE_WARN1("attc unknown opcode 0x%02x", opcode);
   1dff6:	7afb      	ldrb	r3, [r7, #11]
   1dff8:	4619      	mov	r1, r3
   1dffa:	4805      	ldr	r0, [pc, #20]	; (1e010 <attcDataCback+0x74>)
   1dffc:	f00f fcc8 	bl	2d990 <WsfTrace>
   1e000:	e002      	b.n	1e008 <attcDataCback+0x6c>
    return;
   1e002:	bf00      	nop
   1e004:	e000      	b.n	1e008 <attcDataCback+0x6c>
  ATT_CHECK_DATA_LENGTH(len, ATT_HDR_LEN);
   1e006:	bf00      	nop
  }
}
   1e008:	3710      	adds	r7, #16
   1e00a:	46bd      	mov	sp, r7
   1e00c:	bd80      	pop	{r7, pc}
   1e00e:	bf00      	nop
   1e010:	00044814 	.word	0x00044814

0001e014 <attcCtrlCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcCtrlCback(wsfMsgHdr_t *pMsg)
{
   1e014:	b580      	push	{r7, lr}
   1e016:	b084      	sub	sp, #16
   1e018:	af00      	add	r7, sp, #0
   1e01a:	6078      	str	r0, [r7, #4]
  attcCcb_t     *pCcb;

  /* note this function is currently only called when flow is enabled */

  /* get CCB */
  if ((pCcb = attcCcbByConnId((dmConnId_t) pMsg->param)) != NULL)
   1e01c:	687b      	ldr	r3, [r7, #4]
   1e01e:	881b      	ldrh	r3, [r3, #0]
   1e020:	b2db      	uxtb	r3, r3
   1e022:	4618      	mov	r0, r3
   1e024:	f000 f948 	bl	1e2b8 <attcCcbByConnId>
   1e028:	60f8      	str	r0, [r7, #12]
   1e02a:	68fb      	ldr	r3, [r7, #12]
   1e02c:	2b00      	cmp	r3, #0
   1e02e:	d00d      	beq.n	1e04c <attcCtrlCback+0x38>
  {
    /* if confirmation pending try sending now */
    AttcIndConfirm((dmConnId_t) pMsg->param);
   1e030:	687b      	ldr	r3, [r7, #4]
   1e032:	881b      	ldrh	r3, [r3, #0]
   1e034:	b2db      	uxtb	r3, r3
   1e036:	4618      	mov	r0, r3
   1e038:	f000 fd67 	bl	1eb0a <AttcIndConfirm>

    /* call pending write command callback */
    attcWriteCmdCallback((dmConnId_t) pMsg->param, pCcb, ATT_SUCCESS);
   1e03c:	687b      	ldr	r3, [r7, #4]
   1e03e:	881b      	ldrh	r3, [r3, #0]
   1e040:	b2db      	uxtb	r3, r3
   1e042:	2200      	movs	r2, #0
   1e044:	68f9      	ldr	r1, [r7, #12]
   1e046:	4618      	mov	r0, r3
   1e048:	f7ff fdc6 	bl	1dbd8 <attcWriteCmdCallback>
  }
}
   1e04c:	bf00      	nop
   1e04e:	3710      	adds	r7, #16
   1e050:	46bd      	mov	sp, r7
   1e052:	bd80      	pop	{r7, pc}

0001e054 <attcConnCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcConnCback(attCcb_t *pCcb, dmEvt_t *pDmEvt)
{
   1e054:	b590      	push	{r4, r7, lr}
   1e056:	b087      	sub	sp, #28
   1e058:	af00      	add	r7, sp, #0
   1e05a:	6078      	str	r0, [r7, #4]
   1e05c:	6039      	str	r1, [r7, #0]
  attcCcb_t *pClient;
  uint16_t  localMtu;
  uint8_t   status;

  /* if connection opened */
  if (pDmEvt->hdr.event == DM_CONN_OPEN_IND)
   1e05e:	683b      	ldr	r3, [r7, #0]
   1e060:	789b      	ldrb	r3, [r3, #2]
   1e062:	2b27      	cmp	r3, #39	; 0x27
   1e064:	d126      	bne.n	1e0b4 <attcConnCback+0x60>
  {
    /* if we initiated connection send MTU request */
    if (DmConnRole(pCcb->connId) == DM_ROLE_MASTER)
   1e066:	687b      	ldr	r3, [r7, #4]
   1e068:	7f1b      	ldrb	r3, [r3, #28]
   1e06a:	4618      	mov	r0, r3
   1e06c:	f005 fb0a 	bl	23684 <DmConnRole>
   1e070:	4603      	mov	r3, r0
   1e072:	2b00      	cmp	r3, #0
   1e074:	d170      	bne.n	1e158 <attcConnCback+0x104>
    {
      localMtu = WSF_MIN(pAttCfg->mtu, (HciGetMaxRxAclLen() - L2C_HDR_LEN));
   1e076:	4b3a      	ldr	r3, [pc, #232]	; (1e160 <attcConnCback+0x10c>)
   1e078:	681b      	ldr	r3, [r3, #0]
   1e07a:	889b      	ldrh	r3, [r3, #4]
   1e07c:	461c      	mov	r4, r3
   1e07e:	f008 f9f3 	bl	26468 <HciGetMaxRxAclLen>
   1e082:	4603      	mov	r3, r0
   1e084:	3b04      	subs	r3, #4
   1e086:	429c      	cmp	r4, r3
   1e088:	da03      	bge.n	1e092 <attcConnCback+0x3e>
   1e08a:	4b35      	ldr	r3, [pc, #212]	; (1e160 <attcConnCback+0x10c>)
   1e08c:	681b      	ldr	r3, [r3, #0]
   1e08e:	889b      	ldrh	r3, [r3, #4]
   1e090:	e004      	b.n	1e09c <attcConnCback+0x48>
   1e092:	f008 f9e9 	bl	26468 <HciGetMaxRxAclLen>
   1e096:	4603      	mov	r3, r0
   1e098:	3b04      	subs	r3, #4
   1e09a:	b29b      	uxth	r3, r3
   1e09c:	81fb      	strh	r3, [r7, #14]

      /* if desired MTU is not the default */
      if (localMtu != ATT_DEFAULT_MTU)
   1e09e:	89fb      	ldrh	r3, [r7, #14]
   1e0a0:	2b17      	cmp	r3, #23
   1e0a2:	d059      	beq.n	1e158 <attcConnCback+0x104>
      {
        AttcMtuReq(pCcb->connId, localMtu);
   1e0a4:	687b      	ldr	r3, [r7, #4]
   1e0a6:	7f1b      	ldrb	r3, [r3, #28]
   1e0a8:	89fa      	ldrh	r2, [r7, #14]
   1e0aa:	4611      	mov	r1, r2
   1e0ac:	4618      	mov	r0, r3
   1e0ae:	f000 fcf8 	bl	1eaa2 <AttcMtuReq>
    }

    /* call pending write command callback */
    attcWriteCmdCallback(pCcb->connId, pClient, status);
  }
}
   1e0b2:	e051      	b.n	1e158 <attcConnCback+0x104>
  else if (pDmEvt->hdr.event == DM_CONN_CLOSE_IND)
   1e0b4:	683b      	ldr	r3, [r7, #0]
   1e0b6:	789b      	ldrb	r3, [r3, #2]
   1e0b8:	2b28      	cmp	r3, #40	; 0x28
   1e0ba:	d14d      	bne.n	1e158 <attcConnCback+0x104>
    if (pDmEvt->connClose.hdr.status == HCI_SUCCESS)
   1e0bc:	683b      	ldr	r3, [r7, #0]
   1e0be:	78db      	ldrb	r3, [r3, #3]
   1e0c0:	2b00      	cmp	r3, #0
   1e0c2:	d104      	bne.n	1e0ce <attcConnCback+0x7a>
      status = pDmEvt->connClose.reason + ATT_HCI_ERR_BASE;
   1e0c4:	683b      	ldr	r3, [r7, #0]
   1e0c6:	7a1b      	ldrb	r3, [r3, #8]
   1e0c8:	3b60      	subs	r3, #96	; 0x60
   1e0ca:	75fb      	strb	r3, [r7, #23]
   1e0cc:	e003      	b.n	1e0d6 <attcConnCback+0x82>
      status = pDmEvt->connClose.hdr.status + ATT_HCI_ERR_BASE;
   1e0ce:	683b      	ldr	r3, [r7, #0]
   1e0d0:	78db      	ldrb	r3, [r3, #3]
   1e0d2:	3b60      	subs	r3, #96	; 0x60
   1e0d4:	75fb      	strb	r3, [r7, #23]
    pClient = &attcCb.ccb[pCcb->connId - 1];
   1e0d6:	687b      	ldr	r3, [r7, #4]
   1e0d8:	7f1b      	ldrb	r3, [r3, #28]
   1e0da:	1e5a      	subs	r2, r3, #1
   1e0dc:	4613      	mov	r3, r2
   1e0de:	00db      	lsls	r3, r3, #3
   1e0e0:	1a9b      	subs	r3, r3, r2
   1e0e2:	00db      	lsls	r3, r3, #3
   1e0e4:	4a1f      	ldr	r2, [pc, #124]	; (1e164 <attcConnCback+0x110>)
   1e0e6:	4413      	add	r3, r2
   1e0e8:	613b      	str	r3, [r7, #16]
    if (pClient->outReq.hdr.event != ATTC_MSG_API_NONE)
   1e0ea:	693b      	ldr	r3, [r7, #16]
   1e0ec:	7c9b      	ldrb	r3, [r3, #18]
   1e0ee:	2b00      	cmp	r3, #0
   1e0f0:	d00b      	beq.n	1e10a <attcConnCback+0xb6>
      WsfTimerStop(&pClient->outReqTimer);
   1e0f2:	693b      	ldr	r3, [r7, #16]
   1e0f4:	3324      	adds	r3, #36	; 0x24
   1e0f6:	4618      	mov	r0, r3
   1e0f8:	f00f fb9e 	bl	2d838 <WsfTimerStop>
      attcReqClear(pClient, &pClient->outReq, status);
   1e0fc:	693b      	ldr	r3, [r7, #16]
   1e0fe:	3310      	adds	r3, #16
   1e100:	7dfa      	ldrb	r2, [r7, #23]
   1e102:	4619      	mov	r1, r3
   1e104:	6938      	ldr	r0, [r7, #16]
   1e106:	f000 f94b 	bl	1e3a0 <attcReqClear>
    if (pClient->onDeck.hdr.event != ATTC_MSG_API_NONE)
   1e10a:	693b      	ldr	r3, [r7, #16]
   1e10c:	799b      	ldrb	r3, [r3, #6]
   1e10e:	2b00      	cmp	r3, #0
   1e110:	d006      	beq.n	1e120 <attcConnCback+0xcc>
      attcReqClear(pClient, &pClient->onDeck, status);
   1e112:	693b      	ldr	r3, [r7, #16]
   1e114:	3304      	adds	r3, #4
   1e116:	7dfa      	ldrb	r2, [r7, #23]
   1e118:	4619      	mov	r1, r3
   1e11a:	6938      	ldr	r0, [r7, #16]
   1e11c:	f000 f940 	bl	1e3a0 <attcReqClear>
    pClient->flowDisabled = FALSE;
   1e120:	693b      	ldr	r3, [r7, #16]
   1e122:	2200      	movs	r2, #0
   1e124:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    pClient->cnfPending = FALSE;
   1e128:	693b      	ldr	r3, [r7, #16]
   1e12a:	2200      	movs	r2, #0
   1e12c:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    if (attcCb.pSign != NULL)
   1e130:	4b0c      	ldr	r3, [pc, #48]	; (1e164 <attcConnCback+0x110>)
   1e132:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   1e136:	2b00      	cmp	r3, #0
   1e138:	d007      	beq.n	1e14a <attcConnCback+0xf6>
      (*attcCb.pSign->closeCback)(pClient, status);
   1e13a:	4b0a      	ldr	r3, [pc, #40]	; (1e164 <attcConnCback+0x110>)
   1e13c:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   1e140:	685b      	ldr	r3, [r3, #4]
   1e142:	7dfa      	ldrb	r2, [r7, #23]
   1e144:	4611      	mov	r1, r2
   1e146:	6938      	ldr	r0, [r7, #16]
   1e148:	4798      	blx	r3
    attcWriteCmdCallback(pCcb->connId, pClient, status);
   1e14a:	687b      	ldr	r3, [r7, #4]
   1e14c:	7f1b      	ldrb	r3, [r3, #28]
   1e14e:	7dfa      	ldrb	r2, [r7, #23]
   1e150:	6939      	ldr	r1, [r7, #16]
   1e152:	4618      	mov	r0, r3
   1e154:	f7ff fd40 	bl	1dbd8 <attcWriteCmdCallback>
}
   1e158:	bf00      	nop
   1e15a:	371c      	adds	r7, #28
   1e15c:	46bd      	mov	sp, r7
   1e15e:	bd90      	pop	{r4, r7, pc}
   1e160:	10002b8c 	.word	0x10002b8c
   1e164:	100110c8 	.word	0x100110c8

0001e168 <attcMsgCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attcMsgCback(attcApiMsg_t *pMsg)
{
   1e168:	b580      	push	{r7, lr}
   1e16a:	b084      	sub	sp, #16
   1e16c:	af00      	add	r7, sp, #0
   1e16e:	6078      	str	r0, [r7, #4]
  attcCcb_t   *pCcb;

  /* get CCB and verify connection still in use */
  if ((pCcb = attcCcbByConnId((dmConnId_t) pMsg->hdr.param)) == NULL)
   1e170:	687b      	ldr	r3, [r7, #4]
   1e172:	881b      	ldrh	r3, [r3, #0]
   1e174:	b2db      	uxtb	r3, r3
   1e176:	4618      	mov	r0, r3
   1e178:	f000 f89e 	bl	1e2b8 <attcCcbByConnId>
   1e17c:	60f8      	str	r0, [r7, #12]
   1e17e:	68fb      	ldr	r3, [r7, #12]
   1e180:	2b00      	cmp	r3, #0
   1e182:	d10d      	bne.n	1e1a0 <attcMsgCback+0x38>
  {
    /* if message has a packet buffer */
    if (pMsg->hdr.event >= ATTC_MSG_API_MTU &&
   1e184:	687b      	ldr	r3, [r7, #4]
   1e186:	789b      	ldrb	r3, [r3, #2]
   1e188:	2b00      	cmp	r3, #0
   1e18a:	f000 808e 	beq.w	1e2aa <attcMsgCback+0x142>
        pMsg->hdr.event <= ATTC_MSG_API_SIGNED_WRITE_CMD)
   1e18e:	687b      	ldr	r3, [r7, #4]
   1e190:	789b      	ldrb	r3, [r3, #2]
    if (pMsg->hdr.event >= ATTC_MSG_API_MTU &&
   1e192:	2b0d      	cmp	r3, #13
   1e194:	f200 8089 	bhi.w	1e2aa <attcMsgCback+0x142>
    {
      /* free packet buffer */
      attcFreePkt(pMsg);
   1e198:	6878      	ldr	r0, [r7, #4]
   1e19a:	f000 f8cf 	bl	1e33c <attcFreePkt>
    }

    /* ignore if connection not in use */
    return;
   1e19e:	e084      	b.n	1e2aa <attcMsgCback+0x142>
  }

  /* if an API request to send packet (non-signed) */
  if (pMsg->hdr.event <= ATTC_MSG_API_EXEC_WRITE)
   1e1a0:	687b      	ldr	r3, [r7, #4]
   1e1a2:	789b      	ldrb	r3, [r3, #2]
   1e1a4:	2b0c      	cmp	r3, #12
   1e1a6:	d82d      	bhi.n	1e204 <attcMsgCback+0x9c>
  {
    /* verify no API request already waiting on deck, in progress, or no pending write command
       already for this handle */
    if ((pCcb->onDeck.hdr.event != ATTC_MSG_API_NONE) ||
   1e1a8:	68fb      	ldr	r3, [r7, #12]
   1e1aa:	799b      	ldrb	r3, [r3, #6]
   1e1ac:	2b00      	cmp	r3, #0
   1e1ae:	d10e      	bne.n	1e1ce <attcMsgCback+0x66>
        (pCcb->outReq.hdr.event > ATTC_MSG_API_MTU)   ||
   1e1b0:	68fb      	ldr	r3, [r7, #12]
   1e1b2:	7c9b      	ldrb	r3, [r3, #18]
    if ((pCcb->onDeck.hdr.event != ATTC_MSG_API_NONE) ||
   1e1b4:	2b01      	cmp	r3, #1
   1e1b6:	d80a      	bhi.n	1e1ce <attcMsgCback+0x66>
        ((pMsg->hdr.event == ATTC_MSG_API_WRITE_CMD)  &&
   1e1b8:	687b      	ldr	r3, [r7, #4]
   1e1ba:	789b      	ldrb	r3, [r3, #2]
        (pCcb->outReq.hdr.event > ATTC_MSG_API_MTU)   ||
   1e1bc:	2b0a      	cmp	r3, #10
   1e1be:	d10c      	bne.n	1e1da <attcMsgCback+0x72>
         attcPendWriteCmd(pCcb, pMsg)))
   1e1c0:	6879      	ldr	r1, [r7, #4]
   1e1c2:	68f8      	ldr	r0, [r7, #12]
   1e1c4:	f7ff fcaf 	bl	1db26 <attcPendWriteCmd>
   1e1c8:	4603      	mov	r3, r0
        ((pMsg->hdr.event == ATTC_MSG_API_WRITE_CMD)  &&
   1e1ca:	2b00      	cmp	r3, #0
   1e1cc:	d005      	beq.n	1e1da <attcMsgCback+0x72>
    {
      /* free request and call callback with failure status */
      attcReqClear(pCcb, pMsg, ATT_ERR_OVERFLOW);
   1e1ce:	2272      	movs	r2, #114	; 0x72
   1e1d0:	6879      	ldr	r1, [r7, #4]
   1e1d2:	68f8      	ldr	r0, [r7, #12]
   1e1d4:	f000 f8e4 	bl	1e3a0 <attcReqClear>
      return;
   1e1d8:	e068      	b.n	1e2ac <attcMsgCback+0x144>
    }

    /* if MTU request in progress or flow controlled */
    if (pCcb->outReq.hdr.event == ATTC_MSG_API_MTU || pCcb->flowDisabled)
   1e1da:	68fb      	ldr	r3, [r7, #12]
   1e1dc:	7c9b      	ldrb	r3, [r3, #18]
   1e1de:	2b01      	cmp	r3, #1
   1e1e0:	d004      	beq.n	1e1ec <attcMsgCback+0x84>
   1e1e2:	68fb      	ldr	r3, [r7, #12]
   1e1e4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1e1e8:	2b00      	cmp	r3, #0
   1e1ea:	d006      	beq.n	1e1fa <attcMsgCback+0x92>
    {
      /* put request "on deck" for processing later */
      pCcb->onDeck = *pMsg;
   1e1ec:	68fb      	ldr	r3, [r7, #12]
   1e1ee:	687a      	ldr	r2, [r7, #4]
   1e1f0:	3304      	adds	r3, #4
   1e1f2:	ca07      	ldmia	r2, {r0, r1, r2}
   1e1f4:	e883 0007 	stmia.w	r3, {r0, r1, r2}
   1e1f8:	e058      	b.n	1e2ac <attcMsgCback+0x144>
    }
    /* otherwise ready to send; set up request */
    else
    {
      attcSetupReq(pCcb, pMsg);
   1e1fa:	6879      	ldr	r1, [r7, #4]
   1e1fc:	68f8      	ldr	r0, [r7, #12]
   1e1fe:	f7ff feb3 	bl	1df68 <attcSetupReq>
   1e202:	e053      	b.n	1e2ac <attcMsgCback+0x144>
    }
  }
  /* else if signed data event */
  else if (pMsg->hdr.event >= ATTC_MSG_API_SIGNED_WRITE_CMD &&
   1e204:	687b      	ldr	r3, [r7, #4]
   1e206:	789b      	ldrb	r3, [r3, #2]
   1e208:	2b0c      	cmp	r3, #12
   1e20a:	d910      	bls.n	1e22e <attcMsgCback+0xc6>
           pMsg->hdr.event <= ATTC_MSG_CMAC_CMPL)
   1e20c:	687b      	ldr	r3, [r7, #4]
   1e20e:	789b      	ldrb	r3, [r3, #2]
  else if (pMsg->hdr.event >= ATTC_MSG_API_SIGNED_WRITE_CMD &&
   1e210:	2b0e      	cmp	r3, #14
   1e212:	d80c      	bhi.n	1e22e <attcMsgCback+0xc6>
  {
    /* pass to message callback for signed data */
    if (attcCb.pSign != NULL)
   1e214:	4b27      	ldr	r3, [pc, #156]	; (1e2b4 <attcMsgCback+0x14c>)
   1e216:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   1e21a:	2b00      	cmp	r3, #0
   1e21c:	d046      	beq.n	1e2ac <attcMsgCback+0x144>
    {
      (*attcCb.pSign->msgCback)(pCcb, pMsg);
   1e21e:	4b25      	ldr	r3, [pc, #148]	; (1e2b4 <attcMsgCback+0x14c>)
   1e220:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
   1e224:	681b      	ldr	r3, [r3, #0]
   1e226:	6879      	ldr	r1, [r7, #4]
   1e228:	68f8      	ldr	r0, [r7, #12]
   1e22a:	4798      	blx	r3
    if (attcCb.pSign != NULL)
   1e22c:	e03e      	b.n	1e2ac <attcMsgCback+0x144>
    }
  }
  /* else if cancel request */
  else if (pMsg->hdr.event == ATTC_MSG_API_CANCEL)
   1e22e:	687b      	ldr	r3, [r7, #4]
   1e230:	789b      	ldrb	r3, [r3, #2]
   1e232:	2b0f      	cmp	r3, #15
   1e234:	d120      	bne.n	1e278 <attcMsgCback+0x110>
  {
    /* free any out req (except mtu req) */
    if (pCcb->outReq.hdr.event != ATTC_MSG_API_NONE &&
   1e236:	68fb      	ldr	r3, [r7, #12]
   1e238:	7c9b      	ldrb	r3, [r3, #18]
   1e23a:	2b00      	cmp	r3, #0
   1e23c:	d010      	beq.n	1e260 <attcMsgCback+0xf8>
        pCcb->outReq.hdr.event != ATTC_MSG_API_MTU)
   1e23e:	68fb      	ldr	r3, [r7, #12]
   1e240:	7c9b      	ldrb	r3, [r3, #18]
    if (pCcb->outReq.hdr.event != ATTC_MSG_API_NONE &&
   1e242:	2b01      	cmp	r3, #1
   1e244:	d00c      	beq.n	1e260 <attcMsgCback+0xf8>
    {
      WsfTimerStop(&pCcb->outReqTimer);
   1e246:	68fb      	ldr	r3, [r7, #12]
   1e248:	3324      	adds	r3, #36	; 0x24
   1e24a:	4618      	mov	r0, r3
   1e24c:	f00f faf4 	bl	2d838 <WsfTimerStop>
      attcReqClear(pCcb, &pCcb->outReq, ATT_ERR_CANCELLED);
   1e250:	68fb      	ldr	r3, [r7, #12]
   1e252:	3310      	adds	r3, #16
   1e254:	2274      	movs	r2, #116	; 0x74
   1e256:	4619      	mov	r1, r3
   1e258:	68f8      	ldr	r0, [r7, #12]
   1e25a:	f000 f8a1 	bl	1e3a0 <attcReqClear>
   1e25e:	e025      	b.n	1e2ac <attcMsgCback+0x144>
    }
    /* else free any req on deck */
    else if (pCcb->onDeck.hdr.event != ATTC_MSG_API_NONE)
   1e260:	68fb      	ldr	r3, [r7, #12]
   1e262:	799b      	ldrb	r3, [r3, #6]
   1e264:	2b00      	cmp	r3, #0
   1e266:	d021      	beq.n	1e2ac <attcMsgCback+0x144>
    {
      attcReqClear(pCcb, &pCcb->onDeck, ATT_ERR_CANCELLED);
   1e268:	68fb      	ldr	r3, [r7, #12]
   1e26a:	3304      	adds	r3, #4
   1e26c:	2274      	movs	r2, #116	; 0x74
   1e26e:	4619      	mov	r1, r3
   1e270:	68f8      	ldr	r0, [r7, #12]
   1e272:	f000 f895 	bl	1e3a0 <attcReqClear>
   1e276:	e019      	b.n	1e2ac <attcMsgCback+0x144>
    }
  }
  /* else if timeout */
  else if (pMsg->hdr.event == ATTC_MSG_REQ_TIMEOUT)
   1e278:	687b      	ldr	r3, [r7, #4]
   1e27a:	789b      	ldrb	r3, [r3, #2]
   1e27c:	2b10      	cmp	r3, #16
   1e27e:	d115      	bne.n	1e2ac <attcMsgCback+0x144>
  {
    /* free any out req */
    if (pCcb->outReq.hdr.event != ATTC_MSG_API_NONE)
   1e280:	68fb      	ldr	r3, [r7, #12]
   1e282:	7c9b      	ldrb	r3, [r3, #18]
   1e284:	2b00      	cmp	r3, #0
   1e286:	d011      	beq.n	1e2ac <attcMsgCback+0x144>
    {
      attcReqClear(pCcb, &pCcb->outReq, ATT_ERR_TIMEOUT);
   1e288:	68fb      	ldr	r3, [r7, #12]
   1e28a:	3310      	adds	r3, #16
   1e28c:	2271      	movs	r2, #113	; 0x71
   1e28e:	4619      	mov	r1, r3
   1e290:	68f8      	ldr	r0, [r7, #12]
   1e292:	f000 f885 	bl	1e3a0 <attcReqClear>
      pCcb->pMainCcb->control |= ATT_CCB_STATUS_TX_TIMEOUT;
   1e296:	68fb      	ldr	r3, [r7, #12]
   1e298:	681b      	ldr	r3, [r3, #0]
   1e29a:	7f5a      	ldrb	r2, [r3, #29]
   1e29c:	68fb      	ldr	r3, [r7, #12]
   1e29e:	681b      	ldr	r3, [r3, #0]
   1e2a0:	f042 0204 	orr.w	r2, r2, #4
   1e2a4:	b2d2      	uxtb	r2, r2
   1e2a6:	775a      	strb	r2, [r3, #29]
   1e2a8:	e000      	b.n	1e2ac <attcMsgCback+0x144>
    return;
   1e2aa:	bf00      	nop
    }
  }
}
   1e2ac:	3710      	adds	r7, #16
   1e2ae:	46bd      	mov	sp, r7
   1e2b0:	bd80      	pop	{r7, pc}
   1e2b2:	bf00      	nop
   1e2b4:	100110c8 	.word	0x100110c8

0001e2b8 <attcCcbByConnId>:
 *
 *  \return Pointer to connection control block or NULL if not in use.
 */
/*************************************************************************************************/
attcCcb_t *attcCcbByConnId(dmConnId_t connId)
{
   1e2b8:	b580      	push	{r7, lr}
   1e2ba:	b082      	sub	sp, #8
   1e2bc:	af00      	add	r7, sp, #0
   1e2be:	4603      	mov	r3, r0
   1e2c0:	71fb      	strb	r3, [r7, #7]
  if (DmConnInUse(connId))
   1e2c2:	79fb      	ldrb	r3, [r7, #7]
   1e2c4:	4618      	mov	r0, r3
   1e2c6:	f005 f8ff 	bl	234c8 <DmConnInUse>
   1e2ca:	4603      	mov	r3, r0
   1e2cc:	2b00      	cmp	r3, #0
   1e2ce:	d008      	beq.n	1e2e2 <attcCcbByConnId+0x2a>
  {
    return &attcCb.ccb[connId - 1];
   1e2d0:	79fb      	ldrb	r3, [r7, #7]
   1e2d2:	1e5a      	subs	r2, r3, #1
   1e2d4:	4613      	mov	r3, r2
   1e2d6:	00db      	lsls	r3, r3, #3
   1e2d8:	1a9b      	subs	r3, r3, r2
   1e2da:	00db      	lsls	r3, r3, #3
   1e2dc:	4a06      	ldr	r2, [pc, #24]	; (1e2f8 <attcCcbByConnId+0x40>)
   1e2de:	4413      	add	r3, r2
   1e2e0:	e005      	b.n	1e2ee <attcCcbByConnId+0x36>
  }
  else
  {
    ATT_TRACE_WARN1("attc ccb not in use: %d", connId);
   1e2e2:	79fb      	ldrb	r3, [r7, #7]
   1e2e4:	4619      	mov	r1, r3
   1e2e6:	4805      	ldr	r0, [pc, #20]	; (1e2fc <attcCcbByConnId+0x44>)
   1e2e8:	f00f fb52 	bl	2d990 <WsfTrace>
    return NULL;
   1e2ec:	2300      	movs	r3, #0
  }
}
   1e2ee:	4618      	mov	r0, r3
   1e2f0:	3708      	adds	r7, #8
   1e2f2:	46bd      	mov	sp, r7
   1e2f4:	bd80      	pop	{r7, pc}
   1e2f6:	bf00      	nop
   1e2f8:	100110c8 	.word	0x100110c8
   1e2fc:	00044830 	.word	0x00044830

0001e300 <attcCcbByHandle>:
 *
 *  \return Pointer to connection control block or NULL if not found.
 */
/*************************************************************************************************/
attcCcb_t *attcCcbByHandle(uint16_t handle)
{
   1e300:	b580      	push	{r7, lr}
   1e302:	b084      	sub	sp, #16
   1e304:	af00      	add	r7, sp, #0
   1e306:	4603      	mov	r3, r0
   1e308:	80fb      	strh	r3, [r7, #6]
  dmConnId_t  connId;

  if ((connId = DmConnIdByHandle(handle)) != DM_CONN_ID_NONE)
   1e30a:	88fb      	ldrh	r3, [r7, #6]
   1e30c:	4618      	mov	r0, r3
   1e30e:	f005 f8b3 	bl	23478 <DmConnIdByHandle>
   1e312:	4603      	mov	r3, r0
   1e314:	73fb      	strb	r3, [r7, #15]
   1e316:	7bfb      	ldrb	r3, [r7, #15]
   1e318:	2b00      	cmp	r3, #0
   1e31a:	d008      	beq.n	1e32e <attcCcbByHandle+0x2e>
  {
    return &attcCb.ccb[connId - 1];
   1e31c:	7bfb      	ldrb	r3, [r7, #15]
   1e31e:	1e5a      	subs	r2, r3, #1
   1e320:	4613      	mov	r3, r2
   1e322:	00db      	lsls	r3, r3, #3
   1e324:	1a9b      	subs	r3, r3, r2
   1e326:	00db      	lsls	r3, r3, #3
   1e328:	4a03      	ldr	r2, [pc, #12]	; (1e338 <attcCcbByHandle+0x38>)
   1e32a:	4413      	add	r3, r2
   1e32c:	e000      	b.n	1e330 <attcCcbByHandle+0x30>
  }

  return NULL;
   1e32e:	2300      	movs	r3, #0
}
   1e330:	4618      	mov	r0, r3
   1e332:	3710      	adds	r7, #16
   1e334:	46bd      	mov	sp, r7
   1e336:	bd80      	pop	{r7, pc}
   1e338:	100110c8 	.word	0x100110c8

0001e33c <attcFreePkt>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcFreePkt(attcApiMsg_t *pMsg)
{
   1e33c:	b580      	push	{r7, lr}
   1e33e:	b082      	sub	sp, #8
   1e340:	af00      	add	r7, sp, #0
   1e342:	6078      	str	r0, [r7, #4]
  if (pMsg->pPkt != NULL)
   1e344:	687b      	ldr	r3, [r7, #4]
   1e346:	685b      	ldr	r3, [r3, #4]
   1e348:	2b00      	cmp	r3, #0
   1e34a:	d007      	beq.n	1e35c <attcFreePkt+0x20>
  {
    WsfMsgFree(pMsg->pPkt);
   1e34c:	687b      	ldr	r3, [r7, #4]
   1e34e:	685b      	ldr	r3, [r3, #4]
   1e350:	4618      	mov	r0, r3
   1e352:	f00e fec3 	bl	2d0dc <WsfMsgFree>
    pMsg->pPkt = NULL;
   1e356:	687b      	ldr	r3, [r7, #4]
   1e358:	2200      	movs	r2, #0
   1e35a:	605a      	str	r2, [r3, #4]
  }
}
   1e35c:	bf00      	nop
   1e35e:	3708      	adds	r7, #8
   1e360:	46bd      	mov	sp, r7
   1e362:	bd80      	pop	{r7, pc}

0001e364 <attcExecCallback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcExecCallback(dmConnId_t connId, uint8_t event, uint16_t handle, uint8_t status)
{
   1e364:	b590      	push	{r4, r7, lr}
   1e366:	b085      	sub	sp, #20
   1e368:	af02      	add	r7, sp, #8
   1e36a:	4604      	mov	r4, r0
   1e36c:	4608      	mov	r0, r1
   1e36e:	4611      	mov	r1, r2
   1e370:	461a      	mov	r2, r3
   1e372:	4623      	mov	r3, r4
   1e374:	71fb      	strb	r3, [r7, #7]
   1e376:	4603      	mov	r3, r0
   1e378:	71bb      	strb	r3, [r7, #6]
   1e37a:	460b      	mov	r3, r1
   1e37c:	80bb      	strh	r3, [r7, #4]
   1e37e:	4613      	mov	r3, r2
   1e380:	70fb      	strb	r3, [r7, #3]
  if (event != ATT_METHOD_MTU)
   1e382:	79bb      	ldrb	r3, [r7, #6]
   1e384:	2b01      	cmp	r3, #1
   1e386:	d007      	beq.n	1e398 <attcExecCallback+0x34>
  {
    attExecCallback(connId, event, handle, status, 0);
   1e388:	78fb      	ldrb	r3, [r7, #3]
   1e38a:	88ba      	ldrh	r2, [r7, #4]
   1e38c:	79b9      	ldrb	r1, [r7, #6]
   1e38e:	79f8      	ldrb	r0, [r7, #7]
   1e390:	2400      	movs	r4, #0
   1e392:	9400      	str	r4, [sp, #0]
   1e394:	f7ff fafa 	bl	1d98c <attExecCallback>
  }
}
   1e398:	bf00      	nop
   1e39a:	370c      	adds	r7, #12
   1e39c:	46bd      	mov	sp, r7
   1e39e:	bd90      	pop	{r4, r7, pc}

0001e3a0 <attcReqClear>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcReqClear(attcCcb_t *pCcb, attcApiMsg_t *pMsg, uint8_t status)
{
   1e3a0:	b580      	push	{r7, lr}
   1e3a2:	b084      	sub	sp, #16
   1e3a4:	af00      	add	r7, sp, #0
   1e3a6:	60f8      	str	r0, [r7, #12]
   1e3a8:	60b9      	str	r1, [r7, #8]
   1e3aa:	4613      	mov	r3, r2
   1e3ac:	71fb      	strb	r3, [r7, #7]
  attcFreePkt(pMsg);
   1e3ae:	68b8      	ldr	r0, [r7, #8]
   1e3b0:	f7ff ffc4 	bl	1e33c <attcFreePkt>
  attcExecCallback(pCcb->pMainCcb->connId, pMsg->hdr.event, pMsg->handle, status);
   1e3b4:	68fb      	ldr	r3, [r7, #12]
   1e3b6:	681b      	ldr	r3, [r3, #0]
   1e3b8:	7f18      	ldrb	r0, [r3, #28]
   1e3ba:	68bb      	ldr	r3, [r7, #8]
   1e3bc:	7899      	ldrb	r1, [r3, #2]
   1e3be:	68bb      	ldr	r3, [r7, #8]
   1e3c0:	891a      	ldrh	r2, [r3, #8]
   1e3c2:	79fb      	ldrb	r3, [r7, #7]
   1e3c4:	f7ff ffce 	bl	1e364 <attcExecCallback>
  pMsg->hdr.event = ATTC_MSG_API_NONE;
   1e3c8:	68bb      	ldr	r3, [r7, #8]
   1e3ca:	2200      	movs	r2, #0
   1e3cc:	709a      	strb	r2, [r3, #2]
}
   1e3ce:	bf00      	nop
   1e3d0:	3710      	adds	r7, #16
   1e3d2:	46bd      	mov	sp, r7
   1e3d4:	bd80      	pop	{r7, pc}
	...

0001e3d8 <AttcInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttcInit(void)
{
   1e3d8:	b480      	push	{r7}
   1e3da:	b083      	sub	sp, #12
   1e3dc:	af00      	add	r7, sp, #0
  uint8_t     i;
  attcCcb_t   *pCcb;

  /* Initialize control block */
  attcCb.pSign = NULL;
   1e3de:	4b1a      	ldr	r3, [pc, #104]	; (1e448 <AttcInit+0x70>)
   1e3e0:	2200      	movs	r2, #0
   1e3e2:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  attcCb.autoCnf = TRUE;
   1e3e6:	4b18      	ldr	r3, [pc, #96]	; (1e448 <AttcInit+0x70>)
   1e3e8:	2201      	movs	r2, #1
   1e3ea:	f883 20ac 	strb.w	r2, [r3, #172]	; 0xac

  /* Initialize control block CCBs */
  for (i = 0, pCcb = attcCb.ccb; i < DM_CONN_MAX; i++, pCcb++)
   1e3ee:	2300      	movs	r3, #0
   1e3f0:	71fb      	strb	r3, [r7, #7]
   1e3f2:	4b15      	ldr	r3, [pc, #84]	; (1e448 <AttcInit+0x70>)
   1e3f4:	603b      	str	r3, [r7, #0]
   1e3f6:	e01a      	b.n	1e42e <AttcInit+0x56>
  {
    /* set pointer to main CCB */
    pCcb->pMainCcb = &attCb.ccb[i];
   1e3f8:	79fa      	ldrb	r2, [r7, #7]
   1e3fa:	4613      	mov	r3, r2
   1e3fc:	00db      	lsls	r3, r3, #3
   1e3fe:	4413      	add	r3, r2
   1e400:	009b      	lsls	r3, r3, #2
   1e402:	4a12      	ldr	r2, [pc, #72]	; (1e44c <AttcInit+0x74>)
   1e404:	441a      	add	r2, r3
   1e406:	683b      	ldr	r3, [r7, #0]
   1e408:	601a      	str	r2, [r3, #0]

    /* initialize timer */
    pCcb->outReqTimer.handlerId = attCb.handlerId;
   1e40a:	4b10      	ldr	r3, [pc, #64]	; (1e44c <AttcInit+0x74>)
   1e40c:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
   1e410:	683b      	ldr	r3, [r7, #0]
   1e412:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
    pCcb->outReqTimer.msg.param = i + 1;  /* param stores the conn id */
   1e416:	79fb      	ldrb	r3, [r7, #7]
   1e418:	b29b      	uxth	r3, r3
   1e41a:	3301      	adds	r3, #1
   1e41c:	b29a      	uxth	r2, r3
   1e41e:	683b      	ldr	r3, [r7, #0]
   1e420:	859a      	strh	r2, [r3, #44]	; 0x2c
  for (i = 0, pCcb = attcCb.ccb; i < DM_CONN_MAX; i++, pCcb++)
   1e422:	79fb      	ldrb	r3, [r7, #7]
   1e424:	3301      	adds	r3, #1
   1e426:	71fb      	strb	r3, [r7, #7]
   1e428:	683b      	ldr	r3, [r7, #0]
   1e42a:	3338      	adds	r3, #56	; 0x38
   1e42c:	603b      	str	r3, [r7, #0]
   1e42e:	79fb      	ldrb	r3, [r7, #7]
   1e430:	2b02      	cmp	r3, #2
   1e432:	d9e1      	bls.n	1e3f8 <AttcInit+0x20>
  }

  /* set up callback interface */
  attCb.pClient = &attcFcnIf;
   1e434:	4b05      	ldr	r3, [pc, #20]	; (1e44c <AttcInit+0x74>)
   1e436:	4a06      	ldr	r2, [pc, #24]	; (1e450 <AttcInit+0x78>)
   1e438:	66da      	str	r2, [r3, #108]	; 0x6c
}
   1e43a:	bf00      	nop
   1e43c:	370c      	adds	r7, #12
   1e43e:	46bd      	mov	sp, r7
   1e440:	f85d 7b04 	ldr.w	r7, [sp], #4
   1e444:	4770      	bx	lr
   1e446:	bf00      	nop
   1e448:	100110c8 	.word	0x100110c8
   1e44c:	10011048 	.word	0x10011048
   1e450:	00045b00 	.word	0x00045b00

0001e454 <attcProcErrRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcErrRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1e454:	b480      	push	{r7}
   1e456:	b087      	sub	sp, #28
   1e458:	af00      	add	r7, sp, #0
   1e45a:	60f8      	str	r0, [r7, #12]
   1e45c:	607a      	str	r2, [r7, #4]
   1e45e:	603b      	str	r3, [r7, #0]
   1e460:	460b      	mov	r3, r1
   1e462:	817b      	strh	r3, [r7, #10]
  uint8_t *p;

  p =  pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN;
   1e464:	687b      	ldr	r3, [r7, #4]
   1e466:	3309      	adds	r3, #9
   1e468:	617b      	str	r3, [r7, #20]

  /* set callback event from stored method */
  pEvt->hdr.event = pCcb->outReq.hdr.event;
   1e46a:	68fb      	ldr	r3, [r7, #12]
   1e46c:	7c9a      	ldrb	r2, [r3, #18]
   1e46e:	683b      	ldr	r3, [r7, #0]
   1e470:	709a      	strb	r2, [r3, #2]

  /* ignore request opcode in the error response */
  p++;
   1e472:	697b      	ldr	r3, [r7, #20]
   1e474:	3301      	adds	r3, #1
   1e476:	617b      	str	r3, [r7, #20]

  /* if request was a read or write with a specific handle */
  if (pEvt->hdr.event == ATTC_READ_RSP || pEvt->hdr.event == ATTC_READ_LONG_RSP ||
   1e478:	683b      	ldr	r3, [r7, #0]
   1e47a:	789b      	ldrb	r3, [r3, #2]
   1e47c:	2b05      	cmp	r3, #5
   1e47e:	d00b      	beq.n	1e498 <attcProcErrRsp+0x44>
   1e480:	683b      	ldr	r3, [r7, #0]
   1e482:	789b      	ldrb	r3, [r3, #2]
   1e484:	2b06      	cmp	r3, #6
   1e486:	d007      	beq.n	1e498 <attcProcErrRsp+0x44>
      pEvt->hdr.event == ATTC_WRITE_RSP || pEvt->hdr.event == ATTC_PREPARE_WRITE_RSP)
   1e488:	683b      	ldr	r3, [r7, #0]
   1e48a:	789b      	ldrb	r3, [r3, #2]
  if (pEvt->hdr.event == ATTC_READ_RSP || pEvt->hdr.event == ATTC_READ_LONG_RSP ||
   1e48c:	2b09      	cmp	r3, #9
   1e48e:	d003      	beq.n	1e498 <attcProcErrRsp+0x44>
      pEvt->hdr.event == ATTC_WRITE_RSP || pEvt->hdr.event == ATTC_PREPARE_WRITE_RSP)
   1e490:	683b      	ldr	r3, [r7, #0]
   1e492:	789b      	ldrb	r3, [r3, #2]
   1e494:	2b0b      	cmp	r3, #11
   1e496:	d103      	bne.n	1e4a0 <attcProcErrRsp+0x4c>
  {
    /* ignore handle in the error response; callback will use stored handle from request */
    p += 2;
   1e498:	697b      	ldr	r3, [r7, #20]
   1e49a:	3302      	adds	r3, #2
   1e49c:	617b      	str	r3, [r7, #20]
   1e49e:	e00f      	b.n	1e4c0 <attcProcErrRsp+0x6c>
  }
  else
  {
    /* set handle from packet */
    BSTREAM_TO_UINT16(pEvt->handle, p);
   1e4a0:	697b      	ldr	r3, [r7, #20]
   1e4a2:	781b      	ldrb	r3, [r3, #0]
   1e4a4:	b29a      	uxth	r2, r3
   1e4a6:	697b      	ldr	r3, [r7, #20]
   1e4a8:	3301      	adds	r3, #1
   1e4aa:	781b      	ldrb	r3, [r3, #0]
   1e4ac:	b29b      	uxth	r3, r3
   1e4ae:	021b      	lsls	r3, r3, #8
   1e4b0:	b29b      	uxth	r3, r3
   1e4b2:	4413      	add	r3, r2
   1e4b4:	b29a      	uxth	r2, r3
   1e4b6:	683b      	ldr	r3, [r7, #0]
   1e4b8:	815a      	strh	r2, [r3, #10]
   1e4ba:	697b      	ldr	r3, [r7, #20]
   1e4bc:	3302      	adds	r3, #2
   1e4be:	617b      	str	r3, [r7, #20]
  }

  /* set status from error code in packet, but verify it's not 'success' */
  BSTREAM_TO_UINT8(pEvt->hdr.status, p);
   1e4c0:	697b      	ldr	r3, [r7, #20]
   1e4c2:	1c5a      	adds	r2, r3, #1
   1e4c4:	617a      	str	r2, [r7, #20]
   1e4c6:	781a      	ldrb	r2, [r3, #0]
   1e4c8:	683b      	ldr	r3, [r7, #0]
   1e4ca:	70da      	strb	r2, [r3, #3]
  if (pEvt->hdr.status == ATT_SUCCESS)
   1e4cc:	683b      	ldr	r3, [r7, #0]
   1e4ce:	78db      	ldrb	r3, [r3, #3]
   1e4d0:	2b00      	cmp	r3, #0
   1e4d2:	d102      	bne.n	1e4da <attcProcErrRsp+0x86>
  {
    pEvt->hdr.status = ATT_ERR_UNDEFINED;
   1e4d4:	683b      	ldr	r3, [r7, #0]
   1e4d6:	2275      	movs	r2, #117	; 0x75
   1e4d8:	70da      	strb	r2, [r3, #3]
  }

  /* no parameters so clear length */
  pEvt->valueLen = 0;
   1e4da:	683b      	ldr	r3, [r7, #0]
   1e4dc:	2200      	movs	r2, #0
   1e4de:	811a      	strh	r2, [r3, #8]
}
   1e4e0:	bf00      	nop
   1e4e2:	371c      	adds	r7, #28
   1e4e4:	46bd      	mov	sp, r7
   1e4e6:	f85d 7b04 	ldr.w	r7, [sp], #4
   1e4ea:	4770      	bx	lr

0001e4ec <attcProcMtuRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcMtuRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1e4ec:	b5b0      	push	{r4, r5, r7, lr}
   1e4ee:	b086      	sub	sp, #24
   1e4f0:	af00      	add	r7, sp, #0
   1e4f2:	60f8      	str	r0, [r7, #12]
   1e4f4:	607a      	str	r2, [r7, #4]
   1e4f6:	603b      	str	r3, [r7, #0]
   1e4f8:	460b      	mov	r3, r1
   1e4fa:	817b      	strh	r3, [r7, #10]
  uint16_t  mtu;

  BYTES_TO_UINT16(mtu, pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN);
   1e4fc:	687b      	ldr	r3, [r7, #4]
   1e4fe:	3309      	adds	r3, #9
   1e500:	781b      	ldrb	r3, [r3, #0]
   1e502:	b29a      	uxth	r2, r3
   1e504:	687b      	ldr	r3, [r7, #4]
   1e506:	330a      	adds	r3, #10
   1e508:	781b      	ldrb	r3, [r3, #0]
   1e50a:	b29b      	uxth	r3, r3
   1e50c:	021b      	lsls	r3, r3, #8
   1e50e:	b29b      	uxth	r3, r3
   1e510:	4413      	add	r3, r2
   1e512:	82fb      	strh	r3, [r7, #22]

  /* verify */
  if (mtu < ATT_DEFAULT_MTU)
   1e514:	8afb      	ldrh	r3, [r7, #22]
   1e516:	2b16      	cmp	r3, #22
   1e518:	d801      	bhi.n	1e51e <attcProcMtuRsp+0x32>
  {
    mtu = ATT_DEFAULT_MTU;
   1e51a:	2317      	movs	r3, #23
   1e51c:	82fb      	strh	r3, [r7, #22]
  }

  /* set mtu for the connection */
  attSetMtu(pCcb->pMainCcb, mtu, WSF_MIN(pAttCfg->mtu, (HciGetMaxRxAclLen() - L2C_HDR_LEN)));
   1e51e:	68fb      	ldr	r3, [r7, #12]
   1e520:	681c      	ldr	r4, [r3, #0]
   1e522:	4b0e      	ldr	r3, [pc, #56]	; (1e55c <attcProcMtuRsp+0x70>)
   1e524:	681b      	ldr	r3, [r3, #0]
   1e526:	889b      	ldrh	r3, [r3, #4]
   1e528:	461d      	mov	r5, r3
   1e52a:	f007 ff9d 	bl	26468 <HciGetMaxRxAclLen>
   1e52e:	4603      	mov	r3, r0
   1e530:	3b04      	subs	r3, #4
   1e532:	429d      	cmp	r5, r3
   1e534:	da03      	bge.n	1e53e <attcProcMtuRsp+0x52>
   1e536:	4b09      	ldr	r3, [pc, #36]	; (1e55c <attcProcMtuRsp+0x70>)
   1e538:	681b      	ldr	r3, [r3, #0]
   1e53a:	889b      	ldrh	r3, [r3, #4]
   1e53c:	e004      	b.n	1e548 <attcProcMtuRsp+0x5c>
   1e53e:	f007 ff93 	bl	26468 <HciGetMaxRxAclLen>
   1e542:	4603      	mov	r3, r0
   1e544:	3b04      	subs	r3, #4
   1e546:	b29b      	uxth	r3, r3
   1e548:	8af9      	ldrh	r1, [r7, #22]
   1e54a:	461a      	mov	r2, r3
   1e54c:	4620      	mov	r0, r4
   1e54e:	f7ff f9f9 	bl	1d944 <attSetMtu>
}
   1e552:	bf00      	nop
   1e554:	3718      	adds	r7, #24
   1e556:	46bd      	mov	sp, r7
   1e558:	bdb0      	pop	{r4, r5, r7, pc}
   1e55a:	bf00      	nop
   1e55c:	10002b8c 	.word	0x10002b8c

0001e560 <attcProcFindOrReadRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcFindOrReadRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1e560:	b480      	push	{r7}
   1e562:	b08b      	sub	sp, #44	; 0x2c
   1e564:	af00      	add	r7, sp, #0
   1e566:	60f8      	str	r0, [r7, #12]
   1e568:	607a      	str	r2, [r7, #4]
   1e56a:	603b      	str	r3, [r7, #0]
   1e56c:	460b      	mov	r3, r1
   1e56e:	817b      	strh	r3, [r7, #10]
  uint16_t  handle;
  uint16_t  nextHandle;
  uint16_t  prevHandle;
  uint8_t   paramLen;

  p = pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN;
   1e570:	687b      	ldr	r3, [r7, #4]
   1e572:	3309      	adds	r3, #9
   1e574:	627b      	str	r3, [r7, #36]	; 0x24
  pEnd = pPacket + L2C_PAYLOAD_START + len;
   1e576:	897b      	ldrh	r3, [r7, #10]
   1e578:	3308      	adds	r3, #8
   1e57a:	687a      	ldr	r2, [r7, #4]
   1e57c:	4413      	add	r3, r2
   1e57e:	61bb      	str	r3, [r7, #24]

  /* parameter length depends on packet type */
  if (pCcb->outReq.hdr.event == ATTC_MSG_API_FIND_INFO)
   1e580:	68fb      	ldr	r3, [r7, #12]
   1e582:	7c9b      	ldrb	r3, [r3, #18]
   1e584:	2b02      	cmp	r3, #2
   1e586:	d10b      	bne.n	1e5a0 <attcProcFindOrReadRsp+0x40>
  {
    /* length in find info response is coded by UUID */
    if (*p++ == ATT_FIND_HANDLE_16_UUID)
   1e588:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e58a:	1c5a      	adds	r2, r3, #1
   1e58c:	627a      	str	r2, [r7, #36]	; 0x24
   1e58e:	781b      	ldrb	r3, [r3, #0]
   1e590:	2b01      	cmp	r3, #1
   1e592:	d102      	bne.n	1e59a <attcProcFindOrReadRsp+0x3a>
    {
      paramLen = ATT_16_UUID_LEN;
   1e594:	2302      	movs	r3, #2
   1e596:	77fb      	strb	r3, [r7, #31]
   1e598:	e013      	b.n	1e5c2 <attcProcFindOrReadRsp+0x62>
    }
    else
    {
      paramLen = ATT_128_UUID_LEN;
   1e59a:	2310      	movs	r3, #16
   1e59c:	77fb      	strb	r3, [r7, #31]
   1e59e:	e010      	b.n	1e5c2 <attcProcFindOrReadRsp+0x62>
    }
  }
  else if (pCcb->outReq.hdr.event == ATTC_MSG_API_READ_BY_TYPE)
   1e5a0:	68fb      	ldr	r3, [r7, #12]
   1e5a2:	7c9b      	ldrb	r3, [r3, #18]
   1e5a4:	2b04      	cmp	r3, #4
   1e5a6:	d106      	bne.n	1e5b6 <attcProcFindOrReadRsp+0x56>
  {
    /* length in read by type response is handle plus parameter length */
    paramLen = *p++ - sizeof(uint16_t);
   1e5a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e5aa:	1c5a      	adds	r2, r3, #1
   1e5ac:	627a      	str	r2, [r7, #36]	; 0x24
   1e5ae:	781b      	ldrb	r3, [r3, #0]
   1e5b0:	3b02      	subs	r3, #2
   1e5b2:	77fb      	strb	r3, [r7, #31]
   1e5b4:	e005      	b.n	1e5c2 <attcProcFindOrReadRsp+0x62>
  }
  else
  {
    /* length in read by group type response is two handles plus parameter length */
    paramLen = *p++ - (2 * sizeof(uint16_t));
   1e5b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e5b8:	1c5a      	adds	r2, r3, #1
   1e5ba:	627a      	str	r2, [r7, #36]	; 0x24
   1e5bc:	781b      	ldrb	r3, [r3, #0]
   1e5be:	3b04      	subs	r3, #4
   1e5c0:	77fb      	strb	r3, [r7, #31]
  }

  /* get and verify all handles */
  nextHandle = pCcb->outReqParams.h.startHandle;
   1e5c2:	68fb      	ldr	r3, [r7, #12]
   1e5c4:	8bdb      	ldrh	r3, [r3, #30]
   1e5c6:	843b      	strh	r3, [r7, #32]
  while (p < pEnd)
   1e5c8:	e05f      	b.n	1e68a <attcProcFindOrReadRsp+0x12a>
  {
    /* get and compare handle */
    BSTREAM_TO_UINT16(handle, p);
   1e5ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e5cc:	781b      	ldrb	r3, [r3, #0]
   1e5ce:	b29a      	uxth	r2, r3
   1e5d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e5d2:	3301      	adds	r3, #1
   1e5d4:	781b      	ldrb	r3, [r3, #0]
   1e5d6:	b29b      	uxth	r3, r3
   1e5d8:	021b      	lsls	r3, r3, #8
   1e5da:	b29b      	uxth	r3, r3
   1e5dc:	4413      	add	r3, r2
   1e5de:	847b      	strh	r3, [r7, #34]	; 0x22
   1e5e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e5e2:	3302      	adds	r3, #2
   1e5e4:	627b      	str	r3, [r7, #36]	; 0x24
    if (handle == 0 || nextHandle == 0 || handle < nextHandle ||
   1e5e6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   1e5e8:	2b00      	cmp	r3, #0
   1e5ea:	d00b      	beq.n	1e604 <attcProcFindOrReadRsp+0xa4>
   1e5ec:	8c3b      	ldrh	r3, [r7, #32]
   1e5ee:	2b00      	cmp	r3, #0
   1e5f0:	d008      	beq.n	1e604 <attcProcFindOrReadRsp+0xa4>
   1e5f2:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   1e5f4:	8c3b      	ldrh	r3, [r7, #32]
   1e5f6:	429a      	cmp	r2, r3
   1e5f8:	d304      	bcc.n	1e604 <attcProcFindOrReadRsp+0xa4>
        handle > pCcb->outReqParams.h.endHandle)
   1e5fa:	68fb      	ldr	r3, [r7, #12]
   1e5fc:	8c1b      	ldrh	r3, [r3, #32]
    if (handle == 0 || nextHandle == 0 || handle < nextHandle ||
   1e5fe:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   1e600:	429a      	cmp	r2, r3
   1e602:	d903      	bls.n	1e60c <attcProcFindOrReadRsp+0xac>
    {
      pEvt->hdr.status = ATT_ERR_INVALID_RSP;
   1e604:	683b      	ldr	r3, [r7, #0]
   1e606:	2273      	movs	r2, #115	; 0x73
   1e608:	70da      	strb	r2, [r3, #3]
      break;
   1e60a:	e042      	b.n	1e692 <attcProcFindOrReadRsp+0x132>
    }

    /* if read by group type response get second handle */
    if (pCcb->outReq.hdr.event == ATTC_MSG_API_READ_BY_GROUP_TYPE)
   1e60c:	68fb      	ldr	r3, [r7, #12]
   1e60e:	7c9b      	ldrb	r3, [r3, #18]
   1e610:	2b08      	cmp	r3, #8
   1e612:	d123      	bne.n	1e65c <attcProcFindOrReadRsp+0xfc>
    {
      prevHandle = handle;
   1e614:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   1e616:	82fb      	strh	r3, [r7, #22]
      BSTREAM_TO_UINT16(handle, p);
   1e618:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e61a:	781b      	ldrb	r3, [r3, #0]
   1e61c:	b29a      	uxth	r2, r3
   1e61e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e620:	3301      	adds	r3, #1
   1e622:	781b      	ldrb	r3, [r3, #0]
   1e624:	b29b      	uxth	r3, r3
   1e626:	021b      	lsls	r3, r3, #8
   1e628:	b29b      	uxth	r3, r3
   1e62a:	4413      	add	r3, r2
   1e62c:	847b      	strh	r3, [r7, #34]	; 0x22
   1e62e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e630:	3302      	adds	r3, #2
   1e632:	627b      	str	r3, [r7, #36]	; 0x24
      if (handle == 0 || handle < prevHandle || handle < nextHandle ||
   1e634:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   1e636:	2b00      	cmp	r3, #0
   1e638:	d00c      	beq.n	1e654 <attcProcFindOrReadRsp+0xf4>
   1e63a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   1e63c:	8afb      	ldrh	r3, [r7, #22]
   1e63e:	429a      	cmp	r2, r3
   1e640:	d308      	bcc.n	1e654 <attcProcFindOrReadRsp+0xf4>
   1e642:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   1e644:	8c3b      	ldrh	r3, [r7, #32]
   1e646:	429a      	cmp	r2, r3
   1e648:	d304      	bcc.n	1e654 <attcProcFindOrReadRsp+0xf4>
          handle > pCcb->outReqParams.h.endHandle)
   1e64a:	68fb      	ldr	r3, [r7, #12]
   1e64c:	8c1b      	ldrh	r3, [r3, #32]
      if (handle == 0 || handle < prevHandle || handle < nextHandle ||
   1e64e:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   1e650:	429a      	cmp	r2, r3
   1e652:	d903      	bls.n	1e65c <attcProcFindOrReadRsp+0xfc>
      {
        pEvt->hdr.status = ATT_ERR_INVALID_RSP;
   1e654:	683b      	ldr	r3, [r7, #0]
   1e656:	2273      	movs	r2, #115	; 0x73
   1e658:	70da      	strb	r2, [r3, #3]
        break;
   1e65a:	e01a      	b.n	1e692 <attcProcFindOrReadRsp+0x132>
      }
    }

    /* set next expected handle, with special case for max handle */
    if (handle == ATT_HANDLE_MAX)
   1e65c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   1e65e:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1e662:	4293      	cmp	r3, r2
   1e664:	d102      	bne.n	1e66c <attcProcFindOrReadRsp+0x10c>
    {
      nextHandle = 0;
   1e666:	2300      	movs	r3, #0
   1e668:	843b      	strh	r3, [r7, #32]
   1e66a:	e002      	b.n	1e672 <attcProcFindOrReadRsp+0x112>
    }
    else
    {
      nextHandle = handle + 1;
   1e66c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   1e66e:	3301      	adds	r3, #1
   1e670:	843b      	strh	r3, [r7, #32]
    }

    /* skip over parameter */
    p += paramLen;
   1e672:	7ffb      	ldrb	r3, [r7, #31]
   1e674:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1e676:	4413      	add	r3, r2
   1e678:	627b      	str	r3, [r7, #36]	; 0x24

    /* check for truncated response */
    if (p > pEnd)
   1e67a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1e67c:	69bb      	ldr	r3, [r7, #24]
   1e67e:	429a      	cmp	r2, r3
   1e680:	d903      	bls.n	1e68a <attcProcFindOrReadRsp+0x12a>
    {
      pEvt->hdr.status = ATT_ERR_INVALID_RSP;
   1e682:	683b      	ldr	r3, [r7, #0]
   1e684:	2273      	movs	r2, #115	; 0x73
   1e686:	70da      	strb	r2, [r3, #3]
      break;
   1e688:	e003      	b.n	1e692 <attcProcFindOrReadRsp+0x132>
  while (p < pEnd)
   1e68a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   1e68c:	69bb      	ldr	r3, [r7, #24]
   1e68e:	429a      	cmp	r2, r3
   1e690:	d39b      	bcc.n	1e5ca <attcProcFindOrReadRsp+0x6a>
    }
  }

  /* if response was correct */
  if (pEvt->hdr.status == ATT_SUCCESS)
   1e692:	683b      	ldr	r3, [r7, #0]
   1e694:	78db      	ldrb	r3, [r3, #3]
   1e696:	2b00      	cmp	r3, #0
   1e698:	d116      	bne.n	1e6c8 <attcProcFindOrReadRsp+0x168>
  {
    /* if continuing */
    if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1e69a:	68fb      	ldr	r3, [r7, #12]
   1e69c:	7cdb      	ldrb	r3, [r3, #19]
   1e69e:	2b01      	cmp	r3, #1
   1e6a0:	d112      	bne.n	1e6c8 <attcProcFindOrReadRsp+0x168>
    {
      /* if all handles read */
      if (nextHandle == 0 || nextHandle == (pCcb->outReqParams.h.endHandle + 1))
   1e6a2:	8c3b      	ldrh	r3, [r7, #32]
   1e6a4:	2b00      	cmp	r3, #0
   1e6a6:	d005      	beq.n	1e6b4 <attcProcFindOrReadRsp+0x154>
   1e6a8:	8c3a      	ldrh	r2, [r7, #32]
   1e6aa:	68fb      	ldr	r3, [r7, #12]
   1e6ac:	8c1b      	ldrh	r3, [r3, #32]
   1e6ae:	3301      	adds	r3, #1
   1e6b0:	429a      	cmp	r2, r3
   1e6b2:	d103      	bne.n	1e6bc <attcProcFindOrReadRsp+0x15c>
      {
        /* we're done */
        pCcb->outReq.hdr.status = ATTC_NOT_CONTINUING;
   1e6b4:	68fb      	ldr	r3, [r7, #12]
   1e6b6:	2200      	movs	r2, #0
   1e6b8:	74da      	strb	r2, [r3, #19]
        pCcb->outReqParams.h.startHandle = nextHandle;
        pCcb->outReq.handle = nextHandle;
      }
    }
  }
}
   1e6ba:	e005      	b.n	1e6c8 <attcProcFindOrReadRsp+0x168>
        pCcb->outReqParams.h.startHandle = nextHandle;
   1e6bc:	68fb      	ldr	r3, [r7, #12]
   1e6be:	8c3a      	ldrh	r2, [r7, #32]
   1e6c0:	83da      	strh	r2, [r3, #30]
        pCcb->outReq.handle = nextHandle;
   1e6c2:	68fb      	ldr	r3, [r7, #12]
   1e6c4:	8c3a      	ldrh	r2, [r7, #32]
   1e6c6:	831a      	strh	r2, [r3, #24]
}
   1e6c8:	bf00      	nop
   1e6ca:	372c      	adds	r7, #44	; 0x2c
   1e6cc:	46bd      	mov	sp, r7
   1e6ce:	f85d 7b04 	ldr.w	r7, [sp], #4
   1e6d2:	4770      	bx	lr

0001e6d4 <attcProcReadRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcReadRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1e6d4:	b480      	push	{r7}
   1e6d6:	b085      	sub	sp, #20
   1e6d8:	af00      	add	r7, sp, #0
   1e6da:	60f8      	str	r0, [r7, #12]
   1e6dc:	607a      	str	r2, [r7, #4]
   1e6de:	603b      	str	r3, [r7, #0]
   1e6e0:	460b      	mov	r3, r1
   1e6e2:	817b      	strh	r3, [r7, #10]
  /* nothing to process */
}
   1e6e4:	bf00      	nop
   1e6e6:	3714      	adds	r7, #20
   1e6e8:	46bd      	mov	sp, r7
   1e6ea:	f85d 7b04 	ldr.w	r7, [sp], #4
   1e6ee:	4770      	bx	lr

0001e6f0 <attcProcWriteRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcWriteRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1e6f0:	b480      	push	{r7}
   1e6f2:	b085      	sub	sp, #20
   1e6f4:	af00      	add	r7, sp, #0
   1e6f6:	60f8      	str	r0, [r7, #12]
   1e6f8:	607a      	str	r2, [r7, #4]
   1e6fa:	603b      	str	r3, [r7, #0]
   1e6fc:	460b      	mov	r3, r1
   1e6fe:	817b      	strh	r3, [r7, #10]
  /* no parameters so clear length */
  pEvt->valueLen = 0;
   1e700:	683b      	ldr	r3, [r7, #0]
   1e702:	2200      	movs	r2, #0
   1e704:	811a      	strh	r2, [r3, #8]
}
   1e706:	bf00      	nop
   1e708:	3714      	adds	r7, #20
   1e70a:	46bd      	mov	sp, r7
   1e70c:	f85d 7b04 	ldr.w	r7, [sp], #4
   1e710:	4770      	bx	lr
	...

0001e714 <attcProcRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   1e714:	b590      	push	{r4, r7, lr}
   1e716:	b08b      	sub	sp, #44	; 0x2c
   1e718:	af00      	add	r7, sp, #0
   1e71a:	60f8      	str	r0, [r7, #12]
   1e71c:	460b      	mov	r3, r1
   1e71e:	607a      	str	r2, [r7, #4]
   1e720:	817b      	strh	r3, [r7, #10]
  attEvt_t      evt;
  attcProcRsp_t procFcn;

  /* if no request in progress ignore response */
  if (pCcb->outReq.hdr.event == ATTC_MSG_API_NONE)
   1e722:	68fb      	ldr	r3, [r7, #12]
   1e724:	7c9b      	ldrb	r3, [r3, #18]
   1e726:	2b00      	cmp	r3, #0
   1e728:	d079      	beq.n	1e81e <attcProcRsp+0x10a>
  {
    return;
  }

  /* get method */
  evt.hdr.event = ATT_OPCODE_2_METHOD(*(pPacket + L2C_PAYLOAD_START));
   1e72a:	687b      	ldr	r3, [r7, #4]
   1e72c:	3308      	adds	r3, #8
   1e72e:	781b      	ldrb	r3, [r3, #0]
   1e730:	105b      	asrs	r3, r3, #1
   1e732:	b2db      	uxtb	r3, r3
   1e734:	75bb      	strb	r3, [r7, #22]

  /* check the validity of event */
  if (evt.hdr.event > ATT_METHOD_SIGNED_WRITE_CMD)
   1e736:	7dbb      	ldrb	r3, [r7, #22]
   1e738:	2b10      	cmp	r3, #16
   1e73a:	d872      	bhi.n	1e822 <attcProcRsp+0x10e>
  {
    return;
  }

  /* if response method is not error and does not match stored method ignore response */
  if ((evt.hdr.event != ATT_METHOD_ERR) && (evt.hdr.event != pCcb->outReq.hdr.event))
   1e73c:	7dbb      	ldrb	r3, [r7, #22]
   1e73e:	2b00      	cmp	r3, #0
   1e740:	d004      	beq.n	1e74c <attcProcRsp+0x38>
   1e742:	7dba      	ldrb	r2, [r7, #22]
   1e744:	68fb      	ldr	r3, [r7, #12]
   1e746:	7c9b      	ldrb	r3, [r3, #18]
   1e748:	429a      	cmp	r2, r3
   1e74a:	d16c      	bne.n	1e826 <attcProcRsp+0x112>
  {
    return;
  }

  /* stop request timer */
  WsfTimerStop(&pCcb->outReqTimer);
   1e74c:	68fb      	ldr	r3, [r7, #12]
   1e74e:	3324      	adds	r3, #36	; 0x24
   1e750:	4618      	mov	r0, r3
   1e752:	f00f f871 	bl	2d838 <WsfTimerStop>

  /* initialize event structure then process response */
  evt.pValue = pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN;
   1e756:	687b      	ldr	r3, [r7, #4]
   1e758:	3309      	adds	r3, #9
   1e75a:	61bb      	str	r3, [r7, #24]
  evt.valueLen = len - ATT_HDR_LEN;
   1e75c:	897b      	ldrh	r3, [r7, #10]
   1e75e:	3b01      	subs	r3, #1
   1e760:	b29b      	uxth	r3, r3
   1e762:	83bb      	strh	r3, [r7, #28]
  evt.handle = pCcb->outReq.handle;
   1e764:	68fb      	ldr	r3, [r7, #12]
   1e766:	8b1b      	ldrh	r3, [r3, #24]
   1e768:	83fb      	strh	r3, [r7, #30]
  evt.hdr.status = ATT_SUCCESS;
   1e76a:	2300      	movs	r3, #0
   1e76c:	75fb      	strb	r3, [r7, #23]

  /* look up processing function */
  procFcn = attcProcRspTbl[evt.hdr.event];
   1e76e:	7dbb      	ldrb	r3, [r7, #22]
   1e770:	461a      	mov	r2, r3
   1e772:	4b30      	ldr	r3, [pc, #192]	; (1e834 <attcProcRsp+0x120>)
   1e774:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   1e778:	627b      	str	r3, [r7, #36]	; 0x24

  /* if method is supported */
  if (procFcn != NULL)
   1e77a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e77c:	2b00      	cmp	r3, #0
   1e77e:	d010      	beq.n	1e7a2 <attcProcRsp+0x8e>
  {
    /* check the validity of data length */
    ATT_CHECK_DATA_LENGTH(len, attcMinPduLen[evt.hdr.event]);
   1e780:	7dbb      	ldrb	r3, [r7, #22]
   1e782:	461a      	mov	r2, r3
   1e784:	4b2c      	ldr	r3, [pc, #176]	; (1e838 <attcProcRsp+0x124>)
   1e786:	5c9b      	ldrb	r3, [r3, r2]
   1e788:	b29b      	uxth	r3, r3
   1e78a:	897a      	ldrh	r2, [r7, #10]
   1e78c:	429a      	cmp	r2, r3
   1e78e:	d34c      	bcc.n	1e82a <attcProcRsp+0x116>

    /* execute processing function */
    (*procFcn)(pCcb, len, pPacket, &evt);
   1e790:	f107 0314 	add.w	r3, r7, #20
   1e794:	8979      	ldrh	r1, [r7, #10]
   1e796:	6a7c      	ldr	r4, [r7, #36]	; 0x24
   1e798:	687a      	ldr	r2, [r7, #4]
   1e79a:	68f8      	ldr	r0, [r7, #12]
   1e79c:	47a0      	blx	r4

    procFcn = NULL;
   1e79e:	2300      	movs	r3, #0
   1e7a0:	627b      	str	r3, [r7, #36]	; 0x24
  }

  /* if not continuing or status is not success */
  if ((pCcb->outReq.hdr.status == ATTC_NOT_CONTINUING) || (evt.hdr.status != ATT_SUCCESS))
   1e7a2:	68fb      	ldr	r3, [r7, #12]
   1e7a4:	7cdb      	ldrb	r3, [r3, #19]
   1e7a6:	2b00      	cmp	r3, #0
   1e7a8:	d002      	beq.n	1e7b0 <attcProcRsp+0x9c>
   1e7aa:	7dfb      	ldrb	r3, [r7, #23]
   1e7ac:	2b00      	cmp	r3, #0
   1e7ae:	d007      	beq.n	1e7c0 <attcProcRsp+0xac>
  {
    /* we're not sending another request so clear the out req */
    pCcb->outReq.hdr.event = ATTC_MSG_API_NONE;
   1e7b0:	68fb      	ldr	r3, [r7, #12]
   1e7b2:	2200      	movs	r2, #0
   1e7b4:	749a      	strb	r2, [r3, #18]
    attcFreePkt(&pCcb->outReq);
   1e7b6:	68fb      	ldr	r3, [r7, #12]
   1e7b8:	3310      	adds	r3, #16
   1e7ba:	4618      	mov	r0, r3
   1e7bc:	f7ff fdbe 	bl	1e33c <attcFreePkt>
  }

  /* call callback (if not mtu rsp) */
  if ((evt.hdr.event != ATT_METHOD_MTU) && attCb.cback)
   1e7c0:	7dbb      	ldrb	r3, [r7, #22]
   1e7c2:	2b01      	cmp	r3, #1
   1e7c4:	d010      	beq.n	1e7e8 <attcProcRsp+0xd4>
   1e7c6:	4b1d      	ldr	r3, [pc, #116]	; (1e83c <attcProcRsp+0x128>)
   1e7c8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1e7ca:	2b00      	cmp	r3, #0
   1e7cc:	d00c      	beq.n	1e7e8 <attcProcRsp+0xd4>
  {
    /* set additional parameters and call callback */
    evt.continuing = pCcb->outReq.hdr.status;   /* continuing flag */
   1e7ce:	68fb      	ldr	r3, [r7, #12]
   1e7d0:	7cdb      	ldrb	r3, [r3, #19]
   1e7d2:	f887 3020 	strb.w	r3, [r7, #32]
    evt.hdr.param = pCcb->outReq.hdr.param;     /* connId */
   1e7d6:	68fb      	ldr	r3, [r7, #12]
   1e7d8:	8a1b      	ldrh	r3, [r3, #16]
   1e7da:	82bb      	strh	r3, [r7, #20]
    (*attCb.cback)(&evt);
   1e7dc:	4b17      	ldr	r3, [pc, #92]	; (1e83c <attcProcRsp+0x128>)
   1e7de:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1e7e0:	f107 0214 	add.w	r2, r7, #20
   1e7e4:	4610      	mov	r0, r2
   1e7e6:	4798      	blx	r3
  }

  /* if no flow control */
  if (!pCcb->flowDisabled)
   1e7e8:	68fb      	ldr	r3, [r7, #12]
   1e7ea:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1e7ee:	2b00      	cmp	r3, #0
   1e7f0:	d11c      	bne.n	1e82c <attcProcRsp+0x118>
  {
    /* if out req ready */
    if (pCcb->outReq.pPkt != NULL)
   1e7f2:	68fb      	ldr	r3, [r7, #12]
   1e7f4:	695b      	ldr	r3, [r3, #20]
   1e7f6:	2b00      	cmp	r3, #0
   1e7f8:	d003      	beq.n	1e802 <attcProcRsp+0xee>
    {
      /* build and send request */
      attcSendReq(pCcb);
   1e7fa:	68f8      	ldr	r0, [r7, #12]
   1e7fc:	f7ff fba2 	bl	1df44 <attcSendReq>
   1e800:	e014      	b.n	1e82c <attcProcRsp+0x118>
    }
    /* else if api is on deck */
    else if (pCcb->onDeck.hdr.event != ATTC_MSG_API_NONE)
   1e802:	68fb      	ldr	r3, [r7, #12]
   1e804:	799b      	ldrb	r3, [r3, #6]
   1e806:	2b00      	cmp	r3, #0
   1e808:	d010      	beq.n	1e82c <attcProcRsp+0x118>
    {
      /* set up and send request */
      attcSetupReq(pCcb, &pCcb->onDeck);
   1e80a:	68fb      	ldr	r3, [r7, #12]
   1e80c:	3304      	adds	r3, #4
   1e80e:	4619      	mov	r1, r3
   1e810:	68f8      	ldr	r0, [r7, #12]
   1e812:	f7ff fba9 	bl	1df68 <attcSetupReq>

      /* clear on deck */
      pCcb->onDeck.hdr.event = ATTC_MSG_API_NONE;
   1e816:	68fb      	ldr	r3, [r7, #12]
   1e818:	2200      	movs	r2, #0
   1e81a:	719a      	strb	r2, [r3, #6]
   1e81c:	e006      	b.n	1e82c <attcProcRsp+0x118>
    return;
   1e81e:	bf00      	nop
   1e820:	e004      	b.n	1e82c <attcProcRsp+0x118>
    return;
   1e822:	bf00      	nop
   1e824:	e002      	b.n	1e82c <attcProcRsp+0x118>
    return;
   1e826:	bf00      	nop
   1e828:	e000      	b.n	1e82c <attcProcRsp+0x118>
    ATT_CHECK_DATA_LENGTH(len, attcMinPduLen[evt.hdr.event]);
   1e82a:	bf00      	nop
    }
  }
}
   1e82c:	372c      	adds	r7, #44	; 0x2c
   1e82e:	46bd      	mov	sp, r7
   1e830:	bd90      	pop	{r4, r7, pc}
   1e832:	bf00      	nop
   1e834:	00045b44 	.word	0x00045b44
   1e838:	00045b78 	.word	0x00045b78
   1e83c:	10011048 	.word	0x10011048

0001e840 <attcProcInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcInd(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   1e840:	b580      	push	{r7, lr}
   1e842:	b08a      	sub	sp, #40	; 0x28
   1e844:	af00      	add	r7, sp, #0
   1e846:	60f8      	str	r0, [r7, #12]
   1e848:	460b      	mov	r3, r1
   1e84a:	607a      	str	r2, [r7, #4]
   1e84c:	817b      	strh	r3, [r7, #10]
  attEvt_t    evt;
  uint8_t     *p;
  uint8_t     *pPkt;

  /* check the validity of data length */
  ATT_CHECK_DATA_LENGTH(len, ATT_VALUE_IND_LEN);
   1e84e:	897b      	ldrh	r3, [r7, #10]
   1e850:	2b02      	cmp	r3, #2
   1e852:	d95a      	bls.n	1e90a <attcProcInd+0xca>

  p = pPacket + L2C_PAYLOAD_START;
   1e854:	687b      	ldr	r3, [r7, #4]
   1e856:	3308      	adds	r3, #8
   1e858:	627b      	str	r3, [r7, #36]	; 0x24

  /* parse packet and set callback event struct */
  evt.hdr.event = ATT_OPCODE_2_METHOD(*p++);
   1e85a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e85c:	1c5a      	adds	r2, r3, #1
   1e85e:	627a      	str	r2, [r7, #36]	; 0x24
   1e860:	781b      	ldrb	r3, [r3, #0]
   1e862:	105b      	asrs	r3, r3, #1
   1e864:	b2db      	uxtb	r3, r3
   1e866:	74bb      	strb	r3, [r7, #18]
  BSTREAM_TO_UINT16(evt.handle, p);
   1e868:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e86a:	781b      	ldrb	r3, [r3, #0]
   1e86c:	b29a      	uxth	r2, r3
   1e86e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e870:	3301      	adds	r3, #1
   1e872:	781b      	ldrb	r3, [r3, #0]
   1e874:	b29b      	uxth	r3, r3
   1e876:	021b      	lsls	r3, r3, #8
   1e878:	b29b      	uxth	r3, r3
   1e87a:	4413      	add	r3, r2
   1e87c:	b29b      	uxth	r3, r3
   1e87e:	837b      	strh	r3, [r7, #26]
   1e880:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e882:	3302      	adds	r3, #2
   1e884:	627b      	str	r3, [r7, #36]	; 0x24
  evt.pValue = p;
   1e886:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   1e888:	617b      	str	r3, [r7, #20]
  evt.valueLen = len - ATT_HDR_LEN - sizeof(uint16_t);
   1e88a:	897b      	ldrh	r3, [r7, #10]
   1e88c:	3b03      	subs	r3, #3
   1e88e:	b29b      	uxth	r3, r3
   1e890:	833b      	strh	r3, [r7, #24]
  evt.hdr.param = pCcb->pMainCcb->connId;
   1e892:	68fb      	ldr	r3, [r7, #12]
   1e894:	681b      	ldr	r3, [r3, #0]
   1e896:	7f1b      	ldrb	r3, [r3, #28]
   1e898:	b29b      	uxth	r3, r3
   1e89a:	823b      	strh	r3, [r7, #16]
  evt.hdr.status = ATT_SUCCESS;
   1e89c:	2300      	movs	r3, #0
   1e89e:	74fb      	strb	r3, [r7, #19]
  evt.continuing = FALSE;
   1e8a0:	2300      	movs	r3, #0
   1e8a2:	773b      	strb	r3, [r7, #28]

  /* verify handle and call callback */
  if ((evt.handle != 0) && attCb.cback)
   1e8a4:	8b7b      	ldrh	r3, [r7, #26]
   1e8a6:	2b00      	cmp	r3, #0
   1e8a8:	d009      	beq.n	1e8be <attcProcInd+0x7e>
   1e8aa:	4b1b      	ldr	r3, [pc, #108]	; (1e918 <attcProcInd+0xd8>)
   1e8ac:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1e8ae:	2b00      	cmp	r3, #0
   1e8b0:	d005      	beq.n	1e8be <attcProcInd+0x7e>
  {
    (*attCb.cback)(&evt);
   1e8b2:	4b19      	ldr	r3, [pc, #100]	; (1e918 <attcProcInd+0xd8>)
   1e8b4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1e8b6:	f107 0210 	add.w	r2, r7, #16
   1e8ba:	4610      	mov	r0, r2
   1e8bc:	4798      	blx	r3
  }

  /* if indication send confirm */
  if (attcCb.autoCnf && (evt.hdr.event == ATT_METHOD_VALUE_IND))
   1e8be:	4b17      	ldr	r3, [pc, #92]	; (1e91c <attcProcInd+0xdc>)
   1e8c0:	f893 30ac 	ldrb.w	r3, [r3, #172]	; 0xac
   1e8c4:	2b00      	cmp	r3, #0
   1e8c6:	d01b      	beq.n	1e900 <attcProcInd+0xc0>
   1e8c8:	7cbb      	ldrb	r3, [r7, #18]
   1e8ca:	2b0e      	cmp	r3, #14
   1e8cc:	d118      	bne.n	1e900 <attcProcInd+0xc0>
  {
    if (!pCcb->flowDisabled)
   1e8ce:	68fb      	ldr	r3, [r7, #12]
   1e8d0:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1e8d4:	2b00      	cmp	r3, #0
   1e8d6:	d11a      	bne.n	1e90e <attcProcInd+0xce>
    {
      if ((pPkt = attMsgAlloc(ATT_VALUE_CNF_LEN + L2C_PAYLOAD_START)) != NULL)
   1e8d8:	2009      	movs	r0, #9
   1e8da:	f7ff f885 	bl	1d9e8 <attMsgAlloc>
   1e8de:	6238      	str	r0, [r7, #32]
   1e8e0:	6a3b      	ldr	r3, [r7, #32]
   1e8e2:	2b00      	cmp	r3, #0
   1e8e4:	d013      	beq.n	1e90e <attcProcInd+0xce>
      {
        *(pPkt + L2C_PAYLOAD_START) = ATT_PDU_VALUE_CNF;
   1e8e6:	6a3b      	ldr	r3, [r7, #32]
   1e8e8:	3308      	adds	r3, #8
   1e8ea:	221e      	movs	r2, #30
   1e8ec:	701a      	strb	r2, [r3, #0]
        L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, ATT_VALUE_CNF_LEN, pPkt);
   1e8ee:	68fb      	ldr	r3, [r7, #12]
   1e8f0:	681b      	ldr	r3, [r3, #0]
   1e8f2:	8b19      	ldrh	r1, [r3, #24]
   1e8f4:	6a3b      	ldr	r3, [r7, #32]
   1e8f6:	2201      	movs	r2, #1
   1e8f8:	2004      	movs	r0, #4
   1e8fa:	f00b faf5 	bl	29ee8 <L2cDataReq>
      }
    }

    return;
   1e8fe:	e006      	b.n	1e90e <attcProcInd+0xce>
  }

  /* mark confirm as pending; will be sent when flow enabled or application sends it. */
  pCcb->cnfPending = TRUE;
   1e900:	68fb      	ldr	r3, [r7, #12]
   1e902:	2201      	movs	r2, #1
   1e904:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
   1e908:	e002      	b.n	1e910 <attcProcInd+0xd0>
  ATT_CHECK_DATA_LENGTH(len, ATT_VALUE_IND_LEN);
   1e90a:	bf00      	nop
   1e90c:	e000      	b.n	1e910 <attcProcInd+0xd0>
    return;
   1e90e:	bf00      	nop
}
   1e910:	3728      	adds	r7, #40	; 0x28
   1e912:	46bd      	mov	sp, r7
   1e914:	bd80      	pop	{r7, pc}
   1e916:	bf00      	nop
   1e918:	10011048 	.word	0x10011048
   1e91c:	100110c8 	.word	0x100110c8

0001e920 <attcSendMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcSendMsg(dmConnId_t connId, uint16_t handle, uint8_t msgId, attcPktParam_t *pPkt, bool_t continuing)
{
   1e920:	b580      	push	{r7, lr}
   1e922:	b086      	sub	sp, #24
   1e924:	af00      	add	r7, sp, #0
   1e926:	603b      	str	r3, [r7, #0]
   1e928:	4603      	mov	r3, r0
   1e92a:	71fb      	strb	r3, [r7, #7]
   1e92c:	460b      	mov	r3, r1
   1e92e:	80bb      	strh	r3, [r7, #4]
   1e930:	4613      	mov	r3, r2
   1e932:	71bb      	strb	r3, [r7, #6]
  attcCcb_t   *pCcb;
  uint16_t    mtu;
  bool_t      transTimedOut;

  WsfTaskLock();
   1e934:	f00e fc66 	bl	2d204 <WsfTaskLock>

  /* get CCB and verify connection still in use */
  if ((pCcb = attcCcbByConnId(connId)) != NULL)
   1e938:	79fb      	ldrb	r3, [r7, #7]
   1e93a:	4618      	mov	r0, r3
   1e93c:	f7ff fcbc 	bl	1e2b8 <attcCcbByConnId>
   1e940:	60f8      	str	r0, [r7, #12]
   1e942:	68fb      	ldr	r3, [r7, #12]
   1e944:	2b00      	cmp	r3, #0
   1e946:	d00f      	beq.n	1e968 <attcSendMsg+0x48>
  {
    /* get MTU size */
    mtu = pCcb->pMainCcb->mtu;
   1e948:	68fb      	ldr	r3, [r7, #12]
   1e94a:	681b      	ldr	r3, [r3, #0]
   1e94c:	8b5b      	ldrh	r3, [r3, #26]
   1e94e:	82fb      	strh	r3, [r7, #22]
    transTimedOut = !!(pCcb->pMainCcb->control & ATT_CCB_STATUS_TX_TIMEOUT);
   1e950:	68fb      	ldr	r3, [r7, #12]
   1e952:	681b      	ldr	r3, [r3, #0]
   1e954:	7f5b      	ldrb	r3, [r3, #29]
   1e956:	f003 0304 	and.w	r3, r3, #4
   1e95a:	2b00      	cmp	r3, #0
   1e95c:	bf14      	ite	ne
   1e95e:	2301      	movne	r3, #1
   1e960:	2300      	moveq	r3, #0
   1e962:	b2db      	uxtb	r3, r3
   1e964:	757b      	strb	r3, [r7, #21]
   1e966:	e003      	b.n	1e970 <attcSendMsg+0x50>
  }
  /* else connection not in use */
  else
  {
    /* MTU size unknown */
    mtu = 0;
   1e968:	2300      	movs	r3, #0
   1e96a:	82fb      	strh	r3, [r7, #22]
    transTimedOut = FALSE;
   1e96c:	2300      	movs	r3, #0
   1e96e:	757b      	strb	r3, [r7, #21]
  }

  WsfTaskUnlock();
   1e970:	f00e fc4e 	bl	2d210 <WsfTaskUnlock>

  /* if MTU size known for connection */
  if (mtu > 0)
   1e974:	8afb      	ldrh	r3, [r7, #22]
   1e976:	2b00      	cmp	r3, #0
   1e978:	d047      	beq.n	1ea0a <attcSendMsg+0xea>
  {
    /* if no transaction's timed out */
    if (!transTimedOut)
   1e97a:	7d7b      	ldrb	r3, [r7, #21]
   1e97c:	2b00      	cmp	r3, #0
   1e97e:	d13e      	bne.n	1e9fe <attcSendMsg+0xde>
    {
      uint16_t dataLen = 0;
   1e980:	2300      	movs	r3, #0
   1e982:	827b      	strh	r3, [r7, #18]

      /* if packet is not null then find out its length */
      if (pPkt != NULL)
   1e984:	683b      	ldr	r3, [r7, #0]
   1e986:	2b00      	cmp	r3, #0
   1e988:	d00e      	beq.n	1e9a8 <attcSendMsg+0x88>
      {
        /* if not prepare write request */
        if (msgId != ATTC_MSG_API_PREP_WRITE)
   1e98a:	79bb      	ldrb	r3, [r7, #6]
   1e98c:	2b0b      	cmp	r3, #11
   1e98e:	d003      	beq.n	1e998 <attcSendMsg+0x78>
        {
          dataLen = pPkt->len;
   1e990:	683b      	ldr	r3, [r7, #0]
   1e992:	881b      	ldrh	r3, [r3, #0]
   1e994:	827b      	strh	r3, [r7, #18]
   1e996:	e007      	b.n	1e9a8 <attcSendMsg+0x88>
        }
        /* else prepare write request */
        else
        {
          /* if not continuing */
          if (!continuing)
   1e998:	f897 3020 	ldrb.w	r3, [r7, #32]
   1e99c:	2b00      	cmp	r3, #0
   1e99e:	d103      	bne.n	1e9a8 <attcSendMsg+0x88>
          {
            /* single prepare write request */
            dataLen = ATT_PREP_WRITE_REQ_LEN + pPkt->w.len;
   1e9a0:	683b      	ldr	r3, [r7, #0]
   1e9a2:	881b      	ldrh	r3, [r3, #0]
   1e9a4:	3305      	adds	r3, #5
   1e9a6:	827b      	strh	r3, [r7, #18]
          /* else will be sent as multiple prepare write requests */
        }
      }

      /* if packet length is less than or equal to negotiated MTU */
      if (dataLen <= mtu)
   1e9a8:	8a7a      	ldrh	r2, [r7, #18]
   1e9aa:	8afb      	ldrh	r3, [r7, #22]
   1e9ac:	429a      	cmp	r2, r3
   1e9ae:	d81f      	bhi.n	1e9f0 <attcSendMsg+0xd0>
      {
        attcApiMsg_t *pMsg;

        /* allocate message buffer */
        if ((pMsg = WsfMsgAlloc(sizeof(attcApiMsg_t))) != NULL)
   1e9b0:	200c      	movs	r0, #12
   1e9b2:	f00e fb7c 	bl	2d0ae <WsfMsgAlloc>
   1e9b6:	60b8      	str	r0, [r7, #8]
   1e9b8:	68bb      	ldr	r3, [r7, #8]
   1e9ba:	2b00      	cmp	r3, #0
   1e9bc:	d025      	beq.n	1ea0a <attcSendMsg+0xea>
        {
          /* set parameters */
          pMsg->hdr.param = connId;
   1e9be:	79fb      	ldrb	r3, [r7, #7]
   1e9c0:	b29a      	uxth	r2, r3
   1e9c2:	68bb      	ldr	r3, [r7, #8]
   1e9c4:	801a      	strh	r2, [r3, #0]
          pMsg->hdr.status = continuing;
   1e9c6:	68bb      	ldr	r3, [r7, #8]
   1e9c8:	f897 2020 	ldrb.w	r2, [r7, #32]
   1e9cc:	70da      	strb	r2, [r3, #3]
          pMsg->hdr.event = msgId;
   1e9ce:	68bb      	ldr	r3, [r7, #8]
   1e9d0:	79ba      	ldrb	r2, [r7, #6]
   1e9d2:	709a      	strb	r2, [r3, #2]
          pMsg->pPkt = pPkt;
   1e9d4:	68bb      	ldr	r3, [r7, #8]
   1e9d6:	683a      	ldr	r2, [r7, #0]
   1e9d8:	605a      	str	r2, [r3, #4]
          pMsg->handle = handle;
   1e9da:	68bb      	ldr	r3, [r7, #8]
   1e9dc:	88ba      	ldrh	r2, [r7, #4]
   1e9de:	811a      	strh	r2, [r3, #8]

          /* send message */
          WsfMsgSend(attCb.handlerId, pMsg);
   1e9e0:	4b0e      	ldr	r3, [pc, #56]	; (1ea1c <attcSendMsg+0xfc>)
   1e9e2:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
   1e9e6:	68b9      	ldr	r1, [r7, #8]
   1e9e8:	4618      	mov	r0, r3
   1e9ea:	f00e fb84 	bl	2d0f6 <WsfMsgSend>
          return;
   1e9ee:	e012      	b.n	1ea16 <attcSendMsg+0xf6>
      }
      /* else packet length exceeds MTU size */
      else
      {
        /* call callback with failure status */
        attcExecCallback(connId, msgId, handle, ATT_ERR_MTU_EXCEEDED);
   1e9f0:	88ba      	ldrh	r2, [r7, #4]
   1e9f2:	79b9      	ldrb	r1, [r7, #6]
   1e9f4:	79f8      	ldrb	r0, [r7, #7]
   1e9f6:	2377      	movs	r3, #119	; 0x77
   1e9f8:	f7ff fcb4 	bl	1e364 <attcExecCallback>
   1e9fc:	e005      	b.n	1ea0a <attcSendMsg+0xea>
    }
    else
    /* transaction's timed out */
    {
      /* call callback with failure status */
      attcExecCallback(connId, msgId, handle, ATT_ERR_TIMEOUT);
   1e9fe:	88ba      	ldrh	r2, [r7, #4]
   1ea00:	79b9      	ldrb	r1, [r7, #6]
   1ea02:	79f8      	ldrb	r0, [r7, #7]
   1ea04:	2371      	movs	r3, #113	; 0x71
   1ea06:	f7ff fcad 	bl	1e364 <attcExecCallback>
    }
  }

  /* alloc failed, transaction's timed out or packet length exceeded MTU size; free packet buffer */
  if (pPkt != NULL)
   1ea0a:	683b      	ldr	r3, [r7, #0]
   1ea0c:	2b00      	cmp	r3, #0
   1ea0e:	d002      	beq.n	1ea16 <attcSendMsg+0xf6>
  {
    WsfMsgFree(pPkt);
   1ea10:	6838      	ldr	r0, [r7, #0]
   1ea12:	f00e fb63 	bl	2d0dc <WsfMsgFree>
  }
}
   1ea16:	3718      	adds	r7, #24
   1ea18:	46bd      	mov	sp, r7
   1ea1a:	bd80      	pop	{r7, pc}
   1ea1c:	10011048 	.word	0x10011048

0001ea20 <AttcWriteReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttcWriteReq(dmConnId_t connId, uint16_t handle, uint16_t valueLen, uint8_t *pValue)
{
   1ea20:	b580      	push	{r7, lr}
   1ea22:	b088      	sub	sp, #32
   1ea24:	af02      	add	r7, sp, #8
   1ea26:	607b      	str	r3, [r7, #4]
   1ea28:	4603      	mov	r3, r0
   1ea2a:	73fb      	strb	r3, [r7, #15]
   1ea2c:	460b      	mov	r3, r1
   1ea2e:	81bb      	strh	r3, [r7, #12]
   1ea30:	4613      	mov	r3, r2
   1ea32:	817b      	strh	r3, [r7, #10]
  attcPktParam_t  *pPkt;
  uint8_t         *p;

  /* allocate packet and parameter buffer */
  if ((pPkt = attMsgAlloc(ATT_WRITE_REQ_BUF_LEN + valueLen)) != NULL)
   1ea34:	897b      	ldrh	r3, [r7, #10]
   1ea36:	330b      	adds	r3, #11
   1ea38:	b29b      	uxth	r3, r3
   1ea3a:	4618      	mov	r0, r3
   1ea3c:	f7fe ffd4 	bl	1d9e8 <attMsgAlloc>
   1ea40:	6178      	str	r0, [r7, #20]
   1ea42:	697b      	ldr	r3, [r7, #20]
   1ea44:	2b00      	cmp	r3, #0
   1ea46:	d028      	beq.n	1ea9a <AttcWriteReq+0x7a>
  {
    /* set length */
    pPkt->len = ATT_WRITE_REQ_LEN + valueLen;
   1ea48:	897b      	ldrh	r3, [r7, #10]
   1ea4a:	3303      	adds	r3, #3
   1ea4c:	b29a      	uxth	r2, r3
   1ea4e:	697b      	ldr	r3, [r7, #20]
   1ea50:	801a      	strh	r2, [r3, #0]

    /* build packet */
    p = (uint8_t *) pPkt + L2C_PAYLOAD_START;
   1ea52:	697b      	ldr	r3, [r7, #20]
   1ea54:	3308      	adds	r3, #8
   1ea56:	613b      	str	r3, [r7, #16]
    UINT8_TO_BSTREAM(p, ATT_PDU_WRITE_REQ);
   1ea58:	693b      	ldr	r3, [r7, #16]
   1ea5a:	1c5a      	adds	r2, r3, #1
   1ea5c:	613a      	str	r2, [r7, #16]
   1ea5e:	2212      	movs	r2, #18
   1ea60:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, handle);
   1ea62:	693b      	ldr	r3, [r7, #16]
   1ea64:	1c5a      	adds	r2, r3, #1
   1ea66:	613a      	str	r2, [r7, #16]
   1ea68:	89ba      	ldrh	r2, [r7, #12]
   1ea6a:	b2d2      	uxtb	r2, r2
   1ea6c:	701a      	strb	r2, [r3, #0]
   1ea6e:	89bb      	ldrh	r3, [r7, #12]
   1ea70:	0a1b      	lsrs	r3, r3, #8
   1ea72:	b299      	uxth	r1, r3
   1ea74:	693b      	ldr	r3, [r7, #16]
   1ea76:	1c5a      	adds	r2, r3, #1
   1ea78:	613a      	str	r2, [r7, #16]
   1ea7a:	b2ca      	uxtb	r2, r1
   1ea7c:	701a      	strb	r2, [r3, #0]
    memcpy(p, pValue, valueLen);
   1ea7e:	897b      	ldrh	r3, [r7, #10]
   1ea80:	461a      	mov	r2, r3
   1ea82:	6879      	ldr	r1, [r7, #4]
   1ea84:	6938      	ldr	r0, [r7, #16]
   1ea86:	f7f9 fbe5 	bl	18254 <memcpy>

    /* send message */
    attcSendMsg(connId, handle, ATTC_MSG_API_WRITE, pPkt, FALSE);
   1ea8a:	89b9      	ldrh	r1, [r7, #12]
   1ea8c:	7bf8      	ldrb	r0, [r7, #15]
   1ea8e:	2300      	movs	r3, #0
   1ea90:	9300      	str	r3, [sp, #0]
   1ea92:	697b      	ldr	r3, [r7, #20]
   1ea94:	2209      	movs	r2, #9
   1ea96:	f7ff ff43 	bl	1e920 <attcSendMsg>
  }
}
   1ea9a:	bf00      	nop
   1ea9c:	3718      	adds	r7, #24
   1ea9e:	46bd      	mov	sp, r7
   1eaa0:	bd80      	pop	{r7, pc}

0001eaa2 <AttcMtuReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttcMtuReq(dmConnId_t connId, uint16_t mtu)
{
   1eaa2:	b580      	push	{r7, lr}
   1eaa4:	b086      	sub	sp, #24
   1eaa6:	af02      	add	r7, sp, #8
   1eaa8:	4603      	mov	r3, r0
   1eaaa:	460a      	mov	r2, r1
   1eaac:	71fb      	strb	r3, [r7, #7]
   1eaae:	4613      	mov	r3, r2
   1eab0:	80bb      	strh	r3, [r7, #4]
  attcPktParam_t  *pPkt;
  uint8_t         *p;

  /* allocate packet and parameter buffer */
  if ((pPkt = attMsgAlloc(ATT_MTU_REQ_BUF_LEN)) != NULL)
   1eab2:	200b      	movs	r0, #11
   1eab4:	f7fe ff98 	bl	1d9e8 <attMsgAlloc>
   1eab8:	60f8      	str	r0, [r7, #12]
   1eaba:	68fb      	ldr	r3, [r7, #12]
   1eabc:	2b00      	cmp	r3, #0
   1eabe:	d020      	beq.n	1eb02 <AttcMtuReq+0x60>
  {
    /* set length */
    pPkt->len = ATT_MTU_REQ_LEN;
   1eac0:	68fb      	ldr	r3, [r7, #12]
   1eac2:	2203      	movs	r2, #3
   1eac4:	801a      	strh	r2, [r3, #0]

    /* build packet */
    p = (uint8_t *) pPkt + L2C_PAYLOAD_START;
   1eac6:	68fb      	ldr	r3, [r7, #12]
   1eac8:	3308      	adds	r3, #8
   1eaca:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, ATT_PDU_MTU_REQ);
   1eacc:	68bb      	ldr	r3, [r7, #8]
   1eace:	1c5a      	adds	r2, r3, #1
   1ead0:	60ba      	str	r2, [r7, #8]
   1ead2:	2202      	movs	r2, #2
   1ead4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, mtu);
   1ead6:	68bb      	ldr	r3, [r7, #8]
   1ead8:	1c5a      	adds	r2, r3, #1
   1eada:	60ba      	str	r2, [r7, #8]
   1eadc:	88ba      	ldrh	r2, [r7, #4]
   1eade:	b2d2      	uxtb	r2, r2
   1eae0:	701a      	strb	r2, [r3, #0]
   1eae2:	88bb      	ldrh	r3, [r7, #4]
   1eae4:	0a1b      	lsrs	r3, r3, #8
   1eae6:	b299      	uxth	r1, r3
   1eae8:	68bb      	ldr	r3, [r7, #8]
   1eaea:	1c5a      	adds	r2, r3, #1
   1eaec:	60ba      	str	r2, [r7, #8]
   1eaee:	b2ca      	uxtb	r2, r1
   1eaf0:	701a      	strb	r2, [r3, #0]

    /* send message */
    attcSendMsg(connId, 0, ATTC_MSG_API_MTU, pPkt, FALSE);
   1eaf2:	79f8      	ldrb	r0, [r7, #7]
   1eaf4:	2300      	movs	r3, #0
   1eaf6:	9300      	str	r3, [sp, #0]
   1eaf8:	68fb      	ldr	r3, [r7, #12]
   1eafa:	2201      	movs	r2, #1
   1eafc:	2100      	movs	r1, #0
   1eafe:	f7ff ff0f 	bl	1e920 <attcSendMsg>
  }
}
   1eb02:	bf00      	nop
   1eb04:	3710      	adds	r7, #16
   1eb06:	46bd      	mov	sp, r7
   1eb08:	bd80      	pop	{r7, pc}

0001eb0a <AttcIndConfirm>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttcIndConfirm(dmConnId_t connId)
{
   1eb0a:	b580      	push	{r7, lr}
   1eb0c:	b084      	sub	sp, #16
   1eb0e:	af00      	add	r7, sp, #0
   1eb10:	4603      	mov	r3, r0
   1eb12:	71fb      	strb	r3, [r7, #7]
  attcCcb_t   *pCcb;
  uint8_t     *pPkt;

  pCcb = attcCcbByHandle(connId - 1);
   1eb14:	79fb      	ldrb	r3, [r7, #7]
   1eb16:	b29b      	uxth	r3, r3
   1eb18:	3b01      	subs	r3, #1
   1eb1a:	b29b      	uxth	r3, r3
   1eb1c:	4618      	mov	r0, r3
   1eb1e:	f7ff fbef 	bl	1e300 <attcCcbByHandle>
   1eb22:	60f8      	str	r0, [r7, #12]

  /* If confirmation is pending */
  if (pCcb && pCcb->cnfPending && !pCcb->flowDisabled)
   1eb24:	68fb      	ldr	r3, [r7, #12]
   1eb26:	2b00      	cmp	r3, #0
   1eb28:	d020      	beq.n	1eb6c <AttcIndConfirm+0x62>
   1eb2a:	68fb      	ldr	r3, [r7, #12]
   1eb2c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
   1eb30:	2b00      	cmp	r3, #0
   1eb32:	d01b      	beq.n	1eb6c <AttcIndConfirm+0x62>
   1eb34:	68fb      	ldr	r3, [r7, #12]
   1eb36:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   1eb3a:	2b00      	cmp	r3, #0
   1eb3c:	d116      	bne.n	1eb6c <AttcIndConfirm+0x62>
  {
    if ((pPkt = attMsgAlloc(ATT_VALUE_CNF_LEN + L2C_PAYLOAD_START)) != NULL)
   1eb3e:	2009      	movs	r0, #9
   1eb40:	f7fe ff52 	bl	1d9e8 <attMsgAlloc>
   1eb44:	60b8      	str	r0, [r7, #8]
   1eb46:	68bb      	ldr	r3, [r7, #8]
   1eb48:	2b00      	cmp	r3, #0
   1eb4a:	d00f      	beq.n	1eb6c <AttcIndConfirm+0x62>
    {
      pCcb->cnfPending = FALSE;
   1eb4c:	68fb      	ldr	r3, [r7, #12]
   1eb4e:	2200      	movs	r2, #0
   1eb50:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      *(pPkt + L2C_PAYLOAD_START) = ATT_PDU_VALUE_CNF;
   1eb54:	68bb      	ldr	r3, [r7, #8]
   1eb56:	3308      	adds	r3, #8
   1eb58:	221e      	movs	r2, #30
   1eb5a:	701a      	strb	r2, [r3, #0]
      L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, ATT_VALUE_CNF_LEN, pPkt);
   1eb5c:	68fb      	ldr	r3, [r7, #12]
   1eb5e:	681b      	ldr	r3, [r3, #0]
   1eb60:	8b19      	ldrh	r1, [r3, #24]
   1eb62:	68bb      	ldr	r3, [r7, #8]
   1eb64:	2201      	movs	r2, #1
   1eb66:	2004      	movs	r0, #4
   1eb68:	f00b f9be 	bl	29ee8 <L2cDataReq>
    }
  }
}
   1eb6c:	bf00      	nop
   1eb6e:	3710      	adds	r7, #16
   1eb70:	46bd      	mov	sp, r7
   1eb72:	bd80      	pop	{r7, pc}

0001eb74 <attcProcFindByTypeRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcFindByTypeRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1eb74:	b480      	push	{r7}
   1eb76:	b089      	sub	sp, #36	; 0x24
   1eb78:	af00      	add	r7, sp, #0
   1eb7a:	60f8      	str	r0, [r7, #12]
   1eb7c:	607a      	str	r2, [r7, #4]
   1eb7e:	603b      	str	r3, [r7, #0]
   1eb80:	460b      	mov	r3, r1
   1eb82:	817b      	strh	r3, [r7, #10]
  uint8_t   *pEnd;
  uint16_t  startHandle;
  uint16_t  endHandle;
  uint16_t  nextHandle;

  p = pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN;
   1eb84:	687b      	ldr	r3, [r7, #4]
   1eb86:	3309      	adds	r3, #9
   1eb88:	61fb      	str	r3, [r7, #28]
  pEnd = pPacket + L2C_PAYLOAD_START + len;
   1eb8a:	897b      	ldrh	r3, [r7, #10]
   1eb8c:	3308      	adds	r3, #8
   1eb8e:	687a      	ldr	r2, [r7, #4]
   1eb90:	4413      	add	r3, r2
   1eb92:	617b      	str	r3, [r7, #20]

  /* get and verify all handles */
  nextHandle = pCcb->outReqParams.h.startHandle;
   1eb94:	68fb      	ldr	r3, [r7, #12]
   1eb96:	8bdb      	ldrh	r3, [r3, #30]
   1eb98:	837b      	strh	r3, [r7, #26]
  while (p < pEnd)
   1eb9a:	e042      	b.n	1ec22 <attcProcFindByTypeRsp+0xae>
  {
    /* get handle pair */
    BSTREAM_TO_UINT16(startHandle, p);
   1eb9c:	69fb      	ldr	r3, [r7, #28]
   1eb9e:	781b      	ldrb	r3, [r3, #0]
   1eba0:	b29a      	uxth	r2, r3
   1eba2:	69fb      	ldr	r3, [r7, #28]
   1eba4:	3301      	adds	r3, #1
   1eba6:	781b      	ldrb	r3, [r3, #0]
   1eba8:	b29b      	uxth	r3, r3
   1ebaa:	021b      	lsls	r3, r3, #8
   1ebac:	b29b      	uxth	r3, r3
   1ebae:	4413      	add	r3, r2
   1ebb0:	827b      	strh	r3, [r7, #18]
   1ebb2:	69fb      	ldr	r3, [r7, #28]
   1ebb4:	3302      	adds	r3, #2
   1ebb6:	61fb      	str	r3, [r7, #28]
    BSTREAM_TO_UINT16(endHandle, p);
   1ebb8:	69fb      	ldr	r3, [r7, #28]
   1ebba:	781b      	ldrb	r3, [r3, #0]
   1ebbc:	b29a      	uxth	r2, r3
   1ebbe:	69fb      	ldr	r3, [r7, #28]
   1ebc0:	3301      	adds	r3, #1
   1ebc2:	781b      	ldrb	r3, [r3, #0]
   1ebc4:	b29b      	uxth	r3, r3
   1ebc6:	021b      	lsls	r3, r3, #8
   1ebc8:	b29b      	uxth	r3, r3
   1ebca:	4413      	add	r3, r2
   1ebcc:	823b      	strh	r3, [r7, #16]
   1ebce:	69fb      	ldr	r3, [r7, #28]
   1ebd0:	3302      	adds	r3, #2
   1ebd2:	61fb      	str	r3, [r7, #28]
     *  not greater than end handle of handle pair
     *  not less than than start handle of request or end handle of previous handle pair
     *  not greater than end handle of request
     * and no additional handle pairs following end handle = 0xFFFF
     */
    if ((startHandle > endHandle) || (startHandle < nextHandle) ||
   1ebd4:	8a7a      	ldrh	r2, [r7, #18]
   1ebd6:	8a3b      	ldrh	r3, [r7, #16]
   1ebd8:	429a      	cmp	r2, r3
   1ebda:	d80b      	bhi.n	1ebf4 <attcProcFindByTypeRsp+0x80>
   1ebdc:	8a7a      	ldrh	r2, [r7, #18]
   1ebde:	8b7b      	ldrh	r3, [r7, #26]
   1ebe0:	429a      	cmp	r2, r3
   1ebe2:	d307      	bcc.n	1ebf4 <attcProcFindByTypeRsp+0x80>
        (startHandle > pCcb->outReqParams.h.endHandle) || (nextHandle == 0))
   1ebe4:	68fb      	ldr	r3, [r7, #12]
   1ebe6:	8c1b      	ldrh	r3, [r3, #32]
    if ((startHandle > endHandle) || (startHandle < nextHandle) ||
   1ebe8:	8a7a      	ldrh	r2, [r7, #18]
   1ebea:	429a      	cmp	r2, r3
   1ebec:	d802      	bhi.n	1ebf4 <attcProcFindByTypeRsp+0x80>
        (startHandle > pCcb->outReqParams.h.endHandle) || (nextHandle == 0))
   1ebee:	8b7b      	ldrh	r3, [r7, #26]
   1ebf0:	2b00      	cmp	r3, #0
   1ebf2:	d103      	bne.n	1ebfc <attcProcFindByTypeRsp+0x88>
    {
      pEvt->hdr.status = ATT_ERR_INVALID_RSP;
   1ebf4:	683b      	ldr	r3, [r7, #0]
   1ebf6:	2273      	movs	r2, #115	; 0x73
   1ebf8:	70da      	strb	r2, [r3, #3]
      break;
   1ebfa:	e016      	b.n	1ec2a <attcProcFindByTypeRsp+0xb6>
    }

    /* set next expected handle, with special case for max handle */
    if (endHandle == ATT_HANDLE_MAX)
   1ebfc:	8a3b      	ldrh	r3, [r7, #16]
   1ebfe:	f64f 72ff 	movw	r2, #65535	; 0xffff
   1ec02:	4293      	cmp	r3, r2
   1ec04:	d102      	bne.n	1ec0c <attcProcFindByTypeRsp+0x98>
    {
      nextHandle = 0;
   1ec06:	2300      	movs	r3, #0
   1ec08:	837b      	strh	r3, [r7, #26]
   1ec0a:	e002      	b.n	1ec12 <attcProcFindByTypeRsp+0x9e>
    }
    else
    {
      nextHandle = endHandle + 1;
   1ec0c:	8a3b      	ldrh	r3, [r7, #16]
   1ec0e:	3301      	adds	r3, #1
   1ec10:	837b      	strh	r3, [r7, #26]
    }

    /* check for truncated response */
    if (p > pEnd)
   1ec12:	69fa      	ldr	r2, [r7, #28]
   1ec14:	697b      	ldr	r3, [r7, #20]
   1ec16:	429a      	cmp	r2, r3
   1ec18:	d903      	bls.n	1ec22 <attcProcFindByTypeRsp+0xae>
    {
      pEvt->hdr.status = ATT_ERR_INVALID_RSP;
   1ec1a:	683b      	ldr	r3, [r7, #0]
   1ec1c:	2273      	movs	r2, #115	; 0x73
   1ec1e:	70da      	strb	r2, [r3, #3]
      break;
   1ec20:	e003      	b.n	1ec2a <attcProcFindByTypeRsp+0xb6>
  while (p < pEnd)
   1ec22:	69fa      	ldr	r2, [r7, #28]
   1ec24:	697b      	ldr	r3, [r7, #20]
   1ec26:	429a      	cmp	r2, r3
   1ec28:	d3b8      	bcc.n	1eb9c <attcProcFindByTypeRsp+0x28>
    }
  }

  /* if response was correct */
  if (pEvt->hdr.status == ATT_SUCCESS)
   1ec2a:	683b      	ldr	r3, [r7, #0]
   1ec2c:	78db      	ldrb	r3, [r3, #3]
   1ec2e:	2b00      	cmp	r3, #0
   1ec30:	d115      	bne.n	1ec5e <attcProcFindByTypeRsp+0xea>
  {
    /* if continuing */
    if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1ec32:	68fb      	ldr	r3, [r7, #12]
   1ec34:	7cdb      	ldrb	r3, [r3, #19]
   1ec36:	2b01      	cmp	r3, #1
   1ec38:	d111      	bne.n	1ec5e <attcProcFindByTypeRsp+0xea>
    {
      /* if all handles read */
      if (nextHandle == 0 || nextHandle > pCcb->outReqParams.h.endHandle)
   1ec3a:	8b7b      	ldrh	r3, [r7, #26]
   1ec3c:	2b00      	cmp	r3, #0
   1ec3e:	d004      	beq.n	1ec4a <attcProcFindByTypeRsp+0xd6>
   1ec40:	68fb      	ldr	r3, [r7, #12]
   1ec42:	8c1b      	ldrh	r3, [r3, #32]
   1ec44:	8b7a      	ldrh	r2, [r7, #26]
   1ec46:	429a      	cmp	r2, r3
   1ec48:	d903      	bls.n	1ec52 <attcProcFindByTypeRsp+0xde>
      {
        /* we're done */
        pCcb->outReq.hdr.status = ATTC_NOT_CONTINUING;
   1ec4a:	68fb      	ldr	r3, [r7, #12]
   1ec4c:	2200      	movs	r2, #0
   1ec4e:	74da      	strb	r2, [r3, #19]
        pCcb->outReqParams.h.startHandle = nextHandle;
        pCcb->outReq.handle = nextHandle;
      }
    }
  }
}
   1ec50:	e005      	b.n	1ec5e <attcProcFindByTypeRsp+0xea>
        pCcb->outReqParams.h.startHandle = nextHandle;
   1ec52:	68fb      	ldr	r3, [r7, #12]
   1ec54:	8b7a      	ldrh	r2, [r7, #26]
   1ec56:	83da      	strh	r2, [r3, #30]
        pCcb->outReq.handle = nextHandle;
   1ec58:	68fb      	ldr	r3, [r7, #12]
   1ec5a:	8b7a      	ldrh	r2, [r7, #26]
   1ec5c:	831a      	strh	r2, [r3, #24]
}
   1ec5e:	bf00      	nop
   1ec60:	3724      	adds	r7, #36	; 0x24
   1ec62:	46bd      	mov	sp, r7
   1ec64:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ec68:	4770      	bx	lr

0001ec6a <attcProcReadLongRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcReadLongRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1ec6a:	b480      	push	{r7}
   1ec6c:	b085      	sub	sp, #20
   1ec6e:	af00      	add	r7, sp, #0
   1ec70:	60f8      	str	r0, [r7, #12]
   1ec72:	607a      	str	r2, [r7, #4]
   1ec74:	603b      	str	r3, [r7, #0]
   1ec76:	460b      	mov	r3, r1
   1ec78:	817b      	strh	r3, [r7, #10]
  /* if continuing */
  if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1ec7a:	68fb      	ldr	r3, [r7, #12]
   1ec7c:	7cdb      	ldrb	r3, [r3, #19]
   1ec7e:	2b01      	cmp	r3, #1
   1ec80:	d111      	bne.n	1eca6 <attcProcReadLongRsp+0x3c>
  {
    /* length of response is less than mtu */
    if (len < pCcb->pMainCcb->mtu)
   1ec82:	68fb      	ldr	r3, [r7, #12]
   1ec84:	681b      	ldr	r3, [r3, #0]
   1ec86:	8b5b      	ldrh	r3, [r3, #26]
   1ec88:	897a      	ldrh	r2, [r7, #10]
   1ec8a:	429a      	cmp	r2, r3
   1ec8c:	d203      	bcs.n	1ec96 <attcProcReadLongRsp+0x2c>
    {
      /* we're done */
      pCcb->outReq.hdr.status = ATTC_NOT_CONTINUING;
   1ec8e:	68fb      	ldr	r3, [r7, #12]
   1ec90:	2200      	movs	r2, #0
   1ec92:	74da      	strb	r2, [r3, #19]
    else
    {
      pCcb->outReqParams.o.offset += pEvt->valueLen;
    }
  }
}
   1ec94:	e007      	b.n	1eca6 <attcProcReadLongRsp+0x3c>
      pCcb->outReqParams.o.offset += pEvt->valueLen;
   1ec96:	68fb      	ldr	r3, [r7, #12]
   1ec98:	8bda      	ldrh	r2, [r3, #30]
   1ec9a:	683b      	ldr	r3, [r7, #0]
   1ec9c:	891b      	ldrh	r3, [r3, #8]
   1ec9e:	4413      	add	r3, r2
   1eca0:	b29a      	uxth	r2, r3
   1eca2:	68fb      	ldr	r3, [r7, #12]
   1eca4:	83da      	strh	r2, [r3, #30]
}
   1eca6:	bf00      	nop
   1eca8:	3714      	adds	r7, #20
   1ecaa:	46bd      	mov	sp, r7
   1ecac:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ecb0:	4770      	bx	lr

0001ecb2 <attcProcPrepWriteRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attcProcPrepWriteRsp(attcCcb_t *pCcb, uint16_t len, uint8_t *pPacket, attEvt_t *pEvt)
{
   1ecb2:	b480      	push	{r7}
   1ecb4:	b085      	sub	sp, #20
   1ecb6:	af00      	add	r7, sp, #0
   1ecb8:	60f8      	str	r0, [r7, #12]
   1ecba:	607a      	str	r2, [r7, #4]
   1ecbc:	603b      	str	r3, [r7, #0]
   1ecbe:	460b      	mov	r3, r1
   1ecc0:	817b      	strh	r3, [r7, #10]
  /* if continuing */
  if (pCcb->outReq.hdr.status == ATTC_CONTINUING)
   1ecc2:	68fb      	ldr	r3, [r7, #12]
   1ecc4:	7cdb      	ldrb	r3, [r3, #19]
   1ecc6:	2b01      	cmp	r3, #1
   1ecc8:	d106      	bne.n	1ecd8 <attcProcPrepWriteRsp+0x26>
  {
    /* if no more data to send */
    if (pCcb->outReqParams.w.len == 0)
   1ecca:	68fb      	ldr	r3, [r7, #12]
   1eccc:	8b9b      	ldrh	r3, [r3, #28]
   1ecce:	2b00      	cmp	r3, #0
   1ecd0:	d102      	bne.n	1ecd8 <attcProcPrepWriteRsp+0x26>
    {
      /* we're done */
      pCcb->outReq.hdr.status = ATTC_NOT_CONTINUING;
   1ecd2:	68fb      	ldr	r3, [r7, #12]
   1ecd4:	2200      	movs	r2, #0
   1ecd6:	74da      	strb	r2, [r3, #19]
    }
  }

  /* adjust attribute value and its length (adjusted by ATT header length already) */
  pEvt->pValue += (ATT_PREP_WRITE_RSP_LEN - ATT_HDR_LEN);
   1ecd8:	683b      	ldr	r3, [r7, #0]
   1ecda:	685b      	ldr	r3, [r3, #4]
   1ecdc:	1d1a      	adds	r2, r3, #4
   1ecde:	683b      	ldr	r3, [r7, #0]
   1ece0:	605a      	str	r2, [r3, #4]
  pEvt->valueLen -= (ATT_PREP_WRITE_RSP_LEN - ATT_HDR_LEN);
   1ece2:	683b      	ldr	r3, [r7, #0]
   1ece4:	891b      	ldrh	r3, [r3, #8]
   1ece6:	3b04      	subs	r3, #4
   1ece8:	b29a      	uxth	r2, r3
   1ecea:	683b      	ldr	r3, [r7, #0]
   1ecec:	811a      	strh	r2, [r3, #8]
}
   1ecee:	bf00      	nop
   1ecf0:	3714      	adds	r7, #20
   1ecf2:	46bd      	mov	sp, r7
   1ecf4:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ecf8:	4770      	bx	lr
	...

0001ecfc <attsCccCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsCccCback(dmConnId_t connId, uint8_t idx, uint16_t handle, uint16_t value)
{
   1ecfc:	b590      	push	{r4, r7, lr}
   1ecfe:	b087      	sub	sp, #28
   1ed00:	af00      	add	r7, sp, #0
   1ed02:	4604      	mov	r4, r0
   1ed04:	4608      	mov	r0, r1
   1ed06:	4611      	mov	r1, r2
   1ed08:	461a      	mov	r2, r3
   1ed0a:	4623      	mov	r3, r4
   1ed0c:	71fb      	strb	r3, [r7, #7]
   1ed0e:	4603      	mov	r3, r0
   1ed10:	71bb      	strb	r3, [r7, #6]
   1ed12:	460b      	mov	r3, r1
   1ed14:	80bb      	strh	r3, [r7, #4]
   1ed16:	4613      	mov	r3, r2
   1ed18:	807b      	strh	r3, [r7, #2]
  attsCccEvt_t  evt;

  evt.hdr.event = ATTS_CCC_STATE_IND;
   1ed1a:	2310      	movs	r3, #16
   1ed1c:	73bb      	strb	r3, [r7, #14]
  evt.hdr.param = connId;
   1ed1e:	79fb      	ldrb	r3, [r7, #7]
   1ed20:	b29b      	uxth	r3, r3
   1ed22:	81bb      	strh	r3, [r7, #12]
  evt.idx = idx;
   1ed24:	79bb      	ldrb	r3, [r7, #6]
   1ed26:	753b      	strb	r3, [r7, #20]
  evt.handle = handle;
   1ed28:	88bb      	ldrh	r3, [r7, #4]
   1ed2a:	823b      	strh	r3, [r7, #16]
  evt.value = value;
   1ed2c:	887b      	ldrh	r3, [r7, #2]
   1ed2e:	827b      	strh	r3, [r7, #18]

  (*attsCccCb.cback)(&evt);
   1ed30:	4b04      	ldr	r3, [pc, #16]	; (1ed44 <attsCccCback+0x48>)
   1ed32:	691b      	ldr	r3, [r3, #16]
   1ed34:	f107 020c 	add.w	r2, r7, #12
   1ed38:	4610      	mov	r0, r2
   1ed3a:	4798      	blx	r3
}
   1ed3c:	bf00      	nop
   1ed3e:	371c      	adds	r7, #28
   1ed40:	46bd      	mov	sp, r7
   1ed42:	bd90      	pop	{r4, r7, pc}
   1ed44:	10003f34 	.word	0x10003f34

0001ed48 <attsCccAllocTbl>:
 *
 *  \return Pointer into the CCC table.
 */
/*************************************************************************************************/
static uint16_t *attsCccAllocTbl(dmConnId_t connId)
{
   1ed48:	b590      	push	{r4, r7, lr}
   1ed4a:	b083      	sub	sp, #12
   1ed4c:	af00      	add	r7, sp, #0
   1ed4e:	4603      	mov	r3, r0
   1ed50:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  /* if not already allocated */
  if (attsCccCb.pCccTbl[connId - 1] == NULL)
   1ed52:	79fb      	ldrb	r3, [r7, #7]
   1ed54:	3b01      	subs	r3, #1
   1ed56:	4a0e      	ldr	r2, [pc, #56]	; (1ed90 <attsCccAllocTbl+0x48>)
   1ed58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1ed5c:	2b00      	cmp	r3, #0
   1ed5e:	d10d      	bne.n	1ed7c <attsCccAllocTbl+0x34>
  {
    WSF_ASSERT(attsCccCb.setLen > 0);

    /* allocate new buffer */
    attsCccCb.pCccTbl[connId - 1] = WsfBufAlloc(attsCccCb.setLen * sizeof(uint16_t));
   1ed60:	4b0b      	ldr	r3, [pc, #44]	; (1ed90 <attsCccAllocTbl+0x48>)
   1ed62:	7d1b      	ldrb	r3, [r3, #20]
   1ed64:	b29b      	uxth	r3, r3
   1ed66:	005b      	lsls	r3, r3, #1
   1ed68:	b29a      	uxth	r2, r3
   1ed6a:	79fb      	ldrb	r3, [r7, #7]
   1ed6c:	1e5c      	subs	r4, r3, #1
   1ed6e:	4610      	mov	r0, r2
   1ed70:	f00e f90e 	bl	2cf90 <WsfBufAlloc>
   1ed74:	4603      	mov	r3, r0
   1ed76:	4a06      	ldr	r2, [pc, #24]	; (1ed90 <attsCccAllocTbl+0x48>)
   1ed78:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
  }

  return attsCccCb.pCccTbl[connId - 1];
   1ed7c:	79fb      	ldrb	r3, [r7, #7]
   1ed7e:	3b01      	subs	r3, #1
   1ed80:	4a03      	ldr	r2, [pc, #12]	; (1ed90 <attsCccAllocTbl+0x48>)
   1ed82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
   1ed86:	4618      	mov	r0, r3
   1ed88:	370c      	adds	r7, #12
   1ed8a:	46bd      	mov	sp, r7
   1ed8c:	bd90      	pop	{r4, r7, pc}
   1ed8e:	bf00      	nop
   1ed90:	10003f34 	.word	0x10003f34

0001ed94 <attsCccGetTbl>:
 *
 *  \return Pointer into the CCC table.
 */
/*************************************************************************************************/
static uint16_t *attsCccGetTbl(dmConnId_t connId)
{
   1ed94:	b480      	push	{r7}
   1ed96:	b083      	sub	sp, #12
   1ed98:	af00      	add	r7, sp, #0
   1ed9a:	4603      	mov	r3, r0
   1ed9c:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return attsCccCb.pCccTbl[connId - 1];
   1ed9e:	79fb      	ldrb	r3, [r7, #7]
   1eda0:	3b01      	subs	r3, #1
   1eda2:	4a04      	ldr	r2, [pc, #16]	; (1edb4 <attsCccGetTbl+0x20>)
   1eda4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
}
   1eda8:	4618      	mov	r0, r3
   1edaa:	370c      	adds	r7, #12
   1edac:	46bd      	mov	sp, r7
   1edae:	f85d 7b04 	ldr.w	r7, [sp], #4
   1edb2:	4770      	bx	lr
   1edb4:	10003f34 	.word	0x10003f34

0001edb8 <attsCccFreeTbl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsCccFreeTbl(dmConnId_t connId)
{
   1edb8:	b580      	push	{r7, lr}
   1edba:	b082      	sub	sp, #8
   1edbc:	af00      	add	r7, sp, #0
   1edbe:	4603      	mov	r3, r0
   1edc0:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  if (attsCccCb.pCccTbl[connId - 1] != NULL)
   1edc2:	79fb      	ldrb	r3, [r7, #7]
   1edc4:	3b01      	subs	r3, #1
   1edc6:	4a0b      	ldr	r2, [pc, #44]	; (1edf4 <attsCccFreeTbl+0x3c>)
   1edc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1edcc:	2b00      	cmp	r3, #0
   1edce:	d00d      	beq.n	1edec <attsCccFreeTbl+0x34>
  {
    WsfBufFree(attsCccCb.pCccTbl[connId - 1]);
   1edd0:	79fb      	ldrb	r3, [r7, #7]
   1edd2:	3b01      	subs	r3, #1
   1edd4:	4a07      	ldr	r2, [pc, #28]	; (1edf4 <attsCccFreeTbl+0x3c>)
   1edd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1edda:	4618      	mov	r0, r3
   1eddc:	f00e f918 	bl	2d010 <WsfBufFree>
    attsCccCb.pCccTbl[connId - 1] = NULL;
   1ede0:	79fb      	ldrb	r3, [r7, #7]
   1ede2:	3b01      	subs	r3, #1
   1ede4:	4a03      	ldr	r2, [pc, #12]	; (1edf4 <attsCccFreeTbl+0x3c>)
   1ede6:	2100      	movs	r1, #0
   1ede8:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  }
}
   1edec:	bf00      	nop
   1edee:	3708      	adds	r7, #8
   1edf0:	46bd      	mov	sp, r7
   1edf2:	bd80      	pop	{r7, pc}
   1edf4:	10003f34 	.word	0x10003f34

0001edf8 <attsCccReadValue>:
 *
 *  \return ATT_SUCCESS if successful otherwise error.
 */
/*************************************************************************************************/
static uint8_t attsCccReadValue(dmConnId_t connId, uint16_t handle, uint8_t *pValue)
{
   1edf8:	b580      	push	{r7, lr}
   1edfa:	b086      	sub	sp, #24
   1edfc:	af00      	add	r7, sp, #0
   1edfe:	4603      	mov	r3, r0
   1ee00:	603a      	str	r2, [r7, #0]
   1ee02:	71fb      	strb	r3, [r7, #7]
   1ee04:	460b      	mov	r3, r1
   1ee06:	80bb      	strh	r3, [r7, #4]
  attsCccSet_t  *pSet;
  uint16_t      *pTbl;
  uint8_t       i;

  /* find handle in handle array */
  for (pSet = attsCccCb.pSet, i = 0; i < attsCccCb.setLen; i++, pSet++)
   1ee08:	4b21      	ldr	r3, [pc, #132]	; (1ee90 <attsCccReadValue+0x98>)
   1ee0a:	68db      	ldr	r3, [r3, #12]
   1ee0c:	617b      	str	r3, [r7, #20]
   1ee0e:	2300      	movs	r3, #0
   1ee10:	74fb      	strb	r3, [r7, #19]
   1ee12:	e00a      	b.n	1ee2a <attsCccReadValue+0x32>
  {
    if (pSet->handle == handle)
   1ee14:	697b      	ldr	r3, [r7, #20]
   1ee16:	881b      	ldrh	r3, [r3, #0]
   1ee18:	88ba      	ldrh	r2, [r7, #4]
   1ee1a:	429a      	cmp	r2, r3
   1ee1c:	d00b      	beq.n	1ee36 <attsCccReadValue+0x3e>
  for (pSet = attsCccCb.pSet, i = 0; i < attsCccCb.setLen; i++, pSet++)
   1ee1e:	7cfb      	ldrb	r3, [r7, #19]
   1ee20:	3301      	adds	r3, #1
   1ee22:	74fb      	strb	r3, [r7, #19]
   1ee24:	697b      	ldr	r3, [r7, #20]
   1ee26:	3306      	adds	r3, #6
   1ee28:	617b      	str	r3, [r7, #20]
   1ee2a:	4b19      	ldr	r3, [pc, #100]	; (1ee90 <attsCccReadValue+0x98>)
   1ee2c:	7d1b      	ldrb	r3, [r3, #20]
   1ee2e:	7cfa      	ldrb	r2, [r7, #19]
   1ee30:	429a      	cmp	r2, r3
   1ee32:	d3ef      	bcc.n	1ee14 <attsCccReadValue+0x1c>
   1ee34:	e000      	b.n	1ee38 <attsCccReadValue+0x40>
    {
      break;
   1ee36:	bf00      	nop
    }
  }

  /* if handle not found return error */
  if (i == attsCccCb.setLen)
   1ee38:	4b15      	ldr	r3, [pc, #84]	; (1ee90 <attsCccReadValue+0x98>)
   1ee3a:	7d1b      	ldrb	r3, [r3, #20]
   1ee3c:	7cfa      	ldrb	r2, [r7, #19]
   1ee3e:	429a      	cmp	r2, r3
   1ee40:	d101      	bne.n	1ee46 <attsCccReadValue+0x4e>
  {
    return ATT_ERR_NOT_FOUND;
   1ee42:	230a      	movs	r3, #10
   1ee44:	e020      	b.n	1ee88 <attsCccReadValue+0x90>
  }

  /* get pointer to the table for this connection */
  if ((pTbl = attsCccGetTbl(connId)) != NULL)
   1ee46:	79fb      	ldrb	r3, [r7, #7]
   1ee48:	4618      	mov	r0, r3
   1ee4a:	f7ff ffa3 	bl	1ed94 <attsCccGetTbl>
   1ee4e:	60f8      	str	r0, [r7, #12]
   1ee50:	68fb      	ldr	r3, [r7, #12]
   1ee52:	2b00      	cmp	r3, #0
   1ee54:	d017      	beq.n	1ee86 <attsCccReadValue+0x8e>
  {
    /* read value */
    UINT16_TO_BSTREAM(pValue, pTbl[i]);
   1ee56:	7cfb      	ldrb	r3, [r7, #19]
   1ee58:	005b      	lsls	r3, r3, #1
   1ee5a:	68fa      	ldr	r2, [r7, #12]
   1ee5c:	4413      	add	r3, r2
   1ee5e:	8819      	ldrh	r1, [r3, #0]
   1ee60:	683b      	ldr	r3, [r7, #0]
   1ee62:	1c5a      	adds	r2, r3, #1
   1ee64:	603a      	str	r2, [r7, #0]
   1ee66:	b2ca      	uxtb	r2, r1
   1ee68:	701a      	strb	r2, [r3, #0]
   1ee6a:	7cfb      	ldrb	r3, [r7, #19]
   1ee6c:	005b      	lsls	r3, r3, #1
   1ee6e:	68fa      	ldr	r2, [r7, #12]
   1ee70:	4413      	add	r3, r2
   1ee72:	881b      	ldrh	r3, [r3, #0]
   1ee74:	0a1b      	lsrs	r3, r3, #8
   1ee76:	b299      	uxth	r1, r3
   1ee78:	683b      	ldr	r3, [r7, #0]
   1ee7a:	1c5a      	adds	r2, r3, #1
   1ee7c:	603a      	str	r2, [r7, #0]
   1ee7e:	b2ca      	uxtb	r2, r1
   1ee80:	701a      	strb	r2, [r3, #0]

    return ATT_SUCCESS;
   1ee82:	2300      	movs	r3, #0
   1ee84:	e000      	b.n	1ee88 <attsCccReadValue+0x90>
  }
  else
  {
    return ATT_ERR_RESOURCES;
   1ee86:	2311      	movs	r3, #17
  }
}
   1ee88:	4618      	mov	r0, r3
   1ee8a:	3718      	adds	r7, #24
   1ee8c:	46bd      	mov	sp, r7
   1ee8e:	bd80      	pop	{r7, pc}
   1ee90:	10003f34 	.word	0x10003f34

0001ee94 <attsCccWriteValue>:
 *
 *  \return ATT_SUCCESS if successful otherwise error.
 */
/*************************************************************************************************/
static uint8_t attsCccWriteValue(dmConnId_t connId, uint16_t handle, uint8_t *pValue)
{
   1ee94:	b580      	push	{r7, lr}
   1ee96:	b086      	sub	sp, #24
   1ee98:	af00      	add	r7, sp, #0
   1ee9a:	4603      	mov	r3, r0
   1ee9c:	603a      	str	r2, [r7, #0]
   1ee9e:	71fb      	strb	r3, [r7, #7]
   1eea0:	460b      	mov	r3, r1
   1eea2:	80bb      	strh	r3, [r7, #4]
  uint8_t       i;
  uint16_t      value;
  uint16_t      prevValue;

  /* find handle in handle array */
  for (pSet = attsCccCb.pSet, i = 0; i < attsCccCb.setLen; i++, pSet++)
   1eea4:	4b31      	ldr	r3, [pc, #196]	; (1ef6c <attsCccWriteValue+0xd8>)
   1eea6:	68db      	ldr	r3, [r3, #12]
   1eea8:	617b      	str	r3, [r7, #20]
   1eeaa:	2300      	movs	r3, #0
   1eeac:	74fb      	strb	r3, [r7, #19]
   1eeae:	e00a      	b.n	1eec6 <attsCccWriteValue+0x32>
  {
    if (pSet->handle == handle)
   1eeb0:	697b      	ldr	r3, [r7, #20]
   1eeb2:	881b      	ldrh	r3, [r3, #0]
   1eeb4:	88ba      	ldrh	r2, [r7, #4]
   1eeb6:	429a      	cmp	r2, r3
   1eeb8:	d00b      	beq.n	1eed2 <attsCccWriteValue+0x3e>
  for (pSet = attsCccCb.pSet, i = 0; i < attsCccCb.setLen; i++, pSet++)
   1eeba:	7cfb      	ldrb	r3, [r7, #19]
   1eebc:	3301      	adds	r3, #1
   1eebe:	74fb      	strb	r3, [r7, #19]
   1eec0:	697b      	ldr	r3, [r7, #20]
   1eec2:	3306      	adds	r3, #6
   1eec4:	617b      	str	r3, [r7, #20]
   1eec6:	4b29      	ldr	r3, [pc, #164]	; (1ef6c <attsCccWriteValue+0xd8>)
   1eec8:	7d1b      	ldrb	r3, [r3, #20]
   1eeca:	7cfa      	ldrb	r2, [r7, #19]
   1eecc:	429a      	cmp	r2, r3
   1eece:	d3ef      	bcc.n	1eeb0 <attsCccWriteValue+0x1c>
   1eed0:	e000      	b.n	1eed4 <attsCccWriteValue+0x40>
    {
      break;
   1eed2:	bf00      	nop
    }
  }

  /* if handle not found return error */
  if (i == attsCccCb.setLen)
   1eed4:	4b25      	ldr	r3, [pc, #148]	; (1ef6c <attsCccWriteValue+0xd8>)
   1eed6:	7d1b      	ldrb	r3, [r3, #20]
   1eed8:	7cfa      	ldrb	r2, [r7, #19]
   1eeda:	429a      	cmp	r2, r3
   1eedc:	d101      	bne.n	1eee2 <attsCccWriteValue+0x4e>
  {
    return ATT_ERR_NOT_FOUND;
   1eede:	230a      	movs	r3, #10
   1eee0:	e040      	b.n	1ef64 <attsCccWriteValue+0xd0>
  }

  BYTES_TO_UINT16(value, pValue);
   1eee2:	683b      	ldr	r3, [r7, #0]
   1eee4:	781b      	ldrb	r3, [r3, #0]
   1eee6:	b29a      	uxth	r2, r3
   1eee8:	683b      	ldr	r3, [r7, #0]
   1eeea:	3301      	adds	r3, #1
   1eeec:	781b      	ldrb	r3, [r3, #0]
   1eeee:	b29b      	uxth	r3, r3
   1eef0:	021b      	lsls	r3, r3, #8
   1eef2:	b29b      	uxth	r3, r3
   1eef4:	4413      	add	r3, r2
   1eef6:	823b      	strh	r3, [r7, #16]

  /* verify value range */
  if (((value != 0) && (value != ATT_CLIENT_CFG_NOTIFY) && (value != ATT_CLIENT_CFG_INDICATE)) ||
   1eef8:	8a3b      	ldrh	r3, [r7, #16]
   1eefa:	2b00      	cmp	r3, #0
   1eefc:	d005      	beq.n	1ef0a <attsCccWriteValue+0x76>
   1eefe:	8a3b      	ldrh	r3, [r7, #16]
   1ef00:	2b01      	cmp	r3, #1
   1ef02:	d002      	beq.n	1ef0a <attsCccWriteValue+0x76>
   1ef04:	8a3b      	ldrh	r3, [r7, #16]
   1ef06:	2b02      	cmp	r3, #2
   1ef08:	d109      	bne.n	1ef1e <attsCccWriteValue+0x8a>
   1ef0a:	8a3b      	ldrh	r3, [r7, #16]
   1ef0c:	2b00      	cmp	r3, #0
   1ef0e:	d008      	beq.n	1ef22 <attsCccWriteValue+0x8e>
      ((value != 0) && ((value & pSet->valueRange) == 0)))
   1ef10:	697b      	ldr	r3, [r7, #20]
   1ef12:	885a      	ldrh	r2, [r3, #2]
   1ef14:	8a3b      	ldrh	r3, [r7, #16]
   1ef16:	4013      	ands	r3, r2
   1ef18:	b29b      	uxth	r3, r3
   1ef1a:	2b00      	cmp	r3, #0
   1ef1c:	d101      	bne.n	1ef22 <attsCccWriteValue+0x8e>
  {
    return ATT_ERR_VALUE_RANGE;
   1ef1e:	2380      	movs	r3, #128	; 0x80
   1ef20:	e020      	b.n	1ef64 <attsCccWriteValue+0xd0>
  }

  /* get pointer to the table for this connection */
  if ((pTbl = attsCccGetTbl(connId)) != NULL)
   1ef22:	79fb      	ldrb	r3, [r7, #7]
   1ef24:	4618      	mov	r0, r3
   1ef26:	f7ff ff35 	bl	1ed94 <attsCccGetTbl>
   1ef2a:	60f8      	str	r0, [r7, #12]
   1ef2c:	68fb      	ldr	r3, [r7, #12]
   1ef2e:	2b00      	cmp	r3, #0
   1ef30:	d017      	beq.n	1ef62 <attsCccWriteValue+0xce>
  {
    /* write value */
    prevValue = pTbl[i];
   1ef32:	7cfb      	ldrb	r3, [r7, #19]
   1ef34:	005b      	lsls	r3, r3, #1
   1ef36:	68fa      	ldr	r2, [r7, #12]
   1ef38:	4413      	add	r3, r2
   1ef3a:	881b      	ldrh	r3, [r3, #0]
   1ef3c:	817b      	strh	r3, [r7, #10]
    pTbl[i] = value;
   1ef3e:	7cfb      	ldrb	r3, [r7, #19]
   1ef40:	005b      	lsls	r3, r3, #1
   1ef42:	68fa      	ldr	r2, [r7, #12]
   1ef44:	4413      	add	r3, r2
   1ef46:	8a3a      	ldrh	r2, [r7, #16]
   1ef48:	801a      	strh	r2, [r3, #0]
    if (prevValue != value || handle == ATVV_CTL_CH_CCC_HDL)  // AMVOS_TX_CH_CCC_HDL (VoS Workaround for re-connection after RESET board.)
#else // configUSE_AMVOS_ATVV
    if (prevValue != value || handle == AMVOS_TX_CH_CCC_HDL)  // AMVOS_TX_CH_CCC_HDL (VoS Workaround for re-connection after RESET board.)
#endif // configUSE_AMVOS_ATVV
#else  // AM_VOS_SDK
    if (prevValue != value)
   1ef4a:	897a      	ldrh	r2, [r7, #10]
   1ef4c:	8a3b      	ldrh	r3, [r7, #16]
   1ef4e:	429a      	cmp	r2, r3
   1ef50:	d005      	beq.n	1ef5e <attsCccWriteValue+0xca>
#endif  // AM_VOS_SDK
    {
      attsCccCback(connId, i, handle, value);
   1ef52:	8a3b      	ldrh	r3, [r7, #16]
   1ef54:	88ba      	ldrh	r2, [r7, #4]
   1ef56:	7cf9      	ldrb	r1, [r7, #19]
   1ef58:	79f8      	ldrb	r0, [r7, #7]
   1ef5a:	f7ff fecf 	bl	1ecfc <attsCccCback>
    }

    return ATT_SUCCESS;
   1ef5e:	2300      	movs	r3, #0
   1ef60:	e000      	b.n	1ef64 <attsCccWriteValue+0xd0>
  }
  else
  {
    return ATT_ERR_RESOURCES;
   1ef62:	2311      	movs	r3, #17
  }
}
   1ef64:	4618      	mov	r0, r3
   1ef66:	3718      	adds	r7, #24
   1ef68:	46bd      	mov	sp, r7
   1ef6a:	bd80      	pop	{r7, pc}
   1ef6c:	10003f34 	.word	0x10003f34

0001ef70 <attsCccMainCback>:
 *
 *  \return ATT_SUCCESS if successful otherwise error.
 */
/*************************************************************************************************/
static uint8_t attsCccMainCback(dmConnId_t connId, uint8_t method, uint16_t handle, uint8_t *pValue)
{
   1ef70:	b580      	push	{r7, lr}
   1ef72:	b082      	sub	sp, #8
   1ef74:	af00      	add	r7, sp, #0
   1ef76:	603b      	str	r3, [r7, #0]
   1ef78:	4603      	mov	r3, r0
   1ef7a:	71fb      	strb	r3, [r7, #7]
   1ef7c:	460b      	mov	r3, r1
   1ef7e:	71bb      	strb	r3, [r7, #6]
   1ef80:	4613      	mov	r3, r2
   1ef82:	80bb      	strh	r3, [r7, #4]
  ATT_TRACE_INFO2("attsCccMainCback connId=%d handle=%d", connId, handle);
   1ef84:	79fb      	ldrb	r3, [r7, #7]
   1ef86:	88ba      	ldrh	r2, [r7, #4]
   1ef88:	4619      	mov	r1, r3
   1ef8a:	480c      	ldr	r0, [pc, #48]	; (1efbc <attsCccMainCback+0x4c>)
   1ef8c:	f00e fd00 	bl	2d990 <WsfTrace>

  if (method == ATT_METHOD_READ)
   1ef90:	79bb      	ldrb	r3, [r7, #6]
   1ef92:	2b05      	cmp	r3, #5
   1ef94:	d107      	bne.n	1efa6 <attsCccMainCback+0x36>
  {
    return attsCccReadValue(connId, handle, pValue);
   1ef96:	88b9      	ldrh	r1, [r7, #4]
   1ef98:	79fb      	ldrb	r3, [r7, #7]
   1ef9a:	683a      	ldr	r2, [r7, #0]
   1ef9c:	4618      	mov	r0, r3
   1ef9e:	f7ff ff2b 	bl	1edf8 <attsCccReadValue>
   1efa2:	4603      	mov	r3, r0
   1efa4:	e006      	b.n	1efb4 <attsCccMainCback+0x44>
  }
  else
  {
    return attsCccWriteValue(connId, handle, pValue);
   1efa6:	88b9      	ldrh	r1, [r7, #4]
   1efa8:	79fb      	ldrb	r3, [r7, #7]
   1efaa:	683a      	ldr	r2, [r7, #0]
   1efac:	4618      	mov	r0, r3
   1efae:	f7ff ff71 	bl	1ee94 <attsCccWriteValue>
   1efb2:	4603      	mov	r3, r0
  }
}
   1efb4:	4618      	mov	r0, r3
   1efb6:	3708      	adds	r7, #8
   1efb8:	46bd      	mov	sp, r7
   1efba:	bd80      	pop	{r7, pc}
   1efbc:	00044848 	.word	0x00044848

0001efc0 <AttsCccRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsCccRegister(uint8_t setLen, attsCccSet_t *pSet, attsCccCback_t cback)
{
   1efc0:	b480      	push	{r7}
   1efc2:	b085      	sub	sp, #20
   1efc4:	af00      	add	r7, sp, #0
   1efc6:	4603      	mov	r3, r0
   1efc8:	60b9      	str	r1, [r7, #8]
   1efca:	607a      	str	r2, [r7, #4]
   1efcc:	73fb      	strb	r3, [r7, #15]
  attsCccCb.setLen = setLen;
   1efce:	4a09      	ldr	r2, [pc, #36]	; (1eff4 <AttsCccRegister+0x34>)
   1efd0:	7bfb      	ldrb	r3, [r7, #15]
   1efd2:	7513      	strb	r3, [r2, #20]
  attsCccCb.pSet = pSet;
   1efd4:	4a07      	ldr	r2, [pc, #28]	; (1eff4 <AttsCccRegister+0x34>)
   1efd6:	68bb      	ldr	r3, [r7, #8]
   1efd8:	60d3      	str	r3, [r2, #12]
  attsCccCb.cback = cback;
   1efda:	4a06      	ldr	r2, [pc, #24]	; (1eff4 <AttsCccRegister+0x34>)
   1efdc:	687b      	ldr	r3, [r7, #4]
   1efde:	6113      	str	r3, [r2, #16]

  attsCb.cccCback = attsCccMainCback;
   1efe0:	4b05      	ldr	r3, [pc, #20]	; (1eff8 <AttsCccRegister+0x38>)
   1efe2:	4a06      	ldr	r2, [pc, #24]	; (1effc <AttsCccRegister+0x3c>)
   1efe4:	615a      	str	r2, [r3, #20]
}
   1efe6:	bf00      	nop
   1efe8:	3714      	adds	r7, #20
   1efea:	46bd      	mov	sp, r7
   1efec:	f85d 7b04 	ldr.w	r7, [sp], #4
   1eff0:	4770      	bx	lr
   1eff2:	bf00      	nop
   1eff4:	10003f34 	.word	0x10003f34
   1eff8:	100111dc 	.word	0x100111dc
   1effc:	0001ef71 	.word	0x0001ef71

0001f000 <AttsCccInitTable>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsCccInitTable(dmConnId_t connId, uint16_t *pCccTbl)
{
   1f000:	b580      	push	{r7, lr}
   1f002:	b084      	sub	sp, #16
   1f004:	af00      	add	r7, sp, #0
   1f006:	4603      	mov	r3, r0
   1f008:	6039      	str	r1, [r7, #0]
   1f00a:	71fb      	strb	r3, [r7, #7]
  uint8_t   i;
  uint16_t  *pTbl;

  ATT_TRACE_INFO1("AttsCccInitTable connId=%d", connId);
   1f00c:	79fb      	ldrb	r3, [r7, #7]
   1f00e:	4619      	mov	r1, r3
   1f010:	481d      	ldr	r0, [pc, #116]	; (1f088 <AttsCccInitTable+0x88>)
   1f012:	f00e fcbd 	bl	2d990 <WsfTrace>

  if ((pTbl = attsCccAllocTbl(connId)) != NULL)
   1f016:	79fb      	ldrb	r3, [r7, #7]
   1f018:	4618      	mov	r0, r3
   1f01a:	f7ff fe95 	bl	1ed48 <attsCccAllocTbl>
   1f01e:	60b8      	str	r0, [r7, #8]
   1f020:	68bb      	ldr	r3, [r7, #8]
   1f022:	2b00      	cmp	r3, #0
   1f024:	d02b      	beq.n	1f07e <AttsCccInitTable+0x7e>
  {
    /* if initializer table is passed in */
    if (pCccTbl != NULL)
   1f026:	683b      	ldr	r3, [r7, #0]
   1f028:	2b00      	cmp	r3, #0
   1f02a:	d020      	beq.n	1f06e <AttsCccInitTable+0x6e>
    {
      /* initialize table */
      for (i = 0; i < attsCccCb.setLen; i++, pCccTbl++, pTbl++)
   1f02c:	2300      	movs	r3, #0
   1f02e:	73fb      	strb	r3, [r7, #15]
   1f030:	e017      	b.n	1f062 <AttsCccInitTable+0x62>
      {
        /* copy value */
        *pTbl = *pCccTbl;
   1f032:	683b      	ldr	r3, [r7, #0]
   1f034:	881a      	ldrh	r2, [r3, #0]
   1f036:	68bb      	ldr	r3, [r7, #8]
   1f038:	801a      	strh	r2, [r3, #0]

        /* execute callback for each nonzero entry in table */
        if (*pCccTbl != 0)
   1f03a:	683b      	ldr	r3, [r7, #0]
   1f03c:	881b      	ldrh	r3, [r3, #0]
   1f03e:	2b00      	cmp	r3, #0
   1f040:	d006      	beq.n	1f050 <AttsCccInitTable+0x50>
        {
          attsCccCback(connId, i, ATT_HANDLE_NONE, *pCccTbl);
   1f042:	683b      	ldr	r3, [r7, #0]
   1f044:	881b      	ldrh	r3, [r3, #0]
   1f046:	7bf9      	ldrb	r1, [r7, #15]
   1f048:	79f8      	ldrb	r0, [r7, #7]
   1f04a:	2200      	movs	r2, #0
   1f04c:	f7ff fe56 	bl	1ecfc <attsCccCback>
      for (i = 0; i < attsCccCb.setLen; i++, pCccTbl++, pTbl++)
   1f050:	7bfb      	ldrb	r3, [r7, #15]
   1f052:	3301      	adds	r3, #1
   1f054:	73fb      	strb	r3, [r7, #15]
   1f056:	683b      	ldr	r3, [r7, #0]
   1f058:	3302      	adds	r3, #2
   1f05a:	603b      	str	r3, [r7, #0]
   1f05c:	68bb      	ldr	r3, [r7, #8]
   1f05e:	3302      	adds	r3, #2
   1f060:	60bb      	str	r3, [r7, #8]
   1f062:	4b0a      	ldr	r3, [pc, #40]	; (1f08c <AttsCccInitTable+0x8c>)
   1f064:	7d1b      	ldrb	r3, [r3, #20]
   1f066:	7bfa      	ldrb	r2, [r7, #15]
   1f068:	429a      	cmp	r2, r3
   1f06a:	d3e2      	bcc.n	1f032 <AttsCccInitTable+0x32>
    {
      /* initialize table to zero */
      memset(pTbl, 0, (sizeof(uint16_t) * attsCccCb.setLen));
    }
  }
}
   1f06c:	e007      	b.n	1f07e <AttsCccInitTable+0x7e>
      memset(pTbl, 0, (sizeof(uint16_t) * attsCccCb.setLen));
   1f06e:	4b07      	ldr	r3, [pc, #28]	; (1f08c <AttsCccInitTable+0x8c>)
   1f070:	7d1b      	ldrb	r3, [r3, #20]
   1f072:	005b      	lsls	r3, r3, #1
   1f074:	461a      	mov	r2, r3
   1f076:	2100      	movs	r1, #0
   1f078:	68b8      	ldr	r0, [r7, #8]
   1f07a:	f011 f839 	bl	300f0 <memset>
}
   1f07e:	bf00      	nop
   1f080:	3710      	adds	r7, #16
   1f082:	46bd      	mov	sp, r7
   1f084:	bd80      	pop	{r7, pc}
   1f086:	bf00      	nop
   1f088:	00044870 	.word	0x00044870
   1f08c:	10003f34 	.word	0x10003f34

0001f090 <AttsCccClearTable>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsCccClearTable(dmConnId_t connId)
{
   1f090:	b580      	push	{r7, lr}
   1f092:	b082      	sub	sp, #8
   1f094:	af00      	add	r7, sp, #0
   1f096:	4603      	mov	r3, r0
   1f098:	71fb      	strb	r3, [r7, #7]
  ATT_TRACE_INFO1("AttsCccClearTable connId=%d", connId);
   1f09a:	79fb      	ldrb	r3, [r7, #7]
   1f09c:	4619      	mov	r1, r3
   1f09e:	4805      	ldr	r0, [pc, #20]	; (1f0b4 <AttsCccClearTable+0x24>)
   1f0a0:	f00e fc76 	bl	2d990 <WsfTrace>

  attsCccFreeTbl(connId);
   1f0a4:	79fb      	ldrb	r3, [r7, #7]
   1f0a6:	4618      	mov	r0, r3
   1f0a8:	f7ff fe86 	bl	1edb8 <attsCccFreeTbl>
}
   1f0ac:	bf00      	nop
   1f0ae:	3708      	adds	r7, #8
   1f0b0:	46bd      	mov	sp, r7
   1f0b2:	bd80      	pop	{r7, pc}
   1f0b4:	0004488c 	.word	0x0004488c

0001f0b8 <attsCsfSetHashUpdateStatus>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsCsfSetHashUpdateStatus(bool_t isUpdating)
{
   1f0b8:	b580      	push	{r7, lr}
   1f0ba:	b084      	sub	sp, #16
   1f0bc:	af00      	add	r7, sp, #0
   1f0be:	4603      	mov	r3, r0
   1f0c0:	71fb      	strb	r3, [r7, #7]
  if (attsCsfCb.isHashUpdating == isUpdating)
   1f0c2:	4b17      	ldr	r3, [pc, #92]	; (1f120 <attsCsfSetHashUpdateStatus+0x68>)
   1f0c4:	7b1b      	ldrb	r3, [r3, #12]
   1f0c6:	79fa      	ldrb	r2, [r7, #7]
   1f0c8:	429a      	cmp	r2, r3
   1f0ca:	d025      	beq.n	1f118 <attsCsfSetHashUpdateStatus+0x60>
    return;
  }
  else
  {
    /* Update state. */
    attsCsfCb.isHashUpdating = isUpdating;
   1f0cc:	4a14      	ldr	r2, [pc, #80]	; (1f120 <attsCsfSetHashUpdateStatus+0x68>)
   1f0ce:	79fb      	ldrb	r3, [r7, #7]
   1f0d0:	7313      	strb	r3, [r2, #12]
  }

  /* Update complete.
   * Check if clients were pending on the hash value and fulfill their requests.
   */
  if (isUpdating == FALSE)
   1f0d2:	79fb      	ldrb	r3, [r7, #7]
   1f0d4:	2b00      	cmp	r3, #0
   1f0d6:	d105      	bne.n	1f0e4 <attsCsfSetHashUpdateStatus+0x2c>
  {
    ATT_TRACE_INFO0("Database hash calculation complete");
   1f0d8:	4812      	ldr	r0, [pc, #72]	; (1f124 <attsCsfSetHashUpdateStatus+0x6c>)
   1f0da:	f00e fc59 	bl	2d990 <WsfTrace>

    attsCheckPendDbHashReadRsp();
   1f0de:	f000 fe3d 	bl	1fd5c <attsCheckPendDbHashReadRsp>
   1f0e2:	e01a      	b.n	1f11a <attsCsfSetHashUpdateStatus+0x62>
     * sync.
     */
  }
  else
  {
    ATT_TRACE_INFO0("Calculating database hash");
   1f0e4:	4810      	ldr	r0, [pc, #64]	; (1f128 <attsCsfSetHashUpdateStatus+0x70>)
   1f0e6:	f00e fc53 	bl	2d990 <WsfTrace>
    /* If the application, for whatever reason, previously recalculated the database hash over an
     * unchanged database and a client pended on a Read By Type Request of the database hash, then
     * that clients state may be out of step if the application did not initiate a state
     * transition.  That state transition is forced here to keep handle next transition.
     */
    for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   1f0ea:	2300      	movs	r3, #0
   1f0ec:	73fb      	strb	r3, [r7, #15]
   1f0ee:	e00f      	b.n	1f110 <attsCsfSetHashUpdateStatus+0x58>
    {
      if (attsCsfCb.attsCsfTable[i].changeAwareState == ATTS_CLIENT_CHANGE_AWARE_DB_READ_PENDING)
   1f0f0:	7bfb      	ldrb	r3, [r7, #15]
   1f0f2:	4a0b      	ldr	r2, [pc, #44]	; (1f120 <attsCsfSetHashUpdateStatus+0x68>)
   1f0f4:	005b      	lsls	r3, r3, #1
   1f0f6:	4413      	add	r3, r2
   1f0f8:	785b      	ldrb	r3, [r3, #1]
   1f0fa:	2b02      	cmp	r3, #2
   1f0fc:	d105      	bne.n	1f10a <attsCsfSetHashUpdateStatus+0x52>
      {
        attsCsfCb.attsCsfTable[i].changeAwareState = ATTS_CLIENT_CHANGE_PENDING_AWARE;
   1f0fe:	7bfb      	ldrb	r3, [r7, #15]
   1f100:	4a07      	ldr	r2, [pc, #28]	; (1f120 <attsCsfSetHashUpdateStatus+0x68>)
   1f102:	005b      	lsls	r3, r3, #1
   1f104:	4413      	add	r3, r2
   1f106:	2201      	movs	r2, #1
   1f108:	705a      	strb	r2, [r3, #1]
    for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   1f10a:	7bfb      	ldrb	r3, [r7, #15]
   1f10c:	3301      	adds	r3, #1
   1f10e:	73fb      	strb	r3, [r7, #15]
   1f110:	7bfb      	ldrb	r3, [r7, #15]
   1f112:	2b02      	cmp	r3, #2
   1f114:	d9ec      	bls.n	1f0f0 <attsCsfSetHashUpdateStatus+0x38>
   1f116:	e000      	b.n	1f11a <attsCsfSetHashUpdateStatus+0x62>
    return;
   1f118:	bf00      	nop
      }
    }
  }
}
   1f11a:	3710      	adds	r7, #16
   1f11c:	46bd      	mov	sp, r7
   1f11e:	bd80      	pop	{r7, pc}
   1f120:	10011178 	.word	0x10011178
   1f124:	000448a8 	.word	0x000448a8
   1f128:	000448cc 	.word	0x000448cc

0001f12c <attsCsfGetHashUpdateStatus>:
*
*  \return \ref TRUE if update in progress, \ref FALSE otherwise.
*/
/*************************************************************************************************/
uint8_t attsCsfGetHashUpdateStatus(void)
{
   1f12c:	b480      	push	{r7}
   1f12e:	af00      	add	r7, sp, #0
  return attsCsfCb.isHashUpdating;
   1f130:	4b03      	ldr	r3, [pc, #12]	; (1f140 <attsCsfGetHashUpdateStatus+0x14>)
   1f132:	7b1b      	ldrb	r3, [r3, #12]
}
   1f134:	4618      	mov	r0, r3
   1f136:	46bd      	mov	sp, r7
   1f138:	f85d 7b04 	ldr.w	r7, [sp], #4
   1f13c:	4770      	bx	lr
   1f13e:	bf00      	nop
   1f140:	10011178 	.word	0x10011178

0001f144 <attsCsfIsClientChangeAware>:
 *
 *  \return \ref TRUE if client is aware, otherwise \ref FALSE.
 */
/*************************************************************************************************/
uint8_t attsCsfIsClientChangeAware(dmConnId_t connId, uint16_t handle)
{
   1f144:	b480      	push	{r7}
   1f146:	b083      	sub	sp, #12
   1f148:	af00      	add	r7, sp, #0
   1f14a:	4603      	mov	r3, r0
   1f14c:	460a      	mov	r2, r1
   1f14e:	71fb      	strb	r3, [r7, #7]
   1f150:	4613      	mov	r3, r2
   1f152:	80bb      	strh	r3, [r7, #4]
  if ((attsCsfCb.attsCsfTable[connId - 1].csf & ATTS_CSF_ROBUST_CACHING) &&
   1f154:	79fb      	ldrb	r3, [r7, #7]
   1f156:	3b01      	subs	r3, #1
   1f158:	4a0d      	ldr	r2, [pc, #52]	; (1f190 <attsCsfIsClientChangeAware+0x4c>)
   1f15a:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
   1f15e:	f003 0301 	and.w	r3, r3, #1
   1f162:	2b00      	cmp	r3, #0
   1f164:	d00c      	beq.n	1f180 <attsCsfIsClientChangeAware+0x3c>
      (attsCsfCb.attsCsfTable[connId - 1].changeAwareState == ATTS_CLIENT_CHANGE_UNAWARE) &&
   1f166:	79fb      	ldrb	r3, [r7, #7]
   1f168:	3b01      	subs	r3, #1
   1f16a:	4a09      	ldr	r2, [pc, #36]	; (1f190 <attsCsfIsClientChangeAware+0x4c>)
   1f16c:	005b      	lsls	r3, r3, #1
   1f16e:	4413      	add	r3, r2
   1f170:	785b      	ldrb	r3, [r3, #1]
  if ((attsCsfCb.attsCsfTable[connId - 1].csf & ATTS_CSF_ROBUST_CACHING) &&
   1f172:	2b03      	cmp	r3, #3
   1f174:	d104      	bne.n	1f180 <attsCsfIsClientChangeAware+0x3c>
      (attsCsfCb.attsCsfTable[connId - 1].changeAwareState == ATTS_CLIENT_CHANGE_UNAWARE) &&
   1f176:	88bb      	ldrh	r3, [r7, #4]
   1f178:	2b12      	cmp	r3, #18
   1f17a:	d001      	beq.n	1f180 <attsCsfIsClientChangeAware+0x3c>
      (handle != GATT_SC_HDL))
  {
    return FALSE;
   1f17c:	2300      	movs	r3, #0
   1f17e:	e000      	b.n	1f182 <attsCsfIsClientChangeAware+0x3e>
  }

  return TRUE;
   1f180:	2301      	movs	r3, #1
}
   1f182:	4618      	mov	r0, r3
   1f184:	370c      	adds	r7, #12
   1f186:	46bd      	mov	sp, r7
   1f188:	f85d 7b04 	ldr.w	r7, [sp], #4
   1f18c:	4770      	bx	lr
   1f18e:	bf00      	nop
   1f190:	10011178 	.word	0x10011178

0001f194 <attsCsfActClientState>:
 *
 *  \return \ref ATT_SUCCESS if client is change-aware, else \ref ATT_ERR_DATABASE_OUT_OF_SYNC.
 */
/*************************************************************************************************/
uint8_t attsCsfActClientState(uint16_t handle, uint8_t opcode, uint8_t *pPacket)
{
   1f194:	b580      	push	{r7, lr}
   1f196:	b086      	sub	sp, #24
   1f198:	af00      	add	r7, sp, #0
   1f19a:	4603      	mov	r3, r0
   1f19c:	603a      	str	r2, [r7, #0]
   1f19e:	80fb      	strh	r3, [r7, #6]
   1f1a0:	460b      	mov	r3, r1
   1f1a2:	717b      	strb	r3, [r7, #5]
  uint8_t err = ATT_SUCCESS;
   1f1a4:	2300      	movs	r3, #0
   1f1a6:	75fb      	strb	r3, [r7, #23]
  attsCsfRec_t *pRec;

  /* PDU which do not operate on att handles are handled agnostically of the client's state. */
  if (opcode == ATT_PDU_MTU_REQ || opcode == ATT_PDU_VALUE_CNF)
   1f1a8:	797b      	ldrb	r3, [r7, #5]
   1f1aa:	2b02      	cmp	r3, #2
   1f1ac:	d002      	beq.n	1f1b4 <attsCsfActClientState+0x20>
   1f1ae:	797b      	ldrb	r3, [r7, #5]
   1f1b0:	2b1e      	cmp	r3, #30
   1f1b2:	d101      	bne.n	1f1b8 <attsCsfActClientState+0x24>
  {
    return err;
   1f1b4:	7dfb      	ldrb	r3, [r7, #23]
   1f1b6:	e078      	b.n	1f2aa <attsCsfActClientState+0x116>
  }

  pRec = &attsCsfCb.attsCsfTable[handle];
   1f1b8:	88fb      	ldrh	r3, [r7, #6]
   1f1ba:	005b      	lsls	r3, r3, #1
   1f1bc:	4a3d      	ldr	r2, [pc, #244]	; (1f2b4 <attsCsfActClientState+0x120>)
   1f1be:	4413      	add	r3, r2
   1f1c0:	613b      	str	r3, [r7, #16]

  /* If the client is change-unaware */
  if (pRec->changeAwareState == ATTS_CLIENT_CHANGE_UNAWARE)
   1f1c2:	693b      	ldr	r3, [r7, #16]
   1f1c4:	785b      	ldrb	r3, [r3, #1]
   1f1c6:	2b03      	cmp	r3, #3
   1f1c8:	d11c      	bne.n	1f204 <attsCsfActClientState+0x70>
  {
    /* If not a command */
    if ((opcode & ATT_PDU_MASK_COMMAND) == 0)
   1f1ca:	797b      	ldrb	r3, [r7, #5]
   1f1cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1f1d0:	2b00      	cmp	r3, #0
   1f1d2:	d109      	bne.n	1f1e8 <attsCsfActClientState+0x54>
      /* Note: there is no need to call back to the application here.  The application only
       * needs to know when a transition to or from the change-aware state occurs.
       */

      /* Move client change-aware state to pending */
      pRec->changeAwareState = ATTS_CLIENT_CHANGE_PENDING_AWARE;
   1f1d4:	693b      	ldr	r3, [r7, #16]
   1f1d6:	2201      	movs	r2, #1
   1f1d8:	705a      	strb	r2, [r3, #1]

      ATT_TRACE_INFO2("ConnId %d change aware state is %d", handle + 1,
   1f1da:	88fb      	ldrh	r3, [r7, #6]
   1f1dc:	3301      	adds	r3, #1
   1f1de:	2201      	movs	r2, #1
   1f1e0:	4619      	mov	r1, r3
   1f1e2:	4835      	ldr	r0, [pc, #212]	; (1f2b8 <attsCsfActClientState+0x124>)
   1f1e4:	f00e fbd4 	bl	2d990 <WsfTrace>
    }

    /* If this is a command or the Client has indicated Robust Caching, set an error so that
     * this command or request is not processed.
     */
    if ((opcode & ATT_PDU_MASK_COMMAND) ||
   1f1e8:	797b      	ldrb	r3, [r7, #5]
   1f1ea:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1f1ee:	2b00      	cmp	r3, #0
   1f1f0:	d105      	bne.n	1f1fe <attsCsfActClientState+0x6a>
        (pRec->csf & ATTS_CSF_ROBUST_CACHING))
   1f1f2:	693b      	ldr	r3, [r7, #16]
   1f1f4:	781b      	ldrb	r3, [r3, #0]
   1f1f6:	f003 0301 	and.w	r3, r3, #1
    if ((opcode & ATT_PDU_MASK_COMMAND) ||
   1f1fa:	2b00      	cmp	r3, #0
   1f1fc:	d026      	beq.n	1f24c <attsCsfActClientState+0xb8>
    {
      /* return a database out of sync error */
      err = ATT_ERR_DATABASE_OUT_OF_SYNC;
   1f1fe:	2312      	movs	r3, #18
   1f200:	75fb      	strb	r3, [r7, #23]
   1f202:	e023      	b.n	1f24c <attsCsfActClientState+0xb8>
    }
  }
  else if (pRec->changeAwareState == ATTS_CLIENT_CHANGE_PENDING_AWARE)
   1f204:	693b      	ldr	r3, [r7, #16]
   1f206:	785b      	ldrb	r3, [r3, #1]
   1f208:	2b01      	cmp	r3, #1
   1f20a:	d11f      	bne.n	1f24c <attsCsfActClientState+0xb8>
  {
    /* If not a command */
    if ((opcode & ATT_PDU_MASK_COMMAND) == 0)
   1f20c:	797b      	ldrb	r3, [r7, #5]
   1f20e:	f003 0340 	and.w	r3, r3, #64	; 0x40
   1f212:	2b00      	cmp	r3, #0
   1f214:	d118      	bne.n	1f248 <attsCsfActClientState+0xb4>
    {
      /* Move client change-aware state to aware */
      pRec->changeAwareState = ATTS_CLIENT_CHANGE_AWARE;
   1f216:	693b      	ldr	r3, [r7, #16]
   1f218:	2200      	movs	r2, #0
   1f21a:	705a      	strb	r2, [r3, #1]

      ATT_TRACE_INFO2("ConnId %d change aware state is %d", handle + 1, ATTS_CLIENT_CHANGE_AWARE);
   1f21c:	88fb      	ldrh	r3, [r7, #6]
   1f21e:	3301      	adds	r3, #1
   1f220:	2200      	movs	r2, #0
   1f222:	4619      	mov	r1, r3
   1f224:	4824      	ldr	r0, [pc, #144]	; (1f2b8 <attsCsfActClientState+0x124>)
   1f226:	f00e fbb3 	bl	2d990 <WsfTrace>

      /* Callback to application to store updated awareness, if bonded. */
      if (attsCsfCb.writeCback != NULL)
   1f22a:	4b22      	ldr	r3, [pc, #136]	; (1f2b4 <attsCsfActClientState+0x120>)
   1f22c:	689b      	ldr	r3, [r3, #8]
   1f22e:	2b00      	cmp	r3, #0
   1f230:	d00c      	beq.n	1f24c <attsCsfActClientState+0xb8>
      {
        attsCsfCb.writeCback(handle + 1, pRec->changeAwareState, &pRec->csf);
   1f232:	4b20      	ldr	r3, [pc, #128]	; (1f2b4 <attsCsfActClientState+0x120>)
   1f234:	689b      	ldr	r3, [r3, #8]
   1f236:	88fa      	ldrh	r2, [r7, #6]
   1f238:	b2d2      	uxtb	r2, r2
   1f23a:	3201      	adds	r2, #1
   1f23c:	b2d0      	uxtb	r0, r2
   1f23e:	693a      	ldr	r2, [r7, #16]
   1f240:	7851      	ldrb	r1, [r2, #1]
   1f242:	693a      	ldr	r2, [r7, #16]
   1f244:	4798      	blx	r3
   1f246:	e001      	b.n	1f24c <attsCsfActClientState+0xb8>
      }
    }
    else
    {
      /* Return an error so that command is not processed. */
      err = ATT_ERR_DATABASE_OUT_OF_SYNC;
   1f248:	2312      	movs	r3, #18
   1f24a:	75fb      	strb	r3, [r7, #23]
    }
  }

  /* If this is Read by Type request */
  if (opcode == ATT_PDU_READ_TYPE_REQ)
   1f24c:	797b      	ldrb	r3, [r7, #5]
   1f24e:	2b08      	cmp	r3, #8
   1f250:	d120      	bne.n	1f294 <attsCsfActClientState+0x100>
  {
    uint16_t    uuid;

    /* Extract UUID: Skip L2C, ATT Header and 4 byte handle range */
    BYTES_TO_UINT16(uuid, (pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN + 4));
   1f252:	683b      	ldr	r3, [r7, #0]
   1f254:	330d      	adds	r3, #13
   1f256:	781b      	ldrb	r3, [r3, #0]
   1f258:	b29a      	uxth	r2, r3
   1f25a:	683b      	ldr	r3, [r7, #0]
   1f25c:	330e      	adds	r3, #14
   1f25e:	781b      	ldrb	r3, [r3, #0]
   1f260:	b29b      	uxth	r3, r3
   1f262:	021b      	lsls	r3, r3, #8
   1f264:	b29b      	uxth	r3, r3
   1f266:	4413      	add	r3, r2
   1f268:	81fb      	strh	r3, [r7, #14]

    /* If this is a Read By Type Request of the Database Hash characteristic value */
    if (uuid == ATT_UUID_DATABASE_HASH)
   1f26a:	89fb      	ldrh	r3, [r7, #14]
   1f26c:	f642 322a 	movw	r2, #11050	; 0x2b2a
   1f270:	4293      	cmp	r3, r2
   1f272:	d10f      	bne.n	1f294 <attsCsfActClientState+0x100>
    {
      err = ATT_SUCCESS;
   1f274:	2300      	movs	r3, #0
   1f276:	75fb      	strb	r3, [r7, #23]

      /* Reading the hash during a hash update causes the new hash to be returned and counts
       * towards the peer's progression towards a change-aware state.
       */
      if (attsCsfCb.isHashUpdating)
   1f278:	4b0e      	ldr	r3, [pc, #56]	; (1f2b4 <attsCsfActClientState+0x120>)
   1f27a:	7b1b      	ldrb	r3, [r3, #12]
   1f27c:	2b00      	cmp	r3, #0
   1f27e:	d009      	beq.n	1f294 <attsCsfActClientState+0x100>
      {
        /* This read will not be processed until after the hash update completes, so this read
        * request shall be counted as a move from change-unaware to chang-aware pending.
        */
        pRec->changeAwareState = ATTS_CLIENT_CHANGE_AWARE_DB_READ_PENDING;
   1f280:	693b      	ldr	r3, [r7, #16]
   1f282:	2202      	movs	r2, #2
   1f284:	705a      	strb	r2, [r3, #1]

        ATT_TRACE_INFO2("ConnId %d change aware state is %d", handle + 1,
   1f286:	88fb      	ldrh	r3, [r7, #6]
   1f288:	3301      	adds	r3, #1
   1f28a:	2202      	movs	r2, #2
   1f28c:	4619      	mov	r1, r3
   1f28e:	480a      	ldr	r0, [pc, #40]	; (1f2b8 <attsCsfActClientState+0x124>)
   1f290:	f00e fb7e 	bl	2d990 <WsfTrace>
                        ATTS_CLIENT_CHANGE_AWARE_DB_READ_PENDING);
      }
    }
  }

  if (err == ATT_ERR_DATABASE_OUT_OF_SYNC)
   1f294:	7dfb      	ldrb	r3, [r7, #23]
   1f296:	2b12      	cmp	r3, #18
   1f298:	d106      	bne.n	1f2a8 <attsCsfActClientState+0x114>
  {
    ATT_TRACE_INFO2("ConnId %d out of sync, PDU with opcode 0x%02x ignored!", handle + 1, opcode);
   1f29a:	88fb      	ldrh	r3, [r7, #6]
   1f29c:	3301      	adds	r3, #1
   1f29e:	797a      	ldrb	r2, [r7, #5]
   1f2a0:	4619      	mov	r1, r3
   1f2a2:	4806      	ldr	r0, [pc, #24]	; (1f2bc <attsCsfActClientState+0x128>)
   1f2a4:	f00e fb74 	bl	2d990 <WsfTrace>
  }

  return err;
   1f2a8:	7dfb      	ldrb	r3, [r7, #23]
}
   1f2aa:	4618      	mov	r0, r3
   1f2ac:	3718      	adds	r7, #24
   1f2ae:	46bd      	mov	sp, r7
   1f2b0:	bd80      	pop	{r7, pc}
   1f2b2:	bf00      	nop
   1f2b4:	10011178 	.word	0x10011178
   1f2b8:	000448e8 	.word	0x000448e8
   1f2bc:	0004490c 	.word	0x0004490c

0001f2c0 <AttsCsfWriteFeatures>:
 *  \return \ref ATT_SUCCESS is successful, \ref ATT_ERR_VALUE_NOT_ALLOWED if any supported
 *          features are flipped from 1 to 0.
 */
/*************************************************************************************************/
uint8_t AttsCsfWriteFeatures(dmConnId_t connId, uint16_t offset, uint16_t valueLen, uint8_t *pValue)
{
   1f2c0:	b580      	push	{r7, lr}
   1f2c2:	b086      	sub	sp, #24
   1f2c4:	af00      	add	r7, sp, #0
   1f2c6:	607b      	str	r3, [r7, #4]
   1f2c8:	4603      	mov	r3, r0
   1f2ca:	73fb      	strb	r3, [r7, #15]
   1f2cc:	460b      	mov	r3, r1
   1f2ce:	81bb      	strh	r3, [r7, #12]
   1f2d0:	4613      	mov	r3, r2
   1f2d2:	817b      	strh	r3, [r7, #10]
  attsCsfRec_t *pCsfRec = &attsCsfCb.attsCsfTable[connId - 1];
   1f2d4:	7bfb      	ldrb	r3, [r7, #15]
   1f2d6:	3b01      	subs	r3, #1
   1f2d8:	005b      	lsls	r3, r3, #1
   1f2da:	4a19      	ldr	r2, [pc, #100]	; (1f340 <AttsCsfWriteFeatures+0x80>)
   1f2dc:	4413      	add	r3, r2
   1f2de:	617b      	str	r3, [r7, #20]
  /* future parameter in case the client supported features characteristic becomes a multi-octet
   * structure.
   */
  (void)offset;

  if (valueLen > ATT_CSF_LEN)
   1f2e0:	897b      	ldrh	r3, [r7, #10]
   1f2e2:	2b01      	cmp	r3, #1
   1f2e4:	d901      	bls.n	1f2ea <AttsCsfWriteFeatures+0x2a>
  {
    return ATT_ERR_LENGTH;
   1f2e6:	230d      	movs	r3, #13
   1f2e8:	e025      	b.n	1f336 <AttsCsfWriteFeatures+0x76>
  }

  /* A client can not clear any bits it has set. */
  if ((pCsfRec->csf & *pValue) < pCsfRec->csf)
   1f2ea:	697b      	ldr	r3, [r7, #20]
   1f2ec:	781a      	ldrb	r2, [r3, #0]
   1f2ee:	687b      	ldr	r3, [r7, #4]
   1f2f0:	781b      	ldrb	r3, [r3, #0]
   1f2f2:	4013      	ands	r3, r2
   1f2f4:	b2da      	uxtb	r2, r3
   1f2f6:	697b      	ldr	r3, [r7, #20]
   1f2f8:	781b      	ldrb	r3, [r3, #0]
   1f2fa:	429a      	cmp	r2, r3
   1f2fc:	d201      	bcs.n	1f302 <AttsCsfWriteFeatures+0x42>
  {
    return ATT_ERR_VALUE_NOT_ALLOWED;
   1f2fe:	2313      	movs	r3, #19
   1f300:	e019      	b.n	1f336 <AttsCsfWriteFeatures+0x76>
  }

  pCsfRec->csf = *pValue & ATTS_CSF_OCT0_FEATURES;
   1f302:	687b      	ldr	r3, [r7, #4]
   1f304:	781b      	ldrb	r3, [r3, #0]
   1f306:	f003 0301 	and.w	r3, r3, #1
   1f30a:	b2da      	uxtb	r2, r3
   1f30c:	697b      	ldr	r3, [r7, #20]
   1f30e:	701a      	strb	r2, [r3, #0]

  ATT_TRACE_INFO2("connId %d updated csf to 0x%02x", connId, pCsfRec->csf);
   1f310:	7bf9      	ldrb	r1, [r7, #15]
   1f312:	697b      	ldr	r3, [r7, #20]
   1f314:	781b      	ldrb	r3, [r3, #0]
   1f316:	461a      	mov	r2, r3
   1f318:	480a      	ldr	r0, [pc, #40]	; (1f344 <AttsCsfWriteFeatures+0x84>)
   1f31a:	f00e fb39 	bl	2d990 <WsfTrace>

  /* Callback to application to store updated features, if bonded. */
  if (attsCsfCb.writeCback != NULL)
   1f31e:	4b08      	ldr	r3, [pc, #32]	; (1f340 <AttsCsfWriteFeatures+0x80>)
   1f320:	689b      	ldr	r3, [r3, #8]
   1f322:	2b00      	cmp	r3, #0
   1f324:	d006      	beq.n	1f334 <AttsCsfWriteFeatures+0x74>
  {
    attsCsfCb.writeCback(connId, pCsfRec->changeAwareState, &pCsfRec->csf);
   1f326:	4b06      	ldr	r3, [pc, #24]	; (1f340 <AttsCsfWriteFeatures+0x80>)
   1f328:	689b      	ldr	r3, [r3, #8]
   1f32a:	697a      	ldr	r2, [r7, #20]
   1f32c:	7851      	ldrb	r1, [r2, #1]
   1f32e:	697a      	ldr	r2, [r7, #20]
   1f330:	7bf8      	ldrb	r0, [r7, #15]
   1f332:	4798      	blx	r3
  }

  return ATT_SUCCESS;
   1f334:	2300      	movs	r3, #0
}
   1f336:	4618      	mov	r0, r3
   1f338:	3718      	adds	r7, #24
   1f33a:	46bd      	mov	sp, r7
   1f33c:	bd80      	pop	{r7, pc}
   1f33e:	bf00      	nop
   1f340:	10011178 	.word	0x10011178
   1f344:	00044944 	.word	0x00044944

0001f348 <AttsCsfGetFeatures>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsCsfGetFeatures(dmConnId_t connId, uint8_t *pCsfOut, uint8_t pCsfOutLen)
{
   1f348:	b580      	push	{r7, lr}
   1f34a:	b082      	sub	sp, #8
   1f34c:	af00      	add	r7, sp, #0
   1f34e:	4603      	mov	r3, r0
   1f350:	6039      	str	r1, [r7, #0]
   1f352:	71fb      	strb	r3, [r7, #7]
   1f354:	4613      	mov	r3, r2
   1f356:	71bb      	strb	r3, [r7, #6]
  if (pCsfOutLen <= ATT_CSF_LEN)
   1f358:	79bb      	ldrb	r3, [r7, #6]
   1f35a:	2b01      	cmp	r3, #1
   1f35c:	d809      	bhi.n	1f372 <AttsCsfGetFeatures+0x2a>
  {
    memcpy(pCsfOut, &attsCsfCb.attsCsfTable[connId - 1].csf, pCsfOutLen);
   1f35e:	79fb      	ldrb	r3, [r7, #7]
   1f360:	3b01      	subs	r3, #1
   1f362:	005b      	lsls	r3, r3, #1
   1f364:	4a05      	ldr	r2, [pc, #20]	; (1f37c <AttsCsfGetFeatures+0x34>)
   1f366:	4413      	add	r3, r2
   1f368:	79ba      	ldrb	r2, [r7, #6]
   1f36a:	4619      	mov	r1, r3
   1f36c:	6838      	ldr	r0, [r7, #0]
   1f36e:	f7f8 ff71 	bl	18254 <memcpy>
  }
}
   1f372:	bf00      	nop
   1f374:	3708      	adds	r7, #8
   1f376:	46bd      	mov	sp, r7
   1f378:	bd80      	pop	{r7, pc}
   1f37a:	bf00      	nop
   1f37c:	10011178 	.word	0x10011178

0001f380 <attsIndCcbByConnId>:
 *
 *  \return Pointer to connection control block or NULL if not in use.
 */
/*************************************************************************************************/
static attsIndCcb_t *attsIndCcbByConnId(dmConnId_t connId)
{
   1f380:	b580      	push	{r7, lr}
   1f382:	b082      	sub	sp, #8
   1f384:	af00      	add	r7, sp, #0
   1f386:	4603      	mov	r3, r0
   1f388:	71fb      	strb	r3, [r7, #7]
  if (DmConnInUse(connId))
   1f38a:	79fb      	ldrb	r3, [r7, #7]
   1f38c:	4618      	mov	r0, r3
   1f38e:	f004 f89b 	bl	234c8 <DmConnInUse>
   1f392:	4603      	mov	r3, r0
   1f394:	2b00      	cmp	r3, #0
   1f396:	d008      	beq.n	1f3aa <attsIndCcbByConnId+0x2a>
  {
    return &attsIndCb.ccb[connId - 1];
   1f398:	79fb      	ldrb	r3, [r7, #7]
   1f39a:	1e5a      	subs	r2, r3, #1
   1f39c:	4613      	mov	r3, r2
   1f39e:	00db      	lsls	r3, r3, #3
   1f3a0:	1a9b      	subs	r3, r3, r2
   1f3a2:	009b      	lsls	r3, r3, #2
   1f3a4:	4a06      	ldr	r2, [pc, #24]	; (1f3c0 <attsIndCcbByConnId+0x40>)
   1f3a6:	4413      	add	r3, r2
   1f3a8:	e005      	b.n	1f3b6 <attsIndCcbByConnId+0x36>
  }
  else
  {
    ATT_TRACE_WARN1("atts ccb not in use: %d", connId);
   1f3aa:	79fb      	ldrb	r3, [r7, #7]
   1f3ac:	4619      	mov	r1, r3
   1f3ae:	4805      	ldr	r0, [pc, #20]	; (1f3c4 <attsIndCcbByConnId+0x44>)
   1f3b0:	f00e faee 	bl	2d990 <WsfTrace>
    return NULL;
   1f3b4:	2300      	movs	r3, #0
  }
}
   1f3b6:	4618      	mov	r0, r3
   1f3b8:	3708      	adds	r7, #8
   1f3ba:	46bd      	mov	sp, r7
   1f3bc:	bd80      	pop	{r7, pc}
   1f3be:	bf00      	nop
   1f3c0:	10011188 	.word	0x10011188
   1f3c4:	00044964 	.word	0x00044964

0001f3c8 <attsPendIndNtfHandle>:
 *  \return TRUE if app callback's pending or max number of simultaneous notifications reached.
 *          FALSE, otherwise.
 */
/*************************************************************************************************/
static bool_t attsPendIndNtfHandle(attsIndCcb_t *pCcb, attsPktParam_t *pPkt)
{
   1f3c8:	b480      	push	{r7}
   1f3ca:	b085      	sub	sp, #20
   1f3cc:	af00      	add	r7, sp, #0
   1f3ce:	6078      	str	r0, [r7, #4]
   1f3d0:	6039      	str	r1, [r7, #0]
  uint8_t     opcode;
  uint8_t     pendNtfs;
  uint8_t     i;

  /* extract opcode */
  opcode = *(((uint8_t *) pPkt) + L2C_PAYLOAD_START);
   1f3d2:	683b      	ldr	r3, [r7, #0]
   1f3d4:	7a1b      	ldrb	r3, [r3, #8]
   1f3d6:	737b      	strb	r3, [r7, #13]

  /* if indication */
  if (opcode == ATT_PDU_VALUE_IND)
   1f3d8:	7b7b      	ldrb	r3, [r7, #13]
   1f3da:	2b1d      	cmp	r3, #29
   1f3dc:	d107      	bne.n	1f3ee <attsPendIndNtfHandle+0x26>
  {
    /* see if callback pending for indication */
    return (pCcb->pendIndHandle == ATT_HANDLE_NONE) ? FALSE : TRUE;
   1f3de:	687b      	ldr	r3, [r7, #4]
   1f3e0:	8adb      	ldrh	r3, [r3, #22]
   1f3e2:	2b00      	cmp	r3, #0
   1f3e4:	bf14      	ite	ne
   1f3e6:	2301      	movne	r3, #1
   1f3e8:	2300      	moveq	r3, #0
   1f3ea:	b2db      	uxtb	r3, r3
   1f3ec:	e025      	b.n	1f43a <attsPendIndNtfHandle+0x72>
  }

  /* initialize number of notification callbacks pending */
  pendNtfs = 0;
   1f3ee:	2300      	movs	r3, #0
   1f3f0:	73fb      	strb	r3, [r7, #15]

  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f3f2:	2300      	movs	r3, #0
   1f3f4:	73bb      	strb	r3, [r7, #14]
   1f3f6:	e017      	b.n	1f428 <attsPendIndNtfHandle+0x60>
  {
    /* if callback pending for notification */
    if (pCcb->pendNtfHandle[i] != ATT_HANDLE_NONE)
   1f3f8:	7bba      	ldrb	r2, [r7, #14]
   1f3fa:	687b      	ldr	r3, [r7, #4]
   1f3fc:	320c      	adds	r2, #12
   1f3fe:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   1f402:	2b00      	cmp	r3, #0
   1f404:	d00d      	beq.n	1f422 <attsPendIndNtfHandle+0x5a>
    {
      /* if callback pending for this handle */
      if (pCcb->pendNtfHandle[i] == pPkt->handle)
   1f406:	7bba      	ldrb	r2, [r7, #14]
   1f408:	687b      	ldr	r3, [r7, #4]
   1f40a:	320c      	adds	r2, #12
   1f40c:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
   1f410:	683b      	ldr	r3, [r7, #0]
   1f412:	885b      	ldrh	r3, [r3, #2]
   1f414:	429a      	cmp	r2, r3
   1f416:	d101      	bne.n	1f41c <attsPendIndNtfHandle+0x54>
      {
        /* callback pending for this notification */
        return TRUE;
   1f418:	2301      	movs	r3, #1
   1f41a:	e00e      	b.n	1f43a <attsPendIndNtfHandle+0x72>
      }

      pendNtfs++;
   1f41c:	7bfb      	ldrb	r3, [r7, #15]
   1f41e:	3301      	adds	r3, #1
   1f420:	73fb      	strb	r3, [r7, #15]
  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f422:	7bbb      	ldrb	r3, [r7, #14]
   1f424:	3301      	adds	r3, #1
   1f426:	73bb      	strb	r3, [r7, #14]
   1f428:	7bbb      	ldrb	r3, [r7, #14]
   1f42a:	2b00      	cmp	r3, #0
   1f42c:	d0e4      	beq.n	1f3f8 <attsPendIndNtfHandle+0x30>
    }
  }

  /* no callback is pending for this notification but see if the maximum number of simultaneous
     notifications has been reached */
  return (pendNtfs < ATT_NUM_SIMUL_NTF) ? FALSE : TRUE;
   1f42e:	7bfb      	ldrb	r3, [r7, #15]
   1f430:	2b00      	cmp	r3, #0
   1f432:	bf14      	ite	ne
   1f434:	2301      	movne	r3, #1
   1f436:	2300      	moveq	r3, #0
   1f438:	b2db      	uxtb	r3, r3
}
   1f43a:	4618      	mov	r0, r3
   1f43c:	3714      	adds	r7, #20
   1f43e:	46bd      	mov	sp, r7
   1f440:	f85d 7b04 	ldr.w	r7, [sp], #4
   1f444:	4770      	bx	lr

0001f446 <attsSetPendNtfHandle>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsSetPendNtfHandle(attsIndCcb_t *pCcb, uint16_t handle)
{
   1f446:	b480      	push	{r7}
   1f448:	b085      	sub	sp, #20
   1f44a:	af00      	add	r7, sp, #0
   1f44c:	6078      	str	r0, [r7, #4]
   1f44e:	460b      	mov	r3, r1
   1f450:	807b      	strh	r3, [r7, #2]
  uint8_t     i;

  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f452:	2300      	movs	r3, #0
   1f454:	73fb      	strb	r3, [r7, #15]
   1f456:	e010      	b.n	1f47a <attsSetPendNtfHandle+0x34>
  {
    /* if entry free */
    if (pCcb->pendNtfHandle[i] == ATT_HANDLE_NONE)
   1f458:	7bfa      	ldrb	r2, [r7, #15]
   1f45a:	687b      	ldr	r3, [r7, #4]
   1f45c:	320c      	adds	r2, #12
   1f45e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   1f462:	2b00      	cmp	r3, #0
   1f464:	d106      	bne.n	1f474 <attsSetPendNtfHandle+0x2e>
    {
      /* set pending notification handle */
      pCcb->pendNtfHandle[i] = handle;
   1f466:	7bfa      	ldrb	r2, [r7, #15]
   1f468:	687b      	ldr	r3, [r7, #4]
   1f46a:	320c      	adds	r2, #12
   1f46c:	8879      	ldrh	r1, [r7, #2]
   1f46e:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
      break;
   1f472:	e006      	b.n	1f482 <attsSetPendNtfHandle+0x3c>
  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f474:	7bfb      	ldrb	r3, [r7, #15]
   1f476:	3301      	adds	r3, #1
   1f478:	73fb      	strb	r3, [r7, #15]
   1f47a:	7bfb      	ldrb	r3, [r7, #15]
   1f47c:	2b00      	cmp	r3, #0
   1f47e:	d0eb      	beq.n	1f458 <attsSetPendNtfHandle+0x12>
    }
  }
}
   1f480:	bf00      	nop
   1f482:	bf00      	nop
   1f484:	3714      	adds	r7, #20
   1f486:	46bd      	mov	sp, r7
   1f488:	f85d 7b04 	ldr.w	r7, [sp], #4
   1f48c:	4770      	bx	lr

0001f48e <attsExecCallback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsExecCallback(dmConnId_t connId, uint16_t handle, uint8_t status)
{
   1f48e:	b580      	push	{r7, lr}
   1f490:	b084      	sub	sp, #16
   1f492:	af02      	add	r7, sp, #8
   1f494:	4603      	mov	r3, r0
   1f496:	71fb      	strb	r3, [r7, #7]
   1f498:	460b      	mov	r3, r1
   1f49a:	80bb      	strh	r3, [r7, #4]
   1f49c:	4613      	mov	r3, r2
   1f49e:	71bb      	strb	r3, [r7, #6]
  attExecCallback(connId, ATTS_HANDLE_VALUE_CNF, handle, status, 0);
   1f4a0:	79bb      	ldrb	r3, [r7, #6]
   1f4a2:	88ba      	ldrh	r2, [r7, #4]
   1f4a4:	79f8      	ldrb	r0, [r7, #7]
   1f4a6:	2100      	movs	r1, #0
   1f4a8:	9100      	str	r1, [sp, #0]
   1f4aa:	210f      	movs	r1, #15
   1f4ac:	f7fe fa6e 	bl	1d98c <attExecCallback>
}
   1f4b0:	bf00      	nop
   1f4b2:	3708      	adds	r7, #8
   1f4b4:	46bd      	mov	sp, r7
   1f4b6:	bd80      	pop	{r7, pc}

0001f4b8 <attsIndNtfCallback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsIndNtfCallback(dmConnId_t connId, attsIndCcb_t *pCcb, uint8_t status)
{
   1f4b8:	b580      	push	{r7, lr}
   1f4ba:	b084      	sub	sp, #16
   1f4bc:	af00      	add	r7, sp, #0
   1f4be:	4603      	mov	r3, r0
   1f4c0:	6039      	str	r1, [r7, #0]
   1f4c2:	71fb      	strb	r3, [r7, #7]
   1f4c4:	4613      	mov	r3, r2
   1f4c6:	71bb      	strb	r3, [r7, #6]
  uint8_t     i;

  /* if pending indication callback */
  if (pCcb->pendIndHandle != ATT_HANDLE_NONE)
   1f4c8:	683b      	ldr	r3, [r7, #0]
   1f4ca:	8adb      	ldrh	r3, [r3, #22]
   1f4cc:	2b00      	cmp	r3, #0
   1f4ce:	d009      	beq.n	1f4e4 <attsIndNtfCallback+0x2c>
  {
    /* call indication callback with status */
    attsExecCallback(connId, pCcb->pendIndHandle, status);
   1f4d0:	683b      	ldr	r3, [r7, #0]
   1f4d2:	8ad9      	ldrh	r1, [r3, #22]
   1f4d4:	79ba      	ldrb	r2, [r7, #6]
   1f4d6:	79fb      	ldrb	r3, [r7, #7]
   1f4d8:	4618      	mov	r0, r3
   1f4da:	f7ff ffd8 	bl	1f48e <attsExecCallback>
    pCcb->pendIndHandle = ATT_HANDLE_NONE;
   1f4de:	683b      	ldr	r3, [r7, #0]
   1f4e0:	2200      	movs	r2, #0
   1f4e2:	82da      	strh	r2, [r3, #22]
  }

  /* if any pending notification callback */
  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f4e4:	2300      	movs	r3, #0
   1f4e6:	73fb      	strb	r3, [r7, #15]
   1f4e8:	e019      	b.n	1f51e <attsIndNtfCallback+0x66>
  {
    if (pCcb->pendNtfHandle[i] != ATT_HANDLE_NONE)
   1f4ea:	7bfa      	ldrb	r2, [r7, #15]
   1f4ec:	683b      	ldr	r3, [r7, #0]
   1f4ee:	320c      	adds	r2, #12
   1f4f0:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   1f4f4:	2b00      	cmp	r3, #0
   1f4f6:	d00f      	beq.n	1f518 <attsIndNtfCallback+0x60>
    {
      /* call notification callback with status */
      attsExecCallback(connId, pCcb->pendNtfHandle[i], status);
   1f4f8:	7bfa      	ldrb	r2, [r7, #15]
   1f4fa:	683b      	ldr	r3, [r7, #0]
   1f4fc:	320c      	adds	r2, #12
   1f4fe:	f833 1012 	ldrh.w	r1, [r3, r2, lsl #1]
   1f502:	79ba      	ldrb	r2, [r7, #6]
   1f504:	79fb      	ldrb	r3, [r7, #7]
   1f506:	4618      	mov	r0, r3
   1f508:	f7ff ffc1 	bl	1f48e <attsExecCallback>
      pCcb->pendNtfHandle[i] = ATT_HANDLE_NONE;
   1f50c:	7bfa      	ldrb	r2, [r7, #15]
   1f50e:	683b      	ldr	r3, [r7, #0]
   1f510:	320c      	adds	r2, #12
   1f512:	2100      	movs	r1, #0
   1f514:	f823 1012 	strh.w	r1, [r3, r2, lsl #1]
  for (i = 0; i < ATT_NUM_SIMUL_NTF; i++)
   1f518:	7bfb      	ldrb	r3, [r7, #15]
   1f51a:	3301      	adds	r3, #1
   1f51c:	73fb      	strb	r3, [r7, #15]
   1f51e:	7bfb      	ldrb	r3, [r7, #15]
   1f520:	2b00      	cmp	r3, #0
   1f522:	d0e2      	beq.n	1f4ea <attsIndNtfCallback+0x32>
    }
  }
}
   1f524:	bf00      	nop
   1f526:	bf00      	nop
   1f528:	3710      	adds	r7, #16
   1f52a:	46bd      	mov	sp, r7
   1f52c:	bd80      	pop	{r7, pc}
	...

0001f530 <attsSetupMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsSetupMsg(attsIndCcb_t *pCcb, dmConnId_t connId, attsPktParam_t *pPkt)
{
   1f530:	b580      	push	{r7, lr}
   1f532:	b086      	sub	sp, #24
   1f534:	af00      	add	r7, sp, #0
   1f536:	60f8      	str	r0, [r7, #12]
   1f538:	460b      	mov	r3, r1
   1f53a:	607a      	str	r2, [r7, #4]
   1f53c:	72fb      	strb	r3, [r7, #11]
  uint8_t     opcode;
  uint16_t    handle;

  /* extract opcode */
  opcode = *(((uint8_t *) pPkt) + L2C_PAYLOAD_START);
   1f53e:	687b      	ldr	r3, [r7, #4]
   1f540:	7a1b      	ldrb	r3, [r3, #8]
   1f542:	75fb      	strb	r3, [r7, #23]

  /* copy handle (it may be overwritten in pPkt) */
  handle = pPkt->handle;
   1f544:	687b      	ldr	r3, [r7, #4]
   1f546:	885b      	ldrh	r3, [r3, #2]
   1f548:	82bb      	strh	r3, [r7, #20]

  /* send pdu */
  L2cDataReq(L2C_CID_ATT, pCcb->pMainCcb->handle, pPkt->len, (uint8_t *) pPkt);
   1f54a:	68fb      	ldr	r3, [r7, #12]
   1f54c:	691b      	ldr	r3, [r3, #16]
   1f54e:	8b19      	ldrh	r1, [r3, #24]
   1f550:	687b      	ldr	r3, [r7, #4]
   1f552:	881a      	ldrh	r2, [r3, #0]
   1f554:	687b      	ldr	r3, [r7, #4]
   1f556:	2004      	movs	r0, #4
   1f558:	f00a fcc6 	bl	29ee8 <L2cDataReq>

  /* if indication store handle and start timer */
  if (opcode == ATT_PDU_VALUE_IND)
   1f55c:	7dfb      	ldrb	r3, [r7, #23]
   1f55e:	2b1d      	cmp	r3, #29
   1f560:	d112      	bne.n	1f588 <attsSetupMsg+0x58>
  {
    pCcb->outIndHandle = pCcb->pendIndHandle = handle;
   1f562:	68fb      	ldr	r3, [r7, #12]
   1f564:	8aba      	ldrh	r2, [r7, #20]
   1f566:	82da      	strh	r2, [r3, #22]
   1f568:	68fb      	ldr	r3, [r7, #12]
   1f56a:	8ada      	ldrh	r2, [r3, #22]
   1f56c:	68fb      	ldr	r3, [r7, #12]
   1f56e:	829a      	strh	r2, [r3, #20]
    pCcb->outIndTimer.msg.event = ATTS_MSG_IND_TIMEOUT;
   1f570:	68fb      	ldr	r3, [r7, #12]
   1f572:	2222      	movs	r2, #34	; 0x22
   1f574:	729a      	strb	r2, [r3, #10]
    WsfTimerStartSec(&pCcb->outIndTimer, pAttCfg->transTimeout);
   1f576:	68fa      	ldr	r2, [r7, #12]
   1f578:	4b0f      	ldr	r3, [pc, #60]	; (1f5b8 <attsSetupMsg+0x88>)
   1f57a:	681b      	ldr	r3, [r3, #0]
   1f57c:	799b      	ldrb	r3, [r3, #6]
   1f57e:	4619      	mov	r1, r3
   1f580:	4610      	mov	r0, r2
   1f582:	f00e f933 	bl	2d7ec <WsfTimerStartSec>
  /* else set pending notification callback for this handle */
  else
  {
    attsSetPendNtfHandle(pCcb, handle);
  }
}
   1f586:	e012      	b.n	1f5ae <attsSetupMsg+0x7e>
  else if (!(pCcb->pMainCcb->control & ATT_CCB_STATUS_FLOW_DISABLED))
   1f588:	68fb      	ldr	r3, [r7, #12]
   1f58a:	691b      	ldr	r3, [r3, #16]
   1f58c:	7f5b      	ldrb	r3, [r3, #29]
   1f58e:	f003 0302 	and.w	r3, r3, #2
   1f592:	2b00      	cmp	r3, #0
   1f594:	d106      	bne.n	1f5a4 <attsSetupMsg+0x74>
    attsExecCallback(connId, handle, ATT_SUCCESS);
   1f596:	8ab9      	ldrh	r1, [r7, #20]
   1f598:	7afb      	ldrb	r3, [r7, #11]
   1f59a:	2200      	movs	r2, #0
   1f59c:	4618      	mov	r0, r3
   1f59e:	f7ff ff76 	bl	1f48e <attsExecCallback>
}
   1f5a2:	e004      	b.n	1f5ae <attsSetupMsg+0x7e>
    attsSetPendNtfHandle(pCcb, handle);
   1f5a4:	8abb      	ldrh	r3, [r7, #20]
   1f5a6:	4619      	mov	r1, r3
   1f5a8:	68f8      	ldr	r0, [r7, #12]
   1f5aa:	f7ff ff4c 	bl	1f446 <attsSetPendNtfHandle>
}
   1f5ae:	bf00      	nop
   1f5b0:	3718      	adds	r7, #24
   1f5b2:	46bd      	mov	sp, r7
   1f5b4:	bd80      	pop	{r7, pc}
   1f5b6:	bf00      	nop
   1f5b8:	10002b8c 	.word	0x10002b8c

0001f5bc <attsIndConnCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsIndConnCback(attCcb_t *pCcb, dmEvt_t *pDmEvt)
{
   1f5bc:	b580      	push	{r7, lr}
   1f5be:	b084      	sub	sp, #16
   1f5c0:	af00      	add	r7, sp, #0
   1f5c2:	6078      	str	r0, [r7, #4]
   1f5c4:	6039      	str	r1, [r7, #0]
  attsIndCcb_t *pIndCcb;
  uint8_t      status;

  /* if connection opened */
  if (pDmEvt->hdr.event == DM_CONN_OPEN_IND)
   1f5c6:	683b      	ldr	r3, [r7, #0]
   1f5c8:	789b      	ldrb	r3, [r3, #2]
   1f5ca:	2b27      	cmp	r3, #39	; 0x27
   1f5cc:	d02c      	beq.n	1f628 <attsIndConnCback+0x6c>
  {

  }
  /* if connection closed */
  else if (pDmEvt->hdr.event == DM_CONN_CLOSE_IND)
   1f5ce:	683b      	ldr	r3, [r7, #0]
   1f5d0:	789b      	ldrb	r3, [r3, #2]
   1f5d2:	2b28      	cmp	r3, #40	; 0x28
   1f5d4:	d128      	bne.n	1f628 <attsIndConnCback+0x6c>
  {
    /* set status */
    if (pDmEvt->connClose.hdr.status == HCI_SUCCESS)
   1f5d6:	683b      	ldr	r3, [r7, #0]
   1f5d8:	78db      	ldrb	r3, [r3, #3]
   1f5da:	2b00      	cmp	r3, #0
   1f5dc:	d104      	bne.n	1f5e8 <attsIndConnCback+0x2c>
    {
      status = pDmEvt->connClose.reason + ATT_HCI_ERR_BASE;
   1f5de:	683b      	ldr	r3, [r7, #0]
   1f5e0:	7a1b      	ldrb	r3, [r3, #8]
   1f5e2:	3b60      	subs	r3, #96	; 0x60
   1f5e4:	73fb      	strb	r3, [r7, #15]
   1f5e6:	e003      	b.n	1f5f0 <attsIndConnCback+0x34>
    }
    else
    {
      status = pDmEvt->connClose.hdr.status + ATT_HCI_ERR_BASE;
   1f5e8:	683b      	ldr	r3, [r7, #0]
   1f5ea:	78db      	ldrb	r3, [r3, #3]
   1f5ec:	3b60      	subs	r3, #96	; 0x60
   1f5ee:	73fb      	strb	r3, [r7, #15]
    }

    /* get server control block directly */
    pIndCcb = &attsIndCb.ccb[pCcb->connId - 1];
   1f5f0:	687b      	ldr	r3, [r7, #4]
   1f5f2:	7f1b      	ldrb	r3, [r3, #28]
   1f5f4:	1e5a      	subs	r2, r3, #1
   1f5f6:	4613      	mov	r3, r2
   1f5f8:	00db      	lsls	r3, r3, #3
   1f5fa:	1a9b      	subs	r3, r3, r2
   1f5fc:	009b      	lsls	r3, r3, #2
   1f5fe:	4a0c      	ldr	r2, [pc, #48]	; (1f630 <attsIndConnCback+0x74>)
   1f600:	4413      	add	r3, r2
   1f602:	60bb      	str	r3, [r7, #8]

    /* if outstanding indication */
    if (pIndCcb->outIndHandle != ATT_HANDLE_NONE)
   1f604:	68bb      	ldr	r3, [r7, #8]
   1f606:	8a9b      	ldrh	r3, [r3, #20]
   1f608:	2b00      	cmp	r3, #0
   1f60a:	d006      	beq.n	1f61a <attsIndConnCback+0x5e>
    {
      /* stop timer */
      WsfTimerStop(&pIndCcb->outIndTimer);
   1f60c:	68bb      	ldr	r3, [r7, #8]
   1f60e:	4618      	mov	r0, r3
   1f610:	f00e f912 	bl	2d838 <WsfTimerStop>
      pIndCcb->outIndHandle = ATT_HANDLE_NONE;
   1f614:	68bb      	ldr	r3, [r7, #8]
   1f616:	2200      	movs	r2, #0
   1f618:	829a      	strh	r2, [r3, #20]
    }

    /* call pending indication and notification callback */
    attsIndNtfCallback(pCcb->connId, pIndCcb, status);
   1f61a:	687b      	ldr	r3, [r7, #4]
   1f61c:	7f1b      	ldrb	r3, [r3, #28]
   1f61e:	7bfa      	ldrb	r2, [r7, #15]
   1f620:	68b9      	ldr	r1, [r7, #8]
   1f622:	4618      	mov	r0, r3
   1f624:	f7ff ff48 	bl	1f4b8 <attsIndNtfCallback>
  }
}
   1f628:	bf00      	nop
   1f62a:	3710      	adds	r7, #16
   1f62c:	46bd      	mov	sp, r7
   1f62e:	bd80      	pop	{r7, pc}
   1f630:	10011188 	.word	0x10011188

0001f634 <attsIndMsgCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsIndMsgCback(attsApiMsg_t *pMsg)
{
   1f634:	b580      	push	{r7, lr}
   1f636:	b084      	sub	sp, #16
   1f638:	af00      	add	r7, sp, #0
   1f63a:	6078      	str	r0, [r7, #4]
  attsIndCcb_t   *pCcb;

  /* get CCB and verify connection still in use */
  if ((pCcb = attsIndCcbByConnId((dmConnId_t) pMsg->hdr.param)) == NULL)
   1f63c:	687b      	ldr	r3, [r7, #4]
   1f63e:	881b      	ldrh	r3, [r3, #0]
   1f640:	b2db      	uxtb	r3, r3
   1f642:	4618      	mov	r0, r3
   1f644:	f7ff fe9c 	bl	1f380 <attsIndCcbByConnId>
   1f648:	60f8      	str	r0, [r7, #12]
   1f64a:	68fb      	ldr	r3, [r7, #12]
   1f64c:	2b00      	cmp	r3, #0
   1f64e:	d109      	bne.n	1f664 <attsIndMsgCback+0x30>
  {
    /* if message has a packet buffer free packet buffer */
    if (pMsg->hdr.event == ATTS_MSG_API_VALUE_IND_NTF)
   1f650:	687b      	ldr	r3, [r7, #4]
   1f652:	789b      	ldrb	r3, [r3, #2]
   1f654:	2b21      	cmp	r3, #33	; 0x21
   1f656:	d14d      	bne.n	1f6f4 <attsIndMsgCback+0xc0>
    {
      WsfMsgFree(pMsg->pPkt);
   1f658:	687b      	ldr	r3, [r7, #4]
   1f65a:	685b      	ldr	r3, [r3, #4]
   1f65c:	4618      	mov	r0, r3
   1f65e:	f00d fd3d 	bl	2d0dc <WsfMsgFree>
    }

    /* ignore if connection not in use */
    return;
   1f662:	e047      	b.n	1f6f4 <attsIndMsgCback+0xc0>
  }

  /* if an API message to send packet */
  if (pMsg->hdr.event == ATTS_MSG_API_VALUE_IND_NTF)
   1f664:	687b      	ldr	r3, [r7, #4]
   1f666:	789b      	ldrb	r3, [r3, #2]
   1f668:	2b21      	cmp	r3, #33	; 0x21
   1f66a:	d122      	bne.n	1f6b2 <attsIndMsgCback+0x7e>
  {
    /* verify no API message already pending */
    if (attsPendIndNtfHandle(pCcb, pMsg->pPkt))
   1f66c:	687b      	ldr	r3, [r7, #4]
   1f66e:	685b      	ldr	r3, [r3, #4]
   1f670:	4619      	mov	r1, r3
   1f672:	68f8      	ldr	r0, [r7, #12]
   1f674:	f7ff fea8 	bl	1f3c8 <attsPendIndNtfHandle>
   1f678:	4603      	mov	r3, r0
   1f67a:	2b00      	cmp	r3, #0
   1f67c:	d00f      	beq.n	1f69e <attsIndMsgCback+0x6a>
    {
      /* call callback with failure status and free packet buffer */
      attsExecCallback((dmConnId_t) pMsg->hdr.param, pMsg->pPkt->handle, ATT_ERR_OVERFLOW);
   1f67e:	687b      	ldr	r3, [r7, #4]
   1f680:	881b      	ldrh	r3, [r3, #0]
   1f682:	b2d8      	uxtb	r0, r3
   1f684:	687b      	ldr	r3, [r7, #4]
   1f686:	685b      	ldr	r3, [r3, #4]
   1f688:	885b      	ldrh	r3, [r3, #2]
   1f68a:	2272      	movs	r2, #114	; 0x72
   1f68c:	4619      	mov	r1, r3
   1f68e:	f7ff fefe 	bl	1f48e <attsExecCallback>
      WsfMsgFree(pMsg->pPkt);
   1f692:	687b      	ldr	r3, [r7, #4]
   1f694:	685b      	ldr	r3, [r3, #4]
   1f696:	4618      	mov	r0, r3
   1f698:	f00d fd20 	bl	2d0dc <WsfMsgFree>
   1f69c:	e02b      	b.n	1f6f6 <attsIndMsgCback+0xc2>
    }
    /* otherwise ready to send; set up request */
    else
    {
      attsSetupMsg(pCcb, (dmConnId_t) pMsg->hdr.param, pMsg->pPkt);
   1f69e:	687b      	ldr	r3, [r7, #4]
   1f6a0:	881b      	ldrh	r3, [r3, #0]
   1f6a2:	b2d9      	uxtb	r1, r3
   1f6a4:	687b      	ldr	r3, [r7, #4]
   1f6a6:	685b      	ldr	r3, [r3, #4]
   1f6a8:	461a      	mov	r2, r3
   1f6aa:	68f8      	ldr	r0, [r7, #12]
   1f6ac:	f7ff ff40 	bl	1f530 <attsSetupMsg>
   1f6b0:	e021      	b.n	1f6f6 <attsIndMsgCback+0xc2>
    }
  }
  /* else if indication timeout */
  else if (pMsg->hdr.event == ATTS_MSG_IND_TIMEOUT)
   1f6b2:	687b      	ldr	r3, [r7, #4]
   1f6b4:	789b      	ldrb	r3, [r3, #2]
   1f6b6:	2b22      	cmp	r3, #34	; 0x22
   1f6b8:	d11d      	bne.n	1f6f6 <attsIndMsgCback+0xc2>
  {
    /* if outstanding indication */
    if (pCcb->outIndHandle != ATT_HANDLE_NONE)
   1f6ba:	68fb      	ldr	r3, [r7, #12]
   1f6bc:	8a9b      	ldrh	r3, [r3, #20]
   1f6be:	2b00      	cmp	r3, #0
   1f6c0:	d019      	beq.n	1f6f6 <attsIndMsgCback+0xc2>
    {
      /* clear out handle */
      pCcb->outIndHandle = ATT_HANDLE_NONE;
   1f6c2:	68fb      	ldr	r3, [r7, #12]
   1f6c4:	2200      	movs	r2, #0
   1f6c6:	829a      	strh	r2, [r3, #20]

      /* call callback with timeout error */
      attsExecCallback((dmConnId_t) pMsg->hdr.param, pCcb->pendIndHandle, ATT_ERR_TIMEOUT);
   1f6c8:	687b      	ldr	r3, [r7, #4]
   1f6ca:	881b      	ldrh	r3, [r3, #0]
   1f6cc:	b2d8      	uxtb	r0, r3
   1f6ce:	68fb      	ldr	r3, [r7, #12]
   1f6d0:	8adb      	ldrh	r3, [r3, #22]
   1f6d2:	2271      	movs	r2, #113	; 0x71
   1f6d4:	4619      	mov	r1, r3
   1f6d6:	f7ff feda 	bl	1f48e <attsExecCallback>
      pCcb->pendIndHandle = ATT_HANDLE_NONE;
   1f6da:	68fb      	ldr	r3, [r7, #12]
   1f6dc:	2200      	movs	r2, #0
   1f6de:	82da      	strh	r2, [r3, #22]
      pCcb->pMainCcb->control |= ATT_CCB_STATUS_TX_TIMEOUT;
   1f6e0:	68fb      	ldr	r3, [r7, #12]
   1f6e2:	691b      	ldr	r3, [r3, #16]
   1f6e4:	7f5a      	ldrb	r2, [r3, #29]
   1f6e6:	68fb      	ldr	r3, [r7, #12]
   1f6e8:	691b      	ldr	r3, [r3, #16]
   1f6ea:	f042 0204 	orr.w	r2, r2, #4
   1f6ee:	b2d2      	uxtb	r2, r2
   1f6f0:	775a      	strb	r2, [r3, #29]
   1f6f2:	e000      	b.n	1f6f6 <attsIndMsgCback+0xc2>
    return;
   1f6f4:	bf00      	nop
    }
  }
}
   1f6f6:	3710      	adds	r7, #16
   1f6f8:	46bd      	mov	sp, r7
   1f6fa:	bd80      	pop	{r7, pc}

0001f6fc <attsIndCtrlCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsIndCtrlCback(wsfMsgHdr_t *pMsg)
{
   1f6fc:	b580      	push	{r7, lr}
   1f6fe:	b084      	sub	sp, #16
   1f700:	af00      	add	r7, sp, #0
   1f702:	6078      	str	r0, [r7, #4]
  attsIndCcb_t   *pCcb;

  /* note this function is currently only called when flow is enabled */

  /* get CCB */
  if ((pCcb = attsIndCcbByConnId((dmConnId_t) pMsg->param)) != NULL)
   1f704:	687b      	ldr	r3, [r7, #4]
   1f706:	881b      	ldrh	r3, [r3, #0]
   1f708:	b2db      	uxtb	r3, r3
   1f70a:	4618      	mov	r0, r3
   1f70c:	f7ff fe38 	bl	1f380 <attsIndCcbByConnId>
   1f710:	60f8      	str	r0, [r7, #12]
   1f712:	68fb      	ldr	r3, [r7, #12]
   1f714:	2b00      	cmp	r3, #0
   1f716:	d007      	beq.n	1f728 <attsIndCtrlCback+0x2c>
  {
    /* call pending indication and notification callback */
    attsIndNtfCallback((dmConnId_t) pMsg->param, pCcb, ATT_SUCCESS);
   1f718:	687b      	ldr	r3, [r7, #4]
   1f71a:	881b      	ldrh	r3, [r3, #0]
   1f71c:	b2db      	uxtb	r3, r3
   1f71e:	2200      	movs	r2, #0
   1f720:	68f9      	ldr	r1, [r7, #12]
   1f722:	4618      	mov	r0, r3
   1f724:	f7ff fec8 	bl	1f4b8 <attsIndNtfCallback>
  }
}
   1f728:	bf00      	nop
   1f72a:	3710      	adds	r7, #16
   1f72c:	46bd      	mov	sp, r7
   1f72e:	bd80      	pop	{r7, pc}

0001f730 <attsHandleValueIndNtf>:
 *  \return None.
 */
/*************************************************************************************************/
static void attsHandleValueIndNtf(dmConnId_t connId, uint16_t handle, uint16_t valueLen,
                                  uint8_t *pValue, uint8_t opcode, bool_t zeroCpy)
{
   1f730:	b580      	push	{r7, lr}
   1f732:	b088      	sub	sp, #32
   1f734:	af00      	add	r7, sp, #0
   1f736:	607b      	str	r3, [r7, #4]
   1f738:	4603      	mov	r3, r0
   1f73a:	73fb      	strb	r3, [r7, #15]
   1f73c:	460b      	mov	r3, r1
   1f73e:	81bb      	strh	r3, [r7, #12]
   1f740:	4613      	mov	r3, r2
   1f742:	817b      	strh	r3, [r7, #10]
  attsIndCcb_t   *pCcb;
  uint16_t       mtu;
  bool_t         transTimedOut;
  bool_t         pktSent = FALSE;
   1f744:	2300      	movs	r3, #0
   1f746:	773b      	strb	r3, [r7, #28]

  WsfTaskLock();
   1f748:	f00d fd5c 	bl	2d204 <WsfTaskLock>

  /* get CCB and verify connection still in use */
  if ((pCcb = attsIndCcbByConnId(connId)) != NULL)
   1f74c:	7bfb      	ldrb	r3, [r7, #15]
   1f74e:	4618      	mov	r0, r3
   1f750:	f7ff fe16 	bl	1f380 <attsIndCcbByConnId>
   1f754:	61b8      	str	r0, [r7, #24]
   1f756:	69bb      	ldr	r3, [r7, #24]
   1f758:	2b00      	cmp	r3, #0
   1f75a:	d00f      	beq.n	1f77c <attsHandleValueIndNtf+0x4c>
  {
    /* get MTU size */
    mtu = pCcb->pMainCcb->mtu;
   1f75c:	69bb      	ldr	r3, [r7, #24]
   1f75e:	691b      	ldr	r3, [r3, #16]
   1f760:	8b5b      	ldrh	r3, [r3, #26]
   1f762:	83fb      	strh	r3, [r7, #30]
    transTimedOut = !!(pCcb->pMainCcb->control & ATT_CCB_STATUS_TX_TIMEOUT);
   1f764:	69bb      	ldr	r3, [r7, #24]
   1f766:	691b      	ldr	r3, [r3, #16]
   1f768:	7f5b      	ldrb	r3, [r3, #29]
   1f76a:	f003 0304 	and.w	r3, r3, #4
   1f76e:	2b00      	cmp	r3, #0
   1f770:	bf14      	ite	ne
   1f772:	2301      	movne	r3, #1
   1f774:	2300      	moveq	r3, #0
   1f776:	b2db      	uxtb	r3, r3
   1f778:	777b      	strb	r3, [r7, #29]
   1f77a:	e003      	b.n	1f784 <attsHandleValueIndNtf+0x54>
  }
  /* else connection not in use */
  else
  {
    /* MTU size unknown */
    mtu = 0;
   1f77c:	2300      	movs	r3, #0
   1f77e:	83fb      	strh	r3, [r7, #30]
    transTimedOut = FALSE;
   1f780:	2300      	movs	r3, #0
   1f782:	777b      	strb	r3, [r7, #29]
  }

  WsfTaskUnlock();
   1f784:	f00d fd44 	bl	2d210 <WsfTaskUnlock>

  /* if MTU size known for connection */
  if (mtu > 0)
   1f788:	8bfb      	ldrh	r3, [r7, #30]
   1f78a:	2b00      	cmp	r3, #0
   1f78c:	d07c      	beq.n	1f888 <attsHandleValueIndNtf+0x158>
  {
    /* if no transaction's timed out */
    if (!transTimedOut)
   1f78e:	7f7b      	ldrb	r3, [r7, #29]
   1f790:	2b00      	cmp	r3, #0
   1f792:	d173      	bne.n	1f87c <attsHandleValueIndNtf+0x14c>
    {
      /* Only send notifications and indications if client is aware of any database changes. */
      if (attsCsfIsClientChangeAware(connId, handle))
   1f794:	89ba      	ldrh	r2, [r7, #12]
   1f796:	7bfb      	ldrb	r3, [r7, #15]
   1f798:	4611      	mov	r1, r2
   1f79a:	4618      	mov	r0, r3
   1f79c:	f7ff fcd2 	bl	1f144 <attsCsfIsClientChangeAware>
   1f7a0:	4603      	mov	r3, r0
   1f7a2:	2b00      	cmp	r3, #0
   1f7a4:	d070      	beq.n	1f888 <attsHandleValueIndNtf+0x158>
      {
        /* if packet length is less than or equal to negotiated MTU */
        if ((valueLen + ATT_VALUE_NTF_LEN) <= mtu)
   1f7a6:	897b      	ldrh	r3, [r7, #10]
   1f7a8:	1c9a      	adds	r2, r3, #2
   1f7aa:	8bfb      	ldrh	r3, [r7, #30]
   1f7ac:	429a      	cmp	r2, r3
   1f7ae:	da5e      	bge.n	1f86e <attsHandleValueIndNtf+0x13e>
        {
          attsApiMsg_t  *pMsg;
          uint8_t       *p;

          /* allocate message buffer */
          if ((pMsg = WsfMsgAlloc(sizeof(attsApiMsg_t))) != NULL)
   1f7b0:	2008      	movs	r0, #8
   1f7b2:	f00d fc7c 	bl	2d0ae <WsfMsgAlloc>
   1f7b6:	6178      	str	r0, [r7, #20]
   1f7b8:	697b      	ldr	r3, [r7, #20]
   1f7ba:	2b00      	cmp	r3, #0
   1f7bc:	d064      	beq.n	1f888 <attsHandleValueIndNtf+0x158>
          {
            /* set parameters */
            pMsg->hdr.param = connId;
   1f7be:	7bfb      	ldrb	r3, [r7, #15]
   1f7c0:	b29a      	uxth	r2, r3
   1f7c2:	697b      	ldr	r3, [r7, #20]
   1f7c4:	801a      	strh	r2, [r3, #0]
            pMsg->hdr.event = ATTS_MSG_API_VALUE_IND_NTF;
   1f7c6:	697b      	ldr	r3, [r7, #20]
   1f7c8:	2221      	movs	r2, #33	; 0x21
   1f7ca:	709a      	strb	r2, [r3, #2]

            if (zeroCpy)
   1f7cc:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   1f7d0:	2b00      	cmp	r3, #0
   1f7d2:	d005      	beq.n	1f7e0 <attsHandleValueIndNtf+0xb0>
            {
              /* use packet buffer provided */
              pMsg->pPkt = (attsPktParam_t *)(pValue - ATT_VALUE_IND_NTF_BUF_LEN);
   1f7d4:	687b      	ldr	r3, [r7, #4]
   1f7d6:	f1a3 020b 	sub.w	r2, r3, #11
   1f7da:	697b      	ldr	r3, [r7, #20]
   1f7dc:	605a      	str	r2, [r3, #4]
   1f7de:	e008      	b.n	1f7f2 <attsHandleValueIndNtf+0xc2>
            }
            else
            {
              /* allocate packet buffer */
              pMsg->pPkt = attMsgAlloc(ATT_VALUE_IND_NTF_BUF_LEN + valueLen);
   1f7e0:	897b      	ldrh	r3, [r7, #10]
   1f7e2:	330b      	adds	r3, #11
   1f7e4:	b29b      	uxth	r3, r3
   1f7e6:	4618      	mov	r0, r3
   1f7e8:	f7fe f8fe 	bl	1d9e8 <attMsgAlloc>
   1f7ec:	4602      	mov	r2, r0
   1f7ee:	697b      	ldr	r3, [r7, #20]
   1f7f0:	605a      	str	r2, [r3, #4]
            }

            if (pMsg->pPkt != NULL)
   1f7f2:	697b      	ldr	r3, [r7, #20]
   1f7f4:	685b      	ldr	r3, [r3, #4]
   1f7f6:	2b00      	cmp	r3, #0
   1f7f8:	d035      	beq.n	1f866 <attsHandleValueIndNtf+0x136>
            {
              /* set data length and handle (ind and ntf have same header length) */
              pMsg->pPkt->len = ATT_VALUE_IND_LEN + valueLen;
   1f7fa:	697b      	ldr	r3, [r7, #20]
   1f7fc:	685b      	ldr	r3, [r3, #4]
   1f7fe:	897a      	ldrh	r2, [r7, #10]
   1f800:	3203      	adds	r2, #3
   1f802:	b292      	uxth	r2, r2
   1f804:	801a      	strh	r2, [r3, #0]
              pMsg->pPkt->handle = handle;
   1f806:	697b      	ldr	r3, [r7, #20]
   1f808:	685b      	ldr	r3, [r3, #4]
   1f80a:	89ba      	ldrh	r2, [r7, #12]
   1f80c:	805a      	strh	r2, [r3, #2]

              /* build packet */
              p = (uint8_t *)pMsg->pPkt + L2C_PAYLOAD_START;
   1f80e:	697b      	ldr	r3, [r7, #20]
   1f810:	685b      	ldr	r3, [r3, #4]
   1f812:	3308      	adds	r3, #8
   1f814:	613b      	str	r3, [r7, #16]
              UINT8_TO_BSTREAM(p, opcode);
   1f816:	693b      	ldr	r3, [r7, #16]
   1f818:	1c5a      	adds	r2, r3, #1
   1f81a:	613a      	str	r2, [r7, #16]
   1f81c:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
   1f820:	701a      	strb	r2, [r3, #0]
              UINT16_TO_BSTREAM(p, handle);
   1f822:	693b      	ldr	r3, [r7, #16]
   1f824:	1c5a      	adds	r2, r3, #1
   1f826:	613a      	str	r2, [r7, #16]
   1f828:	89ba      	ldrh	r2, [r7, #12]
   1f82a:	b2d2      	uxtb	r2, r2
   1f82c:	701a      	strb	r2, [r3, #0]
   1f82e:	89bb      	ldrh	r3, [r7, #12]
   1f830:	0a1b      	lsrs	r3, r3, #8
   1f832:	b299      	uxth	r1, r3
   1f834:	693b      	ldr	r3, [r7, #16]
   1f836:	1c5a      	adds	r2, r3, #1
   1f838:	613a      	str	r2, [r7, #16]
   1f83a:	b2ca      	uxtb	r2, r1
   1f83c:	701a      	strb	r2, [r3, #0]

              if (!zeroCpy)
   1f83e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   1f842:	2b00      	cmp	r3, #0
   1f844:	d105      	bne.n	1f852 <attsHandleValueIndNtf+0x122>
              {
                memcpy(p, pValue, valueLen);
   1f846:	897b      	ldrh	r3, [r7, #10]
   1f848:	461a      	mov	r2, r3
   1f84a:	6879      	ldr	r1, [r7, #4]
   1f84c:	6938      	ldr	r0, [r7, #16]
   1f84e:	f7f8 fd01 	bl	18254 <memcpy>
              }

              /* send message */
              WsfMsgSend(attCb.handlerId, pMsg);
   1f852:	4b16      	ldr	r3, [pc, #88]	; (1f8ac <attsHandleValueIndNtf+0x17c>)
   1f854:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
   1f858:	6979      	ldr	r1, [r7, #20]
   1f85a:	4618      	mov	r0, r3
   1f85c:	f00d fc4b 	bl	2d0f6 <WsfMsgSend>
              pktSent = TRUE;
   1f860:	2301      	movs	r3, #1
   1f862:	773b      	strb	r3, [r7, #28]
   1f864:	e010      	b.n	1f888 <attsHandleValueIndNtf+0x158>
            }
            else
            {
              /* free message buffer if packet buffer alloc failed */
              WsfMsgFree(pMsg);
   1f866:	6978      	ldr	r0, [r7, #20]
   1f868:	f00d fc38 	bl	2d0dc <WsfMsgFree>
   1f86c:	e00c      	b.n	1f888 <attsHandleValueIndNtf+0x158>
        }
        /* packet length exceeds MTU size */
        else
        {
          /* call callback with failure status */
          attsExecCallback(connId, handle, ATT_ERR_MTU_EXCEEDED);
   1f86e:	89b9      	ldrh	r1, [r7, #12]
   1f870:	7bfb      	ldrb	r3, [r7, #15]
   1f872:	2277      	movs	r2, #119	; 0x77
   1f874:	4618      	mov	r0, r3
   1f876:	f7ff fe0a 	bl	1f48e <attsExecCallback>
   1f87a:	e005      	b.n	1f888 <attsHandleValueIndNtf+0x158>
    }
    else
    /* transaction's timed out */
    {
      /* call callback with failure status */
      attsExecCallback(connId, handle, ATT_ERR_TIMEOUT);
   1f87c:	89b9      	ldrh	r1, [r7, #12]
   1f87e:	7bfb      	ldrb	r3, [r7, #15]
   1f880:	2271      	movs	r2, #113	; 0x71
   1f882:	4618      	mov	r0, r3
   1f884:	f7ff fe03 	bl	1f48e <attsExecCallback>
    }
  }

  /* if packet wasn't sent and it's a zero-copy packet */
  if (!pktSent && zeroCpy)
   1f888:	7f3b      	ldrb	r3, [r7, #28]
   1f88a:	2b00      	cmp	r3, #0
   1f88c:	d109      	bne.n	1f8a2 <attsHandleValueIndNtf+0x172>
   1f88e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   1f892:	2b00      	cmp	r3, #0
   1f894:	d005      	beq.n	1f8a2 <attsHandleValueIndNtf+0x172>
  {
    /* free packet buffer provided */
    AttMsgFree(pValue, opcode);
   1f896:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   1f89a:	4619      	mov	r1, r3
   1f89c:	6878      	ldr	r0, [r7, #4]
   1f89e:	f7fe f926 	bl	1daee <AttMsgFree>
  }
}
   1f8a2:	bf00      	nop
   1f8a4:	3720      	adds	r7, #32
   1f8a6:	46bd      	mov	sp, r7
   1f8a8:	bd80      	pop	{r7, pc}
   1f8aa:	bf00      	nop
   1f8ac:	10011048 	.word	0x10011048

0001f8b0 <attsProcValueCnf>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcValueCnf(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   1f8b0:	b580      	push	{r7, lr}
   1f8b2:	b086      	sub	sp, #24
   1f8b4:	af00      	add	r7, sp, #0
   1f8b6:	60f8      	str	r0, [r7, #12]
   1f8b8:	460b      	mov	r3, r1
   1f8ba:	607a      	str	r2, [r7, #4]
   1f8bc:	817b      	strh	r3, [r7, #10]
  attsIndCcb_t    *pIndCcb;

  /* get server indication CCB */
  if ((pIndCcb = attsIndCcbByConnId(pCcb->connId)) == NULL)
   1f8be:	68fb      	ldr	r3, [r7, #12]
   1f8c0:	7f1b      	ldrb	r3, [r3, #28]
   1f8c2:	4618      	mov	r0, r3
   1f8c4:	f7ff fd5c 	bl	1f380 <attsIndCcbByConnId>
   1f8c8:	6178      	str	r0, [r7, #20]
   1f8ca:	697b      	ldr	r3, [r7, #20]
   1f8cc:	2b00      	cmp	r3, #0
   1f8ce:	d01c      	beq.n	1f90a <attsProcValueCnf+0x5a>
  {
    return;
  }

  /* if an outstanding indication */
  if (pIndCcb->outIndHandle != ATT_HANDLE_NONE)
   1f8d0:	697b      	ldr	r3, [r7, #20]
   1f8d2:	8a9b      	ldrh	r3, [r3, #20]
   1f8d4:	2b00      	cmp	r3, #0
   1f8d6:	d019      	beq.n	1f90c <attsProcValueCnf+0x5c>
  {
    /* clear outstanding indication */
    pIndCcb->outIndHandle = ATT_HANDLE_NONE;
   1f8d8:	697b      	ldr	r3, [r7, #20]
   1f8da:	2200      	movs	r2, #0
   1f8dc:	829a      	strh	r2, [r3, #20]

    /* stop indication timer */
    WsfTimerStop(&pIndCcb->outIndTimer);
   1f8de:	697b      	ldr	r3, [r7, #20]
   1f8e0:	4618      	mov	r0, r3
   1f8e2:	f00d ffa9 	bl	2d838 <WsfTimerStop>

    /* call callback if flow control permits */
    if (!(pCcb->control & ATT_CCB_STATUS_FLOW_DISABLED))
   1f8e6:	68fb      	ldr	r3, [r7, #12]
   1f8e8:	7f5b      	ldrb	r3, [r3, #29]
   1f8ea:	f003 0302 	and.w	r3, r3, #2
   1f8ee:	2b00      	cmp	r3, #0
   1f8f0:	d10c      	bne.n	1f90c <attsProcValueCnf+0x5c>
    {
      attsExecCallback(pCcb->connId, pIndCcb->pendIndHandle, ATT_SUCCESS);
   1f8f2:	68fb      	ldr	r3, [r7, #12]
   1f8f4:	7f18      	ldrb	r0, [r3, #28]
   1f8f6:	697b      	ldr	r3, [r7, #20]
   1f8f8:	8adb      	ldrh	r3, [r3, #22]
   1f8fa:	2200      	movs	r2, #0
   1f8fc:	4619      	mov	r1, r3
   1f8fe:	f7ff fdc6 	bl	1f48e <attsExecCallback>
      pIndCcb->pendIndHandle = ATT_HANDLE_NONE;
   1f902:	697b      	ldr	r3, [r7, #20]
   1f904:	2200      	movs	r2, #0
   1f906:	82da      	strh	r2, [r3, #22]
   1f908:	e000      	b.n	1f90c <attsProcValueCnf+0x5c>
    return;
   1f90a:	bf00      	nop
    }
  }
}
   1f90c:	3718      	adds	r7, #24
   1f90e:	46bd      	mov	sp, r7
   1f910:	bd80      	pop	{r7, pc}
	...

0001f914 <AttsIndInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsIndInit(void)
{
   1f914:	b480      	push	{r7}
   1f916:	b083      	sub	sp, #12
   1f918:	af00      	add	r7, sp, #0
  uint8_t       i;
  attsIndCcb_t  *pCcb;

  /* Initialize control block CCBs */
  for (i = 0, pCcb = attsIndCb.ccb; i < DM_CONN_MAX; i++, pCcb++)
   1f91a:	2300      	movs	r3, #0
   1f91c:	71fb      	strb	r3, [r7, #7]
   1f91e:	4b14      	ldr	r3, [pc, #80]	; (1f970 <AttsIndInit+0x5c>)
   1f920:	603b      	str	r3, [r7, #0]
   1f922:	e019      	b.n	1f958 <AttsIndInit+0x44>
  {
    /* set pointer to main CCB */
    pCcb->pMainCcb = &attCb.ccb[i];
   1f924:	79fa      	ldrb	r2, [r7, #7]
   1f926:	4613      	mov	r3, r2
   1f928:	00db      	lsls	r3, r3, #3
   1f92a:	4413      	add	r3, r2
   1f92c:	009b      	lsls	r3, r3, #2
   1f92e:	4a11      	ldr	r2, [pc, #68]	; (1f974 <AttsIndInit+0x60>)
   1f930:	441a      	add	r2, r3
   1f932:	683b      	ldr	r3, [r7, #0]
   1f934:	611a      	str	r2, [r3, #16]

    /* initialize timer */
    pCcb->outIndTimer.handlerId = attCb.handlerId;
   1f936:	4b0f      	ldr	r3, [pc, #60]	; (1f974 <AttsIndInit+0x60>)
   1f938:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
   1f93c:	683b      	ldr	r3, [r7, #0]
   1f93e:	731a      	strb	r2, [r3, #12]
    pCcb->outIndTimer.msg.param = i + 1;  /* param stores the conn id */
   1f940:	79fb      	ldrb	r3, [r7, #7]
   1f942:	b29b      	uxth	r3, r3
   1f944:	3301      	adds	r3, #1
   1f946:	b29a      	uxth	r2, r3
   1f948:	683b      	ldr	r3, [r7, #0]
   1f94a:	811a      	strh	r2, [r3, #8]
  for (i = 0, pCcb = attsIndCb.ccb; i < DM_CONN_MAX; i++, pCcb++)
   1f94c:	79fb      	ldrb	r3, [r7, #7]
   1f94e:	3301      	adds	r3, #1
   1f950:	71fb      	strb	r3, [r7, #7]
   1f952:	683b      	ldr	r3, [r7, #0]
   1f954:	331c      	adds	r3, #28
   1f956:	603b      	str	r3, [r7, #0]
   1f958:	79fb      	ldrb	r3, [r7, #7]
   1f95a:	2b02      	cmp	r3, #2
   1f95c:	d9e2      	bls.n	1f924 <AttsIndInit+0x10>
  }

  /* set up callback interface */
  attsCb.pInd = &attsIndFcnIf;
   1f95e:	4b06      	ldr	r3, [pc, #24]	; (1f978 <AttsIndInit+0x64>)
   1f960:	4a06      	ldr	r2, [pc, #24]	; (1f97c <AttsIndInit+0x68>)
   1f962:	609a      	str	r2, [r3, #8]
}
   1f964:	bf00      	nop
   1f966:	370c      	adds	r7, #12
   1f968:	46bd      	mov	sp, r7
   1f96a:	f85d 7b04 	ldr.w	r7, [sp], #4
   1f96e:	4770      	bx	lr
   1f970:	10011188 	.word	0x10011188
   1f974:	10011048 	.word	0x10011048
   1f978:	100111dc 	.word	0x100111dc
   1f97c:	00045b88 	.word	0x00045b88

0001f980 <AttsHandleValueNtf>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsHandleValueNtf(dmConnId_t connId, uint16_t handle, uint16_t valueLen, uint8_t *pValue)
{
   1f980:	b580      	push	{r7, lr}
   1f982:	b086      	sub	sp, #24
   1f984:	af02      	add	r7, sp, #8
   1f986:	607b      	str	r3, [r7, #4]
   1f988:	4603      	mov	r3, r0
   1f98a:	73fb      	strb	r3, [r7, #15]
   1f98c:	460b      	mov	r3, r1
   1f98e:	81bb      	strh	r3, [r7, #12]
   1f990:	4613      	mov	r3, r2
   1f992:	817b      	strh	r3, [r7, #10]
  attsHandleValueIndNtf(connId, handle, valueLen, pValue, ATT_PDU_VALUE_NTF, FALSE);
   1f994:	897a      	ldrh	r2, [r7, #10]
   1f996:	89b9      	ldrh	r1, [r7, #12]
   1f998:	7bf8      	ldrb	r0, [r7, #15]
   1f99a:	2300      	movs	r3, #0
   1f99c:	9301      	str	r3, [sp, #4]
   1f99e:	231b      	movs	r3, #27
   1f9a0:	9300      	str	r3, [sp, #0]
   1f9a2:	687b      	ldr	r3, [r7, #4]
   1f9a4:	f7ff fec4 	bl	1f730 <attsHandleValueIndNtf>
}
   1f9a8:	bf00      	nop
   1f9aa:	3710      	adds	r7, #16
   1f9ac:	46bd      	mov	sp, r7
   1f9ae:	bd80      	pop	{r7, pc}

0001f9b0 <attsDataCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsDataCback(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   1f9b0:	b580      	push	{r7, lr}
   1f9b2:	b086      	sub	sp, #24
   1f9b4:	af00      	add	r7, sp, #0
   1f9b6:	4603      	mov	r3, r0
   1f9b8:	603a      	str	r2, [r7, #0]
   1f9ba:	80fb      	strh	r3, [r7, #6]
   1f9bc:	460b      	mov	r3, r1
   1f9be:	80bb      	strh	r3, [r7, #4]
  attsProcFcn_t procFcn;
  attCcb_t      *pCcb;
  uint16_t      attHandle;

  /* get connection cb for this handle */
  if ((pCcb = attCcbByHandle(handle)) == NULL)
   1f9c0:	88fb      	ldrh	r3, [r7, #6]
   1f9c2:	4618      	mov	r0, r3
   1f9c4:	f7fd ff6c 	bl	1d8a0 <attCcbByHandle>
   1f9c8:	6138      	str	r0, [r7, #16]
   1f9ca:	693b      	ldr	r3, [r7, #16]
   1f9cc:	2b00      	cmp	r3, #0
   1f9ce:	d07a      	beq.n	1fac6 <attsDataCback+0x116>
  {
    return;
  }

  /* check the validity of data length */
  ATT_CHECK_DATA_LENGTH(len, ATT_HDR_LEN);
   1f9d0:	88bb      	ldrh	r3, [r7, #4]
   1f9d2:	2b00      	cmp	r3, #0
   1f9d4:	d079      	beq.n	1faca <attsDataCback+0x11a>

  /* parse opcode */
  opcode = *(pPacket + L2C_PAYLOAD_START);
   1f9d6:	683b      	ldr	r3, [r7, #0]
   1f9d8:	7a1b      	ldrb	r3, [r3, #8]
   1f9da:	73fb      	strb	r3, [r7, #15]

  /* get method */
  if ((opcode <= ATT_PDU_WRITE_REQ) ||
   1f9dc:	7bfb      	ldrb	r3, [r7, #15]
   1f9de:	2b12      	cmp	r3, #18
   1f9e0:	d905      	bls.n	1f9ee <attsDataCback+0x3e>
   1f9e2:	7bfb      	ldrb	r3, [r7, #15]
   1f9e4:	2b15      	cmp	r3, #21
   1f9e6:	d906      	bls.n	1f9f6 <attsDataCback+0x46>
      ((opcode >= ATT_PDU_PREP_WRITE_REQ) && (opcode <= ATT_PDU_VALUE_CNF)))
   1f9e8:	7bfb      	ldrb	r3, [r7, #15]
   1f9ea:	2b1e      	cmp	r3, #30
   1f9ec:	d803      	bhi.n	1f9f6 <attsDataCback+0x46>
  {
    method = ATT_OPCODE_2_METHOD(opcode);
   1f9ee:	7bfb      	ldrb	r3, [r7, #15]
   1f9f0:	105b      	asrs	r3, r3, #1
   1f9f2:	75fb      	strb	r3, [r7, #23]
   1f9f4:	e00d      	b.n	1fa12 <attsDataCback+0x62>
  }
  else if (opcode == ATT_PDU_WRITE_CMD)
   1f9f6:	7bfb      	ldrb	r3, [r7, #15]
   1f9f8:	2b52      	cmp	r3, #82	; 0x52
   1f9fa:	d102      	bne.n	1fa02 <attsDataCback+0x52>
  {
    method = ATT_METHOD_WRITE_CMD;
   1f9fc:	230a      	movs	r3, #10
   1f9fe:	75fb      	strb	r3, [r7, #23]
   1fa00:	e007      	b.n	1fa12 <attsDataCback+0x62>
  }
  else if (opcode == ATT_PDU_SIGNED_WRITE_CMD)
   1fa02:	7bfb      	ldrb	r3, [r7, #15]
   1fa04:	2bd2      	cmp	r3, #210	; 0xd2
   1fa06:	d102      	bne.n	1fa0e <attsDataCback+0x5e>
  {
    method = ATT_METHOD_SIGNED_WRITE_CMD;
   1fa08:	2310      	movs	r3, #16
   1fa0a:	75fb      	strb	r3, [r7, #23]
   1fa0c:	e001      	b.n	1fa12 <attsDataCback+0x62>
  }
  else
  {
    method = ATT_METHOD_ERR;
   1fa0e:	2300      	movs	r3, #0
   1fa10:	75fb      	strb	r3, [r7, #23]
  }

  /* ignore packet if write response is pending. */
  if (pCcb->control & ATT_CCB_STATUS_RSP_PENDING)
   1fa12:	693b      	ldr	r3, [r7, #16]
   1fa14:	7f5b      	ldrb	r3, [r3, #29]
   1fa16:	f003 0308 	and.w	r3, r3, #8
   1fa1a:	2b00      	cmp	r3, #0
   1fa1c:	d002      	beq.n	1fa24 <attsDataCback+0x74>
  {
    if (method != ATT_METHOD_VALUE_CNF)
   1fa1e:	7dfb      	ldrb	r3, [r7, #23]
   1fa20:	2b0f      	cmp	r3, #15
   1fa22:	d154      	bne.n	1face <attsDataCback+0x11e>
      return;
    }
  }

  /* check client's status to see if server is allowed to process this PDU. */
  err = attsCsfActClientState(handle, opcode, pPacket);
   1fa24:	7bf9      	ldrb	r1, [r7, #15]
   1fa26:	88fb      	ldrh	r3, [r7, #6]
   1fa28:	683a      	ldr	r2, [r7, #0]
   1fa2a:	4618      	mov	r0, r3
   1fa2c:	f7ff fbb2 	bl	1f194 <attsCsfActClientState>
   1fa30:	4603      	mov	r3, r0
   1fa32:	75bb      	strb	r3, [r7, #22]
  if (err)
   1fa34:	7dbb      	ldrb	r3, [r7, #22]
   1fa36:	2b00      	cmp	r3, #0
   1fa38:	d00f      	beq.n	1fa5a <attsDataCback+0xaa>
  {
    /* check the validity of data length */
    ATT_CHECK_DATA_LENGTH(len, (ATT_HDR_LEN + 2));
   1fa3a:	88bb      	ldrh	r3, [r7, #4]
   1fa3c:	2b02      	cmp	r3, #2
   1fa3e:	d948      	bls.n	1fad2 <attsDataCback+0x122>

    BYTES_TO_UINT16(attHandle, pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN);
   1fa40:	683b      	ldr	r3, [r7, #0]
   1fa42:	3309      	adds	r3, #9
   1fa44:	781b      	ldrb	r3, [r3, #0]
   1fa46:	b29a      	uxth	r2, r3
   1fa48:	683b      	ldr	r3, [r7, #0]
   1fa4a:	330a      	adds	r3, #10
   1fa4c:	781b      	ldrb	r3, [r3, #0]
   1fa4e:	b29b      	uxth	r3, r3
   1fa50:	021b      	lsls	r3, r3, #8
   1fa52:	b29b      	uxth	r3, r3
   1fa54:	4413      	add	r3, r2
   1fa56:	82bb      	strh	r3, [r7, #20]
   1fa58:	e001      	b.n	1fa5e <attsDataCback+0xae>
  }
  else
  {
    attHandle = ATT_HANDLE_NONE;
   1fa5a:	2300      	movs	r3, #0
   1fa5c:	82bb      	strh	r3, [r7, #20]
    return;
  }
#endif

  /* if no error process request */
  if (!err)
   1fa5e:	7dbb      	ldrb	r3, [r7, #22]
   1fa60:	2b00      	cmp	r3, #0
   1fa62:	d11b      	bne.n	1fa9c <attsDataCback+0xec>
  {
    /* look up processing function */
    procFcn = attsProcFcnTbl[method];
   1fa64:	7dfb      	ldrb	r3, [r7, #23]
   1fa66:	4a1d      	ldr	r2, [pc, #116]	; (1fadc <attsDataCback+0x12c>)
   1fa68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1fa6c:	60bb      	str	r3, [r7, #8]

    /* if method is supported */
    if (procFcn != NULL)
   1fa6e:	68bb      	ldr	r3, [r7, #8]
   1fa70:	2b00      	cmp	r3, #0
   1fa72:	d011      	beq.n	1fa98 <attsDataCback+0xe8>
    {
      /* verify length */
      if (len >= attsMinPduLen[method])
   1fa74:	7dfb      	ldrb	r3, [r7, #23]
   1fa76:	4a1a      	ldr	r2, [pc, #104]	; (1fae0 <attsDataCback+0x130>)
   1fa78:	5cd3      	ldrb	r3, [r2, r3]
   1fa7a:	b29b      	uxth	r3, r3
   1fa7c:	88ba      	ldrh	r2, [r7, #4]
   1fa7e:	429a      	cmp	r2, r3
   1fa80:	d307      	bcc.n	1fa92 <attsDataCback+0xe2>
      {
        /* execute processing function */
        (*procFcn)(pCcb, len, pPacket);
   1fa82:	88b9      	ldrh	r1, [r7, #4]
   1fa84:	68bb      	ldr	r3, [r7, #8]
   1fa86:	683a      	ldr	r2, [r7, #0]
   1fa88:	6938      	ldr	r0, [r7, #16]
   1fa8a:	4798      	blx	r3
        err = 0;
   1fa8c:	2300      	movs	r3, #0
   1fa8e:	75bb      	strb	r3, [r7, #22]
   1fa90:	e004      	b.n	1fa9c <attsDataCback+0xec>
      }
      else
      {
        /* invalid PDU length */
        err = ATT_ERR_INVALID_PDU;
   1fa92:	2304      	movs	r3, #4
   1fa94:	75bb      	strb	r3, [r7, #22]
   1fa96:	e001      	b.n	1fa9c <attsDataCback+0xec>
      }
    }
    else
    {
      /* PDU not supported */
      err = ATT_ERR_NOT_SUP;
   1fa98:	2306      	movs	r3, #6
   1fa9a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /* if there's an error and an error response can be sent for this opcode */
  if (err && (opcode != ATT_PDU_MTU_REQ) && (opcode != ATT_PDU_VALUE_CNF) &&
   1fa9c:	7dbb      	ldrb	r3, [r7, #22]
   1fa9e:	2b00      	cmp	r3, #0
   1faa0:	d018      	beq.n	1fad4 <attsDataCback+0x124>
   1faa2:	7bfb      	ldrb	r3, [r7, #15]
   1faa4:	2b02      	cmp	r3, #2
   1faa6:	d015      	beq.n	1fad4 <attsDataCback+0x124>
   1faa8:	7bfb      	ldrb	r3, [r7, #15]
   1faaa:	2b1e      	cmp	r3, #30
   1faac:	d012      	beq.n	1fad4 <attsDataCback+0x124>
      ((opcode & ATT_PDU_MASK_COMMAND) == 0))
   1faae:	7bfb      	ldrb	r3, [r7, #15]
   1fab0:	f003 0340 	and.w	r3, r3, #64	; 0x40
  if (err && (opcode != ATT_PDU_MTU_REQ) && (opcode != ATT_PDU_VALUE_CNF) &&
   1fab4:	2b00      	cmp	r3, #0
   1fab6:	d10d      	bne.n	1fad4 <attsDataCback+0x124>
  {
    attsErrRsp(handle, opcode, attHandle, err);
   1fab8:	7dbb      	ldrb	r3, [r7, #22]
   1faba:	8aba      	ldrh	r2, [r7, #20]
   1fabc:	7bf9      	ldrb	r1, [r7, #15]
   1fabe:	88f8      	ldrh	r0, [r7, #6]
   1fac0:	f000 f87a 	bl	1fbb8 <attsErrRsp>
   1fac4:	e006      	b.n	1fad4 <attsDataCback+0x124>
    return;
   1fac6:	bf00      	nop
   1fac8:	e004      	b.n	1fad4 <attsDataCback+0x124>
  ATT_CHECK_DATA_LENGTH(len, ATT_HDR_LEN);
   1faca:	bf00      	nop
   1facc:	e002      	b.n	1fad4 <attsDataCback+0x124>
      return;
   1face:	bf00      	nop
   1fad0:	e000      	b.n	1fad4 <attsDataCback+0x124>
    ATT_CHECK_DATA_LENGTH(len, (ATT_HDR_LEN + 2));
   1fad2:	bf00      	nop
  }
}
   1fad4:	3718      	adds	r7, #24
   1fad6:	46bd      	mov	sp, r7
   1fad8:	bd80      	pop	{r7, pc}
   1fada:	bf00      	nop
   1fadc:	10002b48 	.word	0x10002b48
   1fae0:	00045ba8 	.word	0x00045ba8

0001fae4 <attsConnCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsConnCback(attCcb_t *pCcb, dmEvt_t *pDmEvt)
{
   1fae4:	b580      	push	{r7, lr}
   1fae6:	b082      	sub	sp, #8
   1fae8:	af00      	add	r7, sp, #0
   1faea:	6078      	str	r0, [r7, #4]
   1faec:	6039      	str	r1, [r7, #0]
  /* if connection closed */
  if (pDmEvt->hdr.event == DM_CONN_CLOSE_IND)
   1faee:	683b      	ldr	r3, [r7, #0]
   1faf0:	789b      	ldrb	r3, [r3, #2]
   1faf2:	2b28      	cmp	r3, #40	; 0x28
   1faf4:	d111      	bne.n	1fb1a <attsConnCback+0x36>
  {
    /* clear prepare write queue */
    attsClearPrepWrites(pCcb);
   1faf6:	6878      	ldr	r0, [r7, #4]
   1faf8:	f000 f89e 	bl	1fc38 <attsClearPrepWrites>

    /* stop service discovery idle timer, if running */
    if (DmConnCheckIdle(pCcb->connId) & DM_IDLE_ATTS_DISC)
   1fafc:	687b      	ldr	r3, [r7, #4]
   1fafe:	7f1b      	ldrb	r3, [r3, #28]
   1fb00:	4618      	mov	r0, r3
   1fb02:	f003 fda3 	bl	2364c <DmConnCheckIdle>
   1fb06:	4603      	mov	r3, r0
   1fb08:	f003 0304 	and.w	r3, r3, #4
   1fb0c:	2b00      	cmp	r3, #0
   1fb0e:	d004      	beq.n	1fb1a <attsConnCback+0x36>
    {
      WsfTimerStop(&pCcb->idleTimer);
   1fb10:	687b      	ldr	r3, [r7, #4]
   1fb12:	3308      	adds	r3, #8
   1fb14:	4618      	mov	r0, r3
   1fb16:	f00d fe8f 	bl	2d838 <WsfTimerStop>
    }
  }

  /* pass event to indication interface */
  (*attsCb.pInd->connCback)(pCcb, pDmEvt);
   1fb1a:	4b05      	ldr	r3, [pc, #20]	; (1fb30 <attsConnCback+0x4c>)
   1fb1c:	689b      	ldr	r3, [r3, #8]
   1fb1e:	68db      	ldr	r3, [r3, #12]
   1fb20:	6839      	ldr	r1, [r7, #0]
   1fb22:	6878      	ldr	r0, [r7, #4]
   1fb24:	4798      	blx	r3
}
   1fb26:	bf00      	nop
   1fb28:	3708      	adds	r7, #8
   1fb2a:	46bd      	mov	sp, r7
   1fb2c:	bd80      	pop	{r7, pc}
   1fb2e:	bf00      	nop
   1fb30:	100111dc 	.word	0x100111dc

0001fb34 <attsMsgCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsMsgCback(wsfMsgHdr_t *pMsg)
{
   1fb34:	b580      	push	{r7, lr}
   1fb36:	b082      	sub	sp, #8
   1fb38:	af00      	add	r7, sp, #0
   1fb3a:	6078      	str	r0, [r7, #4]
  /* handle service discovery idle timeout */
  if (pMsg->event == ATTS_MSG_IDLE_TIMEOUT)
   1fb3c:	687b      	ldr	r3, [r7, #4]
   1fb3e:	789b      	ldrb	r3, [r3, #2]
   1fb40:	2b20      	cmp	r3, #32
   1fb42:	d108      	bne.n	1fb56 <attsMsgCback+0x22>
  {
    /* set channel as idle */
    DmConnSetIdle((dmConnId_t) pMsg->param, DM_IDLE_ATTS_DISC, DM_CONN_IDLE);
   1fb44:	687b      	ldr	r3, [r7, #4]
   1fb46:	881b      	ldrh	r3, [r3, #0]
   1fb48:	b2db      	uxtb	r3, r3
   1fb4a:	2200      	movs	r2, #0
   1fb4c:	2104      	movs	r1, #4
   1fb4e:	4618      	mov	r0, r3
   1fb50:	f003 fd18 	bl	23584 <DmConnSetIdle>
  else if (pMsg->event == ATTS_MSG_DBH_CMAC_CMPL)
  {
    /* handle database hash update */
    attsProcessDatabaseHashUpdate((secCmacMsg_t *) pMsg);
  }
}
   1fb54:	e019      	b.n	1fb8a <attsMsgCback+0x56>
  else if (pMsg->event <= ATTS_MSG_IND_TIMEOUT)
   1fb56:	687b      	ldr	r3, [r7, #4]
   1fb58:	789b      	ldrb	r3, [r3, #2]
   1fb5a:	2b22      	cmp	r3, #34	; 0x22
   1fb5c:	d805      	bhi.n	1fb6a <attsMsgCback+0x36>
    (*attsCb.pInd->msgCback)(pMsg);
   1fb5e:	4b0d      	ldr	r3, [pc, #52]	; (1fb94 <attsMsgCback+0x60>)
   1fb60:	689b      	ldr	r3, [r3, #8]
   1fb62:	689b      	ldr	r3, [r3, #8]
   1fb64:	6878      	ldr	r0, [r7, #4]
   1fb66:	4798      	blx	r3
}
   1fb68:	e00f      	b.n	1fb8a <attsMsgCback+0x56>
  else if (pMsg->event == ATTS_MSG_SIGN_CMAC_CMPL)
   1fb6a:	687b      	ldr	r3, [r7, #4]
   1fb6c:	789b      	ldrb	r3, [r3, #2]
   1fb6e:	2b23      	cmp	r3, #35	; 0x23
   1fb70:	d104      	bne.n	1fb7c <attsMsgCback+0x48>
    (*attsCb.signMsgCback)(pMsg);
   1fb72:	4b08      	ldr	r3, [pc, #32]	; (1fb94 <attsMsgCback+0x60>)
   1fb74:	68db      	ldr	r3, [r3, #12]
   1fb76:	6878      	ldr	r0, [r7, #4]
   1fb78:	4798      	blx	r3
}
   1fb7a:	e006      	b.n	1fb8a <attsMsgCback+0x56>
  else if (pMsg->event == ATTS_MSG_DBH_CMAC_CMPL)
   1fb7c:	687b      	ldr	r3, [r7, #4]
   1fb7e:	789b      	ldrb	r3, [r3, #2]
   1fb80:	2b24      	cmp	r3, #36	; 0x24
   1fb82:	d102      	bne.n	1fb8a <attsMsgCback+0x56>
    attsProcessDatabaseHashUpdate((secCmacMsg_t *) pMsg);
   1fb84:	6878      	ldr	r0, [r7, #4]
   1fb86:	f000 f89d 	bl	1fcc4 <attsProcessDatabaseHashUpdate>
}
   1fb8a:	bf00      	nop
   1fb8c:	3708      	adds	r7, #8
   1fb8e:	46bd      	mov	sp, r7
   1fb90:	bd80      	pop	{r7, pc}
   1fb92:	bf00      	nop
   1fb94:	100111dc 	.word	0x100111dc

0001fb98 <attsL2cCtrlCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void attsL2cCtrlCback(wsfMsgHdr_t *pMsg)
{
   1fb98:	b580      	push	{r7, lr}
   1fb9a:	b082      	sub	sp, #8
   1fb9c:	af00      	add	r7, sp, #0
   1fb9e:	6078      	str	r0, [r7, #4]
  /* pass event to indication interface */
  (*attsCb.pInd->ctrlCback)(pMsg);
   1fba0:	4b04      	ldr	r3, [pc, #16]	; (1fbb4 <attsL2cCtrlCback+0x1c>)
   1fba2:	689b      	ldr	r3, [r3, #8]
   1fba4:	685b      	ldr	r3, [r3, #4]
   1fba6:	6878      	ldr	r0, [r7, #4]
   1fba8:	4798      	blx	r3
}
   1fbaa:	bf00      	nop
   1fbac:	3708      	adds	r7, #8
   1fbae:	46bd      	mov	sp, r7
   1fbb0:	bd80      	pop	{r7, pc}
   1fbb2:	bf00      	nop
   1fbb4:	100111dc 	.word	0x100111dc

0001fbb8 <attsErrRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsErrRsp(uint16_t handle, uint8_t opcode, uint16_t attHandle, uint8_t reason)
{
   1fbb8:	b590      	push	{r4, r7, lr}
   1fbba:	b085      	sub	sp, #20
   1fbbc:	af00      	add	r7, sp, #0
   1fbbe:	4604      	mov	r4, r0
   1fbc0:	4608      	mov	r0, r1
   1fbc2:	4611      	mov	r1, r2
   1fbc4:	461a      	mov	r2, r3
   1fbc6:	4623      	mov	r3, r4
   1fbc8:	80fb      	strh	r3, [r7, #6]
   1fbca:	4603      	mov	r3, r0
   1fbcc:	717b      	strb	r3, [r7, #5]
   1fbce:	460b      	mov	r3, r1
   1fbd0:	807b      	strh	r3, [r7, #2]
   1fbd2:	4613      	mov	r3, r2
   1fbd4:	713b      	strb	r3, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  /* allocate buffer */
  if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_ERR_RSP_LEN)) != NULL)
   1fbd6:	200d      	movs	r0, #13
   1fbd8:	f7fd ff06 	bl	1d9e8 <attMsgAlloc>
   1fbdc:	60f8      	str	r0, [r7, #12]
   1fbde:	68fb      	ldr	r3, [r7, #12]
   1fbe0:	2b00      	cmp	r3, #0
   1fbe2:	d025      	beq.n	1fc30 <attsErrRsp+0x78>
  {
    p = pBuf + L2C_PAYLOAD_START;
   1fbe4:	68fb      	ldr	r3, [r7, #12]
   1fbe6:	3308      	adds	r3, #8
   1fbe8:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, ATT_PDU_ERR_RSP);
   1fbea:	68bb      	ldr	r3, [r7, #8]
   1fbec:	1c5a      	adds	r2, r3, #1
   1fbee:	60ba      	str	r2, [r7, #8]
   1fbf0:	2201      	movs	r2, #1
   1fbf2:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, opcode);
   1fbf4:	68bb      	ldr	r3, [r7, #8]
   1fbf6:	1c5a      	adds	r2, r3, #1
   1fbf8:	60ba      	str	r2, [r7, #8]
   1fbfa:	797a      	ldrb	r2, [r7, #5]
   1fbfc:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, attHandle);
   1fbfe:	68bb      	ldr	r3, [r7, #8]
   1fc00:	1c5a      	adds	r2, r3, #1
   1fc02:	60ba      	str	r2, [r7, #8]
   1fc04:	887a      	ldrh	r2, [r7, #2]
   1fc06:	b2d2      	uxtb	r2, r2
   1fc08:	701a      	strb	r2, [r3, #0]
   1fc0a:	887b      	ldrh	r3, [r7, #2]
   1fc0c:	0a1b      	lsrs	r3, r3, #8
   1fc0e:	b299      	uxth	r1, r3
   1fc10:	68bb      	ldr	r3, [r7, #8]
   1fc12:	1c5a      	adds	r2, r3, #1
   1fc14:	60ba      	str	r2, [r7, #8]
   1fc16:	b2ca      	uxtb	r2, r1
   1fc18:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, reason);
   1fc1a:	68bb      	ldr	r3, [r7, #8]
   1fc1c:	1c5a      	adds	r2, r3, #1
   1fc1e:	60ba      	str	r2, [r7, #8]
   1fc20:	793a      	ldrb	r2, [r7, #4]
   1fc22:	701a      	strb	r2, [r3, #0]

    L2cDataReq(L2C_CID_ATT, handle, ATT_ERR_RSP_LEN, pBuf);
   1fc24:	88f9      	ldrh	r1, [r7, #6]
   1fc26:	68fb      	ldr	r3, [r7, #12]
   1fc28:	2205      	movs	r2, #5
   1fc2a:	2004      	movs	r0, #4
   1fc2c:	f00a f95c 	bl	29ee8 <L2cDataReq>
  }
}
   1fc30:	bf00      	nop
   1fc32:	3714      	adds	r7, #20
   1fc34:	46bd      	mov	sp, r7
   1fc36:	bd90      	pop	{r4, r7, pc}

0001fc38 <attsClearPrepWrites>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsClearPrepWrites(attCcb_t *pCcb)
{
   1fc38:	b580      	push	{r7, lr}
   1fc3a:	b084      	sub	sp, #16
   1fc3c:	af00      	add	r7, sp, #0
   1fc3e:	6078      	str	r0, [r7, #4]
  void *pBuf;

  while ((pBuf = WsfQueueDeq(&pCcb->prepWriteQueue)) != NULL)
   1fc40:	e002      	b.n	1fc48 <attsClearPrepWrites+0x10>
  {
    WsfBufFree(pBuf);
   1fc42:	68f8      	ldr	r0, [r7, #12]
   1fc44:	f00d f9e4 	bl	2d010 <WsfBufFree>
  while ((pBuf = WsfQueueDeq(&pCcb->prepWriteQueue)) != NULL)
   1fc48:	687b      	ldr	r3, [r7, #4]
   1fc4a:	4618      	mov	r0, r3
   1fc4c:	f00d fc8e 	bl	2d56c <WsfQueueDeq>
   1fc50:	60f8      	str	r0, [r7, #12]
   1fc52:	68fb      	ldr	r3, [r7, #12]
   1fc54:	2b00      	cmp	r3, #0
   1fc56:	d1f4      	bne.n	1fc42 <attsClearPrepWrites+0xa>
  }
}
   1fc58:	bf00      	nop
   1fc5a:	bf00      	nop
   1fc5c:	3710      	adds	r7, #16
   1fc5e:	46bd      	mov	sp, r7
   1fc60:	bd80      	pop	{r7, pc}
	...

0001fc64 <attsDiscBusy>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsDiscBusy(attCcb_t *pCcb)
{
   1fc64:	b580      	push	{r7, lr}
   1fc66:	b082      	sub	sp, #8
   1fc68:	af00      	add	r7, sp, #0
   1fc6a:	6078      	str	r0, [r7, #4]
  if (pAttCfg->discIdleTimeout > 0)
   1fc6c:	4b13      	ldr	r3, [pc, #76]	; (1fcbc <attsDiscBusy+0x58>)
   1fc6e:	681b      	ldr	r3, [r3, #0]
   1fc70:	681b      	ldr	r3, [r3, #0]
   1fc72:	2b00      	cmp	r3, #0
   1fc74:	d01d      	beq.n	1fcb2 <attsDiscBusy+0x4e>
  {
    /* set channel as busy */
    DmConnSetIdle(pCcb->connId, DM_IDLE_ATTS_DISC, DM_CONN_BUSY);
   1fc76:	687b      	ldr	r3, [r7, #4]
   1fc78:	7f1b      	ldrb	r3, [r3, #28]
   1fc7a:	2201      	movs	r2, #1
   1fc7c:	2104      	movs	r1, #4
   1fc7e:	4618      	mov	r0, r3
   1fc80:	f003 fc80 	bl	23584 <DmConnSetIdle>

    /* start service discovery idle timer */
    pCcb->idleTimer.handlerId = attCb.handlerId;
   1fc84:	4b0e      	ldr	r3, [pc, #56]	; (1fcc0 <attsDiscBusy+0x5c>)
   1fc86:	f893 207c 	ldrb.w	r2, [r3, #124]	; 0x7c
   1fc8a:	687b      	ldr	r3, [r7, #4]
   1fc8c:	751a      	strb	r2, [r3, #20]
    pCcb->idleTimer.msg.event = ATTS_MSG_IDLE_TIMEOUT;
   1fc8e:	687b      	ldr	r3, [r7, #4]
   1fc90:	2220      	movs	r2, #32
   1fc92:	749a      	strb	r2, [r3, #18]
    pCcb->idleTimer.msg.param = pCcb->connId;
   1fc94:	687b      	ldr	r3, [r7, #4]
   1fc96:	7f1b      	ldrb	r3, [r3, #28]
   1fc98:	b29a      	uxth	r2, r3
   1fc9a:	687b      	ldr	r3, [r7, #4]
   1fc9c:	821a      	strh	r2, [r3, #16]
    WsfTimerStartSec(&pCcb->idleTimer, pAttCfg->discIdleTimeout);
   1fc9e:	687b      	ldr	r3, [r7, #4]
   1fca0:	f103 0208 	add.w	r2, r3, #8
   1fca4:	4b05      	ldr	r3, [pc, #20]	; (1fcbc <attsDiscBusy+0x58>)
   1fca6:	681b      	ldr	r3, [r3, #0]
   1fca8:	681b      	ldr	r3, [r3, #0]
   1fcaa:	4619      	mov	r1, r3
   1fcac:	4610      	mov	r0, r2
   1fcae:	f00d fd9d 	bl	2d7ec <WsfTimerStartSec>
  }
}
   1fcb2:	bf00      	nop
   1fcb4:	3708      	adds	r7, #8
   1fcb6:	46bd      	mov	sp, r7
   1fcb8:	bd80      	pop	{r7, pc}
   1fcba:	bf00      	nop
   1fcbc:	10002b8c 	.word	0x10002b8c
   1fcc0:	10011048 	.word	0x10011048

0001fcc4 <attsProcessDatabaseHashUpdate>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcessDatabaseHashUpdate(secCmacMsg_t *pMsg)
{
   1fcc4:	b580      	push	{r7, lr}
   1fcc6:	b08c      	sub	sp, #48	; 0x30
   1fcc8:	af02      	add	r7, sp, #8
   1fcca:	6078      	str	r0, [r7, #4]
  attsAttr_t *pAttr;
  attsGroup_t *pGroup;
  uint16_t dbhCharHandle;

  /* send to application */
  evt.hdr.event = ATTS_DB_HASH_CALC_CMPL_IND;
   1fccc:	2311      	movs	r3, #17
   1fcce:	75bb      	strb	r3, [r7, #22]
  evt.hdr.status = ATT_SUCCESS;
   1fcd0:	2300      	movs	r3, #0
   1fcd2:	75fb      	strb	r3, [r7, #23]
  evt.hdr.param = DM_CONN_ID_NONE;
   1fcd4:	2300      	movs	r3, #0
   1fcd6:	82bb      	strh	r3, [r7, #20]

  evt.valueLen = ATT_DATABASE_HASH_LEN;
   1fcd8:	2310      	movs	r3, #16
   1fcda:	83bb      	strh	r3, [r7, #28]
  evt.handle = ATT_HANDLE_NONE;
   1fcdc:	2300      	movs	r3, #0
   1fcde:	83fb      	strh	r3, [r7, #30]
  evt.continuing = FALSE;
   1fce0:	2300      	movs	r3, #0
   1fce2:	f887 3020 	strb.w	r3, [r7, #32]
  evt.mtu = 0;
   1fce6:	2300      	movs	r3, #0
   1fce8:	847b      	strh	r3, [r7, #34]	; 0x22

  /* free plain text buffer */
  if (pMsg->pPlainText != NULL)
   1fcea:	687b      	ldr	r3, [r7, #4]
   1fcec:	689b      	ldr	r3, [r3, #8]
   1fcee:	2b00      	cmp	r3, #0
   1fcf0:	d007      	beq.n	1fd02 <attsProcessDatabaseHashUpdate+0x3e>
  {
    WsfBufFree(pMsg->pPlainText);
   1fcf2:	687b      	ldr	r3, [r7, #4]
   1fcf4:	689b      	ldr	r3, [r3, #8]
   1fcf6:	4618      	mov	r0, r3
   1fcf8:	f00d f98a 	bl	2d010 <WsfBufFree>
    pMsg->pPlainText = NULL;
   1fcfc:	687b      	ldr	r3, [r7, #4]
   1fcfe:	2200      	movs	r2, #0
   1fd00:	609a      	str	r2, [r3, #8]
  }

  /* copy in little endian */
  evt.pValue = pMsg->pCiphertext;
   1fd02:	687b      	ldr	r3, [r7, #4]
   1fd04:	685b      	ldr	r3, [r3, #4]
   1fd06:	61bb      	str	r3, [r7, #24]

  /* find GATT database handle */
  dbhCharHandle = attsFindUuidInRange(ATT_HANDLE_START, ATT_HANDLE_MAX, ATT_16_UUID_LEN,
   1fd08:	f107 030c 	add.w	r3, r7, #12
   1fd0c:	9301      	str	r3, [sp, #4]
   1fd0e:	f107 0310 	add.w	r3, r7, #16
   1fd12:	9300      	str	r3, [sp, #0]
   1fd14:	4b0f      	ldr	r3, [pc, #60]	; (1fd54 <attsProcessDatabaseHashUpdate+0x90>)
   1fd16:	2202      	movs	r2, #2
   1fd18:	f64f 71ff 	movw	r1, #65535	; 0xffff
   1fd1c:	2001      	movs	r0, #1
   1fd1e:	f000 fda3 	bl	20868 <attsFindUuidInRange>
   1fd22:	4603      	mov	r3, r0
   1fd24:	84fb      	strh	r3, [r7, #38]	; 0x26
                                      (uint8_t *) attGattDbhChUuid, &pAttr, &pGroup);

  if (dbhCharHandle != ATT_HANDLE_NONE)
   1fd26:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   1fd28:	2b00      	cmp	r3, #0
   1fd2a:	d005      	beq.n	1fd38 <attsProcessDatabaseHashUpdate+0x74>
  {
    /* Set hash in service. */
    AttsSetAttr(dbhCharHandle, SEC_CMAC_HASH_LEN, evt.pValue);
   1fd2c:	69ba      	ldr	r2, [r7, #24]
   1fd2e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   1fd30:	2110      	movs	r1, #16
   1fd32:	4618      	mov	r0, r3
   1fd34:	f000 fa32 	bl	2019c <AttsSetAttr>
  }

  /* set hash update complete */
  attsCsfSetHashUpdateStatus(FALSE);
   1fd38:	2000      	movs	r0, #0
   1fd3a:	f7ff f9bd 	bl	1f0b8 <attsCsfSetHashUpdateStatus>

  attCb.cback(&evt);
   1fd3e:	4b06      	ldr	r3, [pc, #24]	; (1fd58 <attsProcessDatabaseHashUpdate+0x94>)
   1fd40:	6f5b      	ldr	r3, [r3, #116]	; 0x74
   1fd42:	f107 0214 	add.w	r2, r7, #20
   1fd46:	4610      	mov	r0, r2
   1fd48:	4798      	blx	r3
}
   1fd4a:	bf00      	nop
   1fd4c:	3728      	adds	r7, #40	; 0x28
   1fd4e:	46bd      	mov	sp, r7
   1fd50:	bd80      	pop	{r7, pc}
   1fd52:	bf00      	nop
   1fd54:	00045afc 	.word	0x00045afc
   1fd58:	10011048 	.word	0x10011048

0001fd5c <attsCheckPendDbHashReadRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsCheckPendDbHashReadRsp(void)
{
   1fd5c:	b580      	push	{r7, lr}
   1fd5e:	b086      	sub	sp, #24
   1fd60:	af00      	add	r7, sp, #0
  for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   1fd62:	2300      	movs	r3, #0
   1fd64:	75fb      	strb	r3, [r7, #23]
   1fd66:	e07d      	b.n	1fe64 <attsCheckPendDbHashReadRsp+0x108>
  {
    attCcb_t *pCcb = &attCb.ccb[i];
   1fd68:	7dfa      	ldrb	r2, [r7, #23]
   1fd6a:	4613      	mov	r3, r2
   1fd6c:	00db      	lsls	r3, r3, #3
   1fd6e:	4413      	add	r3, r2
   1fd70:	009b      	lsls	r3, r3, #2
   1fd72:	4a41      	ldr	r2, [pc, #260]	; (1fe78 <attsCheckPendDbHashReadRsp+0x11c>)
   1fd74:	4413      	add	r3, r2
   1fd76:	613b      	str	r3, [r7, #16]

    if (pCcb->pPendDbHashRsp)
   1fd78:	693b      	ldr	r3, [r7, #16]
   1fd7a:	6a1b      	ldr	r3, [r3, #32]
   1fd7c:	2b00      	cmp	r3, #0
   1fd7e:	d06e      	beq.n	1fe5e <attsCheckPendDbHashReadRsp+0x102>
    {
      uint8_t *pBuf;

      /* allocate max size buffer for response */
      if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   1fd80:	693b      	ldr	r3, [r7, #16]
   1fd82:	8b5b      	ldrh	r3, [r3, #26]
   1fd84:	3308      	adds	r3, #8
   1fd86:	b29b      	uxth	r3, r3
   1fd88:	4618      	mov	r0, r3
   1fd8a:	f7fd fe2d 	bl	1d9e8 <attMsgAlloc>
   1fd8e:	60f8      	str	r0, [r7, #12]
   1fd90:	68fb      	ldr	r3, [r7, #12]
   1fd92:	2b00      	cmp	r3, #0
   1fd94:	d051      	beq.n	1fe3a <attsCheckPendDbHashReadRsp+0xde>
      {
        uint8_t *p;
        attsAttr_t  *pAttr;
        attsGroup_t *pGroup;

        p = pBuf + L2C_PAYLOAD_START;
   1fd96:	68fb      	ldr	r3, [r7, #12]
   1fd98:	3308      	adds	r3, #8
   1fd9a:	60bb      	str	r3, [r7, #8]
        UINT8_TO_BSTREAM(p, ATT_PDU_READ_TYPE_RSP);
   1fd9c:	68bb      	ldr	r3, [r7, #8]
   1fd9e:	1c5a      	adds	r2, r3, #1
   1fda0:	60ba      	str	r2, [r7, #8]
   1fda2:	2209      	movs	r2, #9
   1fda4:	701a      	strb	r2, [r3, #0]

        /* set length parameter in response message */
        UINT8_TO_BSTREAM(p, ATT_DATABASE_HASH_LEN + sizeof(uint16_t));
   1fda6:	68bb      	ldr	r3, [r7, #8]
   1fda8:	1c5a      	adds	r2, r3, #1
   1fdaa:	60ba      	str	r2, [r7, #8]
   1fdac:	2212      	movs	r2, #18
   1fdae:	701a      	strb	r2, [r3, #0]

        /* copy result to response message */
        UINT16_TO_BSTREAM(p, pCcb->pPendDbHashRsp->handle);
   1fdb0:	693b      	ldr	r3, [r7, #16]
   1fdb2:	6a1b      	ldr	r3, [r3, #32]
   1fdb4:	8859      	ldrh	r1, [r3, #2]
   1fdb6:	68bb      	ldr	r3, [r7, #8]
   1fdb8:	1c5a      	adds	r2, r3, #1
   1fdba:	60ba      	str	r2, [r7, #8]
   1fdbc:	b2ca      	uxtb	r2, r1
   1fdbe:	701a      	strb	r2, [r3, #0]
   1fdc0:	693b      	ldr	r3, [r7, #16]
   1fdc2:	6a1b      	ldr	r3, [r3, #32]
   1fdc4:	885b      	ldrh	r3, [r3, #2]
   1fdc6:	0a1b      	lsrs	r3, r3, #8
   1fdc8:	b299      	uxth	r1, r3
   1fdca:	68bb      	ldr	r3, [r7, #8]
   1fdcc:	1c5a      	adds	r2, r3, #1
   1fdce:	60ba      	str	r2, [r7, #8]
   1fdd0:	b2ca      	uxtb	r2, r1
   1fdd2:	701a      	strb	r2, [r3, #0]

        if ((pAttr = attsFindByHandle(pCcb->pPendDbHashRsp->handle, &pGroup)) != NULL)
   1fdd4:	693b      	ldr	r3, [r7, #16]
   1fdd6:	6a1b      	ldr	r3, [r3, #32]
   1fdd8:	885b      	ldrh	r3, [r3, #2]
   1fdda:	463a      	mov	r2, r7
   1fddc:	4611      	mov	r1, r2
   1fdde:	4618      	mov	r0, r3
   1fde0:	f000 fa80 	bl	202e4 <attsFindByHandle>
   1fde4:	6078      	str	r0, [r7, #4]
   1fde6:	687b      	ldr	r3, [r7, #4]
   1fde8:	2b00      	cmp	r3, #0
   1fdea:	d01b      	beq.n	1fe24 <attsCheckPendDbHashReadRsp+0xc8>
        {
          memcpy(p, pAttr->pValue, *pAttr->pLen);
   1fdec:	687b      	ldr	r3, [r7, #4]
   1fdee:	6859      	ldr	r1, [r3, #4]
   1fdf0:	687b      	ldr	r3, [r7, #4]
   1fdf2:	689b      	ldr	r3, [r3, #8]
   1fdf4:	881b      	ldrh	r3, [r3, #0]
   1fdf6:	461a      	mov	r2, r3
   1fdf8:	68b8      	ldr	r0, [r7, #8]
   1fdfa:	f7f8 fa2b 	bl	18254 <memcpy>
          p += *pAttr->pLen;
   1fdfe:	687b      	ldr	r3, [r7, #4]
   1fe00:	689b      	ldr	r3, [r3, #8]
   1fe02:	881b      	ldrh	r3, [r3, #0]
   1fe04:	461a      	mov	r2, r3
   1fe06:	68bb      	ldr	r3, [r7, #8]
   1fe08:	4413      	add	r3, r2
   1fe0a:	60bb      	str	r3, [r7, #8]

          L2cDataReq(L2C_CID_ATT, pCcb->handle, p - (pBuf + L2C_PAYLOAD_START), pBuf);
   1fe0c:	693b      	ldr	r3, [r7, #16]
   1fe0e:	8b19      	ldrh	r1, [r3, #24]
   1fe10:	68fb      	ldr	r3, [r7, #12]
   1fe12:	3308      	adds	r3, #8
   1fe14:	68ba      	ldr	r2, [r7, #8]
   1fe16:	1ad3      	subs	r3, r2, r3
   1fe18:	b29a      	uxth	r2, r3
   1fe1a:	68fb      	ldr	r3, [r7, #12]
   1fe1c:	2004      	movs	r0, #4
   1fe1e:	f00a f863 	bl	29ee8 <L2cDataReq>
   1fe22:	e014      	b.n	1fe4e <attsCheckPendDbHashReadRsp+0xf2>
        }
        else
        {
          attsErrRsp(pCcb->connId, ATT_PDU_READ_TYPE_REQ, pCcb->pPendDbHashRsp->startHandle, ATT_ERR_NOT_FOUND);
   1fe24:	693b      	ldr	r3, [r7, #16]
   1fe26:	7f1b      	ldrb	r3, [r3, #28]
   1fe28:	b298      	uxth	r0, r3
   1fe2a:	693b      	ldr	r3, [r7, #16]
   1fe2c:	6a1b      	ldr	r3, [r3, #32]
   1fe2e:	881a      	ldrh	r2, [r3, #0]
   1fe30:	230a      	movs	r3, #10
   1fe32:	2108      	movs	r1, #8
   1fe34:	f7ff fec0 	bl	1fbb8 <attsErrRsp>
   1fe38:	e009      	b.n	1fe4e <attsCheckPendDbHashReadRsp+0xf2>
        }
      }
      else
      {
        attsErrRsp(pCcb->connId, ATT_PDU_READ_TYPE_REQ, pCcb->pPendDbHashRsp->startHandle, ATT_ERR_RESOURCES);
   1fe3a:	693b      	ldr	r3, [r7, #16]
   1fe3c:	7f1b      	ldrb	r3, [r3, #28]
   1fe3e:	b298      	uxth	r0, r3
   1fe40:	693b      	ldr	r3, [r7, #16]
   1fe42:	6a1b      	ldr	r3, [r3, #32]
   1fe44:	881a      	ldrh	r2, [r3, #0]
   1fe46:	2311      	movs	r3, #17
   1fe48:	2108      	movs	r1, #8
   1fe4a:	f7ff feb5 	bl	1fbb8 <attsErrRsp>
      }

      /* Free pending state information. */
      WsfBufFree(pCcb->pPendDbHashRsp);
   1fe4e:	693b      	ldr	r3, [r7, #16]
   1fe50:	6a1b      	ldr	r3, [r3, #32]
   1fe52:	4618      	mov	r0, r3
   1fe54:	f00d f8dc 	bl	2d010 <WsfBufFree>
      pCcb->pPendDbHashRsp = NULL;
   1fe58:	693b      	ldr	r3, [r7, #16]
   1fe5a:	2200      	movs	r2, #0
   1fe5c:	621a      	str	r2, [r3, #32]
  for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   1fe5e:	7dfb      	ldrb	r3, [r7, #23]
   1fe60:	3301      	adds	r3, #1
   1fe62:	75fb      	strb	r3, [r7, #23]
   1fe64:	7dfb      	ldrb	r3, [r7, #23]
   1fe66:	2b02      	cmp	r3, #2
   1fe68:	f67f af7e 	bls.w	1fd68 <attsCheckPendDbHashReadRsp+0xc>
    }
  }
}
   1fe6c:	bf00      	nop
   1fe6e:	bf00      	nop
   1fe70:	3718      	adds	r7, #24
   1fe72:	46bd      	mov	sp, r7
   1fe74:	bd80      	pop	{r7, pc}
   1fe76:	bf00      	nop
   1fe78:	10011048 	.word	0x10011048

0001fe7c <attsIsHashableAttr>:
 *        Characteristic Format, and Characteristic Aggreate Format which contribute their ATT
 *        handle and ATT type.
 */
/*************************************************************************************************/
uint16_t attsIsHashableAttr(attsAttr_t *pAttr)
{
   1fe7c:	b480      	push	{r7}
   1fe7e:	b085      	sub	sp, #20
   1fe80:	af00      	add	r7, sp, #0
   1fe82:	6078      	str	r0, [r7, #4]
  /* Initialize length to 2 for ATT Handle length */
  uint16_t length = 2;
   1fe84:	2302      	movs	r3, #2
   1fe86:	81fb      	strh	r3, [r7, #14]
  uint16_t uuid;
  static bool_t isAttrCharVal = FALSE;

  /* Characteristic values are skipped */
  if (isAttrCharVal)
   1fe88:	4b2c      	ldr	r3, [pc, #176]	; (1ff3c <attsIsHashableAttr+0xc0>)
   1fe8a:	781b      	ldrb	r3, [r3, #0]
   1fe8c:	2b00      	cmp	r3, #0
   1fe8e:	d004      	beq.n	1fe9a <attsIsHashableAttr+0x1e>
  {
    isAttrCharVal = FALSE;
   1fe90:	4b2a      	ldr	r3, [pc, #168]	; (1ff3c <attsIsHashableAttr+0xc0>)
   1fe92:	2200      	movs	r2, #0
   1fe94:	701a      	strb	r2, [r3, #0]
    return 0;
   1fe96:	2300      	movs	r3, #0
   1fe98:	e049      	b.n	1ff2e <attsIsHashableAttr+0xb2>
  }

  BYTES_TO_UINT16(uuid, pAttr->pUuid);
   1fe9a:	687b      	ldr	r3, [r7, #4]
   1fe9c:	681b      	ldr	r3, [r3, #0]
   1fe9e:	781b      	ldrb	r3, [r3, #0]
   1fea0:	b29a      	uxth	r2, r3
   1fea2:	687b      	ldr	r3, [r7, #4]
   1fea4:	681b      	ldr	r3, [r3, #0]
   1fea6:	3301      	adds	r3, #1
   1fea8:	781b      	ldrb	r3, [r3, #0]
   1feaa:	b29b      	uxth	r3, r3
   1feac:	021b      	lsls	r3, r3, #8
   1feae:	b29b      	uxth	r3, r3
   1feb0:	4413      	add	r3, r2
   1feb2:	81bb      	strh	r3, [r7, #12]
  switch (uuid)
   1feb4:	89bb      	ldrh	r3, [r7, #12]
   1feb6:	f642 1205 	movw	r2, #10501	; 0x2905
   1feba:	4293      	cmp	r3, r2
   1febc:	d025      	beq.n	1ff0a <attsIsHashableAttr+0x8e>
   1febe:	f642 1205 	movw	r2, #10501	; 0x2905
   1fec2:	4293      	cmp	r3, r2
   1fec4:	dc2f      	bgt.n	1ff26 <attsIsHashableAttr+0xaa>
   1fec6:	f642 1203 	movw	r2, #10499	; 0x2903
   1feca:	4293      	cmp	r3, r2
   1fecc:	dc2b      	bgt.n	1ff26 <attsIsHashableAttr+0xaa>
   1fece:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   1fed2:	dc1a      	bgt.n	1ff0a <attsIsHashableAttr+0x8e>
   1fed4:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   1fed8:	d011      	beq.n	1fefe <attsIsHashableAttr+0x82>
   1feda:	f5b3 5f24 	cmp.w	r3, #10496	; 0x2900
   1fede:	dc22      	bgt.n	1ff26 <attsIsHashableAttr+0xaa>
   1fee0:	f642 0202 	movw	r2, #10242	; 0x2802
   1fee4:	4293      	cmp	r3, r2
   1fee6:	dc03      	bgt.n	1fef0 <attsIsHashableAttr+0x74>
   1fee8:	f5b3 5f20 	cmp.w	r3, #10240	; 0x2800
   1feec:	da07      	bge.n	1fefe <attsIsHashableAttr+0x82>
   1feee:	e01a      	b.n	1ff26 <attsIsHashableAttr+0xaa>
   1fef0:	f642 0203 	movw	r2, #10243	; 0x2803
   1fef4:	4293      	cmp	r3, r2
   1fef6:	d116      	bne.n	1ff26 <attsIsHashableAttr+0xaa>
  {
    /* Top cases include Attribute Value length */
    case ATT_UUID_CHARACTERISTIC:
      /* Set the next characteristic in database to be skipped */
      isAttrCharVal = TRUE;
   1fef8:	4b10      	ldr	r3, [pc, #64]	; (1ff3c <attsIsHashableAttr+0xc0>)
   1fefa:	2201      	movs	r2, #1
   1fefc:	701a      	strb	r2, [r3, #0]
      /* no break */
    case ATT_UUID_PRIMARY_SERVICE:
    case ATT_UUID_SECONDARY_SERVICE:
    case ATT_UUID_INCLUDE:
    case ATT_UUID_CHARACTERISTIC_EXT:
      length += *pAttr->pLen;
   1fefe:	687b      	ldr	r3, [r7, #4]
   1ff00:	689b      	ldr	r3, [r3, #8]
   1ff02:	881a      	ldrh	r2, [r3, #0]
   1ff04:	89fb      	ldrh	r3, [r7, #14]
   1ff06:	4413      	add	r3, r2
   1ff08:	81fb      	strh	r3, [r7, #14]
    /* All values fall through to include Attribute Type length */
    case ATT_UUID_CHAR_USER_DESC:
    case ATT_UUID_CLIENT_CHAR_CONFIG:
    case ATT_UUID_SERVER_CHAR_CONFIG:
    case ATT_UUID_AGGREGATE_FORMAT:
      if (pAttr->settings & ATTS_SET_UUID_128)
   1ff0a:	687b      	ldr	r3, [r7, #4]
   1ff0c:	7b9b      	ldrb	r3, [r3, #14]
   1ff0e:	f003 0301 	and.w	r3, r3, #1
   1ff12:	2b00      	cmp	r3, #0
   1ff14:	d003      	beq.n	1ff1e <attsIsHashableAttr+0xa2>
      {
        length += 16;
   1ff16:	89fb      	ldrh	r3, [r7, #14]
   1ff18:	3310      	adds	r3, #16
   1ff1a:	81fb      	strh	r3, [r7, #14]
      }
      else
      {
        length += 2;
      }
      break;
   1ff1c:	e006      	b.n	1ff2c <attsIsHashableAttr+0xb0>
        length += 2;
   1ff1e:	89fb      	ldrh	r3, [r7, #14]
   1ff20:	3302      	adds	r3, #2
   1ff22:	81fb      	strh	r3, [r7, #14]
      break;
   1ff24:	e002      	b.n	1ff2c <attsIsHashableAttr+0xb0>

    default:
      length = 0;
   1ff26:	2300      	movs	r3, #0
   1ff28:	81fb      	strh	r3, [r7, #14]
      break;
   1ff2a:	bf00      	nop
  }

  return length;
   1ff2c:	89fb      	ldrh	r3, [r7, #14]
}
   1ff2e:	4618      	mov	r0, r3
   1ff30:	3714      	adds	r7, #20
   1ff32:	46bd      	mov	sp, r7
   1ff34:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ff38:	4770      	bx	lr
   1ff3a:	bf00      	nop
   1ff3c:	10003f4c 	.word	0x10003f4c

0001ff40 <AttsInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsInit(void)
{
   1ff40:	b480      	push	{r7}
   1ff42:	af00      	add	r7, sp, #0
  /* Initialize control block */
  WSF_QUEUE_INIT(&attsCb.groupQueue);
   1ff44:	4b09      	ldr	r3, [pc, #36]	; (1ff6c <AttsInit+0x2c>)
   1ff46:	2200      	movs	r2, #0
   1ff48:	601a      	str	r2, [r3, #0]
   1ff4a:	4b08      	ldr	r3, [pc, #32]	; (1ff6c <AttsInit+0x2c>)
   1ff4c:	2200      	movs	r2, #0
   1ff4e:	605a      	str	r2, [r3, #4]
  attsCb.pInd = &attFcnDefault;
   1ff50:	4b06      	ldr	r3, [pc, #24]	; (1ff6c <AttsInit+0x2c>)
   1ff52:	4a07      	ldr	r2, [pc, #28]	; (1ff70 <AttsInit+0x30>)
   1ff54:	609a      	str	r2, [r3, #8]
  attsCb.signMsgCback = (attMsgHandler_t) attEmptyHandler;
   1ff56:	4b05      	ldr	r3, [pc, #20]	; (1ff6c <AttsInit+0x2c>)
   1ff58:	4a06      	ldr	r2, [pc, #24]	; (1ff74 <AttsInit+0x34>)
   1ff5a:	60da      	str	r2, [r3, #12]

  /* set up callback interfaces */
  attCb.pServer = &attsFcnIf;
   1ff5c:	4b06      	ldr	r3, [pc, #24]	; (1ff78 <AttsInit+0x38>)
   1ff5e:	4a07      	ldr	r2, [pc, #28]	; (1ff7c <AttsInit+0x3c>)
   1ff60:	671a      	str	r2, [r3, #112]	; 0x70
}
   1ff62:	bf00      	nop
   1ff64:	46bd      	mov	sp, r7
   1ff66:	f85d 7b04 	ldr.w	r7, [sp], #4
   1ff6a:	4770      	bx	lr
   1ff6c:	100111dc 	.word	0x100111dc
   1ff70:	00045ab4 	.word	0x00045ab4
   1ff74:	0001d859 	.word	0x0001d859
   1ff78:	10011048 	.word	0x10011048
   1ff7c:	00045b98 	.word	0x00045b98

0001ff80 <AttsHashDatabaseString>:
 *
 *  \return \ref TRUE if successful, \ref FALSE if not.
 */
/*************************************************************************************************/
bool_t AttsHashDatabaseString(uint8_t *pKey, uint8_t *pMsg, uint16_t msgLen)
{
   1ff80:	b580      	push	{r7, lr}
   1ff82:	b086      	sub	sp, #24
   1ff84:	af02      	add	r7, sp, #8
   1ff86:	60f8      	str	r0, [r7, #12]
   1ff88:	60b9      	str	r1, [r7, #8]
   1ff8a:	4613      	mov	r3, r2
   1ff8c:	80fb      	strh	r3, [r7, #6]
  return SecCmac(pKey, pMsg, msgLen, attCb.handlerId, 0, ATTS_MSG_DBH_CMAC_CMPL);
   1ff8e:	4b08      	ldr	r3, [pc, #32]	; (1ffb0 <AttsHashDatabaseString+0x30>)
   1ff90:	f893 307c 	ldrb.w	r3, [r3, #124]	; 0x7c
   1ff94:	88fa      	ldrh	r2, [r7, #6]
   1ff96:	2124      	movs	r1, #36	; 0x24
   1ff98:	9101      	str	r1, [sp, #4]
   1ff9a:	2100      	movs	r1, #0
   1ff9c:	9100      	str	r1, [sp, #0]
   1ff9e:	68b9      	ldr	r1, [r7, #8]
   1ffa0:	68f8      	ldr	r0, [r7, #12]
   1ffa2:	f00b fb33 	bl	2b60c <SecCmac>
   1ffa6:	4603      	mov	r3, r0
}
   1ffa8:	4618      	mov	r0, r3
   1ffaa:	3710      	adds	r7, #16
   1ffac:	46bd      	mov	sp, r7
   1ffae:	bd80      	pop	{r7, pc}
   1ffb0:	10011048 	.word	0x10011048

0001ffb4 <AttsCalculateDbHash>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsCalculateDbHash(void)
{
   1ffb4:	b580      	push	{r7, lr}
   1ffb6:	b08e      	sub	sp, #56	; 0x38
   1ffb8:	af00      	add	r7, sp, #0
  uint16_t msgLen = 0;
   1ffba:	2300      	movs	r3, #0
   1ffbc:	86fb      	strh	r3, [r7, #54]	; 0x36
  uint8_t *pMsg;
  attsGroup_t *pGroup = (attsGroup_t *) attsCb.groupQueue.pHead;
   1ffbe:	4b60      	ldr	r3, [pc, #384]	; (20140 <AttsCalculateDbHash+0x18c>)
   1ffc0:	681b      	ldr	r3, [r3, #0]
   1ffc2:	633b      	str	r3, [r7, #48]	; 0x30

  /* Determine length of message. */
  while (pGroup != NULL)
   1ffc4:	e025      	b.n	20012 <AttsCalculateDbHash+0x5e>
  {
    uint8_t numAttrs = (pGroup->endHandle - pGroup->startHandle) + 1;
   1ffc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1ffc8:	8a5b      	ldrh	r3, [r3, #18]
   1ffca:	b2da      	uxtb	r2, r3
   1ffcc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1ffce:	8a1b      	ldrh	r3, [r3, #16]
   1ffd0:	b2db      	uxtb	r3, r3
   1ffd2:	1ad3      	subs	r3, r2, r3
   1ffd4:	b2db      	uxtb	r3, r3
   1ffd6:	3301      	adds	r3, #1
   1ffd8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    for (attsAttr_t *pAttr = pGroup->pAttr; numAttrs != 0; numAttrs--, pAttr++)
   1ffdc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   1ffde:	685b      	ldr	r3, [r3, #4]
   1ffe0:	62bb      	str	r3, [r7, #40]	; 0x28
   1ffe2:	e00f      	b.n	20004 <AttsCalculateDbHash+0x50>
    {
      msgLen += attsIsHashableAttr(pAttr);
   1ffe4:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   1ffe6:	f7ff ff49 	bl	1fe7c <attsIsHashableAttr>
   1ffea:	4603      	mov	r3, r0
   1ffec:	461a      	mov	r2, r3
   1ffee:	8efb      	ldrh	r3, [r7, #54]	; 0x36
   1fff0:	4413      	add	r3, r2
   1fff2:	86fb      	strh	r3, [r7, #54]	; 0x36
    for (attsAttr_t *pAttr = pGroup->pAttr; numAttrs != 0; numAttrs--, pAttr++)
   1fff4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   1fff8:	3b01      	subs	r3, #1
   1fffa:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   1fffe:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20000:	3310      	adds	r3, #16
   20002:	62bb      	str	r3, [r7, #40]	; 0x28
   20004:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   20008:	2b00      	cmp	r3, #0
   2000a:	d1eb      	bne.n	1ffe4 <AttsCalculateDbHash+0x30>
    }

    pGroup = pGroup->pNext;
   2000c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2000e:	681b      	ldr	r3, [r3, #0]
   20010:	633b      	str	r3, [r7, #48]	; 0x30
  while (pGroup != NULL)
   20012:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20014:	2b00      	cmp	r3, #0
   20016:	d1d6      	bne.n	1ffc6 <AttsCalculateDbHash+0x12>
  }

  /* Allocate buffer for message. */
  if ((pMsg = WsfBufAlloc(msgLen)) != NULL)
   20018:	8efb      	ldrh	r3, [r7, #54]	; 0x36
   2001a:	4618      	mov	r0, r3
   2001c:	f00c ffb8 	bl	2cf90 <WsfBufAlloc>
   20020:	6178      	str	r0, [r7, #20]
   20022:	697b      	ldr	r3, [r7, #20]
   20024:	2b00      	cmp	r3, #0
   20026:	f000 8088 	beq.w	2013a <AttsCalculateDbHash+0x186>
  {
    pGroup = (attsGroup_t *)attsCb.groupQueue.pHead;
   2002a:	4b45      	ldr	r3, [pc, #276]	; (20140 <AttsCalculateDbHash+0x18c>)
   2002c:	681b      	ldr	r3, [r3, #0]
   2002e:	633b      	str	r3, [r7, #48]	; 0x30
    uint8_t hashingKey[16] = { 0, };
   20030:	2300      	movs	r3, #0
   20032:	603b      	str	r3, [r7, #0]
   20034:	1d3b      	adds	r3, r7, #4
   20036:	2200      	movs	r2, #0
   20038:	601a      	str	r2, [r3, #0]
   2003a:	605a      	str	r2, [r3, #4]
   2003c:	609a      	str	r2, [r3, #8]
    uint8_t *p = pMsg;
   2003e:	697b      	ldr	r3, [r7, #20]
   20040:	627b      	str	r3, [r7, #36]	; 0x24

    /* For each service in services */
    while (pGroup)
   20042:	e06f      	b.n	20124 <AttsCalculateDbHash+0x170>
    {
      uint16_t attHandle = pGroup->startHandle;
   20044:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20046:	8a1b      	ldrh	r3, [r3, #16]
   20048:	847b      	strh	r3, [r7, #34]	; 0x22

      /* For each attribute in the service */
      for (attsAttr_t *pAttr = pGroup->pAttr; attHandle <= pGroup->endHandle; attHandle++, pAttr++)
   2004a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2004c:	685b      	ldr	r3, [r3, #4]
   2004e:	61fb      	str	r3, [r7, #28]
   20050:	e060      	b.n	20114 <AttsCalculateDbHash+0x160>
      {
        uint16_t valLen;
        uint8_t uuidLen = 2;
   20052:	2302      	movs	r3, #2
   20054:	76fb      	strb	r3, [r7, #27]

        valLen = attsIsHashableAttr(pAttr);
   20056:	69f8      	ldr	r0, [r7, #28]
   20058:	f7ff ff10 	bl	1fe7c <attsIsHashableAttr>
   2005c:	4603      	mov	r3, r0
   2005e:	827b      	strh	r3, [r7, #18]
        if (valLen)
   20060:	8a7b      	ldrh	r3, [r7, #18]
   20062:	2b00      	cmp	r3, #0
   20064:	d050      	beq.n	20108 <AttsCalculateDbHash+0x154>
        {
          /* Add handle */
          UINT16_TO_BSTREAM(p, attHandle);
   20066:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20068:	1c5a      	adds	r2, r3, #1
   2006a:	627a      	str	r2, [r7, #36]	; 0x24
   2006c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   2006e:	b2d2      	uxtb	r2, r2
   20070:	701a      	strb	r2, [r3, #0]
   20072:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   20074:	0a1b      	lsrs	r3, r3, #8
   20076:	b299      	uxth	r1, r3
   20078:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2007a:	1c5a      	adds	r2, r3, #1
   2007c:	627a      	str	r2, [r7, #36]	; 0x24
   2007e:	b2ca      	uxtb	r2, r1
   20080:	701a      	strb	r2, [r3, #0]

          /* Add attribute type*/
          if (pAttr->settings & ATTS_SET_UUID_128)
   20082:	69fb      	ldr	r3, [r7, #28]
   20084:	7b9b      	ldrb	r3, [r3, #14]
   20086:	f003 0301 	and.w	r3, r3, #1
   2008a:	2b00      	cmp	r3, #0
   2008c:	d00c      	beq.n	200a8 <AttsCalculateDbHash+0xf4>
          {
            memcpy(p, pAttr->pUuid, 16);
   2008e:	69fb      	ldr	r3, [r7, #28]
   20090:	681b      	ldr	r3, [r3, #0]
   20092:	2210      	movs	r2, #16
   20094:	4619      	mov	r1, r3
   20096:	6a78      	ldr	r0, [r7, #36]	; 0x24
   20098:	f7f8 f8dc 	bl	18254 <memcpy>
            p += 16;
   2009c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2009e:	3310      	adds	r3, #16
   200a0:	627b      	str	r3, [r7, #36]	; 0x24
            uuidLen = 16;
   200a2:	2310      	movs	r3, #16
   200a4:	76fb      	strb	r3, [r7, #27]
   200a6:	e01a      	b.n	200de <AttsCalculateDbHash+0x12a>
          }
          else
          {
            uint16_t uuid;
            BYTES_TO_UINT16(uuid, pAttr->pUuid);
   200a8:	69fb      	ldr	r3, [r7, #28]
   200aa:	681b      	ldr	r3, [r3, #0]
   200ac:	781b      	ldrb	r3, [r3, #0]
   200ae:	b29a      	uxth	r2, r3
   200b0:	69fb      	ldr	r3, [r7, #28]
   200b2:	681b      	ldr	r3, [r3, #0]
   200b4:	3301      	adds	r3, #1
   200b6:	781b      	ldrb	r3, [r3, #0]
   200b8:	b29b      	uxth	r3, r3
   200ba:	021b      	lsls	r3, r3, #8
   200bc:	b29b      	uxth	r3, r3
   200be:	4413      	add	r3, r2
   200c0:	823b      	strh	r3, [r7, #16]
            UINT16_TO_BSTREAM(p,uuid);
   200c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   200c4:	1c5a      	adds	r2, r3, #1
   200c6:	627a      	str	r2, [r7, #36]	; 0x24
   200c8:	8a3a      	ldrh	r2, [r7, #16]
   200ca:	b2d2      	uxtb	r2, r2
   200cc:	701a      	strb	r2, [r3, #0]
   200ce:	8a3b      	ldrh	r3, [r7, #16]
   200d0:	0a1b      	lsrs	r3, r3, #8
   200d2:	b299      	uxth	r1, r3
   200d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   200d6:	1c5a      	adds	r2, r3, #1
   200d8:	627a      	str	r2, [r7, #36]	; 0x24
   200da:	b2ca      	uxtb	r2, r1
   200dc:	701a      	strb	r2, [r3, #0]
          }

          /* Add Attribute value if required */
          if (valLen - (uuidLen + 2))
   200de:	8a7a      	ldrh	r2, [r7, #18]
   200e0:	7efb      	ldrb	r3, [r7, #27]
   200e2:	3302      	adds	r3, #2
   200e4:	429a      	cmp	r2, r3
   200e6:	d00f      	beq.n	20108 <AttsCalculateDbHash+0x154>
          {
            memcpy(p, pAttr->pValue, *pAttr->pLen);
   200e8:	69fb      	ldr	r3, [r7, #28]
   200ea:	6859      	ldr	r1, [r3, #4]
   200ec:	69fb      	ldr	r3, [r7, #28]
   200ee:	689b      	ldr	r3, [r3, #8]
   200f0:	881b      	ldrh	r3, [r3, #0]
   200f2:	461a      	mov	r2, r3
   200f4:	6a78      	ldr	r0, [r7, #36]	; 0x24
   200f6:	f7f8 f8ad 	bl	18254 <memcpy>
            p += *pAttr->pLen;
   200fa:	69fb      	ldr	r3, [r7, #28]
   200fc:	689b      	ldr	r3, [r3, #8]
   200fe:	881b      	ldrh	r3, [r3, #0]
   20100:	461a      	mov	r2, r3
   20102:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20104:	4413      	add	r3, r2
   20106:	627b      	str	r3, [r7, #36]	; 0x24
      for (attsAttr_t *pAttr = pGroup->pAttr; attHandle <= pGroup->endHandle; attHandle++, pAttr++)
   20108:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   2010a:	3301      	adds	r3, #1
   2010c:	847b      	strh	r3, [r7, #34]	; 0x22
   2010e:	69fb      	ldr	r3, [r7, #28]
   20110:	3310      	adds	r3, #16
   20112:	61fb      	str	r3, [r7, #28]
   20114:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20116:	8a5b      	ldrh	r3, [r3, #18]
   20118:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   2011a:	429a      	cmp	r2, r3
   2011c:	d999      	bls.n	20052 <AttsCalculateDbHash+0x9e>
          }
        }
      }

      pGroup = pGroup->pNext;
   2011e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20120:	681b      	ldr	r3, [r3, #0]
   20122:	633b      	str	r3, [r7, #48]	; 0x30
    while (pGroup)
   20124:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   20126:	2b00      	cmp	r3, #0
   20128:	d18c      	bne.n	20044 <AttsCalculateDbHash+0x90>
    }

    /* Send to CMAC */
    if (AttsHashDatabaseString(hashingKey, pMsg, msgLen))
   2012a:	8efa      	ldrh	r2, [r7, #54]	; 0x36
   2012c:	463b      	mov	r3, r7
   2012e:	6979      	ldr	r1, [r7, #20]
   20130:	4618      	mov	r0, r3
   20132:	f7ff ff25 	bl	1ff80 <AttsHashDatabaseString>
   20136:	4603      	mov	r3, r0
   20138:	2b00      	cmp	r3, #0
    }
  }

  /* Assert on failure to initiate database hash generation. */
  WSF_ASSERT(FALSE);
}
   2013a:	3738      	adds	r7, #56	; 0x38
   2013c:	46bd      	mov	sp, r7
   2013e:	bd80      	pop	{r7, pc}
   20140:	100111dc 	.word	0x100111dc

00020144 <AttsAddGroup>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void AttsAddGroup(attsGroup_t *pGroup)
{
   20144:	b580      	push	{r7, lr}
   20146:	b084      	sub	sp, #16
   20148:	af00      	add	r7, sp, #0
   2014a:	6078      	str	r0, [r7, #4]
  attsGroup_t   *pElem;
  attsGroup_t   *pPrev = NULL;
   2014c:	2300      	movs	r3, #0
   2014e:	60bb      	str	r3, [r7, #8]

  /* task schedule lock */
  WsfTaskLock();
   20150:	f00d f858 	bl	2d204 <WsfTaskLock>

  pElem = (attsGroup_t *) attsCb.groupQueue.pHead;
   20154:	4b10      	ldr	r3, [pc, #64]	; (20198 <AttsAddGroup+0x54>)
   20156:	681b      	ldr	r3, [r3, #0]
   20158:	60fb      	str	r3, [r7, #12]

  /* iterate over queue sorted by increasing handle value */
  while (pElem != NULL)
   2015a:	e00a      	b.n	20172 <AttsAddGroup+0x2e>
  {
    if (pGroup->startHandle < pElem->startHandle)
   2015c:	687b      	ldr	r3, [r7, #4]
   2015e:	8a1a      	ldrh	r2, [r3, #16]
   20160:	68fb      	ldr	r3, [r7, #12]
   20162:	8a1b      	ldrh	r3, [r3, #16]
   20164:	429a      	cmp	r2, r3
   20166:	d308      	bcc.n	2017a <AttsAddGroup+0x36>
    {
      break;
    }
    pPrev = pElem;
   20168:	68fb      	ldr	r3, [r7, #12]
   2016a:	60bb      	str	r3, [r7, #8]
    pElem = pElem->pNext;
   2016c:	68fb      	ldr	r3, [r7, #12]
   2016e:	681b      	ldr	r3, [r3, #0]
   20170:	60fb      	str	r3, [r7, #12]
  while (pElem != NULL)
   20172:	68fb      	ldr	r3, [r7, #12]
   20174:	2b00      	cmp	r3, #0
   20176:	d1f1      	bne.n	2015c <AttsAddGroup+0x18>
   20178:	e000      	b.n	2017c <AttsAddGroup+0x38>
      break;
   2017a:	bf00      	nop
  }

  /* insert new group */
  WsfQueueInsert(&attsCb.groupQueue, pGroup, pPrev);
   2017c:	68ba      	ldr	r2, [r7, #8]
   2017e:	6879      	ldr	r1, [r7, #4]
   20180:	4805      	ldr	r0, [pc, #20]	; (20198 <AttsAddGroup+0x54>)
   20182:	f00d fa2c 	bl	2d5de <WsfQueueInsert>

  /* set database hash update status to true until a new hash is generated */
  attsCsfSetHashUpdateStatus(TRUE);
   20186:	2001      	movs	r0, #1
   20188:	f7fe ff96 	bl	1f0b8 <attsCsfSetHashUpdateStatus>

  /* task schedule unlock */
  WsfTaskUnlock();
   2018c:	f00d f840 	bl	2d210 <WsfTaskUnlock>
}
   20190:	bf00      	nop
   20192:	3710      	adds	r7, #16
   20194:	46bd      	mov	sp, r7
   20196:	bd80      	pop	{r7, pc}
   20198:	100111dc 	.word	0x100111dc

0002019c <AttsSetAttr>:
 *
 *  \return ATT_SUCCESS if successful otherwise error.
 */
/*************************************************************************************************/
uint8_t AttsSetAttr(uint16_t handle, uint16_t valueLen, uint8_t *pValue)
{
   2019c:	b580      	push	{r7, lr}
   2019e:	b086      	sub	sp, #24
   201a0:	af00      	add	r7, sp, #0
   201a2:	4603      	mov	r3, r0
   201a4:	603a      	str	r2, [r7, #0]
   201a6:	80fb      	strh	r3, [r7, #6]
   201a8:	460b      	mov	r3, r1
   201aa:	80bb      	strh	r3, [r7, #4]
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint8_t     err = ATT_SUCCESS;
   201ac:	2300      	movs	r3, #0
   201ae:	75fb      	strb	r3, [r7, #23]

  WsfTaskLock();
   201b0:	f00d f828 	bl	2d204 <WsfTaskLock>

  /* find attribute */
  if ((pAttr = attsFindByHandle(handle, &pGroup)) != NULL)
   201b4:	f107 020c 	add.w	r2, r7, #12
   201b8:	88fb      	ldrh	r3, [r7, #6]
   201ba:	4611      	mov	r1, r2
   201bc:	4618      	mov	r0, r3
   201be:	f000 f891 	bl	202e4 <attsFindByHandle>
   201c2:	6138      	str	r0, [r7, #16]
   201c4:	693b      	ldr	r3, [r7, #16]
   201c6:	2b00      	cmp	r3, #0
   201c8:	d019      	beq.n	201fe <AttsSetAttr+0x62>
  {
    /* verify write length */
    if (valueLen > pAttr->maxLen)
   201ca:	693b      	ldr	r3, [r7, #16]
   201cc:	899b      	ldrh	r3, [r3, #12]
   201ce:	88ba      	ldrh	r2, [r7, #4]
   201d0:	429a      	cmp	r2, r3
   201d2:	d902      	bls.n	201da <AttsSetAttr+0x3e>
    {
      err = ATT_ERR_LENGTH;
   201d4:	230d      	movs	r3, #13
   201d6:	75fb      	strb	r3, [r7, #23]
   201d8:	e013      	b.n	20202 <AttsSetAttr+0x66>
    }
    else
    {
      /* set attribute value */
      memcpy(pAttr->pValue, pValue, valueLen);
   201da:	693b      	ldr	r3, [r7, #16]
   201dc:	685b      	ldr	r3, [r3, #4]
   201de:	88ba      	ldrh	r2, [r7, #4]
   201e0:	6839      	ldr	r1, [r7, #0]
   201e2:	4618      	mov	r0, r3
   201e4:	f7f8 f836 	bl	18254 <memcpy>

      /* set the length if variable length attribute */
      if ((pAttr->settings & ATTS_SET_VARIABLE_LEN) != 0)
   201e8:	693b      	ldr	r3, [r7, #16]
   201ea:	7b9b      	ldrb	r3, [r3, #14]
   201ec:	f003 0308 	and.w	r3, r3, #8
   201f0:	2b00      	cmp	r3, #0
   201f2:	d006      	beq.n	20202 <AttsSetAttr+0x66>
      {
        *(pAttr->pLen) = valueLen;
   201f4:	693b      	ldr	r3, [r7, #16]
   201f6:	689b      	ldr	r3, [r3, #8]
   201f8:	88ba      	ldrh	r2, [r7, #4]
   201fa:	801a      	strh	r2, [r3, #0]
   201fc:	e001      	b.n	20202 <AttsSetAttr+0x66>
    }
  }
  /* else attribute not found */
  else
  {
    err = ATT_ERR_NOT_FOUND;
   201fe:	230a      	movs	r3, #10
   20200:	75fb      	strb	r3, [r7, #23]
  }

  WsfTaskUnlock();
   20202:	f00d f805 	bl	2d210 <WsfTaskUnlock>

  return err;
   20206:	7dfb      	ldrb	r3, [r7, #23]
}
   20208:	4618      	mov	r0, r3
   2020a:	3718      	adds	r7, #24
   2020c:	46bd      	mov	sp, r7
   2020e:	bd80      	pop	{r7, pc}

00020210 <attsUuidCmp>:
 *
 *  \return TRUE of UUIDs match, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t attsUuidCmp(attsAttr_t *pAttr, uint8_t uuidLen, uint8_t *pUuid)
{
   20210:	b580      	push	{r7, lr}
   20212:	b084      	sub	sp, #16
   20214:	af00      	add	r7, sp, #0
   20216:	60f8      	str	r0, [r7, #12]
   20218:	460b      	mov	r3, r1
   2021a:	607a      	str	r2, [r7, #4]
   2021c:	72fb      	strb	r3, [r7, #11]
  /* if both uuids are the same length */
  if ((((pAttr->settings & ATTS_SET_UUID_128) == 0) && (uuidLen == ATT_16_UUID_LEN)) ||
   2021e:	68fb      	ldr	r3, [r7, #12]
   20220:	7b9b      	ldrb	r3, [r3, #14]
   20222:	f003 0301 	and.w	r3, r3, #1
   20226:	2b00      	cmp	r3, #0
   20228:	d102      	bne.n	20230 <attsUuidCmp+0x20>
   2022a:	7afb      	ldrb	r3, [r7, #11]
   2022c:	2b02      	cmp	r3, #2
   2022e:	d008      	beq.n	20242 <attsUuidCmp+0x32>
      (((pAttr->settings & ATTS_SET_UUID_128) != 0) &&  (uuidLen == ATT_128_UUID_LEN)))
   20230:	68fb      	ldr	r3, [r7, #12]
   20232:	7b9b      	ldrb	r3, [r3, #14]
   20234:	f003 0301 	and.w	r3, r3, #1
  if ((((pAttr->settings & ATTS_SET_UUID_128) == 0) && (uuidLen == ATT_16_UUID_LEN)) ||
   20238:	2b00      	cmp	r3, #0
   2023a:	d010      	beq.n	2025e <attsUuidCmp+0x4e>
      (((pAttr->settings & ATTS_SET_UUID_128) != 0) &&  (uuidLen == ATT_128_UUID_LEN)))
   2023c:	7afb      	ldrb	r3, [r7, #11]
   2023e:	2b10      	cmp	r3, #16
   20240:	d10d      	bne.n	2025e <attsUuidCmp+0x4e>
  {
    /* simply compare the data */
    return (memcmp(pAttr->pUuid, pUuid, uuidLen) == 0);
   20242:	68fb      	ldr	r3, [r7, #12]
   20244:	681b      	ldr	r3, [r3, #0]
   20246:	7afa      	ldrb	r2, [r7, #11]
   20248:	6879      	ldr	r1, [r7, #4]
   2024a:	4618      	mov	r0, r3
   2024c:	f00f feb4 	bl	2ffb8 <memcmp>
   20250:	4603      	mov	r3, r0
   20252:	2b00      	cmp	r3, #0
   20254:	bf0c      	ite	eq
   20256:	2301      	moveq	r3, #1
   20258:	2300      	movne	r3, #0
   2025a:	b2db      	uxtb	r3, r3
   2025c:	e017      	b.n	2028e <attsUuidCmp+0x7e>
  }
  /* else we need to convert one of the uuids */
  else if (((pAttr->settings & ATTS_SET_UUID_128) == 0) && (uuidLen == ATT_128_UUID_LEN))
   2025e:	68fb      	ldr	r3, [r7, #12]
   20260:	7b9b      	ldrb	r3, [r3, #14]
   20262:	f003 0301 	and.w	r3, r3, #1
   20266:	2b00      	cmp	r3, #0
   20268:	d10a      	bne.n	20280 <attsUuidCmp+0x70>
   2026a:	7afb      	ldrb	r3, [r7, #11]
   2026c:	2b10      	cmp	r3, #16
   2026e:	d107      	bne.n	20280 <attsUuidCmp+0x70>
  {
    return attUuidCmp16to128(pAttr->pUuid, pUuid);
   20270:	68fb      	ldr	r3, [r7, #12]
   20272:	681b      	ldr	r3, [r3, #0]
   20274:	6879      	ldr	r1, [r7, #4]
   20276:	4618      	mov	r0, r3
   20278:	f7fd fb46 	bl	1d908 <attUuidCmp16to128>
   2027c:	4603      	mov	r3, r0
   2027e:	e006      	b.n	2028e <attsUuidCmp+0x7e>
  }
  else
  {
    return attUuidCmp16to128(pUuid, pAttr->pUuid);
   20280:	68fb      	ldr	r3, [r7, #12]
   20282:	681b      	ldr	r3, [r3, #0]
   20284:	4619      	mov	r1, r3
   20286:	6878      	ldr	r0, [r7, #4]
   20288:	f7fd fb3e 	bl	1d908 <attUuidCmp16to128>
   2028c:	4603      	mov	r3, r0
  }
}
   2028e:	4618      	mov	r0, r3
   20290:	3710      	adds	r7, #16
   20292:	46bd      	mov	sp, r7
   20294:	bd80      	pop	{r7, pc}

00020296 <attsUuid16Cmp>:
 *
 *  \return TRUE of UUIDs match, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t attsUuid16Cmp(uint8_t *pUuid16, uint8_t uuidLen, uint8_t *pUuid)
{
   20296:	b580      	push	{r7, lr}
   20298:	b084      	sub	sp, #16
   2029a:	af00      	add	r7, sp, #0
   2029c:	60f8      	str	r0, [r7, #12]
   2029e:	460b      	mov	r3, r1
   202a0:	607a      	str	r2, [r7, #4]
   202a2:	72fb      	strb	r3, [r7, #11]
  if (uuidLen == ATT_16_UUID_LEN)
   202a4:	7afb      	ldrb	r3, [r7, #11]
   202a6:	2b02      	cmp	r3, #2
   202a8:	d112      	bne.n	202d0 <attsUuid16Cmp+0x3a>
  {
    return ((pUuid16[0] == pUuid[0]) && (pUuid16[1] == pUuid[1]));
   202aa:	68fb      	ldr	r3, [r7, #12]
   202ac:	781a      	ldrb	r2, [r3, #0]
   202ae:	687b      	ldr	r3, [r7, #4]
   202b0:	781b      	ldrb	r3, [r3, #0]
   202b2:	429a      	cmp	r2, r3
   202b4:	d109      	bne.n	202ca <attsUuid16Cmp+0x34>
   202b6:	68fb      	ldr	r3, [r7, #12]
   202b8:	3301      	adds	r3, #1
   202ba:	781a      	ldrb	r2, [r3, #0]
   202bc:	687b      	ldr	r3, [r7, #4]
   202be:	3301      	adds	r3, #1
   202c0:	781b      	ldrb	r3, [r3, #0]
   202c2:	429a      	cmp	r2, r3
   202c4:	d101      	bne.n	202ca <attsUuid16Cmp+0x34>
   202c6:	2301      	movs	r3, #1
   202c8:	e000      	b.n	202cc <attsUuid16Cmp+0x36>
   202ca:	2300      	movs	r3, #0
   202cc:	b2db      	uxtb	r3, r3
   202ce:	e004      	b.n	202da <attsUuid16Cmp+0x44>
  }
  else
  {
    return attUuidCmp16to128(pUuid16, pUuid);
   202d0:	6879      	ldr	r1, [r7, #4]
   202d2:	68f8      	ldr	r0, [r7, #12]
   202d4:	f7fd fb18 	bl	1d908 <attUuidCmp16to128>
   202d8:	4603      	mov	r3, r0
  }
}
   202da:	4618      	mov	r0, r3
   202dc:	3710      	adds	r7, #16
   202de:	46bd      	mov	sp, r7
   202e0:	bd80      	pop	{r7, pc}
	...

000202e4 <attsFindByHandle>:
 *
 *  \return Pointer to attribute if found, othewise NULL.
 */
/*************************************************************************************************/
attsAttr_t *attsFindByHandle(uint16_t handle, attsGroup_t **pAttrGroup)
{
   202e4:	b480      	push	{r7}
   202e6:	b085      	sub	sp, #20
   202e8:	af00      	add	r7, sp, #0
   202ea:	4603      	mov	r3, r0
   202ec:	6039      	str	r1, [r7, #0]
   202ee:	80fb      	strh	r3, [r7, #6]
  attsGroup_t   *pGroup;

  /* iterate over attribute group list */
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   202f0:	4b13      	ldr	r3, [pc, #76]	; (20340 <attsFindByHandle+0x5c>)
   202f2:	681b      	ldr	r3, [r3, #0]
   202f4:	60fb      	str	r3, [r7, #12]
   202f6:	e018      	b.n	2032a <attsFindByHandle+0x46>
  {
    /*  if start handle within handle range of group */
    if ((handle >= pGroup->startHandle) && (handle <= pGroup->endHandle))
   202f8:	68fb      	ldr	r3, [r7, #12]
   202fa:	8a1b      	ldrh	r3, [r3, #16]
   202fc:	88fa      	ldrh	r2, [r7, #6]
   202fe:	429a      	cmp	r2, r3
   20300:	d310      	bcc.n	20324 <attsFindByHandle+0x40>
   20302:	68fb      	ldr	r3, [r7, #12]
   20304:	8a5b      	ldrh	r3, [r3, #18]
   20306:	88fa      	ldrh	r2, [r7, #6]
   20308:	429a      	cmp	r2, r3
   2030a:	d80b      	bhi.n	20324 <attsFindByHandle+0x40>
    {
      /* index by handle into attribute array to return attribute */
      *pAttrGroup = pGroup;
   2030c:	683b      	ldr	r3, [r7, #0]
   2030e:	68fa      	ldr	r2, [r7, #12]
   20310:	601a      	str	r2, [r3, #0]
      return &pGroup->pAttr[handle - pGroup->startHandle];
   20312:	68fb      	ldr	r3, [r7, #12]
   20314:	685a      	ldr	r2, [r3, #4]
   20316:	88fb      	ldrh	r3, [r7, #6]
   20318:	68f9      	ldr	r1, [r7, #12]
   2031a:	8a09      	ldrh	r1, [r1, #16]
   2031c:	1a5b      	subs	r3, r3, r1
   2031e:	011b      	lsls	r3, r3, #4
   20320:	4413      	add	r3, r2
   20322:	e006      	b.n	20332 <attsFindByHandle+0x4e>
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   20324:	68fb      	ldr	r3, [r7, #12]
   20326:	681b      	ldr	r3, [r3, #0]
   20328:	60fb      	str	r3, [r7, #12]
   2032a:	68fb      	ldr	r3, [r7, #12]
   2032c:	2b00      	cmp	r3, #0
   2032e:	d1e3      	bne.n	202f8 <attsFindByHandle+0x14>
    }
  }

  /* handle not found */
  return NULL;
   20330:	2300      	movs	r3, #0
}
   20332:	4618      	mov	r0, r3
   20334:	3714      	adds	r7, #20
   20336:	46bd      	mov	sp, r7
   20338:	f85d 7b04 	ldr.w	r7, [sp], #4
   2033c:	4770      	bx	lr
   2033e:	bf00      	nop
   20340:	100111dc 	.word	0x100111dc

00020344 <attsFindInRange>:
 *
 *  \return Attribute handle or ATT_HANDLE_NONE if not found.
 */
/*************************************************************************************************/
uint16_t attsFindInRange(uint16_t startHandle, uint16_t endHandle, attsAttr_t **pAttr)
{
   20344:	b480      	push	{r7}
   20346:	b085      	sub	sp, #20
   20348:	af00      	add	r7, sp, #0
   2034a:	4603      	mov	r3, r0
   2034c:	603a      	str	r2, [r7, #0]
   2034e:	80fb      	strh	r3, [r7, #6]
   20350:	460b      	mov	r3, r1
   20352:	80bb      	strh	r3, [r7, #4]
  attsGroup_t   *pGroup;

  /* iterate over attribute group list */
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   20354:	4b19      	ldr	r3, [pc, #100]	; (203bc <attsFindInRange+0x78>)
   20356:	681b      	ldr	r3, [r3, #0]
   20358:	60fb      	str	r3, [r7, #12]
   2035a:	e025      	b.n	203a8 <attsFindInRange+0x64>
  {
    /* if start handle is less than group start handle but handle range is within group */
    if ((startHandle < pGroup->startHandle) && (endHandle >= pGroup->startHandle))
   2035c:	68fb      	ldr	r3, [r7, #12]
   2035e:	8a1b      	ldrh	r3, [r3, #16]
   20360:	88fa      	ldrh	r2, [r7, #6]
   20362:	429a      	cmp	r2, r3
   20364:	d207      	bcs.n	20376 <attsFindInRange+0x32>
   20366:	68fb      	ldr	r3, [r7, #12]
   20368:	8a1b      	ldrh	r3, [r3, #16]
   2036a:	88ba      	ldrh	r2, [r7, #4]
   2036c:	429a      	cmp	r2, r3
   2036e:	d302      	bcc.n	20376 <attsFindInRange+0x32>
    {
      /* set start handle to first handle in group */
      startHandle = pGroup->startHandle;
   20370:	68fb      	ldr	r3, [r7, #12]
   20372:	8a1b      	ldrh	r3, [r3, #16]
   20374:	80fb      	strh	r3, [r7, #6]
    }

    /*  if start handle within handle range of group */
    if ((startHandle >= pGroup->startHandle) && (startHandle <= pGroup->endHandle))
   20376:	68fb      	ldr	r3, [r7, #12]
   20378:	8a1b      	ldrh	r3, [r3, #16]
   2037a:	88fa      	ldrh	r2, [r7, #6]
   2037c:	429a      	cmp	r2, r3
   2037e:	d310      	bcc.n	203a2 <attsFindInRange+0x5e>
   20380:	68fb      	ldr	r3, [r7, #12]
   20382:	8a5b      	ldrh	r3, [r3, #18]
   20384:	88fa      	ldrh	r2, [r7, #6]
   20386:	429a      	cmp	r2, r3
   20388:	d80b      	bhi.n	203a2 <attsFindInRange+0x5e>
    {
      /* index by handle into attribute array to return attribute */
      *pAttr = &pGroup->pAttr[startHandle - pGroup->startHandle];
   2038a:	68fb      	ldr	r3, [r7, #12]
   2038c:	685a      	ldr	r2, [r3, #4]
   2038e:	88fb      	ldrh	r3, [r7, #6]
   20390:	68f9      	ldr	r1, [r7, #12]
   20392:	8a09      	ldrh	r1, [r1, #16]
   20394:	1a5b      	subs	r3, r3, r1
   20396:	011b      	lsls	r3, r3, #4
   20398:	441a      	add	r2, r3
   2039a:	683b      	ldr	r3, [r7, #0]
   2039c:	601a      	str	r2, [r3, #0]
      return startHandle;
   2039e:	88fb      	ldrh	r3, [r7, #6]
   203a0:	e006      	b.n	203b0 <attsFindInRange+0x6c>
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   203a2:	68fb      	ldr	r3, [r7, #12]
   203a4:	681b      	ldr	r3, [r3, #0]
   203a6:	60fb      	str	r3, [r7, #12]
   203a8:	68fb      	ldr	r3, [r7, #12]
   203aa:	2b00      	cmp	r3, #0
   203ac:	d1d6      	bne.n	2035c <attsFindInRange+0x18>
    }
  }

  /* handle within range not found */
  return ATT_HANDLE_NONE;
   203ae:	2300      	movs	r3, #0
}
   203b0:	4618      	mov	r0, r3
   203b2:	3714      	adds	r7, #20
   203b4:	46bd      	mov	sp, r7
   203b6:	f85d 7b04 	ldr.w	r7, [sp], #4
   203ba:	4770      	bx	lr
   203bc:	100111dc 	.word	0x100111dc

000203c0 <attsPermissions>:
 *
 *  \return ATT_SUCCESS if successful or error code on failure.
 */
/*************************************************************************************************/
uint8_t attsPermissions(dmConnId_t connId, uint8_t permit, uint16_t handle, uint8_t permissions)
{
   203c0:	b590      	push	{r4, r7, lr}
   203c2:	b085      	sub	sp, #20
   203c4:	af00      	add	r7, sp, #0
   203c6:	4604      	mov	r4, r0
   203c8:	4608      	mov	r0, r1
   203ca:	4611      	mov	r1, r2
   203cc:	461a      	mov	r2, r3
   203ce:	4623      	mov	r3, r4
   203d0:	71fb      	strb	r3, [r7, #7]
   203d2:	4603      	mov	r3, r0
   203d4:	71bb      	strb	r3, [r7, #6]
   203d6:	460b      	mov	r3, r1
   203d8:	80bb      	strh	r3, [r7, #4]
   203da:	4613      	mov	r3, r2
   203dc:	70fb      	strb	r3, [r7, #3]
  uint8_t secLevel;

  /* verify read or write permissions */
  if (!(permissions & permit))
   203de:	78fa      	ldrb	r2, [r7, #3]
   203e0:	79bb      	ldrb	r3, [r7, #6]
   203e2:	4013      	ands	r3, r2
   203e4:	b2db      	uxtb	r3, r3
   203e6:	2b00      	cmp	r3, #0
   203e8:	d106      	bne.n	203f8 <attsPermissions+0x38>
  {
    return (permit == ATTS_PERMIT_READ) ? ATT_ERR_READ : ATT_ERR_WRITE;
   203ea:	79bb      	ldrb	r3, [r7, #6]
   203ec:	2b01      	cmp	r3, #1
   203ee:	d101      	bne.n	203f4 <attsPermissions+0x34>
   203f0:	2302      	movs	r3, #2
   203f2:	e03c      	b.n	2046e <attsPermissions+0xae>
   203f4:	2303      	movs	r3, #3
   203f6:	e03a      	b.n	2046e <attsPermissions+0xae>
  }

  /* convert write permissions to read permissions for easier masking */
  if (permit == ATTS_PERMIT_WRITE)
   203f8:	79bb      	ldrb	r3, [r7, #6]
   203fa:	2b10      	cmp	r3, #16
   203fc:	d102      	bne.n	20404 <attsPermissions+0x44>
  {
    permissions >>= 4;
   203fe:	78fb      	ldrb	r3, [r7, #3]
   20400:	091b      	lsrs	r3, r3, #4
   20402:	70fb      	strb	r3, [r7, #3]
  }

  /* if no security requirements return quickly */
  if ((permissions & (ATTS_PERMIT_READ_AUTH | ATTS_PERMIT_READ_AUTHORIZ | ATTS_PERMIT_READ_ENC)) == 0)
   20404:	78fb      	ldrb	r3, [r7, #3]
   20406:	f003 030e 	and.w	r3, r3, #14
   2040a:	2b00      	cmp	r3, #0
   2040c:	d101      	bne.n	20412 <attsPermissions+0x52>
  {
    return ATT_SUCCESS;
   2040e:	2300      	movs	r3, #0
   20410:	e02d      	b.n	2046e <attsPermissions+0xae>
  }

  /* get security level for this connection */
  secLevel = DmConnSecLevel(connId);
   20412:	79fb      	ldrb	r3, [r7, #7]
   20414:	4618      	mov	r0, r3
   20416:	f003 f89d 	bl	23554 <DmConnSecLevel>
   2041a:	4603      	mov	r3, r0
   2041c:	73fb      	strb	r3, [r7, #15]

  /* check if encryption required */
  if ((permissions & ATTS_PERMIT_READ_ENC) && (secLevel == DM_SEC_LEVEL_NONE))
   2041e:	78fb      	ldrb	r3, [r7, #3]
   20420:	f003 0308 	and.w	r3, r3, #8
   20424:	2b00      	cmp	r3, #0
   20426:	d004      	beq.n	20432 <attsPermissions+0x72>
   20428:	7bfb      	ldrb	r3, [r7, #15]
   2042a:	2b00      	cmp	r3, #0
   2042c:	d101      	bne.n	20432 <attsPermissions+0x72>
  {
    return ATT_ERR_AUTH;
   2042e:	2305      	movs	r3, #5
   20430:	e01d      	b.n	2046e <attsPermissions+0xae>
  }

  /* check if encryption required with authenticated key */
  if (((permissions & (ATTS_PERMIT_READ_AUTH | ATTS_PERMIT_READ_ENC)) ==
   20432:	78fb      	ldrb	r3, [r7, #3]
   20434:	f003 030a 	and.w	r3, r3, #10
   20438:	2b0a      	cmp	r3, #10
   2043a:	d104      	bne.n	20446 <attsPermissions+0x86>
       (ATTS_PERMIT_READ_AUTH | ATTS_PERMIT_READ_ENC)) && (secLevel < DM_SEC_LEVEL_ENC_AUTH))
   2043c:	7bfb      	ldrb	r3, [r7, #15]
   2043e:	2b01      	cmp	r3, #1
   20440:	d801      	bhi.n	20446 <attsPermissions+0x86>
  {
    return ATT_ERR_AUTH;
   20442:	2305      	movs	r3, #5
   20444:	e013      	b.n	2046e <attsPermissions+0xae>
  }

  /* authorization check */
  if (permissions & ATTS_PERMIT_READ_AUTHORIZ)
   20446:	78fb      	ldrb	r3, [r7, #3]
   20448:	f003 0304 	and.w	r3, r3, #4
   2044c:	2b00      	cmp	r3, #0
   2044e:	d00d      	beq.n	2046c <attsPermissions+0xac>
  {
    if (attsCb.authorCback == NULL)
   20450:	4b09      	ldr	r3, [pc, #36]	; (20478 <attsPermissions+0xb8>)
   20452:	691b      	ldr	r3, [r3, #16]
   20454:	2b00      	cmp	r3, #0
   20456:	d101      	bne.n	2045c <attsPermissions+0x9c>
    {
      return ATT_ERR_AUTHOR;
   20458:	2308      	movs	r3, #8
   2045a:	e008      	b.n	2046e <attsPermissions+0xae>
    }
    else
    {
      return (*attsCb.authorCback)(connId, permit, handle);
   2045c:	4b06      	ldr	r3, [pc, #24]	; (20478 <attsPermissions+0xb8>)
   2045e:	691b      	ldr	r3, [r3, #16]
   20460:	88ba      	ldrh	r2, [r7, #4]
   20462:	79b9      	ldrb	r1, [r7, #6]
   20464:	79f8      	ldrb	r0, [r7, #7]
   20466:	4798      	blx	r3
   20468:	4603      	mov	r3, r0
   2046a:	e000      	b.n	2046e <attsPermissions+0xae>
    }
  }
  else
  {
    return ATT_SUCCESS;
   2046c:	2300      	movs	r3, #0
  }
}
   2046e:	4618      	mov	r0, r3
   20470:	3714      	adds	r7, #20
   20472:	46bd      	mov	sp, r7
   20474:	bd90      	pop	{r4, r7, pc}
   20476:	bf00      	nop
   20478:	100111dc 	.word	0x100111dc

0002047c <attsProcMtuReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcMtuReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   2047c:	b590      	push	{r4, r7, lr}
   2047e:	b089      	sub	sp, #36	; 0x24
   20480:	af00      	add	r7, sp, #0
   20482:	60f8      	str	r0, [r7, #12]
   20484:	460b      	mov	r3, r1
   20486:	607a      	str	r2, [r7, #4]
   20488:	817b      	strh	r3, [r7, #10]
  uint8_t   *p;
  uint16_t  mtu;
  uint16_t  localMtu;
  uint8_t   *pRsp;

  p = pPacket + L2C_PAYLOAD_START + ATT_HDR_LEN;
   2048a:	687b      	ldr	r3, [r7, #4]
   2048c:	3309      	adds	r3, #9
   2048e:	61bb      	str	r3, [r7, #24]

  /* parse mtu */
  BYTES_TO_UINT16(mtu, p);
   20490:	69bb      	ldr	r3, [r7, #24]
   20492:	781b      	ldrb	r3, [r3, #0]
   20494:	b29a      	uxth	r2, r3
   20496:	69bb      	ldr	r3, [r7, #24]
   20498:	3301      	adds	r3, #1
   2049a:	781b      	ldrb	r3, [r3, #0]
   2049c:	b29b      	uxth	r3, r3
   2049e:	021b      	lsls	r3, r3, #8
   204a0:	b29b      	uxth	r3, r3
   204a2:	4413      	add	r3, r2
   204a4:	83fb      	strh	r3, [r7, #30]

  /* verify */
  if (mtu < ATT_DEFAULT_MTU)
   204a6:	8bfb      	ldrh	r3, [r7, #30]
   204a8:	2b16      	cmp	r3, #22
   204aa:	d801      	bhi.n	204b0 <attsProcMtuReq+0x34>
  {
    mtu = ATT_DEFAULT_MTU;
   204ac:	2317      	movs	r3, #23
   204ae:	83fb      	strh	r3, [r7, #30]
  }

  /* get desired MTU */
  localMtu = WSF_MIN(pAttCfg->mtu, (HciGetMaxRxAclLen() - L2C_HDR_LEN));
   204b0:	4b20      	ldr	r3, [pc, #128]	; (20534 <attsProcMtuReq+0xb8>)
   204b2:	681b      	ldr	r3, [r3, #0]
   204b4:	889b      	ldrh	r3, [r3, #4]
   204b6:	461c      	mov	r4, r3
   204b8:	f005 ffd6 	bl	26468 <HciGetMaxRxAclLen>
   204bc:	4603      	mov	r3, r0
   204be:	3b04      	subs	r3, #4
   204c0:	429c      	cmp	r4, r3
   204c2:	da03      	bge.n	204cc <attsProcMtuReq+0x50>
   204c4:	4b1b      	ldr	r3, [pc, #108]	; (20534 <attsProcMtuReq+0xb8>)
   204c6:	681b      	ldr	r3, [r3, #0]
   204c8:	889b      	ldrh	r3, [r3, #4]
   204ca:	e004      	b.n	204d6 <attsProcMtuReq+0x5a>
   204cc:	f005 ffcc 	bl	26468 <HciGetMaxRxAclLen>
   204d0:	4603      	mov	r3, r0
   204d2:	3b04      	subs	r3, #4
   204d4:	b29b      	uxth	r3, r3
   204d6:	82fb      	strh	r3, [r7, #22]

  /* send response */
  if ((pRsp = attMsgAlloc(L2C_PAYLOAD_START + ATT_MTU_RSP_LEN)) != NULL)
   204d8:	200b      	movs	r0, #11
   204da:	f7fd fa85 	bl	1d9e8 <attMsgAlloc>
   204de:	6138      	str	r0, [r7, #16]
   204e0:	693b      	ldr	r3, [r7, #16]
   204e2:	2b00      	cmp	r3, #0
   204e4:	d01c      	beq.n	20520 <attsProcMtuReq+0xa4>
  {
    p = pRsp + L2C_PAYLOAD_START;
   204e6:	693b      	ldr	r3, [r7, #16]
   204e8:	3308      	adds	r3, #8
   204ea:	61bb      	str	r3, [r7, #24]
    UINT8_TO_BSTREAM(p, ATT_PDU_MTU_RSP);
   204ec:	69bb      	ldr	r3, [r7, #24]
   204ee:	1c5a      	adds	r2, r3, #1
   204f0:	61ba      	str	r2, [r7, #24]
   204f2:	2203      	movs	r2, #3
   204f4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, localMtu);
   204f6:	69bb      	ldr	r3, [r7, #24]
   204f8:	1c5a      	adds	r2, r3, #1
   204fa:	61ba      	str	r2, [r7, #24]
   204fc:	8afa      	ldrh	r2, [r7, #22]
   204fe:	b2d2      	uxtb	r2, r2
   20500:	701a      	strb	r2, [r3, #0]
   20502:	8afb      	ldrh	r3, [r7, #22]
   20504:	0a1b      	lsrs	r3, r3, #8
   20506:	b299      	uxth	r1, r3
   20508:	69bb      	ldr	r3, [r7, #24]
   2050a:	1c5a      	adds	r2, r3, #1
   2050c:	61ba      	str	r2, [r7, #24]
   2050e:	b2ca      	uxtb	r2, r1
   20510:	701a      	strb	r2, [r3, #0]

    L2cDataReq(L2C_CID_ATT, pCcb->handle, ATT_MTU_RSP_LEN, pRsp);
   20512:	68fb      	ldr	r3, [r7, #12]
   20514:	8b19      	ldrh	r1, [r3, #24]
   20516:	693b      	ldr	r3, [r7, #16]
   20518:	2203      	movs	r2, #3
   2051a:	2004      	movs	r0, #4
   2051c:	f009 fce4 	bl	29ee8 <L2cDataReq>
  }

  /* set mtu for the connection */
  attSetMtu(pCcb, mtu, localMtu);
   20520:	8afa      	ldrh	r2, [r7, #22]
   20522:	8bfb      	ldrh	r3, [r7, #30]
   20524:	4619      	mov	r1, r3
   20526:	68f8      	ldr	r0, [r7, #12]
   20528:	f7fd fa0c 	bl	1d944 <attSetMtu>
}
   2052c:	bf00      	nop
   2052e:	3724      	adds	r7, #36	; 0x24
   20530:	46bd      	mov	sp, r7
   20532:	bd90      	pop	{r4, r7, pc}
   20534:	10002b8c 	.word	0x10002b8c

00020538 <attsProcFindInfoReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcFindInfoReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   20538:	b580      	push	{r7, lr}
   2053a:	b08a      	sub	sp, #40	; 0x28
   2053c:	af00      	add	r7, sp, #0
   2053e:	60f8      	str	r0, [r7, #12]
   20540:	460b      	mov	r3, r1
   20542:	607a      	str	r2, [r7, #4]
   20544:	817b      	strh	r3, [r7, #10]
  uint8_t     *p;
  attsAttr_t  *pAttr;
  uint16_t    startHandle;
  uint16_t    endHandle;
  uint16_t    handle;
  uint8_t     err = ATT_SUCCESS;
   20546:	2300      	movs	r3, #0
   20548:	777b      	strb	r3, [r7, #29]

  /* parse handles */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   2054a:	687b      	ldr	r3, [r7, #4]
   2054c:	3309      	adds	r3, #9
   2054e:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(startHandle, pPacket);
   20550:	687b      	ldr	r3, [r7, #4]
   20552:	781b      	ldrb	r3, [r3, #0]
   20554:	b29a      	uxth	r2, r3
   20556:	687b      	ldr	r3, [r7, #4]
   20558:	3301      	adds	r3, #1
   2055a:	781b      	ldrb	r3, [r3, #0]
   2055c:	b29b      	uxth	r3, r3
   2055e:	021b      	lsls	r3, r3, #8
   20560:	b29b      	uxth	r3, r3
   20562:	4413      	add	r3, r2
   20564:	837b      	strh	r3, [r7, #26]
   20566:	687b      	ldr	r3, [r7, #4]
   20568:	3302      	adds	r3, #2
   2056a:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(endHandle, pPacket);
   2056c:	687b      	ldr	r3, [r7, #4]
   2056e:	781b      	ldrb	r3, [r3, #0]
   20570:	b29a      	uxth	r2, r3
   20572:	687b      	ldr	r3, [r7, #4]
   20574:	3301      	adds	r3, #1
   20576:	781b      	ldrb	r3, [r3, #0]
   20578:	b29b      	uxth	r3, r3
   2057a:	021b      	lsls	r3, r3, #8
   2057c:	b29b      	uxth	r3, r3
   2057e:	4413      	add	r3, r2
   20580:	833b      	strh	r3, [r7, #24]
   20582:	687b      	ldr	r3, [r7, #4]
   20584:	3302      	adds	r3, #2
   20586:	607b      	str	r3, [r7, #4]

  /* verify handles */
  if ((startHandle == 0) || (startHandle > endHandle))
   20588:	8b7b      	ldrh	r3, [r7, #26]
   2058a:	2b00      	cmp	r3, #0
   2058c:	d003      	beq.n	20596 <attsProcFindInfoReq+0x5e>
   2058e:	8b7a      	ldrh	r2, [r7, #26]
   20590:	8b3b      	ldrh	r3, [r7, #24]
   20592:	429a      	cmp	r2, r3
   20594:	d901      	bls.n	2059a <attsProcFindInfoReq+0x62>
  {
    err = ATT_ERR_HANDLE;
   20596:	2301      	movs	r3, #1
   20598:	777b      	strb	r3, [r7, #29]
  }

  if (!err)
   2059a:	7f7b      	ldrb	r3, [r7, #29]
   2059c:	2b00      	cmp	r3, #0
   2059e:	f040 809b 	bne.w	206d8 <attsProcFindInfoReq+0x1a0>
  {
    /* allocate max size buffer for response */
    if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   205a2:	68fb      	ldr	r3, [r7, #12]
   205a4:	8b5b      	ldrh	r3, [r3, #26]
   205a6:	3308      	adds	r3, #8
   205a8:	b29b      	uxth	r3, r3
   205aa:	4618      	mov	r0, r3
   205ac:	f7fd fa1c 	bl	1d9e8 <attMsgAlloc>
   205b0:	6278      	str	r0, [r7, #36]	; 0x24
   205b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   205b4:	2b00      	cmp	r3, #0
   205b6:	f000 808d 	beq.w	206d4 <attsProcFindInfoReq+0x19c>
    {
      p = pBuf + L2C_PAYLOAD_START;
   205ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   205bc:	3308      	adds	r3, #8
   205be:	623b      	str	r3, [r7, #32]
      UINT8_TO_BSTREAM(p, ATT_PDU_FIND_INFO_RSP);
   205c0:	6a3b      	ldr	r3, [r7, #32]
   205c2:	1c5a      	adds	r2, r3, #1
   205c4:	623a      	str	r2, [r7, #32]
   205c6:	2205      	movs	r2, #5
   205c8:	701a      	strb	r2, [r3, #0]

      /* set result format */
      UINT8_TO_BSTREAM(p, ATT_FIND_HANDLE_16_UUID);
   205ca:	6a3b      	ldr	r3, [r7, #32]
   205cc:	1c5a      	adds	r2, r3, #1
   205ce:	623a      	str	r2, [r7, #32]
   205d0:	2201      	movs	r2, #1
   205d2:	701a      	strb	r2, [r3, #0]

      /* find attributes within handle range */
      handle = startHandle;
   205d4:	8b7b      	ldrh	r3, [r7, #26]
   205d6:	83fb      	strh	r3, [r7, #30]
      while ((handle = attsFindInRange(handle, endHandle, &pAttr)) != ATT_HANDLE_NONE)
   205d8:	e05d      	b.n	20696 <attsProcFindInfoReq+0x15e>
      {
        /* copy handle and UUID into response buffer */

        /* if 128 bit UUID */
        if (pAttr->settings & ATTS_SET_UUID_128)
   205da:	697b      	ldr	r3, [r7, #20]
   205dc:	7b9b      	ldrb	r3, [r3, #14]
   205de:	f003 0301 	and.w	r3, r3, #1
   205e2:	2b00      	cmp	r3, #0
   205e4:	d025      	beq.n	20632 <attsProcFindInfoReq+0xfa>
        {
          /* if this is the first result */
          if (p == (pBuf + L2C_PAYLOAD_START + 2))
   205e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   205e8:	330a      	adds	r3, #10
   205ea:	6a3a      	ldr	r2, [r7, #32]
   205ec:	429a      	cmp	r2, r3
   205ee:	d15f      	bne.n	206b0 <attsProcFindInfoReq+0x178>
          {
            p--;
   205f0:	6a3b      	ldr	r3, [r7, #32]
   205f2:	3b01      	subs	r3, #1
   205f4:	623b      	str	r3, [r7, #32]
            UINT8_TO_BSTREAM(p, ATT_FIND_HANDLE_128_UUID);
   205f6:	6a3b      	ldr	r3, [r7, #32]
   205f8:	1c5a      	adds	r2, r3, #1
   205fa:	623a      	str	r2, [r7, #32]
   205fc:	2202      	movs	r2, #2
   205fe:	701a      	strb	r2, [r3, #0]
            UINT16_TO_BSTREAM(p, handle);
   20600:	6a3b      	ldr	r3, [r7, #32]
   20602:	1c5a      	adds	r2, r3, #1
   20604:	623a      	str	r2, [r7, #32]
   20606:	8bfa      	ldrh	r2, [r7, #30]
   20608:	b2d2      	uxtb	r2, r2
   2060a:	701a      	strb	r2, [r3, #0]
   2060c:	8bfb      	ldrh	r3, [r7, #30]
   2060e:	0a1b      	lsrs	r3, r3, #8
   20610:	b299      	uxth	r1, r3
   20612:	6a3b      	ldr	r3, [r7, #32]
   20614:	1c5a      	adds	r2, r3, #1
   20616:	623a      	str	r2, [r7, #32]
   20618:	b2ca      	uxtb	r2, r1
   2061a:	701a      	strb	r2, [r3, #0]
            memcpy(p, pAttr->pUuid, ATT_128_UUID_LEN);
   2061c:	697b      	ldr	r3, [r7, #20]
   2061e:	681b      	ldr	r3, [r3, #0]
   20620:	2210      	movs	r2, #16
   20622:	4619      	mov	r1, r3
   20624:	6a38      	ldr	r0, [r7, #32]
   20626:	f7f7 fe15 	bl	18254 <memcpy>
            p += ATT_128_UUID_LEN;
   2062a:	6a3b      	ldr	r3, [r7, #32]
   2062c:	3310      	adds	r3, #16
   2062e:	623b      	str	r3, [r7, #32]
          }
          break;
   20630:	e03e      	b.n	206b0 <attsProcFindInfoReq+0x178>
        }
        /* else 16 bit UUID */
        else
        {
          /* check if result fits */
          if ((p + ATT_16_UUID_LEN + sizeof(uint16_t)) <=
   20632:	6a3b      	ldr	r3, [r7, #32]
   20634:	1d1a      	adds	r2, r3, #4
              (pBuf + pCcb->mtu + L2C_PAYLOAD_START))
   20636:	68fb      	ldr	r3, [r7, #12]
   20638:	8b5b      	ldrh	r3, [r3, #26]
   2063a:	3308      	adds	r3, #8
   2063c:	6a79      	ldr	r1, [r7, #36]	; 0x24
   2063e:	440b      	add	r3, r1
          if ((p + ATT_16_UUID_LEN + sizeof(uint16_t)) <=
   20640:	429a      	cmp	r2, r3
   20642:	d837      	bhi.n	206b4 <attsProcFindInfoReq+0x17c>
          {
            /* copy result */
            UINT16_TO_BSTREAM(p, handle);
   20644:	6a3b      	ldr	r3, [r7, #32]
   20646:	1c5a      	adds	r2, r3, #1
   20648:	623a      	str	r2, [r7, #32]
   2064a:	8bfa      	ldrh	r2, [r7, #30]
   2064c:	b2d2      	uxtb	r2, r2
   2064e:	701a      	strb	r2, [r3, #0]
   20650:	8bfb      	ldrh	r3, [r7, #30]
   20652:	0a1b      	lsrs	r3, r3, #8
   20654:	b299      	uxth	r1, r3
   20656:	6a3b      	ldr	r3, [r7, #32]
   20658:	1c5a      	adds	r2, r3, #1
   2065a:	623a      	str	r2, [r7, #32]
   2065c:	b2ca      	uxtb	r2, r1
   2065e:	701a      	strb	r2, [r3, #0]
            UINT8_TO_BSTREAM(p, pAttr->pUuid[0]);
   20660:	697b      	ldr	r3, [r7, #20]
   20662:	681a      	ldr	r2, [r3, #0]
   20664:	6a3b      	ldr	r3, [r7, #32]
   20666:	1c59      	adds	r1, r3, #1
   20668:	6239      	str	r1, [r7, #32]
   2066a:	7812      	ldrb	r2, [r2, #0]
   2066c:	701a      	strb	r2, [r3, #0]
            UINT8_TO_BSTREAM(p, pAttr->pUuid[1]);
   2066e:	697b      	ldr	r3, [r7, #20]
   20670:	681b      	ldr	r3, [r3, #0]
   20672:	1c5a      	adds	r2, r3, #1
   20674:	6a3b      	ldr	r3, [r7, #32]
   20676:	1c59      	adds	r1, r3, #1
   20678:	6239      	str	r1, [r7, #32]
   2067a:	7812      	ldrb	r2, [r2, #0]
   2067c:	701a      	strb	r2, [r3, #0]
            break;
          }
        }

        /* special case of handle at max range */
        if (handle == ATT_HANDLE_MAX)
   2067e:	8bfb      	ldrh	r3, [r7, #30]
   20680:	f64f 72ff 	movw	r2, #65535	; 0xffff
   20684:	4293      	cmp	r3, r2
   20686:	d017      	beq.n	206b8 <attsProcFindInfoReq+0x180>
        {
          break;
        }

        /* try next handle */
        if (++handle > endHandle)
   20688:	8bfb      	ldrh	r3, [r7, #30]
   2068a:	3301      	adds	r3, #1
   2068c:	83fb      	strh	r3, [r7, #30]
   2068e:	8bfa      	ldrh	r2, [r7, #30]
   20690:	8b3b      	ldrh	r3, [r7, #24]
   20692:	429a      	cmp	r2, r3
   20694:	d812      	bhi.n	206bc <attsProcFindInfoReq+0x184>
      while ((handle = attsFindInRange(handle, endHandle, &pAttr)) != ATT_HANDLE_NONE)
   20696:	f107 0214 	add.w	r2, r7, #20
   2069a:	8b39      	ldrh	r1, [r7, #24]
   2069c:	8bfb      	ldrh	r3, [r7, #30]
   2069e:	4618      	mov	r0, r3
   206a0:	f7ff fe50 	bl	20344 <attsFindInRange>
   206a4:	4603      	mov	r3, r0
   206a6:	83fb      	strh	r3, [r7, #30]
   206a8:	8bfb      	ldrh	r3, [r7, #30]
   206aa:	2b00      	cmp	r3, #0
   206ac:	d195      	bne.n	205da <attsProcFindInfoReq+0xa2>
   206ae:	e006      	b.n	206be <attsProcFindInfoReq+0x186>
          break;
   206b0:	bf00      	nop
   206b2:	e004      	b.n	206be <attsProcFindInfoReq+0x186>
            break;
   206b4:	bf00      	nop
   206b6:	e002      	b.n	206be <attsProcFindInfoReq+0x186>
          break;
   206b8:	bf00      	nop
   206ba:	e000      	b.n	206be <attsProcFindInfoReq+0x186>
        {
          break;
   206bc:	bf00      	nop
        }
      }

      /* if no results found set error, free buffer */
      if (p == (pBuf + L2C_PAYLOAD_START + 2))
   206be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   206c0:	330a      	adds	r3, #10
   206c2:	6a3a      	ldr	r2, [r7, #32]
   206c4:	429a      	cmp	r2, r3
   206c6:	d107      	bne.n	206d8 <attsProcFindInfoReq+0x1a0>
      {
        WsfMsgFree(pBuf);
   206c8:	6a78      	ldr	r0, [r7, #36]	; 0x24
   206ca:	f00c fd07 	bl	2d0dc <WsfMsgFree>
        err = ATT_ERR_NOT_FOUND;
   206ce:	230a      	movs	r3, #10
   206d0:	777b      	strb	r3, [r7, #29]
   206d2:	e001      	b.n	206d8 <attsProcFindInfoReq+0x1a0>
      }
    }
    else
    {
      /* buffer allocation failed */
      err = ATT_ERR_RESOURCES;
   206d4:	2311      	movs	r3, #17
   206d6:	777b      	strb	r3, [r7, #29]
    }
  }

  /* set channel as busy for service discovery */
  attsDiscBusy(pCcb);
   206d8:	68f8      	ldr	r0, [r7, #12]
   206da:	f7ff fac3 	bl	1fc64 <attsDiscBusy>

  /* if no error send response, else send error */
  if (!err)
   206de:	7f7b      	ldrb	r3, [r7, #29]
   206e0:	2b00      	cmp	r3, #0
   206e2:	d10b      	bne.n	206fc <attsProcFindInfoReq+0x1c4>
  {
    L2cDataReq(L2C_CID_ATT, pCcb->handle, (p - (pBuf + L2C_PAYLOAD_START)), pBuf);
   206e4:	68fb      	ldr	r3, [r7, #12]
   206e6:	8b19      	ldrh	r1, [r3, #24]
   206e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   206ea:	3308      	adds	r3, #8
   206ec:	6a3a      	ldr	r2, [r7, #32]
   206ee:	1ad3      	subs	r3, r2, r3
   206f0:	b29a      	uxth	r2, r3
   206f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   206f4:	2004      	movs	r0, #4
   206f6:	f009 fbf7 	bl	29ee8 <L2cDataReq>
  }
  else
  {
    attsErrRsp(pCcb->handle, ATT_PDU_FIND_INFO_REQ, startHandle, err);
  }
}
   206fa:	e006      	b.n	2070a <attsProcFindInfoReq+0x1d2>
    attsErrRsp(pCcb->handle, ATT_PDU_FIND_INFO_REQ, startHandle, err);
   206fc:	68fb      	ldr	r3, [r7, #12]
   206fe:	8b18      	ldrh	r0, [r3, #24]
   20700:	7f7b      	ldrb	r3, [r7, #29]
   20702:	8b7a      	ldrh	r2, [r7, #26]
   20704:	2104      	movs	r1, #4
   20706:	f7ff fa57 	bl	1fbb8 <attsErrRsp>
}
   2070a:	bf00      	nop
   2070c:	3728      	adds	r7, #40	; 0x28
   2070e:	46bd      	mov	sp, r7
   20710:	bd80      	pop	{r7, pc}
	...

00020714 <attsProcReadReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcReadReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   20714:	b590      	push	{r4, r7, lr}
   20716:	b08d      	sub	sp, #52	; 0x34
   20718:	af02      	add	r7, sp, #8
   2071a:	60f8      	str	r0, [r7, #12]
   2071c:	460b      	mov	r3, r1
   2071e:	607a      	str	r2, [r7, #4]
   20720:	817b      	strh	r3, [r7, #10]
  uint8_t     *p;
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint16_t    handle;
  uint16_t    readLen;
  uint8_t     err = ATT_SUCCESS;
   20722:	2300      	movs	r3, #0
   20724:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  /* parse handle */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   20728:	687b      	ldr	r3, [r7, #4]
   2072a:	3309      	adds	r3, #9
   2072c:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(handle, pPacket);
   2072e:	687b      	ldr	r3, [r7, #4]
   20730:	781b      	ldrb	r3, [r3, #0]
   20732:	b29a      	uxth	r2, r3
   20734:	687b      	ldr	r3, [r7, #4]
   20736:	3301      	adds	r3, #1
   20738:	781b      	ldrb	r3, [r3, #0]
   2073a:	b29b      	uxth	r3, r3
   2073c:	021b      	lsls	r3, r3, #8
   2073e:	b29b      	uxth	r3, r3
   20740:	4413      	add	r3, r2
   20742:	84bb      	strh	r3, [r7, #36]	; 0x24
   20744:	687b      	ldr	r3, [r7, #4]
   20746:	3302      	adds	r3, #2
   20748:	607b      	str	r3, [r7, #4]

  /* find attribute */
  if ((pAttr = attsFindByHandle(handle, &pGroup)) != NULL)
   2074a:	f107 0210 	add.w	r2, r7, #16
   2074e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20750:	4611      	mov	r1, r2
   20752:	4618      	mov	r0, r3
   20754:	f7ff fdc6 	bl	202e4 <attsFindByHandle>
   20758:	6238      	str	r0, [r7, #32]
   2075a:	6a3b      	ldr	r3, [r7, #32]
   2075c:	2b00      	cmp	r3, #0
   2075e:	d06d      	beq.n	2083c <attsProcReadReq+0x128>
  {
    /* verify permissions */
    if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   20760:	68fb      	ldr	r3, [r7, #12]
   20762:	7f18      	ldrb	r0, [r3, #28]
   20764:	6a3b      	ldr	r3, [r7, #32]
   20766:	7bdb      	ldrb	r3, [r3, #15]
   20768:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   2076a:	2101      	movs	r1, #1
   2076c:	f7ff fe28 	bl	203c0 <attsPermissions>
   20770:	4603      	mov	r3, r0
   20772:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   20776:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   2077a:	2b00      	cmp	r3, #0
   2077c:	d161      	bne.n	20842 <attsProcReadReq+0x12e>
                               handle, pAttr->permissions)) == ATT_SUCCESS)
    {
      /* call read callback if desired */
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   2077e:	6a3b      	ldr	r3, [r7, #32]
   20780:	7b9b      	ldrb	r3, [r3, #14]
   20782:	f003 0304 	and.w	r3, r3, #4
   20786:	2b00      	cmp	r3, #0
   20788:	d011      	beq.n	207ae <attsProcReadReq+0x9a>
          (pGroup->readCback != NULL))
   2078a:	693b      	ldr	r3, [r7, #16]
   2078c:	689b      	ldr	r3, [r3, #8]
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   2078e:	2b00      	cmp	r3, #0
   20790:	d00d      	beq.n	207ae <attsProcReadReq+0x9a>
      {
        err = (*pGroup->readCback)(pCcb->connId, handle, ATT_PDU_READ_REQ, 0, pAttr);
   20792:	693b      	ldr	r3, [r7, #16]
   20794:	689c      	ldr	r4, [r3, #8]
   20796:	68fb      	ldr	r3, [r7, #12]
   20798:	7f18      	ldrb	r0, [r3, #28]
   2079a:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
   2079c:	6a3b      	ldr	r3, [r7, #32]
   2079e:	9300      	str	r3, [sp, #0]
   207a0:	2300      	movs	r3, #0
   207a2:	220a      	movs	r2, #10
   207a4:	47a0      	blx	r4
   207a6:	4603      	mov	r3, r0
   207a8:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   207ac:	e015      	b.n	207da <attsProcReadReq+0xc6>
      }
      /* else check if CCC */
      else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   207ae:	6a3b      	ldr	r3, [r7, #32]
   207b0:	7b9b      	ldrb	r3, [r3, #14]
   207b2:	f003 0320 	and.w	r3, r3, #32
   207b6:	2b00      	cmp	r3, #0
   207b8:	d00f      	beq.n	207da <attsProcReadReq+0xc6>
   207ba:	4b2a      	ldr	r3, [pc, #168]	; (20864 <attsProcReadReq+0x150>)
   207bc:	695b      	ldr	r3, [r3, #20]
   207be:	2b00      	cmp	r3, #0
   207c0:	d00b      	beq.n	207da <attsProcReadReq+0xc6>
      {
        err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_READ, handle, pAttr->pValue);
   207c2:	4b28      	ldr	r3, [pc, #160]	; (20864 <attsProcReadReq+0x150>)
   207c4:	695c      	ldr	r4, [r3, #20]
   207c6:	68fb      	ldr	r3, [r7, #12]
   207c8:	7f18      	ldrb	r0, [r3, #28]
   207ca:	6a3b      	ldr	r3, [r7, #32]
   207cc:	685b      	ldr	r3, [r3, #4]
   207ce:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   207d0:	2105      	movs	r1, #5
   207d2:	47a0      	blx	r4
   207d4:	4603      	mov	r3, r0
   207d6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
      }

      if (err == ATT_SUCCESS)
   207da:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   207de:	2b00      	cmp	r3, #0
   207e0:	d12f      	bne.n	20842 <attsProcReadReq+0x12e>
      {
        /* determine length of data to read */
        readLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_RSP_LEN)) ?
   207e2:	68fb      	ldr	r3, [r7, #12]
   207e4:	8b5b      	ldrh	r3, [r3, #26]
   207e6:	3b01      	subs	r3, #1
   207e8:	6a3a      	ldr	r2, [r7, #32]
   207ea:	6892      	ldr	r2, [r2, #8]
   207ec:	8812      	ldrh	r2, [r2, #0]
                   *pAttr->pLen : (pCcb->mtu - ATT_READ_RSP_LEN);
   207ee:	4293      	cmp	r3, r2
   207f0:	bfa8      	it	ge
   207f2:	4613      	movge	r3, r2
        readLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_RSP_LEN)) ?
   207f4:	83fb      	strh	r3, [r7, #30]

        /* Allocate response buffer */
        if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_READ_RSP_LEN + readLen)) != NULL)
   207f6:	8bfb      	ldrh	r3, [r7, #30]
   207f8:	3309      	adds	r3, #9
   207fa:	b29b      	uxth	r3, r3
   207fc:	4618      	mov	r0, r3
   207fe:	f7fd f8f3 	bl	1d9e8 <attMsgAlloc>
   20802:	61b8      	str	r0, [r7, #24]
   20804:	69bb      	ldr	r3, [r7, #24]
   20806:	2b00      	cmp	r3, #0
   20808:	d01b      	beq.n	20842 <attsProcReadReq+0x12e>
        {
          /* build and send PDU */
          p = pBuf + L2C_PAYLOAD_START;
   2080a:	69bb      	ldr	r3, [r7, #24]
   2080c:	3308      	adds	r3, #8
   2080e:	617b      	str	r3, [r7, #20]
          UINT8_TO_BSTREAM(p, ATT_PDU_READ_RSP);
   20810:	697b      	ldr	r3, [r7, #20]
   20812:	1c5a      	adds	r2, r3, #1
   20814:	617a      	str	r2, [r7, #20]
   20816:	220b      	movs	r2, #11
   20818:	701a      	strb	r2, [r3, #0]
          memcpy(p, pAttr->pValue, readLen);
   2081a:	6a3b      	ldr	r3, [r7, #32]
   2081c:	685b      	ldr	r3, [r3, #4]
   2081e:	8bfa      	ldrh	r2, [r7, #30]
   20820:	4619      	mov	r1, r3
   20822:	6978      	ldr	r0, [r7, #20]
   20824:	f7f7 fd16 	bl	18254 <memcpy>

          L2cDataReq(L2C_CID_ATT, pCcb->handle, (ATT_READ_RSP_LEN + readLen), pBuf);
   20828:	68fb      	ldr	r3, [r7, #12]
   2082a:	8b19      	ldrh	r1, [r3, #24]
   2082c:	8bfb      	ldrh	r3, [r7, #30]
   2082e:	3301      	adds	r3, #1
   20830:	b29a      	uxth	r2, r3
   20832:	69bb      	ldr	r3, [r7, #24]
   20834:	2004      	movs	r0, #4
   20836:	f009 fb57 	bl	29ee8 <L2cDataReq>
   2083a:	e002      	b.n	20842 <attsProcReadReq+0x12e>
    }
  }
  /* else invalid handle */
  else
  {
    err = ATT_ERR_HANDLE;
   2083c:	2301      	movs	r3, #1
   2083e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  if (err)
   20842:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   20846:	2b00      	cmp	r3, #0
   20848:	d007      	beq.n	2085a <attsProcReadReq+0x146>
  {
    attsErrRsp(pCcb->handle, ATT_PDU_READ_REQ, handle, err);
   2084a:	68fb      	ldr	r3, [r7, #12]
   2084c:	8b18      	ldrh	r0, [r3, #24]
   2084e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   20852:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20854:	210a      	movs	r1, #10
   20856:	f7ff f9af 	bl	1fbb8 <attsErrRsp>
  }
}
   2085a:	bf00      	nop
   2085c:	372c      	adds	r7, #44	; 0x2c
   2085e:	46bd      	mov	sp, r7
   20860:	bd90      	pop	{r4, r7, pc}
   20862:	bf00      	nop
   20864:	100111dc 	.word	0x100111dc

00020868 <attsFindUuidInRange>:
 *  \return Attribute handle or ATT_HANDLE_NONE if not found.
 */
/*************************************************************************************************/
uint16_t attsFindUuidInRange(uint16_t startHandle, uint16_t endHandle, uint8_t uuidLen,
                             uint8_t *pUuid, attsAttr_t **pAttr, attsGroup_t **pAttrGroup)
{
   20868:	b580      	push	{r7, lr}
   2086a:	b086      	sub	sp, #24
   2086c:	af00      	add	r7, sp, #0
   2086e:	607b      	str	r3, [r7, #4]
   20870:	4603      	mov	r3, r0
   20872:	81fb      	strh	r3, [r7, #14]
   20874:	460b      	mov	r3, r1
   20876:	81bb      	strh	r3, [r7, #12]
   20878:	4613      	mov	r3, r2
   2087a:	72fb      	strb	r3, [r7, #11]
  attsGroup_t *pGroup;

  /* iterate over attribute group list */
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   2087c:	4b2c      	ldr	r3, [pc, #176]	; (20930 <attsFindUuidInRange+0xc8>)
   2087e:	681b      	ldr	r3, [r3, #0]
   20880:	617b      	str	r3, [r7, #20]
   20882:	e04c      	b.n	2091e <attsFindUuidInRange+0xb6>
  {
    /* if start handle is less than group start handle but handle range is within group */
    if ((startHandle < pGroup->startHandle) && (endHandle >= pGroup->startHandle))
   20884:	697b      	ldr	r3, [r7, #20]
   20886:	8a1b      	ldrh	r3, [r3, #16]
   20888:	89fa      	ldrh	r2, [r7, #14]
   2088a:	429a      	cmp	r2, r3
   2088c:	d207      	bcs.n	2089e <attsFindUuidInRange+0x36>
   2088e:	697b      	ldr	r3, [r7, #20]
   20890:	8a1b      	ldrh	r3, [r3, #16]
   20892:	89ba      	ldrh	r2, [r7, #12]
   20894:	429a      	cmp	r2, r3
   20896:	d302      	bcc.n	2089e <attsFindUuidInRange+0x36>
    {
      /* set start handle to first handle in group */
      startHandle = pGroup->startHandle;
   20898:	697b      	ldr	r3, [r7, #20]
   2089a:	8a1b      	ldrh	r3, [r3, #16]
   2089c:	81fb      	strh	r3, [r7, #14]
    }

    /*  if start handle within handle range of group */
    if ((startHandle >= pGroup->startHandle) && (startHandle <= pGroup->endHandle))
   2089e:	697b      	ldr	r3, [r7, #20]
   208a0:	8a1b      	ldrh	r3, [r3, #16]
   208a2:	89fa      	ldrh	r2, [r7, #14]
   208a4:	429a      	cmp	r2, r3
   208a6:	d337      	bcc.n	20918 <attsFindUuidInRange+0xb0>
   208a8:	697b      	ldr	r3, [r7, #20]
   208aa:	8a5b      	ldrh	r3, [r3, #18]
   208ac:	89fa      	ldrh	r2, [r7, #14]
   208ae:	429a      	cmp	r2, r3
   208b0:	d832      	bhi.n	20918 <attsFindUuidInRange+0xb0>
    {
      /* compare uuid with each attribute in group */
      *pAttr = &pGroup->pAttr[startHandle - pGroup->startHandle];
   208b2:	697b      	ldr	r3, [r7, #20]
   208b4:	685a      	ldr	r2, [r3, #4]
   208b6:	89fb      	ldrh	r3, [r7, #14]
   208b8:	6979      	ldr	r1, [r7, #20]
   208ba:	8a09      	ldrh	r1, [r1, #16]
   208bc:	1a5b      	subs	r3, r3, r1
   208be:	011b      	lsls	r3, r3, #4
   208c0:	441a      	add	r2, r3
   208c2:	6a3b      	ldr	r3, [r7, #32]
   208c4:	601a      	str	r2, [r3, #0]
      while ((startHandle <= pGroup->endHandle) && (startHandle <= endHandle))
   208c6:	e01c      	b.n	20902 <attsFindUuidInRange+0x9a>
      {
        /* compare uuid in attribute */
        if (attsUuidCmp(*pAttr, uuidLen, pUuid))
   208c8:	6a3b      	ldr	r3, [r7, #32]
   208ca:	681b      	ldr	r3, [r3, #0]
   208cc:	7af9      	ldrb	r1, [r7, #11]
   208ce:	687a      	ldr	r2, [r7, #4]
   208d0:	4618      	mov	r0, r3
   208d2:	f7ff fc9d 	bl	20210 <attsUuidCmp>
   208d6:	4603      	mov	r3, r0
   208d8:	2b00      	cmp	r3, #0
   208da:	d004      	beq.n	208e6 <attsFindUuidInRange+0x7e>
        {
          *pAttrGroup = pGroup;
   208dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   208de:	697a      	ldr	r2, [r7, #20]
   208e0:	601a      	str	r2, [r3, #0]
          return startHandle;
   208e2:	89fb      	ldrh	r3, [r7, #14]
   208e4:	e01f      	b.n	20926 <attsFindUuidInRange+0xbe>
        }

        /* special case of max handle value */
        if (startHandle == ATT_HANDLE_MAX)
   208e6:	89fb      	ldrh	r3, [r7, #14]
   208e8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   208ec:	4293      	cmp	r3, r2
   208ee:	d012      	beq.n	20916 <attsFindUuidInRange+0xae>
        {
          break;
        }

        startHandle++;
   208f0:	89fb      	ldrh	r3, [r7, #14]
   208f2:	3301      	adds	r3, #1
   208f4:	81fb      	strh	r3, [r7, #14]
        (*pAttr)++;
   208f6:	6a3b      	ldr	r3, [r7, #32]
   208f8:	681b      	ldr	r3, [r3, #0]
   208fa:	f103 0210 	add.w	r2, r3, #16
   208fe:	6a3b      	ldr	r3, [r7, #32]
   20900:	601a      	str	r2, [r3, #0]
      while ((startHandle <= pGroup->endHandle) && (startHandle <= endHandle))
   20902:	697b      	ldr	r3, [r7, #20]
   20904:	8a5b      	ldrh	r3, [r3, #18]
   20906:	89fa      	ldrh	r2, [r7, #14]
   20908:	429a      	cmp	r2, r3
   2090a:	d805      	bhi.n	20918 <attsFindUuidInRange+0xb0>
   2090c:	89fa      	ldrh	r2, [r7, #14]
   2090e:	89bb      	ldrh	r3, [r7, #12]
   20910:	429a      	cmp	r2, r3
   20912:	d9d9      	bls.n	208c8 <attsFindUuidInRange+0x60>
   20914:	e000      	b.n	20918 <attsFindUuidInRange+0xb0>
          break;
   20916:	bf00      	nop
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   20918:	697b      	ldr	r3, [r7, #20]
   2091a:	681b      	ldr	r3, [r3, #0]
   2091c:	617b      	str	r3, [r7, #20]
   2091e:	697b      	ldr	r3, [r7, #20]
   20920:	2b00      	cmp	r3, #0
   20922:	d1af      	bne.n	20884 <attsFindUuidInRange+0x1c>
      }
    }
  }

  /* no match found */
  return ATT_HANDLE_NONE;
   20924:	2300      	movs	r3, #0
}
   20926:	4618      	mov	r0, r3
   20928:	3718      	adds	r7, #24
   2092a:	46bd      	mov	sp, r7
   2092c:	bd80      	pop	{r7, pc}
   2092e:	bf00      	nop
   20930:	100111dc 	.word	0x100111dc

00020934 <attsFindServiceGroupEnd>:
 *
 *  \return Service group end handle.
 */
/*************************************************************************************************/
uint16_t attsFindServiceGroupEnd(uint16_t startHandle)
{
   20934:	b580      	push	{r7, lr}
   20936:	b086      	sub	sp, #24
   20938:	af00      	add	r7, sp, #0
   2093a:	4603      	mov	r3, r0
   2093c:	80fb      	strh	r3, [r7, #6]
  attsGroup_t   *pGroup;
  attsAttr_t    *pAttr;
  uint16_t      prevHandle;
  uint8_t       primSvcUuid[ATT_16_UUID_LEN] = {UINT16_TO_BYTES(ATT_UUID_PRIMARY_SERVICE)};
   2093e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   20942:	81bb      	strh	r3, [r7, #12]
  uint8_t       secSvcUuid[ATT_16_UUID_LEN] = {UINT16_TO_BYTES(ATT_UUID_SECONDARY_SERVICE)};
   20944:	f642 0301 	movw	r3, #10241	; 0x2801
   20948:	813b      	strh	r3, [r7, #8]

  /* special case for max handle */
  if (startHandle == ATT_HANDLE_MAX)
   2094a:	88fb      	ldrh	r3, [r7, #6]
   2094c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   20950:	4293      	cmp	r3, r2
   20952:	d102      	bne.n	2095a <attsFindServiceGroupEnd+0x26>
  {
    return ATT_HANDLE_MAX;
   20954:	f64f 73ff 	movw	r3, #65535	; 0xffff
   20958:	e052      	b.n	20a00 <attsFindServiceGroupEnd+0xcc>
  }

  prevHandle = startHandle;
   2095a:	88fb      	ldrh	r3, [r7, #6]
   2095c:	81fb      	strh	r3, [r7, #14]
  startHandle++;
   2095e:	88fb      	ldrh	r3, [r7, #6]
   20960:	3301      	adds	r3, #1
   20962:	80fb      	strh	r3, [r7, #6]

  /* iterate over attribute group list */
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   20964:	4b28      	ldr	r3, [pc, #160]	; (20a08 <attsFindServiceGroupEnd+0xd4>)
   20966:	681b      	ldr	r3, [r3, #0]
   20968:	617b      	str	r3, [r7, #20]
   2096a:	e044      	b.n	209f6 <attsFindServiceGroupEnd+0xc2>
  {
    /* if start handle is less than group start handle */
    if (startHandle < pGroup->startHandle)
   2096c:	697b      	ldr	r3, [r7, #20]
   2096e:	8a1b      	ldrh	r3, [r3, #16]
   20970:	88fa      	ldrh	r2, [r7, #6]
   20972:	429a      	cmp	r2, r3
   20974:	d202      	bcs.n	2097c <attsFindServiceGroupEnd+0x48>
    {
      /* set start handle to first handle in group */
      startHandle = pGroup->startHandle;
   20976:	697b      	ldr	r3, [r7, #20]
   20978:	8a1b      	ldrh	r3, [r3, #16]
   2097a:	80fb      	strh	r3, [r7, #6]
    }

    /*  if start handle within handle range of group */
    if (startHandle <= pGroup->endHandle)
   2097c:	697b      	ldr	r3, [r7, #20]
   2097e:	8a5b      	ldrh	r3, [r3, #18]
   20980:	88fa      	ldrh	r2, [r7, #6]
   20982:	429a      	cmp	r2, r3
   20984:	d834      	bhi.n	209f0 <attsFindServiceGroupEnd+0xbc>
    {
      /* compare uuid with each attribute in group */
      pAttr = &pGroup->pAttr[startHandle - pGroup->startHandle];
   20986:	697b      	ldr	r3, [r7, #20]
   20988:	685a      	ldr	r2, [r3, #4]
   2098a:	88fb      	ldrh	r3, [r7, #6]
   2098c:	6979      	ldr	r1, [r7, #20]
   2098e:	8a09      	ldrh	r1, [r1, #16]
   20990:	1a5b      	subs	r3, r3, r1
   20992:	011b      	lsls	r3, r3, #4
   20994:	4413      	add	r3, r2
   20996:	613b      	str	r3, [r7, #16]
      while (startHandle <= pGroup->endHandle)
   20998:	e025      	b.n	209e6 <attsFindServiceGroupEnd+0xb2>
      {
        /* compare uuid in attribute to service uuids */
        if (attsUuidCmp(pAttr, ATT_16_UUID_LEN, primSvcUuid) ||
   2099a:	f107 030c 	add.w	r3, r7, #12
   2099e:	461a      	mov	r2, r3
   209a0:	2102      	movs	r1, #2
   209a2:	6938      	ldr	r0, [r7, #16]
   209a4:	f7ff fc34 	bl	20210 <attsUuidCmp>
   209a8:	4603      	mov	r3, r0
   209aa:	2b00      	cmp	r3, #0
   209ac:	d109      	bne.n	209c2 <attsFindServiceGroupEnd+0x8e>
            attsUuidCmp(pAttr, ATT_16_UUID_LEN, secSvcUuid))
   209ae:	f107 0308 	add.w	r3, r7, #8
   209b2:	461a      	mov	r2, r3
   209b4:	2102      	movs	r1, #2
   209b6:	6938      	ldr	r0, [r7, #16]
   209b8:	f7ff fc2a 	bl	20210 <attsUuidCmp>
   209bc:	4603      	mov	r3, r0
        if (attsUuidCmp(pAttr, ATT_16_UUID_LEN, primSvcUuid) ||
   209be:	2b00      	cmp	r3, #0
   209c0:	d001      	beq.n	209c6 <attsFindServiceGroupEnd+0x92>
        {
          /* found next service; return handle of previous attribute */
          return prevHandle;
   209c2:	89fb      	ldrh	r3, [r7, #14]
   209c4:	e01c      	b.n	20a00 <attsFindServiceGroupEnd+0xcc>
        }

        /* special case of max handle value */
        if (startHandle == ATT_HANDLE_MAX)
   209c6:	88fb      	ldrh	r3, [r7, #6]
   209c8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   209cc:	4293      	cmp	r3, r2
   209ce:	d102      	bne.n	209d6 <attsFindServiceGroupEnd+0xa2>
        {
          return ATT_HANDLE_MAX;
   209d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   209d4:	e014      	b.n	20a00 <attsFindServiceGroupEnd+0xcc>
        }

        prevHandle = startHandle;
   209d6:	88fb      	ldrh	r3, [r7, #6]
   209d8:	81fb      	strh	r3, [r7, #14]
        startHandle++;
   209da:	88fb      	ldrh	r3, [r7, #6]
   209dc:	3301      	adds	r3, #1
   209de:	80fb      	strh	r3, [r7, #6]
        pAttr++;
   209e0:	693b      	ldr	r3, [r7, #16]
   209e2:	3310      	adds	r3, #16
   209e4:	613b      	str	r3, [r7, #16]
      while (startHandle <= pGroup->endHandle)
   209e6:	697b      	ldr	r3, [r7, #20]
   209e8:	8a5b      	ldrh	r3, [r3, #18]
   209ea:	88fa      	ldrh	r2, [r7, #6]
   209ec:	429a      	cmp	r2, r3
   209ee:	d9d4      	bls.n	2099a <attsFindServiceGroupEnd+0x66>
  for (pGroup = attsCb.groupQueue.pHead; pGroup != NULL; pGroup = pGroup->pNext)
   209f0:	697b      	ldr	r3, [r7, #20]
   209f2:	681b      	ldr	r3, [r3, #0]
   209f4:	617b      	str	r3, [r7, #20]
   209f6:	697b      	ldr	r3, [r7, #20]
   209f8:	2b00      	cmp	r3, #0
   209fa:	d1b7      	bne.n	2096c <attsFindServiceGroupEnd+0x38>
      }
    }
  }

  /* next service not found; return 0xFFFF as the last handle in the database */
  return ATT_HANDLE_MAX;
   209fc:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
   20a00:	4618      	mov	r0, r3
   20a02:	3718      	adds	r7, #24
   20a04:	46bd      	mov	sp, r7
   20a06:	bd80      	pop	{r7, pc}
   20a08:	100111dc 	.word	0x100111dc

00020a0c <attsProcReadBlobReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcReadBlobReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   20a0c:	b590      	push	{r4, r7, lr}
   20a0e:	b08f      	sub	sp, #60	; 0x3c
   20a10:	af02      	add	r7, sp, #8
   20a12:	60f8      	str	r0, [r7, #12]
   20a14:	460b      	mov	r3, r1
   20a16:	607a      	str	r2, [r7, #4]
   20a18:	817b      	strh	r3, [r7, #10]
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint16_t    handle;
  uint16_t    offset;
  uint16_t    readLen;
  uint8_t     err = ATT_SUCCESS;
   20a1a:	2300      	movs	r3, #0
   20a1c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

  /* parse handle and offset */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   20a20:	687b      	ldr	r3, [r7, #4]
   20a22:	3309      	adds	r3, #9
   20a24:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(handle, pPacket);
   20a26:	687b      	ldr	r3, [r7, #4]
   20a28:	781b      	ldrb	r3, [r3, #0]
   20a2a:	b29a      	uxth	r2, r3
   20a2c:	687b      	ldr	r3, [r7, #4]
   20a2e:	3301      	adds	r3, #1
   20a30:	781b      	ldrb	r3, [r3, #0]
   20a32:	b29b      	uxth	r3, r3
   20a34:	021b      	lsls	r3, r3, #8
   20a36:	b29b      	uxth	r3, r3
   20a38:	4413      	add	r3, r2
   20a3a:	85bb      	strh	r3, [r7, #44]	; 0x2c
   20a3c:	687b      	ldr	r3, [r7, #4]
   20a3e:	3302      	adds	r3, #2
   20a40:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(offset, pPacket);
   20a42:	687b      	ldr	r3, [r7, #4]
   20a44:	781b      	ldrb	r3, [r3, #0]
   20a46:	b29a      	uxth	r2, r3
   20a48:	687b      	ldr	r3, [r7, #4]
   20a4a:	3301      	adds	r3, #1
   20a4c:	781b      	ldrb	r3, [r3, #0]
   20a4e:	b29b      	uxth	r3, r3
   20a50:	021b      	lsls	r3, r3, #8
   20a52:	b29b      	uxth	r3, r3
   20a54:	4413      	add	r3, r2
   20a56:	857b      	strh	r3, [r7, #42]	; 0x2a
   20a58:	687b      	ldr	r3, [r7, #4]
   20a5a:	3302      	adds	r3, #2
   20a5c:	607b      	str	r3, [r7, #4]

  /* find attribute */
  if ((pAttr = attsFindByHandle(handle, &pGroup)) != NULL)
   20a5e:	f107 0214 	add.w	r2, r7, #20
   20a62:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
   20a64:	4611      	mov	r1, r2
   20a66:	4618      	mov	r0, r3
   20a68:	f7ff fc3c 	bl	202e4 <attsFindByHandle>
   20a6c:	6278      	str	r0, [r7, #36]	; 0x24
   20a6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20a70:	2b00      	cmp	r3, #0
   20a72:	d07d      	beq.n	20b70 <attsProcReadBlobReq+0x164>
  {
    /* verify permissions */
    if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   20a74:	68fb      	ldr	r3, [r7, #12]
   20a76:	7f18      	ldrb	r0, [r3, #28]
   20a78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20a7a:	7bdb      	ldrb	r3, [r3, #15]
   20a7c:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
   20a7e:	2101      	movs	r1, #1
   20a80:	f7ff fc9e 	bl	203c0 <attsPermissions>
   20a84:	4603      	mov	r3, r0
   20a86:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   20a8a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   20a8e:	2b00      	cmp	r3, #0
   20a90:	d171      	bne.n	20b76 <attsProcReadBlobReq+0x16a>
                               handle, pAttr->permissions)) != ATT_SUCCESS)
    {
      /* err has been set; fail */
    }
    /* verify offset */
    else if (offset > *pAttr->pLen)
   20a92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20a94:	689b      	ldr	r3, [r3, #8]
   20a96:	881b      	ldrh	r3, [r3, #0]
   20a98:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   20a9a:	429a      	cmp	r2, r3
   20a9c:	d903      	bls.n	20aa6 <attsProcReadBlobReq+0x9a>
    {
      err = ATT_ERR_OFFSET;
   20a9e:	2307      	movs	r3, #7
   20aa0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   20aa4:	e067      	b.n	20b76 <attsProcReadBlobReq+0x16a>
    }
    else
    {
      /* call read callback if desired */
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20aa6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20aa8:	7b9b      	ldrb	r3, [r3, #14]
   20aaa:	f003 0304 	and.w	r3, r3, #4
   20aae:	2b00      	cmp	r3, #0
   20ab0:	d012      	beq.n	20ad8 <attsProcReadBlobReq+0xcc>
          (pGroup->readCback != NULL))
   20ab2:	697b      	ldr	r3, [r7, #20]
   20ab4:	689b      	ldr	r3, [r3, #8]
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20ab6:	2b00      	cmp	r3, #0
   20ab8:	d00e      	beq.n	20ad8 <attsProcReadBlobReq+0xcc>
      {
        err = (*pGroup->readCback)(pCcb->connId, handle, ATT_PDU_READ_BLOB_REQ, offset, pAttr);
   20aba:	697b      	ldr	r3, [r7, #20]
   20abc:	689c      	ldr	r4, [r3, #8]
   20abe:	68fb      	ldr	r3, [r7, #12]
   20ac0:	7f18      	ldrb	r0, [r3, #28]
   20ac2:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   20ac4:	8db9      	ldrh	r1, [r7, #44]	; 0x2c
   20ac6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20ac8:	9300      	str	r3, [sp, #0]
   20aca:	4613      	mov	r3, r2
   20acc:	220c      	movs	r2, #12
   20ace:	47a0      	blx	r4
   20ad0:	4603      	mov	r3, r0
   20ad2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   20ad6:	e015      	b.n	20b04 <attsProcReadBlobReq+0xf8>
      }
      /* else check if CCC */
      else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   20ad8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20ada:	7b9b      	ldrb	r3, [r3, #14]
   20adc:	f003 0320 	and.w	r3, r3, #32
   20ae0:	2b00      	cmp	r3, #0
   20ae2:	d00f      	beq.n	20b04 <attsProcReadBlobReq+0xf8>
   20ae4:	4b2c      	ldr	r3, [pc, #176]	; (20b98 <attsProcReadBlobReq+0x18c>)
   20ae6:	695b      	ldr	r3, [r3, #20]
   20ae8:	2b00      	cmp	r3, #0
   20aea:	d00b      	beq.n	20b04 <attsProcReadBlobReq+0xf8>
      {
        err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_READ, handle, pAttr->pValue);
   20aec:	4b2a      	ldr	r3, [pc, #168]	; (20b98 <attsProcReadBlobReq+0x18c>)
   20aee:	695c      	ldr	r4, [r3, #20]
   20af0:	68fb      	ldr	r3, [r7, #12]
   20af2:	7f18      	ldrb	r0, [r3, #28]
   20af4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20af6:	685b      	ldr	r3, [r3, #4]
   20af8:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
   20afa:	2105      	movs	r1, #5
   20afc:	47a0      	blx	r4
   20afe:	4603      	mov	r3, r0
   20b00:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
      }

      if (err == ATT_SUCCESS)
   20b04:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   20b08:	2b00      	cmp	r3, #0
   20b0a:	d134      	bne.n	20b76 <attsProcReadBlobReq+0x16a>
      {
        /* determine length of data to read */
        readLen = ((*pAttr->pLen - offset) < (pCcb->mtu - ATT_READ_BLOB_RSP_LEN)) ?
   20b0c:	68fb      	ldr	r3, [r7, #12]
   20b0e:	8b5b      	ldrh	r3, [r3, #26]
   20b10:	1e5a      	subs	r2, r3, #1
   20b12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20b14:	689b      	ldr	r3, [r3, #8]
   20b16:	881b      	ldrh	r3, [r3, #0]
   20b18:	4619      	mov	r1, r3
   20b1a:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   20b1c:	1acb      	subs	r3, r1, r3
                   (*pAttr->pLen - offset) : (pCcb->mtu - ATT_READ_BLOB_RSP_LEN);
   20b1e:	4293      	cmp	r3, r2
   20b20:	bfa8      	it	ge
   20b22:	4613      	movge	r3, r2
        readLen = ((*pAttr->pLen - offset) < (pCcb->mtu - ATT_READ_BLOB_RSP_LEN)) ?
   20b24:	847b      	strh	r3, [r7, #34]	; 0x22

        /* Allocate response buffer */
        if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_READ_BLOB_RSP_LEN + readLen)) != NULL)
   20b26:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   20b28:	3309      	adds	r3, #9
   20b2a:	b29b      	uxth	r3, r3
   20b2c:	4618      	mov	r0, r3
   20b2e:	f7fc ff5b 	bl	1d9e8 <attMsgAlloc>
   20b32:	61f8      	str	r0, [r7, #28]
   20b34:	69fb      	ldr	r3, [r7, #28]
   20b36:	2b00      	cmp	r3, #0
   20b38:	d01d      	beq.n	20b76 <attsProcReadBlobReq+0x16a>
        {
          /* build and send PDU */
          p = pBuf + L2C_PAYLOAD_START;
   20b3a:	69fb      	ldr	r3, [r7, #28]
   20b3c:	3308      	adds	r3, #8
   20b3e:	61bb      	str	r3, [r7, #24]
          UINT8_TO_BSTREAM(p, ATT_PDU_READ_BLOB_RSP);
   20b40:	69bb      	ldr	r3, [r7, #24]
   20b42:	1c5a      	adds	r2, r3, #1
   20b44:	61ba      	str	r2, [r7, #24]
   20b46:	220d      	movs	r2, #13
   20b48:	701a      	strb	r2, [r3, #0]
          memcpy(p, (pAttr->pValue + offset), readLen);
   20b4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   20b4c:	685a      	ldr	r2, [r3, #4]
   20b4e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   20b50:	4413      	add	r3, r2
   20b52:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   20b54:	4619      	mov	r1, r3
   20b56:	69b8      	ldr	r0, [r7, #24]
   20b58:	f7f7 fb7c 	bl	18254 <memcpy>

          L2cDataReq(L2C_CID_ATT, pCcb->handle, (ATT_READ_BLOB_RSP_LEN + readLen), pBuf);
   20b5c:	68fb      	ldr	r3, [r7, #12]
   20b5e:	8b19      	ldrh	r1, [r3, #24]
   20b60:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   20b62:	3301      	adds	r3, #1
   20b64:	b29a      	uxth	r2, r3
   20b66:	69fb      	ldr	r3, [r7, #28]
   20b68:	2004      	movs	r0, #4
   20b6a:	f009 f9bd 	bl	29ee8 <L2cDataReq>
   20b6e:	e002      	b.n	20b76 <attsProcReadBlobReq+0x16a>
    }
  }
  /* else invalid handle */
  else
  {
    err = ATT_ERR_HANDLE;
   20b70:	2301      	movs	r3, #1
   20b72:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  }

  if (err)
   20b76:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   20b7a:	2b00      	cmp	r3, #0
   20b7c:	d007      	beq.n	20b8e <attsProcReadBlobReq+0x182>
  {
    attsErrRsp(pCcb->handle, ATT_PDU_READ_BLOB_REQ, handle, err);
   20b7e:	68fb      	ldr	r3, [r7, #12]
   20b80:	8b18      	ldrh	r0, [r3, #24]
   20b82:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   20b86:	8dba      	ldrh	r2, [r7, #44]	; 0x2c
   20b88:	210c      	movs	r1, #12
   20b8a:	f7ff f815 	bl	1fbb8 <attsErrRsp>
  }
}
   20b8e:	bf00      	nop
   20b90:	3734      	adds	r7, #52	; 0x34
   20b92:	46bd      	mov	sp, r7
   20b94:	bd90      	pop	{r4, r7, pc}
   20b96:	bf00      	nop
   20b98:	100111dc 	.word	0x100111dc

00020b9c <attsProcFindTypeReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcFindTypeReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   20b9c:	b580      	push	{r7, lr}
   20b9e:	b08e      	sub	sp, #56	; 0x38
   20ba0:	af02      	add	r7, sp, #8
   20ba2:	60f8      	str	r0, [r7, #12]
   20ba4:	460b      	mov	r3, r1
   20ba6:	607a      	str	r2, [r7, #4]
   20ba8:	817b      	strh	r3, [r7, #10]
  attsGroup_t *pGroup;
  uint16_t    startHandle;
  uint16_t    endHandle;
  uint16_t    handle;
  uint16_t    nextHandle;
  uint8_t     err = ATT_SUCCESS;
   20baa:	2300      	movs	r3, #0
   20bac:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  /* parse handles and uuid; pPacket then points to the value in the request */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   20bb0:	687b      	ldr	r3, [r7, #4]
   20bb2:	3309      	adds	r3, #9
   20bb4:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(startHandle, pPacket);
   20bb6:	687b      	ldr	r3, [r7, #4]
   20bb8:	781b      	ldrb	r3, [r3, #0]
   20bba:	b29a      	uxth	r2, r3
   20bbc:	687b      	ldr	r3, [r7, #4]
   20bbe:	3301      	adds	r3, #1
   20bc0:	781b      	ldrb	r3, [r3, #0]
   20bc2:	b29b      	uxth	r3, r3
   20bc4:	021b      	lsls	r3, r3, #8
   20bc6:	b29b      	uxth	r3, r3
   20bc8:	4413      	add	r3, r2
   20bca:	843b      	strh	r3, [r7, #32]
   20bcc:	687b      	ldr	r3, [r7, #4]
   20bce:	3302      	adds	r3, #2
   20bd0:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(endHandle, pPacket);
   20bd2:	687b      	ldr	r3, [r7, #4]
   20bd4:	781b      	ldrb	r3, [r3, #0]
   20bd6:	b29a      	uxth	r2, r3
   20bd8:	687b      	ldr	r3, [r7, #4]
   20bda:	3301      	adds	r3, #1
   20bdc:	781b      	ldrb	r3, [r3, #0]
   20bde:	b29b      	uxth	r3, r3
   20be0:	021b      	lsls	r3, r3, #8
   20be2:	b29b      	uxth	r3, r3
   20be4:	4413      	add	r3, r2
   20be6:	83fb      	strh	r3, [r7, #30]
   20be8:	687b      	ldr	r3, [r7, #4]
   20bea:	3302      	adds	r3, #2
   20bec:	607b      	str	r3, [r7, #4]
  pUuid = pPacket;
   20bee:	687b      	ldr	r3, [r7, #4]
   20bf0:	61bb      	str	r3, [r7, #24]
  pPacket += ATT_16_UUID_LEN;
   20bf2:	687b      	ldr	r3, [r7, #4]
   20bf4:	3302      	adds	r3, #2
   20bf6:	607b      	str	r3, [r7, #4]

  /* set len to the value length */
  len -= ATT_FIND_TYPE_REQ_LEN;
   20bf8:	897b      	ldrh	r3, [r7, #10]
   20bfa:	3b07      	subs	r3, #7
   20bfc:	817b      	strh	r3, [r7, #10]

  /* verify handles */
  if ((startHandle == 0) || (startHandle > endHandle))
   20bfe:	8c3b      	ldrh	r3, [r7, #32]
   20c00:	2b00      	cmp	r3, #0
   20c02:	d003      	beq.n	20c0c <attsProcFindTypeReq+0x70>
   20c04:	8c3a      	ldrh	r2, [r7, #32]
   20c06:	8bfb      	ldrh	r3, [r7, #30]
   20c08:	429a      	cmp	r2, r3
   20c0a:	d902      	bls.n	20c12 <attsProcFindTypeReq+0x76>
  {
    err = ATT_ERR_HANDLE;
   20c0c:	2301      	movs	r3, #1
   20c0e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  }

  if (!err)
   20c12:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   20c16:	2b00      	cmp	r3, #0
   20c18:	f040 8097 	bne.w	20d4a <attsProcFindTypeReq+0x1ae>
  {
    /* allocate max size buffer for response */
    if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   20c1c:	68fb      	ldr	r3, [r7, #12]
   20c1e:	8b5b      	ldrh	r3, [r3, #26]
   20c20:	3308      	adds	r3, #8
   20c22:	b29b      	uxth	r3, r3
   20c24:	4618      	mov	r0, r3
   20c26:	f7fc fedf 	bl	1d9e8 <attMsgAlloc>
   20c2a:	62f8      	str	r0, [r7, #44]	; 0x2c
   20c2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20c2e:	2b00      	cmp	r3, #0
   20c30:	f000 8088 	beq.w	20d44 <attsProcFindTypeReq+0x1a8>
    {
      p = pBuf + L2C_PAYLOAD_START;
   20c34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20c36:	3308      	adds	r3, #8
   20c38:	62bb      	str	r3, [r7, #40]	; 0x28
      UINT8_TO_BSTREAM(p, ATT_PDU_FIND_TYPE_RSP);
   20c3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20c3c:	1c5a      	adds	r2, r3, #1
   20c3e:	62ba      	str	r2, [r7, #40]	; 0x28
   20c40:	2207      	movs	r2, #7
   20c42:	701a      	strb	r2, [r3, #0]

      /* find attributes with matching uuid within handle range */
      handle = startHandle;
   20c44:	8c3b      	ldrh	r3, [r7, #32]
   20c46:	84fb      	strh	r3, [r7, #38]	; 0x26
      while ((handle = attsFindUuidInRange(handle, endHandle, ATT_16_UUID_LEN,
   20c48:	e05d      	b.n	20d06 <attsProcFindTypeReq+0x16a>
                                           pUuid, &pAttr, &pGroup)) != ATT_HANDLE_NONE)
      {
        /* if value and length matches */
        if ((pAttr->permissions & ATTS_PERMIT_READ) &&
   20c4a:	697b      	ldr	r3, [r7, #20]
   20c4c:	7bdb      	ldrb	r3, [r3, #15]
   20c4e:	f003 0301 	and.w	r3, r3, #1
   20c52:	2b00      	cmp	r3, #0
   20c54:	d049      	beq.n	20cea <attsProcFindTypeReq+0x14e>
   20c56:	897b      	ldrh	r3, [r7, #10]
   20c58:	2b00      	cmp	r3, #0
   20c5a:	d00f      	beq.n	20c7c <attsProcFindTypeReq+0xe0>
            ((len == 0) ||
             ((len == *pAttr->pLen) && (memcmp(pPacket, pAttr->pValue, len) == 0))))
   20c5c:	697b      	ldr	r3, [r7, #20]
   20c5e:	689b      	ldr	r3, [r3, #8]
   20c60:	881b      	ldrh	r3, [r3, #0]
            ((len == 0) ||
   20c62:	897a      	ldrh	r2, [r7, #10]
   20c64:	429a      	cmp	r2, r3
   20c66:	d140      	bne.n	20cea <attsProcFindTypeReq+0x14e>
             ((len == *pAttr->pLen) && (memcmp(pPacket, pAttr->pValue, len) == 0))))
   20c68:	697b      	ldr	r3, [r7, #20]
   20c6a:	685b      	ldr	r3, [r3, #4]
   20c6c:	897a      	ldrh	r2, [r7, #10]
   20c6e:	4619      	mov	r1, r3
   20c70:	6878      	ldr	r0, [r7, #4]
   20c72:	f00f f9a1 	bl	2ffb8 <memcmp>
   20c76:	4603      	mov	r3, r0
   20c78:	2b00      	cmp	r3, #0
   20c7a:	d136      	bne.n	20cea <attsProcFindTypeReq+0x14e>
        {
          /* if uuid in request is for primary service */
          if (pUuid[0] == UINT16_TO_BYTE0(ATT_UUID_PRIMARY_SERVICE) &&
   20c7c:	69bb      	ldr	r3, [r7, #24]
   20c7e:	781b      	ldrb	r3, [r3, #0]
   20c80:	2b00      	cmp	r3, #0
   20c82:	d10b      	bne.n	20c9c <attsProcFindTypeReq+0x100>
              pUuid[1] == UINT16_TO_BYTE1(ATT_UUID_PRIMARY_SERVICE))
   20c84:	69bb      	ldr	r3, [r7, #24]
   20c86:	3301      	adds	r3, #1
   20c88:	781b      	ldrb	r3, [r3, #0]
          if (pUuid[0] == UINT16_TO_BYTE0(ATT_UUID_PRIMARY_SERVICE) &&
   20c8a:	2b28      	cmp	r3, #40	; 0x28
   20c8c:	d106      	bne.n	20c9c <attsProcFindTypeReq+0x100>
          {
            /* next handle is service group end handle */
            nextHandle = attsFindServiceGroupEnd(handle);
   20c8e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20c90:	4618      	mov	r0, r3
   20c92:	f7ff fe4f 	bl	20934 <attsFindServiceGroupEnd>
   20c96:	4603      	mov	r3, r0
   20c98:	84bb      	strh	r3, [r7, #36]	; 0x24
   20c9a:	e001      	b.n	20ca0 <attsProcFindTypeReq+0x104>
          }
          else
          {
            /* for any other uuid next handle is same as found handle */
            nextHandle = handle;
   20c9c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20c9e:	84bb      	strh	r3, [r7, #36]	; 0x24
          }

          /* copy result into response buffer; first check if it fits */
          if (p <= (pBuf + pCcb->mtu + L2C_PAYLOAD_START - (sizeof(uint16_t) * 2)))
   20ca0:	68fb      	ldr	r3, [r7, #12]
   20ca2:	8b5b      	ldrh	r3, [r3, #26]
   20ca4:	3304      	adds	r3, #4
   20ca6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   20ca8:	4413      	add	r3, r2
   20caa:	6aba      	ldr	r2, [r7, #40]	; 0x28
   20cac:	429a      	cmp	r2, r3
   20cae:	d83c      	bhi.n	20d2a <attsProcFindTypeReq+0x18e>
          {
            UINT16_TO_BSTREAM(p, handle);
   20cb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20cb2:	1c5a      	adds	r2, r3, #1
   20cb4:	62ba      	str	r2, [r7, #40]	; 0x28
   20cb6:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   20cb8:	b2d2      	uxtb	r2, r2
   20cba:	701a      	strb	r2, [r3, #0]
   20cbc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20cbe:	0a1b      	lsrs	r3, r3, #8
   20cc0:	b299      	uxth	r1, r3
   20cc2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20cc4:	1c5a      	adds	r2, r3, #1
   20cc6:	62ba      	str	r2, [r7, #40]	; 0x28
   20cc8:	b2ca      	uxtb	r2, r1
   20cca:	701a      	strb	r2, [r3, #0]
            UINT16_TO_BSTREAM(p, nextHandle);
   20ccc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20cce:	1c5a      	adds	r2, r3, #1
   20cd0:	62ba      	str	r2, [r7, #40]	; 0x28
   20cd2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20cd4:	b2d2      	uxtb	r2, r2
   20cd6:	701a      	strb	r2, [r3, #0]
   20cd8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20cda:	0a1b      	lsrs	r3, r3, #8
   20cdc:	b299      	uxth	r1, r3
   20cde:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20ce0:	1c5a      	adds	r2, r3, #1
   20ce2:	62ba      	str	r2, [r7, #40]	; 0x28
   20ce4:	b2ca      	uxtb	r2, r1
   20ce6:	701a      	strb	r2, [r3, #0]
          if (p <= (pBuf + pCcb->mtu + L2C_PAYLOAD_START - (sizeof(uint16_t) * 2)))
   20ce8:	e001      	b.n	20cee <attsProcFindTypeReq+0x152>
          }
        }
        /* value doesn't match; still need to set next handle */
        else
        {
          nextHandle = handle;
   20cea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20cec:	84bb      	strh	r3, [r7, #36]	; 0x24
        }

        /* check if handle has reached end */
        if ((nextHandle >= endHandle) || (nextHandle == ATT_HANDLE_MAX))
   20cee:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20cf0:	8bfb      	ldrh	r3, [r7, #30]
   20cf2:	429a      	cmp	r2, r3
   20cf4:	d21a      	bcs.n	20d2c <attsProcFindTypeReq+0x190>
   20cf6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20cf8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   20cfc:	4293      	cmp	r3, r2
   20cfe:	d015      	beq.n	20d2c <attsProcFindTypeReq+0x190>
        {
          break;
        }

        /* try next handle */
        handle = nextHandle + 1;
   20d00:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20d02:	3301      	adds	r3, #1
   20d04:	84fb      	strh	r3, [r7, #38]	; 0x26
      while ((handle = attsFindUuidInRange(handle, endHandle, ATT_16_UUID_LEN,
   20d06:	8bf9      	ldrh	r1, [r7, #30]
   20d08:	8cf8      	ldrh	r0, [r7, #38]	; 0x26
   20d0a:	f107 0310 	add.w	r3, r7, #16
   20d0e:	9301      	str	r3, [sp, #4]
   20d10:	f107 0314 	add.w	r3, r7, #20
   20d14:	9300      	str	r3, [sp, #0]
   20d16:	69bb      	ldr	r3, [r7, #24]
   20d18:	2202      	movs	r2, #2
   20d1a:	f7ff fda5 	bl	20868 <attsFindUuidInRange>
   20d1e:	4603      	mov	r3, r0
   20d20:	84fb      	strh	r3, [r7, #38]	; 0x26
   20d22:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20d24:	2b00      	cmp	r3, #0
   20d26:	d190      	bne.n	20c4a <attsProcFindTypeReq+0xae>
   20d28:	e000      	b.n	20d2c <attsProcFindTypeReq+0x190>
            break;
   20d2a:	bf00      	nop
      }

      /* if no results found set error, free buffer */
      if (p == (pBuf + L2C_PAYLOAD_START + 1))
   20d2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20d2e:	3309      	adds	r3, #9
   20d30:	6aba      	ldr	r2, [r7, #40]	; 0x28
   20d32:	429a      	cmp	r2, r3
   20d34:	d109      	bne.n	20d4a <attsProcFindTypeReq+0x1ae>
      {
        WsfMsgFree(pBuf);
   20d36:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   20d38:	f00c f9d0 	bl	2d0dc <WsfMsgFree>
        err = ATT_ERR_NOT_FOUND;
   20d3c:	230a      	movs	r3, #10
   20d3e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   20d42:	e002      	b.n	20d4a <attsProcFindTypeReq+0x1ae>
      }
    }
    else
    {
      /* buffer allocation failed */
      err = ATT_ERR_RESOURCES;
   20d44:	2311      	movs	r3, #17
   20d46:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    }
  }

  /* set channel as busy for service discovery */
  attsDiscBusy(pCcb);
   20d4a:	68f8      	ldr	r0, [r7, #12]
   20d4c:	f7fe ff8a 	bl	1fc64 <attsDiscBusy>

  /* if no error send response, else send error */
  if (!err)
   20d50:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   20d54:	2b00      	cmp	r3, #0
   20d56:	d10b      	bne.n	20d70 <attsProcFindTypeReq+0x1d4>
  {
    L2cDataReq(L2C_CID_ATT, pCcb->handle, (p - (pBuf + L2C_PAYLOAD_START)), pBuf);
   20d58:	68fb      	ldr	r3, [r7, #12]
   20d5a:	8b19      	ldrh	r1, [r3, #24]
   20d5c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20d5e:	3308      	adds	r3, #8
   20d60:	6aba      	ldr	r2, [r7, #40]	; 0x28
   20d62:	1ad3      	subs	r3, r2, r3
   20d64:	b29a      	uxth	r2, r3
   20d66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20d68:	2004      	movs	r0, #4
   20d6a:	f009 f8bd 	bl	29ee8 <L2cDataReq>
  }
  else
  {
    attsErrRsp(pCcb->handle, ATT_PDU_FIND_TYPE_REQ, startHandle, err);
  }
}
   20d6e:	e007      	b.n	20d80 <attsProcFindTypeReq+0x1e4>
    attsErrRsp(pCcb->handle, ATT_PDU_FIND_TYPE_REQ, startHandle, err);
   20d70:	68fb      	ldr	r3, [r7, #12]
   20d72:	8b18      	ldrh	r0, [r3, #24]
   20d74:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   20d78:	8c3a      	ldrh	r2, [r7, #32]
   20d7a:	2106      	movs	r1, #6
   20d7c:	f7fe ff1c 	bl	1fbb8 <attsErrRsp>
}
   20d80:	bf00      	nop
   20d82:	3730      	adds	r7, #48	; 0x30
   20d84:	46bd      	mov	sp, r7
   20d86:	bd80      	pop	{r7, pc}

00020d88 <attsProcReadTypeReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcReadTypeReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   20d88:	b590      	push	{r4, r7, lr}
   20d8a:	b08f      	sub	sp, #60	; 0x3c
   20d8c:	af02      	add	r7, sp, #8
   20d8e:	60f8      	str	r0, [r7, #12]
   20d90:	460b      	mov	r3, r1
   20d92:	607a      	str	r2, [r7, #4]
   20d94:	817b      	strh	r3, [r7, #10]
  uint16_t    startHandle;
  uint16_t    endHandle;
  uint16_t    handle;
  uint8_t     uuidLen;
  uint8_t     attLen;
  uint8_t     cbackErr = ATT_SUCCESS;
   20d96:	2300      	movs	r3, #0
   20d98:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  uint8_t     err = ATT_SUCCESS;
   20d9c:	2300      	movs	r3, #0
   20d9e:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

  /* parse handles; pPacket then points to the uuid */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   20da2:	687b      	ldr	r3, [r7, #4]
   20da4:	3309      	adds	r3, #9
   20da6:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(startHandle, pPacket);
   20da8:	687b      	ldr	r3, [r7, #4]
   20daa:	781b      	ldrb	r3, [r3, #0]
   20dac:	b29a      	uxth	r2, r3
   20dae:	687b      	ldr	r3, [r7, #4]
   20db0:	3301      	adds	r3, #1
   20db2:	781b      	ldrb	r3, [r3, #0]
   20db4:	b29b      	uxth	r3, r3
   20db6:	021b      	lsls	r3, r3, #8
   20db8:	b29b      	uxth	r3, r3
   20dba:	4413      	add	r3, r2
   20dbc:	84fb      	strh	r3, [r7, #38]	; 0x26
   20dbe:	687b      	ldr	r3, [r7, #4]
   20dc0:	3302      	adds	r3, #2
   20dc2:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(endHandle, pPacket);
   20dc4:	687b      	ldr	r3, [r7, #4]
   20dc6:	781b      	ldrb	r3, [r3, #0]
   20dc8:	b29a      	uxth	r2, r3
   20dca:	687b      	ldr	r3, [r7, #4]
   20dcc:	3301      	adds	r3, #1
   20dce:	781b      	ldrb	r3, [r3, #0]
   20dd0:	b29b      	uxth	r3, r3
   20dd2:	021b      	lsls	r3, r3, #8
   20dd4:	b29b      	uxth	r3, r3
   20dd6:	4413      	add	r3, r2
   20dd8:	843b      	strh	r3, [r7, #32]
   20dda:	687b      	ldr	r3, [r7, #4]
   20ddc:	3302      	adds	r3, #2
   20dde:	607b      	str	r3, [r7, #4]

  /* get and verify uuid length */
  uuidLen = len - ATT_READ_TYPE_REQ_LEN;
   20de0:	897b      	ldrh	r3, [r7, #10]
   20de2:	b2db      	uxtb	r3, r3
   20de4:	3b05      	subs	r3, #5
   20de6:	77fb      	strb	r3, [r7, #31]
  if (!((uuidLen == ATT_16_UUID_LEN) || (uuidLen == ATT_128_UUID_LEN)))
   20de8:	7ffb      	ldrb	r3, [r7, #31]
   20dea:	2b02      	cmp	r3, #2
   20dec:	d006      	beq.n	20dfc <attsProcReadTypeReq+0x74>
   20dee:	7ffb      	ldrb	r3, [r7, #31]
   20df0:	2b10      	cmp	r3, #16
   20df2:	d003      	beq.n	20dfc <attsProcReadTypeReq+0x74>
  {
    err = ATT_ERR_INVALID_PDU;
   20df4:	2304      	movs	r3, #4
   20df6:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   20dfa:	e009      	b.n	20e10 <attsProcReadTypeReq+0x88>
  }
  /* verify handles */
  else if ((startHandle == 0) || (startHandle > endHandle))
   20dfc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   20dfe:	2b00      	cmp	r3, #0
   20e00:	d003      	beq.n	20e0a <attsProcReadTypeReq+0x82>
   20e02:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   20e04:	8c3b      	ldrh	r3, [r7, #32]
   20e06:	429a      	cmp	r2, r3
   20e08:	d902      	bls.n	20e10 <attsProcReadTypeReq+0x88>
  {
    err = ATT_ERR_HANDLE;
   20e0a:	2301      	movs	r3, #1
   20e0c:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
  }

  if (!err)
   20e10:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   20e14:	2b00      	cmp	r3, #0
   20e16:	f040 8153 	bne.w	210c0 <attsProcReadTypeReq+0x338>
  {
    /* find first attribute with matching uuid within handle range */
    handle = attsFindUuidInRange(startHandle, endHandle, uuidLen, pPacket, &pAttr, &pGroup);
   20e1a:	7ffa      	ldrb	r2, [r7, #31]
   20e1c:	8c39      	ldrh	r1, [r7, #32]
   20e1e:	8cf8      	ldrh	r0, [r7, #38]	; 0x26
   20e20:	f107 0314 	add.w	r3, r7, #20
   20e24:	9301      	str	r3, [sp, #4]
   20e26:	f107 0318 	add.w	r3, r7, #24
   20e2a:	9300      	str	r3, [sp, #0]
   20e2c:	687b      	ldr	r3, [r7, #4]
   20e2e:	f7ff fd1b 	bl	20868 <attsFindUuidInRange>
   20e32:	4603      	mov	r3, r0
   20e34:	84bb      	strh	r3, [r7, #36]	; 0x24
    startHandle = handle;
   20e36:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20e38:	84fb      	strh	r3, [r7, #38]	; 0x26

    if (handle == ATT_HANDLE_NONE)
   20e3a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20e3c:	2b00      	cmp	r3, #0
   20e3e:	d103      	bne.n	20e48 <attsProcReadTypeReq+0xc0>
    {
      err = ATT_ERR_NOT_FOUND;
   20e40:	230a      	movs	r3, #10
   20e42:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   20e46:	e03c      	b.n	20ec2 <attsProcReadTypeReq+0x13a>
    }
    /* check permissions */
    else if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   20e48:	68fb      	ldr	r3, [r7, #12]
   20e4a:	7f18      	ldrb	r0, [r3, #28]
                                    handle, pAttr->permissions)) != ATT_SUCCESS)
   20e4c:	69bb      	ldr	r3, [r7, #24]
    else if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   20e4e:	7bdb      	ldrb	r3, [r3, #15]
   20e50:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20e52:	2101      	movs	r1, #1
   20e54:	f7ff fab4 	bl	203c0 <attsPermissions>
   20e58:	4603      	mov	r3, r0
   20e5a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   20e5e:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   20e62:	2b00      	cmp	r3, #0
   20e64:	d12d      	bne.n	20ec2 <attsProcReadTypeReq+0x13a>
    {
      /* err is set above */
    }
    /* check if read callback should be called */
    else if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20e66:	69bb      	ldr	r3, [r7, #24]
   20e68:	7b9b      	ldrb	r3, [r3, #14]
   20e6a:	f003 0304 	and.w	r3, r3, #4
   20e6e:	2b00      	cmp	r3, #0
   20e70:	d011      	beq.n	20e96 <attsProcReadTypeReq+0x10e>
             (pGroup->readCback != NULL))
   20e72:	697b      	ldr	r3, [r7, #20]
   20e74:	689b      	ldr	r3, [r3, #8]
    else if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20e76:	2b00      	cmp	r3, #0
   20e78:	d00d      	beq.n	20e96 <attsProcReadTypeReq+0x10e>
    {
      err = (*pGroup->readCback)(pCcb->connId, handle, ATT_PDU_READ_TYPE_REQ, 0, pAttr);
   20e7a:	697b      	ldr	r3, [r7, #20]
   20e7c:	689c      	ldr	r4, [r3, #8]
   20e7e:	68fb      	ldr	r3, [r7, #12]
   20e80:	7f18      	ldrb	r0, [r3, #28]
   20e82:	69bb      	ldr	r3, [r7, #24]
   20e84:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
   20e86:	9300      	str	r3, [sp, #0]
   20e88:	2300      	movs	r3, #0
   20e8a:	2208      	movs	r2, #8
   20e8c:	47a0      	blx	r4
   20e8e:	4603      	mov	r3, r0
   20e90:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   20e94:	e015      	b.n	20ec2 <attsProcReadTypeReq+0x13a>
    }
    /* else check if CCC */
    else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   20e96:	69bb      	ldr	r3, [r7, #24]
   20e98:	7b9b      	ldrb	r3, [r3, #14]
   20e9a:	f003 0320 	and.w	r3, r3, #32
   20e9e:	2b00      	cmp	r3, #0
   20ea0:	d00f      	beq.n	20ec2 <attsProcReadTypeReq+0x13a>
   20ea2:	4b95      	ldr	r3, [pc, #596]	; (210f8 <attsProcReadTypeReq+0x370>)
   20ea4:	695b      	ldr	r3, [r3, #20]
   20ea6:	2b00      	cmp	r3, #0
   20ea8:	d00b      	beq.n	20ec2 <attsProcReadTypeReq+0x13a>
    {
      err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_READ, handle, pAttr->pValue);
   20eaa:	4b93      	ldr	r3, [pc, #588]	; (210f8 <attsProcReadTypeReq+0x370>)
   20eac:	695c      	ldr	r4, [r3, #20]
   20eae:	68fb      	ldr	r3, [r7, #12]
   20eb0:	7f18      	ldrb	r0, [r3, #28]
   20eb2:	69bb      	ldr	r3, [r7, #24]
   20eb4:	685b      	ldr	r3, [r3, #4]
   20eb6:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20eb8:	2105      	movs	r1, #5
   20eba:	47a0      	blx	r4
   20ebc:	4603      	mov	r3, r0
   20ebe:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
    }

    if (err == ATT_SUCCESS)
   20ec2:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   20ec6:	2b00      	cmp	r3, #0
   20ec8:	f040 80fa 	bne.w	210c0 <attsProcReadTypeReq+0x338>
    {
      /* Check if UUID is the Database Hash Characteristic Value and the value is being
       * re-calculated
       */
      if ((memcmp(pPacket, attGattDbhChUuid, ATT_16_UUID_LEN) == 0) && attsCsfGetHashUpdateStatus())
   20ecc:	2202      	movs	r2, #2
   20ece:	498b      	ldr	r1, [pc, #556]	; (210fc <attsProcReadTypeReq+0x374>)
   20ed0:	6878      	ldr	r0, [r7, #4]
   20ed2:	f00f f871 	bl	2ffb8 <memcmp>
   20ed6:	4603      	mov	r3, r0
   20ed8:	2b00      	cmp	r3, #0
   20eda:	d11f      	bne.n	20f1c <attsProcReadTypeReq+0x194>
   20edc:	f7fe f926 	bl	1f12c <attsCsfGetHashUpdateStatus>
   20ee0:	4603      	mov	r3, r0
   20ee2:	2b00      	cmp	r3, #0
   20ee4:	d01a      	beq.n	20f1c <attsProcReadTypeReq+0x194>
      {
        /* Store info and return */
        pCcb->pPendDbHashRsp = WsfBufAlloc(sizeof(attPendDbHashRsp_t));
   20ee6:	2004      	movs	r0, #4
   20ee8:	f00c f852 	bl	2cf90 <WsfBufAlloc>
   20eec:	4602      	mov	r2, r0
   20eee:	68fb      	ldr	r3, [r7, #12]
   20ef0:	621a      	str	r2, [r3, #32]
        if (pCcb->pPendDbHashRsp)
   20ef2:	68fb      	ldr	r3, [r7, #12]
   20ef4:	6a1b      	ldr	r3, [r3, #32]
   20ef6:	2b00      	cmp	r3, #0
   20ef8:	d008      	beq.n	20f0c <attsProcReadTypeReq+0x184>
        {
          pCcb->pPendDbHashRsp->startHandle = startHandle;
   20efa:	68fb      	ldr	r3, [r7, #12]
   20efc:	6a1b      	ldr	r3, [r3, #32]
   20efe:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   20f00:	801a      	strh	r2, [r3, #0]
          pCcb->pPendDbHashRsp->handle = handle;
   20f02:	68fb      	ldr	r3, [r7, #12]
   20f04:	6a1b      	ldr	r3, [r3, #32]
   20f06:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20f08:	805a      	strh	r2, [r3, #2]
        else
        {
          attsErrRsp(pCcb->handle, ATT_PDU_READ_TYPE_REQ, startHandle, ATT_ERR_RESOURCES);
        }

        return;
   20f0a:	e0f1      	b.n	210f0 <attsProcReadTypeReq+0x368>
          attsErrRsp(pCcb->handle, ATT_PDU_READ_TYPE_REQ, startHandle, ATT_ERR_RESOURCES);
   20f0c:	68fb      	ldr	r3, [r7, #12]
   20f0e:	8b18      	ldrh	r0, [r3, #24]
   20f10:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   20f12:	2311      	movs	r3, #17
   20f14:	2108      	movs	r1, #8
   20f16:	f7fe fe4f 	bl	1fbb8 <attsErrRsp>
   20f1a:	e0e9      	b.n	210f0 <attsProcReadTypeReq+0x368>
      }

      /* allocate max size buffer for response */
      if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   20f1c:	68fb      	ldr	r3, [r7, #12]
   20f1e:	8b5b      	ldrh	r3, [r3, #26]
   20f20:	3308      	adds	r3, #8
   20f22:	b29b      	uxth	r3, r3
   20f24:	4618      	mov	r0, r3
   20f26:	f7fc fd5f 	bl	1d9e8 <attMsgAlloc>
   20f2a:	62f8      	str	r0, [r7, #44]	; 0x2c
   20f2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20f2e:	2b00      	cmp	r3, #0
   20f30:	f000 80bd 	beq.w	210ae <attsProcReadTypeReq+0x326>
      {
        p = pBuf + L2C_PAYLOAD_START;
   20f34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   20f36:	3308      	adds	r3, #8
   20f38:	62bb      	str	r3, [r7, #40]	; 0x28
        UINT8_TO_BSTREAM(p, ATT_PDU_READ_TYPE_RSP);
   20f3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20f3c:	1c5a      	adds	r2, r3, #1
   20f3e:	62ba      	str	r2, [r7, #40]	; 0x28
   20f40:	2209      	movs	r2, #9
   20f42:	701a      	strb	r2, [r3, #0]

        /* get length of this first attribute */
        attLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_TYPE_RSP_LEN - sizeof(uint16_t))) ?
   20f44:	68fb      	ldr	r3, [r7, #12]
   20f46:	8b5b      	ldrh	r3, [r3, #26]
   20f48:	3b04      	subs	r3, #4
   20f4a:	69ba      	ldr	r2, [r7, #24]
   20f4c:	6892      	ldr	r2, [r2, #8]
   20f4e:	8812      	ldrh	r2, [r2, #0]
                  *pAttr->pLen : (pCcb->mtu - ATT_READ_TYPE_RSP_LEN - sizeof(uint16_t));
   20f50:	4293      	cmp	r3, r2
   20f52:	bf28      	it	cs
   20f54:	4613      	movcs	r3, r2
        attLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_TYPE_RSP_LEN - sizeof(uint16_t))) ?
   20f56:	77bb      	strb	r3, [r7, #30]

        /* set length parameter in response message */
        UINT8_TO_BSTREAM(p, attLen + sizeof(uint16_t));
   20f58:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20f5a:	1c5a      	adds	r2, r3, #1
   20f5c:	62ba      	str	r2, [r7, #40]	; 0x28
   20f5e:	7fba      	ldrb	r2, [r7, #30]
   20f60:	3202      	adds	r2, #2
   20f62:	b2d2      	uxtb	r2, r2
   20f64:	701a      	strb	r2, [r3, #0]

        /* copy result to response message */
        UINT16_TO_BSTREAM(p, handle);
   20f66:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20f68:	1c5a      	adds	r2, r3, #1
   20f6a:	62ba      	str	r2, [r7, #40]	; 0x28
   20f6c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20f6e:	b2d2      	uxtb	r2, r2
   20f70:	701a      	strb	r2, [r3, #0]
   20f72:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20f74:	0a1b      	lsrs	r3, r3, #8
   20f76:	b299      	uxth	r1, r3
   20f78:	6abb      	ldr	r3, [r7, #40]	; 0x28
   20f7a:	1c5a      	adds	r2, r3, #1
   20f7c:	62ba      	str	r2, [r7, #40]	; 0x28
   20f7e:	b2ca      	uxtb	r2, r1
   20f80:	701a      	strb	r2, [r3, #0]
        memcpy(p, pAttr->pValue, attLen);
   20f82:	69bb      	ldr	r3, [r7, #24]
   20f84:	685b      	ldr	r3, [r3, #4]
   20f86:	7fba      	ldrb	r2, [r7, #30]
   20f88:	4619      	mov	r1, r3
   20f8a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   20f8c:	f7f7 f962 	bl	18254 <memcpy>
        p += attLen;
   20f90:	7fbb      	ldrb	r3, [r7, #30]
   20f92:	6aba      	ldr	r2, [r7, #40]	; 0x28
   20f94:	4413      	add	r3, r2
   20f96:	62bb      	str	r3, [r7, #40]	; 0x28

        /* look for additional attributes */
        handle++;
   20f98:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   20f9a:	3301      	adds	r3, #1
   20f9c:	84bb      	strh	r3, [r7, #36]	; 0x24
        while ((handle = attsFindUuidInRange(handle, endHandle, uuidLen,
   20f9e:	e073      	b.n	21088 <attsProcReadTypeReq+0x300>
                                             pPacket, &pAttr, &pGroup)) != ATT_HANDLE_NONE)
        {
          /* call read callback if desired */
          if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20fa0:	69bb      	ldr	r3, [r7, #24]
   20fa2:	7b9b      	ldrb	r3, [r3, #14]
   20fa4:	f003 0304 	and.w	r3, r3, #4
   20fa8:	2b00      	cmp	r3, #0
   20faa:	d011      	beq.n	20fd0 <attsProcReadTypeReq+0x248>
              (pGroup->readCback != NULL))
   20fac:	697b      	ldr	r3, [r7, #20]
   20fae:	689b      	ldr	r3, [r3, #8]
          if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   20fb0:	2b00      	cmp	r3, #0
   20fb2:	d00d      	beq.n	20fd0 <attsProcReadTypeReq+0x248>
          {
            cbackErr = (*pGroup->readCback)(pCcb->connId, handle, ATT_PDU_READ_TYPE_REQ, 0, pAttr);
   20fb4:	697b      	ldr	r3, [r7, #20]
   20fb6:	689c      	ldr	r4, [r3, #8]
   20fb8:	68fb      	ldr	r3, [r7, #12]
   20fba:	7f18      	ldrb	r0, [r3, #28]
   20fbc:	69bb      	ldr	r3, [r7, #24]
   20fbe:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
   20fc0:	9300      	str	r3, [sp, #0]
   20fc2:	2300      	movs	r3, #0
   20fc4:	2208      	movs	r2, #8
   20fc6:	47a0      	blx	r4
   20fc8:	4603      	mov	r3, r0
   20fca:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   20fce:	e015      	b.n	20ffc <attsProcReadTypeReq+0x274>
          }
          /* else check if CCC */
          else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   20fd0:	69bb      	ldr	r3, [r7, #24]
   20fd2:	7b9b      	ldrb	r3, [r3, #14]
   20fd4:	f003 0320 	and.w	r3, r3, #32
   20fd8:	2b00      	cmp	r3, #0
   20fda:	d00f      	beq.n	20ffc <attsProcReadTypeReq+0x274>
   20fdc:	4b46      	ldr	r3, [pc, #280]	; (210f8 <attsProcReadTypeReq+0x370>)
   20fde:	695b      	ldr	r3, [r3, #20]
   20fe0:	2b00      	cmp	r3, #0
   20fe2:	d00b      	beq.n	20ffc <attsProcReadTypeReq+0x274>
          {
            cbackErr = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_READ, handle, pAttr->pValue);
   20fe4:	4b44      	ldr	r3, [pc, #272]	; (210f8 <attsProcReadTypeReq+0x370>)
   20fe6:	695c      	ldr	r4, [r3, #20]
   20fe8:	68fb      	ldr	r3, [r7, #12]
   20fea:	7f18      	ldrb	r0, [r3, #28]
   20fec:	69bb      	ldr	r3, [r7, #24]
   20fee:	685b      	ldr	r3, [r3, #4]
   20ff0:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   20ff2:	2105      	movs	r1, #5
   20ff4:	47a0      	blx	r4
   20ff6:	4603      	mov	r3, r0
   20ff8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

          /* verify no error from read callback
           * verify length is same as first found attribute
           * verify attribute permissions
           */
          if ((cbackErr == ATT_SUCCESS) &&
   20ffc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21000:	2b00      	cmp	r3, #0
   21002:	d15d      	bne.n	210c0 <attsProcReadTypeReq+0x338>
              (*pAttr->pLen == attLen) &&
   21004:	69bb      	ldr	r3, [r7, #24]
   21006:	689b      	ldr	r3, [r3, #8]
   21008:	881a      	ldrh	r2, [r3, #0]
   2100a:	7fbb      	ldrb	r3, [r7, #30]
   2100c:	b29b      	uxth	r3, r3
          if ((cbackErr == ATT_SUCCESS) &&
   2100e:	429a      	cmp	r2, r3
   21010:	d156      	bne.n	210c0 <attsProcReadTypeReq+0x338>
              (attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   21012:	68fb      	ldr	r3, [r7, #12]
   21014:	7f18      	ldrb	r0, [r3, #28]
                               handle, pAttr->permissions) == ATT_SUCCESS))
   21016:	69bb      	ldr	r3, [r7, #24]
              (attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   21018:	7bdb      	ldrb	r3, [r3, #15]
   2101a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   2101c:	2101      	movs	r1, #1
   2101e:	f7ff f9cf 	bl	203c0 <attsPermissions>
   21022:	4603      	mov	r3, r0
              (*pAttr->pLen == attLen) &&
   21024:	2b00      	cmp	r3, #0
   21026:	d14b      	bne.n	210c0 <attsProcReadTypeReq+0x338>
          {
            /* copy result into response buffer; first check if it fits */
            if (p <= (pBuf + pCcb->mtu + L2C_PAYLOAD_START - attLen - sizeof(uint16_t)))
   21028:	68fb      	ldr	r3, [r7, #12]
   2102a:	8b5b      	ldrh	r3, [r3, #26]
   2102c:	461a      	mov	r2, r3
   2102e:	7fbb      	ldrb	r3, [r7, #30]
   21030:	1ad3      	subs	r3, r2, r3
   21032:	3306      	adds	r3, #6
   21034:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   21036:	4413      	add	r3, r2
   21038:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2103a:	429a      	cmp	r2, r3
   2103c:	d83b      	bhi.n	210b6 <attsProcReadTypeReq+0x32e>
            {
              UINT16_TO_BSTREAM(p, handle);
   2103e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21040:	1c5a      	adds	r2, r3, #1
   21042:	62ba      	str	r2, [r7, #40]	; 0x28
   21044:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21046:	b2d2      	uxtb	r2, r2
   21048:	701a      	strb	r2, [r3, #0]
   2104a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2104c:	0a1b      	lsrs	r3, r3, #8
   2104e:	b299      	uxth	r1, r3
   21050:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21052:	1c5a      	adds	r2, r3, #1
   21054:	62ba      	str	r2, [r7, #40]	; 0x28
   21056:	b2ca      	uxtb	r2, r1
   21058:	701a      	strb	r2, [r3, #0]
              memcpy(p, pAttr->pValue, attLen);
   2105a:	69bb      	ldr	r3, [r7, #24]
   2105c:	685b      	ldr	r3, [r3, #4]
   2105e:	7fba      	ldrb	r2, [r7, #30]
   21060:	4619      	mov	r1, r3
   21062:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   21064:	f7f7 f8f6 	bl	18254 <memcpy>
              p += attLen;
   21068:	7fbb      	ldrb	r3, [r7, #30]
   2106a:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2106c:	4413      	add	r3, r2
   2106e:	62bb      	str	r3, [r7, #40]	; 0x28
            /* problem with read callback, length, or permissions; send what we've got so far */
            break;
          }

          /* special case of handle at max range */
          if (handle == ATT_HANDLE_MAX)
   21070:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21072:	f64f 72ff 	movw	r2, #65535	; 0xffff
   21076:	4293      	cmp	r3, r2
   21078:	d01f      	beq.n	210ba <attsProcReadTypeReq+0x332>
          {
            break;
          }

          /* try next handle */
          if (++handle > endHandle)
   2107a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2107c:	3301      	adds	r3, #1
   2107e:	84bb      	strh	r3, [r7, #36]	; 0x24
   21080:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21082:	8c3b      	ldrh	r3, [r7, #32]
   21084:	429a      	cmp	r2, r3
   21086:	d81a      	bhi.n	210be <attsProcReadTypeReq+0x336>
        while ((handle = attsFindUuidInRange(handle, endHandle, uuidLen,
   21088:	7ffa      	ldrb	r2, [r7, #31]
   2108a:	8c39      	ldrh	r1, [r7, #32]
   2108c:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
   2108e:	f107 0314 	add.w	r3, r7, #20
   21092:	9301      	str	r3, [sp, #4]
   21094:	f107 0318 	add.w	r3, r7, #24
   21098:	9300      	str	r3, [sp, #0]
   2109a:	687b      	ldr	r3, [r7, #4]
   2109c:	f7ff fbe4 	bl	20868 <attsFindUuidInRange>
   210a0:	4603      	mov	r3, r0
   210a2:	84bb      	strh	r3, [r7, #36]	; 0x24
   210a4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   210a6:	2b00      	cmp	r3, #0
   210a8:	f47f af7a 	bne.w	20fa0 <attsProcReadTypeReq+0x218>
   210ac:	e008      	b.n	210c0 <attsProcReadTypeReq+0x338>
        }
      }
      else
      {
        /* buffer allocation failed */
        err = ATT_ERR_RESOURCES;
   210ae:	2311      	movs	r3, #17
   210b0:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
   210b4:	e004      	b.n	210c0 <attsProcReadTypeReq+0x338>
              break;
   210b6:	bf00      	nop
   210b8:	e002      	b.n	210c0 <attsProcReadTypeReq+0x338>
            break;
   210ba:	bf00      	nop
   210bc:	e000      	b.n	210c0 <attsProcReadTypeReq+0x338>
            break;
   210be:	bf00      	nop
      }
    }
  }

  /* if no error send response, else send error */
  if (!err)
   210c0:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   210c4:	2b00      	cmp	r3, #0
   210c6:	d10b      	bne.n	210e0 <attsProcReadTypeReq+0x358>
  {
    L2cDataReq(L2C_CID_ATT, pCcb->handle, (p - (pBuf + L2C_PAYLOAD_START)), pBuf);
   210c8:	68fb      	ldr	r3, [r7, #12]
   210ca:	8b19      	ldrh	r1, [r3, #24]
   210cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   210ce:	3308      	adds	r3, #8
   210d0:	6aba      	ldr	r2, [r7, #40]	; 0x28
   210d2:	1ad3      	subs	r3, r2, r3
   210d4:	b29a      	uxth	r2, r3
   210d6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   210d8:	2004      	movs	r0, #4
   210da:	f008 ff05 	bl	29ee8 <L2cDataReq>
   210de:	e007      	b.n	210f0 <attsProcReadTypeReq+0x368>
  }
  else
  {
    attsErrRsp(pCcb->handle, ATT_PDU_READ_TYPE_REQ, startHandle, err);
   210e0:	68fb      	ldr	r3, [r7, #12]
   210e2:	8b18      	ldrh	r0, [r3, #24]
   210e4:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
   210e8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   210ea:	2108      	movs	r1, #8
   210ec:	f7fe fd64 	bl	1fbb8 <attsErrRsp>
  }
}
   210f0:	3734      	adds	r7, #52	; 0x34
   210f2:	46bd      	mov	sp, r7
   210f4:	bd90      	pop	{r4, r7, pc}
   210f6:	bf00      	nop
   210f8:	100111dc 	.word	0x100111dc
   210fc:	00045afc 	.word	0x00045afc

00021100 <attsProcReadMultReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcReadMultReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   21100:	b590      	push	{r4, r7, lr}
   21102:	b08f      	sub	sp, #60	; 0x3c
   21104:	af02      	add	r7, sp, #8
   21106:	60f8      	str	r0, [r7, #12]
   21108:	460b      	mov	r3, r1
   2110a:	607a      	str	r2, [r7, #4]
   2110c:	817b      	strh	r3, [r7, #10]
  uint8_t     *pBuf;
  uint8_t     *p;
  uint8_t     *pEnd;
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint16_t    handle = ATT_HANDLE_NONE;
   2110e:	2300      	movs	r3, #0
   21110:	857b      	strh	r3, [r7, #42]	; 0x2a
  uint16_t    readLen;
  uint8_t     err = ATT_SUCCESS;
   21112:	2300      	movs	r3, #0
   21114:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

  /* points to end of payload */
  pEnd = pPacket + L2C_PAYLOAD_START + len;
   21118:	897b      	ldrh	r3, [r7, #10]
   2111a:	3308      	adds	r3, #8
   2111c:	687a      	ldr	r2, [r7, #4]
   2111e:	4413      	add	r3, r2
   21120:	627b      	str	r3, [r7, #36]	; 0x24

  /* points to first handle */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   21122:	687b      	ldr	r3, [r7, #4]
   21124:	3309      	adds	r3, #9
   21126:	607b      	str	r3, [r7, #4]

  /* allocate max size buffer for response */
  if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   21128:	68fb      	ldr	r3, [r7, #12]
   2112a:	8b5b      	ldrh	r3, [r3, #26]
   2112c:	3308      	adds	r3, #8
   2112e:	b29b      	uxth	r3, r3
   21130:	4618      	mov	r0, r3
   21132:	f7fc fc59 	bl	1d9e8 <attMsgAlloc>
   21136:	6238      	str	r0, [r7, #32]
   21138:	6a3b      	ldr	r3, [r7, #32]
   2113a:	2b00      	cmp	r3, #0
   2113c:	f000 8094 	beq.w	21268 <attsProcReadMultReq+0x168>
  {
    p = pBuf + L2C_PAYLOAD_START;
   21140:	6a3b      	ldr	r3, [r7, #32]
   21142:	3308      	adds	r3, #8
   21144:	62fb      	str	r3, [r7, #44]	; 0x2c
    UINT8_TO_BSTREAM(p, ATT_PDU_READ_MULT_RSP);
   21146:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21148:	1c5a      	adds	r2, r3, #1
   2114a:	62fa      	str	r2, [r7, #44]	; 0x2c
   2114c:	220f      	movs	r2, #15
   2114e:	701a      	strb	r2, [r3, #0]

    /* while there are handles remaining and there is space in response buffer */
    while (pPacket < pEnd)
   21150:	e084      	b.n	2125c <attsProcReadMultReq+0x15c>
    {
      /* parse handle */
      BSTREAM_TO_UINT16(handle, pPacket);
   21152:	687b      	ldr	r3, [r7, #4]
   21154:	781b      	ldrb	r3, [r3, #0]
   21156:	b29a      	uxth	r2, r3
   21158:	687b      	ldr	r3, [r7, #4]
   2115a:	3301      	adds	r3, #1
   2115c:	781b      	ldrb	r3, [r3, #0]
   2115e:	b29b      	uxth	r3, r3
   21160:	021b      	lsls	r3, r3, #8
   21162:	b29b      	uxth	r3, r3
   21164:	4413      	add	r3, r2
   21166:	857b      	strh	r3, [r7, #42]	; 0x2a
   21168:	687b      	ldr	r3, [r7, #4]
   2116a:	3302      	adds	r3, #2
   2116c:	607b      	str	r3, [r7, #4]

      /* find attribute */
      if ((pAttr = attsFindByHandle(handle, &pGroup)) == NULL)
   2116e:	f107 0214 	add.w	r2, r7, #20
   21172:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
   21174:	4611      	mov	r1, r2
   21176:	4618      	mov	r0, r3
   21178:	f7ff f8b4 	bl	202e4 <attsFindByHandle>
   2117c:	61f8      	str	r0, [r7, #28]
   2117e:	69fb      	ldr	r3, [r7, #28]
   21180:	2b00      	cmp	r3, #0
   21182:	d103      	bne.n	2118c <attsProcReadMultReq+0x8c>
      {
        err = ATT_ERR_HANDLE;
   21184:	2301      	movs	r3, #1
   21186:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
        break;
   2118a:	e074      	b.n	21276 <attsProcReadMultReq+0x176>
      }

      /* verify permissions */
      if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   2118c:	68fb      	ldr	r3, [r7, #12]
   2118e:	7f18      	ldrb	r0, [r3, #28]
   21190:	69fb      	ldr	r3, [r7, #28]
   21192:	7bdb      	ldrb	r3, [r3, #15]
   21194:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   21196:	2101      	movs	r1, #1
   21198:	f7ff f912 	bl	203c0 <attsPermissions>
   2119c:	4603      	mov	r3, r0
   2119e:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
   211a2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
   211a6:	2b00      	cmp	r3, #0
   211a8:	d162      	bne.n	21270 <attsProcReadMultReq+0x170>
      {
        break;
      }

      /* call read callback if desired */
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   211aa:	69fb      	ldr	r3, [r7, #28]
   211ac:	7b9b      	ldrb	r3, [r3, #14]
   211ae:	f003 0304 	and.w	r3, r3, #4
   211b2:	2b00      	cmp	r3, #0
   211b4:	d015      	beq.n	211e2 <attsProcReadMultReq+0xe2>
          (pGroup->readCback != NULL))
   211b6:	697b      	ldr	r3, [r7, #20]
   211b8:	689b      	ldr	r3, [r3, #8]
      if ((pAttr->settings & ATTS_SET_READ_CBACK) &&
   211ba:	2b00      	cmp	r3, #0
   211bc:	d011      	beq.n	211e2 <attsProcReadMultReq+0xe2>
      {
        err = (*pGroup->readCback)(pCcb->connId, handle, ATT_PDU_READ_MULT_REQ, 0, pAttr);
   211be:	697b      	ldr	r3, [r7, #20]
   211c0:	689c      	ldr	r4, [r3, #8]
   211c2:	68fb      	ldr	r3, [r7, #12]
   211c4:	7f18      	ldrb	r0, [r3, #28]
   211c6:	8d79      	ldrh	r1, [r7, #42]	; 0x2a
   211c8:	69fb      	ldr	r3, [r7, #28]
   211ca:	9300      	str	r3, [sp, #0]
   211cc:	2300      	movs	r3, #0
   211ce:	220e      	movs	r2, #14
   211d0:	47a0      	blx	r4
   211d2:	4603      	mov	r3, r0
   211d4:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
        if (err != ATT_SUCCESS)
   211d8:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
   211dc:	2b00      	cmp	r3, #0
   211de:	d01a      	beq.n	21216 <attsProcReadMultReq+0x116>
        {
          break;
   211e0:	e049      	b.n	21276 <attsProcReadMultReq+0x176>
        }
      }
      /* else check if CCC */
      else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   211e2:	69fb      	ldr	r3, [r7, #28]
   211e4:	7b9b      	ldrb	r3, [r3, #14]
   211e6:	f003 0320 	and.w	r3, r3, #32
   211ea:	2b00      	cmp	r3, #0
   211ec:	d013      	beq.n	21216 <attsProcReadMultReq+0x116>
   211ee:	4b33      	ldr	r3, [pc, #204]	; (212bc <attsProcReadMultReq+0x1bc>)
   211f0:	695b      	ldr	r3, [r3, #20]
   211f2:	2b00      	cmp	r3, #0
   211f4:	d00f      	beq.n	21216 <attsProcReadMultReq+0x116>
      {
        err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_READ, handle, pAttr->pValue);
   211f6:	4b31      	ldr	r3, [pc, #196]	; (212bc <attsProcReadMultReq+0x1bc>)
   211f8:	695c      	ldr	r4, [r3, #20]
   211fa:	68fb      	ldr	r3, [r7, #12]
   211fc:	7f18      	ldrb	r0, [r3, #28]
   211fe:	69fb      	ldr	r3, [r7, #28]
   21200:	685b      	ldr	r3, [r3, #4]
   21202:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   21204:	2105      	movs	r1, #5
   21206:	47a0      	blx	r4
   21208:	4603      	mov	r3, r0
   2120a:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
        if (err != ATT_SUCCESS)
   2120e:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
   21212:	2b00      	cmp	r3, #0
   21214:	d12e      	bne.n	21274 <attsProcReadMultReq+0x174>
        {
          break;
        }
      }

      if (p < (pBuf + pCcb->mtu + L2C_PAYLOAD_START))
   21216:	68fb      	ldr	r3, [r7, #12]
   21218:	8b5b      	ldrh	r3, [r3, #26]
   2121a:	3308      	adds	r3, #8
   2121c:	6a3a      	ldr	r2, [r7, #32]
   2121e:	4413      	add	r3, r2
   21220:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   21222:	429a      	cmp	r2, r3
   21224:	d21a      	bcs.n	2125c <attsProcReadMultReq+0x15c>
      {
        /* calculate remaining space in response buffer */
        readLen = (pBuf + pCcb->mtu + L2C_PAYLOAD_START) - p;
   21226:	68fb      	ldr	r3, [r7, #12]
   21228:	8b5b      	ldrh	r3, [r3, #26]
   2122a:	3308      	adds	r3, #8
   2122c:	6a3a      	ldr	r2, [r7, #32]
   2122e:	441a      	add	r2, r3
   21230:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21232:	1ad3      	subs	r3, r2, r3
   21234:	837b      	strh	r3, [r7, #26]

        /* actual length is minimum of remaining space and attribute length */
        readLen = (*pAttr->pLen < readLen) ? *pAttr->pLen : readLen;
   21236:	69fb      	ldr	r3, [r7, #28]
   21238:	689b      	ldr	r3, [r3, #8]
   2123a:	881b      	ldrh	r3, [r3, #0]
   2123c:	8b7a      	ldrh	r2, [r7, #26]
   2123e:	4293      	cmp	r3, r2
   21240:	bf28      	it	cs
   21242:	4613      	movcs	r3, r2
   21244:	837b      	strh	r3, [r7, #26]

        /* copy attribute to response buffer */
        memcpy(p, pAttr->pValue, readLen);
   21246:	69fb      	ldr	r3, [r7, #28]
   21248:	685b      	ldr	r3, [r3, #4]
   2124a:	8b7a      	ldrh	r2, [r7, #26]
   2124c:	4619      	mov	r1, r3
   2124e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   21250:	f7f7 f800 	bl	18254 <memcpy>
        p += readLen;
   21254:	8b7b      	ldrh	r3, [r7, #26]
   21256:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   21258:	4413      	add	r3, r2
   2125a:	62fb      	str	r3, [r7, #44]	; 0x2c
    while (pPacket < pEnd)
   2125c:	687a      	ldr	r2, [r7, #4]
   2125e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21260:	429a      	cmp	r2, r3
   21262:	f4ff af76 	bcc.w	21152 <attsProcReadMultReq+0x52>
   21266:	e006      	b.n	21276 <attsProcReadMultReq+0x176>
    }
  }
  else
  {
    /* buffer allocation failed */
    err = ATT_ERR_RESOURCES;
   21268:	2311      	movs	r3, #17
   2126a:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29
   2126e:	e002      	b.n	21276 <attsProcReadMultReq+0x176>
        break;
   21270:	bf00      	nop
   21272:	e000      	b.n	21276 <attsProcReadMultReq+0x176>
          break;
   21274:	bf00      	nop
  }

  /* if no error send response, else send error */
  if (!err)
   21276:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
   2127a:	2b00      	cmp	r3, #0
   2127c:	d10b      	bne.n	21296 <attsProcReadMultReq+0x196>
  {
    L2cDataReq(L2C_CID_ATT, pCcb->handle, (p - (pBuf + L2C_PAYLOAD_START)), pBuf);
   2127e:	68fb      	ldr	r3, [r7, #12]
   21280:	8b19      	ldrh	r1, [r3, #24]
   21282:	6a3b      	ldr	r3, [r7, #32]
   21284:	3308      	adds	r3, #8
   21286:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   21288:	1ad3      	subs	r3, r2, r3
   2128a:	b29a      	uxth	r2, r3
   2128c:	6a3b      	ldr	r3, [r7, #32]
   2128e:	2004      	movs	r0, #4
   21290:	f008 fe2a 	bl	29ee8 <L2cDataReq>
      WsfMsgFree(pBuf);
    }

    attsErrRsp(pCcb->handle, ATT_PDU_READ_MULT_REQ, handle, err);
  }
}
   21294:	e00d      	b.n	212b2 <attsProcReadMultReq+0x1b2>
    if (pBuf != NULL)
   21296:	6a3b      	ldr	r3, [r7, #32]
   21298:	2b00      	cmp	r3, #0
   2129a:	d002      	beq.n	212a2 <attsProcReadMultReq+0x1a2>
      WsfMsgFree(pBuf);
   2129c:	6a38      	ldr	r0, [r7, #32]
   2129e:	f00b ff1d 	bl	2d0dc <WsfMsgFree>
    attsErrRsp(pCcb->handle, ATT_PDU_READ_MULT_REQ, handle, err);
   212a2:	68fb      	ldr	r3, [r7, #12]
   212a4:	8b18      	ldrh	r0, [r3, #24]
   212a6:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
   212aa:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
   212ac:	210e      	movs	r1, #14
   212ae:	f7fe fc83 	bl	1fbb8 <attsErrRsp>
}
   212b2:	bf00      	nop
   212b4:	3734      	adds	r7, #52	; 0x34
   212b6:	46bd      	mov	sp, r7
   212b8:	bd90      	pop	{r4, r7, pc}
   212ba:	bf00      	nop
   212bc:	100111dc 	.word	0x100111dc

000212c0 <attsProcReadGroupTypeReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcReadGroupTypeReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   212c0:	b580      	push	{r7, lr}
   212c2:	b08e      	sub	sp, #56	; 0x38
   212c4:	af02      	add	r7, sp, #8
   212c6:	60f8      	str	r0, [r7, #12]
   212c8:	460b      	mov	r3, r1
   212ca:	607a      	str	r2, [r7, #4]
   212cc:	817b      	strh	r3, [r7, #10]
  uint8_t     *pBuf = NULL;
   212ce:	2300      	movs	r3, #0
   212d0:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint8_t     *p = NULL;
   212d2:	2300      	movs	r3, #0
   212d4:	62bb      	str	r3, [r7, #40]	; 0x28
  uint16_t    startHandle;
  uint16_t    endHandle;
  uint16_t    handle;
  uint8_t     uuidLen;
  uint8_t     attLen;
  uint8_t     err = ATT_SUCCESS;
   212d6:	2300      	movs	r3, #0
   212d8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  uint8_t     primSvcUuid[ATT_16_UUID_LEN] = {UINT16_TO_BYTES(ATT_UUID_PRIMARY_SERVICE)};
   212dc:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   212e0:	823b      	strh	r3, [r7, #16]

  /* parse handles; pPacket then points to the uuid */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   212e2:	687b      	ldr	r3, [r7, #4]
   212e4:	3309      	adds	r3, #9
   212e6:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(startHandle, pPacket);
   212e8:	687b      	ldr	r3, [r7, #4]
   212ea:	781b      	ldrb	r3, [r3, #0]
   212ec:	b29a      	uxth	r2, r3
   212ee:	687b      	ldr	r3, [r7, #4]
   212f0:	3301      	adds	r3, #1
   212f2:	781b      	ldrb	r3, [r3, #0]
   212f4:	b29b      	uxth	r3, r3
   212f6:	021b      	lsls	r3, r3, #8
   212f8:	b29b      	uxth	r3, r3
   212fa:	4413      	add	r3, r2
   212fc:	84fb      	strh	r3, [r7, #38]	; 0x26
   212fe:	687b      	ldr	r3, [r7, #4]
   21300:	3302      	adds	r3, #2
   21302:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(endHandle, pPacket);
   21304:	687b      	ldr	r3, [r7, #4]
   21306:	781b      	ldrb	r3, [r3, #0]
   21308:	b29a      	uxth	r2, r3
   2130a:	687b      	ldr	r3, [r7, #4]
   2130c:	3301      	adds	r3, #1
   2130e:	781b      	ldrb	r3, [r3, #0]
   21310:	b29b      	uxth	r3, r3
   21312:	021b      	lsls	r3, r3, #8
   21314:	b29b      	uxth	r3, r3
   21316:	4413      	add	r3, r2
   21318:	843b      	strh	r3, [r7, #32]
   2131a:	687b      	ldr	r3, [r7, #4]
   2131c:	3302      	adds	r3, #2
   2131e:	607b      	str	r3, [r7, #4]

  /* get and verify uuid length */
  uuidLen = len - ATT_READ_GROUP_TYPE_REQ_LEN;
   21320:	897b      	ldrh	r3, [r7, #10]
   21322:	b2db      	uxtb	r3, r3
   21324:	3b05      	subs	r3, #5
   21326:	77fb      	strb	r3, [r7, #31]
  if (!((uuidLen == ATT_16_UUID_LEN) || (uuidLen == ATT_128_UUID_LEN)))
   21328:	7ffb      	ldrb	r3, [r7, #31]
   2132a:	2b02      	cmp	r3, #2
   2132c:	d006      	beq.n	2133c <attsProcReadGroupTypeReq+0x7c>
   2132e:	7ffb      	ldrb	r3, [r7, #31]
   21330:	2b10      	cmp	r3, #16
   21332:	d003      	beq.n	2133c <attsProcReadGroupTypeReq+0x7c>
  {
    err = ATT_ERR_INVALID_PDU;
   21334:	2304      	movs	r3, #4
   21336:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   2133a:	e017      	b.n	2136c <attsProcReadGroupTypeReq+0xac>
  }
  /* verify handles */
  else if ((startHandle == 0) || (startHandle > endHandle))
   2133c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   2133e:	2b00      	cmp	r3, #0
   21340:	d003      	beq.n	2134a <attsProcReadGroupTypeReq+0x8a>
   21342:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   21344:	8c3b      	ldrh	r3, [r7, #32]
   21346:	429a      	cmp	r2, r3
   21348:	d903      	bls.n	21352 <attsProcReadGroupTypeReq+0x92>
  {
    err = ATT_ERR_HANDLE;
   2134a:	2301      	movs	r3, #1
   2134c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   21350:	e00c      	b.n	2136c <attsProcReadGroupTypeReq+0xac>
  }
  /* verify uuid is primary service group */
  else if (!attsUuid16Cmp(primSvcUuid, uuidLen, pPacket))
   21352:	7ff9      	ldrb	r1, [r7, #31]
   21354:	f107 0310 	add.w	r3, r7, #16
   21358:	687a      	ldr	r2, [r7, #4]
   2135a:	4618      	mov	r0, r3
   2135c:	f7fe ff9b 	bl	20296 <attsUuid16Cmp>
   21360:	4603      	mov	r3, r0
   21362:	2b00      	cmp	r3, #0
   21364:	d102      	bne.n	2136c <attsProcReadGroupTypeReq+0xac>
  {
    err = ATT_ERR_GROUP_TYPE;
   21366:	2310      	movs	r3, #16
   21368:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  }

  if (!err)
   2136c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21370:	2b00      	cmp	r3, #0
   21372:	f040 80ec 	bne.w	2154e <attsProcReadGroupTypeReq+0x28e>
  {
    /* find first attribute with matching uuid within handle range */
    handle = attsFindUuidInRange(startHandle, endHandle, uuidLen, pPacket, &pAttr, &pGroup);
   21376:	7ffa      	ldrb	r2, [r7, #31]
   21378:	8c39      	ldrh	r1, [r7, #32]
   2137a:	8cf8      	ldrh	r0, [r7, #38]	; 0x26
   2137c:	f107 0314 	add.w	r3, r7, #20
   21380:	9301      	str	r3, [sp, #4]
   21382:	f107 0318 	add.w	r3, r7, #24
   21386:	9300      	str	r3, [sp, #0]
   21388:	687b      	ldr	r3, [r7, #4]
   2138a:	f7ff fa6d 	bl	20868 <attsFindUuidInRange>
   2138e:	4603      	mov	r3, r0
   21390:	84bb      	strh	r3, [r7, #36]	; 0x24

    if (handle == ATT_HANDLE_NONE)
   21392:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21394:	2b00      	cmp	r3, #0
   21396:	d103      	bne.n	213a0 <attsProcReadGroupTypeReq+0xe0>
    {
      err = ATT_ERR_NOT_FOUND;
   21398:	230a      	movs	r3, #10
   2139a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   2139e:	e0d6      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
    }
    /* check permissions */
    else if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   213a0:	68fb      	ldr	r3, [r7, #12]
   213a2:	7f18      	ldrb	r0, [r3, #28]
                                    handle, pAttr->permissions)) != ATT_SUCCESS)
   213a4:	69bb      	ldr	r3, [r7, #24]
    else if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   213a6:	7bdb      	ldrb	r3, [r3, #15]
   213a8:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   213aa:	2101      	movs	r1, #1
   213ac:	f7ff f808 	bl	203c0 <attsPermissions>
   213b0:	4603      	mov	r3, r0
   213b2:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   213b6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   213ba:	2b00      	cmp	r3, #0
   213bc:	d002      	beq.n	213c4 <attsProcReadGroupTypeReq+0x104>
    {
      startHandle = handle;     /* this handle is returned in error response */
   213be:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   213c0:	84fb      	strh	r3, [r7, #38]	; 0x26
   213c2:	e0c4      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
    }
    else
    {
      /* allocate max size buffer for response */
      if ((pBuf = attMsgAlloc(pCcb->mtu + L2C_PAYLOAD_START)) != NULL)
   213c4:	68fb      	ldr	r3, [r7, #12]
   213c6:	8b5b      	ldrh	r3, [r3, #26]
   213c8:	3308      	adds	r3, #8
   213ca:	b29b      	uxth	r3, r3
   213cc:	4618      	mov	r0, r3
   213ce:	f7fc fb0b 	bl	1d9e8 <attMsgAlloc>
   213d2:	62f8      	str	r0, [r7, #44]	; 0x2c
   213d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   213d6:	2b00      	cmp	r3, #0
   213d8:	f000 80ae 	beq.w	21538 <attsProcReadGroupTypeReq+0x278>
      {
        p = pBuf + L2C_PAYLOAD_START;
   213dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   213de:	3308      	adds	r3, #8
   213e0:	62bb      	str	r3, [r7, #40]	; 0x28
        UINT8_TO_BSTREAM(p, ATT_PDU_READ_GROUP_TYPE_RSP);
   213e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   213e4:	1c5a      	adds	r2, r3, #1
   213e6:	62ba      	str	r2, [r7, #40]	; 0x28
   213e8:	2211      	movs	r2, #17
   213ea:	701a      	strb	r2, [r3, #0]

        /* get length of this first attribute */
        attLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_GROUP_TYPE_RSP_LEN - (2 * sizeof(uint16_t)))) ?
   213ec:	68fb      	ldr	r3, [r7, #12]
   213ee:	8b5b      	ldrh	r3, [r3, #26]
   213f0:	3b06      	subs	r3, #6
   213f2:	69ba      	ldr	r2, [r7, #24]
   213f4:	6892      	ldr	r2, [r2, #8]
   213f6:	8812      	ldrh	r2, [r2, #0]
                  *pAttr->pLen : (pCcb->mtu - ATT_READ_GROUP_TYPE_RSP_LEN - (2 * sizeof(uint16_t)));
   213f8:	4293      	cmp	r3, r2
   213fa:	bf28      	it	cs
   213fc:	4613      	movcs	r3, r2
        attLen = (*pAttr->pLen < (pCcb->mtu - ATT_READ_GROUP_TYPE_RSP_LEN - (2 * sizeof(uint16_t)))) ?
   213fe:	77bb      	strb	r3, [r7, #30]

        /* set length parameter in response message */
        UINT8_TO_BSTREAM(p, attLen + (2 * sizeof(uint16_t)));
   21400:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21402:	1c5a      	adds	r2, r3, #1
   21404:	62ba      	str	r2, [r7, #40]	; 0x28
   21406:	7fba      	ldrb	r2, [r7, #30]
   21408:	3204      	adds	r2, #4
   2140a:	b2d2      	uxtb	r2, r2
   2140c:	701a      	strb	r2, [r3, #0]

        /* copy handle to response message */
        UINT16_TO_BSTREAM(p, handle);
   2140e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21410:	1c5a      	adds	r2, r3, #1
   21412:	62ba      	str	r2, [r7, #40]	; 0x28
   21414:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21416:	b2d2      	uxtb	r2, r2
   21418:	701a      	strb	r2, [r3, #0]
   2141a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2141c:	0a1b      	lsrs	r3, r3, #8
   2141e:	b299      	uxth	r1, r3
   21420:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21422:	1c5a      	adds	r2, r3, #1
   21424:	62ba      	str	r2, [r7, #40]	; 0x28
   21426:	b2ca      	uxtb	r2, r1
   21428:	701a      	strb	r2, [r3, #0]

        /* get end group handle and copy it to response message */
        handle = attsFindServiceGroupEnd(handle);
   2142a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2142c:	4618      	mov	r0, r3
   2142e:	f7ff fa81 	bl	20934 <attsFindServiceGroupEnd>
   21432:	4603      	mov	r3, r0
   21434:	84bb      	strh	r3, [r7, #36]	; 0x24
        UINT16_TO_BSTREAM(p, handle);
   21436:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21438:	1c5a      	adds	r2, r3, #1
   2143a:	62ba      	str	r2, [r7, #40]	; 0x28
   2143c:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   2143e:	b2d2      	uxtb	r2, r2
   21440:	701a      	strb	r2, [r3, #0]
   21442:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21444:	0a1b      	lsrs	r3, r3, #8
   21446:	b299      	uxth	r1, r3
   21448:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2144a:	1c5a      	adds	r2, r3, #1
   2144c:	62ba      	str	r2, [r7, #40]	; 0x28
   2144e:	b2ca      	uxtb	r2, r1
   21450:	701a      	strb	r2, [r3, #0]

        /* copy the attribute value to response message */
        memcpy(p, pAttr->pValue, attLen);
   21452:	69bb      	ldr	r3, [r7, #24]
   21454:	685b      	ldr	r3, [r3, #4]
   21456:	7fba      	ldrb	r2, [r7, #30]
   21458:	4619      	mov	r1, r3
   2145a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2145c:	f7f6 fefa 	bl	18254 <memcpy>
        p += attLen;
   21460:	7fbb      	ldrb	r3, [r7, #30]
   21462:	6aba      	ldr	r2, [r7, #40]	; 0x28
   21464:	4413      	add	r3, r2
   21466:	62bb      	str	r3, [r7, #40]	; 0x28

        /* look for additional attributes */
        while (TRUE)
        {
          /* special case of handle at max range */
          if (handle == ATT_HANDLE_MAX)
   21468:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2146a:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2146e:	4293      	cmp	r3, r2
   21470:	d066      	beq.n	21540 <attsProcReadGroupTypeReq+0x280>
          {
            break;
          }

          /* increment to next handle */
          if (++handle > endHandle)
   21472:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21474:	3301      	adds	r3, #1
   21476:	84bb      	strh	r3, [r7, #36]	; 0x24
   21478:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   2147a:	8c3b      	ldrh	r3, [r7, #32]
   2147c:	429a      	cmp	r2, r3
   2147e:	d861      	bhi.n	21544 <attsProcReadGroupTypeReq+0x284>
          {
            break;
          }

          /* find next matching handle */
          if ((handle = attsFindUuidInRange(handle, endHandle, uuidLen,
   21480:	7ffa      	ldrb	r2, [r7, #31]
   21482:	8c39      	ldrh	r1, [r7, #32]
   21484:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
   21486:	f107 0314 	add.w	r3, r7, #20
   2148a:	9301      	str	r3, [sp, #4]
   2148c:	f107 0318 	add.w	r3, r7, #24
   21490:	9300      	str	r3, [sp, #0]
   21492:	687b      	ldr	r3, [r7, #4]
   21494:	f7ff f9e8 	bl	20868 <attsFindUuidInRange>
   21498:	4603      	mov	r3, r0
   2149a:	84bb      	strh	r3, [r7, #36]	; 0x24
   2149c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   2149e:	2b00      	cmp	r3, #0
   214a0:	d052      	beq.n	21548 <attsProcReadGroupTypeReq+0x288>
          }

          /* verify length is same as first found attribute
           * verify attribute permissions
           */
          if ((*pAttr->pLen == attLen) &&
   214a2:	69bb      	ldr	r3, [r7, #24]
   214a4:	689b      	ldr	r3, [r3, #8]
   214a6:	881a      	ldrh	r2, [r3, #0]
   214a8:	7fbb      	ldrb	r3, [r7, #30]
   214aa:	b29b      	uxth	r3, r3
   214ac:	429a      	cmp	r2, r3
   214ae:	d14e      	bne.n	2154e <attsProcReadGroupTypeReq+0x28e>
              (attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   214b0:	68fb      	ldr	r3, [r7, #12]
   214b2:	7f18      	ldrb	r0, [r3, #28]
                               handle, pAttr->permissions) == ATT_SUCCESS))
   214b4:	69bb      	ldr	r3, [r7, #24]
              (attsPermissions(pCcb->connId, ATTS_PERMIT_READ,
   214b6:	7bdb      	ldrb	r3, [r3, #15]
   214b8:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   214ba:	2101      	movs	r1, #1
   214bc:	f7fe ff80 	bl	203c0 <attsPermissions>
   214c0:	4603      	mov	r3, r0
          if ((*pAttr->pLen == attLen) &&
   214c2:	2b00      	cmp	r3, #0
   214c4:	d143      	bne.n	2154e <attsProcReadGroupTypeReq+0x28e>
          {
            /* copy result into response buffer; first check if it fits */
            if (p <= (pBuf + pCcb->mtu + L2C_PAYLOAD_START - attLen - (2 * sizeof(uint16_t))))
   214c6:	68fb      	ldr	r3, [r7, #12]
   214c8:	8b5b      	ldrh	r3, [r3, #26]
   214ca:	461a      	mov	r2, r3
   214cc:	7fbb      	ldrb	r3, [r7, #30]
   214ce:	1ad3      	subs	r3, r2, r3
   214d0:	3304      	adds	r3, #4
   214d2:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   214d4:	4413      	add	r3, r2
   214d6:	6aba      	ldr	r2, [r7, #40]	; 0x28
   214d8:	429a      	cmp	r2, r3
   214da:	d837      	bhi.n	2154c <attsProcReadGroupTypeReq+0x28c>
            {
              UINT16_TO_BSTREAM(p, handle);
   214dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   214de:	1c5a      	adds	r2, r3, #1
   214e0:	62ba      	str	r2, [r7, #40]	; 0x28
   214e2:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   214e4:	b2d2      	uxtb	r2, r2
   214e6:	701a      	strb	r2, [r3, #0]
   214e8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   214ea:	0a1b      	lsrs	r3, r3, #8
   214ec:	b299      	uxth	r1, r3
   214ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
   214f0:	1c5a      	adds	r2, r3, #1
   214f2:	62ba      	str	r2, [r7, #40]	; 0x28
   214f4:	b2ca      	uxtb	r2, r1
   214f6:	701a      	strb	r2, [r3, #0]
              handle = attsFindServiceGroupEnd(handle);
   214f8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   214fa:	4618      	mov	r0, r3
   214fc:	f7ff fa1a 	bl	20934 <attsFindServiceGroupEnd>
   21500:	4603      	mov	r3, r0
   21502:	84bb      	strh	r3, [r7, #36]	; 0x24
              UINT16_TO_BSTREAM(p, handle);
   21504:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21506:	1c5a      	adds	r2, r3, #1
   21508:	62ba      	str	r2, [r7, #40]	; 0x28
   2150a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   2150c:	b2d2      	uxtb	r2, r2
   2150e:	701a      	strb	r2, [r3, #0]
   21510:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21512:	0a1b      	lsrs	r3, r3, #8
   21514:	b299      	uxth	r1, r3
   21516:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21518:	1c5a      	adds	r2, r3, #1
   2151a:	62ba      	str	r2, [r7, #40]	; 0x28
   2151c:	b2ca      	uxtb	r2, r1
   2151e:	701a      	strb	r2, [r3, #0]
              memcpy(p, pAttr->pValue, attLen);
   21520:	69bb      	ldr	r3, [r7, #24]
   21522:	685b      	ldr	r3, [r3, #4]
   21524:	7fba      	ldrb	r2, [r7, #30]
   21526:	4619      	mov	r1, r3
   21528:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2152a:	f7f6 fe93 	bl	18254 <memcpy>
              p += attLen;
   2152e:	7fbb      	ldrb	r3, [r7, #30]
   21530:	6aba      	ldr	r2, [r7, #40]	; 0x28
   21532:	4413      	add	r3, r2
   21534:	62bb      	str	r3, [r7, #40]	; 0x28
          if (handle == ATT_HANDLE_MAX)
   21536:	e797      	b.n	21468 <attsProcReadGroupTypeReq+0x1a8>
        }
      }
      else
      {
        /* buffer allocation failed */
        err = ATT_ERR_RESOURCES;
   21538:	2311      	movs	r3, #17
   2153a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   2153e:	e006      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
            break;
   21540:	bf00      	nop
   21542:	e004      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
            break;
   21544:	bf00      	nop
   21546:	e002      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
            break;
   21548:	bf00      	nop
   2154a:	e000      	b.n	2154e <attsProcReadGroupTypeReq+0x28e>
              break;
   2154c:	bf00      	nop
      }
    }
  }

  /* set channel as busy for service discovery */
  attsDiscBusy(pCcb);
   2154e:	68f8      	ldr	r0, [r7, #12]
   21550:	f7fe fb88 	bl	1fc64 <attsDiscBusy>

  /* if no error send response, else send error */
  if (!err)
   21554:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21558:	2b00      	cmp	r3, #0
   2155a:	d10b      	bne.n	21574 <attsProcReadGroupTypeReq+0x2b4>
  {
    L2cDataReq(L2C_CID_ATT, pCcb->handle, (p - (pBuf + L2C_PAYLOAD_START)), pBuf);
   2155c:	68fb      	ldr	r3, [r7, #12]
   2155e:	8b19      	ldrh	r1, [r3, #24]
   21560:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21562:	3308      	adds	r3, #8
   21564:	6aba      	ldr	r2, [r7, #40]	; 0x28
   21566:	1ad3      	subs	r3, r2, r3
   21568:	b29a      	uxth	r2, r3
   2156a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2156c:	2004      	movs	r0, #4
   2156e:	f008 fcbb 	bl	29ee8 <L2cDataReq>
  }
  else
  {
    attsErrRsp(pCcb->handle, ATT_PDU_READ_GROUP_TYPE_REQ, startHandle, err);
  }
}
   21572:	e007      	b.n	21584 <attsProcReadGroupTypeReq+0x2c4>
    attsErrRsp(pCcb->handle, ATT_PDU_READ_GROUP_TYPE_REQ, startHandle, err);
   21574:	68fb      	ldr	r3, [r7, #12]
   21576:	8b18      	ldrh	r0, [r3, #24]
   21578:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   2157c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   2157e:	2110      	movs	r1, #16
   21580:	f7fe fb1a 	bl	1fbb8 <attsErrRsp>
}
   21584:	bf00      	nop
   21586:	3730      	adds	r7, #48	; 0x30
   21588:	46bd      	mov	sp, r7
   2158a:	bd80      	pop	{r7, pc}

0002158c <attsExecPrepWrite>:
 *
 *  \return ATT_SUCCESS or failure status.
 */
/*************************************************************************************************/
static uint8_t attsExecPrepWrite(attCcb_t *pCcb, attsPrepWrite_t *pPrep)
{
   2158c:	b5b0      	push	{r4, r5, r7, lr}
   2158e:	b08a      	sub	sp, #40	; 0x28
   21590:	af04      	add	r7, sp, #16
   21592:	6078      	str	r0, [r7, #4]
   21594:	6039      	str	r1, [r7, #0]
  uint8_t     *p;
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint8_t     err = ATT_SUCCESS;
   21596:	2300      	movs	r3, #0
   21598:	75fb      	strb	r3, [r7, #23]

  p = pPrep->packet;
   2159a:	683b      	ldr	r3, [r7, #0]
   2159c:	330a      	adds	r3, #10
   2159e:	613b      	str	r3, [r7, #16]

  /* find attribute */
  if ((pAttr = attsFindByHandle(pPrep->handle, &pGroup)) == NULL)
   215a0:	683b      	ldr	r3, [r7, #0]
   215a2:	88db      	ldrh	r3, [r3, #6]
   215a4:	f107 0208 	add.w	r2, r7, #8
   215a8:	4611      	mov	r1, r2
   215aa:	4618      	mov	r0, r3
   215ac:	f7fe fe9a 	bl	202e4 <attsFindByHandle>
   215b0:	60f8      	str	r0, [r7, #12]
   215b2:	68fb      	ldr	r3, [r7, #12]
   215b4:	2b00      	cmp	r3, #0
   215b6:	d102      	bne.n	215be <attsExecPrepWrite+0x32>
  {
    /* handle not found; only possible unless handle was removed */
    err = ATT_ERR_UNLIKELY;
   215b8:	230e      	movs	r3, #14
   215ba:	75fb      	strb	r3, [r7, #23]
   215bc:	e057      	b.n	2166e <attsExecPrepWrite+0xe2>
  }
  /* verify write permissions (in theory could have changed) */
  else if (!(pAttr->permissions & ATTS_PERMIT_WRITE))
   215be:	68fb      	ldr	r3, [r7, #12]
   215c0:	7bdb      	ldrb	r3, [r3, #15]
   215c2:	f003 0310 	and.w	r3, r3, #16
   215c6:	2b00      	cmp	r3, #0
   215c8:	d102      	bne.n	215d0 <attsExecPrepWrite+0x44>
  {
    err = ATT_ERR_WRITE;
   215ca:	2303      	movs	r3, #3
   215cc:	75fb      	strb	r3, [r7, #23]
   215ce:	e04e      	b.n	2166e <attsExecPrepWrite+0xe2>
  }
  /* if write callback is desired */
  else if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   215d0:	68fb      	ldr	r3, [r7, #12]
   215d2:	7b9b      	ldrb	r3, [r3, #14]
   215d4:	f003 0302 	and.w	r3, r3, #2
   215d8:	2b00      	cmp	r3, #0
   215da:	d018      	beq.n	2160e <attsExecPrepWrite+0x82>
           (pGroup->writeCback != NULL))
   215dc:	68bb      	ldr	r3, [r7, #8]
   215de:	68db      	ldr	r3, [r3, #12]
  else if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   215e0:	2b00      	cmp	r3, #0
   215e2:	d014      	beq.n	2160e <attsExecPrepWrite+0x82>
  {

    /* write callback performs the write */
    err = (*pGroup->writeCback)(pCcb->connId, pPrep->handle, ATT_PDU_EXEC_WRITE_REQ,
   215e4:	68bb      	ldr	r3, [r7, #8]
   215e6:	68dc      	ldr	r4, [r3, #12]
   215e8:	687b      	ldr	r3, [r7, #4]
   215ea:	7f18      	ldrb	r0, [r3, #28]
   215ec:	683b      	ldr	r3, [r7, #0]
   215ee:	88d9      	ldrh	r1, [r3, #6]
   215f0:	683b      	ldr	r3, [r7, #0]
   215f2:	891d      	ldrh	r5, [r3, #8]
   215f4:	683b      	ldr	r3, [r7, #0]
   215f6:	889b      	ldrh	r3, [r3, #4]
   215f8:	68fa      	ldr	r2, [r7, #12]
   215fa:	9202      	str	r2, [sp, #8]
   215fc:	693a      	ldr	r2, [r7, #16]
   215fe:	9201      	str	r2, [sp, #4]
   21600:	9300      	str	r3, [sp, #0]
   21602:	462b      	mov	r3, r5
   21604:	2218      	movs	r2, #24
   21606:	47a0      	blx	r4
   21608:	4603      	mov	r3, r0
   2160a:	75fb      	strb	r3, [r7, #23]
   2160c:	e02f      	b.n	2166e <attsExecPrepWrite+0xe2>
                                pPrep->offset, pPrep->writeLen, p, pAttr);
  }
  /* else check if CCC */
  else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   2160e:	68fb      	ldr	r3, [r7, #12]
   21610:	7b9b      	ldrb	r3, [r3, #14]
   21612:	f003 0320 	and.w	r3, r3, #32
   21616:	2b00      	cmp	r3, #0
   21618:	d00f      	beq.n	2163a <attsExecPrepWrite+0xae>
   2161a:	4b17      	ldr	r3, [pc, #92]	; (21678 <attsExecPrepWrite+0xec>)
   2161c:	695b      	ldr	r3, [r3, #20]
   2161e:	2b00      	cmp	r3, #0
   21620:	d00b      	beq.n	2163a <attsExecPrepWrite+0xae>
  {
    err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_WRITE, pPrep->handle, p);
   21622:	4b15      	ldr	r3, [pc, #84]	; (21678 <attsExecPrepWrite+0xec>)
   21624:	695c      	ldr	r4, [r3, #20]
   21626:	687b      	ldr	r3, [r7, #4]
   21628:	7f18      	ldrb	r0, [r3, #28]
   2162a:	683b      	ldr	r3, [r7, #0]
   2162c:	88da      	ldrh	r2, [r3, #6]
   2162e:	693b      	ldr	r3, [r7, #16]
   21630:	2109      	movs	r1, #9
   21632:	47a0      	blx	r4
   21634:	4603      	mov	r3, r0
   21636:	75fb      	strb	r3, [r7, #23]
   21638:	e019      	b.n	2166e <attsExecPrepWrite+0xe2>
  else
  {
    /* perform write; parameters have already been vetted by previous procedures */

    /* write attribute value */
    memcpy((pAttr->pValue + pPrep->offset), p, pPrep->writeLen);
   2163a:	68fb      	ldr	r3, [r7, #12]
   2163c:	685b      	ldr	r3, [r3, #4]
   2163e:	683a      	ldr	r2, [r7, #0]
   21640:	8912      	ldrh	r2, [r2, #8]
   21642:	1898      	adds	r0, r3, r2
   21644:	683b      	ldr	r3, [r7, #0]
   21646:	889b      	ldrh	r3, [r3, #4]
   21648:	461a      	mov	r2, r3
   2164a:	6939      	ldr	r1, [r7, #16]
   2164c:	f7f6 fe02 	bl	18254 <memcpy>

    /* write the length if variable length attribute */
    if ((pAttr->settings & ATTS_SET_VARIABLE_LEN) != 0)
   21650:	68fb      	ldr	r3, [r7, #12]
   21652:	7b9b      	ldrb	r3, [r3, #14]
   21654:	f003 0308 	and.w	r3, r3, #8
   21658:	2b00      	cmp	r3, #0
   2165a:	d008      	beq.n	2166e <attsExecPrepWrite+0xe2>
    {
      *(pAttr->pLen) = pPrep->writeLen + pPrep->offset;
   2165c:	683b      	ldr	r3, [r7, #0]
   2165e:	8899      	ldrh	r1, [r3, #4]
   21660:	683b      	ldr	r3, [r7, #0]
   21662:	891a      	ldrh	r2, [r3, #8]
   21664:	68fb      	ldr	r3, [r7, #12]
   21666:	689b      	ldr	r3, [r3, #8]
   21668:	440a      	add	r2, r1
   2166a:	b292      	uxth	r2, r2
   2166c:	801a      	strh	r2, [r3, #0]
    }
  }

  return err;
   2166e:	7dfb      	ldrb	r3, [r7, #23]
}
   21670:	4618      	mov	r0, r3
   21672:	3718      	adds	r7, #24
   21674:	46bd      	mov	sp, r7
   21676:	bdb0      	pop	{r4, r5, r7, pc}
   21678:	100111dc 	.word	0x100111dc

0002167c <attsProcWrite>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcWrite(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   2167c:	b590      	push	{r4, r7, lr}
   2167e:	b08f      	sub	sp, #60	; 0x3c
   21680:	af04      	add	r7, sp, #16
   21682:	60f8      	str	r0, [r7, #12]
   21684:	460b      	mov	r3, r1
   21686:	607a      	str	r2, [r7, #4]
   21688:	817b      	strh	r3, [r7, #10]
  attsAttr_t  *pAttr;
  attsGroup_t *pGroup;
  uint8_t     opcode;
  uint16_t    handle;
  uint16_t    writeLen;
  uint8_t     err = ATT_SUCCESS;
   2168a:	2300      	movs	r3, #0
   2168c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  /* parse opcode handle, calculate write length */
  pPacket += L2C_PAYLOAD_START;
   21690:	687b      	ldr	r3, [r7, #4]
   21692:	3308      	adds	r3, #8
   21694:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT8(opcode, pPacket);
   21696:	687b      	ldr	r3, [r7, #4]
   21698:	1c5a      	adds	r2, r3, #1
   2169a:	607a      	str	r2, [r7, #4]
   2169c:	781b      	ldrb	r3, [r3, #0]
   2169e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  BSTREAM_TO_UINT16(handle, pPacket);
   216a2:	687b      	ldr	r3, [r7, #4]
   216a4:	781b      	ldrb	r3, [r3, #0]
   216a6:	b29a      	uxth	r2, r3
   216a8:	687b      	ldr	r3, [r7, #4]
   216aa:	3301      	adds	r3, #1
   216ac:	781b      	ldrb	r3, [r3, #0]
   216ae:	b29b      	uxth	r3, r3
   216b0:	021b      	lsls	r3, r3, #8
   216b2:	b29b      	uxth	r3, r3
   216b4:	4413      	add	r3, r2
   216b6:	84bb      	strh	r3, [r7, #36]	; 0x24
   216b8:	687b      	ldr	r3, [r7, #4]
   216ba:	3302      	adds	r3, #2
   216bc:	607b      	str	r3, [r7, #4]
  writeLen = len - ATT_WRITE_REQ_LEN;
   216be:	897b      	ldrh	r3, [r7, #10]
   216c0:	3b03      	subs	r3, #3
   216c2:	847b      	strh	r3, [r7, #34]	; 0x22

  /* find attribute */
  if ((pAttr = attsFindByHandle(handle, &pGroup)) != NULL)
   216c4:	f107 0210 	add.w	r2, r7, #16
   216c8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   216ca:	4611      	mov	r1, r2
   216cc:	4618      	mov	r0, r3
   216ce:	f7fe fe09 	bl	202e4 <attsFindByHandle>
   216d2:	61f8      	str	r0, [r7, #28]
   216d4:	69fb      	ldr	r3, [r7, #28]
   216d6:	2b00      	cmp	r3, #0
   216d8:	f000 8091 	beq.w	217fe <attsProcWrite+0x182>
  {
    /* verify permissions */
    if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_WRITE,
   216dc:	68fb      	ldr	r3, [r7, #12]
   216de:	7f18      	ldrb	r0, [r3, #28]
   216e0:	69fb      	ldr	r3, [r7, #28]
   216e2:	7bdb      	ldrb	r3, [r3, #15]
   216e4:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   216e6:	2110      	movs	r1, #16
   216e8:	f7fe fe6a 	bl	203c0 <attsPermissions>
   216ec:	4603      	mov	r3, r0
   216ee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   216f2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   216f6:	2b00      	cmp	r3, #0
   216f8:	f040 8084 	bne.w	21804 <attsProcWrite+0x188>
                               handle, pAttr->permissions)) != ATT_SUCCESS)
    {
      /* err has been set; fail */
    }
    /* verify write length, fixed length */
    else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) == 0) &&
   216fc:	69fb      	ldr	r3, [r7, #28]
   216fe:	7b9b      	ldrb	r3, [r3, #14]
   21700:	f003 0308 	and.w	r3, r3, #8
   21704:	2b00      	cmp	r3, #0
   21706:	d108      	bne.n	2171a <attsProcWrite+0x9e>
             (writeLen != pAttr->maxLen))
   21708:	69fb      	ldr	r3, [r7, #28]
   2170a:	899b      	ldrh	r3, [r3, #12]
    else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) == 0) &&
   2170c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   2170e:	429a      	cmp	r2, r3
   21710:	d003      	beq.n	2171a <attsProcWrite+0x9e>
    {
      err = ATT_ERR_LENGTH;
   21712:	230d      	movs	r3, #13
   21714:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   21718:	e074      	b.n	21804 <attsProcWrite+0x188>
    }
    /* verify write length, variable length */
    else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) != 0) &&
   2171a:	69fb      	ldr	r3, [r7, #28]
   2171c:	7b9b      	ldrb	r3, [r3, #14]
   2171e:	f003 0308 	and.w	r3, r3, #8
   21722:	2b00      	cmp	r3, #0
   21724:	d008      	beq.n	21738 <attsProcWrite+0xbc>
             (writeLen > pAttr->maxLen))
   21726:	69fb      	ldr	r3, [r7, #28]
   21728:	899b      	ldrh	r3, [r3, #12]
    else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) != 0) &&
   2172a:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   2172c:	429a      	cmp	r2, r3
   2172e:	d903      	bls.n	21738 <attsProcWrite+0xbc>
    {
      err = ATT_ERR_LENGTH;
   21730:	230d      	movs	r3, #13
   21732:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   21736:	e065      	b.n	21804 <attsProcWrite+0x188>
    }
    else
    {
      /* if write callback is desired */
      if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   21738:	69fb      	ldr	r3, [r7, #28]
   2173a:	7b9b      	ldrb	r3, [r3, #14]
   2173c:	f003 0302 	and.w	r3, r3, #2
   21740:	2b00      	cmp	r3, #0
   21742:	d016      	beq.n	21772 <attsProcWrite+0xf6>
          (pGroup->writeCback != NULL))
   21744:	693b      	ldr	r3, [r7, #16]
   21746:	68db      	ldr	r3, [r3, #12]
      if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   21748:	2b00      	cmp	r3, #0
   2174a:	d012      	beq.n	21772 <attsProcWrite+0xf6>
      {
        err = (*pGroup->writeCback)(pCcb->connId, handle, opcode, 0, writeLen,
   2174c:	693b      	ldr	r3, [r7, #16]
   2174e:	68dc      	ldr	r4, [r3, #12]
   21750:	68fb      	ldr	r3, [r7, #12]
   21752:	7f18      	ldrb	r0, [r3, #28]
   21754:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
   21758:	8cb9      	ldrh	r1, [r7, #36]	; 0x24
   2175a:	69fb      	ldr	r3, [r7, #28]
   2175c:	9302      	str	r3, [sp, #8]
   2175e:	687b      	ldr	r3, [r7, #4]
   21760:	9301      	str	r3, [sp, #4]
   21762:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
   21764:	9300      	str	r3, [sp, #0]
   21766:	2300      	movs	r3, #0
   21768:	47a0      	blx	r4
   2176a:	4603      	mov	r3, r0
   2176c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   21770:	e026      	b.n	217c0 <attsProcWrite+0x144>
                                    pPacket, pAttr);
      }
      /* else check if CCC */
      else if ((pAttr->settings & ATTS_SET_CCC) && (attsCb.cccCback != NULL))
   21772:	69fb      	ldr	r3, [r7, #28]
   21774:	7b9b      	ldrb	r3, [r3, #14]
   21776:	f003 0320 	and.w	r3, r3, #32
   2177a:	2b00      	cmp	r3, #0
   2177c:	d00f      	beq.n	2179e <attsProcWrite+0x122>
   2177e:	4b31      	ldr	r3, [pc, #196]	; (21844 <attsProcWrite+0x1c8>)
   21780:	695b      	ldr	r3, [r3, #20]
   21782:	2b00      	cmp	r3, #0
   21784:	d00b      	beq.n	2179e <attsProcWrite+0x122>
      {
        err = (*attsCb.cccCback)(pCcb->connId, ATT_METHOD_WRITE, handle, pPacket);
   21786:	4b2f      	ldr	r3, [pc, #188]	; (21844 <attsProcWrite+0x1c8>)
   21788:	695c      	ldr	r4, [r3, #20]
   2178a:	68fb      	ldr	r3, [r7, #12]
   2178c:	7f18      	ldrb	r0, [r3, #28]
   2178e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21790:	687b      	ldr	r3, [r7, #4]
   21792:	2109      	movs	r1, #9
   21794:	47a0      	blx	r4
   21796:	4603      	mov	r3, r0
   21798:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
   2179c:	e010      	b.n	217c0 <attsProcWrite+0x144>
      }
      else
      {
        /* write attribute value */
        memcpy(pAttr->pValue, pPacket, writeLen);
   2179e:	69fb      	ldr	r3, [r7, #28]
   217a0:	685b      	ldr	r3, [r3, #4]
   217a2:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   217a4:	6879      	ldr	r1, [r7, #4]
   217a6:	4618      	mov	r0, r3
   217a8:	f7f6 fd54 	bl	18254 <memcpy>

        /* write the length if variable length attribute */
        if ((pAttr->settings & ATTS_SET_VARIABLE_LEN) != 0)
   217ac:	69fb      	ldr	r3, [r7, #28]
   217ae:	7b9b      	ldrb	r3, [r3, #14]
   217b0:	f003 0308 	and.w	r3, r3, #8
   217b4:	2b00      	cmp	r3, #0
   217b6:	d003      	beq.n	217c0 <attsProcWrite+0x144>
        {
          *(pAttr->pLen) = writeLen;
   217b8:	69fb      	ldr	r3, [r7, #28]
   217ba:	689b      	ldr	r3, [r3, #8]
   217bc:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
   217be:	801a      	strh	r2, [r3, #0]
        }
      }

      /* if success and write req allocate response buffer */
      if (err == ATT_SUCCESS && opcode == ATT_PDU_WRITE_REQ)
   217c0:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   217c4:	2b00      	cmp	r3, #0
   217c6:	d11d      	bne.n	21804 <attsProcWrite+0x188>
   217c8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   217cc:	2b12      	cmp	r3, #18
   217ce:	d119      	bne.n	21804 <attsProcWrite+0x188>
      {
        if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_WRITE_RSP_LEN)) != NULL)
   217d0:	2009      	movs	r0, #9
   217d2:	f7fc f909 	bl	1d9e8 <attMsgAlloc>
   217d6:	61b8      	str	r0, [r7, #24]
   217d8:	69bb      	ldr	r3, [r7, #24]
   217da:	2b00      	cmp	r3, #0
   217dc:	d012      	beq.n	21804 <attsProcWrite+0x188>
        {
          /* build and send PDU */
          p = pBuf + L2C_PAYLOAD_START;
   217de:	69bb      	ldr	r3, [r7, #24]
   217e0:	3308      	adds	r3, #8
   217e2:	617b      	str	r3, [r7, #20]
          UINT8_TO_BSTREAM(p, ATT_PDU_WRITE_RSP);
   217e4:	697b      	ldr	r3, [r7, #20]
   217e6:	1c5a      	adds	r2, r3, #1
   217e8:	617a      	str	r2, [r7, #20]
   217ea:	2213      	movs	r2, #19
   217ec:	701a      	strb	r2, [r3, #0]

          L2cDataReq(L2C_CID_ATT, pCcb->handle, ATT_WRITE_RSP_LEN, pBuf);
   217ee:	68fb      	ldr	r3, [r7, #12]
   217f0:	8b19      	ldrh	r1, [r3, #24]
   217f2:	69bb      	ldr	r3, [r7, #24]
   217f4:	2201      	movs	r2, #1
   217f6:	2004      	movs	r0, #4
   217f8:	f008 fb76 	bl	29ee8 <L2cDataReq>
   217fc:	e002      	b.n	21804 <attsProcWrite+0x188>
    }
  }
  /* else attribute not found */
  else
  {
    err = ATT_ERR_HANDLE;
   217fe:	2301      	movs	r3, #1
   21800:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* send error response for write req only */
  if (err && (opcode == ATT_PDU_WRITE_REQ))
   21804:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   21808:	2b00      	cmp	r3, #0
   2180a:	d017      	beq.n	2183c <attsProcWrite+0x1c0>
   2180c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
   21810:	2b12      	cmp	r3, #18
   21812:	d113      	bne.n	2183c <attsProcWrite+0x1c0>
  {
    if (err == ATT_RSP_PENDING)
   21814:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   21818:	2b79      	cmp	r3, #121	; 0x79
   2181a:	d107      	bne.n	2182c <attsProcWrite+0x1b0>
    {
      /* set response pending */
      pCcb->control |= ATT_CCB_STATUS_RSP_PENDING;
   2181c:	68fb      	ldr	r3, [r7, #12]
   2181e:	7f5b      	ldrb	r3, [r3, #29]
   21820:	f043 0308 	orr.w	r3, r3, #8
   21824:	b2da      	uxtb	r2, r3
   21826:	68fb      	ldr	r3, [r7, #12]
   21828:	775a      	strb	r2, [r3, #29]
    else
    {
      attsErrRsp(pCcb->handle, ATT_PDU_WRITE_REQ, handle, err);
    }
  }
}
   2182a:	e007      	b.n	2183c <attsProcWrite+0x1c0>
      attsErrRsp(pCcb->handle, ATT_PDU_WRITE_REQ, handle, err);
   2182c:	68fb      	ldr	r3, [r7, #12]
   2182e:	8b18      	ldrh	r0, [r3, #24]
   21830:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   21834:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21836:	2112      	movs	r1, #18
   21838:	f7fe f9be 	bl	1fbb8 <attsErrRsp>
}
   2183c:	bf00      	nop
   2183e:	372c      	adds	r7, #44	; 0x2c
   21840:	46bd      	mov	sp, r7
   21842:	bd90      	pop	{r4, r7, pc}
   21844:	100111dc 	.word	0x100111dc

00021848 <attsProcPrepWriteReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcPrepWriteReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   21848:	b590      	push	{r4, r7, lr}
   2184a:	b091      	sub	sp, #68	; 0x44
   2184c:	af04      	add	r7, sp, #16
   2184e:	60f8      	str	r0, [r7, #12]
   21850:	460b      	mov	r3, r1
   21852:	607a      	str	r2, [r7, #4]
   21854:	817b      	strh	r3, [r7, #10]
  attsGroup_t     *pGroup;
  attsPrepWrite_t *pPrep;
  uint16_t        handle;
  uint16_t        offset;
  uint16_t        writeLen;
  uint8_t         err = ATT_SUCCESS;
   21856:	2300      	movs	r3, #0
   21858:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

  /* parse handle and offset, calculate write length */
  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   2185c:	687b      	ldr	r3, [r7, #4]
   2185e:	3309      	adds	r3, #9
   21860:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(handle, pPacket);
   21862:	687b      	ldr	r3, [r7, #4]
   21864:	781b      	ldrb	r3, [r3, #0]
   21866:	b29a      	uxth	r2, r3
   21868:	687b      	ldr	r3, [r7, #4]
   2186a:	3301      	adds	r3, #1
   2186c:	781b      	ldrb	r3, [r3, #0]
   2186e:	b29b      	uxth	r3, r3
   21870:	021b      	lsls	r3, r3, #8
   21872:	b29b      	uxth	r3, r3
   21874:	4413      	add	r3, r2
   21876:	853b      	strh	r3, [r7, #40]	; 0x28
   21878:	687b      	ldr	r3, [r7, #4]
   2187a:	3302      	adds	r3, #2
   2187c:	607b      	str	r3, [r7, #4]
  BSTREAM_TO_UINT16(offset, pPacket);
   2187e:	687b      	ldr	r3, [r7, #4]
   21880:	781b      	ldrb	r3, [r3, #0]
   21882:	b29a      	uxth	r2, r3
   21884:	687b      	ldr	r3, [r7, #4]
   21886:	3301      	adds	r3, #1
   21888:	781b      	ldrb	r3, [r3, #0]
   2188a:	b29b      	uxth	r3, r3
   2188c:	021b      	lsls	r3, r3, #8
   2188e:	b29b      	uxth	r3, r3
   21890:	4413      	add	r3, r2
   21892:	84fb      	strh	r3, [r7, #38]	; 0x26
   21894:	687b      	ldr	r3, [r7, #4]
   21896:	3302      	adds	r3, #2
   21898:	607b      	str	r3, [r7, #4]
  writeLen = len - ATT_PREP_WRITE_REQ_LEN;    /* length of value being written */
   2189a:	897b      	ldrh	r3, [r7, #10]
   2189c:	3b05      	subs	r3, #5
   2189e:	84bb      	strh	r3, [r7, #36]	; 0x24

  /* find attribute */
  if ((pAttr = attsFindByHandle(handle, &pGroup)) == NULL)
   218a0:	f107 0214 	add.w	r2, r7, #20
   218a4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   218a6:	4611      	mov	r1, r2
   218a8:	4618      	mov	r0, r3
   218aa:	f7fe fd1b 	bl	202e4 <attsFindByHandle>
   218ae:	6238      	str	r0, [r7, #32]
   218b0:	6a3b      	ldr	r3, [r7, #32]
   218b2:	2b00      	cmp	r3, #0
   218b4:	d103      	bne.n	218be <attsProcPrepWriteReq+0x76>
  {
    /* attribute not found */
    err = ATT_ERR_HANDLE;
   218b6:	2301      	movs	r3, #1
   218b8:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   218bc:	e063      	b.n	21986 <attsProcPrepWriteReq+0x13e>
  }
  /* verify permissions */
  else if ((err = attsPermissions(pCcb->connId, ATTS_PERMIT_WRITE,
   218be:	68fb      	ldr	r3, [r7, #12]
   218c0:	7f18      	ldrb	r0, [r3, #28]
   218c2:	6a3b      	ldr	r3, [r7, #32]
   218c4:	7bdb      	ldrb	r3, [r3, #15]
   218c6:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   218c8:	2110      	movs	r1, #16
   218ca:	f7fe fd79 	bl	203c0 <attsPermissions>
   218ce:	4603      	mov	r3, r0
   218d0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   218d4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   218d8:	2b00      	cmp	r3, #0
   218da:	d154      	bne.n	21986 <attsProcPrepWriteReq+0x13e>
                               handle, pAttr->permissions)) != ATT_SUCCESS)
  {
    /* err has been set; fail */
  }
  /* verify offset is allowed */
  else if ((offset != 0) && ((pAttr->settings & ATTS_SET_ALLOW_OFFSET) == 0))
   218dc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   218de:	2b00      	cmp	r3, #0
   218e0:	d009      	beq.n	218f6 <attsProcPrepWriteReq+0xae>
   218e2:	6a3b      	ldr	r3, [r7, #32]
   218e4:	7b9b      	ldrb	r3, [r3, #14]
   218e6:	f003 0310 	and.w	r3, r3, #16
   218ea:	2b00      	cmp	r3, #0
   218ec:	d103      	bne.n	218f6 <attsProcPrepWriteReq+0xae>
  {
    err = ATT_ERR_NOT_LONG;
   218ee:	230b      	movs	r3, #11
   218f0:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   218f4:	e047      	b.n	21986 <attsProcPrepWriteReq+0x13e>
  }
  /* verify write length, fixed length */
  else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) == 0) &&
   218f6:	6a3b      	ldr	r3, [r7, #32]
   218f8:	7b9b      	ldrb	r3, [r3, #14]
   218fa:	f003 0308 	and.w	r3, r3, #8
   218fe:	2b00      	cmp	r3, #0
   21900:	d108      	bne.n	21914 <attsProcPrepWriteReq+0xcc>
           (writeLen != pAttr->maxLen))
   21902:	6a3b      	ldr	r3, [r7, #32]
   21904:	899b      	ldrh	r3, [r3, #12]
  else if (((pAttr->settings & ATTS_SET_VARIABLE_LEN) == 0) &&
   21906:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21908:	429a      	cmp	r2, r3
   2190a:	d003      	beq.n	21914 <attsProcPrepWriteReq+0xcc>
  {
    err = ATT_ERR_LENGTH;
   2190c:	230d      	movs	r3, #13
   2190e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   21912:	e038      	b.n	21986 <attsProcPrepWriteReq+0x13e>
  }
  /* verify prepare write queue limit not reached */
  else if (WsfQueueCount(&pCcb->prepWriteQueue) >= pAttCfg->numPrepWrites)
   21914:	68fb      	ldr	r3, [r7, #12]
   21916:	4618      	mov	r0, r3
   21918:	f00b feb3 	bl	2d682 <WsfQueueCount>
   2191c:	4603      	mov	r3, r0
   2191e:	461a      	mov	r2, r3
   21920:	4b4c      	ldr	r3, [pc, #304]	; (21a54 <attsProcPrepWriteReq+0x20c>)
   21922:	681b      	ldr	r3, [r3, #0]
   21924:	79db      	ldrb	r3, [r3, #7]
   21926:	b29b      	uxth	r3, r3
   21928:	429a      	cmp	r2, r3
   2192a:	d303      	bcc.n	21934 <attsProcPrepWriteReq+0xec>
  {
    err = ATT_ERR_QUEUE_FULL;
   2192c:	2309      	movs	r3, #9
   2192e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   21932:	e028      	b.n	21986 <attsProcPrepWriteReq+0x13e>
  }
  /* allocate new buffer to hold prepared write */
  else if ((pPrep = WsfBufAlloc(sizeof(attsPrepWrite_t) - 1 + writeLen)) == NULL)
   21934:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21936:	330b      	adds	r3, #11
   21938:	b29b      	uxth	r3, r3
   2193a:	4618      	mov	r0, r3
   2193c:	f00b fb28 	bl	2cf90 <WsfBufAlloc>
   21940:	62f8      	str	r0, [r7, #44]	; 0x2c
   21942:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21944:	2b00      	cmp	r3, #0
   21946:	d103      	bne.n	21950 <attsProcPrepWriteReq+0x108>
  {
    err = ATT_ERR_RESOURCES;
   21948:	2311      	movs	r3, #17
   2194a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
   2194e:	e01a      	b.n	21986 <attsProcPrepWriteReq+0x13e>
  }
  else if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   21950:	6a3b      	ldr	r3, [r7, #32]
   21952:	7b9b      	ldrb	r3, [r3, #14]
   21954:	f003 0302 	and.w	r3, r3, #2
   21958:	2b00      	cmp	r3, #0
   2195a:	d014      	beq.n	21986 <attsProcPrepWriteReq+0x13e>
          (pGroup->writeCback != NULL))
   2195c:	697b      	ldr	r3, [r7, #20]
   2195e:	68db      	ldr	r3, [r3, #12]
  else if ((pAttr->settings & ATTS_SET_WRITE_CBACK) &&
   21960:	2b00      	cmp	r3, #0
   21962:	d010      	beq.n	21986 <attsProcPrepWriteReq+0x13e>
  {
    err = (*pGroup->writeCback)(pCcb->connId, handle, ATT_PDU_PREP_WRITE_REQ, 0, writeLen,
   21964:	697b      	ldr	r3, [r7, #20]
   21966:	68dc      	ldr	r4, [r3, #12]
   21968:	68fb      	ldr	r3, [r7, #12]
   2196a:	7f18      	ldrb	r0, [r3, #28]
   2196c:	8d39      	ldrh	r1, [r7, #40]	; 0x28
   2196e:	6a3b      	ldr	r3, [r7, #32]
   21970:	9302      	str	r3, [sp, #8]
   21972:	687b      	ldr	r3, [r7, #4]
   21974:	9301      	str	r3, [sp, #4]
   21976:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21978:	9300      	str	r3, [sp, #0]
   2197a:	2300      	movs	r3, #0
   2197c:	2216      	movs	r2, #22
   2197e:	47a0      	blx	r4
   21980:	4603      	mov	r3, r0
   21982:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
                                pPacket, pAttr);
  }

  if (err == ATT_SUCCESS)
   21986:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   2198a:	2b00      	cmp	r3, #0
   2198c:	d151      	bne.n	21a32 <attsProcPrepWriteReq+0x1ea>
  {
    /* copy data to new buffer and queue it */
    pPrep->writeLen = writeLen;
   2198e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21990:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   21992:	809a      	strh	r2, [r3, #4]
    pPrep->handle = handle;
   21994:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   21996:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   21998:	80da      	strh	r2, [r3, #6]
    pPrep->offset = offset;
   2199a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2199c:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   2199e:	811a      	strh	r2, [r3, #8]
    memcpy(pPrep->packet, pPacket, writeLen);
   219a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   219a2:	330a      	adds	r3, #10
   219a4:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   219a6:	6879      	ldr	r1, [r7, #4]
   219a8:	4618      	mov	r0, r3
   219aa:	f7f6 fc53 	bl	18254 <memcpy>
    WsfQueueEnq(&pCcb->prepWriteQueue, pPrep);
   219ae:	68fb      	ldr	r3, [r7, #12]
   219b0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   219b2:	4618      	mov	r0, r3
   219b4:	f00b fdb8 	bl	2d528 <WsfQueueEnq>

    /* allocate response buffer */
    if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_PREP_WRITE_RSP_LEN + writeLen)) != NULL)
   219b8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   219ba:	330d      	adds	r3, #13
   219bc:	b29b      	uxth	r3, r3
   219be:	4618      	mov	r0, r3
   219c0:	f7fc f812 	bl	1d9e8 <attMsgAlloc>
   219c4:	61f8      	str	r0, [r7, #28]
   219c6:	69fb      	ldr	r3, [r7, #28]
   219c8:	2b00      	cmp	r3, #0
   219ca:	d032      	beq.n	21a32 <attsProcPrepWriteReq+0x1ea>
    {
      /* build and send PDU */
      p = pBuf + L2C_PAYLOAD_START;
   219cc:	69fb      	ldr	r3, [r7, #28]
   219ce:	3308      	adds	r3, #8
   219d0:	61bb      	str	r3, [r7, #24]
      UINT8_TO_BSTREAM(p, ATT_PDU_PREP_WRITE_RSP);
   219d2:	69bb      	ldr	r3, [r7, #24]
   219d4:	1c5a      	adds	r2, r3, #1
   219d6:	61ba      	str	r2, [r7, #24]
   219d8:	2217      	movs	r2, #23
   219da:	701a      	strb	r2, [r3, #0]
      UINT16_TO_BSTREAM(p, handle);
   219dc:	69bb      	ldr	r3, [r7, #24]
   219de:	1c5a      	adds	r2, r3, #1
   219e0:	61ba      	str	r2, [r7, #24]
   219e2:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   219e4:	b2d2      	uxtb	r2, r2
   219e6:	701a      	strb	r2, [r3, #0]
   219e8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   219ea:	0a1b      	lsrs	r3, r3, #8
   219ec:	b299      	uxth	r1, r3
   219ee:	69bb      	ldr	r3, [r7, #24]
   219f0:	1c5a      	adds	r2, r3, #1
   219f2:	61ba      	str	r2, [r7, #24]
   219f4:	b2ca      	uxtb	r2, r1
   219f6:	701a      	strb	r2, [r3, #0]
      UINT16_TO_BSTREAM(p, offset);
   219f8:	69bb      	ldr	r3, [r7, #24]
   219fa:	1c5a      	adds	r2, r3, #1
   219fc:	61ba      	str	r2, [r7, #24]
   219fe:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
   21a00:	b2d2      	uxtb	r2, r2
   21a02:	701a      	strb	r2, [r3, #0]
   21a04:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
   21a06:	0a1b      	lsrs	r3, r3, #8
   21a08:	b299      	uxth	r1, r3
   21a0a:	69bb      	ldr	r3, [r7, #24]
   21a0c:	1c5a      	adds	r2, r3, #1
   21a0e:	61ba      	str	r2, [r7, #24]
   21a10:	b2ca      	uxtb	r2, r1
   21a12:	701a      	strb	r2, [r3, #0]
      memcpy(p, pPacket, writeLen);
   21a14:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21a16:	461a      	mov	r2, r3
   21a18:	6879      	ldr	r1, [r7, #4]
   21a1a:	69b8      	ldr	r0, [r7, #24]
   21a1c:	f7f6 fc1a 	bl	18254 <memcpy>

      L2cDataReq(L2C_CID_ATT, pCcb->handle, (ATT_PREP_WRITE_RSP_LEN + writeLen), pBuf);
   21a20:	68fb      	ldr	r3, [r7, #12]
   21a22:	8b19      	ldrh	r1, [r3, #24]
   21a24:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   21a26:	3305      	adds	r3, #5
   21a28:	b29a      	uxth	r2, r3
   21a2a:	69fb      	ldr	r3, [r7, #28]
   21a2c:	2004      	movs	r0, #4
   21a2e:	f008 fa5b 	bl	29ee8 <L2cDataReq>
    }
  }

  if (err)
   21a32:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   21a36:	2b00      	cmp	r3, #0
   21a38:	d007      	beq.n	21a4a <attsProcPrepWriteReq+0x202>
  {
    attsErrRsp(pCcb->handle, ATT_PDU_PREP_WRITE_REQ, handle, err);
   21a3a:	68fb      	ldr	r3, [r7, #12]
   21a3c:	8b18      	ldrh	r0, [r3, #24]
   21a3e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   21a42:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   21a44:	2116      	movs	r1, #22
   21a46:	f7fe f8b7 	bl	1fbb8 <attsErrRsp>
  }
}
   21a4a:	bf00      	nop
   21a4c:	3734      	adds	r7, #52	; 0x34
   21a4e:	46bd      	mov	sp, r7
   21a50:	bd90      	pop	{r4, r7, pc}
   21a52:	bf00      	nop
   21a54:	10002b8c 	.word	0x10002b8c

00021a58 <attsProcExecWriteReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void attsProcExecWriteReq(attCcb_t *pCcb, uint16_t len, uint8_t *pPacket)
{
   21a58:	b580      	push	{r7, lr}
   21a5a:	b08a      	sub	sp, #40	; 0x28
   21a5c:	af00      	add	r7, sp, #0
   21a5e:	60f8      	str	r0, [r7, #12]
   21a60:	460b      	mov	r3, r1
   21a62:	607a      	str	r2, [r7, #4]
   21a64:	817b      	strh	r3, [r7, #10]
  uint8_t         *pBuf;
  uint8_t         *p;
  attsPrepWrite_t *pPrep;
  attsAttr_t      *pAttr;
  attsGroup_t     *pGroup;
  uint8_t         err = ATT_SUCCESS;
   21a66:	2300      	movs	r3, #0
   21a68:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

  pPacket += L2C_PAYLOAD_START + ATT_HDR_LEN;
   21a6c:	687b      	ldr	r3, [r7, #4]
   21a6e:	3309      	adds	r3, #9
   21a70:	607b      	str	r3, [r7, #4]

  /* if cancelling all prepared writes */
  if (*pPacket == ATT_EXEC_WRITE_CANCEL)
   21a72:	687b      	ldr	r3, [r7, #4]
   21a74:	781b      	ldrb	r3, [r3, #0]
   21a76:	2b00      	cmp	r3, #0
   21a78:	d103      	bne.n	21a82 <attsProcExecWriteReq+0x2a>
  {
    /* free all queued buffers */
    attsClearPrepWrites(pCcb);
   21a7a:	68f8      	ldr	r0, [r7, #12]
   21a7c:	f7fe f8dc 	bl	1fc38 <attsClearPrepWrites>
   21a80:	e05a      	b.n	21b38 <attsProcExecWriteReq+0xe0>
  }
  /* else writing all prepared writes */
  else if (*pPacket == ATT_EXEC_WRITE_ALL)
   21a82:	687b      	ldr	r3, [r7, #4]
   21a84:	781b      	ldrb	r3, [r3, #0]
   21a86:	2b01      	cmp	r3, #1
   21a88:	d153      	bne.n	21b32 <attsProcExecWriteReq+0xda>
  {
    /* iterate over prepare write queue and verify offset and length */
    for (pPrep = pCcb->prepWriteQueue.pHead; pPrep != NULL; pPrep = pPrep->pNext)
   21a8a:	68fb      	ldr	r3, [r7, #12]
   21a8c:	681b      	ldr	r3, [r3, #0]
   21a8e:	627b      	str	r3, [r7, #36]	; 0x24
   21a90:	e02d      	b.n	21aee <attsProcExecWriteReq+0x96>
    {
      /* find attribute */
      if ((pAttr = attsFindByHandle(pPrep->handle, &pGroup)) != NULL)
   21a92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21a94:	88db      	ldrh	r3, [r3, #6]
   21a96:	f107 0210 	add.w	r2, r7, #16
   21a9a:	4611      	mov	r1, r2
   21a9c:	4618      	mov	r0, r3
   21a9e:	f7fe fc21 	bl	202e4 <attsFindByHandle>
   21aa2:	61f8      	str	r0, [r7, #28]
   21aa4:	69fb      	ldr	r3, [r7, #28]
   21aa6:	2b00      	cmp	r3, #0
   21aa8:	d01e      	beq.n	21ae8 <attsProcExecWriteReq+0x90>
      {
        /* verify offset */
        if (pPrep->offset > pAttr->maxLen)
   21aaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21aac:	891a      	ldrh	r2, [r3, #8]
   21aae:	69fb      	ldr	r3, [r7, #28]
   21ab0:	899b      	ldrh	r3, [r3, #12]
   21ab2:	429a      	cmp	r2, r3
   21ab4:	d903      	bls.n	21abe <attsProcExecWriteReq+0x66>
        {
          err = ATT_ERR_OFFSET;
   21ab6:	2307      	movs	r3, #7
   21ab8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   21abc:	e00c      	b.n	21ad8 <attsProcExecWriteReq+0x80>
        }
        /* verify write length with offset */
        else if ((pPrep->writeLen + pPrep->offset) > pAttr->maxLen)
   21abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21ac0:	889b      	ldrh	r3, [r3, #4]
   21ac2:	461a      	mov	r2, r3
   21ac4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21ac6:	891b      	ldrh	r3, [r3, #8]
   21ac8:	4413      	add	r3, r2
   21aca:	69fa      	ldr	r2, [r7, #28]
   21acc:	8992      	ldrh	r2, [r2, #12]
   21ace:	4293      	cmp	r3, r2
   21ad0:	dd02      	ble.n	21ad8 <attsProcExecWriteReq+0x80>
        {
          err = ATT_ERR_LENGTH;
   21ad2:	230d      	movs	r3, #13
   21ad4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        }

        if (err)
   21ad8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21adc:	2b00      	cmp	r3, #0
   21ade:	d003      	beq.n	21ae8 <attsProcExecWriteReq+0x90>
        {
          /* verification failed; discard all prepared writes */
          attsClearPrepWrites(pCcb);
   21ae0:	68f8      	ldr	r0, [r7, #12]
   21ae2:	f7fe f8a9 	bl	1fc38 <attsClearPrepWrites>
          break;
   21ae6:	e005      	b.n	21af4 <attsProcExecWriteReq+0x9c>
    for (pPrep = pCcb->prepWriteQueue.pHead; pPrep != NULL; pPrep = pPrep->pNext)
   21ae8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21aea:	681b      	ldr	r3, [r3, #0]
   21aec:	627b      	str	r3, [r7, #36]	; 0x24
   21aee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21af0:	2b00      	cmp	r3, #0
   21af2:	d1ce      	bne.n	21a92 <attsProcExecWriteReq+0x3a>
        }
      }
    }

    /* if length and offset checks ok then write all buffers in queue */
    if (err == ATT_SUCCESS)
   21af4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21af8:	2b00      	cmp	r3, #0
   21afa:	d11d      	bne.n	21b38 <attsProcExecWriteReq+0xe0>
    {
      /* for each buffer */
      while ((pPrep = WsfQueueDeq(&pCcb->prepWriteQueue)) != NULL)
   21afc:	e010      	b.n	21b20 <attsProcExecWriteReq+0xc8>
      {
        /* write buffer */
        if ((err = attsExecPrepWrite(pCcb, pPrep)) != ATT_SUCCESS)
   21afe:	6a79      	ldr	r1, [r7, #36]	; 0x24
   21b00:	68f8      	ldr	r0, [r7, #12]
   21b02:	f7ff fd43 	bl	2158c <attsExecPrepWrite>
   21b06:	4603      	mov	r3, r0
   21b08:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
   21b0c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21b10:	2b00      	cmp	r3, #0
   21b12:	d002      	beq.n	21b1a <attsProcExecWriteReq+0xc2>
        {
          /* write failed; discard remaining prepared writes */
          attsClearPrepWrites(pCcb);
   21b14:	68f8      	ldr	r0, [r7, #12]
   21b16:	f7fe f88f 	bl	1fc38 <attsClearPrepWrites>
        }

        /* free buffer */
        WsfBufFree(pPrep);
   21b1a:	6a78      	ldr	r0, [r7, #36]	; 0x24
   21b1c:	f00b fa78 	bl	2d010 <WsfBufFree>
      while ((pPrep = WsfQueueDeq(&pCcb->prepWriteQueue)) != NULL)
   21b20:	68fb      	ldr	r3, [r7, #12]
   21b22:	4618      	mov	r0, r3
   21b24:	f00b fd22 	bl	2d56c <WsfQueueDeq>
   21b28:	6278      	str	r0, [r7, #36]	; 0x24
   21b2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   21b2c:	2b00      	cmp	r3, #0
   21b2e:	d1e6      	bne.n	21afe <attsProcExecWriteReq+0xa6>
   21b30:	e002      	b.n	21b38 <attsProcExecWriteReq+0xe0>
    }
  }
  /* else unknown operation */
  else
  {
    err = ATT_ERR_INVALID_PDU;
   21b32:	2304      	movs	r3, #4
   21b34:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  }

  /* send response or error response */
  if (err)
   21b38:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21b3c:	2b00      	cmp	r3, #0
   21b3e:	d008      	beq.n	21b52 <attsProcExecWriteReq+0xfa>
  {
    attsErrRsp(pCcb->handle, ATT_PDU_EXEC_WRITE_REQ, 0, err);
   21b40:	68fb      	ldr	r3, [r7, #12]
   21b42:	8b18      	ldrh	r0, [r3, #24]
   21b44:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   21b48:	2200      	movs	r2, #0
   21b4a:	2118      	movs	r1, #24
   21b4c:	f7fe f834 	bl	1fbb8 <attsErrRsp>
      UINT8_TO_BSTREAM(p, ATT_PDU_EXEC_WRITE_RSP);

      L2cDataReq(L2C_CID_ATT, pCcb->handle, ATT_EXEC_WRITE_RSP_LEN, pBuf);
    }
  }
}
   21b50:	e015      	b.n	21b7e <attsProcExecWriteReq+0x126>
    if ((pBuf = attMsgAlloc(L2C_PAYLOAD_START + ATT_EXEC_WRITE_RSP_LEN)) != NULL)
   21b52:	2009      	movs	r0, #9
   21b54:	f7fb ff48 	bl	1d9e8 <attMsgAlloc>
   21b58:	61b8      	str	r0, [r7, #24]
   21b5a:	69bb      	ldr	r3, [r7, #24]
   21b5c:	2b00      	cmp	r3, #0
   21b5e:	d00e      	beq.n	21b7e <attsProcExecWriteReq+0x126>
      p = pBuf + L2C_PAYLOAD_START;
   21b60:	69bb      	ldr	r3, [r7, #24]
   21b62:	3308      	adds	r3, #8
   21b64:	617b      	str	r3, [r7, #20]
      UINT8_TO_BSTREAM(p, ATT_PDU_EXEC_WRITE_RSP);
   21b66:	697b      	ldr	r3, [r7, #20]
   21b68:	1c5a      	adds	r2, r3, #1
   21b6a:	617a      	str	r2, [r7, #20]
   21b6c:	2219      	movs	r2, #25
   21b6e:	701a      	strb	r2, [r3, #0]
      L2cDataReq(L2C_CID_ATT, pCcb->handle, ATT_EXEC_WRITE_RSP_LEN, pBuf);
   21b70:	68fb      	ldr	r3, [r7, #12]
   21b72:	8b19      	ldrh	r1, [r3, #24]
   21b74:	69bb      	ldr	r3, [r7, #24]
   21b76:	2201      	movs	r2, #1
   21b78:	2004      	movs	r0, #4
   21b7a:	f008 f9b5 	bl	29ee8 <L2cDataReq>
}
   21b7e:	bf00      	nop
   21b80:	3728      	adds	r7, #40	; 0x28
   21b82:	46bd      	mov	sp, r7
   21b84:	bd80      	pop	{r7, pc}

00021b86 <BdaCpy>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void BdaCpy(uint8_t *pDst, const uint8_t *pSrc)
{
   21b86:	b580      	push	{r7, lr}
   21b88:	b082      	sub	sp, #8
   21b8a:	af00      	add	r7, sp, #0
   21b8c:	6078      	str	r0, [r7, #4]
   21b8e:	6039      	str	r1, [r7, #0]
  memcpy(pDst, pSrc, BDA_ADDR_LEN);
   21b90:	2206      	movs	r2, #6
   21b92:	6839      	ldr	r1, [r7, #0]
   21b94:	6878      	ldr	r0, [r7, #4]
   21b96:	f7f6 fb5d 	bl	18254 <memcpy>
}
   21b9a:	bf00      	nop
   21b9c:	3708      	adds	r7, #8
   21b9e:	46bd      	mov	sp, r7
   21ba0:	bd80      	pop	{r7, pc}

00021ba2 <BdaCmp>:
 *
 *  \return TRUE if addresses match, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t BdaCmp(const uint8_t *pAddr1, const uint8_t *pAddr2)
{
   21ba2:	b580      	push	{r7, lr}
   21ba4:	b082      	sub	sp, #8
   21ba6:	af00      	add	r7, sp, #0
   21ba8:	6078      	str	r0, [r7, #4]
   21baa:	6039      	str	r1, [r7, #0]
  return (memcmp(pAddr1, pAddr2, BDA_ADDR_LEN) == 0);
   21bac:	2206      	movs	r2, #6
   21bae:	6839      	ldr	r1, [r7, #0]
   21bb0:	6878      	ldr	r0, [r7, #4]
   21bb2:	f00e fa01 	bl	2ffb8 <memcmp>
   21bb6:	4603      	mov	r3, r0
   21bb8:	2b00      	cmp	r3, #0
   21bba:	bf0c      	ite	eq
   21bbc:	2301      	moveq	r3, #1
   21bbe:	2300      	movne	r3, #0
   21bc0:	b2db      	uxtb	r3, r3
}
   21bc2:	4618      	mov	r0, r3
   21bc4:	3708      	adds	r7, #8
   21bc6:	46bd      	mov	sp, r7
   21bc8:	bd80      	pop	{r7, pc}

00021bca <BdaClr>:
 *
 *  \return pDst + BDA_ADDR_LEN
 */
/*************************************************************************************************/
uint8_t *BdaClr(uint8_t *pDst)
{
   21bca:	b580      	push	{r7, lr}
   21bcc:	b082      	sub	sp, #8
   21bce:	af00      	add	r7, sp, #0
   21bd0:	6078      	str	r0, [r7, #4]
  memset(pDst, 0, BDA_ADDR_LEN);
   21bd2:	2206      	movs	r2, #6
   21bd4:	2100      	movs	r1, #0
   21bd6:	6878      	ldr	r0, [r7, #4]
   21bd8:	f00e fa8a 	bl	300f0 <memset>

  return (pDst + BDA_ADDR_LEN);
   21bdc:	687b      	ldr	r3, [r7, #4]
   21bde:	3306      	adds	r3, #6
}
   21be0:	4618      	mov	r0, r3
   21be2:	3708      	adds	r7, #8
   21be4:	46bd      	mov	sp, r7
   21be6:	bd80      	pop	{r7, pc}

00021be8 <Calc128Cpy>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void Calc128Cpy(uint8_t *pDst, uint8_t *pSrc)
{
   21be8:	b580      	push	{r7, lr}
   21bea:	b082      	sub	sp, #8
   21bec:	af00      	add	r7, sp, #0
   21bee:	6078      	str	r0, [r7, #4]
   21bf0:	6039      	str	r1, [r7, #0]
  memcpy(pDst, pSrc, CALC128_LEN);
   21bf2:	2210      	movs	r2, #16
   21bf4:	6839      	ldr	r1, [r7, #0]
   21bf6:	6878      	ldr	r0, [r7, #4]
   21bf8:	f7f6 fb2c 	bl	18254 <memcpy>
}
   21bfc:	bf00      	nop
   21bfe:	3708      	adds	r7, #8
   21c00:	46bd      	mov	sp, r7
   21c02:	bd80      	pop	{r7, pc}

00021c04 <Calc128Xor>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void Calc128Xor(uint8_t *pDst, uint8_t *pSrc)
{
   21c04:	b480      	push	{r7}
   21c06:	b085      	sub	sp, #20
   21c08:	af00      	add	r7, sp, #0
   21c0a:	6078      	str	r0, [r7, #4]
   21c0c:	6039      	str	r1, [r7, #0]
  uint8_t i;
  
  for (i = CALC128_LEN; i > 0; i--)
   21c0e:	2310      	movs	r3, #16
   21c10:	73fb      	strb	r3, [r7, #15]
   21c12:	e00d      	b.n	21c30 <Calc128Xor+0x2c>
  {
    *pDst++ ^= *pSrc++;
   21c14:	683b      	ldr	r3, [r7, #0]
   21c16:	1c5a      	adds	r2, r3, #1
   21c18:	603a      	str	r2, [r7, #0]
   21c1a:	7819      	ldrb	r1, [r3, #0]
   21c1c:	687b      	ldr	r3, [r7, #4]
   21c1e:	1c5a      	adds	r2, r3, #1
   21c20:	607a      	str	r2, [r7, #4]
   21c22:	781a      	ldrb	r2, [r3, #0]
   21c24:	404a      	eors	r2, r1
   21c26:	b2d2      	uxtb	r2, r2
   21c28:	701a      	strb	r2, [r3, #0]
  for (i = CALC128_LEN; i > 0; i--)
   21c2a:	7bfb      	ldrb	r3, [r7, #15]
   21c2c:	3b01      	subs	r3, #1
   21c2e:	73fb      	strb	r3, [r7, #15]
   21c30:	7bfb      	ldrb	r3, [r7, #15]
   21c32:	2b00      	cmp	r3, #0
   21c34:	d1ee      	bne.n	21c14 <Calc128Xor+0x10>
  }
}
   21c36:	bf00      	nop
   21c38:	bf00      	nop
   21c3a:	3714      	adds	r7, #20
   21c3c:	46bd      	mov	sp, r7
   21c3e:	f85d 7b04 	ldr.w	r7, [sp], #4
   21c42:	4770      	bx	lr

00021c44 <dmAdvCbInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvCbInit(uint8_t advHandle)
{
   21c44:	b480      	push	{r7}
   21c46:	b083      	sub	sp, #12
   21c48:	af00      	add	r7, sp, #0
   21c4a:	4603      	mov	r3, r0
   21c4c:	71fb      	strb	r3, [r7, #7]
  /* initialize control block */
  dmAdvCb.advType[advHandle] = DM_ADV_NONE;
   21c4e:	79fb      	ldrb	r3, [r7, #7]
   21c50:	4a13      	ldr	r2, [pc, #76]	; (21ca0 <dmAdvCbInit+0x5c>)
   21c52:	4413      	add	r3, r2
   21c54:	22ff      	movs	r2, #255	; 0xff
   21c56:	751a      	strb	r2, [r3, #20]
  dmAdvCb.intervalMin[advHandle] = DM_GAP_ADV_SLOW_INT_MIN;
   21c58:	79fb      	ldrb	r3, [r7, #7]
   21c5a:	4a11      	ldr	r2, [pc, #68]	; (21ca0 <dmAdvCbInit+0x5c>)
   21c5c:	3308      	adds	r3, #8
   21c5e:	f44f 61c8 	mov.w	r1, #1600	; 0x640
   21c62:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
  dmAdvCb.intervalMax[advHandle] = DM_GAP_ADV_SLOW_INT_MAX;
   21c66:	79fb      	ldrb	r3, [r7, #7]
   21c68:	4a0d      	ldr	r2, [pc, #52]	; (21ca0 <dmAdvCbInit+0x5c>)
   21c6a:	3308      	adds	r3, #8
   21c6c:	005b      	lsls	r3, r3, #1
   21c6e:	4413      	add	r3, r2
   21c70:	f44f 62f0 	mov.w	r2, #1920	; 0x780
   21c74:	805a      	strh	r2, [r3, #2]
  dmAdvCb.channelMap[advHandle] = DM_ADV_CHAN_ALL;
   21c76:	79fb      	ldrb	r3, [r7, #7]
   21c78:	4a09      	ldr	r2, [pc, #36]	; (21ca0 <dmAdvCbInit+0x5c>)
   21c7a:	4413      	add	r3, r2
   21c7c:	2207      	movs	r2, #7
   21c7e:	755a      	strb	r2, [r3, #21]
  dmCb.advFiltPolicy[advHandle] = HCI_ADV_FILT_NONE;
   21c80:	79fb      	ldrb	r3, [r7, #7]
   21c82:	4a08      	ldr	r2, [pc, #32]	; (21ca4 <dmAdvCbInit+0x60>)
   21c84:	4413      	add	r3, r2
   21c86:	2200      	movs	r2, #0
   21c88:	745a      	strb	r2, [r3, #17]
  dmAdvCb.advState[advHandle] = DM_ADV_STATE_IDLE;
   21c8a:	79fb      	ldrb	r3, [r7, #7]
   21c8c:	4a04      	ldr	r2, [pc, #16]	; (21ca0 <dmAdvCbInit+0x5c>)
   21c8e:	4413      	add	r3, r2
   21c90:	2200      	movs	r2, #0
   21c92:	75da      	strb	r2, [r3, #23]
}
   21c94:	bf00      	nop
   21c96:	370c      	adds	r7, #12
   21c98:	46bd      	mov	sp, r7
   21c9a:	f85d 7b04 	ldr.w	r7, [sp], #4
   21c9e:	4770      	bx	lr
   21ca0:	100111f4 	.word	0x100111f4
   21ca4:	100112ec 	.word	0x100112ec

00021ca8 <dmAdvInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvInit(void)
{
   21ca8:	b580      	push	{r7, lr}
   21caa:	b082      	sub	sp, #8
   21cac:	af00      	add	r7, sp, #0
  uint8_t i;

  /* initialize control block */
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   21cae:	2300      	movs	r3, #0
   21cb0:	71fb      	strb	r3, [r7, #7]
   21cb2:	e006      	b.n	21cc2 <dmAdvInit+0x1a>
  {
    dmAdvCbInit(i);
   21cb4:	79fb      	ldrb	r3, [r7, #7]
   21cb6:	4618      	mov	r0, r3
   21cb8:	f7ff ffc4 	bl	21c44 <dmAdvCbInit>
  for (i = 0; i < DM_NUM_ADV_SETS; i++)
   21cbc:	79fb      	ldrb	r3, [r7, #7]
   21cbe:	3301      	adds	r3, #1
   21cc0:	71fb      	strb	r3, [r7, #7]
   21cc2:	79fb      	ldrb	r3, [r7, #7]
   21cc4:	2b00      	cmp	r3, #0
   21cc6:	d0f5      	beq.n	21cb4 <dmAdvInit+0xc>
  }

  dmAdvCb.advTimer.handlerId = dmCb.handlerId;
   21cc8:	4b05      	ldr	r3, [pc, #20]	; (21ce0 <dmAdvInit+0x38>)
   21cca:	7b1a      	ldrb	r2, [r3, #12]
   21ccc:	4b05      	ldr	r3, [pc, #20]	; (21ce4 <dmAdvInit+0x3c>)
   21cce:	731a      	strb	r2, [r3, #12]
  dmCb.advAddrType = DM_ADDR_PUBLIC;
   21cd0:	4b03      	ldr	r3, [pc, #12]	; (21ce0 <dmAdvInit+0x38>)
   21cd2:	2200      	movs	r2, #0
   21cd4:	739a      	strb	r2, [r3, #14]
}
   21cd6:	bf00      	nop
   21cd8:	3708      	adds	r7, #8
   21cda:	46bd      	mov	sp, r7
   21cdc:	bd80      	pop	{r7, pc}
   21cde:	bf00      	nop
   21ce0:	100112ec 	.word	0x100112ec
   21ce4:	100111f4 	.word	0x100111f4

00021ce8 <dmAdvGenConnCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvGenConnCmpl(uint8_t advHandle, uint8_t status)
{
   21ce8:	b580      	push	{r7, lr}
   21cea:	b08c      	sub	sp, #48	; 0x30
   21cec:	af00      	add	r7, sp, #0
   21cee:	4603      	mov	r3, r0
   21cf0:	460a      	mov	r2, r1
   21cf2:	71fb      	strb	r3, [r7, #7]
   21cf4:	4613      	mov	r3, r2
   21cf6:	71bb      	strb	r3, [r7, #6]
  hciLeConnCmplEvt_t  leConnCmpl;

  /* generate enhanced connection complete event */
  memset(&leConnCmpl, 0, sizeof(leConnCmpl));
   21cf8:	f107 030c 	add.w	r3, r7, #12
   21cfc:	2224      	movs	r2, #36	; 0x24
   21cfe:	2100      	movs	r1, #0
   21d00:	4618      	mov	r0, r3
   21d02:	f00e f9f5 	bl	300f0 <memset>

  leConnCmpl.hdr.event = HCI_LE_ENHANCED_CONN_CMPL_CBACK_EVT;
   21d06:	2302      	movs	r3, #2
   21d08:	73bb      	strb	r3, [r7, #14]
  leConnCmpl.hdr.status = leConnCmpl.status = status;
   21d0a:	79bb      	ldrb	r3, [r7, #6]
   21d0c:	743b      	strb	r3, [r7, #16]
   21d0e:	7c3b      	ldrb	r3, [r7, #16]
   21d10:	73fb      	strb	r3, [r7, #15]
  leConnCmpl.role = DM_ROLE_SLAVE;
   21d12:	2301      	movs	r3, #1
   21d14:	753b      	strb	r3, [r7, #20]
  leConnCmpl.addrType = dmAdvCb.peerAddrType[advHandle];
   21d16:	79fb      	ldrb	r3, [r7, #7]
   21d18:	4a0e      	ldr	r2, [pc, #56]	; (21d54 <dmAdvGenConnCmpl+0x6c>)
   21d1a:	4413      	add	r3, r2
   21d1c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
   21d20:	757b      	strb	r3, [r7, #21]
  BdaCpy(leConnCmpl.peerAddr, dmAdvCb.peerAddr[advHandle]);
   21d22:	79fa      	ldrb	r2, [r7, #7]
   21d24:	4613      	mov	r3, r2
   21d26:	005b      	lsls	r3, r3, #1
   21d28:	4413      	add	r3, r2
   21d2a:	005b      	lsls	r3, r3, #1
   21d2c:	3318      	adds	r3, #24
   21d2e:	4a09      	ldr	r2, [pc, #36]	; (21d54 <dmAdvGenConnCmpl+0x6c>)
   21d30:	4413      	add	r3, r2
   21d32:	1cda      	adds	r2, r3, #3
   21d34:	f107 030c 	add.w	r3, r7, #12
   21d38:	330a      	adds	r3, #10
   21d3a:	4611      	mov	r1, r2
   21d3c:	4618      	mov	r0, r3
   21d3e:	f7ff ff22 	bl	21b86 <BdaCpy>

  /* pass connection complete event to DM connection management module */
  dmDevPassHciEvtToConn((hciEvt_t *) &leConnCmpl);
   21d42:	f107 030c 	add.w	r3, r7, #12
   21d46:	4618      	mov	r0, r3
   21d48:	f002 f81a 	bl	23d80 <dmDevPassHciEvtToConn>
}
   21d4c:	bf00      	nop
   21d4e:	3730      	adds	r7, #48	; 0x30
   21d50:	46bd      	mov	sp, r7
   21d52:	bd80      	pop	{r7, pc}
   21d54:	100111f4 	.word	0x100111f4

00021d58 <DmAdvConfig>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvConfig(uint8_t advHandle, uint8_t advType, uint8_t peerAddrType, uint8_t *pPeerAddr)
{
   21d58:	b580      	push	{r7, lr}
   21d5a:	b084      	sub	sp, #16
   21d5c:	af00      	add	r7, sp, #0
   21d5e:	603b      	str	r3, [r7, #0]
   21d60:	4603      	mov	r3, r0
   21d62:	71fb      	strb	r3, [r7, #7]
   21d64:	460b      	mov	r3, r1
   21d66:	71bb      	strb	r3, [r7, #6]
   21d68:	4613      	mov	r3, r2
   21d6a:	717b      	strb	r3, [r7, #5]
  dmAdvApiConfig_t *pMsg;

  WSF_ASSERT(advHandle < DM_NUM_ADV_SETS);

  if ((pMsg = WsfMsgAlloc(sizeof(dmAdvApiConfig_t))) != NULL)
   21d6c:	200e      	movs	r0, #14
   21d6e:	f00b f99e 	bl	2d0ae <WsfMsgAlloc>
   21d72:	60f8      	str	r0, [r7, #12]
   21d74:	68fb      	ldr	r3, [r7, #12]
   21d76:	2b00      	cmp	r3, #0
   21d78:	d017      	beq.n	21daa <DmAdvConfig+0x52>
  {
    pMsg->hdr.event = DM_ADV_MSG_API_CONFIG;
   21d7a:	68fb      	ldr	r3, [r7, #12]
   21d7c:	2200      	movs	r2, #0
   21d7e:	709a      	strb	r2, [r3, #2]
    pMsg->advType = advType;
   21d80:	68fb      	ldr	r3, [r7, #12]
   21d82:	79ba      	ldrb	r2, [r7, #6]
   21d84:	715a      	strb	r2, [r3, #5]
    pMsg->advHandle = advHandle;
   21d86:	68fb      	ldr	r3, [r7, #12]
   21d88:	79fa      	ldrb	r2, [r7, #7]
   21d8a:	711a      	strb	r2, [r3, #4]
    pMsg->peerAddrType = peerAddrType;
   21d8c:	68fb      	ldr	r3, [r7, #12]
   21d8e:	797a      	ldrb	r2, [r7, #5]
   21d90:	719a      	strb	r2, [r3, #6]
    BdaCpy(pMsg->peerAddr, pPeerAddr);
   21d92:	68fb      	ldr	r3, [r7, #12]
   21d94:	3307      	adds	r3, #7
   21d96:	6839      	ldr	r1, [r7, #0]
   21d98:	4618      	mov	r0, r3
   21d9a:	f7ff fef4 	bl	21b86 <BdaCpy>
    WsfMsgSend(dmCb.handlerId, pMsg);
   21d9e:	4b05      	ldr	r3, [pc, #20]	; (21db4 <DmAdvConfig+0x5c>)
   21da0:	7b1b      	ldrb	r3, [r3, #12]
   21da2:	68f9      	ldr	r1, [r7, #12]
   21da4:	4618      	mov	r0, r3
   21da6:	f00b f9a6 	bl	2d0f6 <WsfMsgSend>
  }
}
   21daa:	bf00      	nop
   21dac:	3710      	adds	r7, #16
   21dae:	46bd      	mov	sp, r7
   21db0:	bd80      	pop	{r7, pc}
   21db2:	bf00      	nop
   21db4:	100112ec 	.word	0x100112ec

00021db8 <DmAdvSetData>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvSetData(uint8_t advHandle, uint8_t op, uint8_t location, uint8_t len, uint8_t *pData)
{
   21db8:	b590      	push	{r4, r7, lr}
   21dba:	b085      	sub	sp, #20
   21dbc:	af00      	add	r7, sp, #0
   21dbe:	4604      	mov	r4, r0
   21dc0:	4608      	mov	r0, r1
   21dc2:	4611      	mov	r1, r2
   21dc4:	461a      	mov	r2, r3
   21dc6:	4623      	mov	r3, r4
   21dc8:	71fb      	strb	r3, [r7, #7]
   21dca:	4603      	mov	r3, r0
   21dcc:	71bb      	strb	r3, [r7, #6]
   21dce:	460b      	mov	r3, r1
   21dd0:	717b      	strb	r3, [r7, #5]
   21dd2:	4613      	mov	r3, r2
   21dd4:	713b      	strb	r3, [r7, #4]
  dmAdvApiSetData_t *pMsg;

  WSF_ASSERT((location == DM_DATA_LOC_SCAN) || (location == DM_DATA_LOC_ADV));
  WSF_ASSERT(advHandle < DM_NUM_ADV_SETS);

  if ((pMsg = WsfMsgAlloc(sizeof(dmAdvApiSetData_t) + len)) != NULL)
   21dd6:	793b      	ldrb	r3, [r7, #4]
   21dd8:	b29b      	uxth	r3, r3
   21dda:	3308      	adds	r3, #8
   21ddc:	b29b      	uxth	r3, r3
   21dde:	4618      	mov	r0, r3
   21de0:	f00b f965 	bl	2d0ae <WsfMsgAlloc>
   21de4:	60f8      	str	r0, [r7, #12]
   21de6:	68fb      	ldr	r3, [r7, #12]
   21de8:	2b00      	cmp	r3, #0
   21dea:	d01b      	beq.n	21e24 <DmAdvSetData+0x6c>
  {
    pMsg->hdr.event = DM_ADV_MSG_API_SET_DATA;
   21dec:	68fb      	ldr	r3, [r7, #12]
   21dee:	2201      	movs	r2, #1
   21df0:	709a      	strb	r2, [r3, #2]
    pMsg->advHandle = advHandle;
   21df2:	68fb      	ldr	r3, [r7, #12]
   21df4:	79fa      	ldrb	r2, [r7, #7]
   21df6:	711a      	strb	r2, [r3, #4]
    pMsg->op = op;
   21df8:	68fb      	ldr	r3, [r7, #12]
   21dfa:	79ba      	ldrb	r2, [r7, #6]
   21dfc:	715a      	strb	r2, [r3, #5]
    pMsg->location = location;
   21dfe:	68fb      	ldr	r3, [r7, #12]
   21e00:	797a      	ldrb	r2, [r7, #5]
   21e02:	719a      	strb	r2, [r3, #6]
    pMsg->len = len;
   21e04:	68fb      	ldr	r3, [r7, #12]
   21e06:	793a      	ldrb	r2, [r7, #4]
   21e08:	71da      	strb	r2, [r3, #7]
    memcpy(pMsg->pData, pData, len);
   21e0a:	68fb      	ldr	r3, [r7, #12]
   21e0c:	3308      	adds	r3, #8
   21e0e:	793a      	ldrb	r2, [r7, #4]
   21e10:	6a39      	ldr	r1, [r7, #32]
   21e12:	4618      	mov	r0, r3
   21e14:	f7f6 fa1e 	bl	18254 <memcpy>
    WsfMsgSend(dmCb.handlerId, pMsg);
   21e18:	4b04      	ldr	r3, [pc, #16]	; (21e2c <DmAdvSetData+0x74>)
   21e1a:	7b1b      	ldrb	r3, [r3, #12]
   21e1c:	68f9      	ldr	r1, [r7, #12]
   21e1e:	4618      	mov	r0, r3
   21e20:	f00b f969 	bl	2d0f6 <WsfMsgSend>
  }
}
   21e24:	bf00      	nop
   21e26:	3714      	adds	r7, #20
   21e28:	46bd      	mov	sp, r7
   21e2a:	bd90      	pop	{r4, r7, pc}
   21e2c:	100112ec 	.word	0x100112ec

00021e30 <DmAdvStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvStart(uint8_t numSets, uint8_t *pAdvHandles, uint16_t *pDuration, uint8_t *pMaxEaEvents)
{
   21e30:	b580      	push	{r7, lr}
   21e32:	b086      	sub	sp, #24
   21e34:	af00      	add	r7, sp, #0
   21e36:	60b9      	str	r1, [r7, #8]
   21e38:	607a      	str	r2, [r7, #4]
   21e3a:	603b      	str	r3, [r7, #0]
   21e3c:	4603      	mov	r3, r0
   21e3e:	73fb      	strb	r3, [r7, #15]
  uint8_t i;
  dmAdvApiStart_t *pMsg;

  WSF_ASSERT(numSets <= DM_NUM_ADV_SETS);

  if ((pMsg = WsfMsgAlloc(sizeof(dmAdvApiStart_t))) != NULL)
   21e40:	200a      	movs	r0, #10
   21e42:	f00b f934 	bl	2d0ae <WsfMsgAlloc>
   21e46:	6138      	str	r0, [r7, #16]
   21e48:	693b      	ldr	r3, [r7, #16]
   21e4a:	2b00      	cmp	r3, #0
   21e4c:	d032      	beq.n	21eb4 <DmAdvStart+0x84>
  {
    pMsg->hdr.event = DM_ADV_MSG_API_START;
   21e4e:	693b      	ldr	r3, [r7, #16]
   21e50:	2202      	movs	r2, #2
   21e52:	709a      	strb	r2, [r3, #2]
    pMsg->numSets = numSets;
   21e54:	693b      	ldr	r3, [r7, #16]
   21e56:	7bfa      	ldrb	r2, [r7, #15]
   21e58:	711a      	strb	r2, [r3, #4]

    for (i = 0; i < numSets; i++)
   21e5a:	2300      	movs	r3, #0
   21e5c:	75fb      	strb	r3, [r7, #23]
   21e5e:	e01f      	b.n	21ea0 <DmAdvStart+0x70>
    {
      pMsg->advHandle[i] = pAdvHandles[i];
   21e60:	7dfb      	ldrb	r3, [r7, #23]
   21e62:	68ba      	ldr	r2, [r7, #8]
   21e64:	441a      	add	r2, r3
   21e66:	7dfb      	ldrb	r3, [r7, #23]
   21e68:	7811      	ldrb	r1, [r2, #0]
   21e6a:	693a      	ldr	r2, [r7, #16]
   21e6c:	4413      	add	r3, r2
   21e6e:	460a      	mov	r2, r1
   21e70:	715a      	strb	r2, [r3, #5]
      pMsg->duration[i] = pDuration[i];
   21e72:	7dfb      	ldrb	r3, [r7, #23]
   21e74:	005b      	lsls	r3, r3, #1
   21e76:	687a      	ldr	r2, [r7, #4]
   21e78:	441a      	add	r2, r3
   21e7a:	7dfb      	ldrb	r3, [r7, #23]
   21e7c:	8811      	ldrh	r1, [r2, #0]
   21e7e:	693a      	ldr	r2, [r7, #16]
   21e80:	005b      	lsls	r3, r3, #1
   21e82:	4413      	add	r3, r2
   21e84:	460a      	mov	r2, r1
   21e86:	80da      	strh	r2, [r3, #6]
      pMsg->maxEaEvents[i] = pMaxEaEvents[i];
   21e88:	7dfb      	ldrb	r3, [r7, #23]
   21e8a:	683a      	ldr	r2, [r7, #0]
   21e8c:	441a      	add	r2, r3
   21e8e:	7dfb      	ldrb	r3, [r7, #23]
   21e90:	7811      	ldrb	r1, [r2, #0]
   21e92:	693a      	ldr	r2, [r7, #16]
   21e94:	4413      	add	r3, r2
   21e96:	460a      	mov	r2, r1
   21e98:	721a      	strb	r2, [r3, #8]
    for (i = 0; i < numSets; i++)
   21e9a:	7dfb      	ldrb	r3, [r7, #23]
   21e9c:	3301      	adds	r3, #1
   21e9e:	75fb      	strb	r3, [r7, #23]
   21ea0:	7dfa      	ldrb	r2, [r7, #23]
   21ea2:	7bfb      	ldrb	r3, [r7, #15]
   21ea4:	429a      	cmp	r2, r3
   21ea6:	d3db      	bcc.n	21e60 <DmAdvStart+0x30>
    }

    WsfMsgSend(dmCb.handlerId, pMsg);
   21ea8:	4b04      	ldr	r3, [pc, #16]	; (21ebc <DmAdvStart+0x8c>)
   21eaa:	7b1b      	ldrb	r3, [r3, #12]
   21eac:	6939      	ldr	r1, [r7, #16]
   21eae:	4618      	mov	r0, r3
   21eb0:	f00b f921 	bl	2d0f6 <WsfMsgSend>
  }
}
   21eb4:	bf00      	nop
   21eb6:	3718      	adds	r7, #24
   21eb8:	46bd      	mov	sp, r7
   21eba:	bd80      	pop	{r7, pc}
   21ebc:	100112ec 	.word	0x100112ec

00021ec0 <DmAdvStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvStop(uint8_t numSets, uint8_t *pAdvHandles)
{
   21ec0:	b580      	push	{r7, lr}
   21ec2:	b084      	sub	sp, #16
   21ec4:	af00      	add	r7, sp, #0
   21ec6:	4603      	mov	r3, r0
   21ec8:	6039      	str	r1, [r7, #0]
   21eca:	71fb      	strb	r3, [r7, #7]
  uint8_t i;
  dmAdvApiStop_t *pMsg;

  WSF_ASSERT(numSets <= DM_NUM_ADV_SETS);

  if ((pMsg = WsfMsgAlloc(sizeof(dmAdvApiStop_t))) != NULL)
   21ecc:	2008      	movs	r0, #8
   21ece:	f00b f8ee 	bl	2d0ae <WsfMsgAlloc>
   21ed2:	60b8      	str	r0, [r7, #8]
   21ed4:	68bb      	ldr	r3, [r7, #8]
   21ed6:	2b00      	cmp	r3, #0
   21ed8:	d01e      	beq.n	21f18 <DmAdvStop+0x58>
  {
    pMsg->hdr.event = DM_ADV_MSG_API_STOP;
   21eda:	68bb      	ldr	r3, [r7, #8]
   21edc:	2203      	movs	r2, #3
   21ede:	709a      	strb	r2, [r3, #2]
    pMsg->numSets = numSets;
   21ee0:	68bb      	ldr	r3, [r7, #8]
   21ee2:	79fa      	ldrb	r2, [r7, #7]
   21ee4:	711a      	strb	r2, [r3, #4]

    for (i = 0; i < numSets; i++)
   21ee6:	2300      	movs	r3, #0
   21ee8:	73fb      	strb	r3, [r7, #15]
   21eea:	e00b      	b.n	21f04 <DmAdvStop+0x44>
    {
      pMsg->advHandle[i] = pAdvHandles[i];
   21eec:	7bfb      	ldrb	r3, [r7, #15]
   21eee:	683a      	ldr	r2, [r7, #0]
   21ef0:	441a      	add	r2, r3
   21ef2:	7bfb      	ldrb	r3, [r7, #15]
   21ef4:	7811      	ldrb	r1, [r2, #0]
   21ef6:	68ba      	ldr	r2, [r7, #8]
   21ef8:	4413      	add	r3, r2
   21efa:	460a      	mov	r2, r1
   21efc:	715a      	strb	r2, [r3, #5]
    for (i = 0; i < numSets; i++)
   21efe:	7bfb      	ldrb	r3, [r7, #15]
   21f00:	3301      	adds	r3, #1
   21f02:	73fb      	strb	r3, [r7, #15]
   21f04:	7bfa      	ldrb	r2, [r7, #15]
   21f06:	79fb      	ldrb	r3, [r7, #7]
   21f08:	429a      	cmp	r2, r3
   21f0a:	d3ef      	bcc.n	21eec <DmAdvStop+0x2c>
    }

    WsfMsgSend(dmCb.handlerId, pMsg);
   21f0c:	4b04      	ldr	r3, [pc, #16]	; (21f20 <DmAdvStop+0x60>)
   21f0e:	7b1b      	ldrb	r3, [r3, #12]
   21f10:	68b9      	ldr	r1, [r7, #8]
   21f12:	4618      	mov	r0, r3
   21f14:	f00b f8ef 	bl	2d0f6 <WsfMsgSend>
  }
}
   21f18:	bf00      	nop
   21f1a:	3710      	adds	r7, #16
   21f1c:	46bd      	mov	sp, r7
   21f1e:	bd80      	pop	{r7, pc}
   21f20:	100112ec 	.word	0x100112ec

00021f24 <DmAdvSetInterval>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvSetInterval(uint8_t advHandle, uint16_t intervalMin, uint16_t intervalMax)
{
   21f24:	b580      	push	{r7, lr}
   21f26:	b082      	sub	sp, #8
   21f28:	af00      	add	r7, sp, #0
   21f2a:	4603      	mov	r3, r0
   21f2c:	71fb      	strb	r3, [r7, #7]
   21f2e:	460b      	mov	r3, r1
   21f30:	80bb      	strh	r3, [r7, #4]
   21f32:	4613      	mov	r3, r2
   21f34:	807b      	strh	r3, [r7, #2]
  WSF_ASSERT(advHandle < DM_NUM_ADV_SETS);

  WsfTaskLock();
   21f36:	f00b f965 	bl	2d204 <WsfTaskLock>
  dmAdvCb.intervalMin[advHandle] = intervalMin;
   21f3a:	79fb      	ldrb	r3, [r7, #7]
   21f3c:	4908      	ldr	r1, [pc, #32]	; (21f60 <DmAdvSetInterval+0x3c>)
   21f3e:	3308      	adds	r3, #8
   21f40:	88ba      	ldrh	r2, [r7, #4]
   21f42:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
  dmAdvCb.intervalMax[advHandle] = intervalMax;
   21f46:	79fb      	ldrb	r3, [r7, #7]
   21f48:	4a05      	ldr	r2, [pc, #20]	; (21f60 <DmAdvSetInterval+0x3c>)
   21f4a:	3308      	adds	r3, #8
   21f4c:	005b      	lsls	r3, r3, #1
   21f4e:	4413      	add	r3, r2
   21f50:	887a      	ldrh	r2, [r7, #2]
   21f52:	805a      	strh	r2, [r3, #2]
  WsfTaskUnlock();
   21f54:	f00b f95c 	bl	2d210 <WsfTaskUnlock>
}
   21f58:	bf00      	nop
   21f5a:	3708      	adds	r7, #8
   21f5c:	46bd      	mov	sp, r7
   21f5e:	bd80      	pop	{r7, pc}
   21f60:	100111f4 	.word	0x100111f4

00021f64 <DmAdvSetAdValue>:
 *  \return TRUE if the element was successfully added to the data, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t DmAdvSetAdValue(uint8_t adType, uint8_t len, uint8_t *pValue, uint16_t *pAdvDataLen,
                       uint8_t *pAdvData, uint16_t advDataBufLen)
{
   21f64:	b580      	push	{r7, lr}
   21f66:	b088      	sub	sp, #32
   21f68:	af00      	add	r7, sp, #0
   21f6a:	60ba      	str	r2, [r7, #8]
   21f6c:	607b      	str	r3, [r7, #4]
   21f6e:	4603      	mov	r3, r0
   21f70:	73fb      	strb	r3, [r7, #15]
   21f72:	460b      	mov	r3, r1
   21f74:	73bb      	strb	r3, [r7, #14]
  uint8_t *pElem;
  uint8_t *pNext;
  uint16_t totalLen;
  uint16_t newAdvDataLen;
  bool_t  valueSet = FALSE;
   21f76:	2300      	movs	r3, #0
   21f78:	77fb      	strb	r3, [r7, #31]

  /* find ad type in data */
  if ((pElem = DmFindAdType(adType, *pAdvDataLen, pAdvData)) != NULL)
   21f7a:	687b      	ldr	r3, [r7, #4]
   21f7c:	8819      	ldrh	r1, [r3, #0]
   21f7e:	7bfb      	ldrb	r3, [r7, #15]
   21f80:	6aba      	ldr	r2, [r7, #40]	; 0x28
   21f82:	4618      	mov	r0, r3
   21f84:	f001 ff34 	bl	23df0 <DmFindAdType>
   21f88:	61b8      	str	r0, [r7, #24]
   21f8a:	69bb      	ldr	r3, [r7, #24]
   21f8c:	2b00      	cmp	r3, #0
   21f8e:	d03d      	beq.n	2200c <DmAdvSetAdValue+0xa8>
  {
    /* if new length equals existing length */
    if ((len + 1) == pElem[DM_AD_LEN_IDX])
   21f90:	7bbb      	ldrb	r3, [r7, #14]
   21f92:	3301      	adds	r3, #1
   21f94:	69ba      	ldr	r2, [r7, #24]
   21f96:	7812      	ldrb	r2, [r2, #0]
   21f98:	4293      	cmp	r3, r2
   21f9a:	d109      	bne.n	21fb0 <DmAdvSetAdValue+0x4c>
    {
      /* copy new ad value to data in existing location */
      memcpy(&pElem[DM_AD_DATA_IDX], pValue, len);
   21f9c:	69bb      	ldr	r3, [r7, #24]
   21f9e:	3302      	adds	r3, #2
   21fa0:	7bba      	ldrb	r2, [r7, #14]
   21fa2:	68b9      	ldr	r1, [r7, #8]
   21fa4:	4618      	mov	r0, r3
   21fa6:	f7f6 f955 	bl	18254 <memcpy>
      valueSet = TRUE;
   21faa:	2301      	movs	r3, #1
   21fac:	77fb      	strb	r3, [r7, #31]
   21fae:	e02d      	b.n	2200c <DmAdvSetAdValue+0xa8>
    }
    /* else if new value can replace old value and still fit */
    else
    {
      /* calculate the advertising data length if old element was replaced with new */
      newAdvDataLen = *pAdvDataLen + len + 1 - pElem[DM_AD_LEN_IDX];
   21fb0:	687b      	ldr	r3, [r7, #4]
   21fb2:	881a      	ldrh	r2, [r3, #0]
   21fb4:	7bbb      	ldrb	r3, [r7, #14]
   21fb6:	b29b      	uxth	r3, r3
   21fb8:	4413      	add	r3, r2
   21fba:	b29a      	uxth	r2, r3
   21fbc:	69bb      	ldr	r3, [r7, #24]
   21fbe:	781b      	ldrb	r3, [r3, #0]
   21fc0:	b29b      	uxth	r3, r3
   21fc2:	1ad3      	subs	r3, r2, r3
   21fc4:	b29b      	uxth	r3, r3
   21fc6:	3301      	adds	r3, #1
   21fc8:	82fb      	strh	r3, [r7, #22]

      /* if length is ok */
      if (newAdvDataLen <= advDataBufLen)
   21fca:	8afa      	ldrh	r2, [r7, #22]
   21fcc:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
   21fce:	429a      	cmp	r2, r3
   21fd0:	d81c      	bhi.n	2200c <DmAdvSetAdValue+0xa8>
      {
        /* delete item (then we will replace it) */

        /* get the start of element that follows the element to delete */
        totalLen = pElem[DM_AD_LEN_IDX] + 1;
   21fd2:	69bb      	ldr	r3, [r7, #24]
   21fd4:	781b      	ldrb	r3, [r3, #0]
   21fd6:	b29b      	uxth	r3, r3
   21fd8:	3301      	adds	r3, #1
   21fda:	82bb      	strh	r3, [r7, #20]
        pNext = pElem + totalLen;
   21fdc:	8abb      	ldrh	r3, [r7, #20]
   21fde:	69ba      	ldr	r2, [r7, #24]
   21fe0:	4413      	add	r3, r2
   21fe2:	613b      	str	r3, [r7, #16]

        /* move data from start of next element to start of current item;
         * length is equal the data that remains after pNext
         */
        memmove(pElem, pNext, *pAdvDataLen - (uint8_t)(pNext - pAdvData));
   21fe4:	687b      	ldr	r3, [r7, #4]
   21fe6:	881b      	ldrh	r3, [r3, #0]
   21fe8:	4619      	mov	r1, r3
   21fea:	693a      	ldr	r2, [r7, #16]
   21fec:	6abb      	ldr	r3, [r7, #40]	; 0x28
   21fee:	1ad3      	subs	r3, r2, r3
   21ff0:	b2db      	uxtb	r3, r3
   21ff2:	1acb      	subs	r3, r1, r3
   21ff4:	461a      	mov	r2, r3
   21ff6:	6939      	ldr	r1, [r7, #16]
   21ff8:	69b8      	ldr	r0, [r7, #24]
   21ffa:	f00e f80d 	bl	30018 <memmove>

        /* update length */
        *pAdvDataLen = *pAdvDataLen - totalLen;
   21ffe:	687b      	ldr	r3, [r7, #4]
   22000:	881a      	ldrh	r2, [r3, #0]
   22002:	8abb      	ldrh	r3, [r7, #20]
   22004:	1ad3      	subs	r3, r2, r3
   22006:	b29a      	uxth	r2, r3
   22008:	687b      	ldr	r3, [r7, #4]
   2200a:	801a      	strh	r2, [r3, #0]
      }
    }
  }

  /* if value not set */
  if (!valueSet)
   2200c:	7ffb      	ldrb	r3, [r7, #31]
   2200e:	2b00      	cmp	r3, #0
   22010:	d12c      	bne.n	2206c <DmAdvSetAdValue+0x108>
  {
    /* if new value fits */
    if ((*pAdvDataLen + len + 2) <= advDataBufLen)
   22012:	687b      	ldr	r3, [r7, #4]
   22014:	881b      	ldrh	r3, [r3, #0]
   22016:	461a      	mov	r2, r3
   22018:	7bbb      	ldrb	r3, [r7, #14]
   2201a:	4413      	add	r3, r2
   2201c:	1c5a      	adds	r2, r3, #1
   2201e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
   22020:	429a      	cmp	r2, r3
   22022:	da23      	bge.n	2206c <DmAdvSetAdValue+0x108>
    {
      /* construct AD item in advertising data */
      pElem = &pAdvData[*pAdvDataLen];
   22024:	687b      	ldr	r3, [r7, #4]
   22026:	881b      	ldrh	r3, [r3, #0]
   22028:	461a      	mov	r2, r3
   2202a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2202c:	4413      	add	r3, r2
   2202e:	61bb      	str	r3, [r7, #24]
      *pElem++ = len + 1;
   22030:	69bb      	ldr	r3, [r7, #24]
   22032:	1c5a      	adds	r2, r3, #1
   22034:	61ba      	str	r2, [r7, #24]
   22036:	7bba      	ldrb	r2, [r7, #14]
   22038:	3201      	adds	r2, #1
   2203a:	b2d2      	uxtb	r2, r2
   2203c:	701a      	strb	r2, [r3, #0]
      *pElem++ = adType;
   2203e:	69bb      	ldr	r3, [r7, #24]
   22040:	1c5a      	adds	r2, r3, #1
   22042:	61ba      	str	r2, [r7, #24]
   22044:	7bfa      	ldrb	r2, [r7, #15]
   22046:	701a      	strb	r2, [r3, #0]
      memcpy(pElem, pValue, len);
   22048:	7bbb      	ldrb	r3, [r7, #14]
   2204a:	461a      	mov	r2, r3
   2204c:	68b9      	ldr	r1, [r7, #8]
   2204e:	69b8      	ldr	r0, [r7, #24]
   22050:	f7f6 f900 	bl	18254 <memcpy>

      /* update length */
      *pAdvDataLen = *pAdvDataLen + len + 2;
   22054:	687b      	ldr	r3, [r7, #4]
   22056:	881a      	ldrh	r2, [r3, #0]
   22058:	7bbb      	ldrb	r3, [r7, #14]
   2205a:	b29b      	uxth	r3, r3
   2205c:	4413      	add	r3, r2
   2205e:	b29b      	uxth	r3, r3
   22060:	3302      	adds	r3, #2
   22062:	b29a      	uxth	r2, r3
   22064:	687b      	ldr	r3, [r7, #4]
   22066:	801a      	strh	r2, [r3, #0]

      valueSet = TRUE;
   22068:	2301      	movs	r3, #1
   2206a:	77fb      	strb	r3, [r7, #31]
    }
  }

  return valueSet;
   2206c:	7ffb      	ldrb	r3, [r7, #31]
}
   2206e:	4618      	mov	r0, r3
   22070:	3720      	adds	r7, #32
   22072:	46bd      	mov	sp, r7
   22074:	bd80      	pop	{r7, pc}

00022076 <DmAdvSetName>:
 *  \return TRUE if the element was successfully added to the data, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t DmAdvSetName(uint8_t len, uint8_t *pValue, uint16_t *pAdvDataLen, uint8_t *pAdvData,
                    uint16_t advDataBufLen)
{
   22076:	b580      	push	{r7, lr}
   22078:	b088      	sub	sp, #32
   2207a:	af00      	add	r7, sp, #0
   2207c:	60b9      	str	r1, [r7, #8]
   2207e:	607a      	str	r2, [r7, #4]
   22080:	603b      	str	r3, [r7, #0]
   22082:	4603      	mov	r3, r0
   22084:	73fb      	strb	r3, [r7, #15]
  uint8_t *pNext;
  uint16_t totalLen;
  uint8_t adType;

  /* find name in data */
  if ((pElem = DmFindAdType(DM_ADV_TYPE_LOCAL_NAME, *pAdvDataLen, pAdvData)) == NULL)
   22086:	687b      	ldr	r3, [r7, #4]
   22088:	881b      	ldrh	r3, [r3, #0]
   2208a:	683a      	ldr	r2, [r7, #0]
   2208c:	4619      	mov	r1, r3
   2208e:	2009      	movs	r0, #9
   22090:	f001 feae 	bl	23df0 <DmFindAdType>
   22094:	61f8      	str	r0, [r7, #28]
   22096:	69fb      	ldr	r3, [r7, #28]
   22098:	2b00      	cmp	r3, #0
   2209a:	d107      	bne.n	220ac <DmAdvSetName+0x36>
  {
    pElem = DmFindAdType(DM_ADV_TYPE_SHORT_NAME, *pAdvDataLen, pAdvData);
   2209c:	687b      	ldr	r3, [r7, #4]
   2209e:	881b      	ldrh	r3, [r3, #0]
   220a0:	683a      	ldr	r2, [r7, #0]
   220a2:	4619      	mov	r1, r3
   220a4:	2008      	movs	r0, #8
   220a6:	f001 fea3 	bl	23df0 <DmFindAdType>
   220aa:	61f8      	str	r0, [r7, #28]
  }

  /* if found delete it */
  if (pElem != NULL)
   220ac:	69fb      	ldr	r3, [r7, #28]
   220ae:	2b00      	cmp	r3, #0
   220b0:	d01c      	beq.n	220ec <DmAdvSetName+0x76>
  {
    /* get the start of element that follows the element to delete */
    totalLen = pElem[DM_AD_LEN_IDX] + 1;
   220b2:	69fb      	ldr	r3, [r7, #28]
   220b4:	781b      	ldrb	r3, [r3, #0]
   220b6:	b29b      	uxth	r3, r3
   220b8:	3301      	adds	r3, #1
   220ba:	833b      	strh	r3, [r7, #24]
    pNext = pElem + totalLen;
   220bc:	8b3b      	ldrh	r3, [r7, #24]
   220be:	69fa      	ldr	r2, [r7, #28]
   220c0:	4413      	add	r3, r2
   220c2:	617b      	str	r3, [r7, #20]

    /* move data from start of next element to start of current item;
     * length is equal the data that remains after pNext
     */
    memmove(pElem, pNext, *pAdvDataLen - (uint8_t)(pNext - pAdvData));
   220c4:	687b      	ldr	r3, [r7, #4]
   220c6:	881b      	ldrh	r3, [r3, #0]
   220c8:	4619      	mov	r1, r3
   220ca:	697a      	ldr	r2, [r7, #20]
   220cc:	683b      	ldr	r3, [r7, #0]
   220ce:	1ad3      	subs	r3, r2, r3
   220d0:	b2db      	uxtb	r3, r3
   220d2:	1acb      	subs	r3, r1, r3
   220d4:	461a      	mov	r2, r3
   220d6:	6979      	ldr	r1, [r7, #20]
   220d8:	69f8      	ldr	r0, [r7, #28]
   220da:	f00d ff9d 	bl	30018 <memmove>

    /* update length */
    *pAdvDataLen = *pAdvDataLen - totalLen;
   220de:	687b      	ldr	r3, [r7, #4]
   220e0:	881a      	ldrh	r2, [r3, #0]
   220e2:	8b3b      	ldrh	r3, [r7, #24]
   220e4:	1ad3      	subs	r3, r2, r3
   220e6:	b29a      	uxth	r2, r3
   220e8:	687b      	ldr	r3, [r7, #4]
   220ea:	801a      	strh	r2, [r3, #0]
  }

  /* if name will fit */
  if (*pAdvDataLen <= (advDataBufLen - 2))
   220ec:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   220ee:	3b01      	subs	r3, #1
   220f0:	687a      	ldr	r2, [r7, #4]
   220f2:	8812      	ldrh	r2, [r2, #0]
   220f4:	4293      	cmp	r3, r2
   220f6:	dd3a      	ble.n	2216e <DmAdvSetName+0xf8>
  {
    /* if full device name won't fit */
    if ((*pAdvDataLen + len + 2) > advDataBufLen)
   220f8:	687b      	ldr	r3, [r7, #4]
   220fa:	881b      	ldrh	r3, [r3, #0]
   220fc:	461a      	mov	r2, r3
   220fe:	7bfb      	ldrb	r3, [r7, #15]
   22100:	4413      	add	r3, r2
   22102:	1c5a      	adds	r2, r3, #1
   22104:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   22106:	429a      	cmp	r2, r3
   22108:	db0b      	blt.n	22122 <DmAdvSetName+0xac>
    {
      /* adjust length so that it will fit */
      len = (advDataBufLen - 2) - *pAdvDataLen;
   2210a:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   2210c:	b2da      	uxtb	r2, r3
   2210e:	687b      	ldr	r3, [r7, #4]
   22110:	881b      	ldrh	r3, [r3, #0]
   22112:	b2db      	uxtb	r3, r3
   22114:	1ad3      	subs	r3, r2, r3
   22116:	b2db      	uxtb	r3, r3
   22118:	3b02      	subs	r3, #2
   2211a:	73fb      	strb	r3, [r7, #15]

      /* set ad type to shortened local name */
      adType = DM_ADV_TYPE_SHORT_NAME;
   2211c:	2308      	movs	r3, #8
   2211e:	76fb      	strb	r3, [r7, #27]
   22120:	e001      	b.n	22126 <DmAdvSetName+0xb0>
    }
    else
    {
      adType = DM_ADV_TYPE_LOCAL_NAME;
   22122:	2309      	movs	r3, #9
   22124:	76fb      	strb	r3, [r7, #27]
    }

    /* construct AD item in advertising data */
    pElem = &pAdvData[*pAdvDataLen];
   22126:	687b      	ldr	r3, [r7, #4]
   22128:	881b      	ldrh	r3, [r3, #0]
   2212a:	461a      	mov	r2, r3
   2212c:	683b      	ldr	r3, [r7, #0]
   2212e:	4413      	add	r3, r2
   22130:	61fb      	str	r3, [r7, #28]
    *pElem++ = len + 1;
   22132:	69fb      	ldr	r3, [r7, #28]
   22134:	1c5a      	adds	r2, r3, #1
   22136:	61fa      	str	r2, [r7, #28]
   22138:	7bfa      	ldrb	r2, [r7, #15]
   2213a:	3201      	adds	r2, #1
   2213c:	b2d2      	uxtb	r2, r2
   2213e:	701a      	strb	r2, [r3, #0]
    *pElem++ = adType;
   22140:	69fb      	ldr	r3, [r7, #28]
   22142:	1c5a      	adds	r2, r3, #1
   22144:	61fa      	str	r2, [r7, #28]
   22146:	7efa      	ldrb	r2, [r7, #27]
   22148:	701a      	strb	r2, [r3, #0]
    memcpy(pElem, pValue, len);
   2214a:	7bfb      	ldrb	r3, [r7, #15]
   2214c:	461a      	mov	r2, r3
   2214e:	68b9      	ldr	r1, [r7, #8]
   22150:	69f8      	ldr	r0, [r7, #28]
   22152:	f7f6 f87f 	bl	18254 <memcpy>

    /* update length */
    *pAdvDataLen = *pAdvDataLen + len + 2;
   22156:	687b      	ldr	r3, [r7, #4]
   22158:	881a      	ldrh	r2, [r3, #0]
   2215a:	7bfb      	ldrb	r3, [r7, #15]
   2215c:	b29b      	uxth	r3, r3
   2215e:	4413      	add	r3, r2
   22160:	b29b      	uxth	r3, r3
   22162:	3302      	adds	r3, #2
   22164:	b29a      	uxth	r2, r3
   22166:	687b      	ldr	r3, [r7, #4]
   22168:	801a      	strh	r2, [r3, #0]

    return TRUE;
   2216a:	2301      	movs	r3, #1
   2216c:	e000      	b.n	22170 <DmAdvSetName+0xfa>
  }

  return FALSE;
   2216e:	2300      	movs	r3, #0
}
   22170:	4618      	mov	r0, r3
   22172:	3720      	adds	r7, #32
   22174:	46bd      	mov	sp, r7
   22176:	bd80      	pop	{r7, pc}

00022178 <dmAdvConfig>:
 *
 *  \return None.
*/
/*************************************************************************************************/
static void dmAdvConfig(uint8_t advType, uint8_t peerAddrType, uint8_t *pPeerAddr)
{
   22178:	b5b0      	push	{r4, r5, r7, lr}
   2217a:	b086      	sub	sp, #24
   2217c:	af04      	add	r7, sp, #16
   2217e:	4603      	mov	r3, r0
   22180:	603a      	str	r2, [r7, #0]
   22182:	71fb      	strb	r3, [r7, #7]
   22184:	460b      	mov	r3, r1
   22186:	71bb      	strb	r3, [r7, #6]
  /* set advertising parameters */
  HciLeSetAdvParamCmd(dmAdvCb.intervalMin[DM_ADV_HANDLE_DEFAULT], /* advIntervalMin */
   22188:	4b11      	ldr	r3, [pc, #68]	; (221d0 <dmAdvConfig+0x58>)
   2218a:	8a1c      	ldrh	r4, [r3, #16]
   2218c:	4b10      	ldr	r3, [pc, #64]	; (221d0 <dmAdvConfig+0x58>)
   2218e:	8a5d      	ldrh	r5, [r3, #18]
   22190:	4b10      	ldr	r3, [pc, #64]	; (221d4 <dmAdvConfig+0x5c>)
   22192:	7b9b      	ldrb	r3, [r3, #14]
   22194:	4618      	mov	r0, r3
   22196:	f001 fea5 	bl	23ee4 <DmLlAddrType>
   2219a:	4603      	mov	r3, r0
   2219c:	4618      	mov	r0, r3
   2219e:	4b0c      	ldr	r3, [pc, #48]	; (221d0 <dmAdvConfig+0x58>)
   221a0:	7d5b      	ldrb	r3, [r3, #21]
   221a2:	4a0c      	ldr	r2, [pc, #48]	; (221d4 <dmAdvConfig+0x5c>)
   221a4:	7c52      	ldrb	r2, [r2, #17]
   221a6:	79f9      	ldrb	r1, [r7, #7]
   221a8:	9203      	str	r2, [sp, #12]
   221aa:	9302      	str	r3, [sp, #8]
   221ac:	683b      	ldr	r3, [r7, #0]
   221ae:	9301      	str	r3, [sp, #4]
   221b0:	79bb      	ldrb	r3, [r7, #6]
   221b2:	9300      	str	r3, [sp, #0]
   221b4:	4603      	mov	r3, r0
   221b6:	460a      	mov	r2, r1
   221b8:	4629      	mov	r1, r5
   221ba:	4620      	mov	r0, r4
   221bc:	f003 f9df 	bl	2557e <HciLeSetAdvParamCmd>
                      pPeerAddr,                                  /* pPeerAddr */
                      dmAdvCb.channelMap[DM_ADV_HANDLE_DEFAULT],  /* advChanMap */
                      dmCb.advFiltPolicy[DM_ADV_HANDLE_DEFAULT]); /* advFiltPolicy */

  /* store advertising type */
  dmLegAdvCb.advType = advType;
   221c0:	4a05      	ldr	r2, [pc, #20]	; (221d8 <dmAdvConfig+0x60>)
   221c2:	79fb      	ldrb	r3, [r7, #7]
   221c4:	7013      	strb	r3, [r2, #0]
}
   221c6:	bf00      	nop
   221c8:	3708      	adds	r7, #8
   221ca:	46bd      	mov	sp, r7
   221cc:	bdb0      	pop	{r4, r5, r7, pc}
   221ce:	bf00      	nop
   221d0:	100111f4 	.word	0x100111f4
   221d4:	100112ec 	.word	0x100112ec
   221d8:	10003f50 	.word	0x10003f50

000221dc <dmAdvActConfig>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActConfig(dmAdvMsg_t *pMsg)
{
   221dc:	b580      	push	{r7, lr}
   221de:	b082      	sub	sp, #8
   221e0:	af00      	add	r7, sp, #0
   221e2:	6078      	str	r0, [r7, #4]
  DM_TRACE_INFO1("dmAdvActConfig: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   221e4:	4b10      	ldr	r3, [pc, #64]	; (22228 <dmAdvActConfig+0x4c>)
   221e6:	7ddb      	ldrb	r3, [r3, #23]
   221e8:	4619      	mov	r1, r3
   221ea:	4810      	ldr	r0, [pc, #64]	; (2222c <dmAdvActConfig+0x50>)
   221ec:	f00b fbd0 	bl	2d990 <WsfTrace>

  if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_IDLE)
   221f0:	4b0d      	ldr	r3, [pc, #52]	; (22228 <dmAdvActConfig+0x4c>)
   221f2:	7ddb      	ldrb	r3, [r3, #23]
   221f4:	2b00      	cmp	r3, #0
   221f6:	d114      	bne.n	22222 <dmAdvActConfig+0x46>
  {
    /* if doing directed advertising ignore the request */
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   221f8:	4b0b      	ldr	r3, [pc, #44]	; (22228 <dmAdvActConfig+0x4c>)
   221fa:	7d1b      	ldrb	r3, [r3, #20]
   221fc:	2b01      	cmp	r3, #1
   221fe:	d003      	beq.n	22208 <dmAdvActConfig+0x2c>
        (dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT_LO_DUTY))
   22200:	4b09      	ldr	r3, [pc, #36]	; (22228 <dmAdvActConfig+0x4c>)
   22202:	7d1b      	ldrb	r3, [r3, #20]
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   22204:	2b04      	cmp	r3, #4
   22206:	d103      	bne.n	22210 <dmAdvActConfig+0x34>
    {
      DM_TRACE_WARN0("DmAdvConfig during directed advertising!");
   22208:	4809      	ldr	r0, [pc, #36]	; (22230 <dmAdvActConfig+0x54>)
   2220a:	f00b fbc1 	bl	2d990 <WsfTrace>
      return;
   2220e:	e008      	b.n	22222 <dmAdvActConfig+0x46>
    }

    /* set advertising parameters */
    dmAdvConfig(pMsg->apiConfig.advType, pMsg->apiConfig.peerAddrType, pMsg->apiConfig.peerAddr);
   22210:	687b      	ldr	r3, [r7, #4]
   22212:	7958      	ldrb	r0, [r3, #5]
   22214:	687b      	ldr	r3, [r7, #4]
   22216:	7999      	ldrb	r1, [r3, #6]
   22218:	687b      	ldr	r3, [r7, #4]
   2221a:	3307      	adds	r3, #7
   2221c:	461a      	mov	r2, r3
   2221e:	f7ff ffab 	bl	22178 <dmAdvConfig>
  }
}
   22222:	3708      	adds	r7, #8
   22224:	46bd      	mov	sp, r7
   22226:	bd80      	pop	{r7, pc}
   22228:	100111f4 	.word	0x100111f4
   2222c:	0004497c 	.word	0x0004497c
   22230:	00044998 	.word	0x00044998

00022234 <dmAdvActSetData>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActSetData(dmAdvMsg_t *pMsg)
{
   22234:	b580      	push	{r7, lr}
   22236:	b082      	sub	sp, #8
   22238:	af00      	add	r7, sp, #0
   2223a:	6078      	str	r0, [r7, #4]
  WSF_ASSERT(pMsg->apiSetData.len <= HCI_ADV_DATA_LEN);

  DM_TRACE_INFO1("dmAdvActSetData: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   2223c:	4b11      	ldr	r3, [pc, #68]	; (22284 <dmAdvActSetData+0x50>)
   2223e:	7ddb      	ldrb	r3, [r3, #23]
   22240:	4619      	mov	r1, r3
   22242:	4811      	ldr	r0, [pc, #68]	; (22288 <dmAdvActSetData+0x54>)
   22244:	f00b fba4 	bl	2d990 <WsfTrace>

  if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_IDLE)
   22248:	4b0e      	ldr	r3, [pc, #56]	; (22284 <dmAdvActSetData+0x50>)
   2224a:	7ddb      	ldrb	r3, [r3, #23]
   2224c:	2b00      	cmp	r3, #0
   2224e:	d114      	bne.n	2227a <dmAdvActSetData+0x46>
  {
    /* set new data in HCI */
    if (pMsg->apiSetData.location == DM_DATA_LOC_ADV)
   22250:	687b      	ldr	r3, [r7, #4]
   22252:	799b      	ldrb	r3, [r3, #6]
   22254:	2b00      	cmp	r3, #0
   22256:	d108      	bne.n	2226a <dmAdvActSetData+0x36>
    {
      HciLeSetAdvDataCmd(pMsg->apiSetData.len, pMsg->apiSetData.pData);
   22258:	687b      	ldr	r3, [r7, #4]
   2225a:	79da      	ldrb	r2, [r3, #7]
   2225c:	687b      	ldr	r3, [r7, #4]
   2225e:	3308      	adds	r3, #8
   22260:	4619      	mov	r1, r3
   22262:	4610      	mov	r0, r2
   22264:	f003 f95b 	bl	2551e <HciLeSetAdvDataCmd>
    else
    {
      HciLeSetScanRespDataCmd(pMsg->apiSetData.len, pMsg->apiSetData.pData);
    }
  }
}
   22268:	e007      	b.n	2227a <dmAdvActSetData+0x46>
      HciLeSetScanRespDataCmd(pMsg->apiSetData.len, pMsg->apiSetData.pData);
   2226a:	687b      	ldr	r3, [r7, #4]
   2226c:	79da      	ldrb	r2, [r3, #7]
   2226e:	687b      	ldr	r3, [r7, #4]
   22270:	3308      	adds	r3, #8
   22272:	4619      	mov	r1, r3
   22274:	4610      	mov	r0, r2
   22276:	f003 fa7a 	bl	2576e <HciLeSetScanRespDataCmd>
}
   2227a:	bf00      	nop
   2227c:	3708      	adds	r7, #8
   2227e:	46bd      	mov	sp, r7
   22280:	bd80      	pop	{r7, pc}
   22282:	bf00      	nop
   22284:	100111f4 	.word	0x100111f4
   22288:	000449c4 	.word	0x000449c4

0002228c <dmAdvActStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActStart(dmAdvMsg_t *pMsg)
{
   2228c:	b580      	push	{r7, lr}
   2228e:	b082      	sub	sp, #8
   22290:	af00      	add	r7, sp, #0
   22292:	6078      	str	r0, [r7, #4]
  DM_TRACE_INFO1("dmAdvActStart: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   22294:	4b11      	ldr	r3, [pc, #68]	; (222dc <dmAdvActStart+0x50>)
   22296:	7ddb      	ldrb	r3, [r3, #23]
   22298:	4619      	mov	r1, r3
   2229a:	4811      	ldr	r0, [pc, #68]	; (222e0 <dmAdvActStart+0x54>)
   2229c:	f00b fb78 	bl	2d990 <WsfTrace>

   if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_IDLE)
   222a0:	4b0e      	ldr	r3, [pc, #56]	; (222dc <dmAdvActStart+0x50>)
   222a2:	7ddb      	ldrb	r3, [r3, #23]
   222a4:	2b00      	cmp	r3, #0
   222a6:	d115      	bne.n	222d4 <dmAdvActStart+0x48>
  {
    /* if doing directed advertising ignore the request */
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   222a8:	4b0c      	ldr	r3, [pc, #48]	; (222dc <dmAdvActStart+0x50>)
   222aa:	7d1b      	ldrb	r3, [r3, #20]
   222ac:	2b01      	cmp	r3, #1
   222ae:	d003      	beq.n	222b8 <dmAdvActStart+0x2c>
        (dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT_LO_DUTY))
   222b0:	4b0a      	ldr	r3, [pc, #40]	; (222dc <dmAdvActStart+0x50>)
   222b2:	7d1b      	ldrb	r3, [r3, #20]
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   222b4:	2b04      	cmp	r3, #4
   222b6:	d103      	bne.n	222c0 <dmAdvActStart+0x34>
    {
      DM_TRACE_WARN0("dmAdvActStart during directed advertising!");
   222b8:	480a      	ldr	r0, [pc, #40]	; (222e4 <dmAdvActStart+0x58>)
   222ba:	f00b fb69 	bl	2d990 <WsfTrace>
      return;
   222be:	e009      	b.n	222d4 <dmAdvActStart+0x48>
    }

    /* start advertising */
    dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_STARTING;
   222c0:	4b06      	ldr	r3, [pc, #24]	; (222dc <dmAdvActStart+0x50>)
   222c2:	2203      	movs	r2, #3
   222c4:	75da      	strb	r2, [r3, #23]
    dmAdvCb.advDuration[DM_ADV_HANDLE_DEFAULT] = pMsg->apiStart.duration[DM_ADV_HANDLE_DEFAULT];
   222c6:	687b      	ldr	r3, [r7, #4]
   222c8:	88da      	ldrh	r2, [r3, #6]
   222ca:	4b04      	ldr	r3, [pc, #16]	; (222dc <dmAdvActStart+0x50>)
   222cc:	831a      	strh	r2, [r3, #24]
    HciLeSetAdvEnableCmd(TRUE);
   222ce:	2001      	movs	r0, #1
   222d0:	f003 f908 	bl	254e4 <HciLeSetAdvEnableCmd>
  }
}
   222d4:	3708      	adds	r7, #8
   222d6:	46bd      	mov	sp, r7
   222d8:	bd80      	pop	{r7, pc}
   222da:	bf00      	nop
   222dc:	100111f4 	.word	0x100111f4
   222e0:	000449e0 	.word	0x000449e0
   222e4:	000449fc 	.word	0x000449fc

000222e8 <dmAdvActStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActStop(dmAdvMsg_t *pMsg)
{
   222e8:	b580      	push	{r7, lr}
   222ea:	b082      	sub	sp, #8
   222ec:	af00      	add	r7, sp, #0
   222ee:	6078      	str	r0, [r7, #4]
  DM_TRACE_INFO1("dmAdvActStop: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   222f0:	4b0f      	ldr	r3, [pc, #60]	; (22330 <dmAdvActStop+0x48>)
   222f2:	7ddb      	ldrb	r3, [r3, #23]
   222f4:	4619      	mov	r1, r3
   222f6:	480f      	ldr	r0, [pc, #60]	; (22334 <dmAdvActStop+0x4c>)
   222f8:	f00b fb4a 	bl	2d990 <WsfTrace>

  if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING)
   222fc:	4b0c      	ldr	r3, [pc, #48]	; (22330 <dmAdvActStop+0x48>)
   222fe:	7ddb      	ldrb	r3, [r3, #23]
   22300:	2b01      	cmp	r3, #1
   22302:	d111      	bne.n	22328 <dmAdvActStop+0x40>
  {
    /* if doing directed advertising ignore the request */
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   22304:	4b0a      	ldr	r3, [pc, #40]	; (22330 <dmAdvActStop+0x48>)
   22306:	7d1b      	ldrb	r3, [r3, #20]
   22308:	2b01      	cmp	r3, #1
   2230a:	d003      	beq.n	22314 <dmAdvActStop+0x2c>
        (dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT_LO_DUTY))
   2230c:	4b08      	ldr	r3, [pc, #32]	; (22330 <dmAdvActStop+0x48>)
   2230e:	7d1b      	ldrb	r3, [r3, #20]
    if ((dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] == DM_ADV_CONN_DIRECT) ||
   22310:	2b04      	cmp	r3, #4
   22312:	d103      	bne.n	2231c <dmAdvActStop+0x34>
    {
      DM_TRACE_WARN0("DmAdvStop during directed advertising!");
   22314:	4808      	ldr	r0, [pc, #32]	; (22338 <dmAdvActStop+0x50>)
   22316:	f00b fb3b 	bl	2d990 <WsfTrace>
      return;
   2231a:	e005      	b.n	22328 <dmAdvActStop+0x40>
    }

    /* disable advertising */
    dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_STOPPING;
   2231c:	4b04      	ldr	r3, [pc, #16]	; (22330 <dmAdvActStop+0x48>)
   2231e:	2205      	movs	r2, #5
   22320:	75da      	strb	r2, [r3, #23]
    HciLeSetAdvEnableCmd(FALSE);
   22322:	2000      	movs	r0, #0
   22324:	f003 f8de 	bl	254e4 <HciLeSetAdvEnableCmd>
  }
}
   22328:	3708      	adds	r7, #8
   2232a:	46bd      	mov	sp, r7
   2232c:	bd80      	pop	{r7, pc}
   2232e:	bf00      	nop
   22330:	100111f4 	.word	0x100111f4
   22334:	00044a28 	.word	0x00044a28
   22338:	00044a40 	.word	0x00044a40

0002233c <dmAdvActRemoveSet>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActRemoveSet(dmAdvMsg_t *pMsg)
{
   2233c:	b480      	push	{r7}
   2233e:	b083      	sub	sp, #12
   22340:	af00      	add	r7, sp, #0
   22342:	6078      	str	r0, [r7, #4]
  /* empty */
}
   22344:	bf00      	nop
   22346:	370c      	adds	r7, #12
   22348:	46bd      	mov	sp, r7
   2234a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2234e:	4770      	bx	lr

00022350 <dmAdvActClearSets>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActClearSets(dmAdvMsg_t *pMsg)
{
   22350:	b480      	push	{r7}
   22352:	b083      	sub	sp, #12
   22354:	af00      	add	r7, sp, #0
   22356:	6078      	str	r0, [r7, #4]
  /* empty */
}
   22358:	bf00      	nop
   2235a:	370c      	adds	r7, #12
   2235c:	46bd      	mov	sp, r7
   2235e:	f85d 7b04 	ldr.w	r7, [sp], #4
   22362:	4770      	bx	lr

00022364 <dmAdvActSetRandAddr>:
*
*  \return None.
*/
/*************************************************************************************************/
void dmAdvActSetRandAddr(dmAdvMsg_t *pMsg)
{
   22364:	b480      	push	{r7}
   22366:	b083      	sub	sp, #12
   22368:	af00      	add	r7, sp, #0
   2236a:	6078      	str	r0, [r7, #4]
  /* empty */
}
   2236c:	bf00      	nop
   2236e:	370c      	adds	r7, #12
   22370:	46bd      	mov	sp, r7
   22372:	f85d 7b04 	ldr.w	r7, [sp], #4
   22376:	4770      	bx	lr

00022378 <dmAdvActTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvActTimeout(dmAdvMsg_t *pMsg)
{
   22378:	b580      	push	{r7, lr}
   2237a:	b082      	sub	sp, #8
   2237c:	af00      	add	r7, sp, #0
   2237e:	6078      	str	r0, [r7, #4]
  DM_TRACE_INFO0("dmAdvActTimeout!");
   22380:	4808      	ldr	r0, [pc, #32]	; (223a4 <dmAdvActTimeout+0x2c>)
   22382:	f00b fb05 	bl	2d990 <WsfTrace>

  if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING)
   22386:	4b08      	ldr	r3, [pc, #32]	; (223a8 <dmAdvActTimeout+0x30>)
   22388:	7ddb      	ldrb	r3, [r3, #23]
   2238a:	2b01      	cmp	r3, #1
   2238c:	d105      	bne.n	2239a <dmAdvActTimeout+0x22>
  {
    /* disable advertising */
    dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_STOPPING;
   2238e:	4b06      	ldr	r3, [pc, #24]	; (223a8 <dmAdvActTimeout+0x30>)
   22390:	2205      	movs	r2, #5
   22392:	75da      	strb	r2, [r3, #23]
    HciLeSetAdvEnableCmd(FALSE);
   22394:	2000      	movs	r0, #0
   22396:	f003 f8a5 	bl	254e4 <HciLeSetAdvEnableCmd>
  }
}
   2239a:	bf00      	nop
   2239c:	3708      	adds	r7, #8
   2239e:	46bd      	mov	sp, r7
   223a0:	bd80      	pop	{r7, pc}
   223a2:	bf00      	nop
   223a4:	00044a68 	.word	0x00044a68
   223a8:	100111f4 	.word	0x100111f4

000223ac <dmAdvReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvReset(void)
{
   223ac:	b580      	push	{r7, lr}
   223ae:	b082      	sub	sp, #8
   223b0:	af00      	add	r7, sp, #0
  wsfMsgHdr_t advStop;

  /* if stopping undirected advertisement or advertising but not high duty cycle directed adv */
  if ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STOPPING)     ||
   223b2:	4b0f      	ldr	r3, [pc, #60]	; (223f0 <dmAdvReset+0x44>)
   223b4:	7ddb      	ldrb	r3, [r3, #23]
   223b6:	2b05      	cmp	r3, #5
   223b8:	d007      	beq.n	223ca <dmAdvReset+0x1e>
      ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING) &&
   223ba:	4b0d      	ldr	r3, [pc, #52]	; (223f0 <dmAdvReset+0x44>)
   223bc:	7ddb      	ldrb	r3, [r3, #23]
  if ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STOPPING)     ||
   223be:	2b01      	cmp	r3, #1
   223c0:	d10f      	bne.n	223e2 <dmAdvReset+0x36>
       (dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] != DM_ADV_CONN_DIRECT)))
   223c2:	4b0b      	ldr	r3, [pc, #44]	; (223f0 <dmAdvReset+0x44>)
   223c4:	7d1b      	ldrb	r3, [r3, #20]
      ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING) &&
   223c6:	2b01      	cmp	r3, #1
   223c8:	d00b      	beq.n	223e2 <dmAdvReset+0x36>
  {
    /* stop advertising timer */
    WsfTimerStop(&dmAdvCb.advTimer);
   223ca:	4809      	ldr	r0, [pc, #36]	; (223f0 <dmAdvReset+0x44>)
   223cc:	f00b fa34 	bl	2d838 <WsfTimerStop>

    /* generate advertising stop event */
    advStop.status = HCI_SUCCESS;
   223d0:	2300      	movs	r3, #0
   223d2:	71fb      	strb	r3, [r7, #7]
    advStop.event = DM_ADV_STOP_IND;
   223d4:	2322      	movs	r3, #34	; 0x22
   223d6:	71bb      	strb	r3, [r7, #6]

    /* call callback */
    (*dmCb.cback)((dmEvt_t *) &advStop);
   223d8:	4b06      	ldr	r3, [pc, #24]	; (223f4 <dmAdvReset+0x48>)
   223da:	689b      	ldr	r3, [r3, #8]
   223dc:	1d3a      	adds	r2, r7, #4
   223de:	4610      	mov	r0, r2
   223e0:	4798      	blx	r3
  }

  /* reset legacy adv module */
  dmAdvInit();
   223e2:	f7ff fc61 	bl	21ca8 <dmAdvInit>
}
   223e6:	bf00      	nop
   223e8:	3708      	adds	r7, #8
   223ea:	46bd      	mov	sp, r7
   223ec:	bd80      	pop	{r7, pc}
   223ee:	bf00      	nop
   223f0:	100111f4 	.word	0x100111f4
   223f4:	100112ec 	.word	0x100112ec

000223f8 <dmAdvHciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvHciHandler(hciEvt_t *pEvent)
{
   223f8:	b580      	push	{r7, lr}
   223fa:	b084      	sub	sp, #16
   223fc:	af00      	add	r7, sp, #0
   223fe:	6078      	str	r0, [r7, #4]
  if (pEvent->hdr.event == HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT)
   22400:	687b      	ldr	r3, [r7, #4]
   22402:	789b      	ldrb	r3, [r3, #2]
   22404:	2b35      	cmp	r3, #53	; 0x35
   22406:	d177      	bne.n	224f8 <dmAdvHciHandler+0x100>
  {
    uint8_t cbackEvent = 0;
   22408:	2300      	movs	r3, #0
   2240a:	73fb      	strb	r3, [r7, #15]

    DM_TRACE_INFO1("HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   2240c:	4b3c      	ldr	r3, [pc, #240]	; (22500 <dmAdvHciHandler+0x108>)
   2240e:	7ddb      	ldrb	r3, [r3, #23]
   22410:	4619      	mov	r1, r3
   22412:	483c      	ldr	r0, [pc, #240]	; (22504 <dmAdvHciHandler+0x10c>)
   22414:	f00b fabc 	bl	2d990 <WsfTrace>

    switch (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT])
   22418:	4b39      	ldr	r3, [pc, #228]	; (22500 <dmAdvHciHandler+0x108>)
   2241a:	7ddb      	ldrb	r3, [r3, #23]
   2241c:	2b03      	cmp	r3, #3
   2241e:	dc02      	bgt.n	22426 <dmAdvHciHandler+0x2e>
   22420:	2b02      	cmp	r3, #2
   22422:	da04      	bge.n	2242e <dmAdvHciHandler+0x36>
      }
      break;

    default:
      /* ignore the event */
      break;
   22424:	e055      	b.n	224d2 <dmAdvHciHandler+0xda>
   22426:	3b04      	subs	r3, #4
    switch (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT])
   22428:	2b01      	cmp	r3, #1
   2242a:	d852      	bhi.n	224d2 <dmAdvHciHandler+0xda>
   2242c:	e02c      	b.n	22488 <dmAdvHciHandler+0x90>
      if (pEvent->hdr.status == HCI_SUCCESS)
   2242e:	687b      	ldr	r3, [r7, #4]
   22430:	78db      	ldrb	r3, [r3, #3]
   22432:	2b00      	cmp	r3, #0
   22434:	d124      	bne.n	22480 <dmAdvHciHandler+0x88>
        if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STARTING)
   22436:	4b32      	ldr	r3, [pc, #200]	; (22500 <dmAdvHciHandler+0x108>)
   22438:	7ddb      	ldrb	r3, [r3, #23]
   2243a:	2b03      	cmp	r3, #3
   2243c:	d112      	bne.n	22464 <dmAdvHciHandler+0x6c>
          if (dmAdvCb.advDuration[DM_ADV_HANDLE_DEFAULT] > 0)
   2243e:	4b30      	ldr	r3, [pc, #192]	; (22500 <dmAdvHciHandler+0x108>)
   22440:	8b1b      	ldrh	r3, [r3, #24]
   22442:	2b00      	cmp	r3, #0
   22444:	d008      	beq.n	22458 <dmAdvHciHandler+0x60>
            dmAdvCb.advTimer.msg.event = DM_ADV_MSG_TIMEOUT;
   22446:	4b2e      	ldr	r3, [pc, #184]	; (22500 <dmAdvHciHandler+0x108>)
   22448:	2207      	movs	r2, #7
   2244a:	729a      	strb	r2, [r3, #10]
            WsfTimerStartMs(&dmAdvCb.advTimer, dmAdvCb.advDuration[DM_ADV_HANDLE_DEFAULT]);
   2244c:	4b2c      	ldr	r3, [pc, #176]	; (22500 <dmAdvHciHandler+0x108>)
   2244e:	8b1b      	ldrh	r3, [r3, #24]
   22450:	4619      	mov	r1, r3
   22452:	482b      	ldr	r0, [pc, #172]	; (22500 <dmAdvHciHandler+0x108>)
   22454:	f00b f9dc 	bl	2d810 <WsfTimerStartMs>
          if (dmLegAdvCb.advType != DM_ADV_CONN_DIRECT_LO_DUTY)
   22458:	4b2b      	ldr	r3, [pc, #172]	; (22508 <dmAdvHciHandler+0x110>)
   2245a:	781b      	ldrb	r3, [r3, #0]
   2245c:	2b04      	cmp	r3, #4
   2245e:	d001      	beq.n	22464 <dmAdvHciHandler+0x6c>
            cbackEvent = DM_ADV_START_IND;
   22460:	2321      	movs	r3, #33	; 0x21
   22462:	73fb      	strb	r3, [r7, #15]
        dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_START, DM_ADV_START_IND, 0, 0);
   22464:	2300      	movs	r3, #0
   22466:	2200      	movs	r2, #0
   22468:	2121      	movs	r1, #33	; 0x21
   2246a:	2014      	movs	r0, #20
   2246c:	f001 fbdc 	bl	23c28 <dmDevPassEvtToDevPriv>
        dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] = dmLegAdvCb.advType;
   22470:	4b25      	ldr	r3, [pc, #148]	; (22508 <dmAdvHciHandler+0x110>)
   22472:	781a      	ldrb	r2, [r3, #0]
   22474:	4b22      	ldr	r3, [pc, #136]	; (22500 <dmAdvHciHandler+0x108>)
   22476:	751a      	strb	r2, [r3, #20]
        dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_ADVERTISING;
   22478:	4b21      	ldr	r3, [pc, #132]	; (22500 <dmAdvHciHandler+0x108>)
   2247a:	2201      	movs	r2, #1
   2247c:	75da      	strb	r2, [r3, #23]
      break;
   2247e:	e029      	b.n	224d4 <dmAdvHciHandler+0xdc>
        dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_IDLE;
   22480:	4b1f      	ldr	r3, [pc, #124]	; (22500 <dmAdvHciHandler+0x108>)
   22482:	2200      	movs	r2, #0
   22484:	75da      	strb	r2, [r3, #23]
      break;
   22486:	e025      	b.n	224d4 <dmAdvHciHandler+0xdc>
      if (pEvent->hdr.status == HCI_SUCCESS)
   22488:	687b      	ldr	r3, [r7, #4]
   2248a:	78db      	ldrb	r3, [r3, #3]
   2248c:	2b00      	cmp	r3, #0
   2248e:	d11c      	bne.n	224ca <dmAdvHciHandler+0xd2>
        if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STOPPING)
   22490:	4b1b      	ldr	r3, [pc, #108]	; (22500 <dmAdvHciHandler+0x108>)
   22492:	7ddb      	ldrb	r3, [r3, #23]
   22494:	2b05      	cmp	r3, #5
   22496:	d10b      	bne.n	224b0 <dmAdvHciHandler+0xb8>
          WsfTimerStop(&dmAdvCb.advTimer);
   22498:	4819      	ldr	r0, [pc, #100]	; (22500 <dmAdvHciHandler+0x108>)
   2249a:	f00b f9cd 	bl	2d838 <WsfTimerStop>
          if (dmLegAdvCb.advType == DM_ADV_CONN_DIRECT_LO_DUTY)
   2249e:	4b1a      	ldr	r3, [pc, #104]	; (22508 <dmAdvHciHandler+0x110>)
   224a0:	781b      	ldrb	r3, [r3, #0]
   224a2:	2b04      	cmp	r3, #4
   224a4:	d102      	bne.n	224ac <dmAdvHciHandler+0xb4>
            cbackEvent = HCI_LE_ENHANCED_CONN_CMPL_CBACK_EVT;
   224a6:	2302      	movs	r3, #2
   224a8:	73fb      	strb	r3, [r7, #15]
   224aa:	e001      	b.n	224b0 <dmAdvHciHandler+0xb8>
            cbackEvent = DM_ADV_STOP_IND;
   224ac:	2322      	movs	r3, #34	; 0x22
   224ae:	73fb      	strb	r3, [r7, #15]
        dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_STOP, DM_ADV_STOP_IND, 0, 0);
   224b0:	2300      	movs	r3, #0
   224b2:	2200      	movs	r2, #0
   224b4:	2122      	movs	r1, #34	; 0x22
   224b6:	2015      	movs	r0, #21
   224b8:	f001 fbb6 	bl	23c28 <dmDevPassEvtToDevPriv>
        dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] = DM_ADV_NONE;
   224bc:	4b10      	ldr	r3, [pc, #64]	; (22500 <dmAdvHciHandler+0x108>)
   224be:	22ff      	movs	r2, #255	; 0xff
   224c0:	751a      	strb	r2, [r3, #20]
        dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_IDLE;
   224c2:	4b0f      	ldr	r3, [pc, #60]	; (22500 <dmAdvHciHandler+0x108>)
   224c4:	2200      	movs	r2, #0
   224c6:	75da      	strb	r2, [r3, #23]
      break;
   224c8:	e004      	b.n	224d4 <dmAdvHciHandler+0xdc>
        dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_ADVERTISING;
   224ca:	4b0d      	ldr	r3, [pc, #52]	; (22500 <dmAdvHciHandler+0x108>)
   224cc:	2201      	movs	r2, #1
   224ce:	75da      	strb	r2, [r3, #23]
      break;
   224d0:	e000      	b.n	224d4 <dmAdvHciHandler+0xdc>
      break;
   224d2:	bf00      	nop
    }

    /* if DM conn notify needed */
    if (cbackEvent == HCI_LE_ENHANCED_CONN_CMPL_CBACK_EVT)
   224d4:	7bfb      	ldrb	r3, [r7, #15]
   224d6:	2b02      	cmp	r3, #2
   224d8:	d104      	bne.n	224e4 <dmAdvHciHandler+0xec>
    {
      dmAdvGenConnCmpl(DM_ADV_HANDLE_DEFAULT, HCI_ERR_ADV_TIMEOUT);
   224da:	213c      	movs	r1, #60	; 0x3c
   224dc:	2000      	movs	r0, #0
   224de:	f7ff fc03 	bl	21ce8 <dmAdvGenConnCmpl>
    {
      pEvent->hdr.event = cbackEvent;
      (*dmCb.cback)((dmEvt_t *) pEvent);
    }
  }
}
   224e2:	e009      	b.n	224f8 <dmAdvHciHandler+0x100>
    else if (cbackEvent)
   224e4:	7bfb      	ldrb	r3, [r7, #15]
   224e6:	2b00      	cmp	r3, #0
   224e8:	d006      	beq.n	224f8 <dmAdvHciHandler+0x100>
      pEvent->hdr.event = cbackEvent;
   224ea:	687b      	ldr	r3, [r7, #4]
   224ec:	7bfa      	ldrb	r2, [r7, #15]
   224ee:	709a      	strb	r2, [r3, #2]
      (*dmCb.cback)((dmEvt_t *) pEvent);
   224f0:	4b06      	ldr	r3, [pc, #24]	; (2250c <dmAdvHciHandler+0x114>)
   224f2:	689b      	ldr	r3, [r3, #8]
   224f4:	6878      	ldr	r0, [r7, #4]
   224f6:	4798      	blx	r3
}
   224f8:	bf00      	nop
   224fa:	3710      	adds	r7, #16
   224fc:	46bd      	mov	sp, r7
   224fe:	bd80      	pop	{r7, pc}
   22500:	100111f4 	.word	0x100111f4
   22504:	00044a7c 	.word	0x00044a7c
   22508:	10003f50 	.word	0x10003f50
   2250c:	100112ec 	.word	0x100112ec

00022510 <dmAdvMsgHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvMsgHandler(wsfMsgHdr_t *pMsg)
{
   22510:	b580      	push	{r7, lr}
   22512:	b082      	sub	sp, #8
   22514:	af00      	add	r7, sp, #0
   22516:	6078      	str	r0, [r7, #4]
  /* execute action function */
  (*dmAdvAct[DM_MSG_MASK(pMsg->event)])((dmAdvMsg_t *)pMsg);
   22518:	687b      	ldr	r3, [r7, #4]
   2251a:	789b      	ldrb	r3, [r3, #2]
   2251c:	f003 030f 	and.w	r3, r3, #15
   22520:	4a04      	ldr	r2, [pc, #16]	; (22534 <dmAdvMsgHandler+0x24>)
   22522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22526:	6878      	ldr	r0, [r7, #4]
   22528:	4798      	blx	r3
}
   2252a:	bf00      	nop
   2252c:	3708      	adds	r7, #8
   2252e:	46bd      	mov	sp, r7
   22530:	bd80      	pop	{r7, pc}
   22532:	bf00      	nop
   22534:	00045bd4 	.word	0x00045bd4

00022538 <dmAdvStartDirected>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvStartDirected(uint8_t advType, uint16_t duration, uint8_t addrType, uint8_t *pAddr)
{
   22538:	b580      	push	{r7, lr}
   2253a:	b082      	sub	sp, #8
   2253c:	af00      	add	r7, sp, #0
   2253e:	603b      	str	r3, [r7, #0]
   22540:	4603      	mov	r3, r0
   22542:	71fb      	strb	r3, [r7, #7]
   22544:	460b      	mov	r3, r1
   22546:	80bb      	strh	r3, [r7, #4]
   22548:	4613      	mov	r3, r2
   2254a:	71bb      	strb	r3, [r7, #6]
  DM_TRACE_INFO1("dmAdvStartDirected: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   2254c:	4b11      	ldr	r3, [pc, #68]	; (22594 <dmAdvStartDirected+0x5c>)
   2254e:	7ddb      	ldrb	r3, [r3, #23]
   22550:	4619      	mov	r1, r3
   22552:	4811      	ldr	r0, [pc, #68]	; (22598 <dmAdvStartDirected+0x60>)
   22554:	f00b fa1c 	bl	2d990 <WsfTrace>

  /* if not advertising */
  if (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_IDLE)
   22558:	4b0e      	ldr	r3, [pc, #56]	; (22594 <dmAdvStartDirected+0x5c>)
   2255a:	7ddb      	ldrb	r3, [r3, #23]
   2255c:	2b00      	cmp	r3, #0
   2255e:	d115      	bne.n	2258c <dmAdvStartDirected+0x54>
  {
    /* start advertising */
    HciLeSetAdvEnableCmd(TRUE);
   22560:	2001      	movs	r0, #1
   22562:	f002 ffbf 	bl	254e4 <HciLeSetAdvEnableCmd>

    /* store advertising info */
    dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = (advType == DM_ADV_CONN_DIRECT) ? \
   22566:	79fb      	ldrb	r3, [r7, #7]
   22568:	2b01      	cmp	r3, #1
   2256a:	d101      	bne.n	22570 <dmAdvStartDirected+0x38>
   2256c:	2202      	movs	r2, #2
   2256e:	e000      	b.n	22572 <dmAdvStartDirected+0x3a>
   22570:	2203      	movs	r2, #3
   22572:	4b08      	ldr	r3, [pc, #32]	; (22594 <dmAdvStartDirected+0x5c>)
   22574:	75da      	strb	r2, [r3, #23]
                                              DM_ADV_STATE_STARTING_DIRECTED : DM_ADV_STATE_STARTING;

    dmAdvCb.advDuration[DM_ADV_HANDLE_DEFAULT] = duration;
   22576:	4a07      	ldr	r2, [pc, #28]	; (22594 <dmAdvStartDirected+0x5c>)
   22578:	88bb      	ldrh	r3, [r7, #4]
   2257a:	8313      	strh	r3, [r2, #24]
    BdaCpy(dmAdvCb.peerAddr[DM_ADV_HANDLE_DEFAULT], pAddr);
   2257c:	6839      	ldr	r1, [r7, #0]
   2257e:	4807      	ldr	r0, [pc, #28]	; (2259c <dmAdvStartDirected+0x64>)
   22580:	f7ff fb01 	bl	21b86 <BdaCpy>
    dmAdvCb.peerAddrType[DM_ADV_HANDLE_DEFAULT] = addrType;
   22584:	4a03      	ldr	r2, [pc, #12]	; (22594 <dmAdvStartDirected+0x5c>)
   22586:	79bb      	ldrb	r3, [r7, #6]
   22588:	f882 3021 	strb.w	r3, [r2, #33]	; 0x21
  }
}
   2258c:	bf00      	nop
   2258e:	3708      	adds	r7, #8
   22590:	46bd      	mov	sp, r7
   22592:	bd80      	pop	{r7, pc}
   22594:	100111f4 	.word	0x100111f4
   22598:	00044aac 	.word	0x00044aac
   2259c:	1001120f 	.word	0x1001120f

000225a0 <dmAdvStopDirected>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvStopDirected(void)
{
   225a0:	b580      	push	{r7, lr}
   225a2:	af00      	add	r7, sp, #0
  DM_TRACE_INFO1("dmAdvStopDirected: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   225a4:	4b0f      	ldr	r3, [pc, #60]	; (225e4 <dmAdvStopDirected+0x44>)
   225a6:	7ddb      	ldrb	r3, [r3, #23]
   225a8:	4619      	mov	r1, r3
   225aa:	480f      	ldr	r0, [pc, #60]	; (225e8 <dmAdvStopDirected+0x48>)
   225ac:	f00b f9f0 	bl	2d990 <WsfTrace>

  /* if advertising or starting advertising */
  if ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING) ||
   225b0:	4b0c      	ldr	r3, [pc, #48]	; (225e4 <dmAdvStopDirected+0x44>)
   225b2:	7ddb      	ldrb	r3, [r3, #23]
   225b4:	2b01      	cmp	r3, #1
   225b6:	d007      	beq.n	225c8 <dmAdvStopDirected+0x28>
      (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STARTING)    ||
   225b8:	4b0a      	ldr	r3, [pc, #40]	; (225e4 <dmAdvStopDirected+0x44>)
   225ba:	7ddb      	ldrb	r3, [r3, #23]
  if ((dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_ADVERTISING) ||
   225bc:	2b03      	cmp	r3, #3
   225be:	d003      	beq.n	225c8 <dmAdvStopDirected+0x28>
      (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STARTING_DIRECTED))
   225c0:	4b08      	ldr	r3, [pc, #32]	; (225e4 <dmAdvStopDirected+0x44>)
   225c2:	7ddb      	ldrb	r3, [r3, #23]
      (dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] == DM_ADV_STATE_STARTING)    ||
   225c4:	2b02      	cmp	r3, #2
   225c6:	d10b      	bne.n	225e0 <dmAdvStopDirected+0x40>
  {
    /* disable advertising */
    dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = (dmLegAdvCb.advType == DM_ADV_CONN_DIRECT) ? \
   225c8:	4b08      	ldr	r3, [pc, #32]	; (225ec <dmAdvStopDirected+0x4c>)
   225ca:	781b      	ldrb	r3, [r3, #0]
   225cc:	2b01      	cmp	r3, #1
   225ce:	d101      	bne.n	225d4 <dmAdvStopDirected+0x34>
   225d0:	2204      	movs	r2, #4
   225d2:	e000      	b.n	225d6 <dmAdvStopDirected+0x36>
   225d4:	2205      	movs	r2, #5
   225d6:	4b03      	ldr	r3, [pc, #12]	; (225e4 <dmAdvStopDirected+0x44>)
   225d8:	75da      	strb	r2, [r3, #23]
                                              DM_ADV_STATE_STOPPING_DIRECTED : DM_ADV_STATE_STOPPING;
    HciLeSetAdvEnableCmd(FALSE);
   225da:	2000      	movs	r0, #0
   225dc:	f002 ff82 	bl	254e4 <HciLeSetAdvEnableCmd>
  }
}
   225e0:	bf00      	nop
   225e2:	bd80      	pop	{r7, pc}
   225e4:	100111f4 	.word	0x100111f4
   225e8:	00044acc 	.word	0x00044acc
   225ec:	10003f50 	.word	0x10003f50

000225f0 <dmAdvConnected>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvConnected(void)
{
   225f0:	b580      	push	{r7, lr}
   225f2:	af00      	add	r7, sp, #0
  DM_TRACE_INFO1("dmAdvConnected: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   225f4:	4b0b      	ldr	r3, [pc, #44]	; (22624 <dmAdvConnected+0x34>)
   225f6:	7ddb      	ldrb	r3, [r3, #23]
   225f8:	4619      	mov	r1, r3
   225fa:	480b      	ldr	r0, [pc, #44]	; (22628 <dmAdvConnected+0x38>)
   225fc:	f00b f9c8 	bl	2d990 <WsfTrace>

  WsfTimerStop(&dmAdvCb.advTimer);
   22600:	4808      	ldr	r0, [pc, #32]	; (22624 <dmAdvConnected+0x34>)
   22602:	f00b f919 	bl	2d838 <WsfTimerStop>

  /* pass advertising stop event to dev priv */
  dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_STOP, DM_ADV_STOP_IND, 0, 0);
   22606:	2300      	movs	r3, #0
   22608:	2200      	movs	r2, #0
   2260a:	2122      	movs	r1, #34	; 0x22
   2260c:	2015      	movs	r0, #21
   2260e:	f001 fb0b 	bl	23c28 <dmDevPassEvtToDevPriv>

  dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] = DM_ADV_NONE;
   22612:	4b04      	ldr	r3, [pc, #16]	; (22624 <dmAdvConnected+0x34>)
   22614:	22ff      	movs	r2, #255	; 0xff
   22616:	751a      	strb	r2, [r3, #20]
  dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_IDLE;
   22618:	4b02      	ldr	r3, [pc, #8]	; (22624 <dmAdvConnected+0x34>)
   2261a:	2200      	movs	r2, #0
   2261c:	75da      	strb	r2, [r3, #23]
}
   2261e:	bf00      	nop
   22620:	bd80      	pop	{r7, pc}
   22622:	bf00      	nop
   22624:	100111f4 	.word	0x100111f4
   22628:	00044aec 	.word	0x00044aec

0002262c <dmAdvConnectFailed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmAdvConnectFailed(void)
{
   2262c:	b580      	push	{r7, lr}
   2262e:	af00      	add	r7, sp, #0
  DM_TRACE_INFO1("dmAdvConnectFailed: state: %d", dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT]);
   22630:	4b0b      	ldr	r3, [pc, #44]	; (22660 <dmAdvConnectFailed+0x34>)
   22632:	7ddb      	ldrb	r3, [r3, #23]
   22634:	4619      	mov	r1, r3
   22636:	480b      	ldr	r0, [pc, #44]	; (22664 <dmAdvConnectFailed+0x38>)
   22638:	f00b f9aa 	bl	2d990 <WsfTrace>

  WsfTimerStop(&dmAdvCb.advTimer);
   2263c:	4808      	ldr	r0, [pc, #32]	; (22660 <dmAdvConnectFailed+0x34>)
   2263e:	f00b f8fb 	bl	2d838 <WsfTimerStop>

  /* pass advertising stop event to dev priv */
  dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_STOP, DM_ADV_STOP_IND, 0, 0);
   22642:	2300      	movs	r3, #0
   22644:	2200      	movs	r2, #0
   22646:	2122      	movs	r1, #34	; 0x22
   22648:	2015      	movs	r0, #21
   2264a:	f001 faed 	bl	23c28 <dmDevPassEvtToDevPriv>

  dmAdvCb.advType[DM_ADV_HANDLE_DEFAULT] = DM_ADV_NONE;
   2264e:	4b04      	ldr	r3, [pc, #16]	; (22660 <dmAdvConnectFailed+0x34>)
   22650:	22ff      	movs	r2, #255	; 0xff
   22652:	751a      	strb	r2, [r3, #20]
  dmAdvCb.advState[DM_ADV_HANDLE_DEFAULT] = DM_ADV_STATE_IDLE;
   22654:	4b02      	ldr	r3, [pc, #8]	; (22660 <dmAdvConnectFailed+0x34>)
   22656:	2200      	movs	r2, #0
   22658:	75da      	strb	r2, [r3, #23]
}
   2265a:	bf00      	nop
   2265c:	bd80      	pop	{r7, pc}
   2265e:	bf00      	nop
   22660:	100111f4 	.word	0x100111f4
   22664:	00044b08 	.word	0x00044b08

00022668 <DmAdvInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmAdvInit(void)
{
   22668:	b580      	push	{r7, lr}
   2266a:	af00      	add	r7, sp, #0
  WsfTaskLock();
   2266c:	f00a fdca 	bl	2d204 <WsfTaskLock>

  /* set function interface table */
  dmFcnIfTbl[DM_ID_ADV] = (dmFcnIf_t *) &dmAdvFcnIf;
   22670:	4b07      	ldr	r3, [pc, #28]	; (22690 <DmAdvInit+0x28>)
   22672:	4a08      	ldr	r2, [pc, #32]	; (22694 <DmAdvInit+0x2c>)
   22674:	601a      	str	r2, [r3, #0]

  /* initialize legacy adv module */
  dmAdvInit();
   22676:	f7ff fb17 	bl	21ca8 <dmAdvInit>

  /* clear set advertising set random address callback */
  dmDevCb.advSetRandAddrCback = NULL;
   2267a:	4b07      	ldr	r3, [pc, #28]	; (22698 <DmAdvInit+0x30>)
   2267c:	2200      	movs	r2, #0
   2267e:	601a      	str	r2, [r3, #0]

  /* initialize HCI VS module */
  HciVsInit(0);
   22680:	2000      	movs	r0, #0
   22682:	f007 f8d2 	bl	2982a <HciVsInit>

  WsfTaskUnlock();
   22686:	f00a fdc3 	bl	2d210 <WsfTaskUnlock>
}
   2268a:	bf00      	nop
   2268c:	bd80      	pop	{r7, pc}
   2268e:	bf00      	nop
   22690:	10002b90 	.word	0x10002b90
   22694:	00045bf4 	.word	0x00045bf4
   22698:	100112e8 	.word	0x100112e8

0002269c <dmConnCmplStates>:
 *
 *  \return Pointer to CCB or NULL if failure.
 */
/*************************************************************************************************/
static dmConnCcb_t *dmConnCmplStates(void)
{
   2269c:	b580      	push	{r7, lr}
   2269e:	b082      	sub	sp, #8
   226a0:	af00      	add	r7, sp, #0
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   226a2:	4b16      	ldr	r3, [pc, #88]	; (226fc <dmConnCmplStates+0x60>)
   226a4:	607b      	str	r3, [r7, #4]
  uint8_t       i;

  /* if there's a ccb in accepting state */
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   226a6:	2303      	movs	r3, #3
   226a8:	70fb      	strb	r3, [r7, #3]
   226aa:	e01f      	b.n	226ec <dmConnCmplStates+0x50>
  {
    /* look for connection in accepting state or disconnecting state, cancelled connection */
    if (pCcb->inUse &&
   226ac:	687b      	ldr	r3, [r7, #4]
   226ae:	7d9b      	ldrb	r3, [r3, #22]
   226b0:	2b00      	cmp	r3, #0
   226b2:	d015      	beq.n	226e0 <dmConnCmplStates+0x44>
        ((pCcb->state == DM_CONN_SM_ST_ACCEPTING) ||
   226b4:	687b      	ldr	r3, [r7, #4]
   226b6:	7d5b      	ldrb	r3, [r3, #21]
    if (pCcb->inUse &&
   226b8:	2b02      	cmp	r3, #2
   226ba:	d009      	beq.n	226d0 <dmConnCmplStates+0x34>
         ((pCcb->state == DM_CONN_SM_ST_DISCONNECTING) && (pCcb->handle == DM_CONN_HCI_HANDLE_NONE))))
   226bc:	687b      	ldr	r3, [r7, #4]
   226be:	7d5b      	ldrb	r3, [r3, #21]
        ((pCcb->state == DM_CONN_SM_ST_ACCEPTING) ||
   226c0:	2b04      	cmp	r3, #4
   226c2:	d10d      	bne.n	226e0 <dmConnCmplStates+0x44>
         ((pCcb->state == DM_CONN_SM_ST_DISCONNECTING) && (pCcb->handle == DM_CONN_HCI_HANDLE_NONE))))
   226c4:	687b      	ldr	r3, [r7, #4]
   226c6:	899b      	ldrh	r3, [r3, #12]
   226c8:	f64f 72ff 	movw	r2, #65535	; 0xffff
   226cc:	4293      	cmp	r3, r2
   226ce:	d107      	bne.n	226e0 <dmConnCmplStates+0x44>
    {
      DM_TRACE_INFO1("dmConnCmplStates %d", pCcb->connId);
   226d0:	687b      	ldr	r3, [r7, #4]
   226d2:	7c1b      	ldrb	r3, [r3, #16]
   226d4:	4619      	mov	r1, r3
   226d6:	480a      	ldr	r0, [pc, #40]	; (22700 <dmConnCmplStates+0x64>)
   226d8:	f00b f95a 	bl	2d990 <WsfTrace>
      return pCcb;
   226dc:	687b      	ldr	r3, [r7, #4]
   226de:	e009      	b.n	226f4 <dmConnCmplStates+0x58>
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   226e0:	78fb      	ldrb	r3, [r7, #3]
   226e2:	3b01      	subs	r3, #1
   226e4:	70fb      	strb	r3, [r7, #3]
   226e6:	687b      	ldr	r3, [r7, #4]
   226e8:	3330      	adds	r3, #48	; 0x30
   226ea:	607b      	str	r3, [r7, #4]
   226ec:	78fb      	ldrb	r3, [r7, #3]
   226ee:	2b00      	cmp	r3, #0
   226f0:	d1dc      	bne.n	226ac <dmConnCmplStates+0x10>
    }
  }

  return NULL;
   226f2:	2300      	movs	r3, #0
}
   226f4:	4618      	mov	r0, r3
   226f6:	3708      	adds	r7, #8
   226f8:	46bd      	mov	sp, r7
   226fa:	bd80      	pop	{r7, pc}
   226fc:	10011218 	.word	0x10011218
   22700:	00044b28 	.word	0x00044b28

00022704 <dmConnCcbAlloc>:
 *
 *  \return Pointer to CCB or NULL if failure.
 */
/*************************************************************************************************/
dmConnCcb_t *dmConnCcbAlloc(uint8_t *pAddr)
{
   22704:	b580      	push	{r7, lr}
   22706:	b084      	sub	sp, #16
   22708:	af00      	add	r7, sp, #0
   2270a:	6078      	str	r0, [r7, #4]
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   2270c:	4b1f      	ldr	r3, [pc, #124]	; (2278c <dmConnCcbAlloc+0x88>)
   2270e:	60fb      	str	r3, [r7, #12]
  uint8_t       i;

  for (i = 0; i < DM_CONN_MAX; i++, pCcb++)
   22710:	2300      	movs	r3, #0
   22712:	72fb      	strb	r3, [r7, #11]
   22714:	e02e      	b.n	22774 <dmConnCcbAlloc+0x70>
  {
    if (pCcb->inUse == FALSE)
   22716:	68fb      	ldr	r3, [r7, #12]
   22718:	7d9b      	ldrb	r3, [r3, #22]
   2271a:	2b00      	cmp	r3, #0
   2271c:	d124      	bne.n	22768 <dmConnCcbAlloc+0x64>
    {
      memset(pCcb, 0, sizeof(dmConnCcb_t));
   2271e:	2230      	movs	r2, #48	; 0x30
   22720:	2100      	movs	r1, #0
   22722:	68f8      	ldr	r0, [r7, #12]
   22724:	f00d fce4 	bl	300f0 <memset>

      BdaCpy(pCcb->peerAddr, pAddr);
   22728:	68fb      	ldr	r3, [r7, #12]
   2272a:	6879      	ldr	r1, [r7, #4]
   2272c:	4618      	mov	r0, r3
   2272e:	f7ff fa2a 	bl	21b86 <BdaCpy>
      pCcb->handle = DM_CONN_HCI_HANDLE_NONE;
   22732:	68fb      	ldr	r3, [r7, #12]
   22734:	f64f 72ff 	movw	r2, #65535	; 0xffff
   22738:	819a      	strh	r2, [r3, #12]
      pCcb->connId = i + 1;
   2273a:	7afb      	ldrb	r3, [r7, #11]
   2273c:	3301      	adds	r3, #1
   2273e:	b2da      	uxtb	r2, r3
   22740:	68fb      	ldr	r3, [r7, #12]
   22742:	741a      	strb	r2, [r3, #16]
      pCcb->updating = FALSE;
   22744:	68fb      	ldr	r3, [r7, #12]
   22746:	2200      	movs	r2, #0
   22748:	745a      	strb	r2, [r3, #17]
      pCcb->inUse = TRUE;
   2274a:	68fb      	ldr	r3, [r7, #12]
   2274c:	2201      	movs	r2, #1
   2274e:	759a      	strb	r2, [r3, #22]
      pCcb->featuresPresent = FALSE;
   22750:	68fb      	ldr	r3, [r7, #12]
   22752:	2200      	movs	r2, #0
   22754:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

      DM_TRACE_ALLOC1("dmConnCcbAlloc %d", pCcb->connId);
   22758:	68fb      	ldr	r3, [r7, #12]
   2275a:	7c1b      	ldrb	r3, [r3, #16]
   2275c:	4619      	mov	r1, r3
   2275e:	480c      	ldr	r0, [pc, #48]	; (22790 <dmConnCcbAlloc+0x8c>)
   22760:	f00b f916 	bl	2d990 <WsfTrace>

      return pCcb;
   22764:	68fb      	ldr	r3, [r7, #12]
   22766:	e00c      	b.n	22782 <dmConnCcbAlloc+0x7e>
  for (i = 0; i < DM_CONN_MAX; i++, pCcb++)
   22768:	7afb      	ldrb	r3, [r7, #11]
   2276a:	3301      	adds	r3, #1
   2276c:	72fb      	strb	r3, [r7, #11]
   2276e:	68fb      	ldr	r3, [r7, #12]
   22770:	3330      	adds	r3, #48	; 0x30
   22772:	60fb      	str	r3, [r7, #12]
   22774:	7afb      	ldrb	r3, [r7, #11]
   22776:	2b02      	cmp	r3, #2
   22778:	d9cd      	bls.n	22716 <dmConnCcbAlloc+0x12>
    }
  }

  DM_TRACE_ERR0("dmConnCcbAlloc failed");
   2277a:	4806      	ldr	r0, [pc, #24]	; (22794 <dmConnCcbAlloc+0x90>)
   2277c:	f00b f908 	bl	2d990 <WsfTrace>

  return NULL;
   22780:	2300      	movs	r3, #0
}
   22782:	4618      	mov	r0, r3
   22784:	3710      	adds	r7, #16
   22786:	46bd      	mov	sp, r7
   22788:	bd80      	pop	{r7, pc}
   2278a:	bf00      	nop
   2278c:	10011218 	.word	0x10011218
   22790:	00044b3c 	.word	0x00044b3c
   22794:	00044b50 	.word	0x00044b50

00022798 <dmConnCcbDealloc>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnCcbDealloc(dmConnCcb_t *pCcb)
{
   22798:	b580      	push	{r7, lr}
   2279a:	b082      	sub	sp, #8
   2279c:	af00      	add	r7, sp, #0
   2279e:	6078      	str	r0, [r7, #4]
  DM_TRACE_FREE1("dmConnCcbDealloc %d", pCcb->connId);
   227a0:	687b      	ldr	r3, [r7, #4]
   227a2:	7c1b      	ldrb	r3, [r3, #16]
   227a4:	4619      	mov	r1, r3
   227a6:	4805      	ldr	r0, [pc, #20]	; (227bc <dmConnCcbDealloc+0x24>)
   227a8:	f00b f8f2 	bl	2d990 <WsfTrace>

  pCcb->inUse = FALSE;
   227ac:	687b      	ldr	r3, [r7, #4]
   227ae:	2200      	movs	r2, #0
   227b0:	759a      	strb	r2, [r3, #22]
}
   227b2:	bf00      	nop
   227b4:	3708      	adds	r7, #8
   227b6:	46bd      	mov	sp, r7
   227b8:	bd80      	pop	{r7, pc}
   227ba:	bf00      	nop
   227bc:	00044b68 	.word	0x00044b68

000227c0 <dmConnCcbByHandle>:
 *
 *  \return Pointer to CCB or NULL if failure.
 */
/*************************************************************************************************/
dmConnCcb_t *dmConnCcbByHandle(uint16_t handle)
{
   227c0:	b580      	push	{r7, lr}
   227c2:	b084      	sub	sp, #16
   227c4:	af00      	add	r7, sp, #0
   227c6:	4603      	mov	r3, r0
   227c8:	80fb      	strh	r3, [r7, #6]
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   227ca:	4b11      	ldr	r3, [pc, #68]	; (22810 <dmConnCcbByHandle+0x50>)
   227cc:	60fb      	str	r3, [r7, #12]
  uint8_t       i;

  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   227ce:	2303      	movs	r3, #3
   227d0:	72fb      	strb	r3, [r7, #11]
   227d2:	e010      	b.n	227f6 <dmConnCcbByHandle+0x36>
  {
    if (pCcb->inUse && (pCcb->handle == handle))
   227d4:	68fb      	ldr	r3, [r7, #12]
   227d6:	7d9b      	ldrb	r3, [r3, #22]
   227d8:	2b00      	cmp	r3, #0
   227da:	d006      	beq.n	227ea <dmConnCcbByHandle+0x2a>
   227dc:	68fb      	ldr	r3, [r7, #12]
   227de:	899b      	ldrh	r3, [r3, #12]
   227e0:	88fa      	ldrh	r2, [r7, #6]
   227e2:	429a      	cmp	r2, r3
   227e4:	d101      	bne.n	227ea <dmConnCcbByHandle+0x2a>
    {
      return pCcb;
   227e6:	68fb      	ldr	r3, [r7, #12]
   227e8:	e00e      	b.n	22808 <dmConnCcbByHandle+0x48>
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   227ea:	7afb      	ldrb	r3, [r7, #11]
   227ec:	3b01      	subs	r3, #1
   227ee:	72fb      	strb	r3, [r7, #11]
   227f0:	68fb      	ldr	r3, [r7, #12]
   227f2:	3330      	adds	r3, #48	; 0x30
   227f4:	60fb      	str	r3, [r7, #12]
   227f6:	7afb      	ldrb	r3, [r7, #11]
   227f8:	2b00      	cmp	r3, #0
   227fa:	d1eb      	bne.n	227d4 <dmConnCcbByHandle+0x14>
    }
  }

  DM_TRACE_WARN1("dmConnCcbByHandle not found 0x%04x", handle);
   227fc:	88fb      	ldrh	r3, [r7, #6]
   227fe:	4619      	mov	r1, r3
   22800:	4804      	ldr	r0, [pc, #16]	; (22814 <dmConnCcbByHandle+0x54>)
   22802:	f00b f8c5 	bl	2d990 <WsfTrace>

  return NULL;
   22806:	2300      	movs	r3, #0
}
   22808:	4618      	mov	r0, r3
   2280a:	3710      	adds	r7, #16
   2280c:	46bd      	mov	sp, r7
   2280e:	bd80      	pop	{r7, pc}
   22810:	10011218 	.word	0x10011218
   22814:	00044b7c 	.word	0x00044b7c

00022818 <dmConnCcbByBdAddr>:
 *
 *  \return Pointer to CCB or NULL if failure.
 */
/*************************************************************************************************/
dmConnCcb_t *dmConnCcbByBdAddr(uint8_t *pAddr)
{
   22818:	b580      	push	{r7, lr}
   2281a:	b084      	sub	sp, #16
   2281c:	af00      	add	r7, sp, #0
   2281e:	6078      	str	r0, [r7, #4]
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   22820:	4b11      	ldr	r3, [pc, #68]	; (22868 <dmConnCcbByBdAddr+0x50>)
   22822:	60fb      	str	r3, [r7, #12]
  uint8_t       i;

  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   22824:	2303      	movs	r3, #3
   22826:	72fb      	strb	r3, [r7, #11]
   22828:	e013      	b.n	22852 <dmConnCcbByBdAddr+0x3a>
  {
    if (pCcb->inUse && BdaCmp(pCcb->peerAddr, pAddr))
   2282a:	68fb      	ldr	r3, [r7, #12]
   2282c:	7d9b      	ldrb	r3, [r3, #22]
   2282e:	2b00      	cmp	r3, #0
   22830:	d009      	beq.n	22846 <dmConnCcbByBdAddr+0x2e>
   22832:	68fb      	ldr	r3, [r7, #12]
   22834:	6879      	ldr	r1, [r7, #4]
   22836:	4618      	mov	r0, r3
   22838:	f7ff f9b3 	bl	21ba2 <BdaCmp>
   2283c:	4603      	mov	r3, r0
   2283e:	2b00      	cmp	r3, #0
   22840:	d001      	beq.n	22846 <dmConnCcbByBdAddr+0x2e>
    {
      return pCcb;
   22842:	68fb      	ldr	r3, [r7, #12]
   22844:	e00c      	b.n	22860 <dmConnCcbByBdAddr+0x48>
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   22846:	7afb      	ldrb	r3, [r7, #11]
   22848:	3b01      	subs	r3, #1
   2284a:	72fb      	strb	r3, [r7, #11]
   2284c:	68fb      	ldr	r3, [r7, #12]
   2284e:	3330      	adds	r3, #48	; 0x30
   22850:	60fb      	str	r3, [r7, #12]
   22852:	7afb      	ldrb	r3, [r7, #11]
   22854:	2b00      	cmp	r3, #0
   22856:	d1e8      	bne.n	2282a <dmConnCcbByBdAddr+0x12>
    }
  }

  DM_TRACE_INFO0("dmConnIdByBdAddr not found");
   22858:	4804      	ldr	r0, [pc, #16]	; (2286c <dmConnCcbByBdAddr+0x54>)
   2285a:	f00b f899 	bl	2d990 <WsfTrace>

  return NULL;
   2285e:	2300      	movs	r3, #0
}
   22860:	4618      	mov	r0, r3
   22862:	3710      	adds	r7, #16
   22864:	46bd      	mov	sp, r7
   22866:	bd80      	pop	{r7, pc}
   22868:	10011218 	.word	0x10011218
   2286c:	00044ba0 	.word	0x00044ba0

00022870 <dmConnCcbById>:
 *
 *  \return Pointer to CCB or NULL if failure.
 */
/*************************************************************************************************/
dmConnCcb_t *dmConnCcbById(dmConnId_t connId)
{
   22870:	b480      	push	{r7}
   22872:	b083      	sub	sp, #12
   22874:	af00      	add	r7, sp, #0
   22876:	4603      	mov	r3, r0
   22878:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  connId--;
   2287a:	79fb      	ldrb	r3, [r7, #7]
   2287c:	3b01      	subs	r3, #1
   2287e:	71fb      	strb	r3, [r7, #7]
  if (dmConnCb.ccb[connId].inUse)
   22880:	79fa      	ldrb	r2, [r7, #7]
   22882:	490c      	ldr	r1, [pc, #48]	; (228b4 <dmConnCcbById+0x44>)
   22884:	4613      	mov	r3, r2
   22886:	005b      	lsls	r3, r3, #1
   22888:	4413      	add	r3, r2
   2288a:	011b      	lsls	r3, r3, #4
   2288c:	440b      	add	r3, r1
   2288e:	3316      	adds	r3, #22
   22890:	781b      	ldrb	r3, [r3, #0]
   22892:	2b00      	cmp	r3, #0
   22894:	d007      	beq.n	228a6 <dmConnCcbById+0x36>
  {
    return &dmConnCb.ccb[connId];
   22896:	79fa      	ldrb	r2, [r7, #7]
   22898:	4613      	mov	r3, r2
   2289a:	005b      	lsls	r3, r3, #1
   2289c:	4413      	add	r3, r2
   2289e:	011b      	lsls	r3, r3, #4
   228a0:	4a04      	ldr	r2, [pc, #16]	; (228b4 <dmConnCcbById+0x44>)
   228a2:	4413      	add	r3, r2
   228a4:	e000      	b.n	228a8 <dmConnCcbById+0x38>
  }

  return NULL;
   228a6:	2300      	movs	r3, #0
}
   228a8:	4618      	mov	r0, r3
   228aa:	370c      	adds	r7, #12
   228ac:	46bd      	mov	sp, r7
   228ae:	f85d 7b04 	ldr.w	r7, [sp], #4
   228b2:	4770      	bx	lr
   228b4:	10011218 	.word	0x10011218

000228b8 <dmConnNum>:
 *
 *  \return Number of connections.
 */
/*************************************************************************************************/
uint8_t dmConnNum(void)
{
   228b8:	b480      	push	{r7}
   228ba:	b083      	sub	sp, #12
   228bc:	af00      	add	r7, sp, #0
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   228be:	4b0f      	ldr	r3, [pc, #60]	; (228fc <dmConnNum+0x44>)
   228c0:	607b      	str	r3, [r7, #4]
  uint8_t       i, j;

  for (i = DM_CONN_MAX, j = 0; i > 0; i--, pCcb++)
   228c2:	2303      	movs	r3, #3
   228c4:	70fb      	strb	r3, [r7, #3]
   228c6:	2300      	movs	r3, #0
   228c8:	70bb      	strb	r3, [r7, #2]
   228ca:	e00c      	b.n	228e6 <dmConnNum+0x2e>
  {
    if (pCcb->inUse)
   228cc:	687b      	ldr	r3, [r7, #4]
   228ce:	7d9b      	ldrb	r3, [r3, #22]
   228d0:	2b00      	cmp	r3, #0
   228d2:	d002      	beq.n	228da <dmConnNum+0x22>
    {
      j++;
   228d4:	78bb      	ldrb	r3, [r7, #2]
   228d6:	3301      	adds	r3, #1
   228d8:	70bb      	strb	r3, [r7, #2]
  for (i = DM_CONN_MAX, j = 0; i > 0; i--, pCcb++)
   228da:	78fb      	ldrb	r3, [r7, #3]
   228dc:	3b01      	subs	r3, #1
   228de:	70fb      	strb	r3, [r7, #3]
   228e0:	687b      	ldr	r3, [r7, #4]
   228e2:	3330      	adds	r3, #48	; 0x30
   228e4:	607b      	str	r3, [r7, #4]
   228e6:	78fb      	ldrb	r3, [r7, #3]
   228e8:	2b00      	cmp	r3, #0
   228ea:	d1ef      	bne.n	228cc <dmConnNum+0x14>
    }
  }

  return j;
   228ec:	78bb      	ldrb	r3, [r7, #2]
}
   228ee:	4618      	mov	r0, r3
   228f0:	370c      	adds	r7, #12
   228f2:	46bd      	mov	sp, r7
   228f4:	f85d 7b04 	ldr.w	r7, [sp], #4
   228f8:	4770      	bx	lr
   228fa:	bf00      	nop
   228fc:	10011218 	.word	0x10011218

00022900 <dmConnExecCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnExecCback(dmConnMsg_t *pMsg)
{
   22900:	b580      	push	{r7, lr}
   22902:	b084      	sub	sp, #16
   22904:	af00      	add	r7, sp, #0
   22906:	6078      	str	r0, [r7, #4]
  uint8_t i;

  for (i = 0; i < DM_CLIENT_ID_MAX; i++)
   22908:	2300      	movs	r3, #0
   2290a:	73fb      	strb	r3, [r7, #15]
   2290c:	e010      	b.n	22930 <dmConnExecCback+0x30>
  {
    if (dmConnCb.connCback[i] != NULL)
   2290e:	7bfb      	ldrb	r3, [r7, #15]
   22910:	4a0b      	ldr	r2, [pc, #44]	; (22940 <dmConnExecCback+0x40>)
   22912:	3324      	adds	r3, #36	; 0x24
   22914:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22918:	2b00      	cmp	r3, #0
   2291a:	d006      	beq.n	2292a <dmConnExecCback+0x2a>
    {
      (*dmConnCb.connCback[i])((dmEvt_t *) pMsg);
   2291c:	7bfb      	ldrb	r3, [r7, #15]
   2291e:	4a08      	ldr	r2, [pc, #32]	; (22940 <dmConnExecCback+0x40>)
   22920:	3324      	adds	r3, #36	; 0x24
   22922:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   22926:	6878      	ldr	r0, [r7, #4]
   22928:	4798      	blx	r3
  for (i = 0; i < DM_CLIENT_ID_MAX; i++)
   2292a:	7bfb      	ldrb	r3, [r7, #15]
   2292c:	3301      	adds	r3, #1
   2292e:	73fb      	strb	r3, [r7, #15]
   22930:	7bfb      	ldrb	r3, [r7, #15]
   22932:	2b04      	cmp	r3, #4
   22934:	d9eb      	bls.n	2290e <dmConnExecCback+0xe>
    }
  }
}
   22936:	bf00      	nop
   22938:	bf00      	nop
   2293a:	3710      	adds	r7, #16
   2293c:	46bd      	mov	sp, r7
   2293e:	bd80      	pop	{r7, pc}
   22940:	10011218 	.word	0x10011218

00022944 <dmConnOpenAccept>:
 */
/*************************************************************************************************/
dmConnId_t dmConnOpenAccept(uint8_t clientId, uint8_t initPhys, uint8_t advHandle, uint8_t advType,
                            uint16_t duration, uint8_t maxEaEvents, uint8_t addrType, uint8_t *pAddr,
                            uint8_t role)
{
   22944:	b590      	push	{r4, r7, lr}
   22946:	b085      	sub	sp, #20
   22948:	af00      	add	r7, sp, #0
   2294a:	4604      	mov	r4, r0
   2294c:	4608      	mov	r0, r1
   2294e:	4611      	mov	r1, r2
   22950:	461a      	mov	r2, r3
   22952:	4623      	mov	r3, r4
   22954:	71fb      	strb	r3, [r7, #7]
   22956:	4603      	mov	r3, r0
   22958:	71bb      	strb	r3, [r7, #6]
   2295a:	460b      	mov	r3, r1
   2295c:	717b      	strb	r3, [r7, #5]
   2295e:	4613      	mov	r3, r2
   22960:	713b      	strb	r3, [r7, #4]
  dmConnCcb_t           *pCcb = NULL;
   22962:	2300      	movs	r3, #0
   22964:	60fb      	str	r3, [r7, #12]
  dmConnApiOpen_t       *pMsg;

  /* make sure ccb not already allocated */
  WsfTaskLock();
   22966:	f00a fc4d 	bl	2d204 <WsfTaskLock>
  if ((pCcb = dmConnCcbByBdAddr(pAddr)) == NULL)
   2296a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   2296c:	f7ff ff54 	bl	22818 <dmConnCcbByBdAddr>
   22970:	60f8      	str	r0, [r7, #12]
   22972:	68fb      	ldr	r3, [r7, #12]
   22974:	2b00      	cmp	r3, #0
   22976:	d103      	bne.n	22980 <dmConnOpenAccept+0x3c>
  {
    /* allocate ccb */
    pCcb = dmConnCcbAlloc(pAddr);
   22978:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   2297a:	f7ff fec3 	bl	22704 <dmConnCcbAlloc>
   2297e:	60f8      	str	r0, [r7, #12]
  }
  WsfTaskUnlock();
   22980:	f00a fc46 	bl	2d210 <WsfTaskUnlock>

  if (pCcb != NULL)
   22984:	68fb      	ldr	r3, [r7, #12]
   22986:	2b00      	cmp	r3, #0
   22988:	d049      	beq.n	22a1e <dmConnOpenAccept+0xda>
  {
    if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiOpen_t))) != NULL)
   2298a:	2014      	movs	r0, #20
   2298c:	f00a fb8f 	bl	2d0ae <WsfMsgAlloc>
   22990:	60b8      	str	r0, [r7, #8]
   22992:	68bb      	ldr	r3, [r7, #8]
   22994:	2b00      	cmp	r3, #0
   22996:	d03b      	beq.n	22a10 <dmConnOpenAccept+0xcc>
    {
      pMsg->hdr.param = pCcb->connId;
   22998:	68fb      	ldr	r3, [r7, #12]
   2299a:	7c1b      	ldrb	r3, [r3, #16]
   2299c:	b29a      	uxth	r2, r3
   2299e:	68bb      	ldr	r3, [r7, #8]
   229a0:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = (role == DM_ROLE_MASTER) ?
   229a2:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
   229a6:	2b00      	cmp	r3, #0
   229a8:	d101      	bne.n	229ae <dmConnOpenAccept+0x6a>
   229aa:	2230      	movs	r2, #48	; 0x30
   229ac:	e000      	b.n	229b0 <dmConnOpenAccept+0x6c>
   229ae:	2232      	movs	r2, #50	; 0x32
   229b0:	68bb      	ldr	r3, [r7, #8]
   229b2:	709a      	strb	r2, [r3, #2]
                        DM_CONN_MSG_API_OPEN : DM_CONN_MSG_API_ACCEPT;
      pMsg->initPhys = initPhys;
   229b4:	68bb      	ldr	r3, [r7, #8]
   229b6:	79ba      	ldrb	r2, [r7, #6]
   229b8:	711a      	strb	r2, [r3, #4]
      pMsg->advHandle = advHandle;
   229ba:	68bb      	ldr	r3, [r7, #8]
   229bc:	797a      	ldrb	r2, [r7, #5]
   229be:	715a      	strb	r2, [r3, #5]
      pMsg->advType = advType;
   229c0:	68bb      	ldr	r3, [r7, #8]
   229c2:	793a      	ldrb	r2, [r7, #4]
   229c4:	719a      	strb	r2, [r3, #6]
      pMsg->duration = duration;
   229c6:	68bb      	ldr	r3, [r7, #8]
   229c8:	8c3a      	ldrh	r2, [r7, #32]
   229ca:	811a      	strh	r2, [r3, #8]
      pMsg->maxEaEvents = maxEaEvents;
   229cc:	68bb      	ldr	r3, [r7, #8]
   229ce:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
   229d2:	729a      	strb	r2, [r3, #10]
      BdaCpy(pMsg->peerAddr, pAddr);
   229d4:	68bb      	ldr	r3, [r7, #8]
   229d6:	330b      	adds	r3, #11
   229d8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   229da:	4618      	mov	r0, r3
   229dc:	f7ff f8d3 	bl	21b86 <BdaCpy>
      pMsg->addrType = addrType;
   229e0:	68bb      	ldr	r3, [r7, #8]
   229e2:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
   229e6:	745a      	strb	r2, [r3, #17]
      pMsg->clientId = clientId;
   229e8:	68bb      	ldr	r3, [r7, #8]
   229ea:	79fa      	ldrb	r2, [r7, #7]
   229ec:	749a      	strb	r2, [r3, #18]
      WsfMsgSend(dmCb.handlerId, pMsg);
   229ee:	4b0e      	ldr	r3, [pc, #56]	; (22a28 <dmConnOpenAccept+0xe4>)
   229f0:	7b1b      	ldrb	r3, [r3, #12]
   229f2:	68b9      	ldr	r1, [r7, #8]
   229f4:	4618      	mov	r0, r3
   229f6:	f00a fb7e 	bl	2d0f6 <WsfMsgSend>

      /* set role */
      WsfTaskLock();
   229fa:	f00a fc03 	bl	2d204 <WsfTaskLock>
      pCcb->role = role;
   229fe:	68fb      	ldr	r3, [r7, #12]
   22a00:	f897 2030 	ldrb.w	r2, [r7, #48]	; 0x30
   22a04:	765a      	strb	r2, [r3, #25]
      WsfTaskUnlock();
   22a06:	f00a fc03 	bl	2d210 <WsfTaskUnlock>

      /* return connection id */
      return pCcb->connId;
   22a0a:	68fb      	ldr	r3, [r7, #12]
   22a0c:	7c1b      	ldrb	r3, [r3, #16]
   22a0e:	e007      	b.n	22a20 <dmConnOpenAccept+0xdc>
    }
    else
    {
      WsfTaskLock();
   22a10:	f00a fbf8 	bl	2d204 <WsfTaskLock>
      dmConnCcbDealloc(pCcb);
   22a14:	68f8      	ldr	r0, [r7, #12]
   22a16:	f7ff febf 	bl	22798 <dmConnCcbDealloc>
      WsfTaskUnlock();
   22a1a:	f00a fbf9 	bl	2d210 <WsfTaskUnlock>
    }
  }

  /* open failed */
  return DM_CONN_ID_NONE;
   22a1e:	2300      	movs	r3, #0
}
   22a20:	4618      	mov	r0, r3
   22a22:	3714      	adds	r7, #20
   22a24:	46bd      	mov	sp, r7
   22a26:	bd90      	pop	{r4, r7, pc}
   22a28:	100112ec 	.word	0x100112ec

00022a2c <dmConnSmActNone>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActNone(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22a2c:	b480      	push	{r7}
   22a2e:	b083      	sub	sp, #12
   22a30:	af00      	add	r7, sp, #0
   22a32:	6078      	str	r0, [r7, #4]
   22a34:	6039      	str	r1, [r7, #0]
  return;
   22a36:	bf00      	nop
}
   22a38:	370c      	adds	r7, #12
   22a3a:	46bd      	mov	sp, r7
   22a3c:	f85d 7b04 	ldr.w	r7, [sp], #4
   22a40:	4770      	bx	lr

00022a42 <dmConnSmActClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActClose(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22a42:	b580      	push	{r7, lr}
   22a44:	b082      	sub	sp, #8
   22a46:	af00      	add	r7, sp, #0
   22a48:	6078      	str	r0, [r7, #4]
   22a4a:	6039      	str	r1, [r7, #0]
  HciDisconnectCmd(pCcb->handle, pMsg->apiClose.reason);
   22a4c:	687b      	ldr	r3, [r7, #4]
   22a4e:	899a      	ldrh	r2, [r3, #12]
   22a50:	683b      	ldr	r3, [r7, #0]
   22a52:	791b      	ldrb	r3, [r3, #4]
   22a54:	4619      	mov	r1, r3
   22a56:	4610      	mov	r0, r2
   22a58:	f002 f9da 	bl	24e10 <HciDisconnectCmd>
}
   22a5c:	bf00      	nop
   22a5e:	3708      	adds	r7, #8
   22a60:	46bd      	mov	sp, r7
   22a62:	bd80      	pop	{r7, pc}

00022a64 <dmConnSmActConnOpened>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActConnOpened(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22a64:	b590      	push	{r4, r7, lr}
   22a66:	b083      	sub	sp, #12
   22a68:	af00      	add	r7, sp, #0
   22a6a:	6078      	str	r0, [r7, #4]
   22a6c:	6039      	str	r1, [r7, #0]
  /* store peer address, handle, and role */
  BdaCpy(pCcb->peerAddr, pMsg->hciLeConnCmpl.peerAddr);
   22a6e:	687a      	ldr	r2, [r7, #4]
   22a70:	683b      	ldr	r3, [r7, #0]
   22a72:	330a      	adds	r3, #10
   22a74:	4619      	mov	r1, r3
   22a76:	4610      	mov	r0, r2
   22a78:	f7ff f885 	bl	21b86 <BdaCpy>
  pCcb->handle = pMsg->hciLeConnCmpl.handle;
   22a7c:	683b      	ldr	r3, [r7, #0]
   22a7e:	88da      	ldrh	r2, [r3, #6]
   22a80:	687b      	ldr	r3, [r7, #4]
   22a82:	819a      	strh	r2, [r3, #12]
  pCcb->peerAddrType = DmHostAddrType(pMsg->hciLeConnCmpl.addrType);
   22a84:	683b      	ldr	r3, [r7, #0]
   22a86:	7a5b      	ldrb	r3, [r3, #9]
   22a88:	4618      	mov	r0, r3
   22a8a:	f001 fa4b 	bl	23f24 <DmHostAddrType>
   22a8e:	4603      	mov	r3, r0
   22a90:	461a      	mov	r2, r3
   22a92:	687b      	ldr	r3, [r7, #4]
   22a94:	74da      	strb	r2, [r3, #19]
  pCcb->role = pMsg->hciLeConnCmpl.role;
   22a96:	683b      	ldr	r3, [r7, #0]
   22a98:	7a1a      	ldrb	r2, [r3, #8]
   22a9a:	687b      	ldr	r3, [r7, #4]
   22a9c:	765a      	strb	r2, [r3, #25]

  /* set local address type of connection */
  if (pCcb->role == DM_ROLE_MASTER)
   22a9e:	687b      	ldr	r3, [r7, #4]
   22aa0:	7e5b      	ldrb	r3, [r3, #25]
   22aa2:	2b00      	cmp	r3, #0
   22aa4:	d104      	bne.n	22ab0 <dmConnSmActConnOpened+0x4c>
  {
    pCcb->localAddrType = dmCb.connAddrType;
   22aa6:	4b2b      	ldr	r3, [pc, #172]	; (22b54 <dmConnSmActConnOpened+0xf0>)
   22aa8:	7b5a      	ldrb	r2, [r3, #13]
   22aaa:	687b      	ldr	r3, [r7, #4]
   22aac:	751a      	strb	r2, [r3, #20]
   22aae:	e003      	b.n	22ab8 <dmConnSmActConnOpened+0x54>
  }
  else
  {
    pCcb->localAddrType = dmCb.advAddrType;
   22ab0:	4b28      	ldr	r3, [pc, #160]	; (22b54 <dmConnSmActConnOpened+0xf0>)
   22ab2:	7b9a      	ldrb	r2, [r3, #14]
   22ab4:	687b      	ldr	r3, [r7, #4]
   22ab6:	751a      	strb	r2, [r3, #20]
  }

  /* set local address of connection */
  if (pCcb->localAddrType == DM_ADDR_PUBLIC)
   22ab8:	687b      	ldr	r3, [r7, #4]
   22aba:	7d1b      	ldrb	r3, [r3, #20]
   22abc:	2b00      	cmp	r3, #0
   22abe:	d109      	bne.n	22ad4 <dmConnSmActConnOpened+0x70>
  {
    BdaCpy(pCcb->localAddr, HciGetBdAddr());
   22ac0:	687b      	ldr	r3, [r7, #4]
   22ac2:	1d9c      	adds	r4, r3, #6
   22ac4:	f003 fcac 	bl	26420 <HciGetBdAddr>
   22ac8:	4603      	mov	r3, r0
   22aca:	4619      	mov	r1, r3
   22acc:	4620      	mov	r0, r4
   22ace:	f7ff f85a 	bl	21b86 <BdaCpy>
   22ad2:	e005      	b.n	22ae0 <dmConnSmActConnOpened+0x7c>
  }
  else
  {
    BdaCpy(pCcb->localAddr, dmCb.localAddr);
   22ad4:	687b      	ldr	r3, [r7, #4]
   22ad6:	3306      	adds	r3, #6
   22ad8:	491e      	ldr	r1, [pc, #120]	; (22b54 <dmConnSmActConnOpened+0xf0>)
   22ada:	4618      	mov	r0, r3
   22adc:	f7ff f853 	bl	21b86 <BdaCpy>
  }

  /* store enhanced fields */
  BdaCpy(pCcb->localRpa, pMsg->hciLeConnCmpl.localRpa);
   22ae0:	687b      	ldr	r3, [r7, #4]
   22ae2:	f103 021a 	add.w	r2, r3, #26
   22ae6:	683b      	ldr	r3, [r7, #0]
   22ae8:	3317      	adds	r3, #23
   22aea:	4619      	mov	r1, r3
   22aec:	4610      	mov	r0, r2
   22aee:	f7ff f84a 	bl	21b86 <BdaCpy>
  BdaCpy(pCcb->peerRpa, pMsg->hciLeConnCmpl.peerRpa);
   22af2:	687b      	ldr	r3, [r7, #4]
   22af4:	f103 0220 	add.w	r2, r3, #32
   22af8:	683b      	ldr	r3, [r7, #0]
   22afa:	331d      	adds	r3, #29
   22afc:	4619      	mov	r1, r3
   22afe:	4610      	mov	r0, r2
   22b00:	f7ff f841 	bl	21b86 <BdaCpy>

  /* initialize idle state */
  pCcb->idleMask = 0;
   22b04:	687b      	ldr	r3, [r7, #4]
   22b06:	2200      	movs	r2, #0
   22b08:	81da      	strh	r2, [r3, #14]

  /* if central */
  if (pCcb->role == DM_ROLE_MASTER)
   22b0a:	687b      	ldr	r3, [r7, #4]
   22b0c:	7e5b      	ldrb	r3, [r3, #25]
   22b0e:	2b00      	cmp	r3, #0
   22b10:	d110      	bne.n	22b34 <dmConnSmActConnOpened+0xd0>
  {
    /* pass connection initiation completed to dev priv */
    dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_CTRL, DM_DEV_PRIV_MSG_CONN_INIT_STOP, 0 , 0);
   22b12:	2300      	movs	r3, #0
   22b14:	2200      	movs	r2, #0
   22b16:	2101      	movs	r1, #1
   22b18:	2016      	movs	r0, #22
   22b1a:	f001 f885 	bl	23c28 <dmDevPassEvtToDevPriv>

    /* if first connection opened */
    if (dmConnNum() == 1)
   22b1e:	f7ff fecb 	bl	228b8 <dmConnNum>
   22b22:	4603      	mov	r3, r0
   22b24:	2b01      	cmp	r3, #1
   22b26:	d105      	bne.n	22b34 <dmConnSmActConnOpened+0xd0>
    {
      /* pass conn open event to dev priv */
      dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_START, DM_CONN_OPEN_IND, 0, 0);
   22b28:	2300      	movs	r3, #0
   22b2a:	2200      	movs	r2, #0
   22b2c:	2127      	movs	r1, #39	; 0x27
   22b2e:	2014      	movs	r0, #20
   22b30:	f001 f87a 	bl	23c28 <dmDevPassEvtToDevPriv>
    }
  }

  /* pass conn open event to Connection CTE */
  dmDevPassEvtToConnCte(DM_CONN_OPEN_IND, pCcb->connId);
   22b34:	687b      	ldr	r3, [r7, #4]
   22b36:	7c1b      	ldrb	r3, [r3, #16]
   22b38:	4619      	mov	r1, r3
   22b3a:	2027      	movs	r0, #39	; 0x27
   22b3c:	f001 f8a2 	bl	23c84 <dmDevPassEvtToConnCte>

  pMsg->hdr.event = DM_CONN_OPEN_IND;
   22b40:	683b      	ldr	r3, [r7, #0]
   22b42:	2227      	movs	r2, #39	; 0x27
   22b44:	709a      	strb	r2, [r3, #2]
  dmConnExecCback(pMsg);
   22b46:	6838      	ldr	r0, [r7, #0]
   22b48:	f7ff feda 	bl	22900 <dmConnExecCback>
}
   22b4c:	bf00      	nop
   22b4e:	370c      	adds	r7, #12
   22b50:	46bd      	mov	sp, r7
   22b52:	bd90      	pop	{r4, r7, pc}
   22b54:	100112ec 	.word	0x100112ec

00022b58 <dmConnSmActConnFailed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActConnFailed(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22b58:	b580      	push	{r7, lr}
   22b5a:	b082      	sub	sp, #8
   22b5c:	af00      	add	r7, sp, #0
   22b5e:	6078      	str	r0, [r7, #4]
   22b60:	6039      	str	r1, [r7, #0]
  /* deallocate ccb */
  dmConnCcbDealloc(pCcb);
   22b62:	6878      	ldr	r0, [r7, #4]
   22b64:	f7ff fe18 	bl	22798 <dmConnCcbDealloc>

  /* if central */
  if (pCcb->role == DM_ROLE_MASTER)
   22b68:	687b      	ldr	r3, [r7, #4]
   22b6a:	7e5b      	ldrb	r3, [r3, #25]
   22b6c:	2b00      	cmp	r3, #0
   22b6e:	d110      	bne.n	22b92 <dmConnSmActConnFailed+0x3a>
  {
    /* pass connection initiation completed to dev priv */
    dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_CTRL, DM_DEV_PRIV_MSG_CONN_INIT_STOP, 0, 0);
   22b70:	2300      	movs	r3, #0
   22b72:	2200      	movs	r2, #0
   22b74:	2101      	movs	r1, #1
   22b76:	2016      	movs	r0, #22
   22b78:	f001 f856 	bl	23c28 <dmDevPassEvtToDevPriv>

    /* if last connection closed */
    if (dmConnNum() == 0)
   22b7c:	f7ff fe9c 	bl	228b8 <dmConnNum>
   22b80:	4603      	mov	r3, r0
   22b82:	2b00      	cmp	r3, #0
   22b84:	d105      	bne.n	22b92 <dmConnSmActConnFailed+0x3a>
    {
      /* pass conn close event to dev priv */
      dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_STOP, DM_CONN_CLOSE_IND, 0 , 0);
   22b86:	2300      	movs	r3, #0
   22b88:	2200      	movs	r2, #0
   22b8a:	2128      	movs	r1, #40	; 0x28
   22b8c:	2015      	movs	r0, #21
   22b8e:	f001 f84b 	bl	23c28 <dmDevPassEvtToDevPriv>
    }
  }

  pMsg->hdr.event = DM_CONN_CLOSE_IND;
   22b92:	683b      	ldr	r3, [r7, #0]
   22b94:	2228      	movs	r2, #40	; 0x28
   22b96:	709a      	strb	r2, [r3, #2]
  pMsg->hciLeConnCmpl.handle = pMsg->hciLeConnCmpl.role = 0;
   22b98:	683b      	ldr	r3, [r7, #0]
   22b9a:	2200      	movs	r2, #0
   22b9c:	721a      	strb	r2, [r3, #8]
   22b9e:	683b      	ldr	r3, [r7, #0]
   22ba0:	2200      	movs	r2, #0
   22ba2:	80da      	strh	r2, [r3, #6]
  dmConnExecCback(pMsg);
   22ba4:	6838      	ldr	r0, [r7, #0]
   22ba6:	f7ff feab 	bl	22900 <dmConnExecCback>
}
   22baa:	bf00      	nop
   22bac:	3708      	adds	r7, #8
   22bae:	46bd      	mov	sp, r7
   22bb0:	bd80      	pop	{r7, pc}

00022bb2 <dmConnSmActConnClosed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActConnClosed(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22bb2:	b580      	push	{r7, lr}
   22bb4:	b082      	sub	sp, #8
   22bb6:	af00      	add	r7, sp, #0
   22bb8:	6078      	str	r0, [r7, #4]
   22bba:	6039      	str	r1, [r7, #0]
  /* pass conn close event to Connection CTE */
  dmDevPassEvtToConnCte(DM_CONN_CLOSE_IND, pCcb->connId);
   22bbc:	687b      	ldr	r3, [r7, #4]
   22bbe:	7c1b      	ldrb	r3, [r3, #16]
   22bc0:	4619      	mov	r1, r3
   22bc2:	2028      	movs	r0, #40	; 0x28
   22bc4:	f001 f85e 	bl	23c84 <dmDevPassEvtToConnCte>

  /* deallocate ccb */
  dmConnCcbDealloc(pCcb);
   22bc8:	6878      	ldr	r0, [r7, #4]
   22bca:	f7ff fde5 	bl	22798 <dmConnCcbDealloc>

  /* if central and last connection closed */
  if ((pCcb->role == DM_ROLE_MASTER) && (dmConnNum() == 0))
   22bce:	687b      	ldr	r3, [r7, #4]
   22bd0:	7e5b      	ldrb	r3, [r3, #25]
   22bd2:	2b00      	cmp	r3, #0
   22bd4:	d10a      	bne.n	22bec <dmConnSmActConnClosed+0x3a>
   22bd6:	f7ff fe6f 	bl	228b8 <dmConnNum>
   22bda:	4603      	mov	r3, r0
   22bdc:	2b00      	cmp	r3, #0
   22bde:	d105      	bne.n	22bec <dmConnSmActConnClosed+0x3a>
  {
    /* pass conn close event to dev priv */
    dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_RPA_STOP, DM_CONN_CLOSE_IND, 0, 0);
   22be0:	2300      	movs	r3, #0
   22be2:	2200      	movs	r2, #0
   22be4:	2128      	movs	r1, #40	; 0x28
   22be6:	2015      	movs	r0, #21
   22be8:	f001 f81e 	bl	23c28 <dmDevPassEvtToDevPriv>
  }

  pMsg->hdr.event = DM_CONN_CLOSE_IND;
   22bec:	683b      	ldr	r3, [r7, #0]
   22bee:	2228      	movs	r2, #40	; 0x28
   22bf0:	709a      	strb	r2, [r3, #2]
  dmConnExecCback(pMsg);
   22bf2:	6838      	ldr	r0, [r7, #0]
   22bf4:	f7ff fe84 	bl	22900 <dmConnExecCback>
}
   22bf8:	bf00      	nop
   22bfa:	3708      	adds	r7, #8
   22bfc:	46bd      	mov	sp, r7
   22bfe:	bd80      	pop	{r7, pc}

00022c00 <dmConnSmActHciUpdated>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActHciUpdated(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   22c00:	b580      	push	{r7, lr}
   22c02:	b082      	sub	sp, #8
   22c04:	af00      	add	r7, sp, #0
   22c06:	6078      	str	r0, [r7, #4]
   22c08:	6039      	str	r1, [r7, #0]
  /* call callback */
  pMsg->hdr.event = DM_CONN_UPDATE_IND;
   22c0a:	683b      	ldr	r3, [r7, #0]
   22c0c:	2229      	movs	r2, #41	; 0x29
   22c0e:	709a      	strb	r2, [r3, #2]
  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) pMsg);
   22c10:	4b04      	ldr	r3, [pc, #16]	; (22c24 <dmConnSmActHciUpdated+0x24>)
   22c12:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   22c16:	6838      	ldr	r0, [r7, #0]
   22c18:	4798      	blx	r3
}
   22c1a:	bf00      	nop
   22c1c:	3708      	adds	r7, #8
   22c1e:	46bd      	mov	sp, r7
   22c20:	bd80      	pop	{r7, pc}
   22c22:	bf00      	nop
   22c24:	10011218 	.word	0x10011218

00022c28 <dmConnReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnReset(void)
{
   22c28:	b580      	push	{r7, lr}
   22c2a:	b084      	sub	sp, #16
   22c2c:	af00      	add	r7, sp, #0
  dmConnCcb_t             *pCcb = dmConnCb.ccb;
   22c2e:	4b28      	ldr	r3, [pc, #160]	; (22cd0 <dmConnReset+0xa8>)
   22c30:	60fb      	str	r3, [r7, #12]
  hciDisconnectCmplEvt_t  disconnectCmpl;
  uint8_t                 i;

  /* generate HCI disconnect complete event */
  disconnectCmpl.hdr.event = HCI_DISCONNECT_CMPL_CBACK_EVT;
   22c32:	2303      	movs	r3, #3
   22c34:	70bb      	strb	r3, [r7, #2]
  disconnectCmpl.hdr.status = disconnectCmpl.status = HCI_SUCCESS;
   22c36:	2300      	movs	r3, #0
   22c38:	713b      	strb	r3, [r7, #4]
   22c3a:	793b      	ldrb	r3, [r7, #4]
   22c3c:	70fb      	strb	r3, [r7, #3]
  disconnectCmpl.reason = HCI_ERR_LOCAL_TERMINATED;
   22c3e:	2316      	movs	r3, #22
   22c40:	723b      	strb	r3, [r7, #8]

  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   22c42:	2303      	movs	r3, #3
   22c44:	72fb      	strb	r3, [r7, #11]
   22c46:	e012      	b.n	22c6e <dmConnReset+0x46>
  {
    if (pCcb->inUse)
   22c48:	68fb      	ldr	r3, [r7, #12]
   22c4a:	7d9b      	ldrb	r3, [r3, #22]
   22c4c:	2b00      	cmp	r3, #0
   22c4e:	d008      	beq.n	22c62 <dmConnReset+0x3a>
    {
      /* set connection id */
      disconnectCmpl.hdr.param = disconnectCmpl.handle = pCcb->handle;
   22c50:	68fb      	ldr	r3, [r7, #12]
   22c52:	899b      	ldrh	r3, [r3, #12]
   22c54:	80fb      	strh	r3, [r7, #6]
   22c56:	88fb      	ldrh	r3, [r7, #6]
   22c58:	803b      	strh	r3, [r7, #0]

      /* handle the event */
      dmConnHciHandler((hciEvt_t *) &disconnectCmpl);
   22c5a:	463b      	mov	r3, r7
   22c5c:	4618      	mov	r0, r3
   22c5e:	f000 f853 	bl	22d08 <dmConnHciHandler>
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   22c62:	7afb      	ldrb	r3, [r7, #11]
   22c64:	3b01      	subs	r3, #1
   22c66:	72fb      	strb	r3, [r7, #11]
   22c68:	68fb      	ldr	r3, [r7, #12]
   22c6a:	3330      	adds	r3, #48	; 0x30
   22c6c:	60fb      	str	r3, [r7, #12]
   22c6e:	7afb      	ldrb	r3, [r7, #11]
   22c70:	2b00      	cmp	r3, #0
   22c72:	d1e9      	bne.n	22c48 <dmConnReset+0x20>
    }
  }

  /* initialize control block */
  for (i = 0; i < DM_NUM_PHYS; i++)
   22c74:	2300      	movs	r3, #0
   22c76:	72fb      	strb	r3, [r7, #11]
   22c78:	e01c      	b.n	22cb4 <dmConnReset+0x8c>
  {
    dmConnCb.scanInterval[i] = DM_GAP_SCAN_FAST_INT_MIN;
   22c7a:	7afb      	ldrb	r3, [r7, #11]
   22c7c:	4a14      	ldr	r2, [pc, #80]	; (22cd0 <dmConnReset+0xa8>)
   22c7e:	335c      	adds	r3, #92	; 0x5c
   22c80:	005b      	lsls	r3, r3, #1
   22c82:	4413      	add	r3, r2
   22c84:	2230      	movs	r2, #48	; 0x30
   22c86:	809a      	strh	r2, [r3, #4]
    dmConnCb.scanWindow[i] = DM_GAP_SCAN_FAST_WINDOW;
   22c88:	7afb      	ldrb	r3, [r7, #11]
   22c8a:	4a11      	ldr	r2, [pc, #68]	; (22cd0 <dmConnReset+0xa8>)
   22c8c:	3360      	adds	r3, #96	; 0x60
   22c8e:	2130      	movs	r1, #48	; 0x30
   22c90:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    dmConnCb.connSpec[i] = dmConnSpecDefaults;
   22c94:	7afa      	ldrb	r2, [r7, #11]
   22c96:	490e      	ldr	r1, [pc, #56]	; (22cd0 <dmConnReset+0xa8>)
   22c98:	4613      	mov	r3, r2
   22c9a:	005b      	lsls	r3, r3, #1
   22c9c:	4413      	add	r3, r2
   22c9e:	009b      	lsls	r3, r3, #2
   22ca0:	440b      	add	r3, r1
   22ca2:	33a0      	adds	r3, #160	; 0xa0
   22ca4:	4a0b      	ldr	r2, [pc, #44]	; (22cd4 <dmConnReset+0xac>)
   22ca6:	3304      	adds	r3, #4
   22ca8:	ca07      	ldmia	r2, {r0, r1, r2}
   22caa:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  for (i = 0; i < DM_NUM_PHYS; i++)
   22cae:	7afb      	ldrb	r3, [r7, #11]
   22cb0:	3301      	adds	r3, #1
   22cb2:	72fb      	strb	r3, [r7, #11]
   22cb4:	7afb      	ldrb	r3, [r7, #11]
   22cb6:	2b01      	cmp	r3, #1
   22cb8:	d9df      	bls.n	22c7a <dmConnReset+0x52>
  }

  dmCb.initFiltPolicy = HCI_FILT_NONE;
   22cba:	4b07      	ldr	r3, [pc, #28]	; (22cd8 <dmConnReset+0xb0>)
   22cbc:	2200      	movs	r2, #0
   22cbe:	74da      	strb	r2, [r3, #19]
  dmCb.connAddrType = DM_ADDR_PUBLIC;
   22cc0:	4b05      	ldr	r3, [pc, #20]	; (22cd8 <dmConnReset+0xb0>)
   22cc2:	2200      	movs	r2, #0
   22cc4:	735a      	strb	r2, [r3, #13]
}
   22cc6:	bf00      	nop
   22cc8:	3710      	adds	r7, #16
   22cca:	46bd      	mov	sp, r7
   22ccc:	bd80      	pop	{r7, pc}
   22cce:	bf00      	nop
   22cd0:	10011218 	.word	0x10011218
   22cd4:	00045c00 	.word	0x00045c00
   22cd8:	100112ec 	.word	0x100112ec

00022cdc <dmConnMsgHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnMsgHandler(wsfMsgHdr_t *pMsg)
{
   22cdc:	b580      	push	{r7, lr}
   22cde:	b084      	sub	sp, #16
   22ce0:	af00      	add	r7, sp, #0
   22ce2:	6078      	str	r0, [r7, #4]
  dmConnCcb_t *pCcb;

  /* look up ccb from conn id */
  if ((pCcb = dmConnCcbById((dmConnId_t) pMsg->param)) != NULL)
   22ce4:	687b      	ldr	r3, [r7, #4]
   22ce6:	881b      	ldrh	r3, [r3, #0]
   22ce8:	b2db      	uxtb	r3, r3
   22cea:	4618      	mov	r0, r3
   22cec:	f7ff fdc0 	bl	22870 <dmConnCcbById>
   22cf0:	60f8      	str	r0, [r7, #12]
   22cf2:	68fb      	ldr	r3, [r7, #12]
   22cf4:	2b00      	cmp	r3, #0
   22cf6:	d003      	beq.n	22d00 <dmConnMsgHandler+0x24>
  {
    /* execute state machine */
    dmConnSmExecute(pCcb, (dmConnMsg_t *) pMsg);
   22cf8:	6879      	ldr	r1, [r7, #4]
   22cfa:	68f8      	ldr	r0, [r7, #12]
   22cfc:	f000 feb0 	bl	23a60 <dmConnSmExecute>
  }
}
   22d00:	bf00      	nop
   22d02:	3710      	adds	r7, #16
   22d04:	46bd      	mov	sp, r7
   22d06:	bd80      	pop	{r7, pc}

00022d08 <dmConnHciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnHciHandler(hciEvt_t *pEvent)
{
   22d08:	b580      	push	{r7, lr}
   22d0a:	b084      	sub	sp, #16
   22d0c:	af00      	add	r7, sp, #0
   22d0e:	6078      	str	r0, [r7, #4]
  dmConnCcb_t *pCcb;

  /* handle special cases for connection complete event */
  if ((pEvent->hdr.event == HCI_LE_CONN_CMPL_CBACK_EVT) ||
   22d10:	687b      	ldr	r3, [r7, #4]
   22d12:	789b      	ldrb	r3, [r3, #2]
   22d14:	2b01      	cmp	r3, #1
   22d16:	d003      	beq.n	22d20 <dmConnHciHandler+0x18>
      (pEvent->hdr.event == HCI_LE_ENHANCED_CONN_CMPL_CBACK_EVT))
   22d18:	687b      	ldr	r3, [r7, #4]
   22d1a:	789b      	ldrb	r3, [r3, #2]
  if ((pEvent->hdr.event == HCI_LE_CONN_CMPL_CBACK_EVT) ||
   22d1c:	2b02      	cmp	r3, #2
   22d1e:	d128      	bne.n	22d72 <dmConnHciHandler+0x6a>
  {
    /* first check if ccb exists for this bd addr */
    if ((pCcb = dmConnCcbByBdAddr(pEvent->leConnCmpl.peerAddr)) == NULL)
   22d20:	687b      	ldr	r3, [r7, #4]
   22d22:	330a      	adds	r3, #10
   22d24:	4618      	mov	r0, r3
   22d26:	f7ff fd77 	bl	22818 <dmConnCcbByBdAddr>
   22d2a:	60f8      	str	r0, [r7, #12]
   22d2c:	68fb      	ldr	r3, [r7, #12]
   22d2e:	2b00      	cmp	r3, #0
   22d30:	d113      	bne.n	22d5a <dmConnHciHandler+0x52>
    {
      /* check for special case states */
      if ((pCcb = dmConnCmplStates()) == NULL)
   22d32:	f7ff fcb3 	bl	2269c <dmConnCmplStates>
   22d36:	60f8      	str	r0, [r7, #12]
   22d38:	68fb      	ldr	r3, [r7, #12]
   22d3a:	2b00      	cmp	r3, #0
   22d3c:	d10d      	bne.n	22d5a <dmConnHciHandler+0x52>
      {
        /* else default case for slave, allocate new ccb */
        if ((pEvent->hdr.status == HCI_SUCCESS) && (pEvent->leConnCmpl.role == HCI_ROLE_SLAVE))
   22d3e:	687b      	ldr	r3, [r7, #4]
   22d40:	78db      	ldrb	r3, [r3, #3]
   22d42:	2b00      	cmp	r3, #0
   22d44:	d109      	bne.n	22d5a <dmConnHciHandler+0x52>
   22d46:	687b      	ldr	r3, [r7, #4]
   22d48:	7a1b      	ldrb	r3, [r3, #8]
   22d4a:	2b01      	cmp	r3, #1
   22d4c:	d105      	bne.n	22d5a <dmConnHciHandler+0x52>
        {
          pCcb = dmConnCcbAlloc(pEvent->leConnCmpl.peerAddr);
   22d4e:	687b      	ldr	r3, [r7, #4]
   22d50:	330a      	adds	r3, #10
   22d52:	4618      	mov	r0, r3
   22d54:	f7ff fcd6 	bl	22704 <dmConnCcbAlloc>
   22d58:	60f8      	str	r0, [r7, #12]
        }
      }
    }

    /* translate HCI event to state machine event */
    if (pEvent->hdr.status == HCI_SUCCESS)
   22d5a:	687b      	ldr	r3, [r7, #4]
   22d5c:	78db      	ldrb	r3, [r3, #3]
   22d5e:	2b00      	cmp	r3, #0
   22d60:	d103      	bne.n	22d6a <dmConnHciHandler+0x62>
    {
      pEvent->hdr.event =  DM_CONN_MSG_HCI_LE_CONN_CMPL;
   22d62:	687b      	ldr	r3, [r7, #4]
   22d64:	2238      	movs	r2, #56	; 0x38
   22d66:	709a      	strb	r2, [r3, #2]
    if (pEvent->hdr.status == HCI_SUCCESS)
   22d68:	e00f      	b.n	22d8a <dmConnHciHandler+0x82>
    }
    else
    {
      pEvent->hdr.event = DM_CONN_MSG_HCI_LE_CONN_CMPL_FAIL;
   22d6a:	687b      	ldr	r3, [r7, #4]
   22d6c:	2237      	movs	r2, #55	; 0x37
   22d6e:	709a      	strb	r2, [r3, #2]
    if (pEvent->hdr.status == HCI_SUCCESS)
   22d70:	e00b      	b.n	22d8a <dmConnHciHandler+0x82>
    }
  }
  else
  {
    pCcb = dmConnCcbByHandle(pEvent->hdr.param);
   22d72:	687b      	ldr	r3, [r7, #4]
   22d74:	881b      	ldrh	r3, [r3, #0]
   22d76:	4618      	mov	r0, r3
   22d78:	f7ff fd22 	bl	227c0 <dmConnCcbByHandle>
   22d7c:	60f8      	str	r0, [r7, #12]

    /* translate HCI event to state machine message */
    pEvent->hdr.event = DM_CONN_HCI_EVT_2_MSG(pEvent->hdr.event);
   22d7e:	687b      	ldr	r3, [r7, #4]
   22d80:	789b      	ldrb	r3, [r3, #2]
   22d82:	3336      	adds	r3, #54	; 0x36
   22d84:	b2da      	uxtb	r2, r3
   22d86:	687b      	ldr	r3, [r7, #4]
   22d88:	709a      	strb	r2, [r3, #2]
  }

  /* if ccb found */
  if (pCcb != NULL)
   22d8a:	68fb      	ldr	r3, [r7, #12]
   22d8c:	2b00      	cmp	r3, #0
   22d8e:	d008      	beq.n	22da2 <dmConnHciHandler+0x9a>
  {
    /* set conn id */
    pEvent->hdr.param = pCcb->connId;
   22d90:	68fb      	ldr	r3, [r7, #12]
   22d92:	7c1b      	ldrb	r3, [r3, #16]
   22d94:	b29a      	uxth	r2, r3
   22d96:	687b      	ldr	r3, [r7, #4]
   22d98:	801a      	strh	r2, [r3, #0]

    /* execute state machine */
    dmConnSmExecute(pCcb, (dmConnMsg_t *) pEvent);
   22d9a:	6879      	ldr	r1, [r7, #4]
   22d9c:	68f8      	ldr	r0, [r7, #12]
   22d9e:	f000 fe5f 	bl	23a60 <dmConnSmExecute>
  }
}
   22da2:	bf00      	nop
   22da4:	3710      	adds	r7, #16
   22da6:	46bd      	mov	sp, r7
   22da8:	bd80      	pop	{r7, pc}
	...

00022dac <dmConn2MsgHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConn2MsgHandler(wsfMsgHdr_t *pMsg)
{
   22dac:	b5f0      	push	{r4, r5, r6, r7, lr}
   22dae:	b08b      	sub	sp, #44	; 0x2c
   22db0:	af04      	add	r7, sp, #16
   22db2:	6078      	str	r0, [r7, #4]
  dmConnCcb_t *pCcb;

  /* look up ccb from conn id */
  if ((pCcb = dmConnCcbById((dmConnId_t) pMsg->param)) != NULL)
   22db4:	687b      	ldr	r3, [r7, #4]
   22db6:	881b      	ldrh	r3, [r3, #0]
   22db8:	b2db      	uxtb	r3, r3
   22dba:	4618      	mov	r0, r3
   22dbc:	f7ff fd58 	bl	22870 <dmConnCcbById>
   22dc0:	6178      	str	r0, [r7, #20]
   22dc2:	697b      	ldr	r3, [r7, #20]
   22dc4:	2b00      	cmp	r3, #0
   22dc6:	d051      	beq.n	22e6c <dmConn2MsgHandler+0xc0>
  {
    dmConn2Msg_t *pConn2Msg = (dmConn2Msg_t *) pMsg;
   22dc8:	687b      	ldr	r3, [r7, #4]
   22dca:	613b      	str	r3, [r7, #16]

    /* handle incoming message */
    switch (pMsg->event)
   22dcc:	687b      	ldr	r3, [r7, #4]
   22dce:	789b      	ldrb	r3, [r3, #2]
   22dd0:	3b41      	subs	r3, #65	; 0x41
   22dd2:	2b04      	cmp	r3, #4
   22dd4:	d84c      	bhi.n	22e70 <dmConn2MsgHandler+0xc4>
   22dd6:	a201      	add	r2, pc, #4	; (adr r2, 22ddc <dmConn2MsgHandler+0x30>)
   22dd8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   22ddc:	00022df1 	.word	0x00022df1
   22de0:	00022dfd 	.word	0x00022dfd
   22de4:	00022e31 	.word	0x00022e31
   22de8:	00022e43 	.word	0x00022e43
   22dec:	00022e5b 	.word	0x00022e5b
    {
      case DM_CONN_MSG_API_READ_RSSI:
        HciReadRssiCmd(pCcb->handle);
   22df0:	697b      	ldr	r3, [r7, #20]
   22df2:	899b      	ldrh	r3, [r3, #12]
   22df4:	4618      	mov	r0, r3
   22df6:	f002 fcfd 	bl	257f4 <HciReadRssiCmd>
        break;
   22dfa:	e03a      	b.n	22e72 <dmConn2MsgHandler+0xc6>

      case DM_CONN_MSG_API_REM_CONN_PARAM_REQ_REPLY:
        {
          hciConnSpec_t *pConnSpec = &pConn2Msg->apiRemConnParamReqReply.connSpec;
   22dfc:	693b      	ldr	r3, [r7, #16]
   22dfe:	3304      	adds	r3, #4
   22e00:	60bb      	str	r3, [r7, #8]

          HciLeRemoteConnParamReqReply(pCcb->handle, pConnSpec->connIntervalMin,
   22e02:	697b      	ldr	r3, [r7, #20]
   22e04:	8998      	ldrh	r0, [r3, #12]
   22e06:	68bb      	ldr	r3, [r7, #8]
   22e08:	881c      	ldrh	r4, [r3, #0]
   22e0a:	68bb      	ldr	r3, [r7, #8]
   22e0c:	885d      	ldrh	r5, [r3, #2]
   22e0e:	68bb      	ldr	r3, [r7, #8]
   22e10:	889e      	ldrh	r6, [r3, #4]
   22e12:	68bb      	ldr	r3, [r7, #8]
   22e14:	88db      	ldrh	r3, [r3, #6]
   22e16:	68ba      	ldr	r2, [r7, #8]
   22e18:	8912      	ldrh	r2, [r2, #8]
   22e1a:	68b9      	ldr	r1, [r7, #8]
   22e1c:	8949      	ldrh	r1, [r1, #10]
   22e1e:	9102      	str	r1, [sp, #8]
   22e20:	9201      	str	r2, [sp, #4]
   22e22:	9300      	str	r3, [sp, #0]
   22e24:	4633      	mov	r3, r6
   22e26:	462a      	mov	r2, r5
   22e28:	4621      	mov	r1, r4
   22e2a:	f002 f96f 	bl	2510c <HciLeRemoteConnParamReqReply>
                                       pConnSpec->connIntervalMax, pConnSpec->connLatency,
                                       pConnSpec->supTimeout, pConnSpec->minCeLen,
                                       pConnSpec->maxCeLen);
        }
        break;
   22e2e:	e020      	b.n	22e72 <dmConn2MsgHandler+0xc6>

      case DM_CONN_MSG_API_REM_CONN_PARAM_REQ_NEG_REPLY:
        HciLeRemoteConnParamReqNegReply(pCcb->handle, pConn2Msg->apiRemConnParamReqNegReply.reason);
   22e30:	697b      	ldr	r3, [r7, #20]
   22e32:	899a      	ldrh	r2, [r3, #12]
   22e34:	693b      	ldr	r3, [r7, #16]
   22e36:	791b      	ldrb	r3, [r3, #4]
   22e38:	4619      	mov	r1, r3
   22e3a:	4610      	mov	r0, r2
   22e3c:	f002 f9ea 	bl	25214 <HciLeRemoteConnParamReqNegReply>
        break;
   22e40:	e017      	b.n	22e72 <dmConn2MsgHandler+0xc6>

      case DM_CONN_MSG_API_SET_DATA_LEN:
        {
          dmConnApiSetDataLen_t *pDataLen = &pConn2Msg->apiSetDataLen;
   22e42:	693b      	ldr	r3, [r7, #16]
   22e44:	60fb      	str	r3, [r7, #12]

          HciLeSetDataLen(pCcb->handle, pDataLen->txOctets, pDataLen->txTime);
   22e46:	697b      	ldr	r3, [r7, #20]
   22e48:	8998      	ldrh	r0, [r3, #12]
   22e4a:	68fb      	ldr	r3, [r7, #12]
   22e4c:	8899      	ldrh	r1, [r3, #4]
   22e4e:	68fb      	ldr	r3, [r7, #12]
   22e50:	88db      	ldrh	r3, [r3, #6]
   22e52:	461a      	mov	r2, r3
   22e54:	f002 fa0c 	bl	25270 <HciLeSetDataLen>
        }
        break;
   22e58:	e00b      	b.n	22e72 <dmConn2MsgHandler+0xc6>

      case DM_CONN_MSG_API_WRITE_AUTH_TO:
        HciWriteAuthPayloadTimeout(pCcb->handle, pConn2Msg->apiWriteAuthPayloadTo.timeout);
   22e5a:	697b      	ldr	r3, [r7, #20]
   22e5c:	899a      	ldrh	r2, [r3, #12]
   22e5e:	693b      	ldr	r3, [r7, #16]
   22e60:	889b      	ldrh	r3, [r3, #4]
   22e62:	4619      	mov	r1, r3
   22e64:	4610      	mov	r0, r2
   22e66:	f002 fd5d 	bl	25924 <HciWriteAuthPayloadTimeout>
        break;
   22e6a:	e002      	b.n	22e72 <dmConn2MsgHandler+0xc6>

      default:
        /* should never get here */
        break;
    }
  }
   22e6c:	bf00      	nop
   22e6e:	e000      	b.n	22e72 <dmConn2MsgHandler+0xc6>
        break;
   22e70:	bf00      	nop
}
   22e72:	bf00      	nop
   22e74:	371c      	adds	r7, #28
   22e76:	46bd      	mov	sp, r7
   22e78:	bdf0      	pop	{r4, r5, r6, r7, pc}
   22e7a:	bf00      	nop

00022e7c <dmConn2HciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConn2HciHandler(hciEvt_t *pEvent)
{
   22e7c:	b580      	push	{r7, lr}
   22e7e:	b084      	sub	sp, #16
   22e80:	af00      	add	r7, sp, #0
   22e82:	6078      	str	r0, [r7, #4]
  dmConnCcb_t *pCcb;

  /* look up ccb from conn handle */
  if ((pCcb = dmConnCcbByHandle(pEvent->hdr.param)) != NULL)
   22e84:	687b      	ldr	r3, [r7, #4]
   22e86:	881b      	ldrh	r3, [r3, #0]
   22e88:	4618      	mov	r0, r3
   22e8a:	f7ff fc99 	bl	227c0 <dmConnCcbByHandle>
   22e8e:	60f8      	str	r0, [r7, #12]
   22e90:	68fb      	ldr	r3, [r7, #12]
   22e92:	2b00      	cmp	r3, #0
   22e94:	d06f      	beq.n	22f76 <dmConn2HciHandler+0xfa>
  {
    /* handle incoming event */
    switch (pEvent->hdr.event)
   22e96:	687b      	ldr	r3, [r7, #4]
   22e98:	789b      	ldrb	r3, [r3, #2]
   22e9a:	3b07      	subs	r3, #7
   22e9c:	2b21      	cmp	r3, #33	; 0x21
   22e9e:	d86c      	bhi.n	22f7a <dmConn2HciHandler+0xfe>
   22ea0:	a201      	add	r2, pc, #4	; (adr r2, 22ea8 <dmConn2HciHandler+0x2c>)
   22ea2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   22ea6:	bf00      	nop
   22ea8:	00022f31 	.word	0x00022f31
   22eac:	00022f7b 	.word	0x00022f7b
   22eb0:	00022f7b 	.word	0x00022f7b
   22eb4:	00022f6d 	.word	0x00022f6d
   22eb8:	00022f63 	.word	0x00022f63
   22ebc:	00022f7b 	.word	0x00022f7b
   22ec0:	00022f7b 	.word	0x00022f7b
   22ec4:	00022f7b 	.word	0x00022f7b
   22ec8:	00022f7b 	.word	0x00022f7b
   22ecc:	00022f7b 	.word	0x00022f7b
   22ed0:	00022f7b 	.word	0x00022f7b
   22ed4:	00022f7b 	.word	0x00022f7b
   22ed8:	00022f7b 	.word	0x00022f7b
   22edc:	00022f7b 	.word	0x00022f7b
   22ee0:	00022f7b 	.word	0x00022f7b
   22ee4:	00022f7b 	.word	0x00022f7b
   22ee8:	00022f7b 	.word	0x00022f7b
   22eec:	00022f7b 	.word	0x00022f7b
   22ef0:	00022f7b 	.word	0x00022f7b
   22ef4:	00022f7b 	.word	0x00022f7b
   22ef8:	00022f7b 	.word	0x00022f7b
   22efc:	00022f7b 	.word	0x00022f7b
   22f00:	00022f7b 	.word	0x00022f7b
   22f04:	00022f7b 	.word	0x00022f7b
   22f08:	00022f7b 	.word	0x00022f7b
   22f0c:	00022f7b 	.word	0x00022f7b
   22f10:	00022f7b 	.word	0x00022f7b
   22f14:	00022f7b 	.word	0x00022f7b
   22f18:	00022f3b 	.word	0x00022f3b
   22f1c:	00022f45 	.word	0x00022f45
   22f20:	00022f7b 	.word	0x00022f7b
   22f24:	00022f7b 	.word	0x00022f7b
   22f28:	00022f4f 	.word	0x00022f4f
   22f2c:	00022f59 	.word	0x00022f59
    {
      case HCI_READ_RSSI_CMD_CMPL_CBACK_EVT:
        dmConn2ActRssiRead(pCcb, pEvent);
   22f30:	6879      	ldr	r1, [r7, #4]
   22f32:	68f8      	ldr	r0, [r7, #12]
   22f34:	f000 f826 	bl	22f84 <dmConn2ActRssiRead>
        break;
   22f38:	e020      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_LE_REM_CONN_PARAM_REQ_CBACK_EVT:
        dmConn2ActRemoteConnParamReq(pCcb, pEvent);
   22f3a:	6879      	ldr	r1, [r7, #4]
   22f3c:	68f8      	ldr	r0, [r7, #12]
   22f3e:	f000 f845 	bl	22fcc <dmConn2ActRemoteConnParamReq>
        break;
   22f42:	e01b      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_LE_DATA_LEN_CHANGE_CBACK_EVT:
        dmConn2ActDataLenChange(pCcb, pEvent);
   22f44:	6879      	ldr	r1, [r7, #4]
   22f46:	68f8      	ldr	r0, [r7, #12]
   22f48:	f000 f86a 	bl	23020 <dmConn2ActDataLenChange>
        break;
   22f4c:	e016      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_WRITE_AUTH_PAYLOAD_TO_CMD_CMPL_CBACK_EVT:
        dmConn2ActWriteAuthToCmpl(pCcb, pEvent);
   22f4e:	6879      	ldr	r1, [r7, #4]
   22f50:	68f8      	ldr	r0, [r7, #12]
   22f52:	f000 f88f 	bl	23074 <dmConn2ActWriteAuthToCmpl>
        break;
   22f56:	e011      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_AUTH_PAYLOAD_TO_EXPIRED_CBACK_EVT:
        dmConn2ActAuthToExpired(pCcb, pEvent);
   22f58:	6879      	ldr	r1, [r7, #4]
   22f5a:	68f8      	ldr	r0, [r7, #12]
   22f5c:	f000 f8aa 	bl	230b4 <dmConn2ActAuthToExpired>
        break;
   22f60:	e00c      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_LE_READ_REMOTE_FEAT_CMPL_CBACK_EVT:
        dmConn2ActReadRemoteFeaturesCmpl(pCcb, pEvent);
   22f62:	6879      	ldr	r1, [r7, #4]
   22f64:	68f8      	ldr	r0, [r7, #12]
   22f66:	f000 f8c3 	bl	230f0 <dmConn2ActReadRemoteFeaturesCmpl>
        break;
   22f6a:	e007      	b.n	22f7c <dmConn2HciHandler+0x100>

      case HCI_READ_REMOTE_VER_INFO_CMPL_CBACK_EVT:
        dmConn2ActReadRemoteVerInfoCmpl(pCcb, pEvent);
   22f6c:	6879      	ldr	r1, [r7, #4]
   22f6e:	68f8      	ldr	r0, [r7, #12]
   22f70:	f000 f8fc 	bl	2316c <dmConn2ActReadRemoteVerInfoCmpl>
        break;
   22f74:	e002      	b.n	22f7c <dmConn2HciHandler+0x100>

      default:
        /* should never get here */
        break;
    }
  }
   22f76:	bf00      	nop
   22f78:	e000      	b.n	22f7c <dmConn2HciHandler+0x100>
        break;
   22f7a:	bf00      	nop
}
   22f7c:	bf00      	nop
   22f7e:	3710      	adds	r7, #16
   22f80:	46bd      	mov	sp, r7
   22f82:	bd80      	pop	{r7, pc}

00022f84 <dmConn2ActRssiRead>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActRssiRead(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   22f84:	b580      	push	{r7, lr}
   22f86:	b086      	sub	sp, #24
   22f88:	af00      	add	r7, sp, #0
   22f8a:	6078      	str	r0, [r7, #4]
   22f8c:	6039      	str	r1, [r7, #0]
  hciReadRssiCmdCmplEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_CONN_READ_RSSI_IND;
   22f8e:	2339      	movs	r3, #57	; 0x39
   22f90:	73bb      	strb	r3, [r7, #14]
  evt.hdr.param = pCcb->connId;
   22f92:	687b      	ldr	r3, [r7, #4]
   22f94:	7c1b      	ldrb	r3, [r3, #16]
   22f96:	b29b      	uxth	r3, r3
   22f98:	81bb      	strh	r3, [r7, #12]
  evt.status = evt.hdr.status = (uint8_t) pEvent->readRssiCmdCmpl.status;
   22f9a:	683b      	ldr	r3, [r7, #0]
   22f9c:	791b      	ldrb	r3, [r3, #4]
   22f9e:	73fb      	strb	r3, [r7, #15]
   22fa0:	7bfb      	ldrb	r3, [r7, #15]
   22fa2:	743b      	strb	r3, [r7, #16]
  evt.handle = pCcb->handle;
   22fa4:	687b      	ldr	r3, [r7, #4]
   22fa6:	899b      	ldrh	r3, [r3, #12]
   22fa8:	827b      	strh	r3, [r7, #18]
  evt.rssi = pEvent->readRssiCmdCmpl.rssi;
   22faa:	683b      	ldr	r3, [r7, #0]
   22fac:	f993 3008 	ldrsb.w	r3, [r3, #8]
   22fb0:	753b      	strb	r3, [r7, #20]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   22fb2:	4b05      	ldr	r3, [pc, #20]	; (22fc8 <dmConn2ActRssiRead+0x44>)
   22fb4:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   22fb8:	f107 020c 	add.w	r2, r7, #12
   22fbc:	4610      	mov	r0, r2
   22fbe:	4798      	blx	r3
}
   22fc0:	bf00      	nop
   22fc2:	3718      	adds	r7, #24
   22fc4:	46bd      	mov	sp, r7
   22fc6:	bd80      	pop	{r7, pc}
   22fc8:	10011218 	.word	0x10011218

00022fcc <dmConn2ActRemoteConnParamReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActRemoteConnParamReq(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   22fcc:	b580      	push	{r7, lr}
   22fce:	b086      	sub	sp, #24
   22fd0:	af00      	add	r7, sp, #0
   22fd2:	6078      	str	r0, [r7, #4]
   22fd4:	6039      	str	r1, [r7, #0]
  hciLeRemConnParamReqEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_REM_CONN_PARAM_REQ_IND;
   22fd6:	2340      	movs	r3, #64	; 0x40
   22fd8:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   22fda:	687b      	ldr	r3, [r7, #4]
   22fdc:	7c1b      	ldrb	r3, [r3, #16]
   22fde:	b29b      	uxth	r3, r3
   22fe0:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   22fe2:	2300      	movs	r3, #0
   22fe4:	72fb      	strb	r3, [r7, #11]
  evt.handle = pCcb->handle;
   22fe6:	687b      	ldr	r3, [r7, #4]
   22fe8:	899b      	ldrh	r3, [r3, #12]
   22fea:	81bb      	strh	r3, [r7, #12]
  evt.intervalMin = pEvent->leRemConnParamReq.intervalMin;
   22fec:	683b      	ldr	r3, [r7, #0]
   22fee:	88db      	ldrh	r3, [r3, #6]
   22ff0:	81fb      	strh	r3, [r7, #14]
  evt.intervalMax = pEvent->leRemConnParamReq.intervalMax;
   22ff2:	683b      	ldr	r3, [r7, #0]
   22ff4:	891b      	ldrh	r3, [r3, #8]
   22ff6:	823b      	strh	r3, [r7, #16]
  evt.latency = pEvent->leRemConnParamReq.latency;
   22ff8:	683b      	ldr	r3, [r7, #0]
   22ffa:	895b      	ldrh	r3, [r3, #10]
   22ffc:	827b      	strh	r3, [r7, #18]
  evt.timeout = pEvent->leRemConnParamReq.timeout;
   22ffe:	683b      	ldr	r3, [r7, #0]
   23000:	899b      	ldrh	r3, [r3, #12]
   23002:	82bb      	strh	r3, [r7, #20]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   23004:	4b05      	ldr	r3, [pc, #20]	; (2301c <dmConn2ActRemoteConnParamReq+0x50>)
   23006:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   2300a:	f107 0208 	add.w	r2, r7, #8
   2300e:	4610      	mov	r0, r2
   23010:	4798      	blx	r3
}
   23012:	bf00      	nop
   23014:	3718      	adds	r7, #24
   23016:	46bd      	mov	sp, r7
   23018:	bd80      	pop	{r7, pc}
   2301a:	bf00      	nop
   2301c:	10011218 	.word	0x10011218

00023020 <dmConn2ActDataLenChange>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActDataLenChange(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   23020:	b580      	push	{r7, lr}
   23022:	b086      	sub	sp, #24
   23024:	af00      	add	r7, sp, #0
   23026:	6078      	str	r0, [r7, #4]
   23028:	6039      	str	r1, [r7, #0]
  hciLeDataLenChangeEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_CONN_DATA_LEN_CHANGE_IND;
   2302a:	2341      	movs	r3, #65	; 0x41
   2302c:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   2302e:	687b      	ldr	r3, [r7, #4]
   23030:	7c1b      	ldrb	r3, [r3, #16]
   23032:	b29b      	uxth	r3, r3
   23034:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   23036:	2300      	movs	r3, #0
   23038:	72fb      	strb	r3, [r7, #11]
  evt.handle = pCcb->handle;
   2303a:	687b      	ldr	r3, [r7, #4]
   2303c:	899b      	ldrh	r3, [r3, #12]
   2303e:	81bb      	strh	r3, [r7, #12]
  evt.maxTxOctets = pEvent->leDataLenChange.maxTxOctets;
   23040:	683b      	ldr	r3, [r7, #0]
   23042:	88db      	ldrh	r3, [r3, #6]
   23044:	81fb      	strh	r3, [r7, #14]
  evt.maxTxTime = pEvent->leDataLenChange.maxTxTime;
   23046:	683b      	ldr	r3, [r7, #0]
   23048:	891b      	ldrh	r3, [r3, #8]
   2304a:	823b      	strh	r3, [r7, #16]
  evt.maxRxOctets = pEvent->leDataLenChange.maxRxOctets;
   2304c:	683b      	ldr	r3, [r7, #0]
   2304e:	895b      	ldrh	r3, [r3, #10]
   23050:	827b      	strh	r3, [r7, #18]
  evt.maxRxTime = pEvent->leDataLenChange.maxRxTime;
   23052:	683b      	ldr	r3, [r7, #0]
   23054:	899b      	ldrh	r3, [r3, #12]
   23056:	82bb      	strh	r3, [r7, #20]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   23058:	4b05      	ldr	r3, [pc, #20]	; (23070 <dmConn2ActDataLenChange+0x50>)
   2305a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   2305e:	f107 0208 	add.w	r2, r7, #8
   23062:	4610      	mov	r0, r2
   23064:	4798      	blx	r3
}
   23066:	bf00      	nop
   23068:	3718      	adds	r7, #24
   2306a:	46bd      	mov	sp, r7
   2306c:	bd80      	pop	{r7, pc}
   2306e:	bf00      	nop
   23070:	10011218 	.word	0x10011218

00023074 <dmConn2ActWriteAuthToCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActWriteAuthToCmpl(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   23074:	b580      	push	{r7, lr}
   23076:	b084      	sub	sp, #16
   23078:	af00      	add	r7, sp, #0
   2307a:	6078      	str	r0, [r7, #4]
   2307c:	6039      	str	r1, [r7, #0]
  hciWriteAuthPayloadToCmdCmplEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_CONN_WRITE_AUTH_TO_IND;
   2307e:	2342      	movs	r3, #66	; 0x42
   23080:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   23082:	687b      	ldr	r3, [r7, #4]
   23084:	7c1b      	ldrb	r3, [r3, #16]
   23086:	b29b      	uxth	r3, r3
   23088:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   2308a:	2300      	movs	r3, #0
   2308c:	72fb      	strb	r3, [r7, #11]
  evt.handle = pEvent->writeAuthPayloadToCmdCmpl.handle;
   2308e:	683b      	ldr	r3, [r7, #0]
   23090:	88db      	ldrh	r3, [r3, #6]
   23092:	81fb      	strh	r3, [r7, #14]
  evt.status = pEvent->writeAuthPayloadToCmdCmpl.status;
   23094:	683b      	ldr	r3, [r7, #0]
   23096:	791b      	ldrb	r3, [r3, #4]
   23098:	733b      	strb	r3, [r7, #12]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   2309a:	4b05      	ldr	r3, [pc, #20]	; (230b0 <dmConn2ActWriteAuthToCmpl+0x3c>)
   2309c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   230a0:	f107 0208 	add.w	r2, r7, #8
   230a4:	4610      	mov	r0, r2
   230a6:	4798      	blx	r3
}
   230a8:	bf00      	nop
   230aa:	3710      	adds	r7, #16
   230ac:	46bd      	mov	sp, r7
   230ae:	bd80      	pop	{r7, pc}
   230b0:	10011218 	.word	0x10011218

000230b4 <dmConn2ActAuthToExpired>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActAuthToExpired(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   230b4:	b580      	push	{r7, lr}
   230b6:	b084      	sub	sp, #16
   230b8:	af00      	add	r7, sp, #0
   230ba:	6078      	str	r0, [r7, #4]
   230bc:	6039      	str	r1, [r7, #0]
  hciAuthPayloadToExpiredEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_CONN_AUTH_TO_EXPIRED_IND;
   230be:	2343      	movs	r3, #67	; 0x43
   230c0:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   230c2:	687b      	ldr	r3, [r7, #4]
   230c4:	7c1b      	ldrb	r3, [r3, #16]
   230c6:	b29b      	uxth	r3, r3
   230c8:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   230ca:	2300      	movs	r3, #0
   230cc:	72fb      	strb	r3, [r7, #11]
  evt.handle = pEvent->authPayloadToExpired.handle;
   230ce:	683b      	ldr	r3, [r7, #0]
   230d0:	889b      	ldrh	r3, [r3, #4]
   230d2:	81bb      	strh	r3, [r7, #12]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   230d4:	4b05      	ldr	r3, [pc, #20]	; (230ec <dmConn2ActAuthToExpired+0x38>)
   230d6:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   230da:	f107 0208 	add.w	r2, r7, #8
   230de:	4610      	mov	r0, r2
   230e0:	4798      	blx	r3
}
   230e2:	bf00      	nop
   230e4:	3710      	adds	r7, #16
   230e6:	46bd      	mov	sp, r7
   230e8:	bd80      	pop	{r7, pc}
   230ea:	bf00      	nop
   230ec:	10011218 	.word	0x10011218

000230f0 <dmConn2ActReadRemoteFeaturesCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActReadRemoteFeaturesCmpl(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   230f0:	b580      	push	{r7, lr}
   230f2:	b086      	sub	sp, #24
   230f4:	af00      	add	r7, sp, #0
   230f6:	6078      	str	r0, [r7, #4]
   230f8:	6039      	str	r1, [r7, #0]
  hciLeReadRemoteFeatCmplEvt_t evt;

  /* Save the features */
  BYTES_TO_UINT32(pCcb->features, pEvent->leReadRemoteFeatCmpl.features);
   230fa:	683b      	ldr	r3, [r7, #0]
   230fc:	7a1b      	ldrb	r3, [r3, #8]
   230fe:	461a      	mov	r2, r3
   23100:	683b      	ldr	r3, [r7, #0]
   23102:	7a5b      	ldrb	r3, [r3, #9]
   23104:	021b      	lsls	r3, r3, #8
   23106:	441a      	add	r2, r3
   23108:	683b      	ldr	r3, [r7, #0]
   2310a:	7a9b      	ldrb	r3, [r3, #10]
   2310c:	041b      	lsls	r3, r3, #16
   2310e:	441a      	add	r2, r3
   23110:	683b      	ldr	r3, [r7, #0]
   23112:	7adb      	ldrb	r3, [r3, #11]
   23114:	061b      	lsls	r3, r3, #24
   23116:	441a      	add	r2, r3
   23118:	687b      	ldr	r3, [r7, #4]
   2311a:	629a      	str	r2, [r3, #40]	; 0x28
  pCcb->featuresPresent = TRUE;
   2311c:	687b      	ldr	r3, [r7, #4]
   2311e:	2201      	movs	r2, #1
   23120:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c

  /* call callback */
  evt.hdr.event = DM_REMOTE_FEATURES_IND;
   23124:	2357      	movs	r3, #87	; 0x57
   23126:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   23128:	687b      	ldr	r3, [r7, #4]
   2312a:	7c1b      	ldrb	r3, [r3, #16]
   2312c:	b29b      	uxth	r3, r3
   2312e:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   23130:	2300      	movs	r3, #0
   23132:	72fb      	strb	r3, [r7, #11]

  evt.status = pEvent->leReadRemoteFeatCmpl.status;
   23134:	683b      	ldr	r3, [r7, #0]
   23136:	791b      	ldrb	r3, [r3, #4]
   23138:	733b      	strb	r3, [r7, #12]
  evt.handle = pEvent->leReadRemoteFeatCmpl.handle;
   2313a:	683b      	ldr	r3, [r7, #0]
   2313c:	88db      	ldrh	r3, [r3, #6]
   2313e:	81fb      	strh	r3, [r7, #14]
  memcpy(evt.features, pEvent->leReadRemoteFeatCmpl.features, sizeof(evt.features));
   23140:	683b      	ldr	r3, [r7, #0]
   23142:	f103 0208 	add.w	r2, r3, #8
   23146:	f107 0310 	add.w	r3, r7, #16
   2314a:	6810      	ldr	r0, [r2, #0]
   2314c:	6851      	ldr	r1, [r2, #4]
   2314e:	c303      	stmia	r3!, {r0, r1}

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   23150:	4b05      	ldr	r3, [pc, #20]	; (23168 <dmConn2ActReadRemoteFeaturesCmpl+0x78>)
   23152:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   23156:	f107 0208 	add.w	r2, r7, #8
   2315a:	4610      	mov	r0, r2
   2315c:	4798      	blx	r3
}
   2315e:	bf00      	nop
   23160:	3718      	adds	r7, #24
   23162:	46bd      	mov	sp, r7
   23164:	bd80      	pop	{r7, pc}
   23166:	bf00      	nop
   23168:	10011218 	.word	0x10011218

0002316c <dmConn2ActReadRemoteVerInfoCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConn2ActReadRemoteVerInfoCmpl(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   2316c:	b580      	push	{r7, lr}
   2316e:	b086      	sub	sp, #24
   23170:	af00      	add	r7, sp, #0
   23172:	6078      	str	r0, [r7, #4]
   23174:	6039      	str	r1, [r7, #0]
  hciReadRemoteVerInfoCmplEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_READ_REMOTE_VER_INFO_IND;
   23176:	2358      	movs	r3, #88	; 0x58
   23178:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   2317a:	687b      	ldr	r3, [r7, #4]
   2317c:	7c1b      	ldrb	r3, [r3, #16]
   2317e:	b29b      	uxth	r3, r3
   23180:	813b      	strh	r3, [r7, #8]
  evt.hdr.status = HCI_SUCCESS;
   23182:	2300      	movs	r3, #0
   23184:	72fb      	strb	r3, [r7, #11]

  evt.status = pEvent->readRemoteVerInfoCmpl.status;
   23186:	683b      	ldr	r3, [r7, #0]
   23188:	791b      	ldrb	r3, [r3, #4]
   2318a:	733b      	strb	r3, [r7, #12]
  evt.handle = pEvent->readRemoteVerInfoCmpl.handle;
   2318c:	683b      	ldr	r3, [r7, #0]
   2318e:	88db      	ldrh	r3, [r3, #6]
   23190:	81fb      	strh	r3, [r7, #14]
  evt.version = pEvent->readRemoteVerInfoCmpl.version;
   23192:	683b      	ldr	r3, [r7, #0]
   23194:	7a1b      	ldrb	r3, [r3, #8]
   23196:	743b      	strb	r3, [r7, #16]
  evt.mfrName = pEvent->readRemoteVerInfoCmpl.mfrName;
   23198:	683b      	ldr	r3, [r7, #0]
   2319a:	895b      	ldrh	r3, [r3, #10]
   2319c:	827b      	strh	r3, [r7, #18]
  evt.subversion = pEvent->readRemoteVerInfoCmpl.subversion;
   2319e:	683b      	ldr	r3, [r7, #0]
   231a0:	899b      	ldrh	r3, [r3, #12]
   231a2:	82bb      	strh	r3, [r7, #20]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   231a4:	4b05      	ldr	r3, [pc, #20]	; (231bc <dmConn2ActReadRemoteVerInfoCmpl+0x50>)
   231a6:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   231aa:	f107 0208 	add.w	r2, r7, #8
   231ae:	4610      	mov	r0, r2
   231b0:	4798      	blx	r3
}
   231b2:	bf00      	nop
   231b4:	3718      	adds	r7, #24
   231b6:	46bd      	mov	sp, r7
   231b8:	bd80      	pop	{r7, pc}
   231ba:	bf00      	nop
   231bc:	10011218 	.word	0x10011218

000231c0 <DmConnInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnInit(void)
{
   231c0:	b480      	push	{r7}
   231c2:	af00      	add	r7, sp, #0
  dmFcnIfTbl[DM_ID_CONN] = (dmFcnIf_t *) &dmConnFcnIf;
   231c4:	4b06      	ldr	r3, [pc, #24]	; (231e0 <DmConnInit+0x20>)
   231c6:	4a07      	ldr	r2, [pc, #28]	; (231e4 <DmConnInit+0x24>)
   231c8:	60da      	str	r2, [r3, #12]
  dmFcnIfTbl[DM_ID_CONN_2] = (dmFcnIf_t *) &dmConn2FcnIf;
   231ca:	4b05      	ldr	r3, [pc, #20]	; (231e0 <DmConnInit+0x20>)
   231cc:	4a06      	ldr	r2, [pc, #24]	; (231e8 <DmConnInit+0x28>)
   231ce:	611a      	str	r2, [r3, #16]
  dmConnActSet[DM_CONN_ACT_SET_MAIN] = (dmConnAct_t *) dmConnActSetMain;
   231d0:	4b06      	ldr	r3, [pc, #24]	; (231ec <DmConnInit+0x2c>)
   231d2:	4a07      	ldr	r2, [pc, #28]	; (231f0 <DmConnInit+0x30>)
   231d4:	601a      	str	r2, [r3, #0]
}
   231d6:	bf00      	nop
   231d8:	46bd      	mov	sp, r7
   231da:	f85d 7b04 	ldr.w	r7, [sp], #4
   231de:	4770      	bx	lr
   231e0:	10002b90 	.word	0x10002b90
   231e4:	00045c24 	.word	0x00045c24
   231e8:	00045c30 	.word	0x00045c30
   231ec:	100112dc 	.word	0x100112dc
   231f0:	00045c0c 	.word	0x00045c0c

000231f4 <DmConnRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnRegister(uint8_t clientId, dmCback_t cback)
{
   231f4:	b580      	push	{r7, lr}
   231f6:	b082      	sub	sp, #8
   231f8:	af00      	add	r7, sp, #0
   231fa:	4603      	mov	r3, r0
   231fc:	6039      	str	r1, [r7, #0]
   231fe:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT(clientId < DM_CLIENT_ID_MAX);

  /* store callback */
  WsfTaskLock();
   23200:	f00a f800 	bl	2d204 <WsfTaskLock>
  dmConnCb.connCback[clientId] = cback;
   23204:	79fb      	ldrb	r3, [r7, #7]
   23206:	4905      	ldr	r1, [pc, #20]	; (2321c <DmConnRegister+0x28>)
   23208:	3324      	adds	r3, #36	; 0x24
   2320a:	683a      	ldr	r2, [r7, #0]
   2320c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  WsfTaskUnlock();
   23210:	f009 fffe 	bl	2d210 <WsfTaskUnlock>
}
   23214:	bf00      	nop
   23216:	3708      	adds	r7, #8
   23218:	46bd      	mov	sp, r7
   2321a:	bd80      	pop	{r7, pc}
   2321c:	10011218 	.word	0x10011218

00023220 <DmConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnClose(uint8_t clientId, dmConnId_t connId, uint8_t reason)
{
   23220:	b580      	push	{r7, lr}
   23222:	b084      	sub	sp, #16
   23224:	af00      	add	r7, sp, #0
   23226:	4603      	mov	r3, r0
   23228:	71fb      	strb	r3, [r7, #7]
   2322a:	460b      	mov	r3, r1
   2322c:	71bb      	strb	r3, [r7, #6]
   2322e:	4613      	mov	r3, r2
   23230:	717b      	strb	r3, [r7, #5]
  dmConnApiClose_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiClose_t))) != NULL)
   23232:	2006      	movs	r0, #6
   23234:	f009 ff3b 	bl	2d0ae <WsfMsgAlloc>
   23238:	60f8      	str	r0, [r7, #12]
   2323a:	68fb      	ldr	r3, [r7, #12]
   2323c:	2b00      	cmp	r3, #0
   2323e:	d016      	beq.n	2326e <DmConnClose+0x4e>
  {
    pMsg->hdr.event = DM_CONN_MSG_API_CLOSE;
   23240:	68fb      	ldr	r3, [r7, #12]
   23242:	2231      	movs	r2, #49	; 0x31
   23244:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   23246:	79bb      	ldrb	r3, [r7, #6]
   23248:	b29a      	uxth	r2, r3
   2324a:	68fb      	ldr	r3, [r7, #12]
   2324c:	801a      	strh	r2, [r3, #0]
    pMsg->hdr.status = pMsg->reason = reason;
   2324e:	68fb      	ldr	r3, [r7, #12]
   23250:	797a      	ldrb	r2, [r7, #5]
   23252:	711a      	strb	r2, [r3, #4]
   23254:	68fb      	ldr	r3, [r7, #12]
   23256:	791a      	ldrb	r2, [r3, #4]
   23258:	68fb      	ldr	r3, [r7, #12]
   2325a:	70da      	strb	r2, [r3, #3]
    pMsg->clientId = clientId;
   2325c:	68fb      	ldr	r3, [r7, #12]
   2325e:	79fa      	ldrb	r2, [r7, #7]
   23260:	715a      	strb	r2, [r3, #5]

    WsfMsgSend(dmCb.handlerId, pMsg);
   23262:	4b05      	ldr	r3, [pc, #20]	; (23278 <DmConnClose+0x58>)
   23264:	7b1b      	ldrb	r3, [r3, #12]
   23266:	68f9      	ldr	r1, [r7, #12]
   23268:	4618      	mov	r0, r3
   2326a:	f009 ff44 	bl	2d0f6 <WsfMsgSend>
  }
}
   2326e:	bf00      	nop
   23270:	3710      	adds	r7, #16
   23272:	46bd      	mov	sp, r7
   23274:	bd80      	pop	{r7, pc}
   23276:	bf00      	nop
   23278:	100112ec 	.word	0x100112ec

0002327c <DmReadRemoteFeatures>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmReadRemoteFeatures(dmConnId_t connId)
{
   2327c:	b580      	push	{r7, lr}
   2327e:	b088      	sub	sp, #32
   23280:	af00      	add	r7, sp, #0
   23282:	4603      	mov	r3, r0
   23284:	71fb      	strb	r3, [r7, #7]
  dmConnCcb_t *pCcb;

  /* look up ccb from conn handle */
  if ((pCcb = dmConnCcbById(connId)) != NULL)
   23286:	79fb      	ldrb	r3, [r7, #7]
   23288:	4618      	mov	r0, r3
   2328a:	f7ff faf1 	bl	22870 <dmConnCcbById>
   2328e:	61f8      	str	r0, [r7, #28]
   23290:	69fb      	ldr	r3, [r7, #28]
   23292:	2b00      	cmp	r3, #0
   23294:	d041      	beq.n	2331a <DmReadRemoteFeatures+0x9e>
  {
    if (pCcb->featuresPresent)
   23296:	69fb      	ldr	r3, [r7, #28]
   23298:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   2329c:	2b00      	cmp	r3, #0
   2329e:	d037      	beq.n	23310 <DmReadRemoteFeatures+0x94>
    {
      hciLeReadRemoteFeatCmplEvt_t evt;
      uint8_t *p = evt.features;
   232a0:	f107 0308 	add.w	r3, r7, #8
   232a4:	3308      	adds	r3, #8
   232a6:	61bb      	str	r3, [r7, #24]

      /* call callback */
      evt.hdr.event = DM_REMOTE_FEATURES_IND;
   232a8:	2357      	movs	r3, #87	; 0x57
   232aa:	72bb      	strb	r3, [r7, #10]
      evt.hdr.param = pCcb->connId;
   232ac:	69fb      	ldr	r3, [r7, #28]
   232ae:	7c1b      	ldrb	r3, [r3, #16]
   232b0:	b29b      	uxth	r3, r3
   232b2:	813b      	strh	r3, [r7, #8]
      evt.hdr.status = HCI_SUCCESS;
   232b4:	2300      	movs	r3, #0
   232b6:	72fb      	strb	r3, [r7, #11]

      evt.status = HCI_SUCCESS;
   232b8:	2300      	movs	r3, #0
   232ba:	733b      	strb	r3, [r7, #12]
      evt.handle = pCcb->handle;
   232bc:	69fb      	ldr	r3, [r7, #28]
   232be:	899b      	ldrh	r3, [r3, #12]
   232c0:	81fb      	strh	r3, [r7, #14]
      UINT32_TO_BSTREAM(p, pCcb->features);
   232c2:	69fb      	ldr	r3, [r7, #28]
   232c4:	6a99      	ldr	r1, [r3, #40]	; 0x28
   232c6:	69bb      	ldr	r3, [r7, #24]
   232c8:	1c5a      	adds	r2, r3, #1
   232ca:	61ba      	str	r2, [r7, #24]
   232cc:	b2ca      	uxtb	r2, r1
   232ce:	701a      	strb	r2, [r3, #0]
   232d0:	69fb      	ldr	r3, [r7, #28]
   232d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   232d4:	0a19      	lsrs	r1, r3, #8
   232d6:	69bb      	ldr	r3, [r7, #24]
   232d8:	1c5a      	adds	r2, r3, #1
   232da:	61ba      	str	r2, [r7, #24]
   232dc:	b2ca      	uxtb	r2, r1
   232de:	701a      	strb	r2, [r3, #0]
   232e0:	69fb      	ldr	r3, [r7, #28]
   232e2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   232e4:	0c19      	lsrs	r1, r3, #16
   232e6:	69bb      	ldr	r3, [r7, #24]
   232e8:	1c5a      	adds	r2, r3, #1
   232ea:	61ba      	str	r2, [r7, #24]
   232ec:	b2ca      	uxtb	r2, r1
   232ee:	701a      	strb	r2, [r3, #0]
   232f0:	69fb      	ldr	r3, [r7, #28]
   232f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   232f4:	0e19      	lsrs	r1, r3, #24
   232f6:	69bb      	ldr	r3, [r7, #24]
   232f8:	1c5a      	adds	r2, r3, #1
   232fa:	61ba      	str	r2, [r7, #24]
   232fc:	b2ca      	uxtb	r2, r1
   232fe:	701a      	strb	r2, [r3, #0]

      (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   23300:	4b08      	ldr	r3, [pc, #32]	; (23324 <DmReadRemoteFeatures+0xa8>)
   23302:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   23306:	f107 0208 	add.w	r2, r7, #8
   2330a:	4610      	mov	r0, r2
   2330c:	4798      	blx	r3
    {
      /* Request the remote features from the peer */
      HciLeReadRemoteFeatCmd(pCcb->handle);
    }
  }
}
   2330e:	e004      	b.n	2331a <DmReadRemoteFeatures+0x9e>
      HciLeReadRemoteFeatCmd(pCcb->handle);
   23310:	69fb      	ldr	r3, [r7, #28]
   23312:	899b      	ldrh	r3, [r3, #12]
   23314:	4618      	mov	r0, r3
   23316:	f002 f899 	bl	2544c <HciLeReadRemoteFeatCmd>
}
   2331a:	bf00      	nop
   2331c:	3720      	adds	r7, #32
   2331e:	46bd      	mov	sp, r7
   23320:	bd80      	pop	{r7, pc}
   23322:	bf00      	nop
   23324:	10011218 	.word	0x10011218

00023328 <DmConnUpdate>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnUpdate(dmConnId_t connId, hciConnSpec_t *pConnSpec)
{
   23328:	b580      	push	{r7, lr}
   2332a:	b084      	sub	sp, #16
   2332c:	af00      	add	r7, sp, #0
   2332e:	4603      	mov	r3, r0
   23330:	6039      	str	r1, [r7, #0]
   23332:	71fb      	strb	r3, [r7, #7]
  dmConnApiUpdate_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiUpdate_t))) != NULL)
   23334:	2010      	movs	r0, #16
   23336:	f009 feba 	bl	2d0ae <WsfMsgAlloc>
   2333a:	60f8      	str	r0, [r7, #12]
   2333c:	68fb      	ldr	r3, [r7, #12]
   2333e:	2b00      	cmp	r3, #0
   23340:	d01c      	beq.n	2337c <DmConnUpdate+0x54>
  {
    pMsg->hdr.event = (DmConnRole(connId) == DM_ROLE_MASTER) ?
   23342:	79fb      	ldrb	r3, [r7, #7]
   23344:	4618      	mov	r0, r3
   23346:	f000 f99d 	bl	23684 <DmConnRole>
   2334a:	4603      	mov	r3, r0
   2334c:	2b00      	cmp	r3, #0
   2334e:	d101      	bne.n	23354 <DmConnUpdate+0x2c>
   23350:	2233      	movs	r2, #51	; 0x33
   23352:	e000      	b.n	23356 <DmConnUpdate+0x2e>
   23354:	2234      	movs	r2, #52	; 0x34
   23356:	68fb      	ldr	r3, [r7, #12]
   23358:	709a      	strb	r2, [r3, #2]
                      DM_CONN_MSG_API_UPDATE_MASTER : DM_CONN_MSG_API_UPDATE_SLAVE;
    pMsg->hdr.param = connId;
   2335a:	79fb      	ldrb	r3, [r7, #7]
   2335c:	b29a      	uxth	r2, r3
   2335e:	68fb      	ldr	r3, [r7, #12]
   23360:	801a      	strh	r2, [r3, #0]
    memcpy(&pMsg->connSpec, pConnSpec, sizeof(hciConnSpec_t));
   23362:	68fb      	ldr	r3, [r7, #12]
   23364:	3304      	adds	r3, #4
   23366:	220c      	movs	r2, #12
   23368:	6839      	ldr	r1, [r7, #0]
   2336a:	4618      	mov	r0, r3
   2336c:	f7f4 ff72 	bl	18254 <memcpy>

    WsfMsgSend(dmCb.handlerId, pMsg);
   23370:	4b04      	ldr	r3, [pc, #16]	; (23384 <DmConnUpdate+0x5c>)
   23372:	7b1b      	ldrb	r3, [r3, #12]
   23374:	68f9      	ldr	r1, [r7, #12]
   23376:	4618      	mov	r0, r3
   23378:	f009 febd 	bl	2d0f6 <WsfMsgSend>
  }
}
   2337c:	bf00      	nop
   2337e:	3710      	adds	r7, #16
   23380:	46bd      	mov	sp, r7
   23382:	bd80      	pop	{r7, pc}
   23384:	100112ec 	.word	0x100112ec

00023388 <DmRemoteConnParamReqReply>:
*
*  \return None.
*/
/*************************************************************************************************/
void DmRemoteConnParamReqReply(dmConnId_t connId, hciConnSpec_t *pConnSpec)
{
   23388:	b580      	push	{r7, lr}
   2338a:	b084      	sub	sp, #16
   2338c:	af00      	add	r7, sp, #0
   2338e:	4603      	mov	r3, r0
   23390:	6039      	str	r1, [r7, #0]
   23392:	71fb      	strb	r3, [r7, #7]
  dmConnApiRemConnParamReqReply_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiRemConnParamReqReply_t))) != NULL)
   23394:	2010      	movs	r0, #16
   23396:	f009 fe8a 	bl	2d0ae <WsfMsgAlloc>
   2339a:	60f8      	str	r0, [r7, #12]
   2339c:	68fb      	ldr	r3, [r7, #12]
   2339e:	2b00      	cmp	r3, #0
   233a0:	d013      	beq.n	233ca <DmRemoteConnParamReqReply+0x42>
  {
    pMsg->hdr.event = DM_CONN_MSG_API_REM_CONN_PARAM_REQ_REPLY;
   233a2:	68fb      	ldr	r3, [r7, #12]
   233a4:	2242      	movs	r2, #66	; 0x42
   233a6:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   233a8:	79fb      	ldrb	r3, [r7, #7]
   233aa:	b29a      	uxth	r2, r3
   233ac:	68fb      	ldr	r3, [r7, #12]
   233ae:	801a      	strh	r2, [r3, #0]
    memcpy(&pMsg->connSpec, pConnSpec, sizeof(hciConnSpec_t));
   233b0:	68fb      	ldr	r3, [r7, #12]
   233b2:	3304      	adds	r3, #4
   233b4:	220c      	movs	r2, #12
   233b6:	6839      	ldr	r1, [r7, #0]
   233b8:	4618      	mov	r0, r3
   233ba:	f7f4 ff4b 	bl	18254 <memcpy>

    WsfMsgSend(dmCb.handlerId, pMsg);
   233be:	4b05      	ldr	r3, [pc, #20]	; (233d4 <DmRemoteConnParamReqReply+0x4c>)
   233c0:	7b1b      	ldrb	r3, [r3, #12]
   233c2:	68f9      	ldr	r1, [r7, #12]
   233c4:	4618      	mov	r0, r3
   233c6:	f009 fe96 	bl	2d0f6 <WsfMsgSend>
  }
}
   233ca:	bf00      	nop
   233cc:	3710      	adds	r7, #16
   233ce:	46bd      	mov	sp, r7
   233d0:	bd80      	pop	{r7, pc}
   233d2:	bf00      	nop
   233d4:	100112ec 	.word	0x100112ec

000233d8 <DmRemoteConnParamReqNegReply>:
*
*  \return None.
*/
/*************************************************************************************************/
void DmRemoteConnParamReqNegReply(dmConnId_t connId, uint8_t reason)
{
   233d8:	b580      	push	{r7, lr}
   233da:	b084      	sub	sp, #16
   233dc:	af00      	add	r7, sp, #0
   233de:	4603      	mov	r3, r0
   233e0:	460a      	mov	r2, r1
   233e2:	71fb      	strb	r3, [r7, #7]
   233e4:	4613      	mov	r3, r2
   233e6:	71bb      	strb	r3, [r7, #6]
  dmConnApiRemConnParamReqNegReply_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiRemConnParamReqNegReply_t))) != NULL)
   233e8:	2006      	movs	r0, #6
   233ea:	f009 fe60 	bl	2d0ae <WsfMsgAlloc>
   233ee:	60f8      	str	r0, [r7, #12]
   233f0:	68fb      	ldr	r3, [r7, #12]
   233f2:	2b00      	cmp	r3, #0
   233f4:	d00f      	beq.n	23416 <DmRemoteConnParamReqNegReply+0x3e>
  {
    pMsg->hdr.event = DM_CONN_MSG_API_REM_CONN_PARAM_REQ_NEG_REPLY;
   233f6:	68fb      	ldr	r3, [r7, #12]
   233f8:	2243      	movs	r2, #67	; 0x43
   233fa:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   233fc:	79fb      	ldrb	r3, [r7, #7]
   233fe:	b29a      	uxth	r2, r3
   23400:	68fb      	ldr	r3, [r7, #12]
   23402:	801a      	strh	r2, [r3, #0]
    pMsg->reason = reason;
   23404:	68fb      	ldr	r3, [r7, #12]
   23406:	79ba      	ldrb	r2, [r7, #6]
   23408:	711a      	strb	r2, [r3, #4]

    WsfMsgSend(dmCb.handlerId, pMsg);
   2340a:	4b05      	ldr	r3, [pc, #20]	; (23420 <DmRemoteConnParamReqNegReply+0x48>)
   2340c:	7b1b      	ldrb	r3, [r3, #12]
   2340e:	68f9      	ldr	r1, [r7, #12]
   23410:	4618      	mov	r0, r3
   23412:	f009 fe70 	bl	2d0f6 <WsfMsgSend>
  }
}
   23416:	bf00      	nop
   23418:	3710      	adds	r7, #16
   2341a:	46bd      	mov	sp, r7
   2341c:	bd80      	pop	{r7, pc}
   2341e:	bf00      	nop
   23420:	100112ec 	.word	0x100112ec

00023424 <DmConnSetDataLen>:
*
*  \return None.
*/
/*************************************************************************************************/
void DmConnSetDataLen(dmConnId_t connId, uint16_t txOctets, uint16_t txTime)
{
   23424:	b580      	push	{r7, lr}
   23426:	b084      	sub	sp, #16
   23428:	af00      	add	r7, sp, #0
   2342a:	4603      	mov	r3, r0
   2342c:	71fb      	strb	r3, [r7, #7]
   2342e:	460b      	mov	r3, r1
   23430:	80bb      	strh	r3, [r7, #4]
   23432:	4613      	mov	r3, r2
   23434:	807b      	strh	r3, [r7, #2]
  dmConnApiSetDataLen_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmConnApiSetDataLen_t))) != NULL)
   23436:	2008      	movs	r0, #8
   23438:	f009 fe39 	bl	2d0ae <WsfMsgAlloc>
   2343c:	60f8      	str	r0, [r7, #12]
   2343e:	68fb      	ldr	r3, [r7, #12]
   23440:	2b00      	cmp	r3, #0
   23442:	d012      	beq.n	2346a <DmConnSetDataLen+0x46>
  {
    pMsg->hdr.event = DM_CONN_MSG_API_SET_DATA_LEN;
   23444:	68fb      	ldr	r3, [r7, #12]
   23446:	2244      	movs	r2, #68	; 0x44
   23448:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   2344a:	79fb      	ldrb	r3, [r7, #7]
   2344c:	b29a      	uxth	r2, r3
   2344e:	68fb      	ldr	r3, [r7, #12]
   23450:	801a      	strh	r2, [r3, #0]
    pMsg->txOctets = txOctets;
   23452:	68fb      	ldr	r3, [r7, #12]
   23454:	88ba      	ldrh	r2, [r7, #4]
   23456:	809a      	strh	r2, [r3, #4]
    pMsg->txTime = txTime;
   23458:	68fb      	ldr	r3, [r7, #12]
   2345a:	887a      	ldrh	r2, [r7, #2]
   2345c:	80da      	strh	r2, [r3, #6]

    WsfMsgSend(dmCb.handlerId, pMsg);
   2345e:	4b05      	ldr	r3, [pc, #20]	; (23474 <DmConnSetDataLen+0x50>)
   23460:	7b1b      	ldrb	r3, [r3, #12]
   23462:	68f9      	ldr	r1, [r7, #12]
   23464:	4618      	mov	r0, r3
   23466:	f009 fe46 	bl	2d0f6 <WsfMsgSend>
  }
}
   2346a:	bf00      	nop
   2346c:	3710      	adds	r7, #16
   2346e:	46bd      	mov	sp, r7
   23470:	bd80      	pop	{r7, pc}
   23472:	bf00      	nop
   23474:	100112ec 	.word	0x100112ec

00023478 <DmConnIdByHandle>:
 *
 *  \return Connection ID or DM_CONN_ID_NONE if error.
 */
/*************************************************************************************************/
dmConnId_t DmConnIdByHandle(uint16_t handle)
{
   23478:	b480      	push	{r7}
   2347a:	b085      	sub	sp, #20
   2347c:	af00      	add	r7, sp, #0
   2347e:	4603      	mov	r3, r0
   23480:	80fb      	strh	r3, [r7, #6]
  dmConnCcb_t   *pCcb = dmConnCb.ccb;
   23482:	4b10      	ldr	r3, [pc, #64]	; (234c4 <DmConnIdByHandle+0x4c>)
   23484:	60fb      	str	r3, [r7, #12]
  uint8_t       i;

  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   23486:	2303      	movs	r3, #3
   23488:	72fb      	strb	r3, [r7, #11]
   2348a:	e011      	b.n	234b0 <DmConnIdByHandle+0x38>
  {
    if (pCcb->inUse && (pCcb->handle == handle))
   2348c:	68fb      	ldr	r3, [r7, #12]
   2348e:	7d9b      	ldrb	r3, [r3, #22]
   23490:	2b00      	cmp	r3, #0
   23492:	d007      	beq.n	234a4 <DmConnIdByHandle+0x2c>
   23494:	68fb      	ldr	r3, [r7, #12]
   23496:	899b      	ldrh	r3, [r3, #12]
   23498:	88fa      	ldrh	r2, [r7, #6]
   2349a:	429a      	cmp	r2, r3
   2349c:	d102      	bne.n	234a4 <DmConnIdByHandle+0x2c>
    {
      return pCcb->connId;
   2349e:	68fb      	ldr	r3, [r7, #12]
   234a0:	7c1b      	ldrb	r3, [r3, #16]
   234a2:	e009      	b.n	234b8 <DmConnIdByHandle+0x40>
  for (i = DM_CONN_MAX; i > 0; i--, pCcb++)
   234a4:	7afb      	ldrb	r3, [r7, #11]
   234a6:	3b01      	subs	r3, #1
   234a8:	72fb      	strb	r3, [r7, #11]
   234aa:	68fb      	ldr	r3, [r7, #12]
   234ac:	3330      	adds	r3, #48	; 0x30
   234ae:	60fb      	str	r3, [r7, #12]
   234b0:	7afb      	ldrb	r3, [r7, #11]
   234b2:	2b00      	cmp	r3, #0
   234b4:	d1ea      	bne.n	2348c <DmConnIdByHandle+0x14>
    }
  }

  // DM_TRACE_WARN1("DmConnIdByHandle not found 0x%04x", handle);

  return DM_CONN_ID_NONE;
   234b6:	2300      	movs	r3, #0
}
   234b8:	4618      	mov	r0, r3
   234ba:	3714      	adds	r7, #20
   234bc:	46bd      	mov	sp, r7
   234be:	f85d 7b04 	ldr.w	r7, [sp], #4
   234c2:	4770      	bx	lr
   234c4:	10011218 	.word	0x10011218

000234c8 <DmConnInUse>:
 *
 *  \return TRUE if the connection is in use, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t DmConnInUse(dmConnId_t connId)
{
   234c8:	b480      	push	{r7}
   234ca:	b083      	sub	sp, #12
   234cc:	af00      	add	r7, sp, #0
   234ce:	4603      	mov	r3, r0
   234d0:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return dmConnCb.ccb[connId-1].inUse;
   234d2:	79fb      	ldrb	r3, [r7, #7]
   234d4:	1e5a      	subs	r2, r3, #1
   234d6:	4907      	ldr	r1, [pc, #28]	; (234f4 <DmConnInUse+0x2c>)
   234d8:	4613      	mov	r3, r2
   234da:	005b      	lsls	r3, r3, #1
   234dc:	4413      	add	r3, r2
   234de:	011b      	lsls	r3, r3, #4
   234e0:	440b      	add	r3, r1
   234e2:	3316      	adds	r3, #22
   234e4:	781b      	ldrb	r3, [r3, #0]
}
   234e6:	4618      	mov	r0, r3
   234e8:	370c      	adds	r7, #12
   234ea:	46bd      	mov	sp, r7
   234ec:	f85d 7b04 	ldr.w	r7, [sp], #4
   234f0:	4770      	bx	lr
   234f2:	bf00      	nop
   234f4:	10011218 	.word	0x10011218

000234f8 <DmConnPeerAddrType>:
 *
 *  \return Peer address type.
 */
/*************************************************************************************************/
uint8_t DmConnPeerAddrType(dmConnId_t connId)
{
   234f8:	b480      	push	{r7}
   234fa:	b083      	sub	sp, #12
   234fc:	af00      	add	r7, sp, #0
   234fe:	4603      	mov	r3, r0
   23500:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return dmConnCb.ccb[connId-1].peerAddrType;
   23502:	79fb      	ldrb	r3, [r7, #7]
   23504:	1e5a      	subs	r2, r3, #1
   23506:	4907      	ldr	r1, [pc, #28]	; (23524 <DmConnPeerAddrType+0x2c>)
   23508:	4613      	mov	r3, r2
   2350a:	005b      	lsls	r3, r3, #1
   2350c:	4413      	add	r3, r2
   2350e:	011b      	lsls	r3, r3, #4
   23510:	440b      	add	r3, r1
   23512:	3313      	adds	r3, #19
   23514:	781b      	ldrb	r3, [r3, #0]
}
   23516:	4618      	mov	r0, r3
   23518:	370c      	adds	r7, #12
   2351a:	46bd      	mov	sp, r7
   2351c:	f85d 7b04 	ldr.w	r7, [sp], #4
   23520:	4770      	bx	lr
   23522:	bf00      	nop
   23524:	10011218 	.word	0x10011218

00023528 <DmConnPeerAddr>:
 *
 *  \return Pointer to peer device address.
 */
/*************************************************************************************************/
uint8_t *DmConnPeerAddr(dmConnId_t connId)
{
   23528:	b480      	push	{r7}
   2352a:	b083      	sub	sp, #12
   2352c:	af00      	add	r7, sp, #0
   2352e:	4603      	mov	r3, r0
   23530:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return dmConnCb.ccb[connId-1].peerAddr;
   23532:	79fb      	ldrb	r3, [r7, #7]
   23534:	1e5a      	subs	r2, r3, #1
   23536:	4613      	mov	r3, r2
   23538:	005b      	lsls	r3, r3, #1
   2353a:	4413      	add	r3, r2
   2353c:	011b      	lsls	r3, r3, #4
   2353e:	4a04      	ldr	r2, [pc, #16]	; (23550 <DmConnPeerAddr+0x28>)
   23540:	4413      	add	r3, r2
}
   23542:	4618      	mov	r0, r3
   23544:	370c      	adds	r7, #12
   23546:	46bd      	mov	sp, r7
   23548:	f85d 7b04 	ldr.w	r7, [sp], #4
   2354c:	4770      	bx	lr
   2354e:	bf00      	nop
   23550:	10011218 	.word	0x10011218

00023554 <DmConnSecLevel>:
 *
 *  \return Security level of the connection.
 */
/*************************************************************************************************/
uint8_t DmConnSecLevel(dmConnId_t connId)
{
   23554:	b480      	push	{r7}
   23556:	b083      	sub	sp, #12
   23558:	af00      	add	r7, sp, #0
   2355a:	4603      	mov	r3, r0
   2355c:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return dmConnCb.ccb[connId-1].secLevel;
   2355e:	79fb      	ldrb	r3, [r7, #7]
   23560:	1e5a      	subs	r2, r3, #1
   23562:	4907      	ldr	r1, [pc, #28]	; (23580 <DmConnSecLevel+0x2c>)
   23564:	4613      	mov	r3, r2
   23566:	005b      	lsls	r3, r3, #1
   23568:	4413      	add	r3, r2
   2356a:	011b      	lsls	r3, r3, #4
   2356c:	440b      	add	r3, r1
   2356e:	3317      	adds	r3, #23
   23570:	781b      	ldrb	r3, [r3, #0]
}
   23572:	4618      	mov	r0, r3
   23574:	370c      	adds	r7, #12
   23576:	46bd      	mov	sp, r7
   23578:	f85d 7b04 	ldr.w	r7, [sp], #4
   2357c:	4770      	bx	lr
   2357e:	bf00      	nop
   23580:	10011218 	.word	0x10011218

00023584 <DmConnSetIdle>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnSetIdle(dmConnId_t connId, uint16_t idleMask, uint8_t idle)
{
   23584:	b580      	push	{r7, lr}
   23586:	b082      	sub	sp, #8
   23588:	af00      	add	r7, sp, #0
   2358a:	4603      	mov	r3, r0
   2358c:	71fb      	strb	r3, [r7, #7]
   2358e:	460b      	mov	r3, r1
   23590:	80bb      	strh	r3, [r7, #4]
   23592:	4613      	mov	r3, r2
   23594:	71bb      	strb	r3, [r7, #6]
  WsfTaskLock();
   23596:	f009 fe35 	bl	2d204 <WsfTaskLock>

  if (DmConnInUse(connId))
   2359a:	79fb      	ldrb	r3, [r7, #7]
   2359c:	4618      	mov	r0, r3
   2359e:	f7ff ff93 	bl	234c8 <DmConnInUse>
   235a2:	4603      	mov	r3, r0
   235a4:	2b00      	cmp	r3, #0
   235a6:	d038      	beq.n	2361a <DmConnSetIdle+0x96>
  {
    if (idle == DM_CONN_IDLE)
   235a8:	79bb      	ldrb	r3, [r7, #6]
   235aa:	2b00      	cmp	r3, #0
   235ac:	d11d      	bne.n	235ea <DmConnSetIdle+0x66>
    {
      /* clear bit if idle */
      dmConnCb.ccb[connId-1].idleMask &= ~idleMask;
   235ae:	79fb      	ldrb	r3, [r7, #7]
   235b0:	1e5a      	subs	r2, r3, #1
   235b2:	4924      	ldr	r1, [pc, #144]	; (23644 <DmConnSetIdle+0xc0>)
   235b4:	4613      	mov	r3, r2
   235b6:	005b      	lsls	r3, r3, #1
   235b8:	4413      	add	r3, r2
   235ba:	011b      	lsls	r3, r3, #4
   235bc:	440b      	add	r3, r1
   235be:	330e      	adds	r3, #14
   235c0:	881b      	ldrh	r3, [r3, #0]
   235c2:	b21a      	sxth	r2, r3
   235c4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
   235c8:	43db      	mvns	r3, r3
   235ca:	b21b      	sxth	r3, r3
   235cc:	4013      	ands	r3, r2
   235ce:	b219      	sxth	r1, r3
   235d0:	79fb      	ldrb	r3, [r7, #7]
   235d2:	1e5a      	subs	r2, r3, #1
   235d4:	b288      	uxth	r0, r1
   235d6:	491b      	ldr	r1, [pc, #108]	; (23644 <DmConnSetIdle+0xc0>)
   235d8:	4613      	mov	r3, r2
   235da:	005b      	lsls	r3, r3, #1
   235dc:	4413      	add	r3, r2
   235de:	011b      	lsls	r3, r3, #4
   235e0:	440b      	add	r3, r1
   235e2:	330e      	adds	r3, #14
   235e4:	4602      	mov	r2, r0
   235e6:	801a      	strh	r2, [r3, #0]
   235e8:	e017      	b.n	2361a <DmConnSetIdle+0x96>
    }
    else
    {
      /* set bit if busy */
      dmConnCb.ccb[connId-1].idleMask |= idleMask;
   235ea:	79fb      	ldrb	r3, [r7, #7]
   235ec:	1e5a      	subs	r2, r3, #1
   235ee:	4915      	ldr	r1, [pc, #84]	; (23644 <DmConnSetIdle+0xc0>)
   235f0:	4613      	mov	r3, r2
   235f2:	005b      	lsls	r3, r3, #1
   235f4:	4413      	add	r3, r2
   235f6:	011b      	lsls	r3, r3, #4
   235f8:	440b      	add	r3, r1
   235fa:	330e      	adds	r3, #14
   235fc:	8819      	ldrh	r1, [r3, #0]
   235fe:	79fb      	ldrb	r3, [r7, #7]
   23600:	1e5a      	subs	r2, r3, #1
   23602:	88bb      	ldrh	r3, [r7, #4]
   23604:	430b      	orrs	r3, r1
   23606:	b298      	uxth	r0, r3
   23608:	490e      	ldr	r1, [pc, #56]	; (23644 <DmConnSetIdle+0xc0>)
   2360a:	4613      	mov	r3, r2
   2360c:	005b      	lsls	r3, r3, #1
   2360e:	4413      	add	r3, r2
   23610:	011b      	lsls	r3, r3, #4
   23612:	440b      	add	r3, r1
   23614:	330e      	adds	r3, #14
   23616:	4602      	mov	r2, r0
   23618:	801a      	strh	r2, [r3, #0]
    }
  }

  WsfTaskUnlock();
   2361a:	f009 fdf9 	bl	2d210 <WsfTaskUnlock>

  DM_TRACE_INFO2("connId=%d idleMask=0x%04x", connId, dmConnCb.ccb[connId-1].idleMask);
   2361e:	79f9      	ldrb	r1, [r7, #7]
   23620:	79fb      	ldrb	r3, [r7, #7]
   23622:	1e5a      	subs	r2, r3, #1
   23624:	4807      	ldr	r0, [pc, #28]	; (23644 <DmConnSetIdle+0xc0>)
   23626:	4613      	mov	r3, r2
   23628:	005b      	lsls	r3, r3, #1
   2362a:	4413      	add	r3, r2
   2362c:	011b      	lsls	r3, r3, #4
   2362e:	4403      	add	r3, r0
   23630:	330e      	adds	r3, #14
   23632:	881b      	ldrh	r3, [r3, #0]
   23634:	461a      	mov	r2, r3
   23636:	4804      	ldr	r0, [pc, #16]	; (23648 <DmConnSetIdle+0xc4>)
   23638:	f00a f9aa 	bl	2d990 <WsfTrace>
}
   2363c:	bf00      	nop
   2363e:	3708      	adds	r7, #8
   23640:	46bd      	mov	sp, r7
   23642:	bd80      	pop	{r7, pc}
   23644:	10011218 	.word	0x10011218
   23648:	00044bbc 	.word	0x00044bbc

0002364c <DmConnCheckIdle>:
 *
 *  \return Zero if connection is idle, nonzero if busy.
 */
/*************************************************************************************************/
uint16_t DmConnCheckIdle(dmConnId_t connId)
{
   2364c:	b580      	push	{r7, lr}
   2364e:	b084      	sub	sp, #16
   23650:	af00      	add	r7, sp, #0
   23652:	4603      	mov	r3, r0
   23654:	71fb      	strb	r3, [r7, #7]
  uint16_t idleMask;

  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  WsfTaskLock();
   23656:	f009 fdd5 	bl	2d204 <WsfTaskLock>
  idleMask = dmConnCb.ccb[connId-1].idleMask;
   2365a:	79fb      	ldrb	r3, [r7, #7]
   2365c:	1e5a      	subs	r2, r3, #1
   2365e:	4908      	ldr	r1, [pc, #32]	; (23680 <DmConnCheckIdle+0x34>)
   23660:	4613      	mov	r3, r2
   23662:	005b      	lsls	r3, r3, #1
   23664:	4413      	add	r3, r2
   23666:	011b      	lsls	r3, r3, #4
   23668:	440b      	add	r3, r1
   2366a:	330e      	adds	r3, #14
   2366c:	881b      	ldrh	r3, [r3, #0]
   2366e:	81fb      	strh	r3, [r7, #14]
  WsfTaskUnlock();
   23670:	f009 fdce 	bl	2d210 <WsfTaskUnlock>

  return idleMask;
   23674:	89fb      	ldrh	r3, [r7, #14]
}
   23676:	4618      	mov	r0, r3
   23678:	3710      	adds	r7, #16
   2367a:	46bd      	mov	sp, r7
   2367c:	bd80      	pop	{r7, pc}
   2367e:	bf00      	nop
   23680:	10011218 	.word	0x10011218

00023684 <DmConnRole>:
 *
 *  \return Connection role.
 */
/*************************************************************************************************/
uint8_t DmConnRole(dmConnId_t connId)
{
   23684:	b480      	push	{r7}
   23686:	b083      	sub	sp, #12
   23688:	af00      	add	r7, sp, #0
   2368a:	4603      	mov	r3, r0
   2368c:	71fb      	strb	r3, [r7, #7]
  WSF_ASSERT((connId > 0) && (connId <= DM_CONN_MAX));

  return dmConnCb.ccb[connId-1].role;
   2368e:	79fb      	ldrb	r3, [r7, #7]
   23690:	1e5a      	subs	r2, r3, #1
   23692:	4907      	ldr	r1, [pc, #28]	; (236b0 <DmConnRole+0x2c>)
   23694:	4613      	mov	r3, r2
   23696:	005b      	lsls	r3, r3, #1
   23698:	4413      	add	r3, r2
   2369a:	011b      	lsls	r3, r3, #4
   2369c:	440b      	add	r3, r1
   2369e:	3319      	adds	r3, #25
   236a0:	781b      	ldrb	r3, [r3, #0]
}
   236a2:	4618      	mov	r0, r3
   236a4:	370c      	adds	r7, #12
   236a6:	46bd      	mov	sp, r7
   236a8:	f85d 7b04 	ldr.w	r7, [sp], #4
   236ac:	4770      	bx	lr
   236ae:	bf00      	nop
   236b0:	10011218 	.word	0x10011218

000236b4 <dmConnSmActCancelOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActCancelOpen(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   236b4:	b580      	push	{r7, lr}
   236b6:	b082      	sub	sp, #8
   236b8:	af00      	add	r7, sp, #0
   236ba:	6078      	str	r0, [r7, #4]
   236bc:	6039      	str	r1, [r7, #0]
  /* cancel create connection */
  HciLeCreateConnCancelCmd();
   236be:	f001 fd12 	bl	250e6 <HciLeCreateConnCancelCmd>

  /* pass connection initiation stopped to dev priv */
  dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_CTRL, DM_DEV_PRIV_MSG_CONN_INIT_STOP, 0, 0);
   236c2:	2300      	movs	r3, #0
   236c4:	2200      	movs	r2, #0
   236c6:	2101      	movs	r1, #1
   236c8:	2016      	movs	r0, #22
   236ca:	f000 faad 	bl	23c28 <dmDevPassEvtToDevPriv>
}
   236ce:	bf00      	nop
   236d0:	3708      	adds	r7, #8
   236d2:	46bd      	mov	sp, r7
   236d4:	bd80      	pop	{r7, pc}

000236d6 <dmConnSmActUpdateMaster>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActUpdateMaster(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   236d6:	b580      	push	{r7, lr}
   236d8:	b082      	sub	sp, #8
   236da:	af00      	add	r7, sp, #0
   236dc:	6078      	str	r0, [r7, #4]
   236de:	6039      	str	r1, [r7, #0]
  /* send HCI command */
  HciLeConnUpdateCmd(pCcb->handle, &pMsg->apiUpdate.connSpec);
   236e0:	687b      	ldr	r3, [r7, #4]
   236e2:	899a      	ldrh	r2, [r3, #12]
   236e4:	683b      	ldr	r3, [r7, #0]
   236e6:	3304      	adds	r3, #4
   236e8:	4619      	mov	r1, r3
   236ea:	4610      	mov	r0, r2
   236ec:	f001 fbbe 	bl	24e6c <HciLeConnUpdateCmd>
}
   236f0:	bf00      	nop
   236f2:	3708      	adds	r7, #8
   236f4:	46bd      	mov	sp, r7
   236f6:	bd80      	pop	{r7, pc}

000236f8 <dmConnSmActL2cUpdateInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActL2cUpdateInd(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   236f8:	b580      	push	{r7, lr}
   236fa:	b082      	sub	sp, #8
   236fc:	af00      	add	r7, sp, #0
   236fe:	6078      	str	r0, [r7, #4]
   23700:	6039      	str	r1, [r7, #0]
  /* always send back response */
  L2cDmConnUpdateRsp(pMsg->l2cUpdateInd.identifier, pCcb->handle, L2C_CONN_PARAM_ACCEPTED);
   23702:	683b      	ldr	r3, [r7, #0]
   23704:	7a18      	ldrb	r0, [r3, #8]
   23706:	687b      	ldr	r3, [r7, #4]
   23708:	899b      	ldrh	r3, [r3, #12]
   2370a:	2200      	movs	r2, #0
   2370c:	4619      	mov	r1, r3
   2370e:	f006 fcfd 	bl	2a10c <L2cDmConnUpdateRsp>

  /* send HCI command */
  HciLeConnUpdateCmd(pCcb->handle, pMsg->l2cUpdateInd.pConnSpec);
   23712:	687b      	ldr	r3, [r7, #4]
   23714:	899a      	ldrh	r2, [r3, #12]
   23716:	683b      	ldr	r3, [r7, #0]
   23718:	685b      	ldr	r3, [r3, #4]
   2371a:	4619      	mov	r1, r3
   2371c:	4610      	mov	r0, r2
   2371e:	f001 fba5 	bl	24e6c <HciLeConnUpdateCmd>
}
   23722:	bf00      	nop
   23724:	3708      	adds	r7, #8
   23726:	46bd      	mov	sp, r7
   23728:	bd80      	pop	{r7, pc}

0002372a <DmL2cConnUpdateInd>:
 *  \param  pConnSpec   Connection spec parameters.
 *  \return None.
 */
/*************************************************************************************************/
void DmL2cConnUpdateInd(uint8_t identifier, uint16_t handle, hciConnSpec_t *pConnSpec)
{
   2372a:	b580      	push	{r7, lr}
   2372c:	b086      	sub	sp, #24
   2372e:	af00      	add	r7, sp, #0
   23730:	4603      	mov	r3, r0
   23732:	603a      	str	r2, [r7, #0]
   23734:	71fb      	strb	r3, [r7, #7]
   23736:	460b      	mov	r3, r1
   23738:	80bb      	strh	r3, [r7, #4]
  dmConnL2cUpdateInd_t  updateInd;
  dmConnCcb_t           *pCcb;

  if ((pCcb = dmConnCcbByHandle(handle)) != NULL)
   2373a:	88bb      	ldrh	r3, [r7, #4]
   2373c:	4618      	mov	r0, r3
   2373e:	f7ff f83f 	bl	227c0 <dmConnCcbByHandle>
   23742:	6178      	str	r0, [r7, #20]
   23744:	697b      	ldr	r3, [r7, #20]
   23746:	2b00      	cmp	r3, #0
   23748:	d00b      	beq.n	23762 <DmL2cConnUpdateInd+0x38>
  {
    updateInd.hdr.event = DM_CONN_MSG_L2C_UPDATE_IND;
   2374a:	2335      	movs	r3, #53	; 0x35
   2374c:	72bb      	strb	r3, [r7, #10]
    updateInd.pConnSpec = pConnSpec;
   2374e:	683b      	ldr	r3, [r7, #0]
   23750:	60fb      	str	r3, [r7, #12]
    updateInd.identifier = identifier;
   23752:	79fb      	ldrb	r3, [r7, #7]
   23754:	743b      	strb	r3, [r7, #16]

    dmConnSmExecute(pCcb, (dmConnMsg_t *) &updateInd);
   23756:	f107 0308 	add.w	r3, r7, #8
   2375a:	4619      	mov	r1, r3
   2375c:	6978      	ldr	r0, [r7, #20]
   2375e:	f000 f97f 	bl	23a60 <dmConnSmExecute>
  }
}
   23762:	bf00      	nop
   23764:	3718      	adds	r7, #24
   23766:	46bd      	mov	sp, r7
   23768:	bd80      	pop	{r7, pc}

0002376a <DmConnOpen>:
 *
 *  \return Connection identifier.
 */
/*************************************************************************************************/
dmConnId_t DmConnOpen(uint8_t clientId, uint8_t initPhys, uint8_t addrType, uint8_t *pAddr)
{
   2376a:	b580      	push	{r7, lr}
   2376c:	b088      	sub	sp, #32
   2376e:	af06      	add	r7, sp, #24
   23770:	603b      	str	r3, [r7, #0]
   23772:	4603      	mov	r3, r0
   23774:	71fb      	strb	r3, [r7, #7]
   23776:	460b      	mov	r3, r1
   23778:	71bb      	strb	r3, [r7, #6]
   2377a:	4613      	mov	r3, r2
   2377c:	717b      	strb	r3, [r7, #5]
  return dmConnOpenAccept(clientId, initPhys, 0, 0, 0, 0, addrType, pAddr, DM_ROLE_MASTER);
   2377e:	79b9      	ldrb	r1, [r7, #6]
   23780:	79f8      	ldrb	r0, [r7, #7]
   23782:	2300      	movs	r3, #0
   23784:	9304      	str	r3, [sp, #16]
   23786:	683b      	ldr	r3, [r7, #0]
   23788:	9303      	str	r3, [sp, #12]
   2378a:	797b      	ldrb	r3, [r7, #5]
   2378c:	9302      	str	r3, [sp, #8]
   2378e:	2300      	movs	r3, #0
   23790:	9301      	str	r3, [sp, #4]
   23792:	2300      	movs	r3, #0
   23794:	9300      	str	r3, [sp, #0]
   23796:	2300      	movs	r3, #0
   23798:	2200      	movs	r2, #0
   2379a:	f7ff f8d3 	bl	22944 <dmConnOpenAccept>
   2379e:	4603      	mov	r3, r0
}
   237a0:	4618      	mov	r0, r3
   237a2:	3708      	adds	r7, #8
   237a4:	46bd      	mov	sp, r7
   237a6:	bd80      	pop	{r7, pc}

000237a8 <dmConnOpen>:
 *
 *  \return Connection identifier.
 */
/*************************************************************************************************/
static void dmConnOpen(uint8_t initPhys, uint8_t addrType, uint8_t *pAddr)
{
   237a8:	b5f0      	push	{r4, r5, r6, r7, lr}
   237aa:	b089      	sub	sp, #36	; 0x24
   237ac:	af04      	add	r7, sp, #16
   237ae:	4603      	mov	r3, r0
   237b0:	603a      	str	r2, [r7, #0]
   237b2:	71fb      	strb	r3, [r7, #7]
   237b4:	460b      	mov	r3, r1
   237b6:	71bb      	strb	r3, [r7, #6]
  uint8_t phyIdx = DmScanPhyToIdx(HCI_SCAN_PHY_LE_1M_BIT);
   237b8:	2001      	movs	r0, #1
   237ba:	f000 fbfb 	bl	23fb4 <DmScanPhyToIdx>
   237be:	4603      	mov	r3, r0
   237c0:	73fb      	strb	r3, [r7, #15]

  /* Create connection */
  HciLeCreateConnCmd(dmConnCb.scanInterval[phyIdx], dmConnCb.scanWindow[phyIdx], dmCb.initFiltPolicy,
   237c2:	7bfb      	ldrb	r3, [r7, #15]
   237c4:	4a18      	ldr	r2, [pc, #96]	; (23828 <dmConnOpen+0x80>)
   237c6:	335c      	adds	r3, #92	; 0x5c
   237c8:	005b      	lsls	r3, r3, #1
   237ca:	4413      	add	r3, r2
   237cc:	889c      	ldrh	r4, [r3, #4]
   237ce:	7bfb      	ldrb	r3, [r7, #15]
   237d0:	4a15      	ldr	r2, [pc, #84]	; (23828 <dmConnOpen+0x80>)
   237d2:	3360      	adds	r3, #96	; 0x60
   237d4:	f832 5013 	ldrh.w	r5, [r2, r3, lsl #1]
   237d8:	4b14      	ldr	r3, [pc, #80]	; (2382c <dmConnOpen+0x84>)
   237da:	7cde      	ldrb	r6, [r3, #19]
   237dc:	4b13      	ldr	r3, [pc, #76]	; (2382c <dmConnOpen+0x84>)
   237de:	7b5b      	ldrb	r3, [r3, #13]
   237e0:	4618      	mov	r0, r3
   237e2:	f000 fb7f 	bl	23ee4 <DmLlAddrType>
   237e6:	4603      	mov	r3, r0
   237e8:	4619      	mov	r1, r3
                     addrType, pAddr, DmLlAddrType(dmCb.connAddrType), &(dmConnCb.connSpec[phyIdx]));
   237ea:	7bfa      	ldrb	r2, [r7, #15]
  HciLeCreateConnCmd(dmConnCb.scanInterval[phyIdx], dmConnCb.scanWindow[phyIdx], dmCb.initFiltPolicy,
   237ec:	4613      	mov	r3, r2
   237ee:	005b      	lsls	r3, r3, #1
   237f0:	4413      	add	r3, r2
   237f2:	009b      	lsls	r3, r3, #2
   237f4:	33a0      	adds	r3, #160	; 0xa0
   237f6:	4a0c      	ldr	r2, [pc, #48]	; (23828 <dmConnOpen+0x80>)
   237f8:	4413      	add	r3, r2
   237fa:	3304      	adds	r3, #4
   237fc:	79ba      	ldrb	r2, [r7, #6]
   237fe:	9302      	str	r3, [sp, #8]
   23800:	9101      	str	r1, [sp, #4]
   23802:	683b      	ldr	r3, [r7, #0]
   23804:	9300      	str	r3, [sp, #0]
   23806:	4613      	mov	r3, r2
   23808:	4632      	mov	r2, r6
   2380a:	4629      	mov	r1, r5
   2380c:	4620      	mov	r0, r4
   2380e:	f001 fbb4 	bl	24f7a <HciLeCreateConnCmd>

  /* pass connection initiation started to dev priv */
  dmDevPassEvtToDevPriv(DM_DEV_PRIV_MSG_CTRL, DM_DEV_PRIV_MSG_CONN_INIT_START, 0, 0);
   23812:	2300      	movs	r3, #0
   23814:	2200      	movs	r2, #0
   23816:	2100      	movs	r1, #0
   23818:	2016      	movs	r0, #22
   2381a:	f000 fa05 	bl	23c28 <dmDevPassEvtToDevPriv>
}
   2381e:	bf00      	nop
   23820:	3714      	adds	r7, #20
   23822:	46bd      	mov	sp, r7
   23824:	bdf0      	pop	{r4, r5, r6, r7, pc}
   23826:	bf00      	nop
   23828:	10011218 	.word	0x10011218
   2382c:	100112ec 	.word	0x100112ec

00023830 <dmConnSmActOpen>:
 *
 *  \return None.
*/
/*************************************************************************************************/
void dmConnSmActOpen(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   23830:	b580      	push	{r7, lr}
   23832:	b082      	sub	sp, #8
   23834:	af00      	add	r7, sp, #0
   23836:	6078      	str	r0, [r7, #4]
   23838:	6039      	str	r1, [r7, #0]
  dmConnOpen(pMsg->apiOpen.initPhys, pMsg->apiOpen.addrType, pMsg->apiOpen.peerAddr);
   2383a:	683b      	ldr	r3, [r7, #0]
   2383c:	7918      	ldrb	r0, [r3, #4]
   2383e:	683b      	ldr	r3, [r7, #0]
   23840:	7c59      	ldrb	r1, [r3, #17]
   23842:	683b      	ldr	r3, [r7, #0]
   23844:	330b      	adds	r3, #11
   23846:	461a      	mov	r2, r3
   23848:	f7ff ffae 	bl	237a8 <dmConnOpen>
}
   2384c:	bf00      	nop
   2384e:	3708      	adds	r7, #8
   23850:	46bd      	mov	sp, r7
   23852:	bd80      	pop	{r7, pc}

00023854 <DmConnMasterInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnMasterInit(void)
{
   23854:	b480      	push	{r7}
   23856:	af00      	add	r7, sp, #0
  dmConnActSet[DM_CONN_ACT_SET_MASTER] = (dmConnAct_t *) dmConnActSetMaster;
   23858:	4b03      	ldr	r3, [pc, #12]	; (23868 <DmConnMasterInit+0x14>)
   2385a:	4a04      	ldr	r2, [pc, #16]	; (2386c <DmConnMasterInit+0x18>)
   2385c:	605a      	str	r2, [r3, #4]
}
   2385e:	bf00      	nop
   23860:	46bd      	mov	sp, r7
   23862:	f85d 7b04 	ldr.w	r7, [sp], #4
   23866:	4770      	bx	lr
   23868:	100112dc 	.word	0x100112dc
   2386c:	00045c3c 	.word	0x00045c3c

00023870 <dmConnUpdateCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmConnUpdateCback(dmConnCcb_t *pCcb, uint8_t status)
{
   23870:	b580      	push	{r7, lr}
   23872:	b086      	sub	sp, #24
   23874:	af00      	add	r7, sp, #0
   23876:	6078      	str	r0, [r7, #4]
   23878:	460b      	mov	r3, r1
   2387a:	70fb      	strb	r3, [r7, #3]
  hciLeConnUpdateCmplEvt_t  evt;

  /* call callback */
  evt.hdr.event = DM_CONN_UPDATE_IND;
   2387c:	2329      	movs	r3, #41	; 0x29
   2387e:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = pCcb->connId;
   23880:	687b      	ldr	r3, [r7, #4]
   23882:	7c1b      	ldrb	r3, [r3, #16]
   23884:	b29b      	uxth	r3, r3
   23886:	813b      	strh	r3, [r7, #8]
  evt.status = evt.hdr.status = status;
   23888:	78fb      	ldrb	r3, [r7, #3]
   2388a:	72fb      	strb	r3, [r7, #11]
   2388c:	7afb      	ldrb	r3, [r7, #11]
   2388e:	733b      	strb	r3, [r7, #12]
  evt.handle = pCcb->handle;
   23890:	687b      	ldr	r3, [r7, #4]
   23892:	899b      	ldrh	r3, [r3, #12]
   23894:	81fb      	strh	r3, [r7, #14]
  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *) &evt);
   23896:	4b05      	ldr	r3, [pc, #20]	; (238ac <dmConnUpdateCback+0x3c>)
   23898:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   2389c:	f107 0208 	add.w	r2, r7, #8
   238a0:	4610      	mov	r0, r2
   238a2:	4798      	blx	r3
}
   238a4:	bf00      	nop
   238a6:	3718      	adds	r7, #24
   238a8:	46bd      	mov	sp, r7
   238aa:	bd80      	pop	{r7, pc}
   238ac:	10011218 	.word	0x10011218

000238b0 <dmConnSmActUpdateSlave>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActUpdateSlave(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   238b0:	b580      	push	{r7, lr}
   238b2:	b082      	sub	sp, #8
   238b4:	af00      	add	r7, sp, #0
   238b6:	6078      	str	r0, [r7, #4]
   238b8:	6039      	str	r1, [r7, #0]
  if ((pCcb->features & HCI_LE_SUP_FEAT_CONN_PARAM_REQ_PROC) &&
   238ba:	687b      	ldr	r3, [r7, #4]
   238bc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   238be:	f003 0302 	and.w	r3, r3, #2
   238c2:	2b00      	cmp	r3, #0
   238c4:	d00f      	beq.n	238e6 <dmConnSmActUpdateSlave+0x36>
      (HciGetLeSupFeat() & HCI_LE_SUP_FEAT_CONN_PARAM_REQ_PROC))
   238c6:	f002 fdc1 	bl	2644c <HciGetLeSupFeat>
   238ca:	4603      	mov	r3, r0
   238cc:	f003 0302 	and.w	r3, r3, #2
  if ((pCcb->features & HCI_LE_SUP_FEAT_CONN_PARAM_REQ_PROC) &&
   238d0:	2b00      	cmp	r3, #0
   238d2:	d008      	beq.n	238e6 <dmConnSmActUpdateSlave+0x36>
  {
    HciLeConnUpdateCmd(pCcb->handle, &pMsg->apiUpdate.connSpec);
   238d4:	687b      	ldr	r3, [r7, #4]
   238d6:	899a      	ldrh	r2, [r3, #12]
   238d8:	683b      	ldr	r3, [r7, #0]
   238da:	3304      	adds	r3, #4
   238dc:	4619      	mov	r1, r3
   238de:	4610      	mov	r0, r2
   238e0:	f001 fac4 	bl	24e6c <HciLeConnUpdateCmd>
  else
  {
    /* call callback */
    dmConnUpdateCback(pCcb, (uint8_t) HCI_ERR_CMD_DISALLOWED);
  }
}
   238e4:	e013      	b.n	2390e <dmConnSmActUpdateSlave+0x5e>
  else if (!pCcb->updating)
   238e6:	687b      	ldr	r3, [r7, #4]
   238e8:	7c5b      	ldrb	r3, [r3, #17]
   238ea:	2b00      	cmp	r3, #0
   238ec:	d10b      	bne.n	23906 <dmConnSmActUpdateSlave+0x56>
    pCcb->updating = TRUE;
   238ee:	687b      	ldr	r3, [r7, #4]
   238f0:	2201      	movs	r2, #1
   238f2:	745a      	strb	r2, [r3, #17]
    L2cDmConnUpdateReq(pCcb->handle, &pMsg->apiUpdate.connSpec);
   238f4:	687b      	ldr	r3, [r7, #4]
   238f6:	899a      	ldrh	r2, [r3, #12]
   238f8:	683b      	ldr	r3, [r7, #0]
   238fa:	3304      	adds	r3, #4
   238fc:	4619      	mov	r1, r3
   238fe:	4610      	mov	r0, r2
   23900:	f006 fd00 	bl	2a304 <L2cDmConnUpdateReq>
}
   23904:	e003      	b.n	2390e <dmConnSmActUpdateSlave+0x5e>
    dmConnUpdateCback(pCcb, (uint8_t) HCI_ERR_CMD_DISALLOWED);
   23906:	210c      	movs	r1, #12
   23908:	6878      	ldr	r0, [r7, #4]
   2390a:	f7ff ffb1 	bl	23870 <dmConnUpdateCback>
}
   2390e:	bf00      	nop
   23910:	3708      	adds	r7, #8
   23912:	46bd      	mov	sp, r7
   23914:	bd80      	pop	{r7, pc}

00023916 <dmConnSmActL2cUpdateCnf>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActL2cUpdateCnf(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   23916:	b580      	push	{r7, lr}
   23918:	b082      	sub	sp, #8
   2391a:	af00      	add	r7, sp, #0
   2391c:	6078      	str	r0, [r7, #4]
   2391e:	6039      	str	r1, [r7, #0]
  /* if connection update in progress */
  if (pCcb->updating)
   23920:	687b      	ldr	r3, [r7, #4]
   23922:	7c5b      	ldrb	r3, [r3, #17]
   23924:	2b00      	cmp	r3, #0
   23926:	d00d      	beq.n	23944 <dmConnSmActL2cUpdateCnf+0x2e>
  {
    pCcb->updating = FALSE;
   23928:	687b      	ldr	r3, [r7, #4]
   2392a:	2200      	movs	r2, #0
   2392c:	745a      	strb	r2, [r3, #17]

    /* if reason indicates failure */
    if (pMsg->l2cUpdateCnf.result != L2C_CONN_PARAM_ACCEPTED)
   2392e:	683b      	ldr	r3, [r7, #0]
   23930:	889b      	ldrh	r3, [r3, #4]
   23932:	2b00      	cmp	r3, #0
   23934:	d006      	beq.n	23944 <dmConnSmActL2cUpdateCnf+0x2e>
    {
      /* call callback */
      dmConnUpdateCback(pCcb, (uint8_t) pMsg->l2cUpdateCnf.result);
   23936:	683b      	ldr	r3, [r7, #0]
   23938:	889b      	ldrh	r3, [r3, #4]
   2393a:	b2db      	uxtb	r3, r3
   2393c:	4619      	mov	r1, r3
   2393e:	6878      	ldr	r0, [r7, #4]
   23940:	f7ff ff96 	bl	23870 <dmConnUpdateCback>
    }
  }
}
   23944:	bf00      	nop
   23946:	3708      	adds	r7, #8
   23948:	46bd      	mov	sp, r7
   2394a:	bd80      	pop	{r7, pc}

0002394c <DmL2cConnUpdateCnf>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmL2cConnUpdateCnf(uint16_t handle, uint16_t result)
{
   2394c:	b580      	push	{r7, lr}
   2394e:	b086      	sub	sp, #24
   23950:	af00      	add	r7, sp, #0
   23952:	4603      	mov	r3, r0
   23954:	460a      	mov	r2, r1
   23956:	80fb      	strh	r3, [r7, #6]
   23958:	4613      	mov	r3, r2
   2395a:	80bb      	strh	r3, [r7, #4]
  dmConnL2cUpdateCnf_t  updateCnf;
  dmConnCcb_t           *pCcb;

  if ((pCcb = dmConnCcbByHandle(handle)) != NULL)
   2395c:	88fb      	ldrh	r3, [r7, #6]
   2395e:	4618      	mov	r0, r3
   23960:	f7fe ff2e 	bl	227c0 <dmConnCcbByHandle>
   23964:	6178      	str	r0, [r7, #20]
   23966:	697b      	ldr	r3, [r7, #20]
   23968:	2b00      	cmp	r3, #0
   2396a:	d009      	beq.n	23980 <DmL2cConnUpdateCnf+0x34>
  {
    updateCnf.hdr.event = DM_CONN_MSG_L2C_UPDATE_CNF;
   2396c:	2336      	movs	r3, #54	; 0x36
   2396e:	73bb      	strb	r3, [r7, #14]
    updateCnf.result = result;
   23970:	88bb      	ldrh	r3, [r7, #4]
   23972:	823b      	strh	r3, [r7, #16]

    dmConnSmExecute(pCcb, (dmConnMsg_t *) &updateCnf);
   23974:	f107 030c 	add.w	r3, r7, #12
   23978:	4619      	mov	r1, r3
   2397a:	6978      	ldr	r0, [r7, #20]
   2397c:	f000 f870 	bl	23a60 <dmConnSmExecute>
  }
}
   23980:	bf00      	nop
   23982:	3718      	adds	r7, #24
   23984:	46bd      	mov	sp, r7
   23986:	bd80      	pop	{r7, pc}

00023988 <DmL2cCmdRejInd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmL2cCmdRejInd(uint16_t handle, uint16_t result)
{
   23988:	b580      	push	{r7, lr}
   2398a:	b084      	sub	sp, #16
   2398c:	af00      	add	r7, sp, #0
   2398e:	4603      	mov	r3, r0
   23990:	460a      	mov	r2, r1
   23992:	80fb      	strh	r3, [r7, #6]
   23994:	4613      	mov	r3, r2
   23996:	80bb      	strh	r3, [r7, #4]
  dmL2cCmdRejEvt_t  evt;

  /* call callback */
  evt.hdr.event = DM_L2C_CMD_REJ_IND;
   23998:	2364      	movs	r3, #100	; 0x64
   2399a:	72bb      	strb	r3, [r7, #10]
  evt.hdr.status = HCI_SUCCESS;
   2399c:	2300      	movs	r3, #0
   2399e:	72fb      	strb	r3, [r7, #11]
  evt.reason = result;
   239a0:	88bb      	ldrh	r3, [r7, #4]
   239a2:	81bb      	strh	r3, [r7, #12]
  evt.handle = handle;
   239a4:	88fb      	ldrh	r3, [r7, #6]
   239a6:	81fb      	strh	r3, [r7, #14]
  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *)&evt);
   239a8:	4b05      	ldr	r3, [pc, #20]	; (239c0 <DmL2cCmdRejInd+0x38>)
   239aa:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   239ae:	f107 0208 	add.w	r2, r7, #8
   239b2:	4610      	mov	r0, r2
   239b4:	4798      	blx	r3
}
   239b6:	bf00      	nop
   239b8:	3710      	adds	r7, #16
   239ba:	46bd      	mov	sp, r7
   239bc:	bd80      	pop	{r7, pc}
   239be:	bf00      	nop
   239c0:	10011218 	.word	0x10011218

000239c4 <dmConnSmActAccept>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActAccept(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   239c4:	b580      	push	{r7, lr}
   239c6:	b082      	sub	sp, #8
   239c8:	af00      	add	r7, sp, #0
   239ca:	6078      	str	r0, [r7, #4]
   239cc:	6039      	str	r1, [r7, #0]
  dmAdvStartDirected(pMsg->apiOpen.advType, pMsg->apiOpen.duration, pMsg->apiOpen.addrType,
   239ce:	683b      	ldr	r3, [r7, #0]
   239d0:	7998      	ldrb	r0, [r3, #6]
   239d2:	683b      	ldr	r3, [r7, #0]
   239d4:	8919      	ldrh	r1, [r3, #8]
   239d6:	683b      	ldr	r3, [r7, #0]
   239d8:	7c5a      	ldrb	r2, [r3, #17]
                     pMsg->apiOpen.peerAddr);
   239da:	683b      	ldr	r3, [r7, #0]
   239dc:	330b      	adds	r3, #11
  dmAdvStartDirected(pMsg->apiOpen.advType, pMsg->apiOpen.duration, pMsg->apiOpen.addrType,
   239de:	f7fe fdab 	bl	22538 <dmAdvStartDirected>
}
   239e2:	bf00      	nop
   239e4:	3708      	adds	r7, #8
   239e6:	46bd      	mov	sp, r7
   239e8:	bd80      	pop	{r7, pc}

000239ea <dmConnSmActCancelAccept>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActCancelAccept(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   239ea:	b580      	push	{r7, lr}
   239ec:	b082      	sub	sp, #8
   239ee:	af00      	add	r7, sp, #0
   239f0:	6078      	str	r0, [r7, #4]
   239f2:	6039      	str	r1, [r7, #0]
  dmAdvStopDirected();
   239f4:	f7fe fdd4 	bl	225a0 <dmAdvStopDirected>

  dmConnSmActConnFailed(pCcb, pMsg);
   239f8:	6839      	ldr	r1, [r7, #0]
   239fa:	6878      	ldr	r0, [r7, #4]
   239fc:	f7ff f8ac 	bl	22b58 <dmConnSmActConnFailed>
}
   23a00:	bf00      	nop
   23a02:	3708      	adds	r7, #8
   23a04:	46bd      	mov	sp, r7
   23a06:	bd80      	pop	{r7, pc}

00023a08 <dmConnSmActConnAccepted>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActConnAccepted(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   23a08:	b580      	push	{r7, lr}
   23a0a:	b082      	sub	sp, #8
   23a0c:	af00      	add	r7, sp, #0
   23a0e:	6078      	str	r0, [r7, #4]
   23a10:	6039      	str	r1, [r7, #0]
  dmAdvConnected();
   23a12:	f7fe fded 	bl	225f0 <dmAdvConnected>

  dmConnSmActConnOpened(pCcb, pMsg);
   23a16:	6839      	ldr	r1, [r7, #0]
   23a18:	6878      	ldr	r0, [r7, #4]
   23a1a:	f7ff f823 	bl	22a64 <dmConnSmActConnOpened>
}
   23a1e:	bf00      	nop
   23a20:	3708      	adds	r7, #8
   23a22:	46bd      	mov	sp, r7
   23a24:	bd80      	pop	{r7, pc}

00023a26 <dmConnSmActAcceptFailed>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmActAcceptFailed(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   23a26:	b580      	push	{r7, lr}
   23a28:	b082      	sub	sp, #8
   23a2a:	af00      	add	r7, sp, #0
   23a2c:	6078      	str	r0, [r7, #4]
   23a2e:	6039      	str	r1, [r7, #0]
  dmAdvConnectFailed();
   23a30:	f7fe fdfc 	bl	2262c <dmAdvConnectFailed>

  dmConnSmActConnFailed(pCcb, pMsg);
   23a34:	6839      	ldr	r1, [r7, #0]
   23a36:	6878      	ldr	r0, [r7, #4]
   23a38:	f7ff f88e 	bl	22b58 <dmConnSmActConnFailed>
}
   23a3c:	bf00      	nop
   23a3e:	3708      	adds	r7, #8
   23a40:	46bd      	mov	sp, r7
   23a42:	bd80      	pop	{r7, pc}

00023a44 <DmConnSlaveInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmConnSlaveInit(void)
{
   23a44:	b480      	push	{r7}
   23a46:	af00      	add	r7, sp, #0
  dmConnActSet[DM_CONN_ACT_SET_SLAVE] = (dmConnAct_t *) dmConnActSetSlave;
   23a48:	4b03      	ldr	r3, [pc, #12]	; (23a58 <DmConnSlaveInit+0x14>)
   23a4a:	4a04      	ldr	r2, [pc, #16]	; (23a5c <DmConnSlaveInit+0x18>)
   23a4c:	609a      	str	r2, [r3, #8]
}
   23a4e:	bf00      	nop
   23a50:	46bd      	mov	sp, r7
   23a52:	f85d 7b04 	ldr.w	r7, [sp], #4
   23a56:	4770      	bx	lr
   23a58:	100112dc 	.word	0x100112dc
   23a5c:	00045c4c 	.word	0x00045c4c

00023a60 <dmConnSmExecute>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmConnSmExecute(dmConnCcb_t *pCcb, dmConnMsg_t *pMsg)
{
   23a60:	b580      	push	{r7, lr}
   23a62:	b084      	sub	sp, #16
   23a64:	af00      	add	r7, sp, #0
   23a66:	6078      	str	r0, [r7, #4]
   23a68:	6039      	str	r1, [r7, #0]
  dmConnAct_t       *actSet;
  uint8_t           action;
  uint8_t           event;

  DM_TRACE_INFO2("dmConnSmExecute event=%d state=%d", pMsg->hdr.event, pCcb->state);
   23a6a:	683b      	ldr	r3, [r7, #0]
   23a6c:	789b      	ldrb	r3, [r3, #2]
   23a6e:	4619      	mov	r1, r3
   23a70:	687b      	ldr	r3, [r7, #4]
   23a72:	7d5b      	ldrb	r3, [r3, #21]
   23a74:	461a      	mov	r2, r3
   23a76:	4822      	ldr	r0, [pc, #136]	; (23b00 <dmConnSmExecute+0xa0>)
   23a78:	f009 ff8a 	bl	2d990 <WsfTrace>

  /* get the event */
  event = DM_MSG_MASK(pMsg->hdr.event);
   23a7c:	683b      	ldr	r3, [r7, #0]
   23a7e:	789b      	ldrb	r3, [r3, #2]
   23a80:	f003 030f 	and.w	r3, r3, #15
   23a84:	73fb      	strb	r3, [r7, #15]

  /* get action */
  action = dmConnStateTbl[pCcb->state][event][DM_CONN_ACTION];
   23a86:	687b      	ldr	r3, [r7, #4]
   23a88:	7d5b      	ldrb	r3, [r3, #21]
   23a8a:	461a      	mov	r2, r3
   23a8c:	7bf9      	ldrb	r1, [r7, #15]
   23a8e:	481d      	ldr	r0, [pc, #116]	; (23b04 <dmConnSmExecute+0xa4>)
   23a90:	4613      	mov	r3, r2
   23a92:	005b      	lsls	r3, r3, #1
   23a94:	4413      	add	r3, r2
   23a96:	009b      	lsls	r3, r3, #2
   23a98:	4413      	add	r3, r2
   23a9a:	440b      	add	r3, r1
   23a9c:	005b      	lsls	r3, r3, #1
   23a9e:	4403      	add	r3, r0
   23aa0:	785b      	ldrb	r3, [r3, #1]
   23aa2:	73bb      	strb	r3, [r7, #14]

  /* set next state */
  pCcb->state = dmConnStateTbl[pCcb->state][event][DM_CONN_NEXT_STATE];
   23aa4:	687b      	ldr	r3, [r7, #4]
   23aa6:	7d5b      	ldrb	r3, [r3, #21]
   23aa8:	461a      	mov	r2, r3
   23aaa:	7bf9      	ldrb	r1, [r7, #15]
   23aac:	4815      	ldr	r0, [pc, #84]	; (23b04 <dmConnSmExecute+0xa4>)
   23aae:	4613      	mov	r3, r2
   23ab0:	005b      	lsls	r3, r3, #1
   23ab2:	4413      	add	r3, r2
   23ab4:	009b      	lsls	r3, r3, #2
   23ab6:	4413      	add	r3, r2
   23ab8:	440b      	add	r3, r1
   23aba:	f810 2013 	ldrb.w	r2, [r0, r3, lsl #1]
   23abe:	687b      	ldr	r3, [r7, #4]
   23ac0:	755a      	strb	r2, [r3, #21]

  /* look up action set */
  actSet = dmConnActSet[DM_CONN_ACT_SET_ID(action)];
   23ac2:	7bbb      	ldrb	r3, [r7, #14]
   23ac4:	091b      	lsrs	r3, r3, #4
   23ac6:	b2db      	uxtb	r3, r3
   23ac8:	461a      	mov	r2, r3
   23aca:	4b0f      	ldr	r3, [pc, #60]	; (23b08 <dmConnSmExecute+0xa8>)
   23acc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   23ad0:	60bb      	str	r3, [r7, #8]

  /* if action set present */
  if (actSet != NULL)
   23ad2:	68bb      	ldr	r3, [r7, #8]
   23ad4:	2b00      	cmp	r3, #0
   23ad6:	d00a      	beq.n	23aee <dmConnSmExecute+0x8e>
  {
    /* execute action function in action set */
    (*actSet[DM_CONN_ACT_ID(action)])(pCcb, pMsg);
   23ad8:	7bbb      	ldrb	r3, [r7, #14]
   23ada:	f003 030f 	and.w	r3, r3, #15
   23ade:	009b      	lsls	r3, r3, #2
   23ae0:	68ba      	ldr	r2, [r7, #8]
   23ae2:	4413      	add	r3, r2
   23ae4:	681b      	ldr	r3, [r3, #0]
   23ae6:	6839      	ldr	r1, [r7, #0]
   23ae8:	6878      	ldr	r0, [r7, #4]
   23aea:	4798      	blx	r3
  else
  {
     /* no action */
     dmConnSmActNone(pCcb, pMsg);
  }
}
   23aec:	e003      	b.n	23af6 <dmConnSmExecute+0x96>
     dmConnSmActNone(pCcb, pMsg);
   23aee:	6839      	ldr	r1, [r7, #0]
   23af0:	6878      	ldr	r0, [r7, #4]
   23af2:	f7fe ff9b 	bl	22a2c <dmConnSmActNone>
}
   23af6:	bf00      	nop
   23af8:	3710      	adds	r7, #16
   23afa:	46bd      	mov	sp, r7
   23afc:	bd80      	pop	{r7, pc}
   23afe:	bf00      	nop
   23b00:	00044bd8 	.word	0x00044bd8
   23b04:	00045c64 	.word	0x00045c64
   23b08:	100112dc 	.word	0x100112dc

00023b0c <dmDevActReset>:
 *
 *  \return None.
*/
/*************************************************************************************************/
void dmDevActReset(wsfMsgHdr_t *pMsg)
{
   23b0c:	b580      	push	{r7, lr}
   23b0e:	b084      	sub	sp, #16
   23b10:	af00      	add	r7, sp, #0
   23b12:	6078      	str	r0, [r7, #4]
  uint8_t i;

  /* if DM not resetting */
  if (!dmCb.resetting)
   23b14:	4b0d      	ldr	r3, [pc, #52]	; (23b4c <dmDevActReset+0x40>)
   23b16:	7c1b      	ldrb	r3, [r3, #16]
   23b18:	2b00      	cmp	r3, #0
   23b1a:	d113      	bne.n	23b44 <dmDevActReset+0x38>
  {
    /* set resetting state */
    dmCb.resetting = TRUE;
   23b1c:	4b0b      	ldr	r3, [pc, #44]	; (23b4c <dmDevActReset+0x40>)
   23b1e:	2201      	movs	r2, #1
   23b20:	741a      	strb	r2, [r3, #16]

    /* for each DM component */
    for (i = 0; i < DM_NUM_IDS; i++)
   23b22:	2300      	movs	r3, #0
   23b24:	73fb      	strb	r3, [r7, #15]
   23b26:	e008      	b.n	23b3a <dmDevActReset+0x2e>
    {
      /* call component's reset function */
      (*(dmFcnIfTbl[i]->reset))();
   23b28:	7bfb      	ldrb	r3, [r7, #15]
   23b2a:	4a09      	ldr	r2, [pc, #36]	; (23b50 <dmDevActReset+0x44>)
   23b2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   23b30:	681b      	ldr	r3, [r3, #0]
   23b32:	4798      	blx	r3
    for (i = 0; i < DM_NUM_IDS; i++)
   23b34:	7bfb      	ldrb	r3, [r7, #15]
   23b36:	3301      	adds	r3, #1
   23b38:	73fb      	strb	r3, [r7, #15]
   23b3a:	7bfb      	ldrb	r3, [r7, #15]
   23b3c:	2b0d      	cmp	r3, #13
   23b3e:	d9f3      	bls.n	23b28 <dmDevActReset+0x1c>
    }

    /* start HCI reset sequence */
    HciResetSequence();
   23b40:	f002 fad8 	bl	260f4 <HciResetSequence>
  }
}
   23b44:	bf00      	nop
   23b46:	3710      	adds	r7, #16
   23b48:	46bd      	mov	sp, r7
   23b4a:	bd80      	pop	{r7, pc}
   23b4c:	100112ec 	.word	0x100112ec
   23b50:	10002b90 	.word	0x10002b90

00023b54 <dmDevHciEvtReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmDevHciEvtReset(hciEvt_t *pEvent)
{
   23b54:	b580      	push	{r7, lr}
   23b56:	b082      	sub	sp, #8
   23b58:	af00      	add	r7, sp, #0
   23b5a:	6078      	str	r0, [r7, #4]
  /* reset resetting state */
  dmCb.resetting = FALSE;
   23b5c:	4b06      	ldr	r3, [pc, #24]	; (23b78 <dmDevHciEvtReset+0x24>)
   23b5e:	2200      	movs	r2, #0
   23b60:	741a      	strb	r2, [r3, #16]

  pEvent->hdr.event = DM_RESET_CMPL_IND;
   23b62:	687b      	ldr	r3, [r7, #4]
   23b64:	2220      	movs	r2, #32
   23b66:	709a      	strb	r2, [r3, #2]
  (*dmCb.cback)((dmEvt_t *) pEvent);
   23b68:	4b03      	ldr	r3, [pc, #12]	; (23b78 <dmDevHciEvtReset+0x24>)
   23b6a:	689b      	ldr	r3, [r3, #8]
   23b6c:	6878      	ldr	r0, [r7, #4]
   23b6e:	4798      	blx	r3
}
   23b70:	bf00      	nop
   23b72:	3708      	adds	r7, #8
   23b74:	46bd      	mov	sp, r7
   23b76:	bd80      	pop	{r7, pc}
   23b78:	100112ec 	.word	0x100112ec

00023b7c <dmDevHciEvtVendorSpec>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmDevHciEvtVendorSpec(hciEvt_t *pEvent)
{
   23b7c:	b580      	push	{r7, lr}
   23b7e:	b082      	sub	sp, #8
   23b80:	af00      	add	r7, sp, #0
   23b82:	6078      	str	r0, [r7, #4]
  pEvent->hdr.event = DM_VENDOR_SPEC_IND;
   23b84:	687b      	ldr	r3, [r7, #4]
   23b86:	2267      	movs	r2, #103	; 0x67
   23b88:	709a      	strb	r2, [r3, #2]
  (*dmCb.cback)((dmEvt_t *) pEvent);
   23b8a:	4b04      	ldr	r3, [pc, #16]	; (23b9c <dmDevHciEvtVendorSpec+0x20>)
   23b8c:	689b      	ldr	r3, [r3, #8]
   23b8e:	6878      	ldr	r0, [r7, #4]
   23b90:	4798      	blx	r3
}
   23b92:	bf00      	nop
   23b94:	3708      	adds	r7, #8
   23b96:	46bd      	mov	sp, r7
   23b98:	bd80      	pop	{r7, pc}
   23b9a:	bf00      	nop
   23b9c:	100112ec 	.word	0x100112ec

00023ba0 <dmDevHciEvtHwError>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmDevHciEvtHwError(hciEvt_t *pEvent)
{
   23ba0:	b580      	push	{r7, lr}
   23ba2:	b082      	sub	sp, #8
   23ba4:	af00      	add	r7, sp, #0
   23ba6:	6078      	str	r0, [r7, #4]
  pEvent->hdr.event = DM_HW_ERROR_IND;
   23ba8:	687b      	ldr	r3, [r7, #4]
   23baa:	2266      	movs	r2, #102	; 0x66
   23bac:	709a      	strb	r2, [r3, #2]
  (*dmCb.cback)((dmEvt_t *) pEvent);
   23bae:	4b04      	ldr	r3, [pc, #16]	; (23bc0 <dmDevHciEvtHwError+0x20>)
   23bb0:	689b      	ldr	r3, [r3, #8]
   23bb2:	6878      	ldr	r0, [r7, #4]
   23bb4:	4798      	blx	r3
}
   23bb6:	bf00      	nop
   23bb8:	3708      	adds	r7, #8
   23bba:	46bd      	mov	sp, r7
   23bbc:	bd80      	pop	{r7, pc}
   23bbe:	bf00      	nop
   23bc0:	100112ec 	.word	0x100112ec

00023bc4 <dmDevHciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmDevHciHandler(hciEvt_t *pEvent)
{
   23bc4:	b580      	push	{r7, lr}
   23bc6:	b082      	sub	sp, #8
   23bc8:	af00      	add	r7, sp, #0
   23bca:	6078      	str	r0, [r7, #4]
  switch (pEvent->hdr.event)
   23bcc:	687b      	ldr	r3, [r7, #4]
   23bce:	789b      	ldrb	r3, [r3, #2]
   23bd0:	2b14      	cmp	r3, #20
   23bd2:	d011      	beq.n	23bf8 <dmDevHciHandler+0x34>
   23bd4:	2b14      	cmp	r3, #20
   23bd6:	dc13      	bgt.n	23c00 <dmDevHciHandler+0x3c>
   23bd8:	2b00      	cmp	r3, #0
   23bda:	d005      	beq.n	23be8 <dmDevHciHandler+0x24>
   23bdc:	2b00      	cmp	r3, #0
   23bde:	db0f      	blt.n	23c00 <dmDevHciHandler+0x3c>
   23be0:	3b12      	subs	r3, #18
   23be2:	2b01      	cmp	r3, #1
   23be4:	d80c      	bhi.n	23c00 <dmDevHciHandler+0x3c>
   23be6:	e003      	b.n	23bf0 <dmDevHciHandler+0x2c>
  {
    case HCI_RESET_SEQ_CMPL_CBACK_EVT:
      dmDevHciEvtReset(pEvent);
   23be8:	6878      	ldr	r0, [r7, #4]
   23bea:	f7ff ffb3 	bl	23b54 <dmDevHciEvtReset>
      break;
   23bee:	e008      	b.n	23c02 <dmDevHciHandler+0x3e>

    case HCI_VENDOR_SPEC_CMD_CMPL_CBACK_EVT:
    case HCI_VENDOR_SPEC_CBACK_EVT:
      dmDevHciEvtVendorSpec(pEvent);
   23bf0:	6878      	ldr	r0, [r7, #4]
   23bf2:	f7ff ffc3 	bl	23b7c <dmDevHciEvtVendorSpec>
      break;
   23bf6:	e004      	b.n	23c02 <dmDevHciHandler+0x3e>

    case HCI_HW_ERROR_CBACK_EVT:
      dmDevHciEvtHwError(pEvent);
   23bf8:	6878      	ldr	r0, [r7, #4]
   23bfa:	f7ff ffd1 	bl	23ba0 <dmDevHciEvtHwError>
      break;
   23bfe:	e000      	b.n	23c02 <dmDevHciHandler+0x3e>

    default:
      /* ignore event */
      break;
   23c00:	bf00      	nop
  }
}
   23c02:	bf00      	nop
   23c04:	3708      	adds	r7, #8
   23c06:	46bd      	mov	sp, r7
   23c08:	bd80      	pop	{r7, pc}
	...

00023c0c <dmDevMsgHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmDevMsgHandler(wsfMsgHdr_t *pMsg)
{
   23c0c:	b580      	push	{r7, lr}
   23c0e:	b082      	sub	sp, #8
   23c10:	af00      	add	r7, sp, #0
   23c12:	6078      	str	r0, [r7, #4]
  /* execute action function */
  (*dmDevAct[DM_MSG_MASK(pMsg->event)])(pMsg);
   23c14:	4b03      	ldr	r3, [pc, #12]	; (23c24 <dmDevMsgHandler+0x18>)
   23c16:	6878      	ldr	r0, [r7, #4]
   23c18:	4798      	blx	r3
}
   23c1a:	bf00      	nop
   23c1c:	3708      	adds	r7, #8
   23c1e:	46bd      	mov	sp, r7
   23c20:	bd80      	pop	{r7, pc}
   23c22:	bf00      	nop
   23c24:	00023b0d 	.word	0x00023b0d

00023c28 <dmDevPassEvtToDevPriv>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmDevPassEvtToDevPriv(uint8_t event, uint8_t param, uint8_t advHandle, bool_t connectable)
{
   23c28:	b590      	push	{r4, r7, lr}
   23c2a:	b085      	sub	sp, #20
   23c2c:	af00      	add	r7, sp, #0
   23c2e:	4604      	mov	r4, r0
   23c30:	4608      	mov	r0, r1
   23c32:	4611      	mov	r1, r2
   23c34:	461a      	mov	r2, r3
   23c36:	4623      	mov	r3, r4
   23c38:	71fb      	strb	r3, [r7, #7]
   23c3a:	4603      	mov	r3, r0
   23c3c:	71bb      	strb	r3, [r7, #6]
   23c3e:	460b      	mov	r3, r1
   23c40:	717b      	strb	r3, [r7, #5]
   23c42:	4613      	mov	r3, r2
   23c44:	713b      	strb	r3, [r7, #4]
  dmDevPrivMsg_t evt;

  DM_TRACE_INFO3("dmDevPassEvtToDevPriv: event: %d, param: %d, advHandle: %d", event, param, advHandle);
   23c46:	79f9      	ldrb	r1, [r7, #7]
   23c48:	79ba      	ldrb	r2, [r7, #6]
   23c4a:	797b      	ldrb	r3, [r7, #5]
   23c4c:	480b      	ldr	r0, [pc, #44]	; (23c7c <dmDevPassEvtToDevPriv+0x54>)
   23c4e:	f009 fe9f 	bl	2d990 <WsfTrace>

  /* build event */
  evt.hdr.event = event;
   23c52:	79fb      	ldrb	r3, [r7, #7]
   23c54:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = param;
   23c56:	79bb      	ldrb	r3, [r7, #6]
   23c58:	b29b      	uxth	r3, r3
   23c5a:	813b      	strh	r3, [r7, #8]
  evt.privCtrl.advHandle = advHandle;
   23c5c:	797b      	ldrb	r3, [r7, #5]
   23c5e:	733b      	strb	r3, [r7, #12]
  evt.privCtrl.connectable = connectable;
   23c60:	793b      	ldrb	r3, [r7, #4]
   23c62:	737b      	strb	r3, [r7, #13]

  /* pass event to device privacy */
  (*(dmFcnIfTbl[DM_ID_DEV_PRIV]->msgHandler))((wsfMsgHdr_t *) &evt);
   23c64:	4b06      	ldr	r3, [pc, #24]	; (23c80 <dmDevPassEvtToDevPriv+0x58>)
   23c66:	685b      	ldr	r3, [r3, #4]
   23c68:	689b      	ldr	r3, [r3, #8]
   23c6a:	f107 0208 	add.w	r2, r7, #8
   23c6e:	4610      	mov	r0, r2
   23c70:	4798      	blx	r3
}
   23c72:	bf00      	nop
   23c74:	3714      	adds	r7, #20
   23c76:	46bd      	mov	sp, r7
   23c78:	bd90      	pop	{r4, r7, pc}
   23c7a:	bf00      	nop
   23c7c:	00044bfc 	.word	0x00044bfc
   23c80:	10002b90 	.word	0x10002b90

00023c84 <dmDevPassEvtToConnCte>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmDevPassEvtToConnCte(uint8_t state, dmConnId_t connId)
{
   23c84:	b580      	push	{r7, lr}
   23c86:	b084      	sub	sp, #16
   23c88:	af00      	add	r7, sp, #0
   23c8a:	4603      	mov	r3, r0
   23c8c:	460a      	mov	r2, r1
   23c8e:	71fb      	strb	r3, [r7, #7]
   23c90:	4613      	mov	r3, r2
   23c92:	71bb      	strb	r3, [r7, #6]
  wsfMsgHdr_t evt;

  /* build event */
  evt.event = DM_CONN_CTE_MSG_STATE;
   23c94:	23d7      	movs	r3, #215	; 0xd7
   23c96:	73bb      	strb	r3, [r7, #14]
  evt.status = state;
   23c98:	79fb      	ldrb	r3, [r7, #7]
   23c9a:	73fb      	strb	r3, [r7, #15]
  evt.param = connId;
   23c9c:	79bb      	ldrb	r3, [r7, #6]
   23c9e:	b29b      	uxth	r3, r3
   23ca0:	81bb      	strh	r3, [r7, #12]

  /* pass event to Connection CTE */
  (*(dmFcnIfTbl[DM_ID_CONN_CTE]->msgHandler))(&evt);
   23ca2:	4b05      	ldr	r3, [pc, #20]	; (23cb8 <dmDevPassEvtToConnCte+0x34>)
   23ca4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
   23ca6:	689b      	ldr	r3, [r3, #8]
   23ca8:	f107 020c 	add.w	r2, r7, #12
   23cac:	4610      	mov	r0, r2
   23cae:	4798      	blx	r3
}
   23cb0:	bf00      	nop
   23cb2:	3710      	adds	r7, #16
   23cb4:	46bd      	mov	sp, r7
   23cb6:	bd80      	pop	{r7, pc}
   23cb8:	10002b90 	.word	0x10002b90

00023cbc <DmDevReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmDevReset(void)
{
   23cbc:	b580      	push	{r7, lr}
   23cbe:	b082      	sub	sp, #8
   23cc0:	af00      	add	r7, sp, #0
  wsfMsgHdr_t *pMsg;

  // if DM reset still in progress, clear flag
  if(dmCb.resetting)
   23cc2:	4b0d      	ldr	r3, [pc, #52]	; (23cf8 <DmDevReset+0x3c>)
   23cc4:	7c1b      	ldrb	r3, [r3, #16]
   23cc6:	2b00      	cmp	r3, #0
   23cc8:	d002      	beq.n	23cd0 <DmDevReset+0x14>
  {
    dmCb.resetting = FALSE;
   23cca:	4b0b      	ldr	r3, [pc, #44]	; (23cf8 <DmDevReset+0x3c>)
   23ccc:	2200      	movs	r2, #0
   23cce:	741a      	strb	r2, [r3, #16]
  }

  if ((pMsg = WsfMsgAlloc(sizeof(wsfMsgHdr_t))) != NULL)
   23cd0:	2004      	movs	r0, #4
   23cd2:	f009 f9ec 	bl	2d0ae <WsfMsgAlloc>
   23cd6:	6078      	str	r0, [r7, #4]
   23cd8:	687b      	ldr	r3, [r7, #4]
   23cda:	2b00      	cmp	r3, #0
   23cdc:	d008      	beq.n	23cf0 <DmDevReset+0x34>
  {
    pMsg->event = DM_DEV_MSG_API_RESET;
   23cde:	687b      	ldr	r3, [r7, #4]
   23ce0:	2270      	movs	r2, #112	; 0x70
   23ce2:	709a      	strb	r2, [r3, #2]

    WsfMsgSend(dmCb.handlerId, pMsg);
   23ce4:	4b04      	ldr	r3, [pc, #16]	; (23cf8 <DmDevReset+0x3c>)
   23ce6:	7b1b      	ldrb	r3, [r3, #12]
   23ce8:	6879      	ldr	r1, [r7, #4]
   23cea:	4618      	mov	r0, r3
   23cec:	f009 fa03 	bl	2d0f6 <WsfMsgSend>
  }
}
   23cf0:	bf00      	nop
   23cf2:	3708      	adds	r7, #8
   23cf4:	46bd      	mov	sp, r7
   23cf6:	bd80      	pop	{r7, pc}
   23cf8:	100112ec 	.word	0x100112ec

00023cfc <DmDevVsInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmDevVsInit(uint8_t param)
{
   23cfc:	b580      	push	{r7, lr}
   23cfe:	b082      	sub	sp, #8
   23d00:	af00      	add	r7, sp, #0
   23d02:	4603      	mov	r3, r0
   23d04:	71fb      	strb	r3, [r7, #7]
  HciVsInit(param);
   23d06:	79fb      	ldrb	r3, [r7, #7]
   23d08:	4618      	mov	r0, r3
   23d0a:	f005 fd8e 	bl	2982a <HciVsInit>
}
   23d0e:	bf00      	nop
   23d10:	3708      	adds	r7, #8
   23d12:	46bd      	mov	sp, r7
   23d14:	bd80      	pop	{r7, pc}
	...

00023d18 <dmHciEvtCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmHciEvtCback(hciEvt_t *pEvent)
{
   23d18:	b580      	push	{r7, lr}
   23d1a:	b082      	sub	sp, #8
   23d1c:	af00      	add	r7, sp, #0
   23d1e:	6078      	str	r0, [r7, #4]
  WSF_ASSERT(pEvent->hdr.event <= HCI_LE_CONNLESS_IQ_REPORT_CBACK_EVT);

  /* if DM not resetting or resetting but incoming event is HCI reset sequence complete event */
  if (!dmCb.resetting || (pEvent->hdr.event == HCI_RESET_SEQ_CMPL_CBACK_EVT))
   23d20:	4b0b      	ldr	r3, [pc, #44]	; (23d50 <dmHciEvtCback+0x38>)
   23d22:	7c1b      	ldrb	r3, [r3, #16]
   23d24:	2b00      	cmp	r3, #0
   23d26:	d003      	beq.n	23d30 <dmHciEvtCback+0x18>
   23d28:	687b      	ldr	r3, [r7, #4]
   23d2a:	789b      	ldrb	r3, [r3, #2]
   23d2c:	2b00      	cmp	r3, #0
   23d2e:	d10b      	bne.n	23d48 <dmHciEvtCback+0x30>
  {
    /* route event to DM component handling function */
    (*(dmFcnIfTbl[dmHciToIdTbl[pEvent->hdr.event]]->hciHandler))(pEvent);
   23d30:	687b      	ldr	r3, [r7, #4]
   23d32:	789b      	ldrb	r3, [r3, #2]
   23d34:	461a      	mov	r2, r3
   23d36:	4b07      	ldr	r3, [pc, #28]	; (23d54 <dmHciEvtCback+0x3c>)
   23d38:	5c9b      	ldrb	r3, [r3, r2]
   23d3a:	461a      	mov	r2, r3
   23d3c:	4b06      	ldr	r3, [pc, #24]	; (23d58 <dmHciEvtCback+0x40>)
   23d3e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   23d42:	685b      	ldr	r3, [r3, #4]
   23d44:	6878      	ldr	r0, [r7, #4]
   23d46:	4798      	blx	r3
  }
}
   23d48:	bf00      	nop
   23d4a:	3708      	adds	r7, #8
   23d4c:	46bd      	mov	sp, r7
   23d4e:	bd80      	pop	{r7, pc}
   23d50:	100112ec 	.word	0x100112ec
   23d54:	00045cf4 	.word	0x00045cf4
   23d58:	10002b90 	.word	0x10002b90

00023d5c <dmEmptyReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmEmptyReset(void)
{
   23d5c:	b480      	push	{r7}
   23d5e:	af00      	add	r7, sp, #0
  /* empty */
}
   23d60:	bf00      	nop
   23d62:	46bd      	mov	sp, r7
   23d64:	f85d 7b04 	ldr.w	r7, [sp], #4
   23d68:	4770      	bx	lr

00023d6a <dmEmptyHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmEmptyHandler(wsfMsgHdr_t *pMsg)
{
   23d6a:	b480      	push	{r7}
   23d6c:	b083      	sub	sp, #12
   23d6e:	af00      	add	r7, sp, #0
   23d70:	6078      	str	r0, [r7, #4]
  return;
   23d72:	bf00      	nop
}
   23d74:	370c      	adds	r7, #12
   23d76:	46bd      	mov	sp, r7
   23d78:	f85d 7b04 	ldr.w	r7, [sp], #4
   23d7c:	4770      	bx	lr
	...

00023d80 <dmDevPassHciEvtToConn>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmDevPassHciEvtToConn(hciEvt_t *pEvent)
{
   23d80:	b580      	push	{r7, lr}
   23d82:	b082      	sub	sp, #8
   23d84:	af00      	add	r7, sp, #0
   23d86:	6078      	str	r0, [r7, #4]
  /* pass event to DM connection management module */
  (*(dmFcnIfTbl[DM_ID_CONN]->hciHandler))(pEvent);
   23d88:	4b04      	ldr	r3, [pc, #16]	; (23d9c <dmDevPassHciEvtToConn+0x1c>)
   23d8a:	68db      	ldr	r3, [r3, #12]
   23d8c:	685b      	ldr	r3, [r3, #4]
   23d8e:	6878      	ldr	r0, [r7, #4]
   23d90:	4798      	blx	r3
}
   23d92:	bf00      	nop
   23d94:	3708      	adds	r7, #8
   23d96:	46bd      	mov	sp, r7
   23d98:	bd80      	pop	{r7, pc}
   23d9a:	bf00      	nop
   23d9c:	10002b90 	.word	0x10002b90

00023da0 <DmRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmRegister(dmCback_t cback)
{
   23da0:	b580      	push	{r7, lr}
   23da2:	b09c      	sub	sp, #112	; 0x70
   23da4:	af00      	add	r7, sp, #0
   23da6:	6078      	str	r0, [r7, #4]
  dmCb.cback = cback;
   23da8:	4a0e      	ldr	r2, [pc, #56]	; (23de4 <DmRegister+0x44>)
   23daa:	687b      	ldr	r3, [r7, #4]
   23dac:	6093      	str	r3, [r2, #8]

  /* if LESC is enabled */
  if (dmFcnIfTbl[DM_ID_LESC] != &dmFcnDefault)
   23dae:	4b0e      	ldr	r3, [pc, #56]	; (23de8 <DmRegister+0x48>)
   23db0:	6a1b      	ldr	r3, [r3, #32]
   23db2:	4a0e      	ldr	r2, [pc, #56]	; (23dec <DmRegister+0x4c>)
   23db4:	4293      	cmp	r3, r2
   23db6:	d010      	beq.n	23dda <DmRegister+0x3a>
  {
    /* if largest LESC key length is larger than maximum RX PDU length */
    if (SMP_PUB_KEY_MSG_LEN > (HciGetMaxRxAclLen() - L2C_HDR_LEN))
   23db8:	f002 fb56 	bl	26468 <HciGetMaxRxAclLen>
   23dbc:	4603      	mov	r3, r0
   23dbe:	2b44      	cmp	r3, #68	; 0x44
   23dc0:	d80b      	bhi.n	23dda <DmRegister+0x3a>
    {
      dmEvt_t evt;

      evt.hdr.param = 0;
   23dc2:	2300      	movs	r3, #0
   23dc4:	81bb      	strh	r3, [r7, #12]
      evt.hdr.event = DM_ERROR_IND;
   23dc6:	2365      	movs	r3, #101	; 0x65
   23dc8:	73bb      	strb	r3, [r7, #14]
      evt.hdr.status = DM_ERR_SMP_RX_PDU_LEN_EXCEEDED;
   23dca:	2301      	movs	r3, #1
   23dcc:	73fb      	strb	r3, [r7, #15]

      (*dmCb.cback)(&evt);
   23dce:	4b05      	ldr	r3, [pc, #20]	; (23de4 <DmRegister+0x44>)
   23dd0:	689b      	ldr	r3, [r3, #8]
   23dd2:	f107 020c 	add.w	r2, r7, #12
   23dd6:	4610      	mov	r0, r2
   23dd8:	4798      	blx	r3
    }
  }
}
   23dda:	bf00      	nop
   23ddc:	3770      	adds	r7, #112	; 0x70
   23dde:	46bd      	mov	sp, r7
   23de0:	bd80      	pop	{r7, pc}
   23de2:	bf00      	nop
   23de4:	100112ec 	.word	0x100112ec
   23de8:	10002b90 	.word	0x10002b90
   23dec:	00045d3c 	.word	0x00045d3c

00023df0 <DmFindAdType>:
 *
 *  \return Pointer to advertising data element byte array or NULL if not found.
 */
/*************************************************************************************************/
uint8_t *DmFindAdType(uint8_t adType, uint16_t dataLen, uint8_t *pData)
{
   23df0:	b480      	push	{r7}
   23df2:	b083      	sub	sp, #12
   23df4:	af00      	add	r7, sp, #0
   23df6:	4603      	mov	r3, r0
   23df8:	603a      	str	r2, [r7, #0]
   23dfa:	71fb      	strb	r3, [r7, #7]
   23dfc:	460b      	mov	r3, r1
   23dfe:	80bb      	strh	r3, [r7, #4]
  /* while not at end of data and
   * data element length is not zero and
   * data element length is not erroneously more than the data length
   */
  while ((dataLen != 0) && (pData[DM_AD_LEN_IDX] != 0) && (pData[DM_AD_LEN_IDX] < dataLen))
   23e00:	e015      	b.n	23e2e <DmFindAdType+0x3e>
  {
    /* if found */
    if (pData[DM_AD_TYPE_IDX] == adType)
   23e02:	683b      	ldr	r3, [r7, #0]
   23e04:	3301      	adds	r3, #1
   23e06:	781b      	ldrb	r3, [r3, #0]
   23e08:	79fa      	ldrb	r2, [r7, #7]
   23e0a:	429a      	cmp	r2, r3
   23e0c:	d101      	bne.n	23e12 <DmFindAdType+0x22>
    {
      return pData;
   23e0e:	683b      	ldr	r3, [r7, #0]
   23e10:	e01b      	b.n	23e4a <DmFindAdType+0x5a>
    }

    /* else go to next element */
    dataLen = dataLen - pData[DM_AD_LEN_IDX] - 1;
   23e12:	683b      	ldr	r3, [r7, #0]
   23e14:	781b      	ldrb	r3, [r3, #0]
   23e16:	b29b      	uxth	r3, r3
   23e18:	88ba      	ldrh	r2, [r7, #4]
   23e1a:	1ad3      	subs	r3, r2, r3
   23e1c:	b29b      	uxth	r3, r3
   23e1e:	3b01      	subs	r3, #1
   23e20:	80bb      	strh	r3, [r7, #4]
    pData = pData + pData[DM_AD_LEN_IDX] + 1;
   23e22:	683b      	ldr	r3, [r7, #0]
   23e24:	781b      	ldrb	r3, [r3, #0]
   23e26:	3301      	adds	r3, #1
   23e28:	683a      	ldr	r2, [r7, #0]
   23e2a:	4413      	add	r3, r2
   23e2c:	603b      	str	r3, [r7, #0]
  while ((dataLen != 0) && (pData[DM_AD_LEN_IDX] != 0) && (pData[DM_AD_LEN_IDX] < dataLen))
   23e2e:	88bb      	ldrh	r3, [r7, #4]
   23e30:	2b00      	cmp	r3, #0
   23e32:	d009      	beq.n	23e48 <DmFindAdType+0x58>
   23e34:	683b      	ldr	r3, [r7, #0]
   23e36:	781b      	ldrb	r3, [r3, #0]
   23e38:	2b00      	cmp	r3, #0
   23e3a:	d005      	beq.n	23e48 <DmFindAdType+0x58>
   23e3c:	683b      	ldr	r3, [r7, #0]
   23e3e:	781b      	ldrb	r3, [r3, #0]
   23e40:	b29b      	uxth	r3, r3
   23e42:	88ba      	ldrh	r2, [r7, #4]
   23e44:	429a      	cmp	r2, r3
   23e46:	d8dc      	bhi.n	23e02 <DmFindAdType+0x12>
  }

  /* not found */
  return NULL;
   23e48:	2300      	movs	r3, #0
}
   23e4a:	4618      	mov	r0, r3
   23e4c:	370c      	adds	r7, #12
   23e4e:	46bd      	mov	sp, r7
   23e50:	f85d 7b04 	ldr.w	r7, [sp], #4
   23e54:	4770      	bx	lr
	...

00023e58 <DmHandlerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmHandlerInit(wsfHandlerId_t handlerId)
{
   23e58:	b580      	push	{r7, lr}
   23e5a:	b082      	sub	sp, #8
   23e5c:	af00      	add	r7, sp, #0
   23e5e:	4603      	mov	r3, r0
   23e60:	71fb      	strb	r3, [r7, #7]
  /* store handler ID */
  dmCb.handlerId = handlerId;
   23e62:	4a08      	ldr	r2, [pc, #32]	; (23e84 <DmHandlerInit+0x2c>)
   23e64:	79fb      	ldrb	r3, [r7, #7]
   23e66:	7313      	strb	r3, [r2, #12]

  dmCb.llPrivEnabled = FALSE;
   23e68:	4b06      	ldr	r3, [pc, #24]	; (23e84 <DmHandlerInit+0x2c>)
   23e6a:	2200      	movs	r2, #0
   23e6c:	755a      	strb	r2, [r3, #21]
  dmCb.resetting = FALSE;
   23e6e:	4b05      	ldr	r3, [pc, #20]	; (23e84 <DmHandlerInit+0x2c>)
   23e70:	2200      	movs	r2, #0
   23e72:	741a      	strb	r2, [r3, #16]

  /* register with the HCI event interface */
  HciEvtRegister(dmHciEvtCback);
   23e74:	4804      	ldr	r0, [pc, #16]	; (23e88 <DmHandlerInit+0x30>)
   23e76:	f005 f8cf 	bl	29018 <HciEvtRegister>
}
   23e7a:	bf00      	nop
   23e7c:	3708      	adds	r7, #8
   23e7e:	46bd      	mov	sp, r7
   23e80:	bd80      	pop	{r7, pc}
   23e82:	bf00      	nop
   23e84:	100112ec 	.word	0x100112ec
   23e88:	00023d19 	.word	0x00023d19

00023e8c <DmHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   23e8c:	b580      	push	{r7, lr}
   23e8e:	b082      	sub	sp, #8
   23e90:	af00      	add	r7, sp, #0
   23e92:	4603      	mov	r3, r0
   23e94:	6039      	str	r1, [r7, #0]
   23e96:	71fb      	strb	r3, [r7, #7]
  /* Handle message */
  if (pMsg != NULL)
   23e98:	683b      	ldr	r3, [r7, #0]
   23e9a:	2b00      	cmp	r3, #0
   23e9c:	d00e      	beq.n	23ebc <DmHandler+0x30>
  {
    WSF_ASSERT(DM_ID_FROM_MSG(pMsg->event) < DM_NUM_IDS);

    /* if DM not resetting */
    if (!dmCb.resetting)
   23e9e:	4b09      	ldr	r3, [pc, #36]	; (23ec4 <DmHandler+0x38>)
   23ea0:	7c1b      	ldrb	r3, [r3, #16]
   23ea2:	2b00      	cmp	r3, #0
   23ea4:	d10a      	bne.n	23ebc <DmHandler+0x30>
    {
      /* route message to DM component handling function */
      (*(dmFcnIfTbl[DM_ID_FROM_MSG(pMsg->event)]->msgHandler))(pMsg);
   23ea6:	683b      	ldr	r3, [r7, #0]
   23ea8:	789b      	ldrb	r3, [r3, #2]
   23eaa:	091b      	lsrs	r3, r3, #4
   23eac:	b2db      	uxtb	r3, r3
   23eae:	461a      	mov	r2, r3
   23eb0:	4b05      	ldr	r3, [pc, #20]	; (23ec8 <DmHandler+0x3c>)
   23eb2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   23eb6:	689b      	ldr	r3, [r3, #8]
   23eb8:	6838      	ldr	r0, [r7, #0]
   23eba:	4798      	blx	r3
  /* Handle events */
  else if (event)
  {

  }
}
   23ebc:	bf00      	nop
   23ebe:	3708      	adds	r7, #8
   23ec0:	46bd      	mov	sp, r7
   23ec2:	bd80      	pop	{r7, pc}
   23ec4:	100112ec 	.word	0x100112ec
   23ec8:	10002b90 	.word	0x10002b90

00023ecc <DmLlPrivEnabled>:
 *
 *  \return TRUE if LL Privacy is enabled. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t DmLlPrivEnabled(void)
{
   23ecc:	b480      	push	{r7}
   23ece:	af00      	add	r7, sp, #0
  return dmCb.llPrivEnabled;
   23ed0:	4b03      	ldr	r3, [pc, #12]	; (23ee0 <DmLlPrivEnabled+0x14>)
   23ed2:	7d5b      	ldrb	r3, [r3, #21]
}
   23ed4:	4618      	mov	r0, r3
   23ed6:	46bd      	mov	sp, r7
   23ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
   23edc:	4770      	bx	lr
   23ede:	bf00      	nop
   23ee0:	100112ec 	.word	0x100112ec

00023ee4 <DmLlAddrType>:
 *
 *  \return Address type used by LL.
 */
/*************************************************************************************************/
uint8_t DmLlAddrType(uint8_t addrType)
{
   23ee4:	b480      	push	{r7}
   23ee6:	b085      	sub	sp, #20
   23ee8:	af00      	add	r7, sp, #0
   23eea:	4603      	mov	r3, r0
   23eec:	71fb      	strb	r3, [r7, #7]
  uint8_t llAddrType = addrType;
   23eee:	79fb      	ldrb	r3, [r7, #7]
   23ef0:	73fb      	strb	r3, [r7, #15]

  /* if LL Privacy is enabled */
  if (dmCb.llPrivEnabled)
   23ef2:	4b0b      	ldr	r3, [pc, #44]	; (23f20 <DmLlAddrType+0x3c>)
   23ef4:	7d5b      	ldrb	r3, [r3, #21]
   23ef6:	2b00      	cmp	r3, #0
   23ef8:	d00a      	beq.n	23f10 <DmLlAddrType+0x2c>
  {
    if (addrType == DM_ADDR_PUBLIC)
   23efa:	79fb      	ldrb	r3, [r7, #7]
   23efc:	2b00      	cmp	r3, #0
   23efe:	d102      	bne.n	23f06 <DmLlAddrType+0x22>
    {
      llAddrType = DM_ADDR_PUBLIC_IDENTITY;
   23f00:	2302      	movs	r3, #2
   23f02:	73fb      	strb	r3, [r7, #15]
   23f04:	e004      	b.n	23f10 <DmLlAddrType+0x2c>
    }
    else if (addrType == DM_ADDR_RANDOM)
   23f06:	79fb      	ldrb	r3, [r7, #7]
   23f08:	2b01      	cmp	r3, #1
   23f0a:	d101      	bne.n	23f10 <DmLlAddrType+0x2c>
    {
      llAddrType = DM_ADDR_RANDOM_IDENTITY;
   23f0c:	2303      	movs	r3, #3
   23f0e:	73fb      	strb	r3, [r7, #15]
    }
  }

  return llAddrType;
   23f10:	7bfb      	ldrb	r3, [r7, #15]
}
   23f12:	4618      	mov	r0, r3
   23f14:	3714      	adds	r7, #20
   23f16:	46bd      	mov	sp, r7
   23f18:	f85d 7b04 	ldr.w	r7, [sp], #4
   23f1c:	4770      	bx	lr
   23f1e:	bf00      	nop
   23f20:	100112ec 	.word	0x100112ec

00023f24 <DmHostAddrType>:
 *
 *  \return Address type used by Host.
 */
/*************************************************************************************************/
uint8_t DmHostAddrType(uint8_t addrType)
{
   23f24:	b480      	push	{r7}
   23f26:	b085      	sub	sp, #20
   23f28:	af00      	add	r7, sp, #0
   23f2a:	4603      	mov	r3, r0
   23f2c:	71fb      	strb	r3, [r7, #7]
  uint8_t hostAddrType = addrType;
   23f2e:	79fb      	ldrb	r3, [r7, #7]
   23f30:	73fb      	strb	r3, [r7, #15]

  /* if LL Privacy is enabled */
  if (dmCb.llPrivEnabled)
   23f32:	4b0b      	ldr	r3, [pc, #44]	; (23f60 <DmHostAddrType+0x3c>)
   23f34:	7d5b      	ldrb	r3, [r3, #21]
   23f36:	2b00      	cmp	r3, #0
   23f38:	d00a      	beq.n	23f50 <DmHostAddrType+0x2c>
  {
    if (addrType == DM_ADDR_PUBLIC_IDENTITY)
   23f3a:	79fb      	ldrb	r3, [r7, #7]
   23f3c:	2b02      	cmp	r3, #2
   23f3e:	d102      	bne.n	23f46 <DmHostAddrType+0x22>
    {
      hostAddrType = DM_ADDR_PUBLIC;
   23f40:	2300      	movs	r3, #0
   23f42:	73fb      	strb	r3, [r7, #15]
   23f44:	e004      	b.n	23f50 <DmHostAddrType+0x2c>
    }
    else if (addrType == DM_ADDR_RANDOM_IDENTITY)
   23f46:	79fb      	ldrb	r3, [r7, #7]
   23f48:	2b03      	cmp	r3, #3
   23f4a:	d101      	bne.n	23f50 <DmHostAddrType+0x2c>
    {
      hostAddrType = DM_ADDR_RANDOM;
   23f4c:	2301      	movs	r3, #1
   23f4e:	73fb      	strb	r3, [r7, #15]
    }
  }

  return hostAddrType;
   23f50:	7bfb      	ldrb	r3, [r7, #15]
}
   23f52:	4618      	mov	r0, r3
   23f54:	3714      	adds	r7, #20
   23f56:	46bd      	mov	sp, r7
   23f58:	f85d 7b04 	ldr.w	r7, [sp], #4
   23f5c:	4770      	bx	lr
   23f5e:	bf00      	nop
   23f60:	100112ec 	.word	0x100112ec

00023f64 <dmScanPhyToIdx>:
 *
 *  \return PHY index.
 */
/*************************************************************************************************/
static uint8_t dmScanPhyToIdx(uint8_t numPhys, uint8_t scanPhy)
{
   23f64:	b480      	push	{r7}
   23f66:	b083      	sub	sp, #12
   23f68:	af00      	add	r7, sp, #0
   23f6a:	4603      	mov	r3, r0
   23f6c:	460a      	mov	r2, r1
   23f6e:	71fb      	strb	r3, [r7, #7]
   23f70:	4613      	mov	r3, r2
   23f72:	71bb      	strb	r3, [r7, #6]
  /* if number of supported PHYs is 1 */
  if (numPhys == 1)
   23f74:	79fb      	ldrb	r3, [r7, #7]
   23f76:	2b01      	cmp	r3, #1
   23f78:	d101      	bne.n	23f7e <dmScanPhyToIdx+0x1a>
  {
    return 0;
   23f7a:	2300      	movs	r3, #0
   23f7c:	e014      	b.n	23fa8 <dmScanPhyToIdx+0x44>
  }

  /* if number of supported PHYs is 2 */
  if (numPhys == 2)
   23f7e:	79fb      	ldrb	r3, [r7, #7]
   23f80:	2b02      	cmp	r3, #2
   23f82:	d106      	bne.n	23f92 <dmScanPhyToIdx+0x2e>
  {
    return (scanPhy == HCI_SCAN_PHY_LE_1M_BIT) ? 0 : 1;
   23f84:	79bb      	ldrb	r3, [r7, #6]
   23f86:	2b01      	cmp	r3, #1
   23f88:	bf14      	ite	ne
   23f8a:	2301      	movne	r3, #1
   23f8c:	2300      	moveq	r3, #0
   23f8e:	b2db      	uxtb	r3, r3
   23f90:	e00a      	b.n	23fa8 <dmScanPhyToIdx+0x44>
  }

  /* all three PHYs are supported */
  return (scanPhy == HCI_SCAN_PHY_LE_1M_BIT) ? 0 : (scanPhy == HCI_SCAN_PHY_LE_2M_BIT) ? 1 : 2;
   23f92:	79bb      	ldrb	r3, [r7, #6]
   23f94:	2b01      	cmp	r3, #1
   23f96:	d006      	beq.n	23fa6 <dmScanPhyToIdx+0x42>
   23f98:	79bb      	ldrb	r3, [r7, #6]
   23f9a:	2b02      	cmp	r3, #2
   23f9c:	d101      	bne.n	23fa2 <dmScanPhyToIdx+0x3e>
   23f9e:	2301      	movs	r3, #1
   23fa0:	e002      	b.n	23fa8 <dmScanPhyToIdx+0x44>
   23fa2:	2302      	movs	r3, #2
   23fa4:	e000      	b.n	23fa8 <dmScanPhyToIdx+0x44>
   23fa6:	2300      	movs	r3, #0
}
   23fa8:	4618      	mov	r0, r3
   23faa:	370c      	adds	r7, #12
   23fac:	46bd      	mov	sp, r7
   23fae:	f85d 7b04 	ldr.w	r7, [sp], #4
   23fb2:	4770      	bx	lr

00023fb4 <DmScanPhyToIdx>:
 *
 *  \return PHY index.
 */
/*************************************************************************************************/
uint8_t DmScanPhyToIdx(uint8_t scanPhy)
{
   23fb4:	b580      	push	{r7, lr}
   23fb6:	b082      	sub	sp, #8
   23fb8:	af00      	add	r7, sp, #0
   23fba:	4603      	mov	r3, r0
   23fbc:	71fb      	strb	r3, [r7, #7]
  return dmScanPhyToIdx(DM_NUM_PHYS, scanPhy);
   23fbe:	79fb      	ldrb	r3, [r7, #7]
   23fc0:	4619      	mov	r1, r3
   23fc2:	2002      	movs	r0, #2
   23fc4:	f7ff ffce 	bl	23f64 <dmScanPhyToIdx>
   23fc8:	4603      	mov	r3, r0
}
   23fca:	4618      	mov	r0, r3
   23fcc:	3708      	adds	r7, #8
   23fce:	46bd      	mov	sp, r7
   23fd0:	bd80      	pop	{r7, pc}

00023fd2 <dmPhyHciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmPhyHciHandler(hciEvt_t *pEvent)
{
   23fd2:	b580      	push	{r7, lr}
   23fd4:	b084      	sub	sp, #16
   23fd6:	af00      	add	r7, sp, #0
   23fd8:	6078      	str	r0, [r7, #4]
  dmConnCcb_t *pCcb;

  if (pEvent->hdr.event == HCI_LE_SET_DEF_PHY_CMD_CMPL_CBACK_EVT)
   23fda:	687b      	ldr	r3, [r7, #4]
   23fdc:	789b      	ldrb	r3, [r3, #2]
   23fde:	2b2a      	cmp	r3, #42	; 0x2a
   23fe0:	d103      	bne.n	23fea <dmPhyHciHandler+0x18>
  {
    dmPhyActDefPhySet(pEvent);
   23fe2:	6878      	ldr	r0, [r7, #4]
   23fe4:	f000 f846 	bl	24074 <dmPhyActDefPhySet>
      default:
        /* should never get here */
        break;
    }
  }
}
   23fe8:	e01a      	b.n	24020 <dmPhyHciHandler+0x4e>
  else if ((pCcb = dmConnCcbByHandle(pEvent->hdr.param)) != NULL)
   23fea:	687b      	ldr	r3, [r7, #4]
   23fec:	881b      	ldrh	r3, [r3, #0]
   23fee:	4618      	mov	r0, r3
   23ff0:	f7fe fbe6 	bl	227c0 <dmConnCcbByHandle>
   23ff4:	60f8      	str	r0, [r7, #12]
   23ff6:	68fb      	ldr	r3, [r7, #12]
   23ff8:	2b00      	cmp	r3, #0
   23ffa:	d010      	beq.n	2401e <dmPhyHciHandler+0x4c>
    switch (pEvent->hdr.event)
   23ffc:	687b      	ldr	r3, [r7, #4]
   23ffe:	789b      	ldrb	r3, [r3, #2]
   24000:	2b29      	cmp	r3, #41	; 0x29
   24002:	d002      	beq.n	2400a <dmPhyHciHandler+0x38>
   24004:	2b2b      	cmp	r3, #43	; 0x2b
   24006:	d005      	beq.n	24014 <dmPhyHciHandler+0x42>
        break;
   24008:	e00a      	b.n	24020 <dmPhyHciHandler+0x4e>
        dmPhyActPhyRead(pCcb, pEvent);
   2400a:	6879      	ldr	r1, [r7, #4]
   2400c:	68f8      	ldr	r0, [r7, #12]
   2400e:	f000 f80b 	bl	24028 <dmPhyActPhyRead>
        break;
   24012:	e005      	b.n	24020 <dmPhyHciHandler+0x4e>
        dmPhyActPhyUpdate(pCcb, pEvent);
   24014:	6879      	ldr	r1, [r7, #4]
   24016:	68f8      	ldr	r0, [r7, #12]
   24018:	f000 f846 	bl	240a8 <dmPhyActPhyUpdate>
        break;
   2401c:	e000      	b.n	24020 <dmPhyHciHandler+0x4e>
  }
   2401e:	bf00      	nop
}
   24020:	bf00      	nop
   24022:	3710      	adds	r7, #16
   24024:	46bd      	mov	sp, r7
   24026:	bd80      	pop	{r7, pc}

00024028 <dmPhyActPhyRead>:
*
*  \return None.
*/
/*************************************************************************************************/
static void dmPhyActPhyRead(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   24028:	b580      	push	{r7, lr}
   2402a:	b086      	sub	sp, #24
   2402c:	af00      	add	r7, sp, #0
   2402e:	6078      	str	r0, [r7, #4]
   24030:	6039      	str	r1, [r7, #0]
  hciLeReadPhyCmdCmplEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_PHY_READ_IND;
   24032:	2344      	movs	r3, #68	; 0x44
   24034:	73bb      	strb	r3, [r7, #14]
  evt.hdr.param = pCcb->connId;
   24036:	687b      	ldr	r3, [r7, #4]
   24038:	7c1b      	ldrb	r3, [r3, #16]
   2403a:	b29b      	uxth	r3, r3
   2403c:	81bb      	strh	r3, [r7, #12]
  evt.status = evt.hdr.status = (uint8_t)pEvent->leReadPhyCmdCmpl.status;
   2403e:	683b      	ldr	r3, [r7, #0]
   24040:	791b      	ldrb	r3, [r3, #4]
   24042:	73fb      	strb	r3, [r7, #15]
   24044:	7bfb      	ldrb	r3, [r7, #15]
   24046:	743b      	strb	r3, [r7, #16]
  evt.handle = pCcb->handle;
   24048:	687b      	ldr	r3, [r7, #4]
   2404a:	899b      	ldrh	r3, [r3, #12]
   2404c:	827b      	strh	r3, [r7, #18]
  evt.txPhy = pEvent->leReadPhyCmdCmpl.txPhy;
   2404e:	683b      	ldr	r3, [r7, #0]
   24050:	7a1b      	ldrb	r3, [r3, #8]
   24052:	753b      	strb	r3, [r7, #20]
  evt.rxPhy = pEvent->leReadPhyCmdCmpl.rxPhy;
   24054:	683b      	ldr	r3, [r7, #0]
   24056:	7a5b      	ldrb	r3, [r3, #9]
   24058:	757b      	strb	r3, [r7, #21]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *)&evt);
   2405a:	4b05      	ldr	r3, [pc, #20]	; (24070 <dmPhyActPhyRead+0x48>)
   2405c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   24060:	f107 020c 	add.w	r2, r7, #12
   24064:	4610      	mov	r0, r2
   24066:	4798      	blx	r3
}
   24068:	bf00      	nop
   2406a:	3718      	adds	r7, #24
   2406c:	46bd      	mov	sp, r7
   2406e:	bd80      	pop	{r7, pc}
   24070:	10011218 	.word	0x10011218

00024074 <dmPhyActDefPhySet>:
*
*  \return None.
*/
/*************************************************************************************************/
static void dmPhyActDefPhySet(hciEvt_t *pEvent)
{
   24074:	b580      	push	{r7, lr}
   24076:	b084      	sub	sp, #16
   24078:	af00      	add	r7, sp, #0
   2407a:	6078      	str	r0, [r7, #4]
  hciLeSetDefPhyCmdCmplEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_PHY_SET_DEF_IND;
   2407c:	2345      	movs	r3, #69	; 0x45
   2407e:	72bb      	strb	r3, [r7, #10]
  evt.hdr.param = 0;
   24080:	2300      	movs	r3, #0
   24082:	813b      	strh	r3, [r7, #8]
  evt.status = evt.hdr.status = (uint8_t)pEvent->leSetDefPhyCmdCmpl.status;
   24084:	687b      	ldr	r3, [r7, #4]
   24086:	791b      	ldrb	r3, [r3, #4]
   24088:	72fb      	strb	r3, [r7, #11]
   2408a:	7afb      	ldrb	r3, [r7, #11]
   2408c:	733b      	strb	r3, [r7, #12]
  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *)&evt);
   2408e:	4b05      	ldr	r3, [pc, #20]	; (240a4 <dmPhyActDefPhySet+0x30>)
   24090:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   24094:	f107 0208 	add.w	r2, r7, #8
   24098:	4610      	mov	r0, r2
   2409a:	4798      	blx	r3
}
   2409c:	bf00      	nop
   2409e:	3710      	adds	r7, #16
   240a0:	46bd      	mov	sp, r7
   240a2:	bd80      	pop	{r7, pc}
   240a4:	10011218 	.word	0x10011218

000240a8 <dmPhyActPhyUpdate>:
*
*  \return None.
*/
/*************************************************************************************************/
static void dmPhyActPhyUpdate(dmConnCcb_t *pCcb, hciEvt_t *pEvent)
{
   240a8:	b580      	push	{r7, lr}
   240aa:	b086      	sub	sp, #24
   240ac:	af00      	add	r7, sp, #0
   240ae:	6078      	str	r0, [r7, #4]
   240b0:	6039      	str	r1, [r7, #0]
  hciLePhyUpdateEvt_t evt;

  /* call callback */
  evt.hdr.event = DM_PHY_UPDATE_IND;
   240b2:	2346      	movs	r3, #70	; 0x46
   240b4:	73bb      	strb	r3, [r7, #14]
  evt.hdr.param = pCcb->connId;
   240b6:	687b      	ldr	r3, [r7, #4]
   240b8:	7c1b      	ldrb	r3, [r3, #16]
   240ba:	b29b      	uxth	r3, r3
   240bc:	81bb      	strh	r3, [r7, #12]
  evt.status = evt.hdr.status = (uint8_t)pEvent->lePhyUpdate.status;
   240be:	683b      	ldr	r3, [r7, #0]
   240c0:	791b      	ldrb	r3, [r3, #4]
   240c2:	73fb      	strb	r3, [r7, #15]
   240c4:	7bfb      	ldrb	r3, [r7, #15]
   240c6:	743b      	strb	r3, [r7, #16]
  evt.handle = pCcb->handle;
   240c8:	687b      	ldr	r3, [r7, #4]
   240ca:	899b      	ldrh	r3, [r3, #12]
   240cc:	827b      	strh	r3, [r7, #18]
  evt.txPhy = pEvent->lePhyUpdate.txPhy;
   240ce:	683b      	ldr	r3, [r7, #0]
   240d0:	7a1b      	ldrb	r3, [r3, #8]
   240d2:	753b      	strb	r3, [r7, #20]
  evt.rxPhy = pEvent->lePhyUpdate.rxPhy;
   240d4:	683b      	ldr	r3, [r7, #0]
   240d6:	7a5b      	ldrb	r3, [r3, #9]
   240d8:	757b      	strb	r3, [r7, #21]

  (*dmConnCb.connCback[DM_CLIENT_ID_APP])((dmEvt_t *)&evt);
   240da:	4b05      	ldr	r3, [pc, #20]	; (240f0 <dmPhyActPhyUpdate+0x48>)
   240dc:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
   240e0:	f107 020c 	add.w	r2, r7, #12
   240e4:	4610      	mov	r0, r2
   240e6:	4798      	blx	r3
}
   240e8:	bf00      	nop
   240ea:	3718      	adds	r7, #24
   240ec:	46bd      	mov	sp, r7
   240ee:	bd80      	pop	{r7, pc}
   240f0:	10011218 	.word	0x10011218

000240f4 <DmPhyInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmPhyInit(void)
{
   240f4:	b480      	push	{r7}
   240f6:	af00      	add	r7, sp, #0
  dmFcnIfTbl[DM_ID_PHY] = (dmFcnIf_t *) &dmPhyFcnIf;
   240f8:	4b03      	ldr	r3, [pc, #12]	; (24108 <DmPhyInit+0x14>)
   240fa:	4a04      	ldr	r2, [pc, #16]	; (2410c <DmPhyInit+0x18>)
   240fc:	625a      	str	r2, [r3, #36]	; 0x24
}
   240fe:	bf00      	nop
   24100:	46bd      	mov	sp, r7
   24102:	f85d 7b04 	ldr.w	r7, [sp], #4
   24106:	4770      	bx	lr
   24108:	10002b90 	.word	0x10002b90
   2410c:	00045d48 	.word	0x00045d48

00024110 <DmPrivResolveAddr>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmPrivResolveAddr(uint8_t *pAddr, uint8_t *pIrk, uint16_t param)
{
   24110:	b580      	push	{r7, lr}
   24112:	b086      	sub	sp, #24
   24114:	af00      	add	r7, sp, #0
   24116:	60f8      	str	r0, [r7, #12]
   24118:	60b9      	str	r1, [r7, #8]
   2411a:	4613      	mov	r3, r2
   2411c:	80fb      	strh	r3, [r7, #6]
  dmPrivApiResolveAddr_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmPrivApiResolveAddr_t))) != NULL)
   2411e:	201a      	movs	r0, #26
   24120:	f008 ffc5 	bl	2d0ae <WsfMsgAlloc>
   24124:	6178      	str	r0, [r7, #20]
   24126:	697b      	ldr	r3, [r7, #20]
   24128:	2b00      	cmp	r3, #0
   2412a:	d017      	beq.n	2415c <DmPrivResolveAddr+0x4c>
  {
    pMsg->hdr.event = DM_PRIV_MSG_API_RESOLVE_ADDR;
   2412c:	697b      	ldr	r3, [r7, #20]
   2412e:	2260      	movs	r2, #96	; 0x60
   24130:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = param;
   24132:	697b      	ldr	r3, [r7, #20]
   24134:	88fa      	ldrh	r2, [r7, #6]
   24136:	801a      	strh	r2, [r3, #0]
    Calc128Cpy(pMsg->irk, pIrk);
   24138:	697b      	ldr	r3, [r7, #20]
   2413a:	3304      	adds	r3, #4
   2413c:	68b9      	ldr	r1, [r7, #8]
   2413e:	4618      	mov	r0, r3
   24140:	f7fd fd52 	bl	21be8 <Calc128Cpy>
    BdaCpy(pMsg->addr, pAddr);
   24144:	697b      	ldr	r3, [r7, #20]
   24146:	3314      	adds	r3, #20
   24148:	68f9      	ldr	r1, [r7, #12]
   2414a:	4618      	mov	r0, r3
   2414c:	f7fd fd1b 	bl	21b86 <BdaCpy>
    WsfMsgSend(dmCb.handlerId, pMsg);
   24150:	4b04      	ldr	r3, [pc, #16]	; (24164 <DmPrivResolveAddr+0x54>)
   24152:	7b1b      	ldrb	r3, [r3, #12]
   24154:	6979      	ldr	r1, [r7, #20]
   24156:	4618      	mov	r0, r3
   24158:	f008 ffcd 	bl	2d0f6 <WsfMsgSend>
  }
}
   2415c:	bf00      	nop
   2415e:	3718      	adds	r7, #24
   24160:	46bd      	mov	sp, r7
   24162:	bd80      	pop	{r7, pc}
   24164:	100112ec 	.word	0x100112ec

00024168 <DmPrivAddDevToResList>:
 *          to resolving list to enable address resolution in the Controller.
 */
/*************************************************************************************************/
void DmPrivAddDevToResList(uint8_t addrType, const uint8_t *pIdentityAddr, uint8_t *pPeerIrk,
                           uint8_t *pLocalIrk, bool_t enableLlPriv, uint16_t param)
{
   24168:	b580      	push	{r7, lr}
   2416a:	b086      	sub	sp, #24
   2416c:	af00      	add	r7, sp, #0
   2416e:	60b9      	str	r1, [r7, #8]
   24170:	607a      	str	r2, [r7, #4]
   24172:	603b      	str	r3, [r7, #0]
   24174:	4603      	mov	r3, r0
   24176:	73fb      	strb	r3, [r7, #15]
  dmPrivApiAddDevToResList_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmPrivApiAddDevToResList_t))) != NULL)
   24178:	202c      	movs	r0, #44	; 0x2c
   2417a:	f008 ff98 	bl	2d0ae <WsfMsgAlloc>
   2417e:	6178      	str	r0, [r7, #20]
   24180:	697b      	ldr	r3, [r7, #20]
   24182:	2b00      	cmp	r3, #0
   24184:	d025      	beq.n	241d2 <DmPrivAddDevToResList+0x6a>
  {
    pMsg->hdr.event = DM_PRIV_MSG_API_ADD_DEV_TO_RES_LIST;
   24186:	697b      	ldr	r3, [r7, #20]
   24188:	2262      	movs	r2, #98	; 0x62
   2418a:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = param;
   2418c:	697b      	ldr	r3, [r7, #20]
   2418e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   24190:	801a      	strh	r2, [r3, #0]
    pMsg->addrType = addrType;
   24192:	697b      	ldr	r3, [r7, #20]
   24194:	7bfa      	ldrb	r2, [r7, #15]
   24196:	711a      	strb	r2, [r3, #4]
    BdaCpy(pMsg->peerAddr, pIdentityAddr);
   24198:	697b      	ldr	r3, [r7, #20]
   2419a:	3305      	adds	r3, #5
   2419c:	68b9      	ldr	r1, [r7, #8]
   2419e:	4618      	mov	r0, r3
   241a0:	f7fd fcf1 	bl	21b86 <BdaCpy>
    Calc128Cpy(pMsg->peerIrk, pPeerIrk);
   241a4:	697b      	ldr	r3, [r7, #20]
   241a6:	330b      	adds	r3, #11
   241a8:	6879      	ldr	r1, [r7, #4]
   241aa:	4618      	mov	r0, r3
   241ac:	f7fd fd1c 	bl	21be8 <Calc128Cpy>
    Calc128Cpy(pMsg->localIrk, pLocalIrk);
   241b0:	697b      	ldr	r3, [r7, #20]
   241b2:	331b      	adds	r3, #27
   241b4:	6839      	ldr	r1, [r7, #0]
   241b6:	4618      	mov	r0, r3
   241b8:	f7fd fd16 	bl	21be8 <Calc128Cpy>
    pMsg->enableLlPriv = enableLlPriv;
   241bc:	697b      	ldr	r3, [r7, #20]
   241be:	f897 2020 	ldrb.w	r2, [r7, #32]
   241c2:	f883 202b 	strb.w	r2, [r3, #43]	; 0x2b
    WsfMsgSend(dmCb.handlerId, pMsg);
   241c6:	4b05      	ldr	r3, [pc, #20]	; (241dc <DmPrivAddDevToResList+0x74>)
   241c8:	7b1b      	ldrb	r3, [r3, #12]
   241ca:	6979      	ldr	r1, [r7, #20]
   241cc:	4618      	mov	r0, r3
   241ce:	f008 ff92 	bl	2d0f6 <WsfMsgSend>
  }
}
   241d2:	bf00      	nop
   241d4:	3718      	adds	r7, #24
   241d6:	46bd      	mov	sp, r7
   241d8:	bd80      	pop	{r7, pc}
   241da:	bf00      	nop
   241dc:	100112ec 	.word	0x100112ec

000241e0 <DmPrivSetPrivacyMode>:
 *          - Scanning is enabled, or
 *          - (Extended) Create connection or Create Sync command is outstanding.
 */
/*************************************************************************************************/
void DmPrivSetPrivacyMode(uint8_t addrType, const uint8_t *pIdentityAddr, uint8_t mode)
{
   241e0:	b580      	push	{r7, lr}
   241e2:	b084      	sub	sp, #16
   241e4:	af00      	add	r7, sp, #0
   241e6:	4603      	mov	r3, r0
   241e8:	6039      	str	r1, [r7, #0]
   241ea:	71fb      	strb	r3, [r7, #7]
   241ec:	4613      	mov	r3, r2
   241ee:	71bb      	strb	r3, [r7, #6]
  dmPrivApiSetPrivacyMode_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmPrivApiSetPrivacyMode_t))) != NULL)
   241f0:	200c      	movs	r0, #12
   241f2:	f008 ff5c 	bl	2d0ae <WsfMsgAlloc>
   241f6:	60f8      	str	r0, [r7, #12]
   241f8:	68fb      	ldr	r3, [r7, #12]
   241fa:	2b00      	cmp	r3, #0
   241fc:	d014      	beq.n	24228 <DmPrivSetPrivacyMode+0x48>
  {
    pMsg->hdr.event = DM_PRIV_MSG_API_SET_PRIVACY_MODE;
   241fe:	68fb      	ldr	r3, [r7, #12]
   24200:	2266      	movs	r2, #102	; 0x66
   24202:	709a      	strb	r2, [r3, #2]
    pMsg->addrType = addrType;
   24204:	68fb      	ldr	r3, [r7, #12]
   24206:	79fa      	ldrb	r2, [r7, #7]
   24208:	711a      	strb	r2, [r3, #4]
    BdaCpy(pMsg->peerAddr, pIdentityAddr);
   2420a:	68fb      	ldr	r3, [r7, #12]
   2420c:	3305      	adds	r3, #5
   2420e:	6839      	ldr	r1, [r7, #0]
   24210:	4618      	mov	r0, r3
   24212:	f7fd fcb8 	bl	21b86 <BdaCpy>
    pMsg->mode = mode;
   24216:	68fb      	ldr	r3, [r7, #12]
   24218:	79ba      	ldrb	r2, [r7, #6]
   2421a:	72da      	strb	r2, [r3, #11]
    WsfMsgSend(dmCb.handlerId, pMsg);
   2421c:	4b04      	ldr	r3, [pc, #16]	; (24230 <DmPrivSetPrivacyMode+0x50>)
   2421e:	7b1b      	ldrb	r3, [r3, #12]
   24220:	68f9      	ldr	r1, [r7, #12]
   24222:	4618      	mov	r0, r3
   24224:	f008 ff67 	bl	2d0f6 <WsfMsgSend>
  }
}
   24228:	bf00      	nop
   2422a:	3710      	adds	r7, #16
   2422c:	46bd      	mov	sp, r7
   2422e:	bd80      	pop	{r7, pc}
   24230:	100112ec 	.word	0x100112ec

00024234 <dmScanInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanInit(void)
{
   24234:	b480      	push	{r7}
   24236:	b083      	sub	sp, #12
   24238:	af00      	add	r7, sp, #0
  uint8_t i;

  /* initialize control block */
  for (i = 0; i < DM_NUM_PHYS; i++)
   2423a:	2300      	movs	r3, #0
   2423c:	71fb      	strb	r3, [r7, #7]
   2423e:	e00f      	b.n	24260 <dmScanInit+0x2c>
  {
    dmScanCb.scanInterval[i] = DM_GAP_SCAN_FAST_INT_MIN;
   24240:	79fb      	ldrb	r3, [r7, #7]
   24242:	4a12      	ldr	r2, [pc, #72]	; (2428c <dmScanInit+0x58>)
   24244:	3308      	adds	r3, #8
   24246:	2130      	movs	r1, #48	; 0x30
   24248:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    dmScanCb.scanWindow[i] = DM_GAP_SCAN_FAST_WINDOW;
   2424c:	79fb      	ldrb	r3, [r7, #7]
   2424e:	4a0f      	ldr	r2, [pc, #60]	; (2428c <dmScanInit+0x58>)
   24250:	3308      	adds	r3, #8
   24252:	005b      	lsls	r3, r3, #1
   24254:	4413      	add	r3, r2
   24256:	2230      	movs	r2, #48	; 0x30
   24258:	809a      	strh	r2, [r3, #4]
  for (i = 0; i < DM_NUM_PHYS; i++)
   2425a:	79fb      	ldrb	r3, [r7, #7]
   2425c:	3301      	adds	r3, #1
   2425e:	71fb      	strb	r3, [r7, #7]
   24260:	79fb      	ldrb	r3, [r7, #7]
   24262:	2b01      	cmp	r3, #1
   24264:	d9ec      	bls.n	24240 <dmScanInit+0xc>
  }

  dmCb.scanFiltPolicy = HCI_FILT_NONE;
   24266:	4b0a      	ldr	r3, [pc, #40]	; (24290 <dmScanInit+0x5c>)
   24268:	2200      	movs	r2, #0
   2426a:	749a      	strb	r2, [r3, #18]
  dmScanCb.scanTimer.handlerId = dmCb.handlerId;
   2426c:	4b08      	ldr	r3, [pc, #32]	; (24290 <dmScanInit+0x5c>)
   2426e:	7b1a      	ldrb	r2, [r3, #12]
   24270:	4b06      	ldr	r3, [pc, #24]	; (2428c <dmScanInit+0x58>)
   24272:	731a      	strb	r2, [r3, #12]
  dmScanCb.scanState = DM_SCAN_STATE_IDLE;
   24274:	4b05      	ldr	r3, [pc, #20]	; (2428c <dmScanInit+0x58>)
   24276:	2200      	movs	r2, #0
   24278:	761a      	strb	r2, [r3, #24]
  dmCb.scanAddrType = DM_ADDR_PUBLIC;
   2427a:	4b05      	ldr	r3, [pc, #20]	; (24290 <dmScanInit+0x5c>)
   2427c:	2200      	movs	r2, #0
   2427e:	73da      	strb	r2, [r3, #15]
}
   24280:	bf00      	nop
   24282:	370c      	adds	r7, #12
   24284:	46bd      	mov	sp, r7
   24286:	f85d 7b04 	ldr.w	r7, [sp], #4
   2428a:	4770      	bx	lr
   2428c:	10011304 	.word	0x10011304
   24290:	100112ec 	.word	0x100112ec

00024294 <DmScanStart>:
 *  \return None.
 */
/*************************************************************************************************/
void DmScanStart(uint8_t scanPhys, uint8_t mode, const uint8_t *pScanType, bool_t filterDup,
                 uint16_t duration, uint16_t period)
{
   24294:	b580      	push	{r7, lr}
   24296:	b084      	sub	sp, #16
   24298:	af00      	add	r7, sp, #0
   2429a:	603a      	str	r2, [r7, #0]
   2429c:	461a      	mov	r2, r3
   2429e:	4603      	mov	r3, r0
   242a0:	71fb      	strb	r3, [r7, #7]
   242a2:	460b      	mov	r3, r1
   242a4:	71bb      	strb	r3, [r7, #6]
   242a6:	4613      	mov	r3, r2
   242a8:	717b      	strb	r3, [r7, #5]
  uint8_t i;              /* scanPhy bit position */
  uint8_t idx;            /* param array index */
  dmScanApiStart_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmScanApiStart_t))) != NULL)
   242aa:	200e      	movs	r0, #14
   242ac:	f008 feff 	bl	2d0ae <WsfMsgAlloc>
   242b0:	60b8      	str	r0, [r7, #8]
   242b2:	68bb      	ldr	r3, [r7, #8]
   242b4:	2b00      	cmp	r3, #0
   242b6:	d039      	beq.n	2432c <DmScanStart+0x98>
  {
    pMsg->hdr.event = DM_SCAN_MSG_API_START;
   242b8:	68bb      	ldr	r3, [r7, #8]
   242ba:	2220      	movs	r2, #32
   242bc:	709a      	strb	r2, [r3, #2]
    pMsg->scanPhys = scanPhys;
   242be:	68bb      	ldr	r3, [r7, #8]
   242c0:	79fa      	ldrb	r2, [r7, #7]
   242c2:	711a      	strb	r2, [r3, #4]

    for (i = 0, idx = 0; (i < 8) && (idx < DM_NUM_PHYS); i++)
   242c4:	2300      	movs	r3, #0
   242c6:	73fb      	strb	r3, [r7, #15]
   242c8:	2300      	movs	r3, #0
   242ca:	73bb      	strb	r3, [r7, #14]
   242cc:	e016      	b.n	242fc <DmScanStart+0x68>
    {
      if (scanPhys & (1 << i))
   242ce:	79fa      	ldrb	r2, [r7, #7]
   242d0:	7bfb      	ldrb	r3, [r7, #15]
   242d2:	fa42 f303 	asr.w	r3, r2, r3
   242d6:	f003 0301 	and.w	r3, r3, #1
   242da:	2b00      	cmp	r3, #0
   242dc:	d00b      	beq.n	242f6 <DmScanStart+0x62>
      {
        /* scan type for this PHY */
        pMsg->scanType[idx] = pScanType[idx];
   242de:	7bbb      	ldrb	r3, [r7, #14]
   242e0:	683a      	ldr	r2, [r7, #0]
   242e2:	441a      	add	r2, r3
   242e4:	7bbb      	ldrb	r3, [r7, #14]
   242e6:	7811      	ldrb	r1, [r2, #0]
   242e8:	68ba      	ldr	r2, [r7, #8]
   242ea:	4413      	add	r3, r2
   242ec:	460a      	mov	r2, r1
   242ee:	715a      	strb	r2, [r3, #5]
        idx++;
   242f0:	7bbb      	ldrb	r3, [r7, #14]
   242f2:	3301      	adds	r3, #1
   242f4:	73bb      	strb	r3, [r7, #14]
    for (i = 0, idx = 0; (i < 8) && (idx < DM_NUM_PHYS); i++)
   242f6:	7bfb      	ldrb	r3, [r7, #15]
   242f8:	3301      	adds	r3, #1
   242fa:	73fb      	strb	r3, [r7, #15]
   242fc:	7bfb      	ldrb	r3, [r7, #15]
   242fe:	2b07      	cmp	r3, #7
   24300:	d802      	bhi.n	24308 <DmScanStart+0x74>
   24302:	7bbb      	ldrb	r3, [r7, #14]
   24304:	2b01      	cmp	r3, #1
   24306:	d9e2      	bls.n	242ce <DmScanStart+0x3a>
      }
    }

    pMsg->mode = mode;
   24308:	68bb      	ldr	r3, [r7, #8]
   2430a:	79ba      	ldrb	r2, [r7, #6]
   2430c:	71da      	strb	r2, [r3, #7]
    pMsg->duration = duration;
   2430e:	68bb      	ldr	r3, [r7, #8]
   24310:	8b3a      	ldrh	r2, [r7, #24]
   24312:	811a      	strh	r2, [r3, #8]
    pMsg->period = period;
   24314:	68bb      	ldr	r3, [r7, #8]
   24316:	8bba      	ldrh	r2, [r7, #28]
   24318:	815a      	strh	r2, [r3, #10]
    pMsg->filterDup = filterDup;
   2431a:	68bb      	ldr	r3, [r7, #8]
   2431c:	797a      	ldrb	r2, [r7, #5]
   2431e:	731a      	strb	r2, [r3, #12]
    WsfMsgSend(dmCb.handlerId, pMsg);
   24320:	4b04      	ldr	r3, [pc, #16]	; (24334 <DmScanStart+0xa0>)
   24322:	7b1b      	ldrb	r3, [r3, #12]
   24324:	68b9      	ldr	r1, [r7, #8]
   24326:	4618      	mov	r0, r3
   24328:	f008 fee5 	bl	2d0f6 <WsfMsgSend>
  }
}
   2432c:	bf00      	nop
   2432e:	3710      	adds	r7, #16
   24330:	46bd      	mov	sp, r7
   24332:	bd80      	pop	{r7, pc}
   24334:	100112ec 	.word	0x100112ec

00024338 <DmScanStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmScanStop(void)
{
   24338:	b580      	push	{r7, lr}
   2433a:	b082      	sub	sp, #8
   2433c:	af00      	add	r7, sp, #0
  wsfMsgHdr_t *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(wsfMsgHdr_t))) != NULL)
   2433e:	2004      	movs	r0, #4
   24340:	f008 feb5 	bl	2d0ae <WsfMsgAlloc>
   24344:	6078      	str	r0, [r7, #4]
   24346:	687b      	ldr	r3, [r7, #4]
   24348:	2b00      	cmp	r3, #0
   2434a:	d008      	beq.n	2435e <DmScanStop+0x26>
  {
    pMsg->event = DM_SCAN_MSG_API_STOP;
   2434c:	687b      	ldr	r3, [r7, #4]
   2434e:	2221      	movs	r2, #33	; 0x21
   24350:	709a      	strb	r2, [r3, #2]
    WsfMsgSend(dmCb.handlerId, pMsg);
   24352:	4b05      	ldr	r3, [pc, #20]	; (24368 <DmScanStop+0x30>)
   24354:	7b1b      	ldrb	r3, [r3, #12]
   24356:	6879      	ldr	r1, [r7, #4]
   24358:	4618      	mov	r0, r3
   2435a:	f008 fecc 	bl	2d0f6 <WsfMsgSend>
  }
}
   2435e:	bf00      	nop
   24360:	3708      	adds	r7, #8
   24362:	46bd      	mov	sp, r7
   24364:	bd80      	pop	{r7, pc}
   24366:	bf00      	nop
   24368:	100112ec 	.word	0x100112ec

0002436c <dmScanSetInterval>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmScanSetInterval(uint8_t scanPhy, uint16_t scanInterval, uint16_t scanWindow)
{
   2436c:	b580      	push	{r7, lr}
   2436e:	b084      	sub	sp, #16
   24370:	af00      	add	r7, sp, #0
   24372:	4603      	mov	r3, r0
   24374:	71fb      	strb	r3, [r7, #7]
   24376:	460b      	mov	r3, r1
   24378:	80bb      	strh	r3, [r7, #4]
   2437a:	4613      	mov	r3, r2
   2437c:	807b      	strh	r3, [r7, #2]
  uint8_t phyIdx;

  WSF_ASSERT((scanPhy == HCI_INIT_PHY_LE_1M_BIT) || (scanPhy == HCI_INIT_PHY_LE_CODED_BIT));

  WsfTaskLock();
   2437e:	f008 ff41 	bl	2d204 <WsfTaskLock>
  phyIdx = DmScanPhyToIdx(scanPhy);
   24382:	79fb      	ldrb	r3, [r7, #7]
   24384:	4618      	mov	r0, r3
   24386:	f7ff fe15 	bl	23fb4 <DmScanPhyToIdx>
   2438a:	4603      	mov	r3, r0
   2438c:	73fb      	strb	r3, [r7, #15]
  dmScanCb.scanInterval[phyIdx] = scanInterval;
   2438e:	7bfb      	ldrb	r3, [r7, #15]
   24390:	4908      	ldr	r1, [pc, #32]	; (243b4 <dmScanSetInterval+0x48>)
   24392:	3308      	adds	r3, #8
   24394:	88ba      	ldrh	r2, [r7, #4]
   24396:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
  dmScanCb.scanWindow[phyIdx] = scanWindow;
   2439a:	7bfb      	ldrb	r3, [r7, #15]
   2439c:	4a05      	ldr	r2, [pc, #20]	; (243b4 <dmScanSetInterval+0x48>)
   2439e:	3308      	adds	r3, #8
   243a0:	005b      	lsls	r3, r3, #1
   243a2:	4413      	add	r3, r2
   243a4:	887a      	ldrh	r2, [r7, #2]
   243a6:	809a      	strh	r2, [r3, #4]
  WsfTaskUnlock();
   243a8:	f008 ff32 	bl	2d210 <WsfTaskUnlock>
}
   243ac:	bf00      	nop
   243ae:	3710      	adds	r7, #16
   243b0:	46bd      	mov	sp, r7
   243b2:	bd80      	pop	{r7, pc}
   243b4:	10011304 	.word	0x10011304

000243b8 <DmScanSetInterval>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmScanSetInterval(uint8_t scanPhys, uint16_t *pScanInterval, uint16_t *pScanWindow)
{
   243b8:	b580      	push	{r7, lr}
   243ba:	b086      	sub	sp, #24
   243bc:	af00      	add	r7, sp, #0
   243be:	4603      	mov	r3, r0
   243c0:	60b9      	str	r1, [r7, #8]
   243c2:	607a      	str	r2, [r7, #4]
   243c4:	73fb      	strb	r3, [r7, #15]
  uint8_t i;   /* scanPhy bit position */
  uint8_t idx; /* param array index */

  for (i = 0, idx = 0; (i < 8) && (idx < DM_NUM_PHYS); i++)
   243c6:	2300      	movs	r3, #0
   243c8:	75fb      	strb	r3, [r7, #23]
   243ca:	2300      	movs	r3, #0
   243cc:	75bb      	strb	r3, [r7, #22]
   243ce:	e01f      	b.n	24410 <DmScanSetInterval+0x58>
  {
    if (scanPhys & (1 << i))
   243d0:	7bfa      	ldrb	r2, [r7, #15]
   243d2:	7dfb      	ldrb	r3, [r7, #23]
   243d4:	fa42 f303 	asr.w	r3, r2, r3
   243d8:	f003 0301 	and.w	r3, r3, #1
   243dc:	2b00      	cmp	r3, #0
   243de:	d014      	beq.n	2440a <DmScanSetInterval+0x52>
    {
      dmScanSetInterval((1 << i), pScanInterval[idx], pScanWindow[idx]);
   243e0:	7dfb      	ldrb	r3, [r7, #23]
   243e2:	2201      	movs	r2, #1
   243e4:	fa02 f303 	lsl.w	r3, r2, r3
   243e8:	b2d8      	uxtb	r0, r3
   243ea:	7dbb      	ldrb	r3, [r7, #22]
   243ec:	005b      	lsls	r3, r3, #1
   243ee:	68ba      	ldr	r2, [r7, #8]
   243f0:	4413      	add	r3, r2
   243f2:	8819      	ldrh	r1, [r3, #0]
   243f4:	7dbb      	ldrb	r3, [r7, #22]
   243f6:	005b      	lsls	r3, r3, #1
   243f8:	687a      	ldr	r2, [r7, #4]
   243fa:	4413      	add	r3, r2
   243fc:	881b      	ldrh	r3, [r3, #0]
   243fe:	461a      	mov	r2, r3
   24400:	f7ff ffb4 	bl	2436c <dmScanSetInterval>
      idx++;
   24404:	7dbb      	ldrb	r3, [r7, #22]
   24406:	3301      	adds	r3, #1
   24408:	75bb      	strb	r3, [r7, #22]
  for (i = 0, idx = 0; (i < 8) && (idx < DM_NUM_PHYS); i++)
   2440a:	7dfb      	ldrb	r3, [r7, #23]
   2440c:	3301      	adds	r3, #1
   2440e:	75fb      	strb	r3, [r7, #23]
   24410:	7dfb      	ldrb	r3, [r7, #23]
   24412:	2b07      	cmp	r3, #7
   24414:	d802      	bhi.n	2441c <DmScanSetInterval+0x64>
   24416:	7dbb      	ldrb	r3, [r7, #22]
   24418:	2b01      	cmp	r3, #1
   2441a:	d9d9      	bls.n	243d0 <DmScanSetInterval+0x18>
    }
  }
}
   2441c:	bf00      	nop
   2441e:	3718      	adds	r7, #24
   24420:	46bd      	mov	sp, r7
   24422:	bd80      	pop	{r7, pc}

00024424 <dmScanActStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanActStart(dmScanMsg_t *pMsg)
{
   24424:	b5f0      	push	{r4, r5, r6, r7, lr}
   24426:	b087      	sub	sp, #28
   24428:	af02      	add	r7, sp, #8
   2442a:	6078      	str	r0, [r7, #4]
  uint8_t phyIdx = DmScanPhyToIdx(HCI_SCAN_PHY_LE_1M_BIT);
   2442c:	2001      	movs	r0, #1
   2442e:	f7ff fdc1 	bl	23fb4 <DmScanPhyToIdx>
   24432:	4603      	mov	r3, r0
   24434:	73fb      	strb	r3, [r7, #15]

  if (dmScanCb.scanState == DM_SCAN_STATE_IDLE)
   24436:	4b25      	ldr	r3, [pc, #148]	; (244cc <dmScanActStart+0xa8>)
   24438:	7e1b      	ldrb	r3, [r3, #24]
   2443a:	2b00      	cmp	r3, #0
   2443c:	d141      	bne.n	244c2 <dmScanActStart+0x9e>
  {
    /* set scan parameters */
    HciLeSetScanParamCmd(pMsg->apiStart.scanType[phyIdx], dmScanCb.scanInterval[phyIdx],
   2443e:	7bfb      	ldrb	r3, [r7, #15]
   24440:	687a      	ldr	r2, [r7, #4]
   24442:	4413      	add	r3, r2
   24444:	795c      	ldrb	r4, [r3, #5]
   24446:	7bfb      	ldrb	r3, [r7, #15]
   24448:	4a20      	ldr	r2, [pc, #128]	; (244cc <dmScanActStart+0xa8>)
   2444a:	3308      	adds	r3, #8
   2444c:	f832 5013 	ldrh.w	r5, [r2, r3, lsl #1]
   24450:	7bfb      	ldrb	r3, [r7, #15]
   24452:	4a1e      	ldr	r2, [pc, #120]	; (244cc <dmScanActStart+0xa8>)
   24454:	3308      	adds	r3, #8
   24456:	005b      	lsls	r3, r3, #1
   24458:	4413      	add	r3, r2
   2445a:	889e      	ldrh	r6, [r3, #4]
   2445c:	4b1c      	ldr	r3, [pc, #112]	; (244d0 <dmScanActStart+0xac>)
   2445e:	7bdb      	ldrb	r3, [r3, #15]
   24460:	4618      	mov	r0, r3
   24462:	f7ff fd3f 	bl	23ee4 <DmLlAddrType>
   24466:	4603      	mov	r3, r0
   24468:	461a      	mov	r2, r3
   2446a:	4b19      	ldr	r3, [pc, #100]	; (244d0 <dmScanActStart+0xac>)
   2446c:	7c9b      	ldrb	r3, [r3, #18]
   2446e:	9300      	str	r3, [sp, #0]
   24470:	4613      	mov	r3, r2
   24472:	4632      	mov	r2, r6
   24474:	4629      	mov	r1, r5
   24476:	4620      	mov	r0, r4
   24478:	f001 f92b 	bl	256d2 <HciLeSetScanParamCmd>
                         dmScanCb.scanWindow[phyIdx], DmLlAddrType(dmCb.scanAddrType),
                         dmCb.scanFiltPolicy);

    /* initialize scan result filtering */
    if (pMsg->apiStart.mode == DM_DISC_MODE_LIMITED)
   2447c:	687b      	ldr	r3, [r7, #4]
   2447e:	79db      	ldrb	r3, [r3, #7]
   24480:	2b01      	cmp	r3, #1
   24482:	d103      	bne.n	2448c <dmScanActStart+0x68>
    {
      dmScanCb.discFilter = DM_FLAG_LE_LIMITED_DISC;
   24484:	4b11      	ldr	r3, [pc, #68]	; (244cc <dmScanActStart+0xa8>)
   24486:	2201      	movs	r2, #1
   24488:	775a      	strb	r2, [r3, #29]
   2448a:	e00a      	b.n	244a2 <dmScanActStart+0x7e>
    }
    else if (pMsg->apiStart.mode == DM_DISC_MODE_GENERAL)
   2448c:	687b      	ldr	r3, [r7, #4]
   2448e:	79db      	ldrb	r3, [r3, #7]
   24490:	2b02      	cmp	r3, #2
   24492:	d103      	bne.n	2449c <dmScanActStart+0x78>
    {
      dmScanCb.discFilter = DM_FLAG_LE_LIMITED_DISC | DM_FLAG_LE_GENERAL_DISC;
   24494:	4b0d      	ldr	r3, [pc, #52]	; (244cc <dmScanActStart+0xa8>)
   24496:	2203      	movs	r2, #3
   24498:	775a      	strb	r2, [r3, #29]
   2449a:	e002      	b.n	244a2 <dmScanActStart+0x7e>
    }
    else
    {
      dmScanCb.discFilter = 0;
   2449c:	4b0b      	ldr	r3, [pc, #44]	; (244cc <dmScanActStart+0xa8>)
   2449e:	2200      	movs	r2, #0
   244a0:	775a      	strb	r2, [r3, #29]
    }
    dmScanCb.filterNextScanRsp = FALSE;
   244a2:	4b0a      	ldr	r3, [pc, #40]	; (244cc <dmScanActStart+0xa8>)
   244a4:	2200      	movs	r2, #0
   244a6:	771a      	strb	r2, [r3, #28]

    /* enable scan */
    dmScanCb.scanDuration = pMsg->apiStart.duration;
   244a8:	687b      	ldr	r3, [r7, #4]
   244aa:	891a      	ldrh	r2, [r3, #8]
   244ac:	4b07      	ldr	r3, [pc, #28]	; (244cc <dmScanActStart+0xa8>)
   244ae:	835a      	strh	r2, [r3, #26]
    dmScanCb.scanState = DM_SCAN_STATE_STARTING;
   244b0:	4b06      	ldr	r3, [pc, #24]	; (244cc <dmScanActStart+0xa8>)
   244b2:	2201      	movs	r2, #1
   244b4:	761a      	strb	r2, [r3, #24]
    HciLeSetScanEnableCmd(TRUE, pMsg->apiStart.filterDup);
   244b6:	687b      	ldr	r3, [r7, #4]
   244b8:	7b1b      	ldrb	r3, [r3, #12]
   244ba:	4619      	mov	r1, r3
   244bc:	2001      	movs	r0, #1
   244be:	f001 f8e3 	bl	25688 <HciLeSetScanEnableCmd>
  }
}
   244c2:	bf00      	nop
   244c4:	3714      	adds	r7, #20
   244c6:	46bd      	mov	sp, r7
   244c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
   244ca:	bf00      	nop
   244cc:	10011304 	.word	0x10011304
   244d0:	100112ec 	.word	0x100112ec

000244d4 <dmScanActStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanActStop(dmScanMsg_t *pMsg)
{
   244d4:	b580      	push	{r7, lr}
   244d6:	b082      	sub	sp, #8
   244d8:	af00      	add	r7, sp, #0
   244da:	6078      	str	r0, [r7, #4]
  if (dmScanCb.scanState == DM_SCAN_STATE_SCANNING)
   244dc:	4b07      	ldr	r3, [pc, #28]	; (244fc <dmScanActStop+0x28>)
   244de:	7e1b      	ldrb	r3, [r3, #24]
   244e0:	2b02      	cmp	r3, #2
   244e2:	d106      	bne.n	244f2 <dmScanActStop+0x1e>
  {
    /* disable scan */
    dmScanCb.scanState = DM_SCAN_STATE_STOPPING;
   244e4:	4b05      	ldr	r3, [pc, #20]	; (244fc <dmScanActStop+0x28>)
   244e6:	2203      	movs	r2, #3
   244e8:	761a      	strb	r2, [r3, #24]
    HciLeSetScanEnableCmd(FALSE, 0);
   244ea:	2100      	movs	r1, #0
   244ec:	2000      	movs	r0, #0
   244ee:	f001 f8cb 	bl	25688 <HciLeSetScanEnableCmd>
  }
}
   244f2:	bf00      	nop
   244f4:	3708      	adds	r7, #8
   244f6:	46bd      	mov	sp, r7
   244f8:	bd80      	pop	{r7, pc}
   244fa:	bf00      	nop
   244fc:	10011304 	.word	0x10011304

00024500 <dmScanActTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanActTimeout(dmScanMsg_t *pMsg)
{
   24500:	b580      	push	{r7, lr}
   24502:	b082      	sub	sp, #8
   24504:	af00      	add	r7, sp, #0
   24506:	6078      	str	r0, [r7, #4]
  dmScanActStop(pMsg);
   24508:	6878      	ldr	r0, [r7, #4]
   2450a:	f7ff ffe3 	bl	244d4 <dmScanActStop>
}
   2450e:	bf00      	nop
   24510:	3708      	adds	r7, #8
   24512:	46bd      	mov	sp, r7
   24514:	bd80      	pop	{r7, pc}
	...

00024518 <dmScanActHciReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void dmScanActHciReport(hciEvt_t *pEvent)
{
   24518:	b580      	push	{r7, lr}
   2451a:	b084      	sub	sp, #16
   2451c:	af00      	add	r7, sp, #0
   2451e:	6078      	str	r0, [r7, #4]
  uint8_t *p;
  bool_t  filtered = FALSE;
   24520:	2300      	movs	r3, #0
   24522:	73fb      	strb	r3, [r7, #15]

  /* ignore if not scanning */
  if (dmScanCb.scanState == DM_SCAN_STATE_SCANNING)
   24524:	4b22      	ldr	r3, [pc, #136]	; (245b0 <dmScanActHciReport+0x98>)
   24526:	7e1b      	ldrb	r3, [r3, #24]
   24528:	2b02      	cmp	r3, #2
   2452a:	d13c      	bne.n	245a6 <dmScanActHciReport+0x8e>
  {
    /* if filtering results for limited or general discovery */
    if (dmScanCb.discFilter != 0)
   2452c:	4b20      	ldr	r3, [pc, #128]	; (245b0 <dmScanActHciReport+0x98>)
   2452e:	7f5b      	ldrb	r3, [r3, #29]
   24530:	2b00      	cmp	r3, #0
   24532:	d02e      	beq.n	24592 <dmScanActHciReport+0x7a>
    {
      /* if this is a scan response */
      if (pEvent->leAdvReport.eventType == DM_RPT_SCAN_RESPONSE)
   24534:	687b      	ldr	r3, [r7, #4]
   24536:	7a9b      	ldrb	r3, [r3, #10]
   24538:	2b04      	cmp	r3, #4
   2453a:	d109      	bne.n	24550 <dmScanActHciReport+0x38>
      {
        /* check if filtering next scan response */
        if (dmScanCb.filterNextScanRsp)
   2453c:	4b1c      	ldr	r3, [pc, #112]	; (245b0 <dmScanActHciReport+0x98>)
   2453e:	7f1b      	ldrb	r3, [r3, #28]
   24540:	2b00      	cmp	r3, #0
   24542:	d026      	beq.n	24592 <dmScanActHciReport+0x7a>
        {
          filtered = TRUE;
   24544:	2301      	movs	r3, #1
   24546:	73fb      	strb	r3, [r7, #15]
          dmScanCb.filterNextScanRsp = FALSE;
   24548:	4b19      	ldr	r3, [pc, #100]	; (245b0 <dmScanActHciReport+0x98>)
   2454a:	2200      	movs	r2, #0
   2454c:	771a      	strb	r2, [r3, #28]
   2454e:	e020      	b.n	24592 <dmScanActHciReport+0x7a>
      }
      /* else it's an advertising response */
      else
      {
        /* find flags in advertising data */
        p = DmFindAdType(DM_ADV_TYPE_FLAGS, pEvent->leAdvReport.len, pEvent->leAdvReport.pData);
   24550:	687b      	ldr	r3, [r7, #4]
   24552:	7a1b      	ldrb	r3, [r3, #8]
   24554:	b299      	uxth	r1, r3
   24556:	687b      	ldr	r3, [r7, #4]
   24558:	685b      	ldr	r3, [r3, #4]
   2455a:	461a      	mov	r2, r3
   2455c:	2001      	movs	r0, #1
   2455e:	f7ff fc47 	bl	23df0 <DmFindAdType>
   24562:	60b8      	str	r0, [r7, #8]
        if (p == NULL)
   24564:	68bb      	ldr	r3, [r7, #8]
   24566:	2b00      	cmp	r3, #0
   24568:	d105      	bne.n	24576 <dmScanActHciReport+0x5e>
        {
          /* flags not found */
          filtered = TRUE;
   2456a:	2301      	movs	r3, #1
   2456c:	73fb      	strb	r3, [r7, #15]
          dmScanCb.filterNextScanRsp = TRUE;
   2456e:	4b10      	ldr	r3, [pc, #64]	; (245b0 <dmScanActHciReport+0x98>)
   24570:	2201      	movs	r2, #1
   24572:	771a      	strb	r2, [r3, #28]
   24574:	e00d      	b.n	24592 <dmScanActHciReport+0x7a>
        }
        /* else flags found; check them */
        else if ((p[DM_AD_DATA_IDX] & dmScanCb.discFilter) == 0)
   24576:	68bb      	ldr	r3, [r7, #8]
   24578:	3302      	adds	r3, #2
   2457a:	781a      	ldrb	r2, [r3, #0]
   2457c:	4b0c      	ldr	r3, [pc, #48]	; (245b0 <dmScanActHciReport+0x98>)
   2457e:	7f5b      	ldrb	r3, [r3, #29]
   24580:	4013      	ands	r3, r2
   24582:	b2db      	uxtb	r3, r3
   24584:	2b00      	cmp	r3, #0
   24586:	d104      	bne.n	24592 <dmScanActHciReport+0x7a>
        {
          /* flags do not match discovery mode */
          filtered = TRUE;
   24588:	2301      	movs	r3, #1
   2458a:	73fb      	strb	r3, [r7, #15]
          dmScanCb.filterNextScanRsp = TRUE;
   2458c:	4b08      	ldr	r3, [pc, #32]	; (245b0 <dmScanActHciReport+0x98>)
   2458e:	2201      	movs	r2, #1
   24590:	771a      	strb	r2, [r3, #28]
        }
      }
    }

    if (!filtered)
   24592:	7bfb      	ldrb	r3, [r7, #15]
   24594:	2b00      	cmp	r3, #0
   24596:	d106      	bne.n	245a6 <dmScanActHciReport+0x8e>
    {
      pEvent->hdr.event = DM_SCAN_REPORT_IND;
   24598:	687b      	ldr	r3, [r7, #4]
   2459a:	2226      	movs	r2, #38	; 0x26
   2459c:	709a      	strb	r2, [r3, #2]
      (*dmCb.cback)((dmEvt_t *) pEvent);
   2459e:	4b05      	ldr	r3, [pc, #20]	; (245b4 <dmScanActHciReport+0x9c>)
   245a0:	689b      	ldr	r3, [r3, #8]
   245a2:	6878      	ldr	r0, [r7, #4]
   245a4:	4798      	blx	r3
    }
  }
}
   245a6:	bf00      	nop
   245a8:	3710      	adds	r7, #16
   245aa:	46bd      	mov	sp, r7
   245ac:	bd80      	pop	{r7, pc}
   245ae:	bf00      	nop
   245b0:	10011304 	.word	0x10011304
   245b4:	100112ec 	.word	0x100112ec

000245b8 <dmScanReset>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanReset(void)
{
   245b8:	b580      	push	{r7, lr}
   245ba:	b082      	sub	sp, #8
   245bc:	af00      	add	r7, sp, #0
  wsfMsgHdr_t scanStop;

  /* if stopping scan or scanning */
  if ((dmScanCb.scanState == DM_SCAN_STATE_STOPPING) ||
   245be:	4b0e      	ldr	r3, [pc, #56]	; (245f8 <dmScanReset+0x40>)
   245c0:	7e1b      	ldrb	r3, [r3, #24]
   245c2:	2b03      	cmp	r3, #3
   245c4:	d003      	beq.n	245ce <dmScanReset+0x16>
      (dmScanCb.scanState == DM_SCAN_STATE_SCANNING))
   245c6:	4b0c      	ldr	r3, [pc, #48]	; (245f8 <dmScanReset+0x40>)
   245c8:	7e1b      	ldrb	r3, [r3, #24]
  if ((dmScanCb.scanState == DM_SCAN_STATE_STOPPING) ||
   245ca:	2b02      	cmp	r3, #2
   245cc:	d10e      	bne.n	245ec <dmScanReset+0x34>
  {
    /* stop scan timer */
    WsfTimerStop(&dmScanCb.scanTimer);
   245ce:	480a      	ldr	r0, [pc, #40]	; (245f8 <dmScanReset+0x40>)
   245d0:	f009 f932 	bl	2d838 <WsfTimerStop>

    /* generate scan stop event */
    scanStop.event = DM_SCAN_STOP_IND;
   245d4:	2325      	movs	r3, #37	; 0x25
   245d6:	71bb      	strb	r3, [r7, #6]
    scanStop.status = HCI_SUCCESS;
   245d8:	2300      	movs	r3, #0
   245da:	71fb      	strb	r3, [r7, #7]

    /* call callback */
    (*dmCb.cback)((dmEvt_t *) &scanStop);
   245dc:	4b07      	ldr	r3, [pc, #28]	; (245fc <dmScanReset+0x44>)
   245de:	689b      	ldr	r3, [r3, #8]
   245e0:	1d3a      	adds	r2, r7, #4
   245e2:	4610      	mov	r0, r2
   245e4:	4798      	blx	r3

    dmScanCb.scanState = DM_SCAN_STATE_IDLE;
   245e6:	4b04      	ldr	r3, [pc, #16]	; (245f8 <dmScanReset+0x40>)
   245e8:	2200      	movs	r2, #0
   245ea:	761a      	strb	r2, [r3, #24]
  }

  /* reset scan module */
  dmScanInit();
   245ec:	f7ff fe22 	bl	24234 <dmScanInit>
}
   245f0:	bf00      	nop
   245f2:	3708      	adds	r7, #8
   245f4:	46bd      	mov	sp, r7
   245f6:	bd80      	pop	{r7, pc}
   245f8:	10011304 	.word	0x10011304
   245fc:	100112ec 	.word	0x100112ec

00024600 <dmScanHciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanHciHandler(hciEvt_t *pEvent)
{
   24600:	b580      	push	{r7, lr}
   24602:	b082      	sub	sp, #8
   24604:	af00      	add	r7, sp, #0
   24606:	6078      	str	r0, [r7, #4]
  if (pEvent->hdr.event == HCI_LE_ADV_REPORT_CBACK_EVT)
   24608:	687b      	ldr	r3, [r7, #4]
   2460a:	789b      	ldrb	r3, [r3, #2]
   2460c:	2b06      	cmp	r3, #6
   2460e:	d103      	bne.n	24618 <dmScanHciHandler+0x18>
  {
    dmScanActHciReport(pEvent);
   24610:	6878      	ldr	r0, [r7, #4]
   24612:	f7ff ff81 	bl	24518 <dmScanActHciReport>
                           0, 0);

    /* call callback */
    (*dmCb.cback)((dmEvt_t *) pEvent);
  }
}
   24616:	e049      	b.n	246ac <dmScanHciHandler+0xac>
  else if (pEvent->hdr.event == HCI_LE_SCAN_ENABLE_CMD_CMPL_CBACK_EVT)
   24618:	687b      	ldr	r3, [r7, #4]
   2461a:	789b      	ldrb	r3, [r3, #2]
   2461c:	2b34      	cmp	r3, #52	; 0x34
   2461e:	d145      	bne.n	246ac <dmScanHciHandler+0xac>
    switch (dmScanCb.scanState)
   24620:	4b24      	ldr	r3, [pc, #144]	; (246b4 <dmScanHciHandler+0xb4>)
   24622:	7e1b      	ldrb	r3, [r3, #24]
   24624:	2b01      	cmp	r3, #1
   24626:	d002      	beq.n	2462e <dmScanHciHandler+0x2e>
   24628:	2b03      	cmp	r3, #3
   2462a:	d01c      	beq.n	24666 <dmScanHciHandler+0x66>
      break;
   2462c:	e02d      	b.n	2468a <dmScanHciHandler+0x8a>
      if (pEvent->hdr.status == HCI_SUCCESS)
   2462e:	687b      	ldr	r3, [r7, #4]
   24630:	78db      	ldrb	r3, [r3, #3]
   24632:	2b00      	cmp	r3, #0
   24634:	d110      	bne.n	24658 <dmScanHciHandler+0x58>
        if (dmScanCb.scanDuration > 0)
   24636:	4b1f      	ldr	r3, [pc, #124]	; (246b4 <dmScanHciHandler+0xb4>)
   24638:	8b5b      	ldrh	r3, [r3, #26]
   2463a:	2b00      	cmp	r3, #0
   2463c:	d008      	beq.n	24650 <dmScanHciHandler+0x50>
          dmScanCb.scanTimer.msg.event = DM_SCAN_MSG_TIMEOUT;
   2463e:	4b1d      	ldr	r3, [pc, #116]	; (246b4 <dmScanHciHandler+0xb4>)
   24640:	2222      	movs	r2, #34	; 0x22
   24642:	729a      	strb	r2, [r3, #10]
          WsfTimerStartMs(&dmScanCb.scanTimer, dmScanCb.scanDuration);
   24644:	4b1b      	ldr	r3, [pc, #108]	; (246b4 <dmScanHciHandler+0xb4>)
   24646:	8b5b      	ldrh	r3, [r3, #26]
   24648:	4619      	mov	r1, r3
   2464a:	481a      	ldr	r0, [pc, #104]	; (246b4 <dmScanHciHandler+0xb4>)
   2464c:	f009 f8e0 	bl	2d810 <WsfTimerStartMs>
        dmScanCb.scanState = DM_SCAN_STATE_SCANNING;
   24650:	4b18      	ldr	r3, [pc, #96]	; (246b4 <dmScanHciHandler+0xb4>)
   24652:	2202      	movs	r2, #2
   24654:	761a      	strb	r2, [r3, #24]
   24656:	e002      	b.n	2465e <dmScanHciHandler+0x5e>
        dmScanCb.scanState = DM_SCAN_STATE_IDLE;
   24658:	4b16      	ldr	r3, [pc, #88]	; (246b4 <dmScanHciHandler+0xb4>)
   2465a:	2200      	movs	r2, #0
   2465c:	761a      	strb	r2, [r3, #24]
      pEvent->hdr.event = DM_SCAN_START_IND;
   2465e:	687b      	ldr	r3, [r7, #4]
   24660:	2224      	movs	r2, #36	; 0x24
   24662:	709a      	strb	r2, [r3, #2]
      break;
   24664:	e011      	b.n	2468a <dmScanHciHandler+0x8a>
      if (pEvent->hdr.status == HCI_SUCCESS)
   24666:	687b      	ldr	r3, [r7, #4]
   24668:	78db      	ldrb	r3, [r3, #3]
   2466a:	2b00      	cmp	r3, #0
   2466c:	d106      	bne.n	2467c <dmScanHciHandler+0x7c>
        WsfTimerStop(&dmScanCb.scanTimer);
   2466e:	4811      	ldr	r0, [pc, #68]	; (246b4 <dmScanHciHandler+0xb4>)
   24670:	f009 f8e2 	bl	2d838 <WsfTimerStop>
        dmScanCb.scanState = DM_SCAN_STATE_IDLE;
   24674:	4b0f      	ldr	r3, [pc, #60]	; (246b4 <dmScanHciHandler+0xb4>)
   24676:	2200      	movs	r2, #0
   24678:	761a      	strb	r2, [r3, #24]
   2467a:	e002      	b.n	24682 <dmScanHciHandler+0x82>
        dmScanCb.scanState = DM_SCAN_STATE_SCANNING;
   2467c:	4b0d      	ldr	r3, [pc, #52]	; (246b4 <dmScanHciHandler+0xb4>)
   2467e:	2202      	movs	r2, #2
   24680:	761a      	strb	r2, [r3, #24]
      pEvent->hdr.event = DM_SCAN_STOP_IND;
   24682:	687b      	ldr	r3, [r7, #4]
   24684:	2225      	movs	r2, #37	; 0x25
   24686:	709a      	strb	r2, [r3, #2]
      break;
   24688:	bf00      	nop
    dmDevPassEvtToDevPriv((pEvent->hdr.event == DM_SCAN_START_IND) ? \
   2468a:	687b      	ldr	r3, [r7, #4]
   2468c:	789b      	ldrb	r3, [r3, #2]
   2468e:	2b24      	cmp	r3, #36	; 0x24
   24690:	d101      	bne.n	24696 <dmScanHciHandler+0x96>
   24692:	2014      	movs	r0, #20
   24694:	e000      	b.n	24698 <dmScanHciHandler+0x98>
   24696:	2015      	movs	r0, #21
   24698:	687b      	ldr	r3, [r7, #4]
   2469a:	7899      	ldrb	r1, [r3, #2]
   2469c:	2300      	movs	r3, #0
   2469e:	2200      	movs	r2, #0
   246a0:	f7ff fac2 	bl	23c28 <dmDevPassEvtToDevPriv>
    (*dmCb.cback)((dmEvt_t *) pEvent);
   246a4:	4b04      	ldr	r3, [pc, #16]	; (246b8 <dmScanHciHandler+0xb8>)
   246a6:	689b      	ldr	r3, [r3, #8]
   246a8:	6878      	ldr	r0, [r7, #4]
   246aa:	4798      	blx	r3
}
   246ac:	bf00      	nop
   246ae:	3708      	adds	r7, #8
   246b0:	46bd      	mov	sp, r7
   246b2:	bd80      	pop	{r7, pc}
   246b4:	10011304 	.word	0x10011304
   246b8:	100112ec 	.word	0x100112ec

000246bc <dmScanMsgHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void dmScanMsgHandler(wsfMsgHdr_t *pMsg)
{
   246bc:	b580      	push	{r7, lr}
   246be:	b082      	sub	sp, #8
   246c0:	af00      	add	r7, sp, #0
   246c2:	6078      	str	r0, [r7, #4]
  /* execute action function */
  (*dmScanAct[DM_MSG_MASK(pMsg->event)])((dmScanMsg_t *)pMsg);
   246c4:	687b      	ldr	r3, [r7, #4]
   246c6:	789b      	ldrb	r3, [r3, #2]
   246c8:	f003 030f 	and.w	r3, r3, #15
   246cc:	4a04      	ldr	r2, [pc, #16]	; (246e0 <dmScanMsgHandler+0x24>)
   246ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   246d2:	6878      	ldr	r0, [r7, #4]
   246d4:	4798      	blx	r3
}
   246d6:	bf00      	nop
   246d8:	3708      	adds	r7, #8
   246da:	46bd      	mov	sp, r7
   246dc:	bd80      	pop	{r7, pc}
   246de:	bf00      	nop
   246e0:	00045d54 	.word	0x00045d54

000246e4 <DmScanInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmScanInit(void)
{
   246e4:	b580      	push	{r7, lr}
   246e6:	af00      	add	r7, sp, #0
  WsfTaskLock();
   246e8:	f008 fd8c 	bl	2d204 <WsfTaskLock>

  /* set function interface table */
  dmFcnIfTbl[DM_ID_SCAN] = (dmFcnIf_t *) &dmScanFcnIf;
   246ec:	4b04      	ldr	r3, [pc, #16]	; (24700 <DmScanInit+0x1c>)
   246ee:	4a05      	ldr	r2, [pc, #20]	; (24704 <DmScanInit+0x20>)
   246f0:	609a      	str	r2, [r3, #8]

  /* initialize scan module */
  dmScanInit();
   246f2:	f7ff fd9f 	bl	24234 <dmScanInit>

  WsfTaskUnlock();
   246f6:	f008 fd8b 	bl	2d210 <WsfTaskUnlock>
}
   246fa:	bf00      	nop
   246fc:	bd80      	pop	{r7, pc}
   246fe:	bf00      	nop
   24700:	10002b90 	.word	0x10002b90
   24704:	00045d60 	.word	0x00045d60

00024708 <DmScanModeLeg>:
 *
 *  \return TRUE if DM scanning is in legacy mode. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t DmScanModeLeg(void)
{
   24708:	b480      	push	{r7}
   2470a:	af00      	add	r7, sp, #0
  return (dmFcnIfTbl[DM_ID_SCAN] == (dmFcnIf_t *) &dmScanFcnIf) ? TRUE : FALSE;
   2470c:	4b06      	ldr	r3, [pc, #24]	; (24728 <DmScanModeLeg+0x20>)
   2470e:	689b      	ldr	r3, [r3, #8]
   24710:	4a06      	ldr	r2, [pc, #24]	; (2472c <DmScanModeLeg+0x24>)
   24712:	4293      	cmp	r3, r2
   24714:	bf0c      	ite	eq
   24716:	2301      	moveq	r3, #1
   24718:	2300      	movne	r3, #0
   2471a:	b2db      	uxtb	r3, r3
}
   2471c:	4618      	mov	r0, r3
   2471e:	46bd      	mov	sp, r7
   24720:	f85d 7b04 	ldr.w	r7, [sp], #4
   24724:	4770      	bx	lr
   24726:	bf00      	nop
   24728:	10002b90 	.word	0x10002b90
   2472c:	00045d60 	.word	0x00045d60

00024730 <DmSecCancelReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecCancelReq(dmConnId_t connId, uint8_t reason)
{
   24730:	b580      	push	{r7, lr}
   24732:	b084      	sub	sp, #16
   24734:	af00      	add	r7, sp, #0
   24736:	4603      	mov	r3, r0
   24738:	460a      	mov	r2, r1
   2473a:	71fb      	strb	r3, [r7, #7]
   2473c:	4613      	mov	r3, r2
   2473e:	71bb      	strb	r3, [r7, #6]
  wsfMsgHdr_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(wsfMsgHdr_t))) != NULL)
   24740:	2004      	movs	r0, #4
   24742:	f008 fcb4 	bl	2d0ae <WsfMsgAlloc>
   24746:	60f8      	str	r0, [r7, #12]
   24748:	68fb      	ldr	r3, [r7, #12]
   2474a:	2b00      	cmp	r3, #0
   2474c:	d00c      	beq.n	24768 <DmSecCancelReq+0x38>
  {
    pMsg->event = SMP_MSG_API_CANCEL_REQ;
   2474e:	68fb      	ldr	r3, [r7, #12]
   24750:	2203      	movs	r2, #3
   24752:	709a      	strb	r2, [r3, #2]
    pMsg->param = connId;
   24754:	79fb      	ldrb	r3, [r7, #7]
   24756:	b29a      	uxth	r2, r3
   24758:	68fb      	ldr	r3, [r7, #12]
   2475a:	801a      	strh	r2, [r3, #0]
    pMsg->status = reason;
   2475c:	68fb      	ldr	r3, [r7, #12]
   2475e:	79ba      	ldrb	r2, [r7, #6]
   24760:	70da      	strb	r2, [r3, #3]

    /* note we're sending this to SMP */
    SmpDmMsgSend((smpDmMsg_t *) pMsg);
   24762:	68f8      	ldr	r0, [r7, #12]
   24764:	f007 f922 	bl	2b9ac <SmpDmMsgSend>
  }
}
   24768:	bf00      	nop
   2476a:	3710      	adds	r7, #16
   2476c:	46bd      	mov	sp, r7
   2476e:	bd80      	pop	{r7, pc}

00024770 <DmSecGetLocalIrk>:
 *
 *  \return Pointer to IRK.
 */
/*************************************************************************************************/
uint8_t *DmSecGetLocalIrk(void)
{
   24770:	b480      	push	{r7}
   24772:	af00      	add	r7, sp, #0
  return dmSecCb.pIrk;
   24774:	4b03      	ldr	r3, [pc, #12]	; (24784 <DmSecGetLocalIrk+0x14>)
   24776:	681b      	ldr	r3, [r3, #0]
}
   24778:	4618      	mov	r0, r3
   2477a:	46bd      	mov	sp, r7
   2477c:	f85d 7b04 	ldr.w	r7, [sp], #4
   24780:	4770      	bx	lr
   24782:	bf00      	nop
   24784:	10011324 	.word	0x10011324

00024788 <DmSecPairReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecPairReq(dmConnId_t connId, uint8_t oob, uint8_t auth, uint8_t iKeyDist, uint8_t rKeyDist)
{
   24788:	b590      	push	{r4, r7, lr}
   2478a:	b085      	sub	sp, #20
   2478c:	af00      	add	r7, sp, #0
   2478e:	4604      	mov	r4, r0
   24790:	4608      	mov	r0, r1
   24792:	4611      	mov	r1, r2
   24794:	461a      	mov	r2, r3
   24796:	4623      	mov	r3, r4
   24798:	71fb      	strb	r3, [r7, #7]
   2479a:	4603      	mov	r3, r0
   2479c:	71bb      	strb	r3, [r7, #6]
   2479e:	460b      	mov	r3, r1
   247a0:	717b      	strb	r3, [r7, #5]
   247a2:	4613      	mov	r3, r2
   247a4:	713b      	strb	r3, [r7, #4]
  smpDmPair_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(smpDmPair_t))) != NULL)
   247a6:	2008      	movs	r0, #8
   247a8:	f008 fc81 	bl	2d0ae <WsfMsgAlloc>
   247ac:	60f8      	str	r0, [r7, #12]
   247ae:	68fb      	ldr	r3, [r7, #12]
   247b0:	2b00      	cmp	r3, #0
   247b2:	d01c      	beq.n	247ee <DmSecPairReq+0x66>
  {
    pMsg->hdr.event = SMP_MSG_API_PAIR_REQ;
   247b4:	68fb      	ldr	r3, [r7, #12]
   247b6:	2201      	movs	r2, #1
   247b8:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   247ba:	79fb      	ldrb	r3, [r7, #7]
   247bc:	b29a      	uxth	r2, r3
   247be:	68fb      	ldr	r3, [r7, #12]
   247c0:	801a      	strh	r2, [r3, #0]
    pMsg->oob = oob;
   247c2:	68fb      	ldr	r3, [r7, #12]
   247c4:	79ba      	ldrb	r2, [r7, #6]
   247c6:	711a      	strb	r2, [r3, #4]
    pMsg->auth = auth;
   247c8:	68fb      	ldr	r3, [r7, #12]
   247ca:	797a      	ldrb	r2, [r7, #5]
   247cc:	715a      	strb	r2, [r3, #5]

    /* clear any erroneous key dist bits set by app */
    pMsg->iKeyDist = iKeyDist & SMP_KEY_DIST_MASK;
   247ce:	793b      	ldrb	r3, [r7, #4]
   247d0:	f003 0307 	and.w	r3, r3, #7
   247d4:	b2da      	uxtb	r2, r3
   247d6:	68fb      	ldr	r3, [r7, #12]
   247d8:	719a      	strb	r2, [r3, #6]
    pMsg->rKeyDist = rKeyDist & SMP_KEY_DIST_MASK;
   247da:	f897 3020 	ldrb.w	r3, [r7, #32]
   247de:	f003 0307 	and.w	r3, r3, #7
   247e2:	b2da      	uxtb	r2, r3
   247e4:	68fb      	ldr	r3, [r7, #12]
   247e6:	71da      	strb	r2, [r3, #7]

    /* note we're sending this to SMP */
    SmpDmMsgSend((smpDmMsg_t *) pMsg);
   247e8:	68f8      	ldr	r0, [r7, #12]
   247ea:	f007 f8df 	bl	2b9ac <SmpDmMsgSend>
  }
}
   247ee:	bf00      	nop
   247f0:	3714      	adds	r7, #20
   247f2:	46bd      	mov	sp, r7
   247f4:	bd90      	pop	{r4, r7, pc}
	...

000247f8 <DmSecEncryptReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecEncryptReq(dmConnId_t connId, uint8_t secLevel, dmSecLtk_t *pLtk)
{
   247f8:	b580      	push	{r7, lr}
   247fa:	b084      	sub	sp, #16
   247fc:	af00      	add	r7, sp, #0
   247fe:	4603      	mov	r3, r0
   24800:	603a      	str	r2, [r7, #0]
   24802:	71fb      	strb	r3, [r7, #7]
   24804:	460b      	mov	r3, r1
   24806:	71bb      	strb	r3, [r7, #6]
  dmSecApiEncryptReq_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmSecApiEncryptReq_t))) != NULL)
   24808:	2020      	movs	r0, #32
   2480a:	f008 fc50 	bl	2d0ae <WsfMsgAlloc>
   2480e:	60f8      	str	r0, [r7, #12]
   24810:	68fb      	ldr	r3, [r7, #12]
   24812:	2b00      	cmp	r3, #0
   24814:	d016      	beq.n	24844 <DmSecEncryptReq+0x4c>
  {
    pMsg->hdr.event = DM_SEC_MSG_API_ENCRYPT_REQ;
   24816:	68fb      	ldr	r3, [r7, #12]
   24818:	2250      	movs	r2, #80	; 0x50
   2481a:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   2481c:	79fb      	ldrb	r3, [r7, #7]
   2481e:	b29a      	uxth	r2, r3
   24820:	68fb      	ldr	r3, [r7, #12]
   24822:	801a      	strh	r2, [r3, #0]
    memcpy(&pMsg->ltk, pLtk, sizeof(dmSecLtk_t));
   24824:	68fb      	ldr	r3, [r7, #12]
   24826:	3304      	adds	r3, #4
   24828:	221a      	movs	r2, #26
   2482a:	6839      	ldr	r1, [r7, #0]
   2482c:	4618      	mov	r0, r3
   2482e:	f7f3 fd11 	bl	18254 <memcpy>
    pMsg->secLevel = secLevel;
   24832:	68fb      	ldr	r3, [r7, #12]
   24834:	79ba      	ldrb	r2, [r7, #6]
   24836:	779a      	strb	r2, [r3, #30]

    WsfMsgSend(dmCb.handlerId, pMsg);
   24838:	4b04      	ldr	r3, [pc, #16]	; (2484c <DmSecEncryptReq+0x54>)
   2483a:	7b1b      	ldrb	r3, [r3, #12]
   2483c:	68f9      	ldr	r1, [r7, #12]
   2483e:	4618      	mov	r0, r3
   24840:	f008 fc59 	bl	2d0f6 <WsfMsgSend>
  }
}
   24844:	bf00      	nop
   24846:	3710      	adds	r7, #16
   24848:	46bd      	mov	sp, r7
   2484a:	bd80      	pop	{r7, pc}
   2484c:	100112ec 	.word	0x100112ec

00024850 <DmSecPairRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecPairRsp(dmConnId_t connId, uint8_t oob, uint8_t auth, uint8_t iKeyDist, uint8_t rKeyDist)
{
   24850:	b590      	push	{r4, r7, lr}
   24852:	b085      	sub	sp, #20
   24854:	af00      	add	r7, sp, #0
   24856:	4604      	mov	r4, r0
   24858:	4608      	mov	r0, r1
   2485a:	4611      	mov	r1, r2
   2485c:	461a      	mov	r2, r3
   2485e:	4623      	mov	r3, r4
   24860:	71fb      	strb	r3, [r7, #7]
   24862:	4603      	mov	r3, r0
   24864:	71bb      	strb	r3, [r7, #6]
   24866:	460b      	mov	r3, r1
   24868:	717b      	strb	r3, [r7, #5]
   2486a:	4613      	mov	r3, r2
   2486c:	713b      	strb	r3, [r7, #4]
  smpDmPair_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(smpDmPair_t))) != NULL)
   2486e:	2008      	movs	r0, #8
   24870:	f008 fc1d 	bl	2d0ae <WsfMsgAlloc>
   24874:	60f8      	str	r0, [r7, #12]
   24876:	68fb      	ldr	r3, [r7, #12]
   24878:	2b00      	cmp	r3, #0
   2487a:	d01c      	beq.n	248b6 <DmSecPairRsp+0x66>
  {
    pMsg->hdr.event = SMP_MSG_API_PAIR_RSP;
   2487c:	68fb      	ldr	r3, [r7, #12]
   2487e:	2202      	movs	r2, #2
   24880:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   24882:	79fb      	ldrb	r3, [r7, #7]
   24884:	b29a      	uxth	r2, r3
   24886:	68fb      	ldr	r3, [r7, #12]
   24888:	801a      	strh	r2, [r3, #0]
    pMsg->oob = oob;
   2488a:	68fb      	ldr	r3, [r7, #12]
   2488c:	79ba      	ldrb	r2, [r7, #6]
   2488e:	711a      	strb	r2, [r3, #4]
    pMsg->auth = auth;
   24890:	68fb      	ldr	r3, [r7, #12]
   24892:	797a      	ldrb	r2, [r7, #5]
   24894:	715a      	strb	r2, [r3, #5]

    /* clear any erroneous key dist bits set by app */
    pMsg->iKeyDist = iKeyDist & SMP_KEY_DIST_MASK;
   24896:	793b      	ldrb	r3, [r7, #4]
   24898:	f003 0307 	and.w	r3, r3, #7
   2489c:	b2da      	uxtb	r2, r3
   2489e:	68fb      	ldr	r3, [r7, #12]
   248a0:	719a      	strb	r2, [r3, #6]
    pMsg->rKeyDist = rKeyDist & SMP_KEY_DIST_MASK;
   248a2:	f897 3020 	ldrb.w	r3, [r7, #32]
   248a6:	f003 0307 	and.w	r3, r3, #7
   248aa:	b2da      	uxtb	r2, r3
   248ac:	68fb      	ldr	r3, [r7, #12]
   248ae:	71da      	strb	r2, [r3, #7]

    /* note we're sending this to SMP */
    SmpDmMsgSend((smpDmMsg_t *) pMsg);
   248b0:	68f8      	ldr	r0, [r7, #12]
   248b2:	f007 f87b 	bl	2b9ac <SmpDmMsgSend>
  }
}
   248b6:	bf00      	nop
   248b8:	3714      	adds	r7, #20
   248ba:	46bd      	mov	sp, r7
   248bc:	bd90      	pop	{r4, r7, pc}

000248be <DmSecSlaveReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecSlaveReq(dmConnId_t connId, uint8_t auth)
{
   248be:	b580      	push	{r7, lr}
   248c0:	b084      	sub	sp, #16
   248c2:	af00      	add	r7, sp, #0
   248c4:	4603      	mov	r3, r0
   248c6:	460a      	mov	r2, r1
   248c8:	71fb      	strb	r3, [r7, #7]
   248ca:	4613      	mov	r3, r2
   248cc:	71bb      	strb	r3, [r7, #6]
  smpDmSecurityReq_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(smpDmSecurityReq_t))) != NULL)
   248ce:	2006      	movs	r0, #6
   248d0:	f008 fbed 	bl	2d0ae <WsfMsgAlloc>
   248d4:	60f8      	str	r0, [r7, #12]
   248d6:	68fb      	ldr	r3, [r7, #12]
   248d8:	2b00      	cmp	r3, #0
   248da:	d00c      	beq.n	248f6 <DmSecSlaveReq+0x38>
  {
    pMsg->hdr.event = SMP_MSG_API_SECURITY_REQ;
   248dc:	68fb      	ldr	r3, [r7, #12]
   248de:	2205      	movs	r2, #5
   248e0:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   248e2:	79fb      	ldrb	r3, [r7, #7]
   248e4:	b29a      	uxth	r2, r3
   248e6:	68fb      	ldr	r3, [r7, #12]
   248e8:	801a      	strh	r2, [r3, #0]
    pMsg->auth = auth;
   248ea:	68fb      	ldr	r3, [r7, #12]
   248ec:	79ba      	ldrb	r2, [r7, #6]
   248ee:	711a      	strb	r2, [r3, #4]

    /* note we're sending this to SMP */
    SmpDmMsgSend((smpDmMsg_t *) pMsg);
   248f0:	68f8      	ldr	r0, [r7, #12]
   248f2:	f007 f85b 	bl	2b9ac <SmpDmMsgSend>
  }
}
   248f6:	bf00      	nop
   248f8:	3710      	adds	r7, #16
   248fa:	46bd      	mov	sp, r7
   248fc:	bd80      	pop	{r7, pc}
	...

00024900 <DmSecLtkRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void DmSecLtkRsp(dmConnId_t connId, bool_t keyFound, uint8_t secLevel, uint8_t *pKey)
{
   24900:	b580      	push	{r7, lr}
   24902:	b084      	sub	sp, #16
   24904:	af00      	add	r7, sp, #0
   24906:	603b      	str	r3, [r7, #0]
   24908:	4603      	mov	r3, r0
   2490a:	71fb      	strb	r3, [r7, #7]
   2490c:	460b      	mov	r3, r1
   2490e:	71bb      	strb	r3, [r7, #6]
   24910:	4613      	mov	r3, r2
   24912:	717b      	strb	r3, [r7, #5]
  dmSecApiLtkRsp_t  *pMsg;

  if ((pMsg = WsfMsgAlloc(sizeof(dmSecApiLtkRsp_t))) != NULL)
   24914:	2016      	movs	r0, #22
   24916:	f008 fbca 	bl	2d0ae <WsfMsgAlloc>
   2491a:	60f8      	str	r0, [r7, #12]
   2491c:	68fb      	ldr	r3, [r7, #12]
   2491e:	2b00      	cmp	r3, #0
   24920:	d01b      	beq.n	2495a <DmSecLtkRsp+0x5a>
  {
    pMsg->hdr.event = DM_SEC_MSG_API_LTK_RSP;
   24922:	68fb      	ldr	r3, [r7, #12]
   24924:	2251      	movs	r2, #81	; 0x51
   24926:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.param = connId;
   24928:	79fb      	ldrb	r3, [r7, #7]
   2492a:	b29a      	uxth	r2, r3
   2492c:	68fb      	ldr	r3, [r7, #12]
   2492e:	801a      	strh	r2, [r3, #0]
    pMsg->keyFound = keyFound;
   24930:	68fb      	ldr	r3, [r7, #12]
   24932:	79ba      	ldrb	r2, [r7, #6]
   24934:	751a      	strb	r2, [r3, #20]
    pMsg->secLevel = secLevel;
   24936:	68fb      	ldr	r3, [r7, #12]
   24938:	797a      	ldrb	r2, [r7, #5]
   2493a:	755a      	strb	r2, [r3, #21]
    if (keyFound)
   2493c:	79bb      	ldrb	r3, [r7, #6]
   2493e:	2b00      	cmp	r3, #0
   24940:	d005      	beq.n	2494e <DmSecLtkRsp+0x4e>
    {
      Calc128Cpy(pMsg->key, pKey);
   24942:	68fb      	ldr	r3, [r7, #12]
   24944:	3304      	adds	r3, #4
   24946:	6839      	ldr	r1, [r7, #0]
   24948:	4618      	mov	r0, r3
   2494a:	f7fd f94d 	bl	21be8 <Calc128Cpy>
    }

    WsfMsgSend(dmCb.handlerId, pMsg);
   2494e:	4b05      	ldr	r3, [pc, #20]	; (24964 <DmSecLtkRsp+0x64>)
   24950:	7b1b      	ldrb	r3, [r3, #12]
   24952:	68f9      	ldr	r1, [r7, #12]
   24954:	4618      	mov	r0, r3
   24956:	f008 fbce 	bl	2d0f6 <WsfMsgSend>
  }
}
   2495a:	bf00      	nop
   2495c:	3710      	adds	r7, #16
   2495e:	46bd      	mov	sp, r7
   24960:	bd80      	pop	{r7, pc}
   24962:	bf00      	nop
   24964:	100112ec 	.word	0x100112ec

00024968 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
   24968:	b580      	push	{r7, lr}
   2496a:	b082      	sub	sp, #8
   2496c:	af00      	add	r7, sp, #0
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
   2496e:	2018      	movs	r0, #24
   24970:	f004 ff66 	bl	29840 <pvPortMalloc>
   24974:	6078      	str	r0, [r7, #4]

		if( pxEventBits != NULL )
   24976:	687b      	ldr	r3, [r7, #4]
   24978:	2b00      	cmp	r3, #0
   2497a:	d007      	beq.n	2498c <xEventGroupCreate+0x24>
		{
			pxEventBits->uxEventBits = 0;
   2497c:	687b      	ldr	r3, [r7, #4]
   2497e:	2200      	movs	r2, #0
   24980:	601a      	str	r2, [r3, #0]
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
   24982:	687b      	ldr	r3, [r7, #4]
   24984:	3304      	adds	r3, #4
   24986:	4618      	mov	r0, r3
   24988:	f005 fd7e 	bl	2a488 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
   2498c:	687b      	ldr	r3, [r7, #4]
	}
   2498e:	4618      	mov	r0, r3
   24990:	3708      	adds	r7, #8
   24992:	46bd      	mov	sp, r7
   24994:	bd80      	pop	{r7, pc}
	...

00024998 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
   24998:	b580      	push	{r7, lr}
   2499a:	b08c      	sub	sp, #48	; 0x30
   2499c:	af00      	add	r7, sp, #0
   2499e:	60f8      	str	r0, [r7, #12]
   249a0:	60b9      	str	r1, [r7, #8]
   249a2:	607a      	str	r2, [r7, #4]
   249a4:	603b      	str	r3, [r7, #0]
EventGroup_t *pxEventBits = xEventGroup;
   249a6:	68fb      	ldr	r3, [r7, #12]
   249a8:	627b      	str	r3, [r7, #36]	; 0x24
EventBits_t uxReturn, uxControlBits = 0;
   249aa:	2300      	movs	r3, #0
   249ac:	62bb      	str	r3, [r7, #40]	; 0x28
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
   249ae:	2300      	movs	r3, #0
   249b0:	623b      	str	r3, [r7, #32]
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
   249b2:	f007 f99f 	bl	2bcf4 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
   249b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   249b8:	681b      	ldr	r3, [r3, #0]
   249ba:	61fb      	str	r3, [r7, #28]

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
   249bc:	683a      	ldr	r2, [r7, #0]
   249be:	68b9      	ldr	r1, [r7, #8]
   249c0:	69f8      	ldr	r0, [r7, #28]
   249c2:	f000 f8ed 	bl	24ba0 <prvTestWaitCondition>
   249c6:	61b8      	str	r0, [r7, #24]

		if( xWaitConditionMet != pdFALSE )
   249c8:	69bb      	ldr	r3, [r7, #24]
   249ca:	2b00      	cmp	r3, #0
   249cc:	d00e      	beq.n	249ec <xEventGroupWaitBits+0x54>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
   249ce:	69fb      	ldr	r3, [r7, #28]
   249d0:	62fb      	str	r3, [r7, #44]	; 0x2c
			xTicksToWait = ( TickType_t ) 0;
   249d2:	2300      	movs	r3, #0
   249d4:	63bb      	str	r3, [r7, #56]	; 0x38

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
   249d6:	687b      	ldr	r3, [r7, #4]
   249d8:	2b00      	cmp	r3, #0
   249da:	d028      	beq.n	24a2e <xEventGroupWaitBits+0x96>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   249dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   249de:	681a      	ldr	r2, [r3, #0]
   249e0:	68bb      	ldr	r3, [r7, #8]
   249e2:	43db      	mvns	r3, r3
   249e4:	401a      	ands	r2, r3
   249e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   249e8:	601a      	str	r2, [r3, #0]
   249ea:	e020      	b.n	24a2e <xEventGroupWaitBits+0x96>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
   249ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   249ee:	2b00      	cmp	r3, #0
   249f0:	d104      	bne.n	249fc <xEventGroupWaitBits+0x64>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
   249f2:	69fb      	ldr	r3, [r7, #28]
   249f4:	62fb      	str	r3, [r7, #44]	; 0x2c
			xTimeoutOccurred = pdTRUE;
   249f6:	2301      	movs	r3, #1
   249f8:	623b      	str	r3, [r7, #32]
   249fa:	e018      	b.n	24a2e <xEventGroupWaitBits+0x96>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
   249fc:	687b      	ldr	r3, [r7, #4]
   249fe:	2b00      	cmp	r3, #0
   24a00:	d003      	beq.n	24a0a <xEventGroupWaitBits+0x72>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
   24a02:	6abb      	ldr	r3, [r7, #40]	; 0x28
   24a04:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   24a08:	62bb      	str	r3, [r7, #40]	; 0x28
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
   24a0a:	683b      	ldr	r3, [r7, #0]
   24a0c:	2b00      	cmp	r3, #0
   24a0e:	d003      	beq.n	24a18 <xEventGroupWaitBits+0x80>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
   24a10:	6abb      	ldr	r3, [r7, #40]	; 0x28
   24a12:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
   24a16:	62bb      	str	r3, [r7, #40]	; 0x28
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
   24a18:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24a1a:	1d18      	adds	r0, r3, #4
   24a1c:	68ba      	ldr	r2, [r7, #8]
   24a1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   24a20:	4313      	orrs	r3, r2
   24a22:	6bba      	ldr	r2, [r7, #56]	; 0x38
   24a24:	4619      	mov	r1, r3
   24a26:	f007 fb5b 	bl	2c0e0 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
   24a2a:	2300      	movs	r3, #0
   24a2c:	62fb      	str	r3, [r7, #44]	; 0x2c

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
   24a2e:	f007 f9a7 	bl	2bd80 <xTaskResumeAll>
   24a32:	6178      	str	r0, [r7, #20]

	if( xTicksToWait != ( TickType_t ) 0 )
   24a34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   24a36:	2b00      	cmp	r3, #0
   24a38:	d031      	beq.n	24a9e <xEventGroupWaitBits+0x106>
	{
		if( xAlreadyYielded == pdFALSE )
   24a3a:	697b      	ldr	r3, [r7, #20]
   24a3c:	2b00      	cmp	r3, #0
   24a3e:	d107      	bne.n	24a50 <xEventGroupWaitBits+0xb8>
		{
			portYIELD_WITHIN_API();
   24a40:	4b19      	ldr	r3, [pc, #100]	; (24aa8 <xEventGroupWaitBits+0x110>)
   24a42:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   24a46:	601a      	str	r2, [r3, #0]
   24a48:	f3bf 8f4f 	dsb	sy
   24a4c:	f3bf 8f6f 	isb	sy

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
   24a50:	f007 fd5e 	bl	2c510 <uxTaskResetEventItemValue>
   24a54:	62f8      	str	r0, [r7, #44]	; 0x2c

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
   24a56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24a58:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
   24a5c:	2b00      	cmp	r3, #0
   24a5e:	d11a      	bne.n	24a96 <xEventGroupWaitBits+0xfe>
		{
			taskENTER_CRITICAL();
   24a60:	f005 feb0 	bl	2a7c4 <vPortEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
   24a64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24a66:	681b      	ldr	r3, [r3, #0]
   24a68:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
   24a6a:	683a      	ldr	r2, [r7, #0]
   24a6c:	68b9      	ldr	r1, [r7, #8]
   24a6e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   24a70:	f000 f896 	bl	24ba0 <prvTestWaitCondition>
   24a74:	4603      	mov	r3, r0
   24a76:	2b00      	cmp	r3, #0
   24a78:	d009      	beq.n	24a8e <xEventGroupWaitBits+0xf6>
				{
					if( xClearOnExit != pdFALSE )
   24a7a:	687b      	ldr	r3, [r7, #4]
   24a7c:	2b00      	cmp	r3, #0
   24a7e:	d006      	beq.n	24a8e <xEventGroupWaitBits+0xf6>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
   24a80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24a82:	681a      	ldr	r2, [r3, #0]
   24a84:	68bb      	ldr	r3, [r7, #8]
   24a86:	43db      	mvns	r3, r3
   24a88:	401a      	ands	r2, r3
   24a8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24a8c:	601a      	str	r2, [r3, #0]
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
   24a8e:	2301      	movs	r3, #1
   24a90:	623b      	str	r3, [r7, #32]
			}
			taskEXIT_CRITICAL();
   24a92:	f005 feb1 	bl	2a7f8 <vPortExitCritical>
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
   24a96:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24a98:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   24a9c:	62fb      	str	r3, [r7, #44]	; 0x2c
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
   24a9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
   24aa0:	4618      	mov	r0, r3
   24aa2:	3730      	adds	r7, #48	; 0x30
   24aa4:	46bd      	mov	sp, r7
   24aa6:	bd80      	pop	{r7, pc}
   24aa8:	e000ed04 	.word	0xe000ed04

00024aac <xEventGroupSetBits>:
	return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
   24aac:	b580      	push	{r7, lr}
   24aae:	b08c      	sub	sp, #48	; 0x30
   24ab0:	af00      	add	r7, sp, #0
   24ab2:	6078      	str	r0, [r7, #4]
   24ab4:	6039      	str	r1, [r7, #0]
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
   24ab6:	2300      	movs	r3, #0
   24ab8:	62bb      	str	r3, [r7, #40]	; 0x28
EventGroup_t *pxEventBits = xEventGroup;
   24aba:	687b      	ldr	r3, [r7, #4]
   24abc:	623b      	str	r3, [r7, #32]
BaseType_t xMatchFound = pdFALSE;
   24abe:	2300      	movs	r3, #0
   24ac0:	627b      	str	r3, [r7, #36]	; 0x24
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
   24ac2:	6a3b      	ldr	r3, [r7, #32]
   24ac4:	3304      	adds	r3, #4
   24ac6:	61fb      	str	r3, [r7, #28]
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   24ac8:	69fb      	ldr	r3, [r7, #28]
   24aca:	3308      	adds	r3, #8
   24acc:	61bb      	str	r3, [r7, #24]
	vTaskSuspendAll();
   24ace:	f007 f911 	bl	2bcf4 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
   24ad2:	69fb      	ldr	r3, [r7, #28]
   24ad4:	68db      	ldr	r3, [r3, #12]
   24ad6:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
   24ad8:	6a3b      	ldr	r3, [r7, #32]
   24ada:	681a      	ldr	r2, [r3, #0]
   24adc:	683b      	ldr	r3, [r7, #0]
   24ade:	431a      	orrs	r2, r3
   24ae0:	6a3b      	ldr	r3, [r7, #32]
   24ae2:	601a      	str	r2, [r3, #0]

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
   24ae4:	e03c      	b.n	24b60 <xEventGroupSetBits+0xb4>
		{
			pxNext = listGET_NEXT( pxListItem );
   24ae6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24ae8:	685b      	ldr	r3, [r3, #4]
   24aea:	617b      	str	r3, [r7, #20]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
   24aec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   24aee:	681b      	ldr	r3, [r3, #0]
   24af0:	613b      	str	r3, [r7, #16]
			xMatchFound = pdFALSE;
   24af2:	2300      	movs	r3, #0
   24af4:	627b      	str	r3, [r7, #36]	; 0x24

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
   24af6:	693b      	ldr	r3, [r7, #16]
   24af8:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
   24afc:	60fb      	str	r3, [r7, #12]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
   24afe:	693b      	ldr	r3, [r7, #16]
   24b00:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   24b04:	613b      	str	r3, [r7, #16]

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
   24b06:	68fb      	ldr	r3, [r7, #12]
   24b08:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
   24b0c:	2b00      	cmp	r3, #0
   24b0e:	d108      	bne.n	24b22 <xEventGroupSetBits+0x76>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
   24b10:	6a3b      	ldr	r3, [r7, #32]
   24b12:	681a      	ldr	r2, [r3, #0]
   24b14:	693b      	ldr	r3, [r7, #16]
   24b16:	4013      	ands	r3, r2
   24b18:	2b00      	cmp	r3, #0
   24b1a:	d00b      	beq.n	24b34 <xEventGroupSetBits+0x88>
				{
					xMatchFound = pdTRUE;
   24b1c:	2301      	movs	r3, #1
   24b1e:	627b      	str	r3, [r7, #36]	; 0x24
   24b20:	e008      	b.n	24b34 <xEventGroupSetBits+0x88>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
   24b22:	6a3b      	ldr	r3, [r7, #32]
   24b24:	681a      	ldr	r2, [r3, #0]
   24b26:	693b      	ldr	r3, [r7, #16]
   24b28:	4013      	ands	r3, r2
   24b2a:	693a      	ldr	r2, [r7, #16]
   24b2c:	429a      	cmp	r2, r3
   24b2e:	d101      	bne.n	24b34 <xEventGroupSetBits+0x88>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
   24b30:	2301      	movs	r3, #1
   24b32:	627b      	str	r3, [r7, #36]	; 0x24
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
   24b34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24b36:	2b00      	cmp	r3, #0
   24b38:	d010      	beq.n	24b5c <xEventGroupSetBits+0xb0>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
   24b3a:	68fb      	ldr	r3, [r7, #12]
   24b3c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   24b40:	2b00      	cmp	r3, #0
   24b42:	d003      	beq.n	24b4c <xEventGroupSetBits+0xa0>
				{
					uxBitsToClear |= uxBitsWaitedFor;
   24b44:	6aba      	ldr	r2, [r7, #40]	; 0x28
   24b46:	693b      	ldr	r3, [r7, #16]
   24b48:	4313      	orrs	r3, r2
   24b4a:	62bb      	str	r3, [r7, #40]	; 0x28
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
   24b4c:	6a3b      	ldr	r3, [r7, #32]
   24b4e:	681b      	ldr	r3, [r3, #0]
   24b50:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
   24b54:	4619      	mov	r1, r3
   24b56:	6af8      	ldr	r0, [r7, #44]	; 0x2c
   24b58:	f007 fb56 	bl	2c208 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
   24b5c:	697b      	ldr	r3, [r7, #20]
   24b5e:	62fb      	str	r3, [r7, #44]	; 0x2c
		while( pxListItem != pxListEnd )
   24b60:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   24b62:	69bb      	ldr	r3, [r7, #24]
   24b64:	429a      	cmp	r2, r3
   24b66:	d1be      	bne.n	24ae6 <xEventGroupSetBits+0x3a>
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
   24b68:	6a3b      	ldr	r3, [r7, #32]
   24b6a:	681a      	ldr	r2, [r3, #0]
   24b6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   24b6e:	43db      	mvns	r3, r3
   24b70:	401a      	ands	r2, r3
   24b72:	6a3b      	ldr	r3, [r7, #32]
   24b74:	601a      	str	r2, [r3, #0]
	}
	( void ) xTaskResumeAll();
   24b76:	f007 f903 	bl	2bd80 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
   24b7a:	6a3b      	ldr	r3, [r7, #32]
   24b7c:	681b      	ldr	r3, [r3, #0]
}
   24b7e:	4618      	mov	r0, r3
   24b80:	3730      	adds	r7, #48	; 0x30
   24b82:	46bd      	mov	sp, r7
   24b84:	bd80      	pop	{r7, pc}

00024b86 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
   24b86:	b580      	push	{r7, lr}
   24b88:	b082      	sub	sp, #8
   24b8a:	af00      	add	r7, sp, #0
   24b8c:	6078      	str	r0, [r7, #4]
   24b8e:	6039      	str	r1, [r7, #0]
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
   24b90:	6839      	ldr	r1, [r7, #0]
   24b92:	6878      	ldr	r0, [r7, #4]
   24b94:	f7ff ff8a 	bl	24aac <xEventGroupSetBits>
}
   24b98:	bf00      	nop
   24b9a:	3708      	adds	r7, #8
   24b9c:	46bd      	mov	sp, r7
   24b9e:	bd80      	pop	{r7, pc}

00024ba0 <prvTestWaitCondition>:
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
   24ba0:	b480      	push	{r7}
   24ba2:	b087      	sub	sp, #28
   24ba4:	af00      	add	r7, sp, #0
   24ba6:	60f8      	str	r0, [r7, #12]
   24ba8:	60b9      	str	r1, [r7, #8]
   24baa:	607a      	str	r2, [r7, #4]
BaseType_t xWaitConditionMet = pdFALSE;
   24bac:	2300      	movs	r3, #0
   24bae:	617b      	str	r3, [r7, #20]

	if( xWaitForAllBits == pdFALSE )
   24bb0:	687b      	ldr	r3, [r7, #4]
   24bb2:	2b00      	cmp	r3, #0
   24bb4:	d107      	bne.n	24bc6 <prvTestWaitCondition+0x26>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
   24bb6:	68fa      	ldr	r2, [r7, #12]
   24bb8:	68bb      	ldr	r3, [r7, #8]
   24bba:	4013      	ands	r3, r2
   24bbc:	2b00      	cmp	r3, #0
   24bbe:	d00a      	beq.n	24bd6 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
   24bc0:	2301      	movs	r3, #1
   24bc2:	617b      	str	r3, [r7, #20]
   24bc4:	e007      	b.n	24bd6 <prvTestWaitCondition+0x36>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
   24bc6:	68fa      	ldr	r2, [r7, #12]
   24bc8:	68bb      	ldr	r3, [r7, #8]
   24bca:	4013      	ands	r3, r2
   24bcc:	68ba      	ldr	r2, [r7, #8]
   24bce:	429a      	cmp	r2, r3
   24bd0:	d101      	bne.n	24bd6 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
   24bd2:	2301      	movs	r3, #1
   24bd4:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
   24bd6:	697b      	ldr	r3, [r7, #20]
}
   24bd8:	4618      	mov	r0, r3
   24bda:	371c      	adds	r7, #28
   24bdc:	46bd      	mov	sp, r7
   24bde:	f85d 7b04 	ldr.w	r7, [sp], #4
   24be2:	4770      	bx	lr

00024be4 <GattSetSvcChangedIdx>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void GattSetSvcChangedIdx(uint8_t idx)
{
   24be4:	b480      	push	{r7}
   24be6:	b083      	sub	sp, #12
   24be8:	af00      	add	r7, sp, #0
   24bea:	4603      	mov	r3, r0
   24bec:	71fb      	strb	r3, [r7, #7]
  gattServCb.svcChangedCccdIdxSet = TRUE;
   24bee:	4b06      	ldr	r3, [pc, #24]	; (24c08 <GattSetSvcChangedIdx+0x24>)
   24bf0:	2201      	movs	r2, #1
   24bf2:	701a      	strb	r2, [r3, #0]
  gattServCb.svcChangedCccdIdx = idx;
   24bf4:	4a04      	ldr	r2, [pc, #16]	; (24c08 <GattSetSvcChangedIdx+0x24>)
   24bf6:	79fb      	ldrb	r3, [r7, #7]
   24bf8:	7053      	strb	r3, [r2, #1]
}
   24bfa:	bf00      	nop
   24bfc:	370c      	adds	r7, #12
   24bfe:	46bd      	mov	sp, r7
   24c00:	f85d 7b04 	ldr.w	r7, [sp], #4
   24c04:	4770      	bx	lr
   24c06:	bf00      	nop
   24c08:	1001132c 	.word	0x1001132c

00024c0c <GattReadCback>:
 *  \return ATT status.
 */
/*************************************************************************************************/
uint8_t GattReadCback(dmConnId_t connId, uint16_t handle, uint8_t operation,
                      uint16_t offset, attsAttr_t *pAttr)
{
   24c0c:	b590      	push	{r4, r7, lr}
   24c0e:	b085      	sub	sp, #20
   24c10:	af00      	add	r7, sp, #0
   24c12:	4604      	mov	r4, r0
   24c14:	4608      	mov	r0, r1
   24c16:	4611      	mov	r1, r2
   24c18:	461a      	mov	r2, r3
   24c1a:	4623      	mov	r3, r4
   24c1c:	71fb      	strb	r3, [r7, #7]
   24c1e:	4603      	mov	r3, r0
   24c20:	80bb      	strh	r3, [r7, #4]
   24c22:	460b      	mov	r3, r1
   24c24:	71bb      	strb	r3, [r7, #6]
   24c26:	4613      	mov	r3, r2
   24c28:	807b      	strh	r3, [r7, #2]
  switch (handle)
   24c2a:	88bb      	ldrh	r3, [r7, #4]
   24c2c:	2b15      	cmp	r3, #21
   24c2e:	d10b      	bne.n	24c48 <GattReadCback+0x3c>
  {
    case GATT_CSF_HDL:
    {
      uint8_t csf[ATT_CSF_LEN];

      AttsCsfGetFeatures(connId, csf, sizeof(csf));
   24c30:	f107 010c 	add.w	r1, r7, #12
   24c34:	79fb      	ldrb	r3, [r7, #7]
   24c36:	2201      	movs	r2, #1
   24c38:	4618      	mov	r0, r3
   24c3a:	f7fa fb85 	bl	1f348 <AttsCsfGetFeatures>
      memcpy(pAttr->pValue, csf, ATT_CSF_LEN);
   24c3e:	6a3b      	ldr	r3, [r7, #32]
   24c40:	685b      	ldr	r3, [r3, #4]
   24c42:	7b3a      	ldrb	r2, [r7, #12]
   24c44:	701a      	strb	r2, [r3, #0]
    }
    break;
   24c46:	e000      	b.n	24c4a <GattReadCback+0x3e>

    default:
      break;
   24c48:	bf00      	nop
  }

  return ATT_SUCCESS;
   24c4a:	2300      	movs	r3, #0
}
   24c4c:	4618      	mov	r0, r3
   24c4e:	3714      	adds	r7, #20
   24c50:	46bd      	mov	sp, r7
   24c52:	bd90      	pop	{r4, r7, pc}

00024c54 <GattWriteCback>:
 *  \return ATT status.
 */
/*************************************************************************************************/
uint8_t GattWriteCback(dmConnId_t connId, uint16_t handle, uint8_t operation,
                       uint16_t offset, uint16_t len, uint8_t *pValue, attsAttr_t *pAttr)
{
   24c54:	b590      	push	{r4, r7, lr}
   24c56:	b085      	sub	sp, #20
   24c58:	af00      	add	r7, sp, #0
   24c5a:	4604      	mov	r4, r0
   24c5c:	4608      	mov	r0, r1
   24c5e:	4611      	mov	r1, r2
   24c60:	461a      	mov	r2, r3
   24c62:	4623      	mov	r3, r4
   24c64:	71fb      	strb	r3, [r7, #7]
   24c66:	4603      	mov	r3, r0
   24c68:	80bb      	strh	r3, [r7, #4]
   24c6a:	460b      	mov	r3, r1
   24c6c:	71bb      	strb	r3, [r7, #6]
   24c6e:	4613      	mov	r3, r2
   24c70:	807b      	strh	r3, [r7, #2]
  uint8_t status;

  switch (handle)
   24c72:	88bb      	ldrh	r3, [r7, #4]
   24c74:	2b15      	cmp	r3, #21
   24c76:	d108      	bne.n	24c8a <GattWriteCback+0x36>
  {
    case GATT_CSF_HDL:
      status = AttsCsfWriteFeatures(connId, offset, len, pValue);
   24c78:	8c3a      	ldrh	r2, [r7, #32]
   24c7a:	8879      	ldrh	r1, [r7, #2]
   24c7c:	79f8      	ldrb	r0, [r7, #7]
   24c7e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   24c80:	f7fa fb1e 	bl	1f2c0 <AttsCsfWriteFeatures>
   24c84:	4603      	mov	r3, r0
   24c86:	73fb      	strb	r3, [r7, #15]
      break;
   24c88:	e002      	b.n	24c90 <GattWriteCback+0x3c>

    default:
      status = ATT_SUCCESS;
   24c8a:	2300      	movs	r3, #0
   24c8c:	73fb      	strb	r3, [r7, #15]
      break;
   24c8e:	bf00      	nop
  }

  return status;
   24c90:	7bfb      	ldrb	r3, [r7, #15]
}
   24c92:	4618      	mov	r0, r3
   24c94:	3714      	adds	r7, #20
   24c96:	46bd      	mov	sp, r7
   24c98:	bd90      	pop	{r4, r7, pc}

00024c9a <hciCmdAlloc>:
 *
 *  \return Pointer to WSF msg buffer.
 */
/*************************************************************************************************/
uint8_t *hciCmdAlloc(uint16_t opcode, uint16_t len)
{
   24c9a:	b580      	push	{r7, lr}
   24c9c:	b084      	sub	sp, #16
   24c9e:	af00      	add	r7, sp, #0
   24ca0:	4603      	mov	r3, r0
   24ca2:	460a      	mov	r2, r1
   24ca4:	80fb      	strh	r3, [r7, #6]
   24ca6:	4613      	mov	r3, r2
   24ca8:	80bb      	strh	r3, [r7, #4]
  uint8_t   *p;

  /* allocate buffer */
  if ((p = WsfMsgAlloc(len + HCI_CMD_HDR_LEN)) != NULL)
   24caa:	88bb      	ldrh	r3, [r7, #4]
   24cac:	3303      	adds	r3, #3
   24cae:	b29b      	uxth	r3, r3
   24cb0:	4618      	mov	r0, r3
   24cb2:	f008 f9fc 	bl	2d0ae <WsfMsgAlloc>
   24cb6:	60f8      	str	r0, [r7, #12]
   24cb8:	68fb      	ldr	r3, [r7, #12]
   24cba:	2b00      	cmp	r3, #0
   24cbc:	d016      	beq.n	24cec <hciCmdAlloc+0x52>
  {
    /* set HCI command header */
    UINT16_TO_BSTREAM(p, opcode);
   24cbe:	68fb      	ldr	r3, [r7, #12]
   24cc0:	1c5a      	adds	r2, r3, #1
   24cc2:	60fa      	str	r2, [r7, #12]
   24cc4:	88fa      	ldrh	r2, [r7, #6]
   24cc6:	b2d2      	uxtb	r2, r2
   24cc8:	701a      	strb	r2, [r3, #0]
   24cca:	88fb      	ldrh	r3, [r7, #6]
   24ccc:	0a1b      	lsrs	r3, r3, #8
   24cce:	b299      	uxth	r1, r3
   24cd0:	68fb      	ldr	r3, [r7, #12]
   24cd2:	1c5a      	adds	r2, r3, #1
   24cd4:	60fa      	str	r2, [r7, #12]
   24cd6:	b2ca      	uxtb	r2, r1
   24cd8:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, len);
   24cda:	68fb      	ldr	r3, [r7, #12]
   24cdc:	1c5a      	adds	r2, r3, #1
   24cde:	60fa      	str	r2, [r7, #12]
   24ce0:	88ba      	ldrh	r2, [r7, #4]
   24ce2:	b2d2      	uxtb	r2, r2
   24ce4:	701a      	strb	r2, [r3, #0]
    p -= HCI_CMD_HDR_LEN;
   24ce6:	68fb      	ldr	r3, [r7, #12]
   24ce8:	3b03      	subs	r3, #3
   24cea:	60fb      	str	r3, [r7, #12]
  }

  return p;
   24cec:	68fb      	ldr	r3, [r7, #12]
}
   24cee:	4618      	mov	r0, r3
   24cf0:	3710      	adds	r7, #16
   24cf2:	46bd      	mov	sp, r7
   24cf4:	bd80      	pop	{r7, pc}
	...

00024cf8 <hciCmdSend>:
 *
 *  \return TRUE if any new or pending hci command sent successfully.
 */
/*************************************************************************************************/
bool_t hciCmdSend(uint8_t *pData)
{
   24cf8:	b580      	push	{r7, lr}
   24cfa:	b084      	sub	sp, #16
   24cfc:	af00      	add	r7, sp, #0
   24cfe:	6078      	str	r0, [r7, #4]
  uint8_t         *p;
  wsfHandlerId_t  handlerId;

  /* queue command if present */
  if (pData != NULL)
   24d00:	687b      	ldr	r3, [r7, #4]
   24d02:	2b00      	cmp	r3, #0
   24d04:	d004      	beq.n	24d10 <hciCmdSend+0x18>
  {
    /* queue data - message handler ID 'handerId' not used */
    WsfMsgEnq(&hciCmdCb.cmdQueue, 0, pData);
   24d06:	687a      	ldr	r2, [r7, #4]
   24d08:	2100      	movs	r1, #0
   24d0a:	481f      	ldr	r0, [pc, #124]	; (24d88 <hciCmdSend+0x90>)
   24d0c:	f008 fa0b 	bl	2d126 <WsfMsgEnq>
  }

  /* service the HCI command queue; first check if controller can accept any commands */
  if (hciCmdCb.numCmdPkts > 0)
   24d10:	4b1e      	ldr	r3, [pc, #120]	; (24d8c <hciCmdSend+0x94>)
   24d12:	7e9b      	ldrb	r3, [r3, #26]
   24d14:	2b00      	cmp	r3, #0
   24d16:	d031      	beq.n	24d7c <hciCmdSend+0x84>
  {
    /* if queue not empty */
    if ((p = WsfMsgPeek(&hciCmdCb.cmdQueue, &handlerId)) != NULL)
   24d18:	f107 030b 	add.w	r3, r7, #11
   24d1c:	4619      	mov	r1, r3
   24d1e:	481a      	ldr	r0, [pc, #104]	; (24d88 <hciCmdSend+0x90>)
   24d20:	f008 fa2e 	bl	2d180 <WsfMsgPeek>
   24d24:	60f8      	str	r0, [r7, #12]
   24d26:	68fb      	ldr	r3, [r7, #12]
   24d28:	2b00      	cmp	r3, #0
   24d2a:	d027      	beq.n	24d7c <hciCmdSend+0x84>
    {
      /* send command to transport */
      if (hciTrSendCmd(p) == TRUE)
   24d2c:	68f8      	ldr	r0, [r7, #12]
   24d2e:	f004 f9f2 	bl	29116 <hciTrSendCmd>
   24d32:	4603      	mov	r3, r0
   24d34:	2b01      	cmp	r3, #1
   24d36:	d121      	bne.n	24d7c <hciCmdSend+0x84>
      {

        /* remove from the queue*/
        WsfMsgDeq(&hciCmdCb.cmdQueue, &handlerId);
   24d38:	f107 030b 	add.w	r3, r7, #11
   24d3c:	4619      	mov	r1, r3
   24d3e:	4812      	ldr	r0, [pc, #72]	; (24d88 <hciCmdSend+0x90>)
   24d40:	f008 fa06 	bl	2d150 <WsfMsgDeq>

        /* decrement controller command packet count */
        hciCmdCb.numCmdPkts--;
   24d44:	4b11      	ldr	r3, [pc, #68]	; (24d8c <hciCmdSend+0x94>)
   24d46:	7e9b      	ldrb	r3, [r3, #26]
   24d48:	3b01      	subs	r3, #1
   24d4a:	b2da      	uxtb	r2, r3
   24d4c:	4b0f      	ldr	r3, [pc, #60]	; (24d8c <hciCmdSend+0x94>)
   24d4e:	769a      	strb	r2, [r3, #26]

        /* store opcode of command we're sending */
        BYTES_TO_UINT16(hciCmdCb.cmdOpcode, p);
   24d50:	68fb      	ldr	r3, [r7, #12]
   24d52:	781b      	ldrb	r3, [r3, #0]
   24d54:	b29a      	uxth	r2, r3
   24d56:	68fb      	ldr	r3, [r7, #12]
   24d58:	3301      	adds	r3, #1
   24d5a:	781b      	ldrb	r3, [r3, #0]
   24d5c:	b29b      	uxth	r3, r3
   24d5e:	021b      	lsls	r3, r3, #8
   24d60:	b29b      	uxth	r3, r3
   24d62:	4413      	add	r3, r2
   24d64:	b29a      	uxth	r2, r3
   24d66:	4b09      	ldr	r3, [pc, #36]	; (24d8c <hciCmdSend+0x94>)
   24d68:	831a      	strh	r2, [r3, #24]

        /* Free buffer here after dequeue */
        WsfMsgFree(p);
   24d6a:	68f8      	ldr	r0, [r7, #12]
   24d6c:	f008 f9b6 	bl	2d0dc <WsfMsgFree>

        /* start command timeout */
        WsfTimerStartSec(&hciCmdCb.cmdTimer, HCI_CMD_TIMEOUT);
   24d70:	210a      	movs	r1, #10
   24d72:	4806      	ldr	r0, [pc, #24]	; (24d8c <hciCmdSend+0x94>)
   24d74:	f008 fd3a 	bl	2d7ec <WsfTimerStartSec>
        return TRUE;
   24d78:	2301      	movs	r3, #1
   24d7a:	e000      	b.n	24d7e <hciCmdSend+0x86>
      }
    }
  }
  return FALSE;
   24d7c:	2300      	movs	r3, #0
}
   24d7e:	4618      	mov	r0, r3
   24d80:	3710      	adds	r7, #16
   24d82:	46bd      	mov	sp, r7
   24d84:	bd80      	pop	{r7, pc}
   24d86:	bf00      	nop
   24d88:	10011340 	.word	0x10011340
   24d8c:	10011330 	.word	0x10011330

00024d90 <hciCmdInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCmdInit(void)
{
   24d90:	b480      	push	{r7}
   24d92:	af00      	add	r7, sp, #0
  WSF_QUEUE_INIT(&hciCmdCb.cmdQueue);
   24d94:	4b0a      	ldr	r3, [pc, #40]	; (24dc0 <hciCmdInit+0x30>)
   24d96:	2200      	movs	r2, #0
   24d98:	611a      	str	r2, [r3, #16]
   24d9a:	4b09      	ldr	r3, [pc, #36]	; (24dc0 <hciCmdInit+0x30>)
   24d9c:	2200      	movs	r2, #0
   24d9e:	615a      	str	r2, [r3, #20]

  /* initialize numCmdPkts for special case of first command */
  hciCmdCb.numCmdPkts = 1;
   24da0:	4b07      	ldr	r3, [pc, #28]	; (24dc0 <hciCmdInit+0x30>)
   24da2:	2201      	movs	r2, #1
   24da4:	769a      	strb	r2, [r3, #26]

  /* initialize timer */
  hciCmdCb.cmdTimer.msg.event = HCI_MSG_CMD_TIMEOUT;
   24da6:	4b06      	ldr	r3, [pc, #24]	; (24dc0 <hciCmdInit+0x30>)
   24da8:	2201      	movs	r2, #1
   24daa:	729a      	strb	r2, [r3, #10]
  hciCmdCb.cmdTimer.handlerId = hciCb.handlerId;
   24dac:	4b05      	ldr	r3, [pc, #20]	; (24dc4 <hciCmdInit+0x34>)
   24dae:	7e1a      	ldrb	r2, [r3, #24]
   24db0:	4b03      	ldr	r3, [pc, #12]	; (24dc0 <hciCmdInit+0x30>)
   24db2:	731a      	strb	r2, [r3, #12]
}
   24db4:	bf00      	nop
   24db6:	46bd      	mov	sp, r7
   24db8:	f85d 7b04 	ldr.w	r7, [sp], #4
   24dbc:	4770      	bx	lr
   24dbe:	bf00      	nop
   24dc0:	10011330 	.word	0x10011330
   24dc4:	100116ec 	.word	0x100116ec

00024dc8 <hciCmdTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCmdTimeout(wsfMsgHdr_t *pMsg)
{
   24dc8:	b580      	push	{r7, lr}
   24dca:	b082      	sub	sp, #8
   24dcc:	af00      	add	r7, sp, #0
   24dce:	6078      	str	r0, [r7, #4]
  HCI_TRACE_INFO1("hciCmdTimeout, opcode=0x%x", hciCmdCb.cmdOpcode);
  // When it times out, pretty much we have to
  // reset/reboot controller and initialize HCI
  // layer and SPI transport layer again.

  HciDrvRadioShutdown();
   24dd0:	f001 fe38 	bl	26a44 <HciDrvRadioShutdown>
  HciDrvRadioBoot(0);
   24dd4:	2000      	movs	r0, #0
   24dd6:	f001 fdc7 	bl	26968 <HciDrvRadioBoot>
  DmDevReset();
   24dda:	f7fe ff6f 	bl	23cbc <DmDevReset>
}
   24dde:	bf00      	nop
   24de0:	3708      	adds	r7, #8
   24de2:	46bd      	mov	sp, r7
   24de4:	bd80      	pop	{r7, pc}
	...

00024de8 <hciCmdRecvCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCmdRecvCmpl(uint8_t numCmdPkts)
{
   24de8:	b580      	push	{r7, lr}
   24dea:	b082      	sub	sp, #8
   24dec:	af00      	add	r7, sp, #0
   24dee:	4603      	mov	r3, r0
   24df0:	71fb      	strb	r3, [r7, #7]
  /* stop the command timeout timer */
  WsfTimerStop(&hciCmdCb.cmdTimer);
   24df2:	4806      	ldr	r0, [pc, #24]	; (24e0c <hciCmdRecvCmpl+0x24>)
   24df4:	f008 fd20 	bl	2d838 <WsfTimerStop>
  /*
   * Set the number of commands that can be sent to the controller.  Setting this
   * to 1 rather than incrementing by numCmdPkts allows only one command at a time to
   * be sent to the controller and simplifies the code.
   */
  hciCmdCb.numCmdPkts = 1;
   24df8:	4b04      	ldr	r3, [pc, #16]	; (24e0c <hciCmdRecvCmpl+0x24>)
   24dfa:	2201      	movs	r2, #1
   24dfc:	769a      	strb	r2, [r3, #26]

  /* send the next queued command */
  hciCmdSend(NULL);
   24dfe:	2000      	movs	r0, #0
   24e00:	f7ff ff7a 	bl	24cf8 <hciCmdSend>
}
   24e04:	bf00      	nop
   24e06:	3708      	adds	r7, #8
   24e08:	46bd      	mov	sp, r7
   24e0a:	bd80      	pop	{r7, pc}
   24e0c:	10011330 	.word	0x10011330

00024e10 <HciDisconnectCmd>:
 *
 *  \brief  HCI disconnect command.
 */
/*************************************************************************************************/
void HciDisconnectCmd(uint16_t handle, uint8_t reason)
{
   24e10:	b580      	push	{r7, lr}
   24e12:	b084      	sub	sp, #16
   24e14:	af00      	add	r7, sp, #0
   24e16:	4603      	mov	r3, r0
   24e18:	460a      	mov	r2, r1
   24e1a:	80fb      	strh	r3, [r7, #6]
   24e1c:	4613      	mov	r3, r2
   24e1e:	717b      	strb	r3, [r7, #5]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_DISCONNECT, HCI_LEN_DISCONNECT)) != NULL)
   24e20:	2103      	movs	r1, #3
   24e22:	f240 4006 	movw	r0, #1030	; 0x406
   24e26:	f7ff ff38 	bl	24c9a <hciCmdAlloc>
   24e2a:	60f8      	str	r0, [r7, #12]
   24e2c:	68fb      	ldr	r3, [r7, #12]
   24e2e:	2b00      	cmp	r3, #0
   24e30:	d018      	beq.n	24e64 <HciDisconnectCmd+0x54>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   24e32:	68fb      	ldr	r3, [r7, #12]
   24e34:	3303      	adds	r3, #3
   24e36:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   24e38:	68bb      	ldr	r3, [r7, #8]
   24e3a:	1c5a      	adds	r2, r3, #1
   24e3c:	60ba      	str	r2, [r7, #8]
   24e3e:	88fa      	ldrh	r2, [r7, #6]
   24e40:	b2d2      	uxtb	r2, r2
   24e42:	701a      	strb	r2, [r3, #0]
   24e44:	88fb      	ldrh	r3, [r7, #6]
   24e46:	0a1b      	lsrs	r3, r3, #8
   24e48:	b299      	uxth	r1, r3
   24e4a:	68bb      	ldr	r3, [r7, #8]
   24e4c:	1c5a      	adds	r2, r3, #1
   24e4e:	60ba      	str	r2, [r7, #8]
   24e50:	b2ca      	uxtb	r2, r1
   24e52:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, reason);
   24e54:	68bb      	ldr	r3, [r7, #8]
   24e56:	1c5a      	adds	r2, r3, #1
   24e58:	60ba      	str	r2, [r7, #8]
   24e5a:	797a      	ldrb	r2, [r7, #5]
   24e5c:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   24e5e:	68f8      	ldr	r0, [r7, #12]
   24e60:	f7ff ff4a 	bl	24cf8 <hciCmdSend>
  }
}
   24e64:	bf00      	nop
   24e66:	3710      	adds	r7, #16
   24e68:	46bd      	mov	sp, r7
   24e6a:	bd80      	pop	{r7, pc}

00024e6c <HciLeConnUpdateCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeConnUpdateCmd(uint16_t handle, hciConnSpec_t *pConnSpec)
{
   24e6c:	b580      	push	{r7, lr}
   24e6e:	b084      	sub	sp, #16
   24e70:	af00      	add	r7, sp, #0
   24e72:	4603      	mov	r3, r0
   24e74:	6039      	str	r1, [r7, #0]
   24e76:	80fb      	strh	r3, [r7, #6]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_CONN_UPDATE, HCI_LEN_LE_CONN_UPDATE)) != NULL)
   24e78:	210e      	movs	r1, #14
   24e7a:	f242 0013 	movw	r0, #8211	; 0x2013
   24e7e:	f7ff ff0c 	bl	24c9a <hciCmdAlloc>
   24e82:	60f8      	str	r0, [r7, #12]
   24e84:	68fb      	ldr	r3, [r7, #12]
   24e86:	2b00      	cmp	r3, #0
   24e88:	d073      	beq.n	24f72 <HciLeConnUpdateCmd+0x106>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   24e8a:	68fb      	ldr	r3, [r7, #12]
   24e8c:	3303      	adds	r3, #3
   24e8e:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   24e90:	68bb      	ldr	r3, [r7, #8]
   24e92:	1c5a      	adds	r2, r3, #1
   24e94:	60ba      	str	r2, [r7, #8]
   24e96:	88fa      	ldrh	r2, [r7, #6]
   24e98:	b2d2      	uxtb	r2, r2
   24e9a:	701a      	strb	r2, [r3, #0]
   24e9c:	88fb      	ldrh	r3, [r7, #6]
   24e9e:	0a1b      	lsrs	r3, r3, #8
   24ea0:	b299      	uxth	r1, r3
   24ea2:	68bb      	ldr	r3, [r7, #8]
   24ea4:	1c5a      	adds	r2, r3, #1
   24ea6:	60ba      	str	r2, [r7, #8]
   24ea8:	b2ca      	uxtb	r2, r1
   24eaa:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMin);
   24eac:	683b      	ldr	r3, [r7, #0]
   24eae:	8819      	ldrh	r1, [r3, #0]
   24eb0:	68bb      	ldr	r3, [r7, #8]
   24eb2:	1c5a      	adds	r2, r3, #1
   24eb4:	60ba      	str	r2, [r7, #8]
   24eb6:	b2ca      	uxtb	r2, r1
   24eb8:	701a      	strb	r2, [r3, #0]
   24eba:	683b      	ldr	r3, [r7, #0]
   24ebc:	881b      	ldrh	r3, [r3, #0]
   24ebe:	0a1b      	lsrs	r3, r3, #8
   24ec0:	b299      	uxth	r1, r3
   24ec2:	68bb      	ldr	r3, [r7, #8]
   24ec4:	1c5a      	adds	r2, r3, #1
   24ec6:	60ba      	str	r2, [r7, #8]
   24ec8:	b2ca      	uxtb	r2, r1
   24eca:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMax);
   24ecc:	683b      	ldr	r3, [r7, #0]
   24ece:	8859      	ldrh	r1, [r3, #2]
   24ed0:	68bb      	ldr	r3, [r7, #8]
   24ed2:	1c5a      	adds	r2, r3, #1
   24ed4:	60ba      	str	r2, [r7, #8]
   24ed6:	b2ca      	uxtb	r2, r1
   24ed8:	701a      	strb	r2, [r3, #0]
   24eda:	683b      	ldr	r3, [r7, #0]
   24edc:	885b      	ldrh	r3, [r3, #2]
   24ede:	0a1b      	lsrs	r3, r3, #8
   24ee0:	b299      	uxth	r1, r3
   24ee2:	68bb      	ldr	r3, [r7, #8]
   24ee4:	1c5a      	adds	r2, r3, #1
   24ee6:	60ba      	str	r2, [r7, #8]
   24ee8:	b2ca      	uxtb	r2, r1
   24eea:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connLatency);
   24eec:	683b      	ldr	r3, [r7, #0]
   24eee:	8899      	ldrh	r1, [r3, #4]
   24ef0:	68bb      	ldr	r3, [r7, #8]
   24ef2:	1c5a      	adds	r2, r3, #1
   24ef4:	60ba      	str	r2, [r7, #8]
   24ef6:	b2ca      	uxtb	r2, r1
   24ef8:	701a      	strb	r2, [r3, #0]
   24efa:	683b      	ldr	r3, [r7, #0]
   24efc:	889b      	ldrh	r3, [r3, #4]
   24efe:	0a1b      	lsrs	r3, r3, #8
   24f00:	b299      	uxth	r1, r3
   24f02:	68bb      	ldr	r3, [r7, #8]
   24f04:	1c5a      	adds	r2, r3, #1
   24f06:	60ba      	str	r2, [r7, #8]
   24f08:	b2ca      	uxtb	r2, r1
   24f0a:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->supTimeout);
   24f0c:	683b      	ldr	r3, [r7, #0]
   24f0e:	88d9      	ldrh	r1, [r3, #6]
   24f10:	68bb      	ldr	r3, [r7, #8]
   24f12:	1c5a      	adds	r2, r3, #1
   24f14:	60ba      	str	r2, [r7, #8]
   24f16:	b2ca      	uxtb	r2, r1
   24f18:	701a      	strb	r2, [r3, #0]
   24f1a:	683b      	ldr	r3, [r7, #0]
   24f1c:	88db      	ldrh	r3, [r3, #6]
   24f1e:	0a1b      	lsrs	r3, r3, #8
   24f20:	b299      	uxth	r1, r3
   24f22:	68bb      	ldr	r3, [r7, #8]
   24f24:	1c5a      	adds	r2, r3, #1
   24f26:	60ba      	str	r2, [r7, #8]
   24f28:	b2ca      	uxtb	r2, r1
   24f2a:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->minCeLen);
   24f2c:	683b      	ldr	r3, [r7, #0]
   24f2e:	8919      	ldrh	r1, [r3, #8]
   24f30:	68bb      	ldr	r3, [r7, #8]
   24f32:	1c5a      	adds	r2, r3, #1
   24f34:	60ba      	str	r2, [r7, #8]
   24f36:	b2ca      	uxtb	r2, r1
   24f38:	701a      	strb	r2, [r3, #0]
   24f3a:	683b      	ldr	r3, [r7, #0]
   24f3c:	891b      	ldrh	r3, [r3, #8]
   24f3e:	0a1b      	lsrs	r3, r3, #8
   24f40:	b299      	uxth	r1, r3
   24f42:	68bb      	ldr	r3, [r7, #8]
   24f44:	1c5a      	adds	r2, r3, #1
   24f46:	60ba      	str	r2, [r7, #8]
   24f48:	b2ca      	uxtb	r2, r1
   24f4a:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->maxCeLen);
   24f4c:	683b      	ldr	r3, [r7, #0]
   24f4e:	8959      	ldrh	r1, [r3, #10]
   24f50:	68bb      	ldr	r3, [r7, #8]
   24f52:	1c5a      	adds	r2, r3, #1
   24f54:	60ba      	str	r2, [r7, #8]
   24f56:	b2ca      	uxtb	r2, r1
   24f58:	701a      	strb	r2, [r3, #0]
   24f5a:	683b      	ldr	r3, [r7, #0]
   24f5c:	895b      	ldrh	r3, [r3, #10]
   24f5e:	0a1b      	lsrs	r3, r3, #8
   24f60:	b299      	uxth	r1, r3
   24f62:	68bb      	ldr	r3, [r7, #8]
   24f64:	1c5a      	adds	r2, r3, #1
   24f66:	60ba      	str	r2, [r7, #8]
   24f68:	b2ca      	uxtb	r2, r1
   24f6a:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   24f6c:	68f8      	ldr	r0, [r7, #12]
   24f6e:	f7ff fec3 	bl	24cf8 <hciCmdSend>
  }
}
   24f72:	bf00      	nop
   24f74:	3710      	adds	r7, #16
   24f76:	46bd      	mov	sp, r7
   24f78:	bd80      	pop	{r7, pc}

00024f7a <HciLeCreateConnCmd>:
 */
/*************************************************************************************************/
void HciLeCreateConnCmd(uint16_t scanInterval, uint16_t scanWindow, uint8_t filterPolicy,
                        uint8_t peerAddrType, uint8_t *pPeerAddr, uint8_t ownAddrType,
                        hciConnSpec_t *pConnSpec)
{
   24f7a:	b590      	push	{r4, r7, lr}
   24f7c:	b085      	sub	sp, #20
   24f7e:	af00      	add	r7, sp, #0
   24f80:	4604      	mov	r4, r0
   24f82:	4608      	mov	r0, r1
   24f84:	4611      	mov	r1, r2
   24f86:	461a      	mov	r2, r3
   24f88:	4623      	mov	r3, r4
   24f8a:	80fb      	strh	r3, [r7, #6]
   24f8c:	4603      	mov	r3, r0
   24f8e:	80bb      	strh	r3, [r7, #4]
   24f90:	460b      	mov	r3, r1
   24f92:	70fb      	strb	r3, [r7, #3]
   24f94:	4613      	mov	r3, r2
   24f96:	70bb      	strb	r3, [r7, #2]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_CREATE_CONN, HCI_LEN_LE_CREATE_CONN)) != NULL)
   24f98:	2119      	movs	r1, #25
   24f9a:	f242 000d 	movw	r0, #8205	; 0x200d
   24f9e:	f7ff fe7c 	bl	24c9a <hciCmdAlloc>
   24fa2:	60f8      	str	r0, [r7, #12]
   24fa4:	68fb      	ldr	r3, [r7, #12]
   24fa6:	2b00      	cmp	r3, #0
   24fa8:	f000 8099 	beq.w	250de <HciLeCreateConnCmd+0x164>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   24fac:	68fb      	ldr	r3, [r7, #12]
   24fae:	3303      	adds	r3, #3
   24fb0:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, scanInterval);
   24fb2:	68bb      	ldr	r3, [r7, #8]
   24fb4:	1c5a      	adds	r2, r3, #1
   24fb6:	60ba      	str	r2, [r7, #8]
   24fb8:	88fa      	ldrh	r2, [r7, #6]
   24fba:	b2d2      	uxtb	r2, r2
   24fbc:	701a      	strb	r2, [r3, #0]
   24fbe:	88fb      	ldrh	r3, [r7, #6]
   24fc0:	0a1b      	lsrs	r3, r3, #8
   24fc2:	b299      	uxth	r1, r3
   24fc4:	68bb      	ldr	r3, [r7, #8]
   24fc6:	1c5a      	adds	r2, r3, #1
   24fc8:	60ba      	str	r2, [r7, #8]
   24fca:	b2ca      	uxtb	r2, r1
   24fcc:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, scanWindow);
   24fce:	68bb      	ldr	r3, [r7, #8]
   24fd0:	1c5a      	adds	r2, r3, #1
   24fd2:	60ba      	str	r2, [r7, #8]
   24fd4:	88ba      	ldrh	r2, [r7, #4]
   24fd6:	b2d2      	uxtb	r2, r2
   24fd8:	701a      	strb	r2, [r3, #0]
   24fda:	88bb      	ldrh	r3, [r7, #4]
   24fdc:	0a1b      	lsrs	r3, r3, #8
   24fde:	b299      	uxth	r1, r3
   24fe0:	68bb      	ldr	r3, [r7, #8]
   24fe2:	1c5a      	adds	r2, r3, #1
   24fe4:	60ba      	str	r2, [r7, #8]
   24fe6:	b2ca      	uxtb	r2, r1
   24fe8:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, filterPolicy);
   24fea:	68bb      	ldr	r3, [r7, #8]
   24fec:	1c5a      	adds	r2, r3, #1
   24fee:	60ba      	str	r2, [r7, #8]
   24ff0:	78fa      	ldrb	r2, [r7, #3]
   24ff2:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, peerAddrType);
   24ff4:	68bb      	ldr	r3, [r7, #8]
   24ff6:	1c5a      	adds	r2, r3, #1
   24ff8:	60ba      	str	r2, [r7, #8]
   24ffa:	78ba      	ldrb	r2, [r7, #2]
   24ffc:	701a      	strb	r2, [r3, #0]
    BDA_TO_BSTREAM(p, pPeerAddr);
   24ffe:	6a39      	ldr	r1, [r7, #32]
   25000:	68b8      	ldr	r0, [r7, #8]
   25002:	f7fc fdc0 	bl	21b86 <BdaCpy>
   25006:	68bb      	ldr	r3, [r7, #8]
   25008:	3306      	adds	r3, #6
   2500a:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, ownAddrType);
   2500c:	68bb      	ldr	r3, [r7, #8]
   2500e:	1c5a      	adds	r2, r3, #1
   25010:	60ba      	str	r2, [r7, #8]
   25012:	f897 2024 	ldrb.w	r2, [r7, #36]	; 0x24
   25016:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMin);
   25018:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2501a:	8819      	ldrh	r1, [r3, #0]
   2501c:	68bb      	ldr	r3, [r7, #8]
   2501e:	1c5a      	adds	r2, r3, #1
   25020:	60ba      	str	r2, [r7, #8]
   25022:	b2ca      	uxtb	r2, r1
   25024:	701a      	strb	r2, [r3, #0]
   25026:	6abb      	ldr	r3, [r7, #40]	; 0x28
   25028:	881b      	ldrh	r3, [r3, #0]
   2502a:	0a1b      	lsrs	r3, r3, #8
   2502c:	b299      	uxth	r1, r3
   2502e:	68bb      	ldr	r3, [r7, #8]
   25030:	1c5a      	adds	r2, r3, #1
   25032:	60ba      	str	r2, [r7, #8]
   25034:	b2ca      	uxtb	r2, r1
   25036:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMax);
   25038:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2503a:	8859      	ldrh	r1, [r3, #2]
   2503c:	68bb      	ldr	r3, [r7, #8]
   2503e:	1c5a      	adds	r2, r3, #1
   25040:	60ba      	str	r2, [r7, #8]
   25042:	b2ca      	uxtb	r2, r1
   25044:	701a      	strb	r2, [r3, #0]
   25046:	6abb      	ldr	r3, [r7, #40]	; 0x28
   25048:	885b      	ldrh	r3, [r3, #2]
   2504a:	0a1b      	lsrs	r3, r3, #8
   2504c:	b299      	uxth	r1, r3
   2504e:	68bb      	ldr	r3, [r7, #8]
   25050:	1c5a      	adds	r2, r3, #1
   25052:	60ba      	str	r2, [r7, #8]
   25054:	b2ca      	uxtb	r2, r1
   25056:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connLatency);
   25058:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2505a:	8899      	ldrh	r1, [r3, #4]
   2505c:	68bb      	ldr	r3, [r7, #8]
   2505e:	1c5a      	adds	r2, r3, #1
   25060:	60ba      	str	r2, [r7, #8]
   25062:	b2ca      	uxtb	r2, r1
   25064:	701a      	strb	r2, [r3, #0]
   25066:	6abb      	ldr	r3, [r7, #40]	; 0x28
   25068:	889b      	ldrh	r3, [r3, #4]
   2506a:	0a1b      	lsrs	r3, r3, #8
   2506c:	b299      	uxth	r1, r3
   2506e:	68bb      	ldr	r3, [r7, #8]
   25070:	1c5a      	adds	r2, r3, #1
   25072:	60ba      	str	r2, [r7, #8]
   25074:	b2ca      	uxtb	r2, r1
   25076:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->supTimeout);
   25078:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2507a:	88d9      	ldrh	r1, [r3, #6]
   2507c:	68bb      	ldr	r3, [r7, #8]
   2507e:	1c5a      	adds	r2, r3, #1
   25080:	60ba      	str	r2, [r7, #8]
   25082:	b2ca      	uxtb	r2, r1
   25084:	701a      	strb	r2, [r3, #0]
   25086:	6abb      	ldr	r3, [r7, #40]	; 0x28
   25088:	88db      	ldrh	r3, [r3, #6]
   2508a:	0a1b      	lsrs	r3, r3, #8
   2508c:	b299      	uxth	r1, r3
   2508e:	68bb      	ldr	r3, [r7, #8]
   25090:	1c5a      	adds	r2, r3, #1
   25092:	60ba      	str	r2, [r7, #8]
   25094:	b2ca      	uxtb	r2, r1
   25096:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->minCeLen);
   25098:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2509a:	8919      	ldrh	r1, [r3, #8]
   2509c:	68bb      	ldr	r3, [r7, #8]
   2509e:	1c5a      	adds	r2, r3, #1
   250a0:	60ba      	str	r2, [r7, #8]
   250a2:	b2ca      	uxtb	r2, r1
   250a4:	701a      	strb	r2, [r3, #0]
   250a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   250a8:	891b      	ldrh	r3, [r3, #8]
   250aa:	0a1b      	lsrs	r3, r3, #8
   250ac:	b299      	uxth	r1, r3
   250ae:	68bb      	ldr	r3, [r7, #8]
   250b0:	1c5a      	adds	r2, r3, #1
   250b2:	60ba      	str	r2, [r7, #8]
   250b4:	b2ca      	uxtb	r2, r1
   250b6:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->maxCeLen);
   250b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   250ba:	8959      	ldrh	r1, [r3, #10]
   250bc:	68bb      	ldr	r3, [r7, #8]
   250be:	1c5a      	adds	r2, r3, #1
   250c0:	60ba      	str	r2, [r7, #8]
   250c2:	b2ca      	uxtb	r2, r1
   250c4:	701a      	strb	r2, [r3, #0]
   250c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   250c8:	895b      	ldrh	r3, [r3, #10]
   250ca:	0a1b      	lsrs	r3, r3, #8
   250cc:	b299      	uxth	r1, r3
   250ce:	68bb      	ldr	r3, [r7, #8]
   250d0:	1c5a      	adds	r2, r3, #1
   250d2:	60ba      	str	r2, [r7, #8]
   250d4:	b2ca      	uxtb	r2, r1
   250d6:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   250d8:	68f8      	ldr	r0, [r7, #12]
   250da:	f7ff fe0d 	bl	24cf8 <hciCmdSend>
  }
}
   250de:	bf00      	nop
   250e0:	3714      	adds	r7, #20
   250e2:	46bd      	mov	sp, r7
   250e4:	bd90      	pop	{r4, r7, pc}

000250e6 <HciLeCreateConnCancelCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeCreateConnCancelCmd(void)
{
   250e6:	b580      	push	{r7, lr}
   250e8:	b082      	sub	sp, #8
   250ea:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_CREATE_CONN_CANCEL, HCI_LEN_LE_CREATE_CONN_CANCEL)) != NULL)
   250ec:	2100      	movs	r1, #0
   250ee:	f242 000e 	movw	r0, #8206	; 0x200e
   250f2:	f7ff fdd2 	bl	24c9a <hciCmdAlloc>
   250f6:	6078      	str	r0, [r7, #4]
   250f8:	687b      	ldr	r3, [r7, #4]
   250fa:	2b00      	cmp	r3, #0
   250fc:	d002      	beq.n	25104 <HciLeCreateConnCancelCmd+0x1e>
  {
    hciCmdSend(pBuf);
   250fe:	6878      	ldr	r0, [r7, #4]
   25100:	f7ff fdfa 	bl	24cf8 <hciCmdSend>
  }
}
   25104:	bf00      	nop
   25106:	3708      	adds	r7, #8
   25108:	46bd      	mov	sp, r7
   2510a:	bd80      	pop	{r7, pc}

0002510c <HciLeRemoteConnParamReqReply>:
*  \return None.
*/
/*************************************************************************************************/
void HciLeRemoteConnParamReqReply(uint16_t handle, uint16_t intervalMin, uint16_t intervalMax, uint16_t latency,
                                  uint16_t timeout, uint16_t minCeLen, uint16_t maxCeLen)
{
   2510c:	b590      	push	{r4, r7, lr}
   2510e:	b085      	sub	sp, #20
   25110:	af00      	add	r7, sp, #0
   25112:	4604      	mov	r4, r0
   25114:	4608      	mov	r0, r1
   25116:	4611      	mov	r1, r2
   25118:	461a      	mov	r2, r3
   2511a:	4623      	mov	r3, r4
   2511c:	80fb      	strh	r3, [r7, #6]
   2511e:	4603      	mov	r3, r0
   25120:	80bb      	strh	r3, [r7, #4]
   25122:	460b      	mov	r3, r1
   25124:	807b      	strh	r3, [r7, #2]
   25126:	4613      	mov	r3, r2
   25128:	803b      	strh	r3, [r7, #0]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_REM_CONN_PARAM_REP, HCI_LEN_LE_REM_CONN_PARAM_REP)) != NULL)
   2512a:	210e      	movs	r1, #14
   2512c:	f242 0020 	movw	r0, #8224	; 0x2020
   25130:	f7ff fdb3 	bl	24c9a <hciCmdAlloc>
   25134:	60f8      	str	r0, [r7, #12]
   25136:	68fb      	ldr	r3, [r7, #12]
   25138:	2b00      	cmp	r3, #0
   2513a:	d067      	beq.n	2520c <HciLeRemoteConnParamReqReply+0x100>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   2513c:	68fb      	ldr	r3, [r7, #12]
   2513e:	3303      	adds	r3, #3
   25140:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   25142:	68bb      	ldr	r3, [r7, #8]
   25144:	1c5a      	adds	r2, r3, #1
   25146:	60ba      	str	r2, [r7, #8]
   25148:	88fa      	ldrh	r2, [r7, #6]
   2514a:	b2d2      	uxtb	r2, r2
   2514c:	701a      	strb	r2, [r3, #0]
   2514e:	88fb      	ldrh	r3, [r7, #6]
   25150:	0a1b      	lsrs	r3, r3, #8
   25152:	b299      	uxth	r1, r3
   25154:	68bb      	ldr	r3, [r7, #8]
   25156:	1c5a      	adds	r2, r3, #1
   25158:	60ba      	str	r2, [r7, #8]
   2515a:	b2ca      	uxtb	r2, r1
   2515c:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, intervalMin);
   2515e:	68bb      	ldr	r3, [r7, #8]
   25160:	1c5a      	adds	r2, r3, #1
   25162:	60ba      	str	r2, [r7, #8]
   25164:	88ba      	ldrh	r2, [r7, #4]
   25166:	b2d2      	uxtb	r2, r2
   25168:	701a      	strb	r2, [r3, #0]
   2516a:	88bb      	ldrh	r3, [r7, #4]
   2516c:	0a1b      	lsrs	r3, r3, #8
   2516e:	b299      	uxth	r1, r3
   25170:	68bb      	ldr	r3, [r7, #8]
   25172:	1c5a      	adds	r2, r3, #1
   25174:	60ba      	str	r2, [r7, #8]
   25176:	b2ca      	uxtb	r2, r1
   25178:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, intervalMax);
   2517a:	68bb      	ldr	r3, [r7, #8]
   2517c:	1c5a      	adds	r2, r3, #1
   2517e:	60ba      	str	r2, [r7, #8]
   25180:	887a      	ldrh	r2, [r7, #2]
   25182:	b2d2      	uxtb	r2, r2
   25184:	701a      	strb	r2, [r3, #0]
   25186:	887b      	ldrh	r3, [r7, #2]
   25188:	0a1b      	lsrs	r3, r3, #8
   2518a:	b299      	uxth	r1, r3
   2518c:	68bb      	ldr	r3, [r7, #8]
   2518e:	1c5a      	adds	r2, r3, #1
   25190:	60ba      	str	r2, [r7, #8]
   25192:	b2ca      	uxtb	r2, r1
   25194:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, latency);
   25196:	68bb      	ldr	r3, [r7, #8]
   25198:	1c5a      	adds	r2, r3, #1
   2519a:	60ba      	str	r2, [r7, #8]
   2519c:	883a      	ldrh	r2, [r7, #0]
   2519e:	b2d2      	uxtb	r2, r2
   251a0:	701a      	strb	r2, [r3, #0]
   251a2:	883b      	ldrh	r3, [r7, #0]
   251a4:	0a1b      	lsrs	r3, r3, #8
   251a6:	b299      	uxth	r1, r3
   251a8:	68bb      	ldr	r3, [r7, #8]
   251aa:	1c5a      	adds	r2, r3, #1
   251ac:	60ba      	str	r2, [r7, #8]
   251ae:	b2ca      	uxtb	r2, r1
   251b0:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, timeout);
   251b2:	68bb      	ldr	r3, [r7, #8]
   251b4:	1c5a      	adds	r2, r3, #1
   251b6:	60ba      	str	r2, [r7, #8]
   251b8:	8c3a      	ldrh	r2, [r7, #32]
   251ba:	b2d2      	uxtb	r2, r2
   251bc:	701a      	strb	r2, [r3, #0]
   251be:	8c3b      	ldrh	r3, [r7, #32]
   251c0:	0a1b      	lsrs	r3, r3, #8
   251c2:	b299      	uxth	r1, r3
   251c4:	68bb      	ldr	r3, [r7, #8]
   251c6:	1c5a      	adds	r2, r3, #1
   251c8:	60ba      	str	r2, [r7, #8]
   251ca:	b2ca      	uxtb	r2, r1
   251cc:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, minCeLen);
   251ce:	68bb      	ldr	r3, [r7, #8]
   251d0:	1c5a      	adds	r2, r3, #1
   251d2:	60ba      	str	r2, [r7, #8]
   251d4:	8cba      	ldrh	r2, [r7, #36]	; 0x24
   251d6:	b2d2      	uxtb	r2, r2
   251d8:	701a      	strb	r2, [r3, #0]
   251da:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
   251dc:	0a1b      	lsrs	r3, r3, #8
   251de:	b299      	uxth	r1, r3
   251e0:	68bb      	ldr	r3, [r7, #8]
   251e2:	1c5a      	adds	r2, r3, #1
   251e4:	60ba      	str	r2, [r7, #8]
   251e6:	b2ca      	uxtb	r2, r1
   251e8:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, maxCeLen);
   251ea:	68bb      	ldr	r3, [r7, #8]
   251ec:	1c5a      	adds	r2, r3, #1
   251ee:	60ba      	str	r2, [r7, #8]
   251f0:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   251f2:	b2d2      	uxtb	r2, r2
   251f4:	701a      	strb	r2, [r3, #0]
   251f6:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
   251f8:	0a1b      	lsrs	r3, r3, #8
   251fa:	b299      	uxth	r1, r3
   251fc:	68bb      	ldr	r3, [r7, #8]
   251fe:	1c5a      	adds	r2, r3, #1
   25200:	60ba      	str	r2, [r7, #8]
   25202:	b2ca      	uxtb	r2, r1
   25204:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25206:	68f8      	ldr	r0, [r7, #12]
   25208:	f7ff fd76 	bl	24cf8 <hciCmdSend>
  }
}
   2520c:	bf00      	nop
   2520e:	3714      	adds	r7, #20
   25210:	46bd      	mov	sp, r7
   25212:	bd90      	pop	{r4, r7, pc}

00025214 <HciLeRemoteConnParamReqNegReply>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciLeRemoteConnParamReqNegReply(uint16_t handle, uint8_t reason)
{
   25214:	b580      	push	{r7, lr}
   25216:	b084      	sub	sp, #16
   25218:	af00      	add	r7, sp, #0
   2521a:	4603      	mov	r3, r0
   2521c:	460a      	mov	r2, r1
   2521e:	80fb      	strh	r3, [r7, #6]
   25220:	4613      	mov	r3, r2
   25222:	717b      	strb	r3, [r7, #5]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_REM_CONN_PARAM_NEG_REP, HCI_LEN_LE_REM_CONN_PARAM_NEG_REP)) != NULL)
   25224:	2103      	movs	r1, #3
   25226:	f242 0021 	movw	r0, #8225	; 0x2021
   2522a:	f7ff fd36 	bl	24c9a <hciCmdAlloc>
   2522e:	60f8      	str	r0, [r7, #12]
   25230:	68fb      	ldr	r3, [r7, #12]
   25232:	2b00      	cmp	r3, #0
   25234:	d018      	beq.n	25268 <HciLeRemoteConnParamReqNegReply+0x54>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25236:	68fb      	ldr	r3, [r7, #12]
   25238:	3303      	adds	r3, #3
   2523a:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   2523c:	68bb      	ldr	r3, [r7, #8]
   2523e:	1c5a      	adds	r2, r3, #1
   25240:	60ba      	str	r2, [r7, #8]
   25242:	88fa      	ldrh	r2, [r7, #6]
   25244:	b2d2      	uxtb	r2, r2
   25246:	701a      	strb	r2, [r3, #0]
   25248:	88fb      	ldrh	r3, [r7, #6]
   2524a:	0a1b      	lsrs	r3, r3, #8
   2524c:	b299      	uxth	r1, r3
   2524e:	68bb      	ldr	r3, [r7, #8]
   25250:	1c5a      	adds	r2, r3, #1
   25252:	60ba      	str	r2, [r7, #8]
   25254:	b2ca      	uxtb	r2, r1
   25256:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, reason);
   25258:	68bb      	ldr	r3, [r7, #8]
   2525a:	1c5a      	adds	r2, r3, #1
   2525c:	60ba      	str	r2, [r7, #8]
   2525e:	797a      	ldrb	r2, [r7, #5]
   25260:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25262:	68f8      	ldr	r0, [r7, #12]
   25264:	f7ff fd48 	bl	24cf8 <hciCmdSend>
  }
}
   25268:	bf00      	nop
   2526a:	3710      	adds	r7, #16
   2526c:	46bd      	mov	sp, r7
   2526e:	bd80      	pop	{r7, pc}

00025270 <HciLeSetDataLen>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciLeSetDataLen(uint16_t handle, uint16_t txOctets, uint16_t txTime)
{
   25270:	b580      	push	{r7, lr}
   25272:	b084      	sub	sp, #16
   25274:	af00      	add	r7, sp, #0
   25276:	4603      	mov	r3, r0
   25278:	80fb      	strh	r3, [r7, #6]
   2527a:	460b      	mov	r3, r1
   2527c:	80bb      	strh	r3, [r7, #4]
   2527e:	4613      	mov	r3, r2
   25280:	807b      	strh	r3, [r7, #2]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_DATA_LEN, HCI_LEN_LE_SET_DATA_LEN)) != NULL)
   25282:	2106      	movs	r1, #6
   25284:	f242 0022 	movw	r0, #8226	; 0x2022
   25288:	f7ff fd07 	bl	24c9a <hciCmdAlloc>
   2528c:	60f8      	str	r0, [r7, #12]
   2528e:	68fb      	ldr	r3, [r7, #12]
   25290:	2b00      	cmp	r3, #0
   25292:	d02f      	beq.n	252f4 <HciLeSetDataLen+0x84>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25294:	68fb      	ldr	r3, [r7, #12]
   25296:	3303      	adds	r3, #3
   25298:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   2529a:	68bb      	ldr	r3, [r7, #8]
   2529c:	1c5a      	adds	r2, r3, #1
   2529e:	60ba      	str	r2, [r7, #8]
   252a0:	88fa      	ldrh	r2, [r7, #6]
   252a2:	b2d2      	uxtb	r2, r2
   252a4:	701a      	strb	r2, [r3, #0]
   252a6:	88fb      	ldrh	r3, [r7, #6]
   252a8:	0a1b      	lsrs	r3, r3, #8
   252aa:	b299      	uxth	r1, r3
   252ac:	68bb      	ldr	r3, [r7, #8]
   252ae:	1c5a      	adds	r2, r3, #1
   252b0:	60ba      	str	r2, [r7, #8]
   252b2:	b2ca      	uxtb	r2, r1
   252b4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, txOctets);
   252b6:	68bb      	ldr	r3, [r7, #8]
   252b8:	1c5a      	adds	r2, r3, #1
   252ba:	60ba      	str	r2, [r7, #8]
   252bc:	88ba      	ldrh	r2, [r7, #4]
   252be:	b2d2      	uxtb	r2, r2
   252c0:	701a      	strb	r2, [r3, #0]
   252c2:	88bb      	ldrh	r3, [r7, #4]
   252c4:	0a1b      	lsrs	r3, r3, #8
   252c6:	b299      	uxth	r1, r3
   252c8:	68bb      	ldr	r3, [r7, #8]
   252ca:	1c5a      	adds	r2, r3, #1
   252cc:	60ba      	str	r2, [r7, #8]
   252ce:	b2ca      	uxtb	r2, r1
   252d0:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, txTime);
   252d2:	68bb      	ldr	r3, [r7, #8]
   252d4:	1c5a      	adds	r2, r3, #1
   252d6:	60ba      	str	r2, [r7, #8]
   252d8:	887a      	ldrh	r2, [r7, #2]
   252da:	b2d2      	uxtb	r2, r2
   252dc:	701a      	strb	r2, [r3, #0]
   252de:	887b      	ldrh	r3, [r7, #2]
   252e0:	0a1b      	lsrs	r3, r3, #8
   252e2:	b299      	uxth	r1, r3
   252e4:	68bb      	ldr	r3, [r7, #8]
   252e6:	1c5a      	adds	r2, r3, #1
   252e8:	60ba      	str	r2, [r7, #8]
   252ea:	b2ca      	uxtb	r2, r1
   252ec:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   252ee:	68f8      	ldr	r0, [r7, #12]
   252f0:	f7ff fd02 	bl	24cf8 <hciCmdSend>
  }
}
   252f4:	bf00      	nop
   252f6:	3710      	adds	r7, #16
   252f8:	46bd      	mov	sp, r7
   252fa:	bd80      	pop	{r7, pc}

000252fc <HciLeWriteDefDataLen>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciLeWriteDefDataLen(uint16_t suggestedMaxTxOctets, uint16_t suggestedMaxTxTime)
{
   252fc:	b580      	push	{r7, lr}
   252fe:	b084      	sub	sp, #16
   25300:	af00      	add	r7, sp, #0
   25302:	4603      	mov	r3, r0
   25304:	460a      	mov	r2, r1
   25306:	80fb      	strh	r3, [r7, #6]
   25308:	4613      	mov	r3, r2
   2530a:	80bb      	strh	r3, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_WRITE_DEF_DATA_LEN, HCI_LEN_LE_WRITE_DEF_DATA_LEN)) != NULL)
   2530c:	2104      	movs	r1, #4
   2530e:	f242 0024 	movw	r0, #8228	; 0x2024
   25312:	f7ff fcc2 	bl	24c9a <hciCmdAlloc>
   25316:	60f8      	str	r0, [r7, #12]
   25318:	68fb      	ldr	r3, [r7, #12]
   2531a:	2b00      	cmp	r3, #0
   2531c:	d021      	beq.n	25362 <HciLeWriteDefDataLen+0x66>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   2531e:	68fb      	ldr	r3, [r7, #12]
   25320:	3303      	adds	r3, #3
   25322:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, suggestedMaxTxOctets);
   25324:	68bb      	ldr	r3, [r7, #8]
   25326:	1c5a      	adds	r2, r3, #1
   25328:	60ba      	str	r2, [r7, #8]
   2532a:	88fa      	ldrh	r2, [r7, #6]
   2532c:	b2d2      	uxtb	r2, r2
   2532e:	701a      	strb	r2, [r3, #0]
   25330:	88fb      	ldrh	r3, [r7, #6]
   25332:	0a1b      	lsrs	r3, r3, #8
   25334:	b299      	uxth	r1, r3
   25336:	68bb      	ldr	r3, [r7, #8]
   25338:	1c5a      	adds	r2, r3, #1
   2533a:	60ba      	str	r2, [r7, #8]
   2533c:	b2ca      	uxtb	r2, r1
   2533e:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, suggestedMaxTxTime);
   25340:	68bb      	ldr	r3, [r7, #8]
   25342:	1c5a      	adds	r2, r3, #1
   25344:	60ba      	str	r2, [r7, #8]
   25346:	88ba      	ldrh	r2, [r7, #4]
   25348:	b2d2      	uxtb	r2, r2
   2534a:	701a      	strb	r2, [r3, #0]
   2534c:	88bb      	ldrh	r3, [r7, #4]
   2534e:	0a1b      	lsrs	r3, r3, #8
   25350:	b299      	uxth	r1, r3
   25352:	68bb      	ldr	r3, [r7, #8]
   25354:	1c5a      	adds	r2, r3, #1
   25356:	60ba      	str	r2, [r7, #8]
   25358:	b2ca      	uxtb	r2, r1
   2535a:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   2535c:	68f8      	ldr	r0, [r7, #12]
   2535e:	f7ff fccb 	bl	24cf8 <hciCmdSend>
  }
}
   25362:	bf00      	nop
   25364:	3710      	adds	r7, #16
   25366:	46bd      	mov	sp, r7
   25368:	bd80      	pop	{r7, pc}

0002536a <HciLeReadMaxDataLen>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciLeReadMaxDataLen(void)
{
   2536a:	b580      	push	{r7, lr}
   2536c:	b082      	sub	sp, #8
   2536e:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_MAX_DATA_LEN, HCI_LEN_LE_READ_MAX_DATA_LEN)) != NULL)
   25370:	2100      	movs	r1, #0
   25372:	f242 002f 	movw	r0, #8239	; 0x202f
   25376:	f7ff fc90 	bl	24c9a <hciCmdAlloc>
   2537a:	6078      	str	r0, [r7, #4]
   2537c:	687b      	ldr	r3, [r7, #4]
   2537e:	2b00      	cmp	r3, #0
   25380:	d002      	beq.n	25388 <HciLeReadMaxDataLen+0x1e>
  {
    hciCmdSend(pBuf);
   25382:	6878      	ldr	r0, [r7, #4]
   25384:	f7ff fcb8 	bl	24cf8 <hciCmdSend>
  }
}
   25388:	bf00      	nop
   2538a:	3708      	adds	r7, #8
   2538c:	46bd      	mov	sp, r7
   2538e:	bd80      	pop	{r7, pc}

00025390 <HciLeEncryptCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeEncryptCmd(uint8_t *pKey, uint8_t *pData)
{
   25390:	b580      	push	{r7, lr}
   25392:	b084      	sub	sp, #16
   25394:	af00      	add	r7, sp, #0
   25396:	6078      	str	r0, [r7, #4]
   25398:	6039      	str	r1, [r7, #0]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_ENCRYPT, HCI_LEN_LE_ENCRYPT)) != NULL)
   2539a:	2120      	movs	r1, #32
   2539c:	f242 0017 	movw	r0, #8215	; 0x2017
   253a0:	f7ff fc7b 	bl	24c9a <hciCmdAlloc>
   253a4:	60f8      	str	r0, [r7, #12]
   253a6:	68fb      	ldr	r3, [r7, #12]
   253a8:	2b00      	cmp	r3, #0
   253aa:	d012      	beq.n	253d2 <HciLeEncryptCmd+0x42>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   253ac:	68fb      	ldr	r3, [r7, #12]
   253ae:	3303      	adds	r3, #3
   253b0:	60bb      	str	r3, [r7, #8]
    memcpy(p, pKey, HCI_KEY_LEN);
   253b2:	2210      	movs	r2, #16
   253b4:	6879      	ldr	r1, [r7, #4]
   253b6:	68b8      	ldr	r0, [r7, #8]
   253b8:	f7f2 ff4c 	bl	18254 <memcpy>
    p += HCI_KEY_LEN;
   253bc:	68bb      	ldr	r3, [r7, #8]
   253be:	3310      	adds	r3, #16
   253c0:	60bb      	str	r3, [r7, #8]
    memcpy(p, pData, HCI_ENCRYPT_DATA_LEN);
   253c2:	2210      	movs	r2, #16
   253c4:	6839      	ldr	r1, [r7, #0]
   253c6:	68b8      	ldr	r0, [r7, #8]
   253c8:	f7f2 ff44 	bl	18254 <memcpy>
    hciCmdSend(pBuf);
   253cc:	68f8      	ldr	r0, [r7, #12]
   253ce:	f7ff fc93 	bl	24cf8 <hciCmdSend>
  }
}
   253d2:	bf00      	nop
   253d4:	3710      	adds	r7, #16
   253d6:	46bd      	mov	sp, r7
   253d8:	bd80      	pop	{r7, pc}

000253da <HciLeRandCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeRandCmd(void)
{
   253da:	b580      	push	{r7, lr}
   253dc:	b082      	sub	sp, #8
   253de:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_RAND, HCI_LEN_LE_RAND)) != NULL)
   253e0:	2100      	movs	r1, #0
   253e2:	f242 0018 	movw	r0, #8216	; 0x2018
   253e6:	f7ff fc58 	bl	24c9a <hciCmdAlloc>
   253ea:	6078      	str	r0, [r7, #4]
   253ec:	687b      	ldr	r3, [r7, #4]
   253ee:	2b00      	cmp	r3, #0
   253f0:	d002      	beq.n	253f8 <HciLeRandCmd+0x1e>
  {
    hciCmdSend(pBuf);
   253f2:	6878      	ldr	r0, [r7, #4]
   253f4:	f7ff fc80 	bl	24cf8 <hciCmdSend>
  }
}
   253f8:	bf00      	nop
   253fa:	3708      	adds	r7, #8
   253fc:	46bd      	mov	sp, r7
   253fe:	bd80      	pop	{r7, pc}

00025400 <HciLeReadBufSizeCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadBufSizeCmd(void)
{
   25400:	b580      	push	{r7, lr}
   25402:	b082      	sub	sp, #8
   25404:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_BUF_SIZE, HCI_LEN_LE_READ_BUF_SIZE)) != NULL)
   25406:	2100      	movs	r1, #0
   25408:	f242 0002 	movw	r0, #8194	; 0x2002
   2540c:	f7ff fc45 	bl	24c9a <hciCmdAlloc>
   25410:	6078      	str	r0, [r7, #4]
   25412:	687b      	ldr	r3, [r7, #4]
   25414:	2b00      	cmp	r3, #0
   25416:	d002      	beq.n	2541e <HciLeReadBufSizeCmd+0x1e>
  {
    hciCmdSend(pBuf);
   25418:	6878      	ldr	r0, [r7, #4]
   2541a:	f7ff fc6d 	bl	24cf8 <hciCmdSend>
  }
}
   2541e:	bf00      	nop
   25420:	3708      	adds	r7, #8
   25422:	46bd      	mov	sp, r7
   25424:	bd80      	pop	{r7, pc}

00025426 <HciLeReadLocalSupFeatCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadLocalSupFeatCmd(void)
{
   25426:	b580      	push	{r7, lr}
   25428:	b082      	sub	sp, #8
   2542a:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_LOCAL_SUP_FEAT, HCI_LEN_LE_READ_LOCAL_SUP_FEAT)) != NULL)
   2542c:	2100      	movs	r1, #0
   2542e:	f242 0003 	movw	r0, #8195	; 0x2003
   25432:	f7ff fc32 	bl	24c9a <hciCmdAlloc>
   25436:	6078      	str	r0, [r7, #4]
   25438:	687b      	ldr	r3, [r7, #4]
   2543a:	2b00      	cmp	r3, #0
   2543c:	d002      	beq.n	25444 <HciLeReadLocalSupFeatCmd+0x1e>
  {
    hciCmdSend(pBuf);
   2543e:	6878      	ldr	r0, [r7, #4]
   25440:	f7ff fc5a 	bl	24cf8 <hciCmdSend>
  }
}
   25444:	bf00      	nop
   25446:	3708      	adds	r7, #8
   25448:	46bd      	mov	sp, r7
   2544a:	bd80      	pop	{r7, pc}

0002544c <HciLeReadRemoteFeatCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadRemoteFeatCmd(uint16_t handle)
{
   2544c:	b580      	push	{r7, lr}
   2544e:	b084      	sub	sp, #16
   25450:	af00      	add	r7, sp, #0
   25452:	4603      	mov	r3, r0
   25454:	80fb      	strh	r3, [r7, #6]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_REMOTE_FEAT, HCI_LEN_LE_READ_REMOTE_FEAT)) != NULL)
   25456:	2102      	movs	r1, #2
   25458:	f242 0016 	movw	r0, #8214	; 0x2016
   2545c:	f7ff fc1d 	bl	24c9a <hciCmdAlloc>
   25460:	60f8      	str	r0, [r7, #12]
   25462:	68fb      	ldr	r3, [r7, #12]
   25464:	2b00      	cmp	r3, #0
   25466:	d013      	beq.n	25490 <HciLeReadRemoteFeatCmd+0x44>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25468:	68fb      	ldr	r3, [r7, #12]
   2546a:	3303      	adds	r3, #3
   2546c:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   2546e:	68bb      	ldr	r3, [r7, #8]
   25470:	1c5a      	adds	r2, r3, #1
   25472:	60ba      	str	r2, [r7, #8]
   25474:	88fa      	ldrh	r2, [r7, #6]
   25476:	b2d2      	uxtb	r2, r2
   25478:	701a      	strb	r2, [r3, #0]
   2547a:	88fb      	ldrh	r3, [r7, #6]
   2547c:	0a1b      	lsrs	r3, r3, #8
   2547e:	b299      	uxth	r1, r3
   25480:	68bb      	ldr	r3, [r7, #8]
   25482:	1c5a      	adds	r2, r3, #1
   25484:	60ba      	str	r2, [r7, #8]
   25486:	b2ca      	uxtb	r2, r1
   25488:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   2548a:	68f8      	ldr	r0, [r7, #12]
   2548c:	f7ff fc34 	bl	24cf8 <hciCmdSend>
  }
}
   25490:	bf00      	nop
   25492:	3710      	adds	r7, #16
   25494:	46bd      	mov	sp, r7
   25496:	bd80      	pop	{r7, pc}

00025498 <HciLeReadSupStatesCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadSupStatesCmd(void)
{
   25498:	b580      	push	{r7, lr}
   2549a:	b082      	sub	sp, #8
   2549c:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_SUP_STATES, HCI_LEN_LE_READ_SUP_STATES)) != NULL)
   2549e:	2100      	movs	r1, #0
   254a0:	f242 001c 	movw	r0, #8220	; 0x201c
   254a4:	f7ff fbf9 	bl	24c9a <hciCmdAlloc>
   254a8:	6078      	str	r0, [r7, #4]
   254aa:	687b      	ldr	r3, [r7, #4]
   254ac:	2b00      	cmp	r3, #0
   254ae:	d002      	beq.n	254b6 <HciLeReadSupStatesCmd+0x1e>
  {
    hciCmdSend(pBuf);
   254b0:	6878      	ldr	r0, [r7, #4]
   254b2:	f7ff fc21 	bl	24cf8 <hciCmdSend>
  }
}
   254b6:	bf00      	nop
   254b8:	3708      	adds	r7, #8
   254ba:	46bd      	mov	sp, r7
   254bc:	bd80      	pop	{r7, pc}

000254be <HciLeReadWhiteListSizeCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadWhiteListSizeCmd(void)
{
   254be:	b580      	push	{r7, lr}
   254c0:	b082      	sub	sp, #8
   254c2:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_WHITE_LIST_SIZE, HCI_LEN_LE_READ_WHITE_LIST_SIZE)) != NULL)
   254c4:	2100      	movs	r1, #0
   254c6:	f242 000f 	movw	r0, #8207	; 0x200f
   254ca:	f7ff fbe6 	bl	24c9a <hciCmdAlloc>
   254ce:	6078      	str	r0, [r7, #4]
   254d0:	687b      	ldr	r3, [r7, #4]
   254d2:	2b00      	cmp	r3, #0
   254d4:	d002      	beq.n	254dc <HciLeReadWhiteListSizeCmd+0x1e>
  {
    hciCmdSend(pBuf);
   254d6:	6878      	ldr	r0, [r7, #4]
   254d8:	f7ff fc0e 	bl	24cf8 <hciCmdSend>
  }
}
   254dc:	bf00      	nop
   254de:	3708      	adds	r7, #8
   254e0:	46bd      	mov	sp, r7
   254e2:	bd80      	pop	{r7, pc}

000254e4 <HciLeSetAdvEnableCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetAdvEnableCmd(uint8_t enable)
{
   254e4:	b580      	push	{r7, lr}
   254e6:	b084      	sub	sp, #16
   254e8:	af00      	add	r7, sp, #0
   254ea:	4603      	mov	r3, r0
   254ec:	71fb      	strb	r3, [r7, #7]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_ADV_ENABLE, HCI_LEN_LE_SET_ADV_ENABLE)) != NULL)
   254ee:	2101      	movs	r1, #1
   254f0:	f242 000a 	movw	r0, #8202	; 0x200a
   254f4:	f7ff fbd1 	bl	24c9a <hciCmdAlloc>
   254f8:	60f8      	str	r0, [r7, #12]
   254fa:	68fb      	ldr	r3, [r7, #12]
   254fc:	2b00      	cmp	r3, #0
   254fe:	d00a      	beq.n	25516 <HciLeSetAdvEnableCmd+0x32>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25500:	68fb      	ldr	r3, [r7, #12]
   25502:	3303      	adds	r3, #3
   25504:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, enable);
   25506:	68bb      	ldr	r3, [r7, #8]
   25508:	1c5a      	adds	r2, r3, #1
   2550a:	60ba      	str	r2, [r7, #8]
   2550c:	79fa      	ldrb	r2, [r7, #7]
   2550e:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25510:	68f8      	ldr	r0, [r7, #12]
   25512:	f7ff fbf1 	bl	24cf8 <hciCmdSend>
  }
}
   25516:	bf00      	nop
   25518:	3710      	adds	r7, #16
   2551a:	46bd      	mov	sp, r7
   2551c:	bd80      	pop	{r7, pc}

0002551e <HciLeSetAdvDataCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetAdvDataCmd(uint8_t len, uint8_t *pData)
{
   2551e:	b580      	push	{r7, lr}
   25520:	b084      	sub	sp, #16
   25522:	af00      	add	r7, sp, #0
   25524:	4603      	mov	r3, r0
   25526:	6039      	str	r1, [r7, #0]
   25528:	71fb      	strb	r3, [r7, #7]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_ADV_DATA, HCI_LEN_LE_SET_ADV_DATA)) != NULL)
   2552a:	2120      	movs	r1, #32
   2552c:	f242 0008 	movw	r0, #8200	; 0x2008
   25530:	f7ff fbb3 	bl	24c9a <hciCmdAlloc>
   25534:	60f8      	str	r0, [r7, #12]
   25536:	68fb      	ldr	r3, [r7, #12]
   25538:	2b00      	cmp	r3, #0
   2553a:	d01c      	beq.n	25576 <HciLeSetAdvDataCmd+0x58>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   2553c:	68fb      	ldr	r3, [r7, #12]
   2553e:	3303      	adds	r3, #3
   25540:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, len);
   25542:	68bb      	ldr	r3, [r7, #8]
   25544:	1c5a      	adds	r2, r3, #1
   25546:	60ba      	str	r2, [r7, #8]
   25548:	79fa      	ldrb	r2, [r7, #7]
   2554a:	701a      	strb	r2, [r3, #0]
    memcpy(p, pData, len);
   2554c:	79fb      	ldrb	r3, [r7, #7]
   2554e:	461a      	mov	r2, r3
   25550:	6839      	ldr	r1, [r7, #0]
   25552:	68b8      	ldr	r0, [r7, #8]
   25554:	f7f2 fe7e 	bl	18254 <memcpy>
    p += len;
   25558:	79fb      	ldrb	r3, [r7, #7]
   2555a:	68ba      	ldr	r2, [r7, #8]
   2555c:	4413      	add	r3, r2
   2555e:	60bb      	str	r3, [r7, #8]
    memset(p, 0, (HCI_ADV_DATA_LEN - len));
   25560:	79fb      	ldrb	r3, [r7, #7]
   25562:	f1c3 031f 	rsb	r3, r3, #31
   25566:	461a      	mov	r2, r3
   25568:	2100      	movs	r1, #0
   2556a:	68b8      	ldr	r0, [r7, #8]
   2556c:	f00a fdc0 	bl	300f0 <memset>
    hciCmdSend(pBuf);
   25570:	68f8      	ldr	r0, [r7, #12]
   25572:	f7ff fbc1 	bl	24cf8 <hciCmdSend>
  }
}
   25576:	bf00      	nop
   25578:	3710      	adds	r7, #16
   2557a:	46bd      	mov	sp, r7
   2557c:	bd80      	pop	{r7, pc}

0002557e <HciLeSetAdvParamCmd>:
 */
/*************************************************************************************************/
void HciLeSetAdvParamCmd(uint16_t advIntervalMin, uint16_t advIntervalMax, uint8_t advType,
                         uint8_t ownAddrType, uint8_t peerAddrType, uint8_t *pPeerAddr,
                         uint8_t advChanMap, uint8_t advFiltPolicy)
{
   2557e:	b590      	push	{r4, r7, lr}
   25580:	b085      	sub	sp, #20
   25582:	af00      	add	r7, sp, #0
   25584:	4604      	mov	r4, r0
   25586:	4608      	mov	r0, r1
   25588:	4611      	mov	r1, r2
   2558a:	461a      	mov	r2, r3
   2558c:	4623      	mov	r3, r4
   2558e:	80fb      	strh	r3, [r7, #6]
   25590:	4603      	mov	r3, r0
   25592:	80bb      	strh	r3, [r7, #4]
   25594:	460b      	mov	r3, r1
   25596:	70fb      	strb	r3, [r7, #3]
   25598:	4613      	mov	r3, r2
   2559a:	70bb      	strb	r3, [r7, #2]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_ADV_PARAM, HCI_LEN_LE_SET_ADV_PARAM)) != NULL)
   2559c:	210f      	movs	r1, #15
   2559e:	f242 0006 	movw	r0, #8198	; 0x2006
   255a2:	f7ff fb7a 	bl	24c9a <hciCmdAlloc>
   255a6:	60b8      	str	r0, [r7, #8]
   255a8:	68bb      	ldr	r3, [r7, #8]
   255aa:	2b00      	cmp	r3, #0
   255ac:	d04c      	beq.n	25648 <HciLeSetAdvParamCmd+0xca>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   255ae:	68bb      	ldr	r3, [r7, #8]
   255b0:	3303      	adds	r3, #3
   255b2:	60fb      	str	r3, [r7, #12]
    UINT16_TO_BSTREAM(p, advIntervalMin);
   255b4:	68fb      	ldr	r3, [r7, #12]
   255b6:	1c5a      	adds	r2, r3, #1
   255b8:	60fa      	str	r2, [r7, #12]
   255ba:	88fa      	ldrh	r2, [r7, #6]
   255bc:	b2d2      	uxtb	r2, r2
   255be:	701a      	strb	r2, [r3, #0]
   255c0:	88fb      	ldrh	r3, [r7, #6]
   255c2:	0a1b      	lsrs	r3, r3, #8
   255c4:	b299      	uxth	r1, r3
   255c6:	68fb      	ldr	r3, [r7, #12]
   255c8:	1c5a      	adds	r2, r3, #1
   255ca:	60fa      	str	r2, [r7, #12]
   255cc:	b2ca      	uxtb	r2, r1
   255ce:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, advIntervalMax);
   255d0:	68fb      	ldr	r3, [r7, #12]
   255d2:	1c5a      	adds	r2, r3, #1
   255d4:	60fa      	str	r2, [r7, #12]
   255d6:	88ba      	ldrh	r2, [r7, #4]
   255d8:	b2d2      	uxtb	r2, r2
   255da:	701a      	strb	r2, [r3, #0]
   255dc:	88bb      	ldrh	r3, [r7, #4]
   255de:	0a1b      	lsrs	r3, r3, #8
   255e0:	b299      	uxth	r1, r3
   255e2:	68fb      	ldr	r3, [r7, #12]
   255e4:	1c5a      	adds	r2, r3, #1
   255e6:	60fa      	str	r2, [r7, #12]
   255e8:	b2ca      	uxtb	r2, r1
   255ea:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, advType);
   255ec:	68fb      	ldr	r3, [r7, #12]
   255ee:	1c5a      	adds	r2, r3, #1
   255f0:	60fa      	str	r2, [r7, #12]
   255f2:	78fa      	ldrb	r2, [r7, #3]
   255f4:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, ownAddrType);
   255f6:	68fb      	ldr	r3, [r7, #12]
   255f8:	1c5a      	adds	r2, r3, #1
   255fa:	60fa      	str	r2, [r7, #12]
   255fc:	78ba      	ldrb	r2, [r7, #2]
   255fe:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, peerAddrType);
   25600:	68fb      	ldr	r3, [r7, #12]
   25602:	1c5a      	adds	r2, r3, #1
   25604:	60fa      	str	r2, [r7, #12]
   25606:	f897 2020 	ldrb.w	r2, [r7, #32]
   2560a:	701a      	strb	r2, [r3, #0]
    if (pPeerAddr != NULL)
   2560c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2560e:	2b00      	cmp	r3, #0
   25610:	d007      	beq.n	25622 <HciLeSetAdvParamCmd+0xa4>
    {
      BDA_TO_BSTREAM(p, pPeerAddr);
   25612:	6a79      	ldr	r1, [r7, #36]	; 0x24
   25614:	68f8      	ldr	r0, [r7, #12]
   25616:	f7fc fab6 	bl	21b86 <BdaCpy>
   2561a:	68fb      	ldr	r3, [r7, #12]
   2561c:	3306      	adds	r3, #6
   2561e:	60fb      	str	r3, [r7, #12]
   25620:	e003      	b.n	2562a <HciLeSetAdvParamCmd+0xac>
    }
    else
    {
      p = BdaClr(p);
   25622:	68f8      	ldr	r0, [r7, #12]
   25624:	f7fc fad1 	bl	21bca <BdaClr>
   25628:	60f8      	str	r0, [r7, #12]
    }
    UINT8_TO_BSTREAM(p, advChanMap);
   2562a:	68fb      	ldr	r3, [r7, #12]
   2562c:	1c5a      	adds	r2, r3, #1
   2562e:	60fa      	str	r2, [r7, #12]
   25630:	f897 2028 	ldrb.w	r2, [r7, #40]	; 0x28
   25634:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, advFiltPolicy);
   25636:	68fb      	ldr	r3, [r7, #12]
   25638:	1c5a      	adds	r2, r3, #1
   2563a:	60fa      	str	r2, [r7, #12]
   2563c:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
   25640:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25642:	68b8      	ldr	r0, [r7, #8]
   25644:	f7ff fb58 	bl	24cf8 <hciCmdSend>
  }
}
   25648:	bf00      	nop
   2564a:	3714      	adds	r7, #20
   2564c:	46bd      	mov	sp, r7
   2564e:	bd90      	pop	{r4, r7, pc}

00025650 <HciLeSetEventMaskCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetEventMaskCmd(uint8_t *pLeEventMask)
{
   25650:	b580      	push	{r7, lr}
   25652:	b084      	sub	sp, #16
   25654:	af00      	add	r7, sp, #0
   25656:	6078      	str	r0, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_EVENT_MASK, HCI_LEN_LE_SET_EVENT_MASK)) != NULL)
   25658:	2108      	movs	r1, #8
   2565a:	f242 0001 	movw	r0, #8193	; 0x2001
   2565e:	f7ff fb1c 	bl	24c9a <hciCmdAlloc>
   25662:	60f8      	str	r0, [r7, #12]
   25664:	68fb      	ldr	r3, [r7, #12]
   25666:	2b00      	cmp	r3, #0
   25668:	d00a      	beq.n	25680 <HciLeSetEventMaskCmd+0x30>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   2566a:	68fb      	ldr	r3, [r7, #12]
   2566c:	3303      	adds	r3, #3
   2566e:	60bb      	str	r3, [r7, #8]
    memcpy(p, pLeEventMask, HCI_LE_EVT_MASK_LEN);
   25670:	2208      	movs	r2, #8
   25672:	6879      	ldr	r1, [r7, #4]
   25674:	68b8      	ldr	r0, [r7, #8]
   25676:	f7f2 fded 	bl	18254 <memcpy>
    hciCmdSend(pBuf);
   2567a:	68f8      	ldr	r0, [r7, #12]
   2567c:	f7ff fb3c 	bl	24cf8 <hciCmdSend>
  }
}
   25680:	bf00      	nop
   25682:	3710      	adds	r7, #16
   25684:	46bd      	mov	sp, r7
   25686:	bd80      	pop	{r7, pc}

00025688 <HciLeSetScanEnableCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetScanEnableCmd(uint8_t enable, uint8_t filterDup)
{
   25688:	b580      	push	{r7, lr}
   2568a:	b084      	sub	sp, #16
   2568c:	af00      	add	r7, sp, #0
   2568e:	4603      	mov	r3, r0
   25690:	460a      	mov	r2, r1
   25692:	71fb      	strb	r3, [r7, #7]
   25694:	4613      	mov	r3, r2
   25696:	71bb      	strb	r3, [r7, #6]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_SCAN_ENABLE, HCI_LEN_LE_SET_SCAN_ENABLE)) != NULL)
   25698:	2102      	movs	r1, #2
   2569a:	f242 000c 	movw	r0, #8204	; 0x200c
   2569e:	f7ff fafc 	bl	24c9a <hciCmdAlloc>
   256a2:	60f8      	str	r0, [r7, #12]
   256a4:	68fb      	ldr	r3, [r7, #12]
   256a6:	2b00      	cmp	r3, #0
   256a8:	d00f      	beq.n	256ca <HciLeSetScanEnableCmd+0x42>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   256aa:	68fb      	ldr	r3, [r7, #12]
   256ac:	3303      	adds	r3, #3
   256ae:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, enable);
   256b0:	68bb      	ldr	r3, [r7, #8]
   256b2:	1c5a      	adds	r2, r3, #1
   256b4:	60ba      	str	r2, [r7, #8]
   256b6:	79fa      	ldrb	r2, [r7, #7]
   256b8:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, filterDup);
   256ba:	68bb      	ldr	r3, [r7, #8]
   256bc:	1c5a      	adds	r2, r3, #1
   256be:	60ba      	str	r2, [r7, #8]
   256c0:	79ba      	ldrb	r2, [r7, #6]
   256c2:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   256c4:	68f8      	ldr	r0, [r7, #12]
   256c6:	f7ff fb17 	bl	24cf8 <hciCmdSend>
  }
}
   256ca:	bf00      	nop
   256cc:	3710      	adds	r7, #16
   256ce:	46bd      	mov	sp, r7
   256d0:	bd80      	pop	{r7, pc}

000256d2 <HciLeSetScanParamCmd>:
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetScanParamCmd(uint8_t scanType, uint16_t scanInterval, uint16_t scanWindow,
                          uint8_t ownAddrType, uint8_t scanFiltPolicy)
{
   256d2:	b590      	push	{r4, r7, lr}
   256d4:	b085      	sub	sp, #20
   256d6:	af00      	add	r7, sp, #0
   256d8:	4604      	mov	r4, r0
   256da:	4608      	mov	r0, r1
   256dc:	4611      	mov	r1, r2
   256de:	461a      	mov	r2, r3
   256e0:	4623      	mov	r3, r4
   256e2:	71fb      	strb	r3, [r7, #7]
   256e4:	4603      	mov	r3, r0
   256e6:	80bb      	strh	r3, [r7, #4]
   256e8:	460b      	mov	r3, r1
   256ea:	807b      	strh	r3, [r7, #2]
   256ec:	4613      	mov	r3, r2
   256ee:	71bb      	strb	r3, [r7, #6]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_SCAN_PARAM, HCI_LEN_LE_SET_SCAN_PARAM)) != NULL)
   256f0:	2107      	movs	r1, #7
   256f2:	f242 000b 	movw	r0, #8203	; 0x200b
   256f6:	f7ff fad0 	bl	24c9a <hciCmdAlloc>
   256fa:	60f8      	str	r0, [r7, #12]
   256fc:	68fb      	ldr	r3, [r7, #12]
   256fe:	2b00      	cmp	r3, #0
   25700:	d031      	beq.n	25766 <HciLeSetScanParamCmd+0x94>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25702:	68fb      	ldr	r3, [r7, #12]
   25704:	3303      	adds	r3, #3
   25706:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, scanType);
   25708:	68bb      	ldr	r3, [r7, #8]
   2570a:	1c5a      	adds	r2, r3, #1
   2570c:	60ba      	str	r2, [r7, #8]
   2570e:	79fa      	ldrb	r2, [r7, #7]
   25710:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, scanInterval);
   25712:	68bb      	ldr	r3, [r7, #8]
   25714:	1c5a      	adds	r2, r3, #1
   25716:	60ba      	str	r2, [r7, #8]
   25718:	88ba      	ldrh	r2, [r7, #4]
   2571a:	b2d2      	uxtb	r2, r2
   2571c:	701a      	strb	r2, [r3, #0]
   2571e:	88bb      	ldrh	r3, [r7, #4]
   25720:	0a1b      	lsrs	r3, r3, #8
   25722:	b299      	uxth	r1, r3
   25724:	68bb      	ldr	r3, [r7, #8]
   25726:	1c5a      	adds	r2, r3, #1
   25728:	60ba      	str	r2, [r7, #8]
   2572a:	b2ca      	uxtb	r2, r1
   2572c:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, scanWindow);
   2572e:	68bb      	ldr	r3, [r7, #8]
   25730:	1c5a      	adds	r2, r3, #1
   25732:	60ba      	str	r2, [r7, #8]
   25734:	887a      	ldrh	r2, [r7, #2]
   25736:	b2d2      	uxtb	r2, r2
   25738:	701a      	strb	r2, [r3, #0]
   2573a:	887b      	ldrh	r3, [r7, #2]
   2573c:	0a1b      	lsrs	r3, r3, #8
   2573e:	b299      	uxth	r1, r3
   25740:	68bb      	ldr	r3, [r7, #8]
   25742:	1c5a      	adds	r2, r3, #1
   25744:	60ba      	str	r2, [r7, #8]
   25746:	b2ca      	uxtb	r2, r1
   25748:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, ownAddrType);
   2574a:	68bb      	ldr	r3, [r7, #8]
   2574c:	1c5a      	adds	r2, r3, #1
   2574e:	60ba      	str	r2, [r7, #8]
   25750:	79ba      	ldrb	r2, [r7, #6]
   25752:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, scanFiltPolicy);
   25754:	68bb      	ldr	r3, [r7, #8]
   25756:	1c5a      	adds	r2, r3, #1
   25758:	60ba      	str	r2, [r7, #8]
   2575a:	f897 2020 	ldrb.w	r2, [r7, #32]
   2575e:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25760:	68f8      	ldr	r0, [r7, #12]
   25762:	f7ff fac9 	bl	24cf8 <hciCmdSend>
  }
}
   25766:	bf00      	nop
   25768:	3714      	adds	r7, #20
   2576a:	46bd      	mov	sp, r7
   2576c:	bd90      	pop	{r4, r7, pc}

0002576e <HciLeSetScanRespDataCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeSetScanRespDataCmd(uint8_t len, uint8_t *pData)
{
   2576e:	b580      	push	{r7, lr}
   25770:	b084      	sub	sp, #16
   25772:	af00      	add	r7, sp, #0
   25774:	4603      	mov	r3, r0
   25776:	6039      	str	r1, [r7, #0]
   25778:	71fb      	strb	r3, [r7, #7]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_SET_SCAN_RESP_DATA, HCI_LEN_LE_SET_SCAN_RESP_DATA)) != NULL)
   2577a:	2120      	movs	r1, #32
   2577c:	f242 0009 	movw	r0, #8201	; 0x2009
   25780:	f7ff fa8b 	bl	24c9a <hciCmdAlloc>
   25784:	60f8      	str	r0, [r7, #12]
   25786:	68fb      	ldr	r3, [r7, #12]
   25788:	2b00      	cmp	r3, #0
   2578a:	d01c      	beq.n	257c6 <HciLeSetScanRespDataCmd+0x58>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   2578c:	68fb      	ldr	r3, [r7, #12]
   2578e:	3303      	adds	r3, #3
   25790:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, len);
   25792:	68bb      	ldr	r3, [r7, #8]
   25794:	1c5a      	adds	r2, r3, #1
   25796:	60ba      	str	r2, [r7, #8]
   25798:	79fa      	ldrb	r2, [r7, #7]
   2579a:	701a      	strb	r2, [r3, #0]
    memcpy(p, pData, len);
   2579c:	79fb      	ldrb	r3, [r7, #7]
   2579e:	461a      	mov	r2, r3
   257a0:	6839      	ldr	r1, [r7, #0]
   257a2:	68b8      	ldr	r0, [r7, #8]
   257a4:	f7f2 fd56 	bl	18254 <memcpy>
    p += len;
   257a8:	79fb      	ldrb	r3, [r7, #7]
   257aa:	68ba      	ldr	r2, [r7, #8]
   257ac:	4413      	add	r3, r2
   257ae:	60bb      	str	r3, [r7, #8]
    memset(p, 0, (HCI_SCAN_DATA_LEN - len));
   257b0:	79fb      	ldrb	r3, [r7, #7]
   257b2:	f1c3 031f 	rsb	r3, r3, #31
   257b6:	461a      	mov	r2, r3
   257b8:	2100      	movs	r1, #0
   257ba:	68b8      	ldr	r0, [r7, #8]
   257bc:	f00a fc98 	bl	300f0 <memset>
    hciCmdSend(pBuf);
   257c0:	68f8      	ldr	r0, [r7, #12]
   257c2:	f7ff fa99 	bl	24cf8 <hciCmdSend>
  }
}
   257c6:	bf00      	nop
   257c8:	3710      	adds	r7, #16
   257ca:	46bd      	mov	sp, r7
   257cc:	bd80      	pop	{r7, pc}

000257ce <HciReadBdAddrCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciReadBdAddrCmd(void)
{
   257ce:	b580      	push	{r7, lr}
   257d0:	b082      	sub	sp, #8
   257d2:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_READ_BD_ADDR, HCI_LEN_READ_BD_ADDR)) != NULL)
   257d4:	2100      	movs	r1, #0
   257d6:	f241 0009 	movw	r0, #4105	; 0x1009
   257da:	f7ff fa5e 	bl	24c9a <hciCmdAlloc>
   257de:	6078      	str	r0, [r7, #4]
   257e0:	687b      	ldr	r3, [r7, #4]
   257e2:	2b00      	cmp	r3, #0
   257e4:	d002      	beq.n	257ec <HciReadBdAddrCmd+0x1e>
  {
    hciCmdSend(pBuf);
   257e6:	6878      	ldr	r0, [r7, #4]
   257e8:	f7ff fa86 	bl	24cf8 <hciCmdSend>
  }
}
   257ec:	bf00      	nop
   257ee:	3708      	adds	r7, #8
   257f0:	46bd      	mov	sp, r7
   257f2:	bd80      	pop	{r7, pc}

000257f4 <HciReadRssiCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciReadRssiCmd(uint16_t handle)
{
   257f4:	b580      	push	{r7, lr}
   257f6:	b084      	sub	sp, #16
   257f8:	af00      	add	r7, sp, #0
   257fa:	4603      	mov	r3, r0
   257fc:	80fb      	strh	r3, [r7, #6]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_READ_RSSI, HCI_LEN_READ_RSSI)) != NULL)
   257fe:	2102      	movs	r1, #2
   25800:	f241 4005 	movw	r0, #5125	; 0x1405
   25804:	f7ff fa49 	bl	24c9a <hciCmdAlloc>
   25808:	60f8      	str	r0, [r7, #12]
   2580a:	68fb      	ldr	r3, [r7, #12]
   2580c:	2b00      	cmp	r3, #0
   2580e:	d013      	beq.n	25838 <HciReadRssiCmd+0x44>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25810:	68fb      	ldr	r3, [r7, #12]
   25812:	3303      	adds	r3, #3
   25814:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   25816:	68bb      	ldr	r3, [r7, #8]
   25818:	1c5a      	adds	r2, r3, #1
   2581a:	60ba      	str	r2, [r7, #8]
   2581c:	88fa      	ldrh	r2, [r7, #6]
   2581e:	b2d2      	uxtb	r2, r2
   25820:	701a      	strb	r2, [r3, #0]
   25822:	88fb      	ldrh	r3, [r7, #6]
   25824:	0a1b      	lsrs	r3, r3, #8
   25826:	b299      	uxth	r1, r3
   25828:	68bb      	ldr	r3, [r7, #8]
   2582a:	1c5a      	adds	r2, r3, #1
   2582c:	60ba      	str	r2, [r7, #8]
   2582e:	b2ca      	uxtb	r2, r1
   25830:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25832:	68f8      	ldr	r0, [r7, #12]
   25834:	f7ff fa60 	bl	24cf8 <hciCmdSend>
  }
}
   25838:	bf00      	nop
   2583a:	3710      	adds	r7, #16
   2583c:	46bd      	mov	sp, r7
   2583e:	bd80      	pop	{r7, pc}

00025840 <hciClearCmdQueue>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciClearCmdQueue(void)
{
   25840:	b580      	push	{r7, lr}
   25842:	b082      	sub	sp, #8
   25844:	af00      	add	r7, sp, #0
  uint8_t *pBuf;
  wsfHandlerId_t  handlerId;

  // Free up any unsent HCI commandss
  while((pBuf = WsfMsgDeq(&hciCmdCb.cmdQueue, &handlerId)) != NULL)
   25846:	e002      	b.n	2584e <hciClearCmdQueue+0xe>
  {
    WsfMsgFree(pBuf);
   25848:	6878      	ldr	r0, [r7, #4]
   2584a:	f007 fc47 	bl	2d0dc <WsfMsgFree>
  while((pBuf = WsfMsgDeq(&hciCmdCb.cmdQueue, &handlerId)) != NULL)
   2584e:	1cfb      	adds	r3, r7, #3
   25850:	4619      	mov	r1, r3
   25852:	4807      	ldr	r0, [pc, #28]	; (25870 <hciClearCmdQueue+0x30>)
   25854:	f007 fc7c 	bl	2d150 <WsfMsgDeq>
   25858:	6078      	str	r0, [r7, #4]
   2585a:	687b      	ldr	r3, [r7, #4]
   2585c:	2b00      	cmp	r3, #0
   2585e:	d1f3      	bne.n	25848 <hciClearCmdQueue+0x8>
  }

  /* initialize numCmdPkts for special case of start the reset sequence */
  hciCmdCb.numCmdPkts = 1;
   25860:	4b04      	ldr	r3, [pc, #16]	; (25874 <hciClearCmdQueue+0x34>)
   25862:	2201      	movs	r2, #1
   25864:	769a      	strb	r2, [r3, #26]
}
   25866:	bf00      	nop
   25868:	3708      	adds	r7, #8
   2586a:	46bd      	mov	sp, r7
   2586c:	bd80      	pop	{r7, pc}
   2586e:	bf00      	nop
   25870:	10011340 	.word	0x10011340
   25874:	10011330 	.word	0x10011330

00025878 <HciResetCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciResetCmd(void)
{
   25878:	b580      	push	{r7, lr}
   2587a:	b084      	sub	sp, #16
   2587c:	af00      	add	r7, sp, #0
  uint8_t *pBuf;
  hciHwErrorEvt_t evt;

  // let security module to clean up pending request/command
  evt.hdr.event = HCI_HW_ERROR_CBACK_EVT;
   2587e:	2314      	movs	r3, #20
   25880:	71bb      	strb	r3, [r7, #6]

  hciCb.secCback((hciEvt_t *)&evt);
   25882:	4b0b      	ldr	r3, [pc, #44]	; (258b0 <HciResetCmd+0x38>)
   25884:	68db      	ldr	r3, [r3, #12]
   25886:	1d3a      	adds	r2, r7, #4
   25888:	4610      	mov	r0, r2
   2588a:	4798      	blx	r3

  hciClearCmdQueue();
   2588c:	f7ff ffd8 	bl	25840 <hciClearCmdQueue>

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_RESET, HCI_LEN_RESET)) != NULL)
   25890:	2100      	movs	r1, #0
   25892:	f640 4003 	movw	r0, #3075	; 0xc03
   25896:	f7ff fa00 	bl	24c9a <hciCmdAlloc>
   2589a:	60f8      	str	r0, [r7, #12]
   2589c:	68fb      	ldr	r3, [r7, #12]
   2589e:	2b00      	cmp	r3, #0
   258a0:	d002      	beq.n	258a8 <HciResetCmd+0x30>
  {
    hciCmdSend(pBuf);
   258a2:	68f8      	ldr	r0, [r7, #12]
   258a4:	f7ff fa28 	bl	24cf8 <hciCmdSend>
  }
}
   258a8:	bf00      	nop
   258aa:	3710      	adds	r7, #16
   258ac:	46bd      	mov	sp, r7
   258ae:	bd80      	pop	{r7, pc}
   258b0:	100116ec 	.word	0x100116ec

000258b4 <HciSetEventMaskCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciSetEventMaskCmd(uint8_t *pEventMask)
{
   258b4:	b580      	push	{r7, lr}
   258b6:	b084      	sub	sp, #16
   258b8:	af00      	add	r7, sp, #0
   258ba:	6078      	str	r0, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_SET_EVENT_MASK, HCI_LEN_SET_EVENT_MASK)) != NULL)
   258bc:	2108      	movs	r1, #8
   258be:	f640 4001 	movw	r0, #3073	; 0xc01
   258c2:	f7ff f9ea 	bl	24c9a <hciCmdAlloc>
   258c6:	60f8      	str	r0, [r7, #12]
   258c8:	68fb      	ldr	r3, [r7, #12]
   258ca:	2b00      	cmp	r3, #0
   258cc:	d00a      	beq.n	258e4 <HciSetEventMaskCmd+0x30>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   258ce:	68fb      	ldr	r3, [r7, #12]
   258d0:	3303      	adds	r3, #3
   258d2:	60bb      	str	r3, [r7, #8]
    memcpy(p, pEventMask, HCI_EVT_MASK_LEN);
   258d4:	2208      	movs	r2, #8
   258d6:	6879      	ldr	r1, [r7, #4]
   258d8:	68b8      	ldr	r0, [r7, #8]
   258da:	f7f2 fcbb 	bl	18254 <memcpy>
    hciCmdSend(pBuf);
   258de:	68f8      	ldr	r0, [r7, #12]
   258e0:	f7ff fa0a 	bl	24cf8 <hciCmdSend>
  }
}
   258e4:	bf00      	nop
   258e6:	3710      	adds	r7, #16
   258e8:	46bd      	mov	sp, r7
   258ea:	bd80      	pop	{r7, pc}

000258ec <HciSetEventMaskPage2Cmd>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciSetEventMaskPage2Cmd(uint8_t *pEventMask)
{
   258ec:	b580      	push	{r7, lr}
   258ee:	b084      	sub	sp, #16
   258f0:	af00      	add	r7, sp, #0
   258f2:	6078      	str	r0, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_SET_EVENT_MASK_PAGE2, HCI_LEN_SET_EVENT_MASK_PAGE2)) != NULL)
   258f4:	2108      	movs	r1, #8
   258f6:	f640 4063 	movw	r0, #3171	; 0xc63
   258fa:	f7ff f9ce 	bl	24c9a <hciCmdAlloc>
   258fe:	60f8      	str	r0, [r7, #12]
   25900:	68fb      	ldr	r3, [r7, #12]
   25902:	2b00      	cmp	r3, #0
   25904:	d00a      	beq.n	2591c <HciSetEventMaskPage2Cmd+0x30>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25906:	68fb      	ldr	r3, [r7, #12]
   25908:	3303      	adds	r3, #3
   2590a:	60bb      	str	r3, [r7, #8]
    memcpy(p, pEventMask, HCI_EVT_MASK_PAGE_2_LEN);
   2590c:	2208      	movs	r2, #8
   2590e:	6879      	ldr	r1, [r7, #4]
   25910:	68b8      	ldr	r0, [r7, #8]
   25912:	f7f2 fc9f 	bl	18254 <memcpy>
    hciCmdSend(pBuf);
   25916:	68f8      	ldr	r0, [r7, #12]
   25918:	f7ff f9ee 	bl	24cf8 <hciCmdSend>
  }
}
   2591c:	bf00      	nop
   2591e:	3710      	adds	r7, #16
   25920:	46bd      	mov	sp, r7
   25922:	bd80      	pop	{r7, pc}

00025924 <HciWriteAuthPayloadTimeout>:
*
*  \return None.
*/
/*************************************************************************************************/
void HciWriteAuthPayloadTimeout(uint16_t handle, uint16_t timeout)
{
   25924:	b580      	push	{r7, lr}
   25926:	b084      	sub	sp, #16
   25928:	af00      	add	r7, sp, #0
   2592a:	4603      	mov	r3, r0
   2592c:	460a      	mov	r2, r1
   2592e:	80fb      	strh	r3, [r7, #6]
   25930:	4613      	mov	r3, r2
   25932:	80bb      	strh	r3, [r7, #4]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_WRITE_AUTH_PAYLOAD_TO, HCI_LEN_WRITE_AUTH_PAYLOAD_TO)) != NULL)
   25934:	2104      	movs	r1, #4
   25936:	f640 407c 	movw	r0, #3196	; 0xc7c
   2593a:	f7ff f9ae 	bl	24c9a <hciCmdAlloc>
   2593e:	60f8      	str	r0, [r7, #12]
   25940:	68fb      	ldr	r3, [r7, #12]
   25942:	2b00      	cmp	r3, #0
   25944:	d021      	beq.n	2598a <HciWriteAuthPayloadTimeout+0x66>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   25946:	68fb      	ldr	r3, [r7, #12]
   25948:	3303      	adds	r3, #3
   2594a:	60bb      	str	r3, [r7, #8]
    UINT16_TO_BSTREAM(p, handle);
   2594c:	68bb      	ldr	r3, [r7, #8]
   2594e:	1c5a      	adds	r2, r3, #1
   25950:	60ba      	str	r2, [r7, #8]
   25952:	88fa      	ldrh	r2, [r7, #6]
   25954:	b2d2      	uxtb	r2, r2
   25956:	701a      	strb	r2, [r3, #0]
   25958:	88fb      	ldrh	r3, [r7, #6]
   2595a:	0a1b      	lsrs	r3, r3, #8
   2595c:	b299      	uxth	r1, r3
   2595e:	68bb      	ldr	r3, [r7, #8]
   25960:	1c5a      	adds	r2, r3, #1
   25962:	60ba      	str	r2, [r7, #8]
   25964:	b2ca      	uxtb	r2, r1
   25966:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, timeout);
   25968:	68bb      	ldr	r3, [r7, #8]
   2596a:	1c5a      	adds	r2, r3, #1
   2596c:	60ba      	str	r2, [r7, #8]
   2596e:	88ba      	ldrh	r2, [r7, #4]
   25970:	b2d2      	uxtb	r2, r2
   25972:	701a      	strb	r2, [r3, #0]
   25974:	88bb      	ldrh	r3, [r7, #4]
   25976:	0a1b      	lsrs	r3, r3, #8
   25978:	b299      	uxth	r1, r3
   2597a:	68bb      	ldr	r3, [r7, #8]
   2597c:	1c5a      	adds	r2, r3, #1
   2597e:	60ba      	str	r2, [r7, #8]
   25980:	b2ca      	uxtb	r2, r1
   25982:	701a      	strb	r2, [r3, #0]
    hciCmdSend(pBuf);
   25984:	68f8      	ldr	r0, [r7, #12]
   25986:	f7ff f9b7 	bl	24cf8 <hciCmdSend>
  }
}
   2598a:	bf00      	nop
   2598c:	3710      	adds	r7, #16
   2598e:	46bd      	mov	sp, r7
   25990:	bd80      	pop	{r7, pc}

00025992 <HciLeReadResolvingListSize>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciLeReadResolvingListSize(void)
{
   25992:	b580      	push	{r7, lr}
   25994:	b082      	sub	sp, #8
   25996:	af00      	add	r7, sp, #0
  uint8_t *pBuf;

  if ((pBuf = hciCmdAlloc(HCI_OPCODE_LE_READ_RES_LIST_SIZE, HCI_LEN_LE_READ_RES_LIST_SIZE)) != NULL)
   25998:	2100      	movs	r1, #0
   2599a:	f242 002a 	movw	r0, #8234	; 0x202a
   2599e:	f7ff f97c 	bl	24c9a <hciCmdAlloc>
   259a2:	6078      	str	r0, [r7, #4]
   259a4:	687b      	ldr	r3, [r7, #4]
   259a6:	2b00      	cmp	r3, #0
   259a8:	d002      	beq.n	259b0 <HciLeReadResolvingListSize+0x1e>
  {
    hciCmdSend(pBuf);
   259aa:	6878      	ldr	r0, [r7, #4]
   259ac:	f7ff f9a4 	bl	24cf8 <hciCmdSend>
  }
}
   259b0:	bf00      	nop
   259b2:	3708      	adds	r7, #8
   259b4:	46bd      	mov	sp, r7
   259b6:	bd80      	pop	{r7, pc}

000259b8 <HciVendorSpecificCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciVendorSpecificCmd(uint16_t opcode, uint8_t len, uint8_t *pData)
{
   259b8:	b580      	push	{r7, lr}
   259ba:	b084      	sub	sp, #16
   259bc:	af00      	add	r7, sp, #0
   259be:	4603      	mov	r3, r0
   259c0:	603a      	str	r2, [r7, #0]
   259c2:	80fb      	strh	r3, [r7, #6]
   259c4:	460b      	mov	r3, r1
   259c6:	717b      	strb	r3, [r7, #5]
  uint8_t *pBuf;
  uint8_t *p;

  if ((pBuf = hciCmdAlloc(opcode, len)) != NULL)
   259c8:	797b      	ldrb	r3, [r7, #5]
   259ca:	b29a      	uxth	r2, r3
   259cc:	88fb      	ldrh	r3, [r7, #6]
   259ce:	4611      	mov	r1, r2
   259d0:	4618      	mov	r0, r3
   259d2:	f7ff f962 	bl	24c9a <hciCmdAlloc>
   259d6:	60f8      	str	r0, [r7, #12]
   259d8:	68fb      	ldr	r3, [r7, #12]
   259da:	2b00      	cmp	r3, #0
   259dc:	d00b      	beq.n	259f6 <HciVendorSpecificCmd+0x3e>
  {
    p = pBuf + HCI_CMD_HDR_LEN;
   259de:	68fb      	ldr	r3, [r7, #12]
   259e0:	3303      	adds	r3, #3
   259e2:	60bb      	str	r3, [r7, #8]
    memcpy(p, pData, len);
   259e4:	797b      	ldrb	r3, [r7, #5]
   259e6:	461a      	mov	r2, r3
   259e8:	6839      	ldr	r1, [r7, #0]
   259ea:	68b8      	ldr	r0, [r7, #8]
   259ec:	f7f2 fc32 	bl	18254 <memcpy>
    hciCmdSend(pBuf);
   259f0:	68f8      	ldr	r0, [r7, #12]
   259f2:	f7ff f981 	bl	24cf8 <hciCmdSend>
  }
}
   259f6:	bf00      	nop
   259f8:	3710      	adds	r7, #16
   259fa:	46bd      	mov	sp, r7
   259fc:	bd80      	pop	{r7, pc}
	...

00025a00 <hciCoreConnAlloc>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciCoreConnAlloc(uint16_t handle)
{
   25a00:	b480      	push	{r7}
   25a02:	b085      	sub	sp, #20
   25a04:	af00      	add	r7, sp, #0
   25a06:	4603      	mov	r3, r0
   25a08:	80fb      	strh	r3, [r7, #6]
  uint8_t         i;
  hciCoreConn_t   *pConn = hciCoreCb.conn;
   25a0a:	4b13      	ldr	r3, [pc, #76]	; (25a58 <hciCoreConnAlloc+0x58>)
   25a0c:	60bb      	str	r3, [r7, #8]

  /* find available connection struct */
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25a0e:	2303      	movs	r3, #3
   25a10:	73fb      	strb	r3, [r7, #15]
   25a12:	e018      	b.n	25a46 <hciCoreConnAlloc+0x46>
  {
    if (pConn->handle == HCI_HANDLE_NONE)
   25a14:	68bb      	ldr	r3, [r7, #8]
   25a16:	8a1b      	ldrh	r3, [r3, #16]
   25a18:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25a1c:	4293      	cmp	r3, r2
   25a1e:	d10c      	bne.n	25a3a <hciCoreConnAlloc+0x3a>
    {
      /* allocate and initialize */
      pConn->handle = handle;
   25a20:	68bb      	ldr	r3, [r7, #8]
   25a22:	88fa      	ldrh	r2, [r7, #6]
   25a24:	821a      	strh	r2, [r3, #16]
      pConn->flowDisabled = FALSE;
   25a26:	68bb      	ldr	r3, [r7, #8]
   25a28:	2200      	movs	r2, #0
   25a2a:	75da      	strb	r2, [r3, #23]
      pConn->outBufs = 0;
   25a2c:	68bb      	ldr	r3, [r7, #8]
   25a2e:	2200      	movs	r2, #0
   25a30:	765a      	strb	r2, [r3, #25]
      pConn->queuedBufs = 0;
   25a32:	68bb      	ldr	r3, [r7, #8]
   25a34:	2200      	movs	r2, #0
   25a36:	761a      	strb	r2, [r3, #24]

      return;
   25a38:	e008      	b.n	25a4c <hciCoreConnAlloc+0x4c>
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25a3a:	7bfb      	ldrb	r3, [r7, #15]
   25a3c:	3b01      	subs	r3, #1
   25a3e:	73fb      	strb	r3, [r7, #15]
   25a40:	68bb      	ldr	r3, [r7, #8]
   25a42:	331c      	adds	r3, #28
   25a44:	60bb      	str	r3, [r7, #8]
   25a46:	7bfb      	ldrb	r3, [r7, #15]
   25a48:	2b00      	cmp	r3, #0
   25a4a:	d1e3      	bne.n	25a14 <hciCoreConnAlloc+0x14>
    }
  }

  HCI_TRACE_WARN0("HCI conn struct alloc failure");
}
   25a4c:	3714      	adds	r7, #20
   25a4e:	46bd      	mov	sp, r7
   25a50:	f85d 7b04 	ldr.w	r7, [sp], #4
   25a54:	4770      	bx	lr
   25a56:	bf00      	nop
   25a58:	1001134c 	.word	0x1001134c

00025a5c <hciCoreConnFree>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciCoreConnFree(uint16_t handle)
{
   25a5c:	b580      	push	{r7, lr}
   25a5e:	b084      	sub	sp, #16
   25a60:	af00      	add	r7, sp, #0
   25a62:	4603      	mov	r3, r0
   25a64:	80fb      	strh	r3, [r7, #6]
  uint8_t         i;
  hciCoreConn_t   *pConn = hciCoreCb.conn;
   25a66:	4b1d      	ldr	r3, [pc, #116]	; (25adc <hciCoreConnFree+0x80>)
   25a68:	60bb      	str	r3, [r7, #8]

  /* find connection struct */
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25a6a:	2303      	movs	r3, #3
   25a6c:	73fb      	strb	r3, [r7, #15]
   25a6e:	e02f      	b.n	25ad0 <hciCoreConnFree+0x74>
  {
    if (pConn->handle == handle)
   25a70:	68bb      	ldr	r3, [r7, #8]
   25a72:	8a1b      	ldrh	r3, [r3, #16]
   25a74:	88fa      	ldrh	r2, [r7, #6]
   25a76:	429a      	cmp	r2, r3
   25a78:	d124      	bne.n	25ac4 <hciCoreConnFree+0x68>
    {
      /* free any fragmenting ACL packet */
      if (pConn->pTxAclPkt != NULL)
   25a7a:	68bb      	ldr	r3, [r7, #8]
   25a7c:	681b      	ldr	r3, [r3, #0]
   25a7e:	2b00      	cmp	r3, #0
   25a80:	d007      	beq.n	25a92 <hciCoreConnFree+0x36>
      {
        WsfMsgFree(pConn->pTxAclPkt);
   25a82:	68bb      	ldr	r3, [r7, #8]
   25a84:	681b      	ldr	r3, [r3, #0]
   25a86:	4618      	mov	r0, r3
   25a88:	f007 fb28 	bl	2d0dc <WsfMsgFree>
        pConn->pTxAclPkt = NULL;
   25a8c:	68bb      	ldr	r3, [r7, #8]
   25a8e:	2200      	movs	r2, #0
   25a90:	601a      	str	r2, [r3, #0]
      }
      pConn->fragmenting = FALSE;
   25a92:	68bb      	ldr	r3, [r7, #8]
   25a94:	2200      	movs	r2, #0
   25a96:	759a      	strb	r2, [r3, #22]

      if (pConn->pRxAclPkt != NULL)
   25a98:	68bb      	ldr	r3, [r7, #8]
   25a9a:	689b      	ldr	r3, [r3, #8]
   25a9c:	2b00      	cmp	r3, #0
   25a9e:	d007      	beq.n	25ab0 <hciCoreConnFree+0x54>
      {
        WsfMsgFree(pConn->pRxAclPkt);
   25aa0:	68bb      	ldr	r3, [r7, #8]
   25aa2:	689b      	ldr	r3, [r3, #8]
   25aa4:	4618      	mov	r0, r3
   25aa6:	f007 fb19 	bl	2d0dc <WsfMsgFree>
        pConn->pRxAclPkt = NULL;
   25aaa:	68bb      	ldr	r3, [r7, #8]
   25aac:	2200      	movs	r2, #0
   25aae:	609a      	str	r2, [r3, #8]
      }

      /* free structure */
      pConn->handle = HCI_HANDLE_NONE;
   25ab0:	68bb      	ldr	r3, [r7, #8]
   25ab2:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25ab6:	821a      	strh	r2, [r3, #16]

      /* optional: iterate through tx ACL queue and free any buffers with this handle */

      /* outstanding buffers are now available; service TX data path */
      hciCoreTxReady(pConn->outBufs);
   25ab8:	68bb      	ldr	r3, [r7, #8]
   25aba:	7e5b      	ldrb	r3, [r3, #25]
   25abc:	4618      	mov	r0, r3
   25abe:	f000 f89b 	bl	25bf8 <hciCoreTxReady>

      return;
   25ac2:	e008      	b.n	25ad6 <hciCoreConnFree+0x7a>
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25ac4:	7bfb      	ldrb	r3, [r7, #15]
   25ac6:	3b01      	subs	r3, #1
   25ac8:	73fb      	strb	r3, [r7, #15]
   25aca:	68bb      	ldr	r3, [r7, #8]
   25acc:	331c      	adds	r3, #28
   25ace:	60bb      	str	r3, [r7, #8]
   25ad0:	7bfb      	ldrb	r3, [r7, #15]
   25ad2:	2b00      	cmp	r3, #0
   25ad4:	d1cc      	bne.n	25a70 <hciCoreConnFree+0x14>
    }
  }

  HCI_TRACE_WARN1("hciCoreConnFree handle not found:%u", handle);
}
   25ad6:	3710      	adds	r7, #16
   25ad8:	46bd      	mov	sp, r7
   25ada:	bd80      	pop	{r7, pc}
   25adc:	1001134c 	.word	0x1001134c

00025ae0 <hciCoreConnByHandle>:
 *
 *  \return Pointer to connection structure or NULL if not found.
 */
/*************************************************************************************************/
hciCoreConn_t *hciCoreConnByHandle(uint16_t handle)
{
   25ae0:	b480      	push	{r7}
   25ae2:	b085      	sub	sp, #20
   25ae4:	af00      	add	r7, sp, #0
   25ae6:	4603      	mov	r3, r0
   25ae8:	80fb      	strh	r3, [r7, #6]
  uint8_t         i;
  hciCoreConn_t   *pConn = hciCoreCb.conn;
   25aea:	4b0e      	ldr	r3, [pc, #56]	; (25b24 <hciCoreConnByHandle+0x44>)
   25aec:	60bb      	str	r3, [r7, #8]

  /* find available connection struct */
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25aee:	2303      	movs	r3, #3
   25af0:	73fb      	strb	r3, [r7, #15]
   25af2:	e00c      	b.n	25b0e <hciCoreConnByHandle+0x2e>
  {
    if (pConn->handle == handle)
   25af4:	68bb      	ldr	r3, [r7, #8]
   25af6:	8a1b      	ldrh	r3, [r3, #16]
   25af8:	88fa      	ldrh	r2, [r7, #6]
   25afa:	429a      	cmp	r2, r3
   25afc:	d101      	bne.n	25b02 <hciCoreConnByHandle+0x22>
    {
      return pConn;
   25afe:	68bb      	ldr	r3, [r7, #8]
   25b00:	e009      	b.n	25b16 <hciCoreConnByHandle+0x36>
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25b02:	7bfb      	ldrb	r3, [r7, #15]
   25b04:	3b01      	subs	r3, #1
   25b06:	73fb      	strb	r3, [r7, #15]
   25b08:	68bb      	ldr	r3, [r7, #8]
   25b0a:	331c      	adds	r3, #28
   25b0c:	60bb      	str	r3, [r7, #8]
   25b0e:	7bfb      	ldrb	r3, [r7, #15]
   25b10:	2b00      	cmp	r3, #0
   25b12:	d1ef      	bne.n	25af4 <hciCoreConnByHandle+0x14>
    }
  }

  return NULL;
   25b14:	2300      	movs	r3, #0
}
   25b16:	4618      	mov	r0, r3
   25b18:	3714      	adds	r7, #20
   25b1a:	46bd      	mov	sp, r7
   25b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
   25b20:	4770      	bx	lr
   25b22:	bf00      	nop
   25b24:	1001134c 	.word	0x1001134c

00025b28 <hciCoreNextConnFragment>:
 *
 *  \return Pointer to connection structure or NULL if not found.
 */
/*************************************************************************************************/
static hciCoreConn_t *hciCoreNextConnFragment(void)
{
   25b28:	b480      	push	{r7}
   25b2a:	b083      	sub	sp, #12
   25b2c:	af00      	add	r7, sp, #0
  uint8_t         i;
  hciCoreConn_t   *pConn = hciCoreCb.conn;
   25b2e:	4b10      	ldr	r3, [pc, #64]	; (25b70 <hciCoreNextConnFragment+0x48>)
   25b30:	603b      	str	r3, [r7, #0]

  /* find connection struct */
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25b32:	2303      	movs	r3, #3
   25b34:	71fb      	strb	r3, [r7, #7]
   25b36:	e011      	b.n	25b5c <hciCoreNextConnFragment+0x34>
  {
    if (pConn->handle != HCI_HANDLE_NONE && pConn->fragmenting)
   25b38:	683b      	ldr	r3, [r7, #0]
   25b3a:	8a1b      	ldrh	r3, [r3, #16]
   25b3c:	f64f 72ff 	movw	r2, #65535	; 0xffff
   25b40:	4293      	cmp	r3, r2
   25b42:	d005      	beq.n	25b50 <hciCoreNextConnFragment+0x28>
   25b44:	683b      	ldr	r3, [r7, #0]
   25b46:	7d9b      	ldrb	r3, [r3, #22]
   25b48:	2b00      	cmp	r3, #0
   25b4a:	d001      	beq.n	25b50 <hciCoreNextConnFragment+0x28>
    {
      return pConn;
   25b4c:	683b      	ldr	r3, [r7, #0]
   25b4e:	e009      	b.n	25b64 <hciCoreNextConnFragment+0x3c>
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   25b50:	79fb      	ldrb	r3, [r7, #7]
   25b52:	3b01      	subs	r3, #1
   25b54:	71fb      	strb	r3, [r7, #7]
   25b56:	683b      	ldr	r3, [r7, #0]
   25b58:	331c      	adds	r3, #28
   25b5a:	603b      	str	r3, [r7, #0]
   25b5c:	79fb      	ldrb	r3, [r7, #7]
   25b5e:	2b00      	cmp	r3, #0
   25b60:	d1ea      	bne.n	25b38 <hciCoreNextConnFragment+0x10>
    }
  }

  return NULL;
   25b62:	2300      	movs	r3, #0
}
   25b64:	4618      	mov	r0, r3
   25b66:	370c      	adds	r7, #12
   25b68:	46bd      	mov	sp, r7
   25b6a:	f85d 7b04 	ldr.w	r7, [sp], #4
   25b6e:	4770      	bx	lr
   25b70:	1001134c 	.word	0x1001134c

00025b74 <hciCoreConnOpen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreConnOpen(uint16_t handle)
{
   25b74:	b580      	push	{r7, lr}
   25b76:	b082      	sub	sp, #8
   25b78:	af00      	add	r7, sp, #0
   25b7a:	4603      	mov	r3, r0
   25b7c:	80fb      	strh	r3, [r7, #6]
  /* allocate connection structure */
  hciCoreConnAlloc(handle);
   25b7e:	88fb      	ldrh	r3, [r7, #6]
   25b80:	4618      	mov	r0, r3
   25b82:	f7ff ff3d 	bl	25a00 <hciCoreConnAlloc>
}
   25b86:	bf00      	nop
   25b88:	3708      	adds	r7, #8
   25b8a:	46bd      	mov	sp, r7
   25b8c:	bd80      	pop	{r7, pc}

00025b8e <hciCoreConnClose>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreConnClose(uint16_t handle)
{
   25b8e:	b580      	push	{r7, lr}
   25b90:	b082      	sub	sp, #8
   25b92:	af00      	add	r7, sp, #0
   25b94:	4603      	mov	r3, r0
   25b96:	80fb      	strh	r3, [r7, #6]
  /* free connection structure */
  hciCoreConnFree(handle);
   25b98:	88fb      	ldrh	r3, [r7, #6]
   25b9a:	4618      	mov	r0, r3
   25b9c:	f7ff ff5e 	bl	25a5c <hciCoreConnFree>
}
   25ba0:	bf00      	nop
   25ba2:	3708      	adds	r7, #8
   25ba4:	46bd      	mov	sp, r7
   25ba6:	bd80      	pop	{r7, pc}

00025ba8 <hciCoreSendAclData>:
 *
 *  \return TRUE if packet sent, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t hciCoreSendAclData(hciCoreConn_t *pConn, uint8_t *pData)
{
   25ba8:	b580      	push	{r7, lr}
   25baa:	b082      	sub	sp, #8
   25bac:	af00      	add	r7, sp, #0
   25bae:	6078      	str	r0, [r7, #4]
   25bb0:	6039      	str	r1, [r7, #0]
  /* send to transport */
  if ( hciTrSendAclData(pConn, pData) > 0)
   25bb2:	6839      	ldr	r1, [r7, #0]
   25bb4:	6878      	ldr	r0, [r7, #4]
   25bb6:	f003 fa88 	bl	290ca <hciTrSendAclData>
   25bba:	4603      	mov	r3, r0
   25bbc:	2b00      	cmp	r3, #0
   25bbe:	d014      	beq.n	25bea <hciCoreSendAclData+0x42>
  {
    /* increment outstanding buf count for handle */
    pConn->outBufs++;
   25bc0:	687b      	ldr	r3, [r7, #4]
   25bc2:	7e5b      	ldrb	r3, [r3, #25]
   25bc4:	3301      	adds	r3, #1
   25bc6:	b2da      	uxtb	r2, r3
   25bc8:	687b      	ldr	r3, [r7, #4]
   25bca:	765a      	strb	r2, [r3, #25]

    /* decrement available buffer count */
    if (hciCoreCb.availBufs > 0)
   25bcc:	4b09      	ldr	r3, [pc, #36]	; (25bf4 <hciCoreSendAclData+0x4c>)
   25bce:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
   25bd2:	2b00      	cmp	r3, #0
   25bd4:	d007      	beq.n	25be6 <hciCoreSendAclData+0x3e>
    {
      hciCoreCb.availBufs--;
   25bd6:	4b07      	ldr	r3, [pc, #28]	; (25bf4 <hciCoreSendAclData+0x4c>)
   25bd8:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
   25bdc:	3b01      	subs	r3, #1
   25bde:	b2da      	uxtb	r2, r3
   25be0:	4b04      	ldr	r3, [pc, #16]	; (25bf4 <hciCoreSendAclData+0x4c>)
   25be2:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
    }
    else
    {
      HCI_TRACE_WARN0("hciCoreSendAclData availBufs=0");
    }
    return TRUE;
   25be6:	2301      	movs	r3, #1
   25be8:	e000      	b.n	25bec <hciCoreSendAclData+0x44>
  }
  return FALSE;
   25bea:	2300      	movs	r3, #0
}
   25bec:	4618      	mov	r0, r3
   25bee:	3708      	adds	r7, #8
   25bf0:	46bd      	mov	sp, r7
   25bf2:	bd80      	pop	{r7, pc}
   25bf4:	1001134c 	.word	0x1001134c

00025bf8 <hciCoreTxReady>:
 *
 *  \return TRUE if any pending hci ACL packet sent successfully.
 */
/*************************************************************************************************/
bool_t hciCoreTxReady(uint8_t bufs)
{
   25bf8:	b580      	push	{r7, lr}
   25bfa:	b088      	sub	sp, #32
   25bfc:	af00      	add	r7, sp, #0
   25bfe:	4603      	mov	r3, r0
   25c00:	71fb      	strb	r3, [r7, #7]
  uint8_t         *pData;
  wsfHandlerId_t  handlerId;
  uint16_t        handle;
  uint16_t        len;
  hciCoreConn_t   *pConn;
  bool_t          pkt_sent = FALSE;
   25c02:	2300      	movs	r3, #0
   25c04:	77fb      	strb	r3, [r7, #31]

  /* increment available buffers, with ceiling */
  if (bufs > 0)
   25c06:	79fb      	ldrb	r3, [r7, #7]
   25c08:	2b00      	cmp	r3, #0
   25c0a:	d066      	beq.n	25cda <hciCoreTxReady+0xe2>
  {
    hciCoreCb.availBufs += bufs;
   25c0c:	4b3a      	ldr	r3, [pc, #232]	; (25cf8 <hciCoreTxReady+0x100>)
   25c0e:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
   25c12:	79fb      	ldrb	r3, [r7, #7]
   25c14:	4413      	add	r3, r2
   25c16:	b2da      	uxtb	r2, r3
   25c18:	4b37      	ldr	r3, [pc, #220]	; (25cf8 <hciCoreTxReady+0x100>)
   25c1a:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
    if (hciCoreCb.availBufs > hciCoreCb.numBufs)
   25c1e:	4b36      	ldr	r3, [pc, #216]	; (25cf8 <hciCoreTxReady+0x100>)
   25c20:	f893 2076 	ldrb.w	r2, [r3, #118]	; 0x76
   25c24:	4b34      	ldr	r3, [pc, #208]	; (25cf8 <hciCoreTxReady+0x100>)
   25c26:	f893 3077 	ldrb.w	r3, [r3, #119]	; 0x77
   25c2a:	429a      	cmp	r2, r3
   25c2c:	d955      	bls.n	25cda <hciCoreTxReady+0xe2>
    {
      hciCoreCb.availBufs = hciCoreCb.numBufs;
   25c2e:	4b32      	ldr	r3, [pc, #200]	; (25cf8 <hciCoreTxReady+0x100>)
   25c30:	f893 2077 	ldrb.w	r2, [r3, #119]	; 0x77
   25c34:	4b30      	ldr	r3, [pc, #192]	; (25cf8 <hciCoreTxReady+0x100>)
   25c36:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
    }
  }

  /* service ACL data queue and send as many buffers as we can */
  while (hciCoreCb.availBufs > 0)
   25c3a:	e04e      	b.n	25cda <hciCoreTxReady+0xe2>
  {
    /* send continuation of any fragments first */
    if (hciCoreTxAclContinue(NULL) == FALSE)
   25c3c:	2000      	movs	r0, #0
   25c3e:	f000 f8b1 	bl	25da4 <hciCoreTxAclContinue>
   25c42:	4603      	mov	r3, r0
   25c44:	2b00      	cmp	r3, #0
   25c46:	d148      	bne.n	25cda <hciCoreTxReady+0xe2>
    {
      /* if no fragments then check for any queued ACL data */
      if ((pData = WsfMsgPeek(&hciCoreCb.aclQueue, &handlerId)) != NULL)
   25c48:	f107 030f 	add.w	r3, r7, #15
   25c4c:	4619      	mov	r1, r3
   25c4e:	482b      	ldr	r0, [pc, #172]	; (25cfc <hciCoreTxReady+0x104>)
   25c50:	f007 fa96 	bl	2d180 <WsfMsgPeek>
   25c54:	61b8      	str	r0, [r7, #24]
   25c56:	69bb      	ldr	r3, [r7, #24]
   25c58:	2b00      	cmp	r3, #0
   25c5a:	d044      	beq.n	25ce6 <hciCoreTxReady+0xee>
      {
        /* parse handle and length */
        BYTES_TO_UINT16(handle, pData);
   25c5c:	69bb      	ldr	r3, [r7, #24]
   25c5e:	781b      	ldrb	r3, [r3, #0]
   25c60:	b29a      	uxth	r2, r3
   25c62:	69bb      	ldr	r3, [r7, #24]
   25c64:	3301      	adds	r3, #1
   25c66:	781b      	ldrb	r3, [r3, #0]
   25c68:	b29b      	uxth	r3, r3
   25c6a:	021b      	lsls	r3, r3, #8
   25c6c:	b29b      	uxth	r3, r3
   25c6e:	4413      	add	r3, r2
   25c70:	82fb      	strh	r3, [r7, #22]
        BYTES_TO_UINT16(len, &pData[2]);
   25c72:	69bb      	ldr	r3, [r7, #24]
   25c74:	3302      	adds	r3, #2
   25c76:	781b      	ldrb	r3, [r3, #0]
   25c78:	b29a      	uxth	r2, r3
   25c7a:	69bb      	ldr	r3, [r7, #24]
   25c7c:	3303      	adds	r3, #3
   25c7e:	781b      	ldrb	r3, [r3, #0]
   25c80:	b29b      	uxth	r3, r3
   25c82:	021b      	lsls	r3, r3, #8
   25c84:	b29b      	uxth	r3, r3
   25c86:	4413      	add	r3, r2
   25c88:	82bb      	strh	r3, [r7, #20]

        /* look up conn structure and send data */
        if ((pConn = hciCoreConnByHandle(handle)) != NULL)
   25c8a:	8afb      	ldrh	r3, [r7, #22]
   25c8c:	4618      	mov	r0, r3
   25c8e:	f7ff ff27 	bl	25ae0 <hciCoreConnByHandle>
   25c92:	6138      	str	r0, [r7, #16]
   25c94:	693b      	ldr	r3, [r7, #16]
   25c96:	2b00      	cmp	r3, #0
   25c98:	d015      	beq.n	25cc6 <hciCoreTxReady+0xce>
        {
          if (hciCoreTxAclStart(pConn, len, pData) == TRUE)
   25c9a:	8abb      	ldrh	r3, [r7, #20]
   25c9c:	69ba      	ldr	r2, [r7, #24]
   25c9e:	4619      	mov	r1, r3
   25ca0:	6938      	ldr	r0, [r7, #16]
   25ca2:	f000 f82d 	bl	25d00 <hciCoreTxAclStart>
   25ca6:	4603      	mov	r3, r0
   25ca8:	2b01      	cmp	r3, #1
   25caa:	d11e      	bne.n	25cea <hciCoreTxReady+0xf2>
          {
            WsfMsgDeq(&hciCoreCb.aclQueue, &handlerId);
   25cac:	f107 030f 	add.w	r3, r7, #15
   25cb0:	4619      	mov	r1, r3
   25cb2:	4812      	ldr	r0, [pc, #72]	; (25cfc <hciCoreTxReady+0x104>)
   25cb4:	f007 fa4c 	bl	2d150 <WsfMsgDeq>
            hciCoreTxAclComplete(pConn, pData);
   25cb8:	69b9      	ldr	r1, [r7, #24]
   25cba:	6938      	ldr	r0, [r7, #16]
   25cbc:	f000 f8d7 	bl	25e6e <hciCoreTxAclComplete>
            pkt_sent = TRUE;
   25cc0:	2301      	movs	r3, #1
   25cc2:	77fb      	strb	r3, [r7, #31]
   25cc4:	e009      	b.n	25cda <hciCoreTxReady+0xe2>
        }
        /* handle not found, connection must be closed */
        else
        {
          /* Dequeue */
          pData = WsfMsgDeq(&hciCoreCb.aclQueue, &handlerId);
   25cc6:	f107 030f 	add.w	r3, r7, #15
   25cca:	4619      	mov	r1, r3
   25ccc:	480b      	ldr	r0, [pc, #44]	; (25cfc <hciCoreTxReady+0x104>)
   25cce:	f007 fa3f 	bl	2d150 <WsfMsgDeq>
   25cd2:	61b8      	str	r0, [r7, #24]
          /* discard buffer */
          WsfMsgFree(pData);
   25cd4:	69b8      	ldr	r0, [r7, #24]
   25cd6:	f007 fa01 	bl	2d0dc <WsfMsgFree>
  while (hciCoreCb.availBufs > 0)
   25cda:	4b07      	ldr	r3, [pc, #28]	; (25cf8 <hciCoreTxReady+0x100>)
   25cdc:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
   25ce0:	2b00      	cmp	r3, #0
   25ce2:	d1ab      	bne.n	25c3c <hciCoreTxReady+0x44>
   25ce4:	e002      	b.n	25cec <hciCoreTxReady+0xf4>
        }
      }
      else
      {
        /* no fragments or queued data to send; we're done */
        break;
   25ce6:	bf00      	nop
   25ce8:	e000      	b.n	25cec <hciCoreTxReady+0xf4>
            break;
   25cea:	bf00      	nop
      }
    }
  }
  return pkt_sent;
   25cec:	7ffb      	ldrb	r3, [r7, #31]
}
   25cee:	4618      	mov	r0, r3
   25cf0:	3720      	adds	r7, #32
   25cf2:	46bd      	mov	sp, r7
   25cf4:	bd80      	pop	{r7, pc}
   25cf6:	bf00      	nop
   25cf8:	1001134c 	.word	0x1001134c
   25cfc:	100113b0 	.word	0x100113b0

00025d00 <hciCoreTxAclStart>:
 *
 *  \return TRUE if packet sent, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t hciCoreTxAclStart(hciCoreConn_t *pConn, uint16_t len, uint8_t *pData)
{
   25d00:	b580      	push	{r7, lr}
   25d02:	b086      	sub	sp, #24
   25d04:	af00      	add	r7, sp, #0
   25d06:	60f8      	str	r0, [r7, #12]
   25d08:	460b      	mov	r3, r1
   25d0a:	607a      	str	r2, [r7, #4]
   25d0c:	817b      	strh	r3, [r7, #10]
  uint16_t hciLen;

  /* make sure not already fragmenting on this connection */
  WSF_ASSERT(pConn->fragmenting == FALSE);

  hciLen = HciGetBufSize();
   25d0e:	f000 fb91 	bl	26434 <HciGetBufSize>
   25d12:	4603      	mov	r3, r0
   25d14:	82fb      	strh	r3, [r7, #22]

  HCI_TRACE_INFO1("hciCoreTxAclStart len=%u", len);

  /* if acl len > controller acl buf len */
  if (len > hciLen)
   25d16:	897a      	ldrh	r2, [r7, #10]
   25d18:	8afb      	ldrh	r3, [r7, #22]
   25d1a:	429a      	cmp	r2, r3
   25d1c:	d939      	bls.n	25d92 <hciCoreTxAclStart+0x92>
  {
    /* store remaining acl len = acl len - hci acl buf len */
    pConn->txAclRemLen = len - hciLen;
   25d1e:	897a      	ldrh	r2, [r7, #10]
   25d20:	8afb      	ldrh	r3, [r7, #22]
   25d22:	1ad3      	subs	r3, r2, r3
   25d24:	b29a      	uxth	r2, r3
   25d26:	68fb      	ldr	r3, [r7, #12]
   25d28:	825a      	strh	r2, [r3, #18]

    /* store position for next fragment */
    pConn->pNextTxFrag = pData + hciLen;
   25d2a:	8afb      	ldrh	r3, [r7, #22]
   25d2c:	687a      	ldr	r2, [r7, #4]
   25d2e:	441a      	add	r2, r3
   25d30:	68fb      	ldr	r3, [r7, #12]
   25d32:	605a      	str	r2, [r3, #4]

    /* store information required for fragmentation */
    pConn->pTxAclPkt = pData;
   25d34:	68fb      	ldr	r3, [r7, #12]
   25d36:	687a      	ldr	r2, [r7, #4]
   25d38:	601a      	str	r2, [r3, #0]
    pConn->fragmenting = TRUE;
   25d3a:	68fb      	ldr	r3, [r7, #12]
   25d3c:	2201      	movs	r2, #1
   25d3e:	759a      	strb	r2, [r3, #22]

    /* set acl len in packet to hci acl buf len */
    UINT16_TO_BUF(&pData[2], hciLen);
   25d40:	687b      	ldr	r3, [r7, #4]
   25d42:	3302      	adds	r3, #2
   25d44:	8afa      	ldrh	r2, [r7, #22]
   25d46:	b2d2      	uxtb	r2, r2
   25d48:	701a      	strb	r2, [r3, #0]
   25d4a:	8afb      	ldrh	r3, [r7, #22]
   25d4c:	0a1b      	lsrs	r3, r3, #8
   25d4e:	b29a      	uxth	r2, r3
   25d50:	687b      	ldr	r3, [r7, #4]
   25d52:	3303      	adds	r3, #3
   25d54:	b2d2      	uxtb	r2, r2
   25d56:	701a      	strb	r2, [r3, #0]

    /* send the packet */
    if (hciCoreSendAclData(pConn, pData) == TRUE)
   25d58:	6879      	ldr	r1, [r7, #4]
   25d5a:	68f8      	ldr	r0, [r7, #12]
   25d5c:	f7ff ff24 	bl	25ba8 <hciCoreSendAclData>
   25d60:	4603      	mov	r3, r0
   25d62:	2b01      	cmp	r3, #1
   25d64:	d101      	bne.n	25d6a <hciCoreTxAclStart+0x6a>
    {
      /* send additional fragments while there are HCI buffers available */
      // while ((hciCoreCb.availBufs > 0) && hciCoreTxAclContinue(pConn));

      // Return True since we save the buffer pointer.
      return TRUE;
   25d66:	2301      	movs	r3, #1
   25d68:	e018      	b.n	25d9c <hciCoreTxAclStart+0x9c>
    }
    else
    {
      /* clear previously stored information required for fragmentation */
      pConn->pTxAclPkt = NULL;
   25d6a:	68fb      	ldr	r3, [r7, #12]
   25d6c:	2200      	movs	r2, #0
   25d6e:	601a      	str	r2, [r3, #0]
      pConn->fragmenting = FALSE;
   25d70:	68fb      	ldr	r3, [r7, #12]
   25d72:	2200      	movs	r2, #0
   25d74:	759a      	strb	r2, [r3, #22]

      /* Restore original acl len in packet */
      UINT16_TO_BUF(&pData[2], len);
   25d76:	687b      	ldr	r3, [r7, #4]
   25d78:	3302      	adds	r3, #2
   25d7a:	897a      	ldrh	r2, [r7, #10]
   25d7c:	b2d2      	uxtb	r2, r2
   25d7e:	701a      	strb	r2, [r3, #0]
   25d80:	897b      	ldrh	r3, [r7, #10]
   25d82:	0a1b      	lsrs	r3, r3, #8
   25d84:	b29a      	uxth	r2, r3
   25d86:	687b      	ldr	r3, [r7, #4]
   25d88:	3303      	adds	r3, #3
   25d8a:	b2d2      	uxtb	r2, r2
   25d8c:	701a      	strb	r2, [r3, #0]

      // Start over for the same packet
      return FALSE;
   25d8e:	2300      	movs	r3, #0
   25d90:	e004      	b.n	25d9c <hciCoreTxAclStart+0x9c>
    }
  }
  else
  {
    /* no fragmentation, just send the packet */
    return hciCoreSendAclData(pConn, pData);
   25d92:	6879      	ldr	r1, [r7, #4]
   25d94:	68f8      	ldr	r0, [r7, #12]
   25d96:	f7ff ff07 	bl	25ba8 <hciCoreSendAclData>
   25d9a:	4603      	mov	r3, r0
  }
}
   25d9c:	4618      	mov	r0, r3
   25d9e:	3718      	adds	r7, #24
   25da0:	46bd      	mov	sp, r7
   25da2:	bd80      	pop	{r7, pc}

00025da4 <hciCoreTxAclContinue>:
 *
 *  \return TRUE if packet sent, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t hciCoreTxAclContinue(hciCoreConn_t *pConn)
{
   25da4:	b590      	push	{r4, r7, lr}
   25da6:	b085      	sub	sp, #20
   25da8:	af00      	add	r7, sp, #0
   25daa:	6078      	str	r0, [r7, #4]
  uint16_t aclLen;

  if (pConn == NULL)
   25dac:	687b      	ldr	r3, [r7, #4]
   25dae:	2b00      	cmp	r3, #0
   25db0:	d102      	bne.n	25db8 <hciCoreTxAclContinue+0x14>
  {
    pConn = hciCoreNextConnFragment();
   25db2:	f7ff feb9 	bl	25b28 <hciCoreNextConnFragment>
   25db6:	6078      	str	r0, [r7, #4]
  }

  if (pConn != NULL)
   25db8:	687b      	ldr	r3, [r7, #4]
   25dba:	2b00      	cmp	r3, #0
   25dbc:	d052      	beq.n	25e64 <hciCoreTxAclContinue+0xc0>
  {
    /* get next fragment length */
    aclLen = (pConn->txAclRemLen < HciGetBufSize()) ? pConn->txAclRemLen : HciGetBufSize();
   25dbe:	687b      	ldr	r3, [r7, #4]
   25dc0:	8a5c      	ldrh	r4, [r3, #18]
   25dc2:	f000 fb37 	bl	26434 <HciGetBufSize>
   25dc6:	4603      	mov	r3, r0
   25dc8:	429c      	cmp	r4, r3
   25dca:	d202      	bcs.n	25dd2 <hciCoreTxAclContinue+0x2e>
   25dcc:	687b      	ldr	r3, [r7, #4]
   25dce:	8a5b      	ldrh	r3, [r3, #18]
   25dd0:	e002      	b.n	25dd8 <hciCoreTxAclContinue+0x34>
   25dd2:	f000 fb2f 	bl	26434 <HciGetBufSize>
   25dd6:	4603      	mov	r3, r0
   25dd8:	81fb      	strh	r3, [r7, #14]

    if (aclLen > 0)
   25dda:	89fb      	ldrh	r3, [r7, #14]
   25ddc:	2b00      	cmp	r3, #0
   25dde:	d041      	beq.n	25e64 <hciCoreTxAclContinue+0xc0>
    {
      /* set handle in packet with continuation bit set */
      UINT16_TO_BUF(pConn->pNextTxFrag, (pConn->handle | HCI_PB_CONTINUE));
   25de0:	687b      	ldr	r3, [r7, #4]
   25de2:	8a1a      	ldrh	r2, [r3, #16]
   25de4:	687b      	ldr	r3, [r7, #4]
   25de6:	685b      	ldr	r3, [r3, #4]
   25de8:	b2d2      	uxtb	r2, r2
   25dea:	701a      	strb	r2, [r3, #0]
   25dec:	687b      	ldr	r3, [r7, #4]
   25dee:	8a1b      	ldrh	r3, [r3, #16]
   25df0:	0a1b      	lsrs	r3, r3, #8
   25df2:	b29b      	uxth	r3, r3
   25df4:	f043 0310 	orr.w	r3, r3, #16
   25df8:	b29a      	uxth	r2, r3
   25dfa:	687b      	ldr	r3, [r7, #4]
   25dfc:	685b      	ldr	r3, [r3, #4]
   25dfe:	3301      	adds	r3, #1
   25e00:	b2d2      	uxtb	r2, r2
   25e02:	701a      	strb	r2, [r3, #0]

      /* set acl len in packet */
      UINT16_TO_BUF(&(pConn->pNextTxFrag[2]), aclLen);
   25e04:	687b      	ldr	r3, [r7, #4]
   25e06:	685b      	ldr	r3, [r3, #4]
   25e08:	3302      	adds	r3, #2
   25e0a:	89fa      	ldrh	r2, [r7, #14]
   25e0c:	b2d2      	uxtb	r2, r2
   25e0e:	701a      	strb	r2, [r3, #0]
   25e10:	89fb      	ldrh	r3, [r7, #14]
   25e12:	0a1b      	lsrs	r3, r3, #8
   25e14:	b29a      	uxth	r2, r3
   25e16:	687b      	ldr	r3, [r7, #4]
   25e18:	685b      	ldr	r3, [r3, #4]
   25e1a:	3303      	adds	r3, #3
   25e1c:	b2d2      	uxtb	r2, r2
   25e1e:	701a      	strb	r2, [r3, #0]

      /* send the packet */
      if ( hciCoreSendAclData(pConn, pConn->pNextTxFrag) == TRUE)
   25e20:	687b      	ldr	r3, [r7, #4]
   25e22:	685b      	ldr	r3, [r3, #4]
   25e24:	4619      	mov	r1, r3
   25e26:	6878      	ldr	r0, [r7, #4]
   25e28:	f7ff febe 	bl	25ba8 <hciCoreSendAclData>
   25e2c:	4603      	mov	r3, r0
   25e2e:	2b01      	cmp	r3, #1
   25e30:	d116      	bne.n	25e60 <hciCoreTxAclContinue+0xbc>
      {
        /* decrement remaining length */
        pConn->txAclRemLen -= aclLen;
   25e32:	687b      	ldr	r3, [r7, #4]
   25e34:	8a5a      	ldrh	r2, [r3, #18]
   25e36:	89fb      	ldrh	r3, [r7, #14]
   25e38:	1ad3      	subs	r3, r2, r3
   25e3a:	b29a      	uxth	r2, r3
   25e3c:	687b      	ldr	r3, [r7, #4]
   25e3e:	825a      	strh	r2, [r3, #18]

        HCI_TRACE_INFO2("hciCoreTxAclContinue aclLen=%u remLen=%u", aclLen, pConn->txAclRemLen);

        /* set up pointer to next fragment */
        if (pConn->txAclRemLen > 0)
   25e40:	687b      	ldr	r3, [r7, #4]
   25e42:	8a5b      	ldrh	r3, [r3, #18]
   25e44:	2b00      	cmp	r3, #0
   25e46:	d005      	beq.n	25e54 <hciCoreTxAclContinue+0xb0>
        {
          pConn->pNextTxFrag += aclLen;
   25e48:	687b      	ldr	r3, [r7, #4]
   25e4a:	685a      	ldr	r2, [r3, #4]
   25e4c:	89fb      	ldrh	r3, [r7, #14]
   25e4e:	441a      	add	r2, r3
   25e50:	687b      	ldr	r3, [r7, #4]
   25e52:	605a      	str	r2, [r3, #4]
        }
        hciCoreTxAclComplete(pConn, pConn->pNextTxFrag);
   25e54:	687b      	ldr	r3, [r7, #4]
   25e56:	685b      	ldr	r3, [r3, #4]
   25e58:	4619      	mov	r1, r3
   25e5a:	6878      	ldr	r0, [r7, #4]
   25e5c:	f000 f807 	bl	25e6e <hciCoreTxAclComplete>
      }
      return TRUE;
   25e60:	2301      	movs	r3, #1
   25e62:	e000      	b.n	25e66 <hciCoreTxAclContinue+0xc2>
    }
  }

  return FALSE;
   25e64:	2300      	movs	r3, #0
}
   25e66:	4618      	mov	r0, r3
   25e68:	3714      	adds	r7, #20
   25e6a:	46bd      	mov	sp, r7
   25e6c:	bd90      	pop	{r4, r7, pc}

00025e6e <hciCoreTxAclComplete>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreTxAclComplete(hciCoreConn_t *pConn, uint8_t *pData)
{
   25e6e:	b580      	push	{r7, lr}
   25e70:	b082      	sub	sp, #8
   25e72:	af00      	add	r7, sp, #0
   25e74:	6078      	str	r0, [r7, #4]
   25e76:	6039      	str	r1, [r7, #0]
  /* if fragmenting */
  if (pConn->fragmenting)
   25e78:	687b      	ldr	r3, [r7, #4]
   25e7a:	7d9b      	ldrb	r3, [r3, #22]
   25e7c:	2b00      	cmp	r3, #0
   25e7e:	d00f      	beq.n	25ea0 <hciCoreTxAclComplete+0x32>
  {
    /* check if all fragments sent */
    if (pConn->txAclRemLen == 0)
   25e80:	687b      	ldr	r3, [r7, #4]
   25e82:	8a5b      	ldrh	r3, [r3, #18]
   25e84:	2b00      	cmp	r3, #0
   25e86:	d111      	bne.n	25eac <hciCoreTxAclComplete+0x3e>
    {
      /* free original buffer */
      WsfMsgFree(pConn->pTxAclPkt);
   25e88:	687b      	ldr	r3, [r7, #4]
   25e8a:	681b      	ldr	r3, [r3, #0]
   25e8c:	4618      	mov	r0, r3
   25e8e:	f007 f925 	bl	2d0dc <WsfMsgFree>
      pConn->pTxAclPkt = NULL;
   25e92:	687b      	ldr	r3, [r7, #4]
   25e94:	2200      	movs	r2, #0
   25e96:	601a      	str	r2, [r3, #0]
      pConn->fragmenting = FALSE;
   25e98:	687b      	ldr	r3, [r7, #4]
   25e9a:	2200      	movs	r2, #0
   25e9c:	759a      	strb	r2, [r3, #22]
  }
  else if (pData != NULL)
  {
    WsfMsgFree(pData);
  }
}
   25e9e:	e005      	b.n	25eac <hciCoreTxAclComplete+0x3e>
  else if (pData != NULL)
   25ea0:	683b      	ldr	r3, [r7, #0]
   25ea2:	2b00      	cmp	r3, #0
   25ea4:	d002      	beq.n	25eac <hciCoreTxAclComplete+0x3e>
    WsfMsgFree(pData);
   25ea6:	6838      	ldr	r0, [r7, #0]
   25ea8:	f007 f918 	bl	2d0dc <WsfMsgFree>
}
   25eac:	bf00      	nop
   25eae:	3708      	adds	r7, #8
   25eb0:	46bd      	mov	sp, r7
   25eb2:	bd80      	pop	{r7, pc}

00025eb4 <hciCoreAclReassembly>:
 *
 *  \return pointer to ACL packet to send, or NULL if no packet to send.
 */
/*************************************************************************************************/
uint8_t *hciCoreAclReassembly(uint8_t *pData)
{
   25eb4:	b580      	push	{r7, lr}
   25eb6:	b088      	sub	sp, #32
   25eb8:	af00      	add	r7, sp, #0
   25eba:	6078      	str	r0, [r7, #4]
  hciCoreConn_t *pConn;
  uint8_t       *pDataRtn = NULL;
   25ebc:	2300      	movs	r3, #0
   25ebe:	61fb      	str	r3, [r7, #28]
  uint16_t      handle;
  uint16_t      aclLen;
  uint16_t      l2cLen;
  uint16_t      pbf;
  bool_t        freeData = TRUE;
   25ec0:	2301      	movs	r3, #1
   25ec2:	76fb      	strb	r3, [r7, #27]

  BYTES_TO_UINT16(handle, pData);
   25ec4:	687b      	ldr	r3, [r7, #4]
   25ec6:	781b      	ldrb	r3, [r3, #0]
   25ec8:	b29a      	uxth	r2, r3
   25eca:	687b      	ldr	r3, [r7, #4]
   25ecc:	3301      	adds	r3, #1
   25ece:	781b      	ldrb	r3, [r3, #0]
   25ed0:	b29b      	uxth	r3, r3
   25ed2:	021b      	lsls	r3, r3, #8
   25ed4:	b29b      	uxth	r3, r3
   25ed6:	4413      	add	r3, r2
   25ed8:	833b      	strh	r3, [r7, #24]
  pbf = handle & HCI_PB_FLAG_MASK;
   25eda:	8b3b      	ldrh	r3, [r7, #24]
   25edc:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
   25ee0:	82fb      	strh	r3, [r7, #22]
  handle &= HCI_HANDLE_MASK;
   25ee2:	8b3b      	ldrh	r3, [r7, #24]
   25ee4:	f3c3 030b 	ubfx	r3, r3, #0, #12
   25ee8:	833b      	strh	r3, [r7, #24]
  BYTES_TO_UINT16(aclLen, &pData[2]);
   25eea:	687b      	ldr	r3, [r7, #4]
   25eec:	3302      	adds	r3, #2
   25eee:	781b      	ldrb	r3, [r3, #0]
   25ef0:	b29a      	uxth	r2, r3
   25ef2:	687b      	ldr	r3, [r7, #4]
   25ef4:	3303      	adds	r3, #3
   25ef6:	781b      	ldrb	r3, [r3, #0]
   25ef8:	b29b      	uxth	r3, r3
   25efa:	021b      	lsls	r3, r3, #8
   25efc:	b29b      	uxth	r3, r3
   25efe:	4413      	add	r3, r2
   25f00:	82bb      	strh	r3, [r7, #20]

  /* look up connection */
  if ((pConn = hciCoreConnByHandle(handle)) != NULL)
   25f02:	8b3b      	ldrh	r3, [r7, #24]
   25f04:	4618      	mov	r0, r3
   25f06:	f7ff fdeb 	bl	25ae0 <hciCoreConnByHandle>
   25f0a:	6138      	str	r0, [r7, #16]
   25f0c:	693b      	ldr	r3, [r7, #16]
   25f0e:	2b00      	cmp	r3, #0
   25f10:	f000 80ad 	beq.w	2606e <hciCoreAclReassembly+0x1ba>
  {
    /* if this is a start packet */
    if (pbf == HCI_PB_START_C2H)
   25f14:	8afb      	ldrh	r3, [r7, #22]
   25f16:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   25f1a:	d17c      	bne.n	26016 <hciCoreAclReassembly+0x162>
    {
      /* if currently reassembled packet not complete */
      if (pConn->pRxAclPkt != NULL)
   25f1c:	693b      	ldr	r3, [r7, #16]
   25f1e:	689b      	ldr	r3, [r3, #8]
   25f20:	2b00      	cmp	r3, #0
   25f22:	d007      	beq.n	25f34 <hciCoreAclReassembly+0x80>
      {
        /* discard currently reassembled packet */
        WsfMsgFree(pConn->pRxAclPkt);
   25f24:	693b      	ldr	r3, [r7, #16]
   25f26:	689b      	ldr	r3, [r3, #8]
   25f28:	4618      	mov	r0, r3
   25f2a:	f007 f8d7 	bl	2d0dc <WsfMsgFree>
        pConn->pRxAclPkt = NULL;
   25f2e:	693b      	ldr	r3, [r7, #16]
   25f30:	2200      	movs	r2, #0
   25f32:	609a      	str	r2, [r3, #8]
        HCI_TRACE_WARN1("disarded hci rx pkt handle=0x%04x", handle);
      }

      /* read l2cap length */
      if (aclLen >= L2C_HDR_LEN)
   25f34:	8abb      	ldrh	r3, [r7, #20]
   25f36:	2b03      	cmp	r3, #3
   25f38:	f240 8099 	bls.w	2606e <hciCoreAclReassembly+0x1ba>
      {
        BYTES_TO_UINT16(l2cLen, &pData[4]);
   25f3c:	687b      	ldr	r3, [r7, #4]
   25f3e:	3304      	adds	r3, #4
   25f40:	781b      	ldrb	r3, [r3, #0]
   25f42:	b29a      	uxth	r2, r3
   25f44:	687b      	ldr	r3, [r7, #4]
   25f46:	3305      	adds	r3, #5
   25f48:	781b      	ldrb	r3, [r3, #0]
   25f4a:	b29b      	uxth	r3, r3
   25f4c:	021b      	lsls	r3, r3, #8
   25f4e:	b29b      	uxth	r3, r3
   25f50:	4413      	add	r3, r2
   25f52:	81fb      	strh	r3, [r7, #14]

        /* check length vs. configured maximum */
        if ((l2cLen + L2C_HDR_LEN) > hciCoreCb.maxRxAclLen)
   25f54:	89fb      	ldrh	r3, [r7, #14]
   25f56:	3303      	adds	r3, #3
   25f58:	4a4a      	ldr	r2, [pc, #296]	; (26084 <hciCoreAclReassembly+0x1d0>)
   25f5a:	f8b2 2070 	ldrh.w	r2, [r2, #112]	; 0x70
   25f5e:	4293      	cmp	r3, r2
   25f60:	f280 8085 	bge.w	2606e <hciCoreAclReassembly+0x1ba>
        {
          HCI_TRACE_WARN1("l2c len=0x%04x to large for reassembly", l2cLen);
        }
        /* if reassembly required */
        else if ((l2cLen + L2C_HDR_LEN) > aclLen)
   25f64:	89fb      	ldrh	r3, [r7, #14]
   25f66:	1cda      	adds	r2, r3, #3
   25f68:	8abb      	ldrh	r3, [r7, #20]
   25f6a:	429a      	cmp	r2, r3
   25f6c:	db4e      	blt.n	2600c <hciCoreAclReassembly+0x158>
        {
          /* allocate buffer to store complete l2cap packet */
          if ((pConn->pRxAclPkt = WsfMsgDataAlloc(l2cLen + L2C_HDR_LEN + HCI_ACL_HDR_LEN, 0)) != NULL)
   25f6e:	89fb      	ldrh	r3, [r7, #14]
   25f70:	3308      	adds	r3, #8
   25f72:	b29b      	uxth	r3, r3
   25f74:	2100      	movs	r1, #0
   25f76:	4618      	mov	r0, r3
   25f78:	f007 f884 	bl	2d084 <WsfMsgDataAlloc>
   25f7c:	4602      	mov	r2, r0
   25f7e:	693b      	ldr	r3, [r7, #16]
   25f80:	609a      	str	r2, [r3, #8]
   25f82:	693b      	ldr	r3, [r7, #16]
   25f84:	689b      	ldr	r3, [r3, #8]
   25f86:	2b00      	cmp	r3, #0
   25f88:	d071      	beq.n	2606e <hciCoreAclReassembly+0x1ba>
          {
            /* store buffer for reassembly */
            pConn->pNextRxFrag = pConn->pRxAclPkt;
   25f8a:	693b      	ldr	r3, [r7, #16]
   25f8c:	689a      	ldr	r2, [r3, #8]
   25f8e:	693b      	ldr	r3, [r7, #16]
   25f90:	60da      	str	r2, [r3, #12]

            /* build acl header and copy data */
            UINT16_TO_BSTREAM(pConn->pNextRxFrag, handle);
   25f92:	693b      	ldr	r3, [r7, #16]
   25f94:	68db      	ldr	r3, [r3, #12]
   25f96:	1c59      	adds	r1, r3, #1
   25f98:	693a      	ldr	r2, [r7, #16]
   25f9a:	60d1      	str	r1, [r2, #12]
   25f9c:	8b3a      	ldrh	r2, [r7, #24]
   25f9e:	b2d2      	uxtb	r2, r2
   25fa0:	701a      	strb	r2, [r3, #0]
   25fa2:	8b3b      	ldrh	r3, [r7, #24]
   25fa4:	0a1b      	lsrs	r3, r3, #8
   25fa6:	b298      	uxth	r0, r3
   25fa8:	693b      	ldr	r3, [r7, #16]
   25faa:	68db      	ldr	r3, [r3, #12]
   25fac:	1c59      	adds	r1, r3, #1
   25fae:	693a      	ldr	r2, [r7, #16]
   25fb0:	60d1      	str	r1, [r2, #12]
   25fb2:	b2c2      	uxtb	r2, r0
   25fb4:	701a      	strb	r2, [r3, #0]
            UINT16_TO_BSTREAM(pConn->pNextRxFrag, l2cLen + L2C_HDR_LEN);
   25fb6:	89fb      	ldrh	r3, [r7, #14]
   25fb8:	b2da      	uxtb	r2, r3
   25fba:	693b      	ldr	r3, [r7, #16]
   25fbc:	68db      	ldr	r3, [r3, #12]
   25fbe:	1c58      	adds	r0, r3, #1
   25fc0:	6939      	ldr	r1, [r7, #16]
   25fc2:	60c8      	str	r0, [r1, #12]
   25fc4:	3204      	adds	r2, #4
   25fc6:	b2d2      	uxtb	r2, r2
   25fc8:	701a      	strb	r2, [r3, #0]
   25fca:	89fb      	ldrh	r3, [r7, #14]
   25fcc:	3304      	adds	r3, #4
   25fce:	1218      	asrs	r0, r3, #8
   25fd0:	693b      	ldr	r3, [r7, #16]
   25fd2:	68db      	ldr	r3, [r3, #12]
   25fd4:	1c59      	adds	r1, r3, #1
   25fd6:	693a      	ldr	r2, [r7, #16]
   25fd8:	60d1      	str	r1, [r2, #12]
   25fda:	b2c2      	uxtb	r2, r0
   25fdc:	701a      	strb	r2, [r3, #0]
            memcpy(pConn->pNextRxFrag, &pData[4], aclLen);
   25fde:	693b      	ldr	r3, [r7, #16]
   25fe0:	68d8      	ldr	r0, [r3, #12]
   25fe2:	687b      	ldr	r3, [r7, #4]
   25fe4:	3304      	adds	r3, #4
   25fe6:	8aba      	ldrh	r2, [r7, #20]
   25fe8:	4619      	mov	r1, r3
   25fea:	f7f2 f933 	bl	18254 <memcpy>
            pConn->pNextRxFrag += aclLen;
   25fee:	693b      	ldr	r3, [r7, #16]
   25ff0:	68da      	ldr	r2, [r3, #12]
   25ff2:	8abb      	ldrh	r3, [r7, #20]
   25ff4:	441a      	add	r2, r3
   25ff6:	693b      	ldr	r3, [r7, #16]
   25ff8:	60da      	str	r2, [r3, #12]

            /* store remaining length */
            pConn->rxAclRemLen = l2cLen + L2C_HDR_LEN - aclLen;
   25ffa:	89fa      	ldrh	r2, [r7, #14]
   25ffc:	8abb      	ldrh	r3, [r7, #20]
   25ffe:	1ad3      	subs	r3, r2, r3
   26000:	b29b      	uxth	r3, r3
   26002:	3304      	adds	r3, #4
   26004:	b29a      	uxth	r2, r3
   26006:	693b      	ldr	r3, [r7, #16]
   26008:	829a      	strh	r2, [r3, #20]
   2600a:	e030      	b.n	2606e <hciCoreAclReassembly+0x1ba>
          }
        }
        else
        {
          /* no reassembly required, pData is ready to go */
          pDataRtn = pData;
   2600c:	687b      	ldr	r3, [r7, #4]
   2600e:	61fb      	str	r3, [r7, #28]
          freeData = FALSE;
   26010:	2300      	movs	r3, #0
   26012:	76fb      	strb	r3, [r7, #27]
   26014:	e02b      	b.n	2606e <hciCoreAclReassembly+0x1ba>
        /* invalid l2cap packet; discard */
        HCI_TRACE_WARN1("invalid l2c pkt aclLen=%u", aclLen);
      }
    }
    /* else if this is a continuation packet */
    else if (pbf == HCI_PB_CONTINUE)
   26016:	8afb      	ldrh	r3, [r7, #22]
   26018:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   2601c:	d127      	bne.n	2606e <hciCoreAclReassembly+0x1ba>
    {
      /* if expecting a continuation */
      if (pConn->pRxAclPkt != NULL)
   2601e:	693b      	ldr	r3, [r7, #16]
   26020:	689b      	ldr	r3, [r3, #8]
   26022:	2b00      	cmp	r3, #0
   26024:	d023      	beq.n	2606e <hciCoreAclReassembly+0x1ba>
      {
        if (aclLen <= pConn->rxAclRemLen)
   26026:	693b      	ldr	r3, [r7, #16]
   26028:	8a9b      	ldrh	r3, [r3, #20]
   2602a:	8aba      	ldrh	r2, [r7, #20]
   2602c:	429a      	cmp	r2, r3
   2602e:	d81e      	bhi.n	2606e <hciCoreAclReassembly+0x1ba>
        {
          /* copy data to start of next fragment */
          memcpy(pConn->pNextRxFrag, &pData[HCI_ACL_HDR_LEN], aclLen);
   26030:	693b      	ldr	r3, [r7, #16]
   26032:	68d8      	ldr	r0, [r3, #12]
   26034:	687b      	ldr	r3, [r7, #4]
   26036:	3304      	adds	r3, #4
   26038:	8aba      	ldrh	r2, [r7, #20]
   2603a:	4619      	mov	r1, r3
   2603c:	f7f2 f90a 	bl	18254 <memcpy>
          pConn->pNextRxFrag += aclLen;
   26040:	693b      	ldr	r3, [r7, #16]
   26042:	68da      	ldr	r2, [r3, #12]
   26044:	8abb      	ldrh	r3, [r7, #20]
   26046:	441a      	add	r2, r3
   26048:	693b      	ldr	r3, [r7, #16]
   2604a:	60da      	str	r2, [r3, #12]

          /* update remaining length */
          pConn->rxAclRemLen -= aclLen;
   2604c:	693b      	ldr	r3, [r7, #16]
   2604e:	8a9a      	ldrh	r2, [r3, #20]
   26050:	8abb      	ldrh	r3, [r7, #20]
   26052:	1ad3      	subs	r3, r2, r3
   26054:	b29a      	uxth	r2, r3
   26056:	693b      	ldr	r3, [r7, #16]
   26058:	829a      	strh	r2, [r3, #20]

          /* if reassembly complete return reassembled packet */
          if (pConn->rxAclRemLen == 0)
   2605a:	693b      	ldr	r3, [r7, #16]
   2605c:	8a9b      	ldrh	r3, [r3, #20]
   2605e:	2b00      	cmp	r3, #0
   26060:	d105      	bne.n	2606e <hciCoreAclReassembly+0x1ba>
          {
            pDataRtn = pConn->pRxAclPkt;
   26062:	693b      	ldr	r3, [r7, #16]
   26064:	689b      	ldr	r3, [r3, #8]
   26066:	61fb      	str	r3, [r7, #28]
            pConn->pRxAclPkt = NULL;
   26068:	693b      	ldr	r3, [r7, #16]
   2606a:	2200      	movs	r2, #0
   2606c:	609a      	str	r2, [r3, #8]
  {
    /* connection not found */
    HCI_TRACE_WARN1("pkt rcvd on unknown handle=0x%04x", (handle & HCI_HANDLE_MASK));
  }

  if (freeData)
   2606e:	7efb      	ldrb	r3, [r7, #27]
   26070:	2b00      	cmp	r3, #0
   26072:	d002      	beq.n	2607a <hciCoreAclReassembly+0x1c6>
  {
    WsfMsgFree(pData);
   26074:	6878      	ldr	r0, [r7, #4]
   26076:	f007 f831 	bl	2d0dc <WsfMsgFree>
  }

  return pDataRtn;
   2607a:	69fb      	ldr	r3, [r7, #28]
}
   2607c:	4618      	mov	r0, r3
   2607e:	3720      	adds	r7, #32
   26080:	46bd      	mov	sp, r7
   26082:	bd80      	pop	{r7, pc}
   26084:	1001134c 	.word	0x1001134c

00026088 <HciCoreInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciCoreInit(void)
{
   26088:	b580      	push	{r7, lr}
   2608a:	b082      	sub	sp, #8
   2608c:	af00      	add	r7, sp, #0
  uint8_t   i;

  WSF_QUEUE_INIT(&hciCoreCb.aclQueue);
   2608e:	4b18      	ldr	r3, [pc, #96]	; (260f0 <HciCoreInit+0x68>)
   26090:	2200      	movs	r2, #0
   26092:	665a      	str	r2, [r3, #100]	; 0x64
   26094:	4b16      	ldr	r3, [pc, #88]	; (260f0 <HciCoreInit+0x68>)
   26096:	2200      	movs	r2, #0
   26098:	669a      	str	r2, [r3, #104]	; 0x68

  for (i = 0; i < DM_CONN_MAX; i++)
   2609a:	2300      	movs	r3, #0
   2609c:	71fb      	strb	r3, [r7, #7]
   2609e:	e00d      	b.n	260bc <HciCoreInit+0x34>
  {
    hciCoreCb.conn[i].handle = HCI_HANDLE_NONE;
   260a0:	79fa      	ldrb	r2, [r7, #7]
   260a2:	4913      	ldr	r1, [pc, #76]	; (260f0 <HciCoreInit+0x68>)
   260a4:	4613      	mov	r3, r2
   260a6:	00db      	lsls	r3, r3, #3
   260a8:	1a9b      	subs	r3, r3, r2
   260aa:	009b      	lsls	r3, r3, #2
   260ac:	440b      	add	r3, r1
   260ae:	3310      	adds	r3, #16
   260b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
   260b4:	801a      	strh	r2, [r3, #0]
  for (i = 0; i < DM_CONN_MAX; i++)
   260b6:	79fb      	ldrb	r3, [r7, #7]
   260b8:	3301      	adds	r3, #1
   260ba:	71fb      	strb	r3, [r7, #7]
   260bc:	79fb      	ldrb	r3, [r7, #7]
   260be:	2b02      	cmp	r3, #2
   260c0:	d9ee      	bls.n	260a0 <HciCoreInit+0x18>
  }

  hciCoreCb.maxRxAclLen = HCI_MAX_RX_ACL_LEN;
   260c2:	4b0b      	ldr	r3, [pc, #44]	; (260f0 <HciCoreInit+0x68>)
   260c4:	221b      	movs	r2, #27
   260c6:	f8a3 2070 	strh.w	r2, [r3, #112]	; 0x70
  hciCoreCb.aclQueueHi = HCI_ACL_QUEUE_HI;
   260ca:	4b09      	ldr	r3, [pc, #36]	; (260f0 <HciCoreInit+0x68>)
   260cc:	220e      	movs	r2, #14
   260ce:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
  hciCoreCb.aclQueueLo = HCI_ACL_QUEUE_LO;
   260d2:	4b07      	ldr	r3, [pc, #28]	; (260f0 <HciCoreInit+0x68>)
   260d4:	220d      	movs	r2, #13
   260d6:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
      // B0 has only less internal ACL buffers
      hciCoreCb.aclQueueHi--;
      hciCoreCb.aclQueueLo--;
    }
  #endif
  hciCoreCb.extResetSeq = NULL;
   260da:	4b05      	ldr	r3, [pc, #20]	; (260f0 <HciCoreInit+0x68>)
   260dc:	2200      	movs	r2, #0
   260de:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

  hciCoreInit();
   260e2:	f000 f8d1 	bl	26288 <hciCoreInit>
}
   260e6:	bf00      	nop
   260e8:	3708      	adds	r7, #8
   260ea:	46bd      	mov	sp, r7
   260ec:	bd80      	pop	{r7, pc}
   260ee:	bf00      	nop
   260f0:	1001134c 	.word	0x1001134c

000260f4 <HciResetSequence>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciResetSequence(void)
{
   260f4:	b580      	push	{r7, lr}
   260f6:	b084      	sub	sp, #16
   260f8:	af00      	add	r7, sp, #0
  uint8_t         *pBuf;
  wsfHandlerId_t    handlerId;

  uint8_t         i;
  hciCoreConn_t   *pConn = hciCoreCb.conn;
   260fa:	4b24      	ldr	r3, [pc, #144]	; (2618c <HciResetSequence+0x98>)
   260fc:	60bb      	str	r3, [r7, #8]

  // free any pending incoming packets
  while ((pBuf = WsfMsgDeq(&hciCb.rxQueue, &handlerId)) != NULL)
   260fe:	e002      	b.n	26106 <HciResetSequence+0x12>
  {
    /* Free buffer */
    WsfMsgFree(pBuf);
   26100:	6878      	ldr	r0, [r7, #4]
   26102:	f006 ffeb 	bl	2d0dc <WsfMsgFree>
  while ((pBuf = WsfMsgDeq(&hciCb.rxQueue, &handlerId)) != NULL)
   26106:	1cfb      	adds	r3, r7, #3
   26108:	4619      	mov	r1, r3
   2610a:	4821      	ldr	r0, [pc, #132]	; (26190 <HciResetSequence+0x9c>)
   2610c:	f007 f820 	bl	2d150 <WsfMsgDeq>
   26110:	6078      	str	r0, [r7, #4]
   26112:	687b      	ldr	r3, [r7, #4]
   26114:	2b00      	cmp	r3, #0
   26116:	d1f3      	bne.n	26100 <HciResetSequence+0xc>
  }

  HCI_TRACE_INFO0("reset sequence");
  // free any pending tx packets
  /* find connection struct */
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   26118:	2303      	movs	r3, #3
   2611a:	73fb      	strb	r3, [r7, #15]
   2611c:	e029      	b.n	26172 <HciResetSequence+0x7e>
  {
    /* free any fragmenting ACL packet */
    if (pConn->pTxAclPkt != NULL)
   2611e:	68bb      	ldr	r3, [r7, #8]
   26120:	681b      	ldr	r3, [r3, #0]
   26122:	2b00      	cmp	r3, #0
   26124:	d007      	beq.n	26136 <HciResetSequence+0x42>
    {
      WsfMsgFree(pConn->pTxAclPkt);
   26126:	68bb      	ldr	r3, [r7, #8]
   26128:	681b      	ldr	r3, [r3, #0]
   2612a:	4618      	mov	r0, r3
   2612c:	f006 ffd6 	bl	2d0dc <WsfMsgFree>
      pConn->pTxAclPkt = NULL;
   26130:	68bb      	ldr	r3, [r7, #8]
   26132:	2200      	movs	r2, #0
   26134:	601a      	str	r2, [r3, #0]
    }
    pConn->fragmenting = FALSE;
   26136:	68bb      	ldr	r3, [r7, #8]
   26138:	2200      	movs	r2, #0
   2613a:	759a      	strb	r2, [r3, #22]

    if (pConn->pRxAclPkt != NULL)
   2613c:	68bb      	ldr	r3, [r7, #8]
   2613e:	689b      	ldr	r3, [r3, #8]
   26140:	2b00      	cmp	r3, #0
   26142:	d007      	beq.n	26154 <HciResetSequence+0x60>
    {
      WsfMsgFree(pConn->pRxAclPkt);
   26144:	68bb      	ldr	r3, [r7, #8]
   26146:	689b      	ldr	r3, [r3, #8]
   26148:	4618      	mov	r0, r3
   2614a:	f006 ffc7 	bl	2d0dc <WsfMsgFree>
      pConn->pRxAclPkt = NULL;
   2614e:	68bb      	ldr	r3, [r7, #8]
   26150:	2200      	movs	r2, #0
   26152:	609a      	str	r2, [r3, #8]
    }

    /* free structure */
    pConn->handle = HCI_HANDLE_NONE;
   26154:	68bb      	ldr	r3, [r7, #8]
   26156:	f64f 72ff 	movw	r2, #65535	; 0xffff
   2615a:	821a      	strh	r2, [r3, #16]

    /* optional: iterate through tx ACL queue and free any buffers with this handle */

    /* outstanding buffers are now available; service TX data path */
    hciCoreTxReady(pConn->outBufs);
   2615c:	68bb      	ldr	r3, [r7, #8]
   2615e:	7e5b      	ldrb	r3, [r3, #25]
   26160:	4618      	mov	r0, r3
   26162:	f7ff fd49 	bl	25bf8 <hciCoreTxReady>
  for (i = DM_CONN_MAX; i > 0; i--, pConn++)
   26166:	7bfb      	ldrb	r3, [r7, #15]
   26168:	3b01      	subs	r3, #1
   2616a:	73fb      	strb	r3, [r7, #15]
   2616c:	68bb      	ldr	r3, [r7, #8]
   2616e:	331c      	adds	r3, #28
   26170:	60bb      	str	r3, [r7, #8]
   26172:	7bfb      	ldrb	r3, [r7, #15]
   26174:	2b00      	cmp	r3, #0
   26176:	d1d2      	bne.n	2611e <HciResetSequence+0x2a>

  }

  /* set resetting state */
  hciCb.resetting = TRUE;
   26178:	4b05      	ldr	r3, [pc, #20]	; (26190 <HciResetSequence+0x9c>)
   2617a:	2201      	movs	r2, #1
   2617c:	765a      	strb	r2, [r3, #25]

  /* start the reset sequence */
  hciCoreResetStart();
   2617e:	f003 f947 	bl	29410 <hciCoreResetStart>
}
   26182:	bf00      	nop
   26184:	3710      	adds	r7, #16
   26186:	46bd      	mov	sp, r7
   26188:	bd80      	pop	{r7, pc}
   2618a:	bf00      	nop
   2618c:	1001134c 	.word	0x1001134c
   26190:	100116ec 	.word	0x100116ec

00026194 <HciSetMaxRxAclLen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciSetMaxRxAclLen(uint16_t len)
{
   26194:	b480      	push	{r7}
   26196:	b083      	sub	sp, #12
   26198:	af00      	add	r7, sp, #0
   2619a:	4603      	mov	r3, r0
   2619c:	80fb      	strh	r3, [r7, #6]
  hciCoreCb.maxRxAclLen = len;
   2619e:	4a05      	ldr	r2, [pc, #20]	; (261b4 <HciSetMaxRxAclLen+0x20>)
   261a0:	88fb      	ldrh	r3, [r7, #6]
   261a2:	f8a2 3070 	strh.w	r3, [r2, #112]	; 0x70
}
   261a6:	bf00      	nop
   261a8:	370c      	adds	r7, #12
   261aa:	46bd      	mov	sp, r7
   261ac:	f85d 7b04 	ldr.w	r7, [sp], #4
   261b0:	4770      	bx	lr
   261b2:	bf00      	nop
   261b4:	1001134c 	.word	0x1001134c

000261b8 <HciSendAclData>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciSendAclData(uint8_t *pData)
{
   261b8:	b590      	push	{r4, r7, lr}
   261ba:	b085      	sub	sp, #20
   261bc:	af00      	add	r7, sp, #0
   261be:	6078      	str	r0, [r7, #4]
  uint16_t        handle;
  uint16_t        len;
  hciCoreConn_t   *pConn;

  /* parse handle and length */
  BYTES_TO_UINT16(handle, pData);
   261c0:	687b      	ldr	r3, [r7, #4]
   261c2:	781b      	ldrb	r3, [r3, #0]
   261c4:	b29a      	uxth	r2, r3
   261c6:	687b      	ldr	r3, [r7, #4]
   261c8:	3301      	adds	r3, #1
   261ca:	781b      	ldrb	r3, [r3, #0]
   261cc:	b29b      	uxth	r3, r3
   261ce:	021b      	lsls	r3, r3, #8
   261d0:	b29b      	uxth	r3, r3
   261d2:	4413      	add	r3, r2
   261d4:	81fb      	strh	r3, [r7, #14]
  BYTES_TO_UINT16(len, &pData[2]);
   261d6:	687b      	ldr	r3, [r7, #4]
   261d8:	3302      	adds	r3, #2
   261da:	781b      	ldrb	r3, [r3, #0]
   261dc:	b29a      	uxth	r2, r3
   261de:	687b      	ldr	r3, [r7, #4]
   261e0:	3303      	adds	r3, #3
   261e2:	781b      	ldrb	r3, [r3, #0]
   261e4:	b29b      	uxth	r3, r3
   261e6:	021b      	lsls	r3, r3, #8
   261e8:	b29b      	uxth	r3, r3
   261ea:	4413      	add	r3, r2
   261ec:	81bb      	strh	r3, [r7, #12]

  /* look up connection structure */
  if ((pConn = hciCoreConnByHandle(handle)) != NULL)
   261ee:	89fb      	ldrh	r3, [r7, #14]
   261f0:	4618      	mov	r0, r3
   261f2:	f7ff fc75 	bl	25ae0 <hciCoreConnByHandle>
   261f6:	60b8      	str	r0, [r7, #8]
   261f8:	68bb      	ldr	r3, [r7, #8]
   261fa:	2b00      	cmp	r3, #0
   261fc:	d036      	beq.n	2626c <HciSendAclData+0xb4>
  {
    /* queue data - message handler ID 'handerId' not used */
    WsfMsgEnq(&hciCoreCb.aclQueue, 0, pData);
   261fe:	687a      	ldr	r2, [r7, #4]
   26200:	2100      	movs	r1, #0
   26202:	481e      	ldr	r0, [pc, #120]	; (2627c <HciSendAclData+0xc4>)
   26204:	f006 ff8f 	bl	2d126 <WsfMsgEnq>

    HCI_TRACE_WARN1("enq acl pkt %x", pData);

    /* if queue not empty and buffers available */
    if ((WsfQueueCount(&hciCoreCb.aclQueue) == 1) && hciCoreCb.availBufs > 0)
   26208:	481c      	ldr	r0, [pc, #112]	; (2627c <HciSendAclData+0xc4>)
   2620a:	f007 fa3a 	bl	2d682 <WsfQueueCount>
   2620e:	4603      	mov	r3, r0
   26210:	2b01      	cmp	r3, #1
   26212:	d107      	bne.n	26224 <HciSendAclData+0x6c>
   26214:	4b1a      	ldr	r3, [pc, #104]	; (26280 <HciSendAclData+0xc8>)
   26216:	f893 3076 	ldrb.w	r3, [r3, #118]	; 0x76
   2621a:	2b00      	cmp	r3, #0
   2621c:	d002      	beq.n	26224 <HciSendAclData+0x6c>
    {
      /* send data */
      hciCoreTxReady(0);
   2621e:	2000      	movs	r0, #0
   26220:	f7ff fcea 	bl	25bf8 <hciCoreTxReady>
    }

    /* increment buffer queue count for this connection with consideration for HCI fragmentation */
    pConn->queuedBufs += ((len - 1) / HciGetBufSize()) + 1;
   26224:	89bb      	ldrh	r3, [r7, #12]
   26226:	1e5c      	subs	r4, r3, #1
   26228:	f000 f904 	bl	26434 <HciGetBufSize>
   2622c:	4603      	mov	r3, r0
   2622e:	fb94 f3f3 	sdiv	r3, r4, r3
   26232:	1c59      	adds	r1, r3, #1
   26234:	68bb      	ldr	r3, [r7, #8]
   26236:	7e1a      	ldrb	r2, [r3, #24]
   26238:	b2cb      	uxtb	r3, r1
   2623a:	4413      	add	r3, r2
   2623c:	b2da      	uxtb	r2, r3
   2623e:	68bb      	ldr	r3, [r7, #8]
   26240:	761a      	strb	r2, [r3, #24]

    /* manage flow control to stack */
    if (pConn->queuedBufs >= hciCoreCb.aclQueueHi && pConn->flowDisabled == FALSE)
   26242:	68bb      	ldr	r3, [r7, #8]
   26244:	7e1a      	ldrb	r2, [r3, #24]
   26246:	4b0e      	ldr	r3, [pc, #56]	; (26280 <HciSendAclData+0xc8>)
   26248:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
   2624c:	429a      	cmp	r2, r3
   2624e:	d310      	bcc.n	26272 <HciSendAclData+0xba>
   26250:	68bb      	ldr	r3, [r7, #8]
   26252:	7ddb      	ldrb	r3, [r3, #23]
   26254:	2b00      	cmp	r3, #0
   26256:	d10c      	bne.n	26272 <HciSendAclData+0xba>
    {
      pConn->flowDisabled = TRUE;
   26258:	68bb      	ldr	r3, [r7, #8]
   2625a:	2201      	movs	r2, #1
   2625c:	75da      	strb	r2, [r3, #23]
      (*hciCb.flowCback)(handle, TRUE);
   2625e:	4b09      	ldr	r3, [pc, #36]	; (26284 <HciSendAclData+0xcc>)
   26260:	695b      	ldr	r3, [r3, #20]
   26262:	89fa      	ldrh	r2, [r7, #14]
   26264:	2101      	movs	r1, #1
   26266:	4610      	mov	r0, r2
   26268:	4798      	blx	r3
    /* discard buffer */
    WsfMsgFree(pData);

    HCI_TRACE_WARN1("HciSendAclData discarding buffer, handle=%u", handle);
  }
}
   2626a:	e002      	b.n	26272 <HciSendAclData+0xba>
    WsfMsgFree(pData);
   2626c:	6878      	ldr	r0, [r7, #4]
   2626e:	f006 ff35 	bl	2d0dc <WsfMsgFree>
}
   26272:	bf00      	nop
   26274:	3714      	adds	r7, #20
   26276:	46bd      	mov	sp, r7
   26278:	bd90      	pop	{r4, r7, pc}
   2627a:	bf00      	nop
   2627c:	100113b0 	.word	0x100113b0
   26280:	1001134c 	.word	0x1001134c
   26284:	100116ec 	.word	0x100116ec

00026288 <hciCoreInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreInit(void)
{
   26288:	b580      	push	{r7, lr}
   2628a:	af00      	add	r7, sp, #0
  hciCmdInit();
   2628c:	f7fe fd80 	bl	24d90 <hciCmdInit>
}
   26290:	bf00      	nop
   26292:	bd80      	pop	{r7, pc}

00026294 <hciCoreNumCmplPkts>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreNumCmplPkts(uint8_t *pMsg)
{
   26294:	b580      	push	{r7, lr}
   26296:	b086      	sub	sp, #24
   26298:	af00      	add	r7, sp, #0
   2629a:	6078      	str	r0, [r7, #4]
  uint8_t         numHandles;
  uint16_t        bufs;
  uint16_t        handle;
  uint8_t         availBufs = 0;
   2629c:	2300      	movs	r3, #0
   2629e:	75bb      	strb	r3, [r7, #22]
  hciCoreConn_t   *pConn;

  /* parse number of handles */
  BSTREAM_TO_UINT8(numHandles, pMsg);
   262a0:	687b      	ldr	r3, [r7, #4]
   262a2:	1c5a      	adds	r2, r3, #1
   262a4:	607a      	str	r2, [r7, #4]
   262a6:	781b      	ldrb	r3, [r3, #0]
   262a8:	75fb      	strb	r3, [r7, #23]

  /* for each handle in event */
  while (numHandles-- > 0)
   262aa:	e04c      	b.n	26346 <hciCoreNumCmplPkts+0xb2>
  {
    /* parse handle and number of buffers */
    BSTREAM_TO_UINT16(handle, pMsg);
   262ac:	687b      	ldr	r3, [r7, #4]
   262ae:	781b      	ldrb	r3, [r3, #0]
   262b0:	b29a      	uxth	r2, r3
   262b2:	687b      	ldr	r3, [r7, #4]
   262b4:	3301      	adds	r3, #1
   262b6:	781b      	ldrb	r3, [r3, #0]
   262b8:	b29b      	uxth	r3, r3
   262ba:	021b      	lsls	r3, r3, #8
   262bc:	b29b      	uxth	r3, r3
   262be:	4413      	add	r3, r2
   262c0:	82bb      	strh	r3, [r7, #20]
   262c2:	687b      	ldr	r3, [r7, #4]
   262c4:	3302      	adds	r3, #2
   262c6:	607b      	str	r3, [r7, #4]
    BSTREAM_TO_UINT16(bufs, pMsg);
   262c8:	687b      	ldr	r3, [r7, #4]
   262ca:	781b      	ldrb	r3, [r3, #0]
   262cc:	b29a      	uxth	r2, r3
   262ce:	687b      	ldr	r3, [r7, #4]
   262d0:	3301      	adds	r3, #1
   262d2:	781b      	ldrb	r3, [r3, #0]
   262d4:	b29b      	uxth	r3, r3
   262d6:	021b      	lsls	r3, r3, #8
   262d8:	b29b      	uxth	r3, r3
   262da:	4413      	add	r3, r2
   262dc:	827b      	strh	r3, [r7, #18]
   262de:	687b      	ldr	r3, [r7, #4]
   262e0:	3302      	adds	r3, #2
   262e2:	607b      	str	r3, [r7, #4]

    if ((pConn = hciCoreConnByHandle(handle)) != NULL)
   262e4:	8abb      	ldrh	r3, [r7, #20]
   262e6:	4618      	mov	r0, r3
   262e8:	f7ff fbfa 	bl	25ae0 <hciCoreConnByHandle>
   262ec:	60f8      	str	r0, [r7, #12]
   262ee:	68fb      	ldr	r3, [r7, #12]
   262f0:	2b00      	cmp	r3, #0
   262f2:	d028      	beq.n	26346 <hciCoreNumCmplPkts+0xb2>
    {
      /* decrement outstanding buffer count to controller */
      pConn->outBufs -= (uint8_t) bufs;
   262f4:	68fb      	ldr	r3, [r7, #12]
   262f6:	7e5a      	ldrb	r2, [r3, #25]
   262f8:	8a7b      	ldrh	r3, [r7, #18]
   262fa:	b2db      	uxtb	r3, r3
   262fc:	1ad3      	subs	r3, r2, r3
   262fe:	b2da      	uxtb	r2, r3
   26300:	68fb      	ldr	r3, [r7, #12]
   26302:	765a      	strb	r2, [r3, #25]

      /* decrement queued buffer count for this connection */
      pConn->queuedBufs -= (uint8_t) bufs;
   26304:	68fb      	ldr	r3, [r7, #12]
   26306:	7e1a      	ldrb	r2, [r3, #24]
   26308:	8a7b      	ldrh	r3, [r7, #18]
   2630a:	b2db      	uxtb	r3, r3
   2630c:	1ad3      	subs	r3, r2, r3
   2630e:	b2da      	uxtb	r2, r3
   26310:	68fb      	ldr	r3, [r7, #12]
   26312:	761a      	strb	r2, [r3, #24]

      /* increment available buffer count */
      availBufs += (uint8_t) bufs;
   26314:	8a7b      	ldrh	r3, [r7, #18]
   26316:	b2da      	uxtb	r2, r3
   26318:	7dbb      	ldrb	r3, [r7, #22]
   2631a:	4413      	add	r3, r2
   2631c:	75bb      	strb	r3, [r7, #22]

      /* call flow control callback */
      if (pConn->flowDisabled && pConn->queuedBufs <= hciCoreCb.aclQueueLo)
   2631e:	68fb      	ldr	r3, [r7, #12]
   26320:	7ddb      	ldrb	r3, [r3, #23]
   26322:	2b00      	cmp	r3, #0
   26324:	d00f      	beq.n	26346 <hciCoreNumCmplPkts+0xb2>
   26326:	68fb      	ldr	r3, [r7, #12]
   26328:	7e1a      	ldrb	r2, [r3, #24]
   2632a:	4b0d      	ldr	r3, [pc, #52]	; (26360 <hciCoreNumCmplPkts+0xcc>)
   2632c:	f893 3075 	ldrb.w	r3, [r3, #117]	; 0x75
   26330:	429a      	cmp	r2, r3
   26332:	d808      	bhi.n	26346 <hciCoreNumCmplPkts+0xb2>
      {
        pConn->flowDisabled = FALSE;
   26334:	68fb      	ldr	r3, [r7, #12]
   26336:	2200      	movs	r2, #0
   26338:	75da      	strb	r2, [r3, #23]
        (*hciCb.flowCback)(handle, FALSE);
   2633a:	4b0a      	ldr	r3, [pc, #40]	; (26364 <hciCoreNumCmplPkts+0xd0>)
   2633c:	695b      	ldr	r3, [r3, #20]
   2633e:	8aba      	ldrh	r2, [r7, #20]
   26340:	2100      	movs	r1, #0
   26342:	4610      	mov	r0, r2
   26344:	4798      	blx	r3
  while (numHandles-- > 0)
   26346:	7dfb      	ldrb	r3, [r7, #23]
   26348:	1e5a      	subs	r2, r3, #1
   2634a:	75fa      	strb	r2, [r7, #23]
   2634c:	2b00      	cmp	r3, #0
   2634e:	d1ad      	bne.n	262ac <hciCoreNumCmplPkts+0x18>
      }
    }
  }

  /* service TX data path */
  hciCoreTxReady(availBufs);
   26350:	7dbb      	ldrb	r3, [r7, #22]
   26352:	4618      	mov	r0, r3
   26354:	f7ff fc50 	bl	25bf8 <hciCoreTxReady>
}
   26358:	bf00      	nop
   2635a:	3718      	adds	r7, #24
   2635c:	46bd      	mov	sp, r7
   2635e:	bd80      	pop	{r7, pc}
   26360:	1001134c 	.word	0x1001134c
   26364:	100116ec 	.word	0x100116ec

00026368 <hciCoreRecv>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreRecv(uint8_t msgType, uint8_t *pCoreRecvMsg)
{
   26368:	b580      	push	{r7, lr}
   2636a:	b082      	sub	sp, #8
   2636c:	af00      	add	r7, sp, #0
   2636e:	4603      	mov	r3, r0
   26370:	6039      	str	r1, [r7, #0]
   26372:	71fb      	strb	r3, [r7, #7]
  {
    HCI_PDUMP_RX_ACL(*(pCoreRecvMsg + 2) + HCI_ACL_HDR_LEN, pCoreRecvMsg);
  }

  /* queue buffer */
  WsfMsgEnq(&hciCb.rxQueue, (wsfHandlerId_t) msgType, pCoreRecvMsg);
   26374:	79fb      	ldrb	r3, [r7, #7]
   26376:	683a      	ldr	r2, [r7, #0]
   26378:	4619      	mov	r1, r3
   2637a:	4806      	ldr	r0, [pc, #24]	; (26394 <hciCoreRecv+0x2c>)
   2637c:	f006 fed3 	bl	2d126 <WsfMsgEnq>

  /* set event */
  WsfSetEvent(hciCb.handlerId, HCI_EVT_RX);
   26380:	4b04      	ldr	r3, [pc, #16]	; (26394 <hciCoreRecv+0x2c>)
   26382:	7e1b      	ldrb	r3, [r3, #24]
   26384:	2101      	movs	r1, #1
   26386:	4618      	mov	r0, r3
   26388:	f006 ff94 	bl	2d2b4 <WsfSetEvent>
}
   2638c:	bf00      	nop
   2638e:	3708      	adds	r7, #8
   26390:	46bd      	mov	sp, r7
   26392:	bd80      	pop	{r7, pc}
   26394:	100116ec 	.word	0x100116ec

00026398 <HciCoreHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciCoreHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   26398:	b580      	push	{r7, lr}
   2639a:	b084      	sub	sp, #16
   2639c:	af00      	add	r7, sp, #0
   2639e:	4603      	mov	r3, r0
   263a0:	6039      	str	r1, [r7, #0]
   263a2:	71fb      	strb	r3, [r7, #7]
  uint8_t         *pBuf;
  wsfHandlerId_t  handlerId;
  
  /* Handle message */
  if (pMsg != NULL)
   263a4:	683b      	ldr	r3, [r7, #0]
   263a6:	2b00      	cmp	r3, #0
   263a8:	d007      	beq.n	263ba <HciCoreHandler+0x22>
  {
    /* Handle HCI command timeout */
    if (pMsg->event == HCI_MSG_CMD_TIMEOUT)
   263aa:	683b      	ldr	r3, [r7, #0]
   263ac:	789b      	ldrb	r3, [r3, #2]
   263ae:	2b01      	cmp	r3, #1
   263b0:	d12f      	bne.n	26412 <HciCoreHandler+0x7a>
    {
      hciCmdTimeout(pMsg);
   263b2:	6838      	ldr	r0, [r7, #0]
   263b4:	f7fe fd08 	bl	24dc8 <hciCmdTimeout>
          hciCb.aclCback(pBuf);
        }
      }
    }
  }
}
   263b8:	e02b      	b.n	26412 <HciCoreHandler+0x7a>
  else if (event & HCI_EVT_RX)
   263ba:	79fb      	ldrb	r3, [r7, #7]
   263bc:	f003 0301 	and.w	r3, r3, #1
   263c0:	2b00      	cmp	r3, #0
   263c2:	d026      	beq.n	26412 <HciCoreHandler+0x7a>
    while ((pBuf = WsfMsgDeq(&hciCb.rxQueue, &handlerId)) != NULL)
   263c4:	e01b      	b.n	263fe <HciCoreHandler+0x66>
      if (handlerId == HCI_EVT_TYPE)
   263c6:	7afb      	ldrb	r3, [r7, #11]
   263c8:	2b04      	cmp	r3, #4
   263ca:	d10d      	bne.n	263e8 <HciCoreHandler+0x50>
        hciEvtProcessMsg(pBuf);
   263cc:	68f8      	ldr	r0, [r7, #12]
   263ce:	f002 fbe1 	bl	28b94 <hciEvtProcessMsg>
        if (hciCb.resetting)
   263d2:	4b12      	ldr	r3, [pc, #72]	; (2641c <HciCoreHandler+0x84>)
   263d4:	7e5b      	ldrb	r3, [r3, #25]
   263d6:	2b00      	cmp	r3, #0
   263d8:	d002      	beq.n	263e0 <HciCoreHandler+0x48>
          hciCoreResetSequence(pBuf);
   263da:	68f8      	ldr	r0, [r7, #12]
   263dc:	f003 f820 	bl	29420 <hciCoreResetSequence>
        WsfMsgFree(pBuf);
   263e0:	68f8      	ldr	r0, [r7, #12]
   263e2:	f006 fe7b 	bl	2d0dc <WsfMsgFree>
   263e6:	e00a      	b.n	263fe <HciCoreHandler+0x66>
        if ((pBuf = hciCoreAclReassembly(pBuf)) != NULL)
   263e8:	68f8      	ldr	r0, [r7, #12]
   263ea:	f7ff fd63 	bl	25eb4 <hciCoreAclReassembly>
   263ee:	60f8      	str	r0, [r7, #12]
   263f0:	68fb      	ldr	r3, [r7, #12]
   263f2:	2b00      	cmp	r3, #0
   263f4:	d003      	beq.n	263fe <HciCoreHandler+0x66>
          hciCb.aclCback(pBuf);
   263f6:	4b09      	ldr	r3, [pc, #36]	; (2641c <HciCoreHandler+0x84>)
   263f8:	691b      	ldr	r3, [r3, #16]
   263fa:	68f8      	ldr	r0, [r7, #12]
   263fc:	4798      	blx	r3
    while ((pBuf = WsfMsgDeq(&hciCb.rxQueue, &handlerId)) != NULL)
   263fe:	f107 030b 	add.w	r3, r7, #11
   26402:	4619      	mov	r1, r3
   26404:	4805      	ldr	r0, [pc, #20]	; (2641c <HciCoreHandler+0x84>)
   26406:	f006 fea3 	bl	2d150 <WsfMsgDeq>
   2640a:	60f8      	str	r0, [r7, #12]
   2640c:	68fb      	ldr	r3, [r7, #12]
   2640e:	2b00      	cmp	r3, #0
   26410:	d1d9      	bne.n	263c6 <HciCoreHandler+0x2e>
}
   26412:	bf00      	nop
   26414:	3710      	adds	r7, #16
   26416:	46bd      	mov	sp, r7
   26418:	bd80      	pop	{r7, pc}
   2641a:	bf00      	nop
   2641c:	100116ec 	.word	0x100116ec

00026420 <HciGetBdAddr>:
 *
 *  \return Pointer to the BD address.
 */
/*************************************************************************************************/
uint8_t *HciGetBdAddr(void)
{
   26420:	b480      	push	{r7}
   26422:	af00      	add	r7, sp, #0
  return hciCoreCb.bdAddr;
   26424:	4b02      	ldr	r3, [pc, #8]	; (26430 <HciGetBdAddr+0x10>)
}
   26426:	4618      	mov	r0, r3
   26428:	46bd      	mov	sp, r7
   2642a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2642e:	4770      	bx	lr
   26430:	100113a8 	.word	0x100113a8

00026434 <HciGetBufSize>:
 *
 *  \return ACL buffer size.
 */
/*************************************************************************************************/
uint16_t HciGetBufSize(void)
{
   26434:	b480      	push	{r7}
   26436:	af00      	add	r7, sp, #0
  return hciCoreCb.bufSize;
   26438:	4b03      	ldr	r3, [pc, #12]	; (26448 <HciGetBufSize+0x14>)
   2643a:	f8b3 3072 	ldrh.w	r3, [r3, #114]	; 0x72
}
   2643e:	4618      	mov	r0, r3
   26440:	46bd      	mov	sp, r7
   26442:	f85d 7b04 	ldr.w	r7, [sp], #4
   26446:	4770      	bx	lr
   26448:	1001134c 	.word	0x1001134c

0002644c <HciGetLeSupFeat>:
 *
 *  \return Supported features.
 */
/*************************************************************************************************/
uint32_t HciGetLeSupFeat(void)
{
   2644c:	b480      	push	{r7}
   2644e:	af00      	add	r7, sp, #0
  // disable LL connection parameter update feature for a better
  // interoperability with Android phones (especially older Android OS).
  return hciCoreCb.leSupFeat & ~HCI_LE_SUP_FEAT_CONN_PARAM_REQ_PROC;
   26450:	4b04      	ldr	r3, [pc, #16]	; (26464 <HciGetLeSupFeat+0x18>)
   26452:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   26454:	f023 0302 	bic.w	r3, r3, #2
}
   26458:	4618      	mov	r0, r3
   2645a:	46bd      	mov	sp, r7
   2645c:	f85d 7b04 	ldr.w	r7, [sp], #4
   26460:	4770      	bx	lr
   26462:	bf00      	nop
   26464:	1001134c 	.word	0x1001134c

00026468 <HciGetMaxRxAclLen>:
 *
 *  \return ACL packet length.
 */
/*************************************************************************************************/
uint16_t HciGetMaxRxAclLen(void)
{
   26468:	b480      	push	{r7}
   2646a:	af00      	add	r7, sp, #0
  return hciCoreCb.maxRxAclLen;
   2646c:	4b03      	ldr	r3, [pc, #12]	; (2647c <HciGetMaxRxAclLen+0x14>)
   2646e:	f8b3 3070 	ldrh.w	r3, [r3, #112]	; 0x70
}
   26472:	4618      	mov	r0, r3
   26474:	46bd      	mov	sp, r7
   26476:	f85d 7b04 	ldr.w	r7, [sp], #4
   2647a:	4770      	bx	lr
   2647c:	1001134c 	.word	0x1001134c

00026480 <HciLlPrivacySupported>:
 *
 *  \return TRUE if LL Privacy is supported. FALSE, otherwise.
 */
/*************************************************************************************************/
bool_t HciLlPrivacySupported(void)
{
   26480:	b480      	push	{r7}
   26482:	af00      	add	r7, sp, #0
  return (hciCoreCb.resListSize > 0) ? TRUE : FALSE;
   26484:	4b06      	ldr	r3, [pc, #24]	; (264a0 <HciLlPrivacySupported+0x20>)
   26486:	f893 3081 	ldrb.w	r3, [r3, #129]	; 0x81
   2648a:	2b00      	cmp	r3, #0
   2648c:	bf14      	ite	ne
   2648e:	2301      	movne	r3, #1
   26490:	2300      	moveq	r3, #0
   26492:	b2db      	uxtb	r3, r3
}
   26494:	4618      	mov	r0, r3
   26496:	46bd      	mov	sp, r7
   26498:	f85d 7b04 	ldr.w	r7, [sp], #4
   2649c:	4770      	bx	lr
   2649e:	bf00      	nop
   264a0:	1001134c 	.word	0x1001134c

000264a4 <TimeStamp2Time>:
    "receive error packet exceed supervision timeout",
    "window size exceed half connection interval"
};

time_type_t TimeStamp2Time(uint32_t ms)
{
   264a4:	b480      	push	{r7}
   264a6:	b085      	sub	sp, #20
   264a8:	af00      	add	r7, sp, #0
   264aa:	6078      	str	r0, [r7, #4]
   264ac:	6039      	str	r1, [r7, #0]
    time_type_t time_ret;

    time_ret.t_ms  = ms%1000;
   264ae:	683a      	ldr	r2, [r7, #0]
   264b0:	4b1f      	ldr	r3, [pc, #124]	; (26530 <TimeStamp2Time+0x8c>)
   264b2:	fba3 1302 	umull	r1, r3, r3, r2
   264b6:	099b      	lsrs	r3, r3, #6
   264b8:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   264bc:	fb01 f303 	mul.w	r3, r1, r3
   264c0:	1ad3      	subs	r3, r2, r3
   264c2:	b29b      	uxth	r3, r3
   264c4:	813b      	strh	r3, [r7, #8]
    time_ret.t_sec = ms/1000%60;
   264c6:	683b      	ldr	r3, [r7, #0]
   264c8:	4a19      	ldr	r2, [pc, #100]	; (26530 <TimeStamp2Time+0x8c>)
   264ca:	fba2 2303 	umull	r2, r3, r2, r3
   264ce:	0999      	lsrs	r1, r3, #6
   264d0:	4b18      	ldr	r3, [pc, #96]	; (26534 <TimeStamp2Time+0x90>)
   264d2:	fba3 2301 	umull	r2, r3, r3, r1
   264d6:	095a      	lsrs	r2, r3, #5
   264d8:	4613      	mov	r3, r2
   264da:	011b      	lsls	r3, r3, #4
   264dc:	1a9b      	subs	r3, r3, r2
   264de:	009b      	lsls	r3, r3, #2
   264e0:	1aca      	subs	r2, r1, r3
   264e2:	b2d3      	uxtb	r3, r2
   264e4:	72bb      	strb	r3, [r7, #10]
    time_ret.t_min = ms/1000/60%60;
   264e6:	683b      	ldr	r3, [r7, #0]
   264e8:	4a13      	ldr	r2, [pc, #76]	; (26538 <TimeStamp2Time+0x94>)
   264ea:	fba2 2303 	umull	r2, r3, r2, r3
   264ee:	0b99      	lsrs	r1, r3, #14
   264f0:	4b10      	ldr	r3, [pc, #64]	; (26534 <TimeStamp2Time+0x90>)
   264f2:	fba3 2301 	umull	r2, r3, r3, r1
   264f6:	095a      	lsrs	r2, r3, #5
   264f8:	4613      	mov	r3, r2
   264fa:	011b      	lsls	r3, r3, #4
   264fc:	1a9b      	subs	r3, r3, r2
   264fe:	009b      	lsls	r3, r3, #2
   26500:	1aca      	subs	r2, r1, r3
   26502:	b2d3      	uxtb	r3, r2
   26504:	72fb      	strb	r3, [r7, #11]
    time_ret.t_hur = ms/1000/60/60;
   26506:	683b      	ldr	r3, [r7, #0]
   26508:	4a0c      	ldr	r2, [pc, #48]	; (2653c <TimeStamp2Time+0x98>)
   2650a:	fba2 2303 	umull	r2, r3, r2, r3
   2650e:	0d5b      	lsrs	r3, r3, #21
   26510:	b2db      	uxtb	r3, r3
   26512:	733b      	strb	r3, [r7, #12]

    return time_ret;
   26514:	687b      	ldr	r3, [r7, #4]
   26516:	461a      	mov	r2, r3
   26518:	f107 0308 	add.w	r3, r7, #8
   2651c:	6818      	ldr	r0, [r3, #0]
   2651e:	6010      	str	r0, [r2, #0]
   26520:	889b      	ldrh	r3, [r3, #4]
   26522:	8093      	strh	r3, [r2, #4]
}
   26524:	6878      	ldr	r0, [r7, #4]
   26526:	3714      	adds	r7, #20
   26528:	46bd      	mov	sp, r7
   2652a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2652e:	4770      	bx	lr
   26530:	10624dd3 	.word	0x10624dd3
   26534:	88888889 	.word	0x88888889
   26538:	45e7b273 	.word	0x45e7b273
   2653c:	95217cb1 	.word	0x95217cb1

00026540 <hci_process_trace_data>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hci_process_trace_data(uint8_t *dbg_data, uint32_t len)
{
   26540:	b5b0      	push	{r4, r5, r7, lr}
   26542:	b094      	sub	sp, #80	; 0x50
   26544:	af04      	add	r7, sp, #16
   26546:	6078      	str	r0, [r7, #4]
   26548:	6039      	str	r1, [r7, #0]
    uint8_t *data_buf = NULL;
   2654a:	2300      	movs	r3, #0
   2654c:	63bb      	str	r3, [r7, #56]	; 0x38
    uint8_t packet_type = 0;
   2654e:	2300      	movs	r3, #0
   26550:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    uint32_t bitmap = 0;
   26554:	2300      	movs	r3, #0
   26556:	633b      	str	r3, [r7, #48]	; 0x30

    data_buf = dbg_data;
   26558:	687b      	ldr	r3, [r7, #4]
   2655a:	63bb      	str	r3, [r7, #56]	; 0x38
    packet_type = *data_buf;
   2655c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2655e:	781b      	ldrb	r3, [r3, #0]
   26560:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    data_buf++;
   26564:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26566:	3301      	adds	r3, #1
   26568:	63bb      	str	r3, [r7, #56]	; 0x38

    switch(packet_type)
   2656a:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
   2656e:	2b01      	cmp	r3, #1
   26570:	d01d      	beq.n	265ae <hci_process_trace_data+0x6e>
   26572:	2b03      	cmp	r3, #3
   26574:	f040 811f 	bne.w	267b6 <hci_process_trace_data+0x276>
    {
        // format: 1packet type, 2cofig word, 4bitmap
        case TRACE_ACK:
            data_buf += TRC_CFG_WORD_LEN; // skip 2 bytes config word length
   26578:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2657a:	3302      	adds	r3, #2
   2657c:	63bb      	str	r3, [r7, #56]	; 0x38
            BYTES_TO_UINT32(bitmap, data_buf);
   2657e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26580:	781b      	ldrb	r3, [r3, #0]
   26582:	461a      	mov	r2, r3
   26584:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26586:	3301      	adds	r3, #1
   26588:	781b      	ldrb	r3, [r3, #0]
   2658a:	021b      	lsls	r3, r3, #8
   2658c:	441a      	add	r2, r3
   2658e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26590:	3302      	adds	r3, #2
   26592:	781b      	ldrb	r3, [r3, #0]
   26594:	041b      	lsls	r3, r3, #16
   26596:	441a      	add	r2, r3
   26598:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2659a:	3303      	adds	r3, #3
   2659c:	781b      	ldrb	r3, [r3, #0]
   2659e:	061b      	lsls	r3, r3, #24
   265a0:	4413      	add	r3, r2
   265a2:	633b      	str	r3, [r7, #48]	; 0x30
            am_util_debug_printf("Hci config trace ack, bitmap:0x%08x\n", bitmap);
   265a4:	6b39      	ldr	r1, [r7, #48]	; 0x30
   265a6:	4888      	ldr	r0, [pc, #544]	; (267c8 <hci_process_trace_data+0x288>)
   265a8:	f7f4 fafa 	bl	1aba0 <am_util_stdio_printf>
        break;
   265ac:	e107      	b.n	267be <hci_process_trace_data+0x27e>

        // format:1 packet typye, 2 length,2 sequence number,4 timestamp,
        // 1 trace type, 2 message id,2 dest id,2 opcode, 2 length
        case TRACE:
        {
            uint32_t ts = 0;
   265ae:	2300      	movs	r3, #0
   265b0:	62fb      	str	r3, [r7, #44]	; 0x2c
            uint8_t trace_type = 0;
   265b2:	2300      	movs	r3, #0
   265b4:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            uint32_t ms = 0;
   265b8:	2300      	movs	r3, #0
   265ba:	627b      	str	r3, [r7, #36]	; 0x24
            uint32_t sec = 0;
   265bc:	2300      	movs	r3, #0
   265be:	623b      	str	r3, [r7, #32]
            uint8_t min = 0;
   265c0:	2300      	movs	r3, #0
   265c2:	77fb      	strb	r3, [r7, #31]
            uint8_t hour = 0;
   265c4:	2300      	movs	r3, #0
   265c6:	77bb      	strb	r3, [r7, #30]
            uint16_t ms_dis = 0;
   265c8:	2300      	movs	r3, #0
   265ca:	83bb      	strh	r3, [r7, #28]
            uint16_t msg_id = 0;
            uint16_t trace_len = 0;
            char *trace_data = NULL;
#endif
            time_type_t cur_time;
            uint16_t us = 0;
   265cc:	2300      	movs	r3, #0
   265ce:	837b      	strh	r3, [r7, #26]

            data_buf += 2; // skip 2bytes length
   265d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265d2:	3302      	adds	r3, #2
   265d4:	63bb      	str	r3, [r7, #56]	; 0x38
            data_buf += 2; // skip sequence number
   265d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265d8:	3302      	adds	r3, #2
   265da:	63bb      	str	r3, [r7, #56]	; 0x38

            BYTES_TO_UINT32(ts, data_buf);  // uint in 312.5us(0.3125ms)
   265dc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265de:	781b      	ldrb	r3, [r3, #0]
   265e0:	461a      	mov	r2, r3
   265e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265e4:	3301      	adds	r3, #1
   265e6:	781b      	ldrb	r3, [r3, #0]
   265e8:	021b      	lsls	r3, r3, #8
   265ea:	441a      	add	r2, r3
   265ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265ee:	3302      	adds	r3, #2
   265f0:	781b      	ldrb	r3, [r3, #0]
   265f2:	041b      	lsls	r3, r3, #16
   265f4:	441a      	add	r2, r3
   265f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   265f8:	3303      	adds	r3, #3
   265fa:	781b      	ldrb	r3, [r3, #0]
   265fc:	061b      	lsls	r3, r3, #24
   265fe:	4413      	add	r3, r2
   26600:	62fb      	str	r3, [r7, #44]	; 0x2c
            data_buf += 4;
   26602:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26604:	3304      	adds	r3, #4
   26606:	63bb      	str	r3, [r7, #56]	; 0x38
            //ms = (ts >>5 )*10;
            us = (ts*TRC_TIME_UNIT)/10%1000;
   26608:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2660a:	f640 4235 	movw	r2, #3125	; 0xc35
   2660e:	fb02 f303 	mul.w	r3, r2, r3
   26612:	4a6e      	ldr	r2, [pc, #440]	; (267cc <hci_process_trace_data+0x28c>)
   26614:	fba2 2303 	umull	r2, r3, r2, r3
   26618:	08da      	lsrs	r2, r3, #3
   2661a:	4b6d      	ldr	r3, [pc, #436]	; (267d0 <hci_process_trace_data+0x290>)
   2661c:	fba3 1302 	umull	r1, r3, r3, r2
   26620:	099b      	lsrs	r3, r3, #6
   26622:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
   26626:	fb01 f303 	mul.w	r3, r1, r3
   2662a:	1ad3      	subs	r3, r2, r3
   2662c:	837b      	strh	r3, [r7, #26]
            ms = (ts*TRC_TIME_UNIT)/10/1000;
   2662e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   26630:	f640 4235 	movw	r2, #3125	; 0xc35
   26634:	fb02 f303 	mul.w	r3, r2, r3
   26638:	4a66      	ldr	r2, [pc, #408]	; (267d4 <hci_process_trace_data+0x294>)
   2663a:	fba2 2303 	umull	r2, r3, r2, r3
   2663e:	0b5b      	lsrs	r3, r3, #13
   26640:	627b      	str	r3, [r7, #36]	; 0x24
            cur_time = TimeStamp2Time(ms);
   26642:	f107 0308 	add.w	r3, r7, #8
   26646:	6a79      	ldr	r1, [r7, #36]	; 0x24
   26648:	4618      	mov	r0, r3
   2664a:	f7ff ff2b 	bl	264a4 <TimeStamp2Time>
            ms_dis = cur_time.t_ms;
   2664e:	893b      	ldrh	r3, [r7, #8]
   26650:	83bb      	strh	r3, [r7, #28]
            sec    = cur_time.t_sec;
   26652:	7abb      	ldrb	r3, [r7, #10]
   26654:	623b      	str	r3, [r7, #32]
            min    = cur_time.t_min;
   26656:	7afb      	ldrb	r3, [r7, #11]
   26658:	77fb      	strb	r3, [r7, #31]
            hour   = cur_time.t_hur;
   2665a:	7b3b      	ldrb	r3, [r7, #12]
   2665c:	77bb      	strb	r3, [r7, #30]

            trace_type = *data_buf;
   2665e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26660:	781b      	ldrb	r3, [r3, #0]
   26662:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
            data_buf ++;
   26666:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26668:	3301      	adds	r3, #1
   2666a:	63bb      	str	r3, [r7, #56]	; 0x38

            switch(trace_type)
   2666c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
   26670:	2b38      	cmp	r3, #56	; 0x38
   26672:	f040 809c 	bne.w	267ae <hci_process_trace_data+0x26e>
#endif
                case CUSTOM:
                {
                    uint8_t  custom_id;
                    uint8_t  custom_data_type;
                    uint32_t custom_data = 0;
   26676:	2300      	movs	r3, #0
   26678:	63fb      	str	r3, [r7, #60]	; 0x3c
                    uint8_t link_id = 0, llc_proc_type = 0, llc_proc_id = 0, error_log = 0;
   2667a:	2300      	movs	r3, #0
   2667c:	767b      	strb	r3, [r7, #25]
   2667e:	2300      	movs	r3, #0
   26680:	763b      	strb	r3, [r7, #24]
   26682:	2300      	movs	r3, #0
   26684:	75fb      	strb	r3, [r7, #23]
   26686:	2300      	movs	r3, #0
   26688:	75bb      	strb	r3, [r7, #22]
                    uint16_t sync_err_count = 0, crc_err_count = 0;
   2668a:	2300      	movs	r3, #0
   2668c:	82bb      	strh	r3, [r7, #20]
   2668e:	2300      	movs	r3, #0
   26690:	827b      	strh	r3, [r7, #18]

                    BSTREAM_TO_UINT8(custom_id, data_buf);
   26692:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26694:	1c5a      	adds	r2, r3, #1
   26696:	63ba      	str	r2, [r7, #56]	; 0x38
   26698:	781b      	ldrb	r3, [r3, #0]
   2669a:	747b      	strb	r3, [r7, #17]
                    BSTREAM_TO_UINT8(custom_data_type, data_buf);
   2669c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2669e:	1c5a      	adds	r2, r3, #1
   266a0:	63ba      	str	r2, [r7, #56]	; 0x38
   266a2:	781b      	ldrb	r3, [r3, #0]
   266a4:	743b      	strb	r3, [r7, #16]

                    if (UINT8_T == custom_data_type) {
   266a6:	7c3b      	ldrb	r3, [r7, #16]
   266a8:	2b01      	cmp	r3, #1
   266aa:	d105      	bne.n	266b8 <hci_process_trace_data+0x178>
                        BSTREAM_TO_UINT8(custom_data, data_buf);
   266ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266ae:	1c5a      	adds	r2, r3, #1
   266b0:	63ba      	str	r2, [r7, #56]	; 0x38
   266b2:	781b      	ldrb	r3, [r3, #0]
   266b4:	63fb      	str	r3, [r7, #60]	; 0x3c
   266b6:	e025      	b.n	26704 <hci_process_trace_data+0x1c4>
                    }
                    else if (UINT16_T == custom_data_type) {
   266b8:	7c3b      	ldrb	r3, [r7, #16]
   266ba:	2b02      	cmp	r3, #2
   266bc:	d10c      	bne.n	266d8 <hci_process_trace_data+0x198>
                        BSTREAM_TO_UINT16(custom_data, data_buf);
   266be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266c0:	781b      	ldrb	r3, [r3, #0]
   266c2:	461a      	mov	r2, r3
   266c4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266c6:	3301      	adds	r3, #1
   266c8:	781b      	ldrb	r3, [r3, #0]
   266ca:	021b      	lsls	r3, r3, #8
   266cc:	4413      	add	r3, r2
   266ce:	63fb      	str	r3, [r7, #60]	; 0x3c
   266d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266d2:	3302      	adds	r3, #2
   266d4:	63bb      	str	r3, [r7, #56]	; 0x38
   266d6:	e015      	b.n	26704 <hci_process_trace_data+0x1c4>
                    }
                    else {
                        BSTREAM_TO_UINT32(custom_data, data_buf);
   266d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266da:	781b      	ldrb	r3, [r3, #0]
   266dc:	461a      	mov	r2, r3
   266de:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266e0:	3301      	adds	r3, #1
   266e2:	781b      	ldrb	r3, [r3, #0]
   266e4:	021b      	lsls	r3, r3, #8
   266e6:	441a      	add	r2, r3
   266e8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266ea:	3302      	adds	r3, #2
   266ec:	781b      	ldrb	r3, [r3, #0]
   266ee:	041b      	lsls	r3, r3, #16
   266f0:	441a      	add	r2, r3
   266f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   266f4:	3303      	adds	r3, #3
   266f6:	781b      	ldrb	r3, [r3, #0]
   266f8:	061b      	lsls	r3, r3, #24
   266fa:	4413      	add	r3, r2
   266fc:	63fb      	str	r3, [r7, #60]	; 0x3c
   266fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   26700:	3304      	adds	r3, #4
   26702:	63bb      	str	r3, [r7, #56]	; 0x38
                    }

                    am_util_debug_printf("[%02d:%02d:%02d:%03d.%03d] Custom data: id 0x%x, 0x%08x\n",
   26704:	7fbc      	ldrb	r4, [r7, #30]
   26706:	7ffd      	ldrb	r5, [r7, #31]
   26708:	8bbb      	ldrh	r3, [r7, #28]
   2670a:	8b7a      	ldrh	r2, [r7, #26]
   2670c:	7c79      	ldrb	r1, [r7, #17]
   2670e:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   26710:	9003      	str	r0, [sp, #12]
   26712:	9102      	str	r1, [sp, #8]
   26714:	9201      	str	r2, [sp, #4]
   26716:	9300      	str	r3, [sp, #0]
   26718:	6a3b      	ldr	r3, [r7, #32]
   2671a:	462a      	mov	r2, r5
   2671c:	4621      	mov	r1, r4
   2671e:	482e      	ldr	r0, [pc, #184]	; (267d8 <hci_process_trace_data+0x298>)
   26720:	f7f4 fa3e 	bl	1aba0 <am_util_stdio_printf>
                                        hour, min, sec, ms_dis, us, custom_id, custom_data);
                    if (custom_id == CUSTOM_ID_32K_VALUE)
   26724:	7c7b      	ldrb	r3, [r7, #17]
   26726:	2b00      	cmp	r3, #0
   26728:	d104      	bne.n	26734 <hci_process_trace_data+0x1f4>
                    {
                        am_util_debug_printf("32K clock= %d Hz\n", custom_data);
   2672a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
   2672c:	482b      	ldr	r0, [pc, #172]	; (267dc <hci_process_trace_data+0x29c>)
   2672e:	f7f4 fa37 	bl	1aba0 <am_util_stdio_printf>
                        crc_err_count = custom_data& 0xFFFF;
                        am_util_debug_printf("Continous sync error %d times, continous crc error %d times\r\n", sync_err_count, crc_err_count);
                    }
                }

                break;
   26732:	e03e      	b.n	267b2 <hci_process_trace_data+0x272>
                    else if (custom_id == CUSTOM_ID_CONN_TIMEOUT_CAUSE)
   26734:	7c7b      	ldrb	r3, [r7, #17]
   26736:	2b02      	cmp	r3, #2
   26738:	d112      	bne.n	26760 <hci_process_trace_data+0x220>
                        link_id = custom_data & 0xFF;
   2673a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2673c:	767b      	strb	r3, [r7, #25]
                        if (((custom_data >> 8) & 0xFF) != 0)
   2673e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   26740:	0a1b      	lsrs	r3, r3, #8
   26742:	b2db      	uxtb	r3, r3
   26744:	2b00      	cmp	r3, #0
   26746:	d034      	beq.n	267b2 <hci_process_trace_data+0x272>
                            am_util_debug_printf("Link %d connection timeout: %s\r\n", link_id, conn_timeout_str[((custom_data >>8) & 0xFF)]);
   26748:	7e79      	ldrb	r1, [r7, #25]
   2674a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2674c:	0a1b      	lsrs	r3, r3, #8
   2674e:	b2db      	uxtb	r3, r3
   26750:	4a23      	ldr	r2, [pc, #140]	; (267e0 <hci_process_trace_data+0x2a0>)
   26752:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   26756:	461a      	mov	r2, r3
   26758:	4822      	ldr	r0, [pc, #136]	; (267e4 <hci_process_trace_data+0x2a4>)
   2675a:	f7f4 fa21 	bl	1aba0 <am_util_stdio_printf>
                break;
   2675e:	e028      	b.n	267b2 <hci_process_trace_data+0x272>
                    else if (custom_id == CUSTOM_ID_DISC_DETAIL)
   26760:	7c7b      	ldrb	r3, [r7, #17]
   26762:	2b09      	cmp	r3, #9
   26764:	d114      	bne.n	26790 <hci_process_trace_data+0x250>
                        link_id = (custom_data >> CUSTOM_DISC_ERROR_LINK_ID_OFFSET) & 0xFF;
   26766:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   26768:	0e1b      	lsrs	r3, r3, #24
   2676a:	767b      	strb	r3, [r7, #25]
                        llc_proc_type = (custom_data >> CUSTOM_DISC_ERROR_LLC_PROC_TYPE_OFFSET) & 0xFF;
   2676c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2676e:	0c1b      	lsrs	r3, r3, #16
   26770:	763b      	strb	r3, [r7, #24]
                        llc_proc_id = (custom_data >> CUSTOM_DISC_ERROR_LLC_PROC_ID_OFFSET) & 0xFF;
   26772:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   26774:	0a1b      	lsrs	r3, r3, #8
   26776:	75fb      	strb	r3, [r7, #23]
                        error_log = custom_data & 0xFF;
   26778:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2677a:	75bb      	strb	r3, [r7, #22]
                        am_util_debug_printf("Link %d LLC_PROC_TYPE: %d, LLC_PROC_ID: %d, error_log: %d\r\n", link_id, llc_proc_type, llc_proc_id, error_log);
   2677c:	7e79      	ldrb	r1, [r7, #25]
   2677e:	7e3a      	ldrb	r2, [r7, #24]
   26780:	7df8      	ldrb	r0, [r7, #23]
   26782:	7dbb      	ldrb	r3, [r7, #22]
   26784:	9300      	str	r3, [sp, #0]
   26786:	4603      	mov	r3, r0
   26788:	4817      	ldr	r0, [pc, #92]	; (267e8 <hci_process_trace_data+0x2a8>)
   2678a:	f7f4 fa09 	bl	1aba0 <am_util_stdio_printf>
                break;
   2678e:	e010      	b.n	267b2 <hci_process_trace_data+0x272>
                    else if (custom_id == CUSTOM_ID_CON_SYNC_CRC_ERR_CNT)
   26790:	7c7b      	ldrb	r3, [r7, #17]
   26792:	2b0a      	cmp	r3, #10
   26794:	d10d      	bne.n	267b2 <hci_process_trace_data+0x272>
                        sync_err_count = (custom_data >> 16) & 0xFFFF;
   26796:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   26798:	0c1b      	lsrs	r3, r3, #16
   2679a:	82bb      	strh	r3, [r7, #20]
                        crc_err_count = custom_data& 0xFFFF;
   2679c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   2679e:	827b      	strh	r3, [r7, #18]
                        am_util_debug_printf("Continous sync error %d times, continous crc error %d times\r\n", sync_err_count, crc_err_count);
   267a0:	8abb      	ldrh	r3, [r7, #20]
   267a2:	8a7a      	ldrh	r2, [r7, #18]
   267a4:	4619      	mov	r1, r3
   267a6:	4811      	ldr	r0, [pc, #68]	; (267ec <hci_process_trace_data+0x2ac>)
   267a8:	f7f4 f9fa 	bl	1aba0 <am_util_stdio_printf>
                break;
   267ac:	e001      	b.n	267b2 <hci_process_trace_data+0x272>

                default:
                break;
   267ae:	bf00      	nop
   267b0:	e005      	b.n	267be <hci_process_trace_data+0x27e>
                break;
   267b2:	bf00      	nop
            }
        }
        break;
   267b4:	e003      	b.n	267be <hci_process_trace_data+0x27e>

        default:
            am_util_debug_printf("unknow trace packet type\n");
   267b6:	480e      	ldr	r0, [pc, #56]	; (267f0 <hci_process_trace_data+0x2b0>)
   267b8:	f7f4 f9f2 	bl	1aba0 <am_util_stdio_printf>
            break;
   267bc:	bf00      	nop
    }
}
   267be:	bf00      	nop
   267c0:	3740      	adds	r7, #64	; 0x40
   267c2:	46bd      	mov	sp, r7
   267c4:	bdb0      	pop	{r4, r5, r7, pc}
   267c6:	bf00      	nop
   267c8:	00044da8 	.word	0x00044da8
   267cc:	cccccccd 	.word	0xcccccccd
   267d0:	10624dd3 	.word	0x10624dd3
   267d4:	d1b71759 	.word	0xd1b71759
   267d8:	00044dd0 	.word	0x00044dd0
   267dc:	00044e0c 	.word	0x00044e0c
   267e0:	10002bcc 	.word	0x10002bcc
   267e4:	00044e20 	.word	0x00044e20
   267e8:	00044e44 	.word	0x00044e44
   267ec:	00044e80 	.word	0x00044e80
   267f0:	00044ec0 	.word	0x00044ec0

000267f4 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
   267f4:	b480      	push	{r7}
   267f6:	b083      	sub	sp, #12
   267f8:	af00      	add	r7, sp, #0
   267fa:	4603      	mov	r3, r0
   267fc:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   267fe:	f997 3007 	ldrsb.w	r3, [r7, #7]
   26802:	2b00      	cmp	r3, #0
   26804:	db0b      	blt.n	2681e <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   26806:	79fb      	ldrb	r3, [r7, #7]
   26808:	f003 021f 	and.w	r2, r3, #31
   2680c:	4907      	ldr	r1, [pc, #28]	; (2682c <__NVIC_EnableIRQ+0x38>)
   2680e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   26812:	095b      	lsrs	r3, r3, #5
   26814:	2001      	movs	r0, #1
   26816:	fa00 f202 	lsl.w	r2, r0, r2
   2681a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
   2681e:	bf00      	nop
   26820:	370c      	adds	r7, #12
   26822:	46bd      	mov	sp, r7
   26824:	f85d 7b04 	ldr.w	r7, [sp], #4
   26828:	4770      	bx	lr
   2682a:	bf00      	nop
   2682c:	e000e100 	.word	0xe000e100

00026830 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   26830:	b480      	push	{r7}
   26832:	b083      	sub	sp, #12
   26834:	af00      	add	r7, sp, #0
   26836:	4603      	mov	r3, r0
   26838:	6039      	str	r1, [r7, #0]
   2683a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2683c:	f997 3007 	ldrsb.w	r3, [r7, #7]
   26840:	2b00      	cmp	r3, #0
   26842:	db0a      	blt.n	2685a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   26844:	683b      	ldr	r3, [r7, #0]
   26846:	b2da      	uxtb	r2, r3
   26848:	490c      	ldr	r1, [pc, #48]	; (2687c <__NVIC_SetPriority+0x4c>)
   2684a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2684e:	0152      	lsls	r2, r2, #5
   26850:	b2d2      	uxtb	r2, r2
   26852:	440b      	add	r3, r1
   26854:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
   26858:	e00a      	b.n	26870 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2685a:	683b      	ldr	r3, [r7, #0]
   2685c:	b2da      	uxtb	r2, r3
   2685e:	4908      	ldr	r1, [pc, #32]	; (26880 <__NVIC_SetPriority+0x50>)
   26860:	79fb      	ldrb	r3, [r7, #7]
   26862:	f003 030f 	and.w	r3, r3, #15
   26866:	3b04      	subs	r3, #4
   26868:	0152      	lsls	r2, r2, #5
   2686a:	b2d2      	uxtb	r2, r2
   2686c:	440b      	add	r3, r1
   2686e:	761a      	strb	r2, [r3, #24]
}
   26870:	bf00      	nop
   26872:	370c      	adds	r7, #12
   26874:	46bd      	mov	sp, r7
   26876:	f85d 7b04 	ldr.w	r7, [sp], #4
   2687a:	4770      	bx	lr
   2687c:	e000e100 	.word	0xe000e100
   26880:	e000ed00 	.word	0xe000ed00

00026884 <error_check>:
// they will be sent there intead.
//
//*****************************************************************************
static void
error_check(uint32_t ui32Status)
{
   26884:	b580      	push	{r7, lr}
   26886:	b084      	sub	sp, #16
   26888:	af00      	add	r7, sp, #0
   2688a:	6078      	str	r0, [r7, #4]
    //
    // Don't do anything unless there's an error.
    //
    if (ui32Status)
   2688c:	687b      	ldr	r3, [r7, #4]
   2688e:	2b00      	cmp	r3, #0
   26890:	d01b      	beq.n	268ca <error_check+0x46>
    {
        //
        // Set the global error status. If there's an error handler function,
        // call it. Otherwise, just print the error status and wait.
        //
        g_ui32FailingStatus = ui32Status;
   26892:	4a10      	ldr	r2, [pc, #64]	; (268d4 <error_check+0x50>)
   26894:	687b      	ldr	r3, [r7, #4]
   26896:	6013      	str	r3, [r2, #0]

        if (g_hciDrvErrorHandler)
   26898:	4b0f      	ldr	r3, [pc, #60]	; (268d8 <error_check+0x54>)
   2689a:	681b      	ldr	r3, [r3, #0]
   2689c:	2b00      	cmp	r3, #0
   2689e:	d006      	beq.n	268ae <error_check+0x2a>
        {
            g_hciDrvErrorHandler(g_ui32FailingStatus);
   268a0:	4b0d      	ldr	r3, [pc, #52]	; (268d8 <error_check+0x54>)
   268a2:	681b      	ldr	r3, [r3, #0]
   268a4:	4a0b      	ldr	r2, [pc, #44]	; (268d4 <error_check+0x50>)
   268a6:	6812      	ldr	r2, [r2, #0]
   268a8:	4610      	mov	r0, r2
   268aa:	4798      	blx	r3
        else
        {
            CRITICAL_PRINT("\nError detected: 0x%08x\n", g_ui32FailingStatus);
        }
    }
}
   268ac:	e00d      	b.n	268ca <error_check+0x46>
            CRITICAL_PRINT("\nError detected: 0x%08x\n", g_ui32FailingStatus);
   268ae:	f00d faa5 	bl	33dfc <am_hal_interrupt_master_disable>
   268b2:	4603      	mov	r3, r0
   268b4:	60fb      	str	r3, [r7, #12]
   268b6:	4b07      	ldr	r3, [pc, #28]	; (268d4 <error_check+0x50>)
   268b8:	681b      	ldr	r3, [r3, #0]
   268ba:	4619      	mov	r1, r3
   268bc:	4807      	ldr	r0, [pc, #28]	; (268dc <error_check+0x58>)
   268be:	f7f4 f96f 	bl	1aba0 <am_util_stdio_printf>
   268c2:	68fb      	ldr	r3, [r7, #12]
   268c4:	4618      	mov	r0, r3
   268c6:	f00d fa9d 	bl	33e04 <am_hal_interrupt_master_set>
}
   268ca:	bf00      	nop
   268cc:	3710      	adds	r7, #16
   268ce:	46bd      	mov	sp, r7
   268d0:	bd80      	pop	{r7, pc}
   268d2:	bf00      	nop
   268d4:	10003f74 	.word	0x10003f74
   268d8:	10003f70 	.word	0x10003f70
   268dc:	00044edc 	.word	0x00044edc

000268e0 <HciDrvIntService>:
//     handlerId = WsfOsSetNextHandler(HciDrvHandler);
//     HciDrvHandler(handlerId);
//
//*****************************************************************************
static void HciDrvIntService(void *pArg)
{
   268e0:	b580      	push	{r7, lr}
   268e2:	b082      	sub	sp, #8
   268e4:	af00      	add	r7, sp, #0
   268e6:	6078      	str	r0, [r7, #4]
    //
    // Send an event to get processed in the HCI handler.
    //
    WsfSetEvent(g_HciDrvHandleID, BLE_TRANSFER_NEEDED_EVENT);
   268e8:	4b04      	ldr	r3, [pc, #16]	; (268fc <HciDrvIntService+0x1c>)
   268ea:	781b      	ldrb	r3, [r3, #0]
   268ec:	2101      	movs	r1, #1
   268ee:	4618      	mov	r0, r3
   268f0:	f006 fce0 	bl	2d2b4 <WsfSetEvent>
}
   268f4:	bf00      	nop
   268f6:	3708      	adds	r7, #8
   268f8:	46bd      	mov	sp, r7
   268fa:	bd80      	pop	{r7, pc}
   268fc:	10003f64 	.word	0x10003f64

00026900 <ClkReqIntService>:

static void ClkReqIntService(void *pArg)
{
   26900:	b580      	push	{r7, lr}
   26902:	b084      	sub	sp, #16
   26904:	af00      	add	r7, sp, #0
   26906:	6078      	str	r0, [r7, #4]
    if(am_devices_cooper_clkreq_read(g_IomDevHdl))
   26908:	4b15      	ldr	r3, [pc, #84]	; (26960 <ClkReqIntService+0x60>)
   2690a:	681b      	ldr	r3, [r3, #0]
   2690c:	4618      	mov	r0, r3
   2690e:	f7f2 fd95 	bl	1943c <am_devices_cooper_clkreq_read>
   26912:	4603      	mov	r3, r0
   26914:	2b00      	cmp	r3, #0
   26916:	d004      	beq.n	26922 <ClkReqIntService+0x22>
    {
        // Power up the 32MHz Crystal
        am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32M_KICK_START, 0);
   26918:	2100      	movs	r1, #0
   2691a:	2002      	movs	r0, #2
   2691c:	f00e f870 	bl	34a00 <am_hal_mcuctrl_control>
   26920:	e003      	b.n	2692a <ClkReqIntService+0x2a>
    }
    else
    {
        am_hal_mcuctrl_control(AM_HAL_MCUCTRL_CONTROL_EXTCLK32M_DISABLE, 0);
   26922:	2100      	movs	r1, #0
   26924:	2004      	movs	r0, #4
   26926:	f00e f86b 	bl	34a00 <am_hal_mcuctrl_control>
    }
    am_hal_gpio_intdir_toggle(AM_DEVICES_COOPER_CLKREQ_PIN);
   2692a:	4b0e      	ldr	r3, [pc, #56]	; (26964 <ClkReqIntService+0x64>)
   2692c:	60fb      	str	r3, [r7, #12]
   2692e:	f00d fa65 	bl	33dfc <am_hal_interrupt_master_disable>
   26932:	4603      	mov	r3, r0
   26934:	60bb      	str	r3, [r7, #8]
   26936:	4b0b      	ldr	r3, [pc, #44]	; (26964 <ClkReqIntService+0x64>)
   26938:	2273      	movs	r2, #115	; 0x73
   2693a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   2693e:	68fb      	ldr	r3, [r7, #12]
   26940:	33a0      	adds	r3, #160	; 0xa0
   26942:	681a      	ldr	r2, [r3, #0]
   26944:	68fb      	ldr	r3, [r7, #12]
   26946:	33a0      	adds	r3, #160	; 0xa0
   26948:	f082 02c0 	eor.w	r2, r2, #192	; 0xc0
   2694c:	601a      	str	r2, [r3, #0]
   2694e:	68bb      	ldr	r3, [r7, #8]
   26950:	4618      	mov	r0, r3
   26952:	f00d fa57 	bl	33e04 <am_hal_interrupt_master_set>
}
   26956:	bf00      	nop
   26958:	3710      	adds	r7, #16
   2695a:	46bd      	mov	sp, r7
   2695c:	bd80      	pop	{r7, pc}
   2695e:	bf00      	nop
   26960:	10003f5c 	.word	0x10003f5c
   26964:	40010000 	.word	0x40010000

00026968 <HciDrvRadioBoot>:
// Boot the radio.
//
//*****************************************************************************
uint32_t
HciDrvRadioBoot(bool bColdBoot)
{
   26968:	b580      	push	{r7, lr}
   2696a:	b096      	sub	sp, #88	; 0x58
   2696c:	af00      	add	r7, sp, #0
   2696e:	4603      	mov	r3, r0
   26970:	71fb      	strb	r3, [r7, #7]
    uint32_t ui32Status = AM_DEVICES_COOPER_STATUS_SUCCESS;
   26972:	2300      	movs	r3, #0
   26974:	657b      	str	r3, [r7, #84]	; 0x54

    am_devices_cooper_config_t stCooperConfig;
    stCooperConfig.pNBTxnBuf = DMATCBBuffer;
   26976:	4b2d      	ldr	r3, [pc, #180]	; (26a2c <HciDrvRadioBoot+0xc4>)
   26978:	64fb      	str	r3, [r7, #76]	; 0x4c
    stCooperConfig.ui32NBTxnBufLength = sizeof(DMATCBBuffer) / 4;
   2697a:	2383      	movs	r3, #131	; 0x83
   2697c:	653b      	str	r3, [r7, #80]	; 0x50

    //
    // Initialize the SPI module.
    //
    ui32Status = am_devices_cooper_init(SPI_MODULE, &stCooperConfig, &g_IomDevHdl, &pvHciSpiHandle);
   2697e:	f107 014c 	add.w	r1, r7, #76	; 0x4c
   26982:	4b2b      	ldr	r3, [pc, #172]	; (26a30 <HciDrvRadioBoot+0xc8>)
   26984:	4a2b      	ldr	r2, [pc, #172]	; (26a34 <HciDrvRadioBoot+0xcc>)
   26986:	2004      	movs	r0, #4
   26988:	f7f2 f980 	bl	18c8c <am_devices_cooper_init>
   2698c:	6578      	str	r0, [r7, #84]	; 0x54
    ERROR_RETURN(ui32Status, ui32Status);
   2698e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   26990:	2b00      	cmp	r3, #0
   26992:	d004      	beq.n	2699e <HciDrvRadioBoot+0x36>
   26994:	6d78      	ldr	r0, [r7, #84]	; 0x54
   26996:	f7ff ff75 	bl	26884 <error_check>
   2699a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
   2699c:	e041      	b.n	26a22 <HciDrvRadioBoot+0xba>

    //
    // Set the default BLE TX Output power.
    //
    am_util_ble_tx_power_set(g_IomDevHdl, TX_POWER_LEVEL_DEFAULT);
   2699e:	4b25      	ldr	r3, [pc, #148]	; (26a34 <HciDrvRadioBoot+0xcc>)
   269a0:	681b      	ldr	r3, [r3, #0]
   269a2:	2104      	movs	r1, #4
   269a4:	4618      	mov	r0, r3
   269a6:	f7f3 fa07 	bl	19db8 <am_util_ble_tx_power_set>

    uint32_t IntNum = AM_DEVICES_COOPER_IRQ_PIN;
   269aa:	2327      	movs	r3, #39	; 0x27
   269ac:	64bb      	str	r3, [r7, #72]	; 0x48
    am_hal_gpio_interrupt_register(AM_HAL_GPIO_INT_CHANNEL_0, IntNum, HciDrvIntService, NULL);
   269ae:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   269b0:	2300      	movs	r3, #0
   269b2:	4a21      	ldr	r2, [pc, #132]	; (26a38 <HciDrvRadioBoot+0xd0>)
   269b4:	2000      	movs	r0, #0
   269b6:	f00f f9fd 	bl	35db4 <am_hal_gpio_interrupt_register>
    am_hal_gpio_interrupt_control(AM_HAL_GPIO_INT_CHANNEL_0,
   269ba:	f107 0348 	add.w	r3, r7, #72	; 0x48
   269be:	461a      	mov	r2, r3
   269c0:	2101      	movs	r1, #1
   269c2:	2000      	movs	r0, #0
   269c4:	f00f f8e4 	bl	35b90 <am_hal_gpio_interrupt_control>
                                  AM_HAL_GPIO_INT_CTRL_INDV_ENABLE,
                                  (void *)&IntNum);
    IntNum = AM_DEVICES_COOPER_CLKREQ_PIN;
   269c8:	2328      	movs	r3, #40	; 0x28
   269ca:	64bb      	str	r3, [r7, #72]	; 0x48
    am_hal_gpio_interrupt_register(AM_HAL_GPIO_INT_CHANNEL_0, IntNum, ClkReqIntService, NULL);
   269cc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
   269ce:	2300      	movs	r3, #0
   269d0:	4a1a      	ldr	r2, [pc, #104]	; (26a3c <HciDrvRadioBoot+0xd4>)
   269d2:	2000      	movs	r0, #0
   269d4:	f00f f9ee 	bl	35db4 <am_hal_gpio_interrupt_register>
    am_hal_gpio_interrupt_control(AM_HAL_GPIO_INT_CHANNEL_0,
   269d8:	f107 0348 	add.w	r3, r7, #72	; 0x48
   269dc:	461a      	mov	r2, r3
   269de:	2101      	movs	r1, #1
   269e0:	2000      	movs	r0, #0
   269e2:	f00f f8d5 	bl	35b90 <am_hal_gpio_interrupt_control>
                                  AM_HAL_GPIO_INT_CTRL_INDV_ENABLE,
                                  (void *)&IntNum);
#ifdef AM_IRQ_PRIORITY_DEFAULT
    NVIC_SetPriority(AM_COOPER_IRQn, AM_IRQ_PRIORITY_DEFAULT);
   269e6:	2104      	movs	r1, #4
   269e8:	2039      	movs	r0, #57	; 0x39
   269ea:	f7ff ff21 	bl	26830 <__NVIC_SetPriority>
#endif // AM_IRQ_PRIORITY_DEFAULT
    NVIC_EnableIRQ(AM_COOPER_IRQn);
   269ee:	2039      	movs	r0, #57	; 0x39
   269f0:	f7ff ff00 	bl	267f4 <__NVIC_EnableIRQ>

    // When it's bColdBoot, it will use Apollo's Device ID to form Bluetooth address.
    if (bColdBoot)
   269f4:	79fb      	ldrb	r3, [r7, #7]
   269f6:	2b00      	cmp	r3, #0
   269f8:	d012      	beq.n	26a20 <HciDrvRadioBoot+0xb8>
    {
        am_hal_mcuctrl_device_t sDevice;
        am_hal_mcuctrl_info_get(AM_HAL_MCUCTRL_INFO_DEVICEID, &sDevice);
   269fa:	f107 030c 	add.w	r3, r7, #12
   269fe:	4619      	mov	r1, r3
   26a00:	2001      	movs	r0, #1
   26a02:	f00e f8f5 	bl	34bf0 <am_hal_mcuctrl_info_get>
   26a06:	697b      	ldr	r3, [r7, #20]

        // Bluetooth address formed by ChipID1 (32 bits) and ChipID0 (8-23 bits).
        memcpy(g_BLEMacAddress, &sDevice.ui32ChipID1, sizeof(sDevice.ui32ChipID1));
   26a08:	4a0d      	ldr	r2, [pc, #52]	; (26a40 <HciDrvRadioBoot+0xd8>)
   26a0a:	6013      	str	r3, [r2, #0]
        // ui32ChipID0 bit 8-31 is test time during chip manufacturing
        g_BLEMacAddress[4] = (sDevice.ui32ChipID0 >> 8) & 0xFF;
   26a0c:	693b      	ldr	r3, [r7, #16]
   26a0e:	0a1b      	lsrs	r3, r3, #8
   26a10:	b2da      	uxtb	r2, r3
   26a12:	4b0b      	ldr	r3, [pc, #44]	; (26a40 <HciDrvRadioBoot+0xd8>)
   26a14:	711a      	strb	r2, [r3, #4]
        g_BLEMacAddress[5] = (sDevice.ui32ChipID0 >> 16) & 0xFF;
   26a16:	693b      	ldr	r3, [r7, #16]
   26a18:	0c1b      	lsrs	r3, r3, #16
   26a1a:	b2da      	uxtb	r2, r3
   26a1c:	4b08      	ldr	r3, [pc, #32]	; (26a40 <HciDrvRadioBoot+0xd8>)
   26a1e:	715a      	strb	r2, [r3, #5]
    }

    return AM_DEVICES_COOPER_STATUS_SUCCESS;
   26a20:	2300      	movs	r3, #0
}
   26a22:	4618      	mov	r0, r3
   26a24:	3758      	adds	r7, #88	; 0x58
   26a26:	46bd      	mov	sp, r7
   26a28:	bd80      	pop	{r7, pc}
   26a2a:	bf00      	nop
   26a2c:	100114e0 	.word	0x100114e0
   26a30:	10003f60 	.word	0x10003f60
   26a34:	10003f5c 	.word	0x10003f5c
   26a38:	000268e1 	.word	0x000268e1
   26a3c:	00026901 	.word	0x00026901
   26a40:	10003f54 	.word	0x10003f54

00026a44 <HciDrvRadioShutdown>:
// Shut down the BLE core.
//
//*****************************************************************************
void
HciDrvRadioShutdown(void)
{
   26a44:	b580      	push	{r7, lr}
   26a46:	b082      	sub	sp, #8
   26a48:	af00      	add	r7, sp, #0
    uint32_t IntNum = AM_DEVICES_COOPER_IRQ_PIN;
   26a4a:	2327      	movs	r3, #39	; 0x27
   26a4c:	607b      	str	r3, [r7, #4]
    am_hal_gpio_interrupt_control(AM_HAL_GPIO_INT_CHANNEL_0,
   26a4e:	1d3b      	adds	r3, r7, #4
   26a50:	461a      	mov	r2, r3
   26a52:	2100      	movs	r1, #0
   26a54:	2000      	movs	r0, #0
   26a56:	f00f f89b 	bl	35b90 <am_hal_gpio_interrupt_control>
                                  AM_HAL_GPIO_INT_CTRL_INDV_DISABLE,
                                  (void *)&IntNum);
    IntNum = AM_DEVICES_COOPER_CLKREQ_PIN;
   26a5a:	2328      	movs	r3, #40	; 0x28
   26a5c:	607b      	str	r3, [r7, #4]
    am_hal_gpio_interrupt_control(AM_HAL_GPIO_INT_CHANNEL_0,
   26a5e:	1d3b      	adds	r3, r7, #4
   26a60:	461a      	mov	r2, r3
   26a62:	2100      	movs	r1, #0
   26a64:	2000      	movs	r0, #0
   26a66:	f00f f893 	bl	35b90 <am_hal_gpio_interrupt_control>
                                  AM_HAL_GPIO_INT_CTRL_INDV_DISABLE,
                                  (void *)&IntNum);

    am_devices_cooper_term(g_IomDevHdl);
   26a6a:	4b04      	ldr	r3, [pc, #16]	; (26a7c <HciDrvRadioShutdown+0x38>)
   26a6c:	681b      	ldr	r3, [r3, #0]
   26a6e:	4618      	mov	r0, r3
   26a70:	f7f2 fa7e 	bl	18f70 <am_devices_cooper_term>
}
   26a74:	bf00      	nop
   26a76:	3708      	adds	r7, #8
   26a78:	46bd      	mov	sp, r7
   26a7a:	bd80      	pop	{r7, pc}
   26a7c:	10003f5c 	.word	0x10003f5c

00026a80 <hciDrvWrite>:
//
//*****************************************************************************

uint16_t
hciDrvWrite(uint8_t type, uint16_t len, uint8_t *pData)
{
   26a80:	b580      	push	{r7, lr}
   26a82:	b086      	sub	sp, #24
   26a84:	af02      	add	r7, sp, #8
   26a86:	4603      	mov	r3, r0
   26a88:	603a      	str	r2, [r7, #0]
   26a8a:	71fb      	strb	r3, [r7, #7]
   26a8c:	460b      	mov	r3, r1
   26a8e:	80bb      	strh	r3, [r7, #4]
    uint32_t ui32ErrorStatus = 0;
   26a90:	2300      	movs	r3, #0
   26a92:	60fb      	str	r3, [r7, #12]

    if (len > AM_DEVICES_COOPER_MAX_TX_PACKET)
   26a94:	88bb      	ldrh	r3, [r7, #4]
   26a96:	f5b3 7f03 	cmp.w	r3, #524	; 0x20c
   26a9a:	d911      	bls.n	26ac0 <hciDrvWrite+0x40>
    {
        CRITICAL_PRINT("\nERROR: Trying to send an HCI packet larger than the hci driver buffer size (needs %d bytes of space).\n",
   26a9c:	f00d f9ae 	bl	33dfc <am_hal_interrupt_master_disable>
   26aa0:	4603      	mov	r3, r0
   26aa2:	60bb      	str	r3, [r7, #8]
   26aa4:	88bb      	ldrh	r3, [r7, #4]
   26aa6:	4619      	mov	r1, r3
   26aa8:	4818      	ldr	r0, [pc, #96]	; (26b0c <hciDrvWrite+0x8c>)
   26aaa:	f7f4 f879 	bl	1aba0 <am_util_stdio_printf>
   26aae:	68bb      	ldr	r3, [r7, #8]
   26ab0:	4618      	mov	r0, r3
   26ab2:	f00d f9a7 	bl	33e04 <am_hal_interrupt_master_set>
                       len);
        ERROR_RETURN(HCI_DRV_TX_PACKET_TOO_LARGE, 0);
   26ab6:	4816      	ldr	r0, [pc, #88]	; (26b10 <hciDrvWrite+0x90>)
   26ab8:	f7ff fee4 	bl	26884 <error_check>
   26abc:	2300      	movs	r3, #0
   26abe:	e020      	b.n	26b02 <hciDrvWrite+0x82>
    }

    ui32ErrorStatus = am_devices_cooper_blocking_write(g_IomDevHdl, type, (uint32_t*)pData, (uint16_t)len, false);
   26ac0:	4b14      	ldr	r3, [pc, #80]	; (26b14 <hciDrvWrite+0x94>)
   26ac2:	6818      	ldr	r0, [r3, #0]
   26ac4:	88bb      	ldrh	r3, [r7, #4]
   26ac6:	79f9      	ldrb	r1, [r7, #7]
   26ac8:	2200      	movs	r2, #0
   26aca:	9200      	str	r2, [sp, #0]
   26acc:	683a      	ldr	r2, [r7, #0]
   26ace:	f7f2 fafd 	bl	190cc <am_devices_cooper_blocking_write>
   26ad2:	60f8      	str	r0, [r7, #12]

    if (ui32ErrorStatus == AM_DEVICES_COOPER_STATUS_SUCCESS)
   26ad4:	68fb      	ldr	r3, [r7, #12]
   26ad6:	2b00      	cmp	r3, #0
   26ad8:	d101      	bne.n	26ade <hciDrvWrite+0x5e>
    {
        return len;
   26ada:	88bb      	ldrh	r3, [r7, #4]
   26adc:	e011      	b.n	26b02 <hciDrvWrite+0x82>
    }
    else if (ui32ErrorStatus == AM_DEVICES_COOPER_STATUS_CONTROLLER_NOT_READY)
   26ade:	68fb      	ldr	r3, [r7, #12]
   26ae0:	2b03      	cmp	r3, #3
   26ae2:	d101      	bne.n	26ae8 <hciDrvWrite+0x68>
    {
        return 0;
   26ae4:	2300      	movs	r3, #0
   26ae6:	e00c      	b.n	26b02 <hciDrvWrite+0x82>
    }
    else if (ui32ErrorStatus == AM_DEVICES_COOPER_STATUS_TIMEOUT)
   26ae8:	68fb      	ldr	r3, [r7, #12]
   26aea:	2b07      	cmp	r3, #7
   26aec:	d108      	bne.n	26b00 <hciDrvWrite+0x80>
    {
        // When using polling mechanism to send HCI packets to Cooper,
        // consider Cooper needs to reboot if no response within setting timeout
        HciDrvRadioShutdown();
   26aee:	f7ff ffa9 	bl	26a44 <HciDrvRadioShutdown>
        HciDrvRadioBoot(0);
   26af2:	2000      	movs	r0, #0
   26af4:	f7ff ff38 	bl	26968 <HciDrvRadioBoot>
        DmDevReset();
   26af8:	f7fd f8e0 	bl	23cbc <DmDevReset>
        return 0;
   26afc:	2300      	movs	r3, #0
   26afe:	e000      	b.n	26b02 <hciDrvWrite+0x82>
    }
    else
    {
        return 0;
   26b00:	2300      	movs	r3, #0
    }
}
   26b02:	4618      	mov	r0, r3
   26b04:	3710      	adds	r7, #16
   26b06:	46bd      	mov	sp, r7
   26b08:	bd80      	pop	{r7, pc}
   26b0a:	bf00      	nop
   26b0c:	00044ef8 	.word	0x00044ef8
   26b10:	09000001 	.word	0x09000001
   26b14:	10003f5c 	.word	0x10003f5c

00026b18 <HciDrvHandlerInit>:
//     HciDrvHandler(handlerId);
//
//*****************************************************************************
void
HciDrvHandlerInit(wsfHandlerId_t handlerId)
{
   26b18:	b480      	push	{r7}
   26b1a:	b083      	sub	sp, #12
   26b1c:	af00      	add	r7, sp, #0
   26b1e:	4603      	mov	r3, r0
   26b20:	71fb      	strb	r3, [r7, #7]
    g_HciDrvHandleID = handlerId;
   26b22:	4a04      	ldr	r2, [pc, #16]	; (26b34 <HciDrvHandlerInit+0x1c>)
   26b24:	79fb      	ldrb	r3, [r7, #7]
   26b26:	7013      	strb	r3, [r2, #0]
}
   26b28:	bf00      	nop
   26b2a:	370c      	adds	r7, #12
   26b2c:	46bd      	mov	sp, r7
   26b2e:	f85d 7b04 	ldr.w	r7, [sp], #4
   26b32:	4770      	bx	lr
   26b34:	10003f64 	.word	0x10003f64

00026b38 <HciDrvHandler>:
// correct order.
//
//*****************************************************************************
void
HciDrvHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   26b38:	b580      	push	{r7, lr}
   26b3a:	b088      	sub	sp, #32
   26b3c:	af00      	add	r7, sp, #0
   26b3e:	4603      	mov	r3, r0
   26b40:	6039      	str	r1, [r7, #0]
   26b42:	71fb      	strb	r3, [r7, #7]
    uint32_t ui32ErrorStatus = 0;
   26b44:	2300      	movs	r3, #0
   26b46:	61fb      	str	r3, [r7, #28]

    //
    //need to check the each bit of event mask
    //
    if ( event & BLE_TRANSFER_NEEDED_EVENT )
   26b48:	79fb      	ldrb	r3, [r7, #7]
   26b4a:	f003 0301 	and.w	r3, r3, #1
   26b4e:	2b00      	cmp	r3, #0
   26b50:	f000 80bc 	beq.w	26ccc <HciDrvHandler+0x194>
    {
        am_devices_cooper_t* pBle = (am_devices_cooper_t*)g_IomDevHdl;
   26b54:	4b5f      	ldr	r3, [pc, #380]	; (26cd4 <HciDrvHandler+0x19c>)
   26b56:	681b      	ldr	r3, [r3, #0]
   26b58:	61bb      	str	r3, [r7, #24]

        if ( pBle->bWakingUp )
   26b5a:	69bb      	ldr	r3, [r7, #24]
   26b5c:	f893 3020 	ldrb.w	r3, [r3, #32]
   26b60:	2b00      	cmp	r3, #0
   26b62:	d00a      	beq.n	26b7a <HciDrvHandler+0x42>
        {
            pBle->bWakingUp = false;
   26b64:	69bb      	ldr	r3, [r7, #24]
   26b66:	2200      	movs	r2, #0
   26b68:	f883 2020 	strb.w	r2, [r3, #32]
            /* Send any pending HCI command */
            hciCmdSend(NULL);
   26b6c:	2000      	movs	r0, #0
   26b6e:	f7fe f8c3 	bl	24cf8 <hciCmdSend>

            /* Send any pending ACL data */
            hciCoreTxReady(0);
   26b72:	2000      	movs	r0, #0
   26b74:	f7ff f840 	bl	25bf8 <hciCoreTxReady>
   26b78:	e0a8      	b.n	26ccc <HciDrvHandler+0x194>
        {
            //
            // Check to see if we read any bytes over the HCI interface that we haven't
            // already sent to the BLE stack.
            //
            if (g_ui32NumBytes > g_consumed_bytes)
   26b7a:	4b57      	ldr	r3, [pc, #348]	; (26cd8 <HciDrvHandler+0x1a0>)
   26b7c:	681a      	ldr	r2, [r3, #0]
   26b7e:	4b57      	ldr	r3, [pc, #348]	; (26cdc <HciDrvHandler+0x1a4>)
   26b80:	681b      	ldr	r3, [r3, #0]
   26b82:	429a      	cmp	r2, r3
   26b84:	d92d      	bls.n	26be2 <HciDrvHandler+0xaa>
            {
                //
                // If we have any bytes saved, we should send them to the BLE stack
                // now.
                //
                g_consumed_bytes += hciTrSerialRxIncoming(g_pui8ReadBuffer + g_consumed_bytes,
   26b86:	4b56      	ldr	r3, [pc, #344]	; (26ce0 <HciDrvHandler+0x1a8>)
   26b88:	681a      	ldr	r2, [r3, #0]
   26b8a:	4b54      	ldr	r3, [pc, #336]	; (26cdc <HciDrvHandler+0x1a4>)
   26b8c:	681b      	ldr	r3, [r3, #0]
   26b8e:	18d0      	adds	r0, r2, r3
   26b90:	4b51      	ldr	r3, [pc, #324]	; (26cd8 <HciDrvHandler+0x1a0>)
   26b92:	681b      	ldr	r3, [r3, #0]
   26b94:	b29a      	uxth	r2, r3
   26b96:	4b51      	ldr	r3, [pc, #324]	; (26cdc <HciDrvHandler+0x1a4>)
   26b98:	681b      	ldr	r3, [r3, #0]
   26b9a:	b29b      	uxth	r3, r3
   26b9c:	1ad3      	subs	r3, r2, r3
   26b9e:	b29b      	uxth	r3, r3
   26ba0:	4619      	mov	r1, r3
   26ba2:	f002 fad5 	bl	29150 <hciTrSerialRxIncoming>
   26ba6:	4603      	mov	r3, r0
   26ba8:	461a      	mov	r2, r3
   26baa:	4b4c      	ldr	r3, [pc, #304]	; (26cdc <HciDrvHandler+0x1a4>)
   26bac:	681b      	ldr	r3, [r3, #0]
   26bae:	4413      	add	r3, r2
   26bb0:	4a4a      	ldr	r2, [pc, #296]	; (26cdc <HciDrvHandler+0x1a4>)
   26bb2:	6013      	str	r3, [r2, #0]
                // If the stack doesn't accept all of the bytes we had, we will need to
                // keep the event set and come back later. Otherwise, we can just reset
                // our variables and exit the loop.
                //
                // Make sure g_ui32NumBytes is not zero.
                if (g_ui32NumBytes && (g_consumed_bytes != g_ui32NumBytes))
   26bb4:	4b48      	ldr	r3, [pc, #288]	; (26cd8 <HciDrvHandler+0x1a0>)
   26bb6:	681b      	ldr	r3, [r3, #0]
   26bb8:	2b00      	cmp	r3, #0
   26bba:	d00c      	beq.n	26bd6 <HciDrvHandler+0x9e>
   26bbc:	4b47      	ldr	r3, [pc, #284]	; (26cdc <HciDrvHandler+0x1a4>)
   26bbe:	681a      	ldr	r2, [r3, #0]
   26bc0:	4b45      	ldr	r3, [pc, #276]	; (26cd8 <HciDrvHandler+0x1a0>)
   26bc2:	681b      	ldr	r3, [r3, #0]
   26bc4:	429a      	cmp	r2, r3
   26bc6:	d006      	beq.n	26bd6 <HciDrvHandler+0x9e>
                {
                    WsfSetEvent(g_HciDrvHandleID, BLE_TRANSFER_NEEDED_EVENT);
   26bc8:	4b46      	ldr	r3, [pc, #280]	; (26ce4 <HciDrvHandler+0x1ac>)
   26bca:	781b      	ldrb	r3, [r3, #0]
   26bcc:	2101      	movs	r1, #1
   26bce:	4618      	mov	r0, r3
   26bd0:	f006 fb70 	bl	2d2b4 <WsfSetEvent>
                    return;
   26bd4:	e07a      	b.n	26ccc <HciDrvHandler+0x194>
                }
                else
                {
                    g_ui32NumBytes   = 0;
   26bd6:	4b40      	ldr	r3, [pc, #256]	; (26cd8 <HciDrvHandler+0x1a0>)
   26bd8:	2200      	movs	r2, #0
   26bda:	601a      	str	r2, [r3, #0]
                    g_consumed_bytes = 0;
   26bdc:	4b3f      	ldr	r3, [pc, #252]	; (26cdc <HciDrvHandler+0x1a4>)
   26bde:	2200      	movs	r2, #0
   26be0:	601a      	str	r2, [r3, #0]
                }
            }

            // Reset
            g_ui32NumBytes = 0;
   26be2:	4b3d      	ldr	r3, [pc, #244]	; (26cd8 <HciDrvHandler+0x1a0>)
   26be4:	2200      	movs	r2, #0
   26be6:	601a      	str	r2, [r3, #0]
            ui32ErrorStatus = am_devices_cooper_blocking_read(g_IomDevHdl, g_pui32ReadBuffer, &g_ui32NumBytes);
   26be8:	4b3a      	ldr	r3, [pc, #232]	; (26cd4 <HciDrvHandler+0x19c>)
   26bea:	681b      	ldr	r3, [r3, #0]
   26bec:	4a3a      	ldr	r2, [pc, #232]	; (26cd8 <HciDrvHandler+0x1a0>)
   26bee:	493e      	ldr	r1, [pc, #248]	; (26ce8 <HciDrvHandler+0x1b0>)
   26bf0:	4618      	mov	r0, r3
   26bf2:	f7f2 fb31 	bl	19258 <am_devices_cooper_blocking_read>
   26bf6:	61f8      	str	r0, [r7, #28]

            if (g_ui32NumBytes > AM_DEVICES_COOPER_MAX_RX_PACKET)
   26bf8:	4b37      	ldr	r3, [pc, #220]	; (26cd8 <HciDrvHandler+0x1a0>)
   26bfa:	681b      	ldr	r3, [r3, #0]
   26bfc:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
   26c00:	d916      	bls.n	26c30 <HciDrvHandler+0xf8>
            {
                CRITICAL_PRINT("\nERROR: Trying to receive an HCI packet larger than the hci driver buffer size (needs %d bytes of space).\n",
   26c02:	f00d f8fb 	bl	33dfc <am_hal_interrupt_master_disable>
   26c06:	4603      	mov	r3, r0
   26c08:	613b      	str	r3, [r7, #16]
   26c0a:	4b33      	ldr	r3, [pc, #204]	; (26cd8 <HciDrvHandler+0x1a0>)
   26c0c:	681b      	ldr	r3, [r3, #0]
   26c0e:	4619      	mov	r1, r3
   26c10:	4836      	ldr	r0, [pc, #216]	; (26cec <HciDrvHandler+0x1b4>)
   26c12:	f7f3 ffc5 	bl	1aba0 <am_util_stdio_printf>
   26c16:	693b      	ldr	r3, [r7, #16]
   26c18:	4618      	mov	r0, r3
   26c1a:	f00d f8f3 	bl	33e04 <am_hal_interrupt_master_set>
                            g_ui32NumBytes);
                ERROR_CHECK_VOID(HCI_DRV_RX_PACKET_TOO_LARGE);
   26c1e:	4b34      	ldr	r3, [pc, #208]	; (26cf0 <HciDrvHandler+0x1b8>)
   26c20:	617b      	str	r3, [r7, #20]
   26c22:	4834      	ldr	r0, [pc, #208]	; (26cf4 <HciDrvHandler+0x1bc>)
   26c24:	f7f3 ffbc 	bl	1aba0 <am_util_stdio_printf>
   26c28:	6978      	ldr	r0, [r7, #20]
   26c2a:	f7ff fe2b 	bl	26884 <error_check>
   26c2e:	e04d      	b.n	26ccc <HciDrvHandler+0x194>
            }
            else if ( ui32ErrorStatus != AM_DEVICES_COOPER_STATUS_SUCCESS)
   26c30:	69fb      	ldr	r3, [r7, #28]
   26c32:	2b00      	cmp	r3, #0
   26c34:	d019      	beq.n	26c6a <HciDrvHandler+0x132>
                // signal before calling the read function, and this driver
                // only contains a single call to the blocking read function,
                // so there shouldn't be any physical reason for the read to
                // fail.
                //
                CRITICAL_PRINT("\nHCI READ failed with status %d. Try recording with a logic analyzer to catch the error.\n",
   26c36:	f00d f8e1 	bl	33dfc <am_hal_interrupt_master_disable>
   26c3a:	4603      	mov	r3, r0
   26c3c:	60fb      	str	r3, [r7, #12]
   26c3e:	69f9      	ldr	r1, [r7, #28]
   26c40:	482d      	ldr	r0, [pc, #180]	; (26cf8 <HciDrvHandler+0x1c0>)
   26c42:	f7f3 ffad 	bl	1aba0 <am_util_stdio_printf>
   26c46:	68fb      	ldr	r3, [r7, #12]
   26c48:	4618      	mov	r0, r3
   26c4a:	f00d f8db 	bl	33e04 <am_hal_interrupt_master_set>
                            ui32ErrorStatus);
                ERROR_RECOVER(ui32ErrorStatus);
   26c4e:	69fb      	ldr	r3, [r7, #28]
   26c50:	2b00      	cmp	r3, #0
   26c52:	d03b      	beq.n	26ccc <HciDrvHandler+0x194>
   26c54:	69f8      	ldr	r0, [r7, #28]
   26c56:	f7ff fe15 	bl	26884 <error_check>
   26c5a:	f7ff fef3 	bl	26a44 <HciDrvRadioShutdown>
   26c5e:	2000      	movs	r0, #0
   26c60:	f7ff fe82 	bl	26968 <HciDrvRadioBoot>
   26c64:	f7fd f82a 	bl	23cbc <DmDevReset>
   26c68:	e030      	b.n	26ccc <HciDrvHandler+0x194>
            }
            else
            {
        #ifdef ENABLE_BLE_CTRL_TRACE
                if(*g_pui8ReadBuffer == HCI_TRACE_TYPE)
   26c6a:	4b1d      	ldr	r3, [pc, #116]	; (26ce0 <HciDrvHandler+0x1a8>)
   26c6c:	681b      	ldr	r3, [r3, #0]
   26c6e:	781b      	ldrb	r3, [r3, #0]
   26c70:	2b06      	cmp	r3, #6
   26c72:	d10e      	bne.n	26c92 <HciDrvHandler+0x15a>

                    am_util_debug_printf("Rx dbg trace: %s, len :%d\n", tmp, g_ui32NumBytes);
                    }
                #endif

                    hci_process_trace_data(g_pui8ReadBuffer+1, g_ui32NumBytes-1);
   26c74:	4b1a      	ldr	r3, [pc, #104]	; (26ce0 <HciDrvHandler+0x1a8>)
   26c76:	681b      	ldr	r3, [r3, #0]
   26c78:	1c5a      	adds	r2, r3, #1
   26c7a:	4b17      	ldr	r3, [pc, #92]	; (26cd8 <HciDrvHandler+0x1a0>)
   26c7c:	681b      	ldr	r3, [r3, #0]
   26c7e:	3b01      	subs	r3, #1
   26c80:	4619      	mov	r1, r3
   26c82:	4610      	mov	r0, r2
   26c84:	f7ff fc5c 	bl	26540 <hci_process_trace_data>
                    g_consumed_bytes = g_ui32NumBytes;
   26c88:	4b13      	ldr	r3, [pc, #76]	; (26cd8 <HciDrvHandler+0x1a0>)
   26c8a:	681b      	ldr	r3, [r3, #0]
   26c8c:	4a13      	ldr	r2, [pc, #76]	; (26cdc <HciDrvHandler+0x1a4>)
   26c8e:	6013      	str	r3, [r2, #0]
   26c90:	e01c      	b.n	26ccc <HciDrvHandler+0x194>
                    //
                    // Pass the data along to the stack. The stack should be able
                    // to read as much data as we send it.  If it can't, we need to
                    // know that.
                    //
                    g_consumed_bytes = hciTrSerialRxIncoming(g_pui8ReadBuffer, g_ui32NumBytes);
   26c92:	4b13      	ldr	r3, [pc, #76]	; (26ce0 <HciDrvHandler+0x1a8>)
   26c94:	681b      	ldr	r3, [r3, #0]
   26c96:	4a10      	ldr	r2, [pc, #64]	; (26cd8 <HciDrvHandler+0x1a0>)
   26c98:	6812      	ldr	r2, [r2, #0]
   26c9a:	b292      	uxth	r2, r2
   26c9c:	4611      	mov	r1, r2
   26c9e:	4618      	mov	r0, r3
   26ca0:	f002 fa56 	bl	29150 <hciTrSerialRxIncoming>
   26ca4:	4603      	mov	r3, r0
   26ca6:	461a      	mov	r2, r3
   26ca8:	4b0c      	ldr	r3, [pc, #48]	; (26cdc <HciDrvHandler+0x1a4>)
   26caa:	601a      	str	r2, [r3, #0]

                    // Make sure g_ui32NumBytes is not zero.
                    if (g_ui32NumBytes && (g_consumed_bytes != g_ui32NumBytes))
   26cac:	4b0a      	ldr	r3, [pc, #40]	; (26cd8 <HciDrvHandler+0x1a0>)
   26cae:	681b      	ldr	r3, [r3, #0]
   26cb0:	2b00      	cmp	r3, #0
   26cb2:	d00b      	beq.n	26ccc <HciDrvHandler+0x194>
   26cb4:	4b09      	ldr	r3, [pc, #36]	; (26cdc <HciDrvHandler+0x1a4>)
   26cb6:	681a      	ldr	r2, [r3, #0]
   26cb8:	4b07      	ldr	r3, [pc, #28]	; (26cd8 <HciDrvHandler+0x1a0>)
   26cba:	681b      	ldr	r3, [r3, #0]
   26cbc:	429a      	cmp	r2, r3
   26cbe:	d005      	beq.n	26ccc <HciDrvHandler+0x194>
                    {

                        // need to come back again
                        WsfSetEvent(g_HciDrvHandleID, BLE_TRANSFER_NEEDED_EVENT);
   26cc0:	4b08      	ldr	r3, [pc, #32]	; (26ce4 <HciDrvHandler+0x1ac>)
   26cc2:	781b      	ldrb	r3, [r3, #0]
   26cc4:	2101      	movs	r1, #1
   26cc6:	4618      	mov	r0, r3
   26cc8:	f006 faf4 	bl	2d2b4 <WsfSetEvent>
                    }
                }
            }
        }
    }
}
   26ccc:	3720      	adds	r7, #32
   26cce:	46bd      	mov	sp, r7
   26cd0:	bd80      	pop	{r7, pc}
   26cd2:	bf00      	nop
   26cd4:	10003f5c 	.word	0x10003f5c
   26cd8:	10003f68 	.word	0x10003f68
   26cdc:	10003f6c 	.word	0x10003f6c
   26ce0:	10002bf4 	.word	0x10002bf4
   26ce4:	10003f64 	.word	0x10003f64
   26ce8:	100113e0 	.word	0x100113e0
   26cec:	00044f60 	.word	0x00044f60
   26cf0:	09000002 	.word	0x09000002
   26cf4:	00044fcc 	.word	0x00044fcc
   26cf8:	00044ffc 	.word	0x00044ffc

00026cfc <HciVscSetRfPowerLevelEx>:
 *
 *  \return true when success, otherwise false
 */
/*************************************************************************************************/
bool HciVscSetRfPowerLevelEx(txPowerLevel_t txPowerlevel)
{
   26cfc:	b580      	push	{r7, lr}
   26cfe:	b084      	sub	sp, #16
   26d00:	af00      	add	r7, sp, #0
   26d02:	4603      	mov	r3, r0
   26d04:	71fb      	strb	r3, [r7, #7]
    // make sure it's 8 bit
    uint8_t tx_power_level = (uint8_t)txPowerlevel;
   26d06:	79fb      	ldrb	r3, [r7, #7]
   26d08:	73fb      	strb	r3, [r7, #15]

    if(tx_power_level < TX_POWER_LEVEL_INVALID) {
   26d0a:	7bfb      	ldrb	r3, [r7, #15]
   26d0c:	2b07      	cmp	r3, #7
   26d0e:	d809      	bhi.n	26d24 <HciVscSetRfPowerLevelEx+0x28>
      HciVendorSpecificCmd(HCI_VSC_SET_TX_POWER_LEVEL_CFG_CMD_OPCODE, HCI_VSC_SET_TX_POWER_LEVEL_CFG_CMD_LENGTH, &tx_power_level);
   26d10:	f107 030f 	add.w	r3, r7, #15
   26d14:	461a      	mov	r2, r3
   26d16:	2101      	movs	r1, #1
   26d18:	f64f 4070 	movw	r0, #64624	; 0xfc70
   26d1c:	f7fe fe4c 	bl	259b8 <HciVendorSpecificCmd>
      return true;
   26d20:	2301      	movs	r3, #1
   26d22:	e000      	b.n	26d26 <HciVscSetRfPowerLevelEx+0x2a>
    }
    else {
      return false;
   26d24:	2300      	movs	r3, #0
    }
}
   26d26:	4618      	mov	r0, r3
   26d28:	3710      	adds	r7, #16
   26d2a:	46bd      	mov	sp, r7
   26d2c:	bd80      	pop	{r7, pc}

00026d2e <HciVscSetTraceBitMap>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciVscSetTraceBitMap(ble_trace_cfg bit_map)
{
   26d2e:	b580      	push	{r7, lr}
   26d30:	b082      	sub	sp, #8
   26d32:	af00      	add	r7, sp, #0
   26d34:	6078      	str	r0, [r7, #4]
    HciVendorSpecificCmd(HCI_VSC_SET_LOG_BITMAP_CFG_CMD_OPCODE, HCI_VSC_SET_LOG_BITMAP_CFG_CMD_LENGTH, (uint8_t *)&bit_map);
   26d36:	1d3b      	adds	r3, r7, #4
   26d38:	461a      	mov	r2, r3
   26d3a:	2104      	movs	r1, #4
   26d3c:	f64f 4073 	movw	r0, #64627	; 0xfc73
   26d40:	f7fe fe3a 	bl	259b8 <HciVendorSpecificCmd>
}
   26d44:	bf00      	nop
   26d46:	3708      	adds	r7, #8
   26d48:	46bd      	mov	sp, r7
   26d4a:	bd80      	pop	{r7, pc}

00026d4c <HciVscSetCustom_BDAddr>:
 *
 *  \return true when success
 */
/*************************************************************************************************/
bool_t HciVscSetCustom_BDAddr(uint8_t *bd_addr)
{
   26d4c:	b580      	push	{r7, lr}
   26d4e:	b084      	sub	sp, #16
   26d50:	af00      	add	r7, sp, #0
   26d52:	6078      	str	r0, [r7, #4]
    uint8_t invalid_bd_addr[6] = {0};
   26d54:	2300      	movs	r3, #0
   26d56:	60bb      	str	r3, [r7, #8]
   26d58:	2300      	movs	r3, #0
   26d5a:	81bb      	strh	r3, [r7, #12]

    // When bd_addr is null, it will use Apollo's Device ID to form Bluetooth address.
    if ((bd_addr == NULL) || (memcmp(invalid_bd_addr, bd_addr, 6) == 0))
   26d5c:	687b      	ldr	r3, [r7, #4]
   26d5e:	2b00      	cmp	r3, #0
   26d60:	d009      	beq.n	26d76 <HciVscSetCustom_BDAddr+0x2a>
   26d62:	f107 0308 	add.w	r3, r7, #8
   26d66:	2206      	movs	r2, #6
   26d68:	6879      	ldr	r1, [r7, #4]
   26d6a:	4618      	mov	r0, r3
   26d6c:	f009 f924 	bl	2ffb8 <memcmp>
   26d70:	4603      	mov	r3, r0
   26d72:	2b00      	cmp	r3, #0
   26d74:	d101      	bne.n	26d7a <HciVscSetCustom_BDAddr+0x2e>
        return false;
   26d76:	2300      	movs	r3, #0
   26d78:	e006      	b.n	26d88 <HciVscSetCustom_BDAddr+0x3c>
    else {
        memcpy(g_BLEMacAddress, bd_addr, 6);
   26d7a:	4b05      	ldr	r3, [pc, #20]	; (26d90 <HciVscSetCustom_BDAddr+0x44>)
   26d7c:	687a      	ldr	r2, [r7, #4]
   26d7e:	6810      	ldr	r0, [r2, #0]
   26d80:	6018      	str	r0, [r3, #0]
   26d82:	8892      	ldrh	r2, [r2, #4]
   26d84:	809a      	strh	r2, [r3, #4]
        return true;
   26d86:	2301      	movs	r3, #1
    }
}
   26d88:	4618      	mov	r0, r3
   26d8a:	3710      	adds	r7, #16
   26d8c:	46bd      	mov	sp, r7
   26d8e:	bd80      	pop	{r7, pc}
   26d90:	10003f54 	.word	0x10003f54

00026d94 <HciVscUpdateBDAddress>:

void HciVscUpdateBDAddress(void)
{
   26d94:	b580      	push	{r7, lr}
   26d96:	af00      	add	r7, sp, #0
    HciVendorSpecificCmd(HCI_VSC_SET_BD_ADDR_CFG_CMD_OPCODE, HCI_VSC_SET_BD_ADDR_CFG_CMD_LENGTH, g_BLEMacAddress);
   26d98:	4a03      	ldr	r2, [pc, #12]	; (26da8 <HciVscUpdateBDAddress+0x14>)
   26d9a:	2106      	movs	r1, #6
   26d9c:	f64f 4074 	movw	r0, #64628	; 0xfc74
   26da0:	f7fe fe0a 	bl	259b8 <HciVendorSpecificCmd>
}
   26da4:	bf00      	nop
   26da6:	bd80      	pop	{r7, pc}
   26da8:	10003f54 	.word	0x10003f54

00026dac <HciVscUpdateNvdsParam>:
    NVDS_PARAMETER_EXT_WAKEUP_TIME,
    NVDS_PARAMETER_OSC_WAKEUP_TIME
};

void HciVscUpdateNvdsParam(void)
{
   26dac:	b580      	push	{r7, lr}
   26dae:	af00      	add	r7, sp, #0
    HciVendorSpecificCmd(HCI_VSC_UPDATE_NVDS_CFG_CMD_OPCODE, HCI_VSC_UPDATE_NVDS_CFG_CMD_LENGTH, nvds_data);
   26db0:	4a03      	ldr	r2, [pc, #12]	; (26dc0 <HciVscUpdateNvdsParam+0x14>)
   26db2:	21f0      	movs	r1, #240	; 0xf0
   26db4:	f64f 4077 	movw	r0, #64631	; 0xfc77
   26db8:	f7fe fdfe 	bl	259b8 <HciVendorSpecificCmd>
}
   26dbc:	bf00      	nop
   26dbe:	bd80      	pop	{r7, pc}
   26dc0:	10002bf8 	.word	0x10002bf8

00026dc4 <HciVscUpdateLinklayerFeature>:

uint8_t ll_local_feats[LE_FEATS_LEN] = {0};

void HciVscUpdateLinklayerFeature(void)
{
   26dc4:	b580      	push	{r7, lr}
   26dc6:	af00      	add	r7, sp, #0
    ll_local_feats[0] = (uint8_t)LL_FEATURES_BYTE0;
   26dc8:	4b09      	ldr	r3, [pc, #36]	; (26df0 <HciVscUpdateLinklayerFeature+0x2c>)
   26dca:	22ff      	movs	r2, #255	; 0xff
   26dcc:	701a      	strb	r2, [r3, #0]
    ll_local_feats[1] = (uint8_t)(LL_FEATURES_BYTE1>>8);
   26dce:	4b08      	ldr	r3, [pc, #32]	; (26df0 <HciVscUpdateLinklayerFeature+0x2c>)
   26dd0:	2271      	movs	r2, #113	; 0x71
   26dd2:	705a      	strb	r2, [r3, #1]
    ll_local_feats[2] = (uint8_t)(LL_FEATURES_BYTE2>>16);
   26dd4:	4b06      	ldr	r3, [pc, #24]	; (26df0 <HciVscUpdateLinklayerFeature+0x2c>)
   26dd6:	22ff      	movs	r2, #255	; 0xff
   26dd8:	709a      	strb	r2, [r3, #2]
    ll_local_feats[3] = (uint8_t)(LL_FEATURES_BYTE3>>24);
   26dda:	4b05      	ldr	r3, [pc, #20]	; (26df0 <HciVscUpdateLinklayerFeature+0x2c>)
   26ddc:	220f      	movs	r2, #15
   26dde:	70da      	strb	r2, [r3, #3]

    HciVendorSpecificCmd(HCI_VSC_UPDATE_LL_FEATURE_CFG_CMD_OPCODE, LE_FEATS_LEN, ll_local_feats);
   26de0:	4a03      	ldr	r2, [pc, #12]	; (26df0 <HciVscUpdateLinklayerFeature+0x2c>)
   26de2:	2108      	movs	r1, #8
   26de4:	f64f 4078 	movw	r0, #64632	; 0xfc78
   26de8:	f7fe fde6 	bl	259b8 <HciVendorSpecificCmd>
}
   26dec:	bf00      	nop
   26dee:	bd80      	pop	{r7, pc}
   26df0:	10003f78 	.word	0x10003f78

00026df4 <hciEvtParseLeConnCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeConnCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   26df4:	b580      	push	{r7, lr}
   26df6:	b084      	sub	sp, #16
   26df8:	af00      	add	r7, sp, #0
   26dfa:	60f8      	str	r0, [r7, #12]
   26dfc:	60b9      	str	r1, [r7, #8]
   26dfe:	4613      	mov	r3, r2
   26e00:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.status, p);
   26e02:	68bb      	ldr	r3, [r7, #8]
   26e04:	1c5a      	adds	r2, r3, #1
   26e06:	60ba      	str	r2, [r7, #8]
   26e08:	781a      	ldrb	r2, [r3, #0]
   26e0a:	68fb      	ldr	r3, [r7, #12]
   26e0c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.handle, p);
   26e0e:	68bb      	ldr	r3, [r7, #8]
   26e10:	781b      	ldrb	r3, [r3, #0]
   26e12:	b29a      	uxth	r2, r3
   26e14:	68bb      	ldr	r3, [r7, #8]
   26e16:	3301      	adds	r3, #1
   26e18:	781b      	ldrb	r3, [r3, #0]
   26e1a:	b29b      	uxth	r3, r3
   26e1c:	021b      	lsls	r3, r3, #8
   26e1e:	b29b      	uxth	r3, r3
   26e20:	4413      	add	r3, r2
   26e22:	b29a      	uxth	r2, r3
   26e24:	68fb      	ldr	r3, [r7, #12]
   26e26:	80da      	strh	r2, [r3, #6]
   26e28:	68bb      	ldr	r3, [r7, #8]
   26e2a:	3302      	adds	r3, #2
   26e2c:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.role, p);
   26e2e:	68bb      	ldr	r3, [r7, #8]
   26e30:	1c5a      	adds	r2, r3, #1
   26e32:	60ba      	str	r2, [r7, #8]
   26e34:	781a      	ldrb	r2, [r3, #0]
   26e36:	68fb      	ldr	r3, [r7, #12]
   26e38:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.addrType, p);
   26e3a:	68bb      	ldr	r3, [r7, #8]
   26e3c:	1c5a      	adds	r2, r3, #1
   26e3e:	60ba      	str	r2, [r7, #8]
   26e40:	781a      	ldrb	r2, [r3, #0]
   26e42:	68fb      	ldr	r3, [r7, #12]
   26e44:	725a      	strb	r2, [r3, #9]
  BSTREAM_TO_BDA(pMsg->leConnCmpl.peerAddr, p);
   26e46:	68fb      	ldr	r3, [r7, #12]
   26e48:	330a      	adds	r3, #10
   26e4a:	68b9      	ldr	r1, [r7, #8]
   26e4c:	4618      	mov	r0, r3
   26e4e:	f7fa fe9a 	bl	21b86 <BdaCpy>
   26e52:	68bb      	ldr	r3, [r7, #8]
   26e54:	3306      	adds	r3, #6
   26e56:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.connInterval, p);
   26e58:	68bb      	ldr	r3, [r7, #8]
   26e5a:	781b      	ldrb	r3, [r3, #0]
   26e5c:	b29a      	uxth	r2, r3
   26e5e:	68bb      	ldr	r3, [r7, #8]
   26e60:	3301      	adds	r3, #1
   26e62:	781b      	ldrb	r3, [r3, #0]
   26e64:	b29b      	uxth	r3, r3
   26e66:	021b      	lsls	r3, r3, #8
   26e68:	b29b      	uxth	r3, r3
   26e6a:	4413      	add	r3, r2
   26e6c:	b29a      	uxth	r2, r3
   26e6e:	68fb      	ldr	r3, [r7, #12]
   26e70:	821a      	strh	r2, [r3, #16]
   26e72:	68bb      	ldr	r3, [r7, #8]
   26e74:	3302      	adds	r3, #2
   26e76:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.connLatency, p);
   26e78:	68bb      	ldr	r3, [r7, #8]
   26e7a:	781b      	ldrb	r3, [r3, #0]
   26e7c:	b29a      	uxth	r2, r3
   26e7e:	68bb      	ldr	r3, [r7, #8]
   26e80:	3301      	adds	r3, #1
   26e82:	781b      	ldrb	r3, [r3, #0]
   26e84:	b29b      	uxth	r3, r3
   26e86:	021b      	lsls	r3, r3, #8
   26e88:	b29b      	uxth	r3, r3
   26e8a:	4413      	add	r3, r2
   26e8c:	b29a      	uxth	r2, r3
   26e8e:	68fb      	ldr	r3, [r7, #12]
   26e90:	825a      	strh	r2, [r3, #18]
   26e92:	68bb      	ldr	r3, [r7, #8]
   26e94:	3302      	adds	r3, #2
   26e96:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.supTimeout, p);
   26e98:	68bb      	ldr	r3, [r7, #8]
   26e9a:	781b      	ldrb	r3, [r3, #0]
   26e9c:	b29a      	uxth	r2, r3
   26e9e:	68bb      	ldr	r3, [r7, #8]
   26ea0:	3301      	adds	r3, #1
   26ea2:	781b      	ldrb	r3, [r3, #0]
   26ea4:	b29b      	uxth	r3, r3
   26ea6:	021b      	lsls	r3, r3, #8
   26ea8:	b29b      	uxth	r3, r3
   26eaa:	4413      	add	r3, r2
   26eac:	b29a      	uxth	r2, r3
   26eae:	68fb      	ldr	r3, [r7, #12]
   26eb0:	829a      	strh	r2, [r3, #20]
   26eb2:	68bb      	ldr	r3, [r7, #8]
   26eb4:	3302      	adds	r3, #2
   26eb6:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.clockAccuracy, p);
   26eb8:	68bb      	ldr	r3, [r7, #8]
   26eba:	1c5a      	adds	r2, r3, #1
   26ebc:	60ba      	str	r2, [r7, #8]
   26ebe:	781a      	ldrb	r2, [r3, #0]
   26ec0:	68fb      	ldr	r3, [r7, #12]
   26ec2:	759a      	strb	r2, [r3, #22]

  /* zero out unused fields */
  memset(pMsg->leConnCmpl.localRpa, 0, BDA_ADDR_LEN);
   26ec4:	68fb      	ldr	r3, [r7, #12]
   26ec6:	3317      	adds	r3, #23
   26ec8:	2206      	movs	r2, #6
   26eca:	2100      	movs	r1, #0
   26ecc:	4618      	mov	r0, r3
   26ece:	f009 f90f 	bl	300f0 <memset>
  memset(pMsg->leConnCmpl.peerRpa, 0, BDA_ADDR_LEN);
   26ed2:	68fb      	ldr	r3, [r7, #12]
   26ed4:	331d      	adds	r3, #29
   26ed6:	2206      	movs	r2, #6
   26ed8:	2100      	movs	r1, #0
   26eda:	4618      	mov	r0, r3
   26edc:	f009 f908 	bl	300f0 <memset>

  pMsg->hdr.param = pMsg->leConnCmpl.handle;
   26ee0:	68fb      	ldr	r3, [r7, #12]
   26ee2:	88da      	ldrh	r2, [r3, #6]
   26ee4:	68fb      	ldr	r3, [r7, #12]
   26ee6:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leConnCmpl.status;
   26ee8:	68fb      	ldr	r3, [r7, #12]
   26eea:	791a      	ldrb	r2, [r3, #4]
   26eec:	68fb      	ldr	r3, [r7, #12]
   26eee:	70da      	strb	r2, [r3, #3]
}
   26ef0:	bf00      	nop
   26ef2:	3710      	adds	r7, #16
   26ef4:	46bd      	mov	sp, r7
   26ef6:	bd80      	pop	{r7, pc}

00026ef8 <hciEvtParseLeEnhancedConnCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeEnhancedConnCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   26ef8:	b580      	push	{r7, lr}
   26efa:	b084      	sub	sp, #16
   26efc:	af00      	add	r7, sp, #0
   26efe:	60f8      	str	r0, [r7, #12]
   26f00:	60b9      	str	r1, [r7, #8]
   26f02:	4613      	mov	r3, r2
   26f04:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.status, p);
   26f06:	68bb      	ldr	r3, [r7, #8]
   26f08:	1c5a      	adds	r2, r3, #1
   26f0a:	60ba      	str	r2, [r7, #8]
   26f0c:	781a      	ldrb	r2, [r3, #0]
   26f0e:	68fb      	ldr	r3, [r7, #12]
   26f10:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.handle, p);
   26f12:	68bb      	ldr	r3, [r7, #8]
   26f14:	781b      	ldrb	r3, [r3, #0]
   26f16:	b29a      	uxth	r2, r3
   26f18:	68bb      	ldr	r3, [r7, #8]
   26f1a:	3301      	adds	r3, #1
   26f1c:	781b      	ldrb	r3, [r3, #0]
   26f1e:	b29b      	uxth	r3, r3
   26f20:	021b      	lsls	r3, r3, #8
   26f22:	b29b      	uxth	r3, r3
   26f24:	4413      	add	r3, r2
   26f26:	b29a      	uxth	r2, r3
   26f28:	68fb      	ldr	r3, [r7, #12]
   26f2a:	80da      	strh	r2, [r3, #6]
   26f2c:	68bb      	ldr	r3, [r7, #8]
   26f2e:	3302      	adds	r3, #2
   26f30:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.role, p);
   26f32:	68bb      	ldr	r3, [r7, #8]
   26f34:	1c5a      	adds	r2, r3, #1
   26f36:	60ba      	str	r2, [r7, #8]
   26f38:	781a      	ldrb	r2, [r3, #0]
   26f3a:	68fb      	ldr	r3, [r7, #12]
   26f3c:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.addrType, p);
   26f3e:	68bb      	ldr	r3, [r7, #8]
   26f40:	1c5a      	adds	r2, r3, #1
   26f42:	60ba      	str	r2, [r7, #8]
   26f44:	781a      	ldrb	r2, [r3, #0]
   26f46:	68fb      	ldr	r3, [r7, #12]
   26f48:	725a      	strb	r2, [r3, #9]
  BSTREAM_TO_BDA(pMsg->leConnCmpl.peerAddr, p);
   26f4a:	68fb      	ldr	r3, [r7, #12]
   26f4c:	330a      	adds	r3, #10
   26f4e:	68b9      	ldr	r1, [r7, #8]
   26f50:	4618      	mov	r0, r3
   26f52:	f7fa fe18 	bl	21b86 <BdaCpy>
   26f56:	68bb      	ldr	r3, [r7, #8]
   26f58:	3306      	adds	r3, #6
   26f5a:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_BDA(pMsg->leConnCmpl.localRpa, p);
   26f5c:	68fb      	ldr	r3, [r7, #12]
   26f5e:	3317      	adds	r3, #23
   26f60:	68b9      	ldr	r1, [r7, #8]
   26f62:	4618      	mov	r0, r3
   26f64:	f7fa fe0f 	bl	21b86 <BdaCpy>
   26f68:	68bb      	ldr	r3, [r7, #8]
   26f6a:	3306      	adds	r3, #6
   26f6c:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_BDA(pMsg->leConnCmpl.peerRpa, p);
   26f6e:	68fb      	ldr	r3, [r7, #12]
   26f70:	331d      	adds	r3, #29
   26f72:	68b9      	ldr	r1, [r7, #8]
   26f74:	4618      	mov	r0, r3
   26f76:	f7fa fe06 	bl	21b86 <BdaCpy>
   26f7a:	68bb      	ldr	r3, [r7, #8]
   26f7c:	3306      	adds	r3, #6
   26f7e:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.connInterval, p);
   26f80:	68bb      	ldr	r3, [r7, #8]
   26f82:	781b      	ldrb	r3, [r3, #0]
   26f84:	b29a      	uxth	r2, r3
   26f86:	68bb      	ldr	r3, [r7, #8]
   26f88:	3301      	adds	r3, #1
   26f8a:	781b      	ldrb	r3, [r3, #0]
   26f8c:	b29b      	uxth	r3, r3
   26f8e:	021b      	lsls	r3, r3, #8
   26f90:	b29b      	uxth	r3, r3
   26f92:	4413      	add	r3, r2
   26f94:	b29a      	uxth	r2, r3
   26f96:	68fb      	ldr	r3, [r7, #12]
   26f98:	821a      	strh	r2, [r3, #16]
   26f9a:	68bb      	ldr	r3, [r7, #8]
   26f9c:	3302      	adds	r3, #2
   26f9e:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.connLatency, p);
   26fa0:	68bb      	ldr	r3, [r7, #8]
   26fa2:	781b      	ldrb	r3, [r3, #0]
   26fa4:	b29a      	uxth	r2, r3
   26fa6:	68bb      	ldr	r3, [r7, #8]
   26fa8:	3301      	adds	r3, #1
   26faa:	781b      	ldrb	r3, [r3, #0]
   26fac:	b29b      	uxth	r3, r3
   26fae:	021b      	lsls	r3, r3, #8
   26fb0:	b29b      	uxth	r3, r3
   26fb2:	4413      	add	r3, r2
   26fb4:	b29a      	uxth	r2, r3
   26fb6:	68fb      	ldr	r3, [r7, #12]
   26fb8:	825a      	strh	r2, [r3, #18]
   26fba:	68bb      	ldr	r3, [r7, #8]
   26fbc:	3302      	adds	r3, #2
   26fbe:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnCmpl.supTimeout, p);
   26fc0:	68bb      	ldr	r3, [r7, #8]
   26fc2:	781b      	ldrb	r3, [r3, #0]
   26fc4:	b29a      	uxth	r2, r3
   26fc6:	68bb      	ldr	r3, [r7, #8]
   26fc8:	3301      	adds	r3, #1
   26fca:	781b      	ldrb	r3, [r3, #0]
   26fcc:	b29b      	uxth	r3, r3
   26fce:	021b      	lsls	r3, r3, #8
   26fd0:	b29b      	uxth	r3, r3
   26fd2:	4413      	add	r3, r2
   26fd4:	b29a      	uxth	r2, r3
   26fd6:	68fb      	ldr	r3, [r7, #12]
   26fd8:	829a      	strh	r2, [r3, #20]
   26fda:	68bb      	ldr	r3, [r7, #8]
   26fdc:	3302      	adds	r3, #2
   26fde:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leConnCmpl.clockAccuracy, p);
   26fe0:	68bb      	ldr	r3, [r7, #8]
   26fe2:	1c5a      	adds	r2, r3, #1
   26fe4:	60ba      	str	r2, [r7, #8]
   26fe6:	781a      	ldrb	r2, [r3, #0]
   26fe8:	68fb      	ldr	r3, [r7, #12]
   26fea:	759a      	strb	r2, [r3, #22]

  pMsg->hdr.param = pMsg->leConnCmpl.handle;
   26fec:	68fb      	ldr	r3, [r7, #12]
   26fee:	88da      	ldrh	r2, [r3, #6]
   26ff0:	68fb      	ldr	r3, [r7, #12]
   26ff2:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leConnCmpl.status;
   26ff4:	68fb      	ldr	r3, [r7, #12]
   26ff6:	791a      	ldrb	r2, [r3, #4]
   26ff8:	68fb      	ldr	r3, [r7, #12]
   26ffa:	70da      	strb	r2, [r3, #3]
}
   26ffc:	bf00      	nop
   26ffe:	3710      	adds	r7, #16
   27000:	46bd      	mov	sp, r7
   27002:	bd80      	pop	{r7, pc}

00027004 <hciEvtParseDisconnectCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseDisconnectCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27004:	b480      	push	{r7}
   27006:	b085      	sub	sp, #20
   27008:	af00      	add	r7, sp, #0
   2700a:	60f8      	str	r0, [r7, #12]
   2700c:	60b9      	str	r1, [r7, #8]
   2700e:	4613      	mov	r3, r2
   27010:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->disconnectCmpl.status, p);
   27012:	68bb      	ldr	r3, [r7, #8]
   27014:	1c5a      	adds	r2, r3, #1
   27016:	60ba      	str	r2, [r7, #8]
   27018:	781a      	ldrb	r2, [r3, #0]
   2701a:	68fb      	ldr	r3, [r7, #12]
   2701c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->disconnectCmpl.handle, p);
   2701e:	68bb      	ldr	r3, [r7, #8]
   27020:	781b      	ldrb	r3, [r3, #0]
   27022:	b29a      	uxth	r2, r3
   27024:	68bb      	ldr	r3, [r7, #8]
   27026:	3301      	adds	r3, #1
   27028:	781b      	ldrb	r3, [r3, #0]
   2702a:	b29b      	uxth	r3, r3
   2702c:	021b      	lsls	r3, r3, #8
   2702e:	b29b      	uxth	r3, r3
   27030:	4413      	add	r3, r2
   27032:	b29a      	uxth	r2, r3
   27034:	68fb      	ldr	r3, [r7, #12]
   27036:	80da      	strh	r2, [r3, #6]
   27038:	68bb      	ldr	r3, [r7, #8]
   2703a:	3302      	adds	r3, #2
   2703c:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->disconnectCmpl.reason, p);
   2703e:	68bb      	ldr	r3, [r7, #8]
   27040:	1c5a      	adds	r2, r3, #1
   27042:	60ba      	str	r2, [r7, #8]
   27044:	781a      	ldrb	r2, [r3, #0]
   27046:	68fb      	ldr	r3, [r7, #12]
   27048:	721a      	strb	r2, [r3, #8]

  pMsg->hdr.param = pMsg->disconnectCmpl.handle;
   2704a:	68fb      	ldr	r3, [r7, #12]
   2704c:	88da      	ldrh	r2, [r3, #6]
   2704e:	68fb      	ldr	r3, [r7, #12]
   27050:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->disconnectCmpl.status;
   27052:	68fb      	ldr	r3, [r7, #12]
   27054:	791a      	ldrb	r2, [r3, #4]
   27056:	68fb      	ldr	r3, [r7, #12]
   27058:	70da      	strb	r2, [r3, #3]
}
   2705a:	bf00      	nop
   2705c:	3714      	adds	r7, #20
   2705e:	46bd      	mov	sp, r7
   27060:	f85d 7b04 	ldr.w	r7, [sp], #4
   27064:	4770      	bx	lr

00027066 <hciEvtParseLeConnUpdateCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeConnUpdateCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27066:	b480      	push	{r7}
   27068:	b085      	sub	sp, #20
   2706a:	af00      	add	r7, sp, #0
   2706c:	60f8      	str	r0, [r7, #12]
   2706e:	60b9      	str	r1, [r7, #8]
   27070:	4613      	mov	r3, r2
   27072:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leConnUpdateCmpl.status, p);
   27074:	68bb      	ldr	r3, [r7, #8]
   27076:	1c5a      	adds	r2, r3, #1
   27078:	60ba      	str	r2, [r7, #8]
   2707a:	781a      	ldrb	r2, [r3, #0]
   2707c:	68fb      	ldr	r3, [r7, #12]
   2707e:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leConnUpdateCmpl.handle, p);
   27080:	68bb      	ldr	r3, [r7, #8]
   27082:	781b      	ldrb	r3, [r3, #0]
   27084:	b29a      	uxth	r2, r3
   27086:	68bb      	ldr	r3, [r7, #8]
   27088:	3301      	adds	r3, #1
   2708a:	781b      	ldrb	r3, [r3, #0]
   2708c:	b29b      	uxth	r3, r3
   2708e:	021b      	lsls	r3, r3, #8
   27090:	b29b      	uxth	r3, r3
   27092:	4413      	add	r3, r2
   27094:	b29a      	uxth	r2, r3
   27096:	68fb      	ldr	r3, [r7, #12]
   27098:	80da      	strh	r2, [r3, #6]
   2709a:	68bb      	ldr	r3, [r7, #8]
   2709c:	3302      	adds	r3, #2
   2709e:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnUpdateCmpl.connInterval, p);
   270a0:	68bb      	ldr	r3, [r7, #8]
   270a2:	781b      	ldrb	r3, [r3, #0]
   270a4:	b29a      	uxth	r2, r3
   270a6:	68bb      	ldr	r3, [r7, #8]
   270a8:	3301      	adds	r3, #1
   270aa:	781b      	ldrb	r3, [r3, #0]
   270ac:	b29b      	uxth	r3, r3
   270ae:	021b      	lsls	r3, r3, #8
   270b0:	b29b      	uxth	r3, r3
   270b2:	4413      	add	r3, r2
   270b4:	b29a      	uxth	r2, r3
   270b6:	68fb      	ldr	r3, [r7, #12]
   270b8:	811a      	strh	r2, [r3, #8]
   270ba:	68bb      	ldr	r3, [r7, #8]
   270bc:	3302      	adds	r3, #2
   270be:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnUpdateCmpl.connLatency, p);
   270c0:	68bb      	ldr	r3, [r7, #8]
   270c2:	781b      	ldrb	r3, [r3, #0]
   270c4:	b29a      	uxth	r2, r3
   270c6:	68bb      	ldr	r3, [r7, #8]
   270c8:	3301      	adds	r3, #1
   270ca:	781b      	ldrb	r3, [r3, #0]
   270cc:	b29b      	uxth	r3, r3
   270ce:	021b      	lsls	r3, r3, #8
   270d0:	b29b      	uxth	r3, r3
   270d2:	4413      	add	r3, r2
   270d4:	b29a      	uxth	r2, r3
   270d6:	68fb      	ldr	r3, [r7, #12]
   270d8:	815a      	strh	r2, [r3, #10]
   270da:	68bb      	ldr	r3, [r7, #8]
   270dc:	3302      	adds	r3, #2
   270de:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leConnUpdateCmpl.supTimeout, p);
   270e0:	68bb      	ldr	r3, [r7, #8]
   270e2:	781b      	ldrb	r3, [r3, #0]
   270e4:	b29a      	uxth	r2, r3
   270e6:	68bb      	ldr	r3, [r7, #8]
   270e8:	3301      	adds	r3, #1
   270ea:	781b      	ldrb	r3, [r3, #0]
   270ec:	b29b      	uxth	r3, r3
   270ee:	021b      	lsls	r3, r3, #8
   270f0:	b29b      	uxth	r3, r3
   270f2:	4413      	add	r3, r2
   270f4:	b29a      	uxth	r2, r3
   270f6:	68fb      	ldr	r3, [r7, #12]
   270f8:	819a      	strh	r2, [r3, #12]
   270fa:	68bb      	ldr	r3, [r7, #8]
   270fc:	3302      	adds	r3, #2
   270fe:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leConnUpdateCmpl.handle;
   27100:	68fb      	ldr	r3, [r7, #12]
   27102:	88da      	ldrh	r2, [r3, #6]
   27104:	68fb      	ldr	r3, [r7, #12]
   27106:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leConnUpdateCmpl.status;
   27108:	68fb      	ldr	r3, [r7, #12]
   2710a:	791a      	ldrb	r2, [r3, #4]
   2710c:	68fb      	ldr	r3, [r7, #12]
   2710e:	70da      	strb	r2, [r3, #3]
}
   27110:	bf00      	nop
   27112:	3714      	adds	r7, #20
   27114:	46bd      	mov	sp, r7
   27116:	f85d 7b04 	ldr.w	r7, [sp], #4
   2711a:	4770      	bx	lr

0002711c <hciEvtParseLeCreateConnCancelCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeCreateConnCancelCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2711c:	b480      	push	{r7}
   2711e:	b085      	sub	sp, #20
   27120:	af00      	add	r7, sp, #0
   27122:	60f8      	str	r0, [r7, #12]
   27124:	60b9      	str	r1, [r7, #8]
   27126:	4613      	mov	r3, r2
   27128:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leCreateConnCancelCmdCmpl.status, p);
   2712a:	68bb      	ldr	r3, [r7, #8]
   2712c:	1c5a      	adds	r2, r3, #1
   2712e:	60ba      	str	r2, [r7, #8]
   27130:	781a      	ldrb	r2, [r3, #0]
   27132:	68fb      	ldr	r3, [r7, #12]
   27134:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leCreateConnCancelCmdCmpl.status;
   27136:	68fb      	ldr	r3, [r7, #12]
   27138:	791a      	ldrb	r2, [r3, #4]
   2713a:	68fb      	ldr	r3, [r7, #12]
   2713c:	70da      	strb	r2, [r3, #3]
}
   2713e:	bf00      	nop
   27140:	3714      	adds	r7, #20
   27142:	46bd      	mov	sp, r7
   27144:	f85d 7b04 	ldr.w	r7, [sp], #4
   27148:	4770      	bx	lr

0002714a <hciEvtParseReadRssiCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadRssiCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2714a:	b480      	push	{r7}
   2714c:	b085      	sub	sp, #20
   2714e:	af00      	add	r7, sp, #0
   27150:	60f8      	str	r0, [r7, #12]
   27152:	60b9      	str	r1, [r7, #8]
   27154:	4613      	mov	r3, r2
   27156:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->readRssiCmdCmpl.status, p);
   27158:	68bb      	ldr	r3, [r7, #8]
   2715a:	1c5a      	adds	r2, r3, #1
   2715c:	60ba      	str	r2, [r7, #8]
   2715e:	781a      	ldrb	r2, [r3, #0]
   27160:	68fb      	ldr	r3, [r7, #12]
   27162:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->readRssiCmdCmpl.handle, p);
   27164:	68bb      	ldr	r3, [r7, #8]
   27166:	781b      	ldrb	r3, [r3, #0]
   27168:	b29a      	uxth	r2, r3
   2716a:	68bb      	ldr	r3, [r7, #8]
   2716c:	3301      	adds	r3, #1
   2716e:	781b      	ldrb	r3, [r3, #0]
   27170:	b29b      	uxth	r3, r3
   27172:	021b      	lsls	r3, r3, #8
   27174:	b29b      	uxth	r3, r3
   27176:	4413      	add	r3, r2
   27178:	b29a      	uxth	r2, r3
   2717a:	68fb      	ldr	r3, [r7, #12]
   2717c:	80da      	strh	r2, [r3, #6]
   2717e:	68bb      	ldr	r3, [r7, #8]
   27180:	3302      	adds	r3, #2
   27182:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->readRssiCmdCmpl.rssi, p);
   27184:	68bb      	ldr	r3, [r7, #8]
   27186:	1c5a      	adds	r2, r3, #1
   27188:	60ba      	str	r2, [r7, #8]
   2718a:	781b      	ldrb	r3, [r3, #0]
   2718c:	b25a      	sxtb	r2, r3
   2718e:	68fb      	ldr	r3, [r7, #12]
   27190:	721a      	strb	r2, [r3, #8]

  pMsg->hdr.param = pMsg->readRssiCmdCmpl.handle;
   27192:	68fb      	ldr	r3, [r7, #12]
   27194:	88da      	ldrh	r2, [r3, #6]
   27196:	68fb      	ldr	r3, [r7, #12]
   27198:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->readRssiCmdCmpl.status;
   2719a:	68fb      	ldr	r3, [r7, #12]
   2719c:	791a      	ldrb	r2, [r3, #4]
   2719e:	68fb      	ldr	r3, [r7, #12]
   271a0:	70da      	strb	r2, [r3, #3]
}
   271a2:	bf00      	nop
   271a4:	3714      	adds	r7, #20
   271a6:	46bd      	mov	sp, r7
   271a8:	f85d 7b04 	ldr.w	r7, [sp], #4
   271ac:	4770      	bx	lr

000271ae <hciEvtParseReadChanMapCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadChanMapCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   271ae:	b580      	push	{r7, lr}
   271b0:	b084      	sub	sp, #16
   271b2:	af00      	add	r7, sp, #0
   271b4:	60f8      	str	r0, [r7, #12]
   271b6:	60b9      	str	r1, [r7, #8]
   271b8:	4613      	mov	r3, r2
   271ba:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->readChanMapCmdCmpl.status, p);
   271bc:	68bb      	ldr	r3, [r7, #8]
   271be:	1c5a      	adds	r2, r3, #1
   271c0:	60ba      	str	r2, [r7, #8]
   271c2:	781a      	ldrb	r2, [r3, #0]
   271c4:	68fb      	ldr	r3, [r7, #12]
   271c6:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->readChanMapCmdCmpl.handle, p);
   271c8:	68bb      	ldr	r3, [r7, #8]
   271ca:	781b      	ldrb	r3, [r3, #0]
   271cc:	b29a      	uxth	r2, r3
   271ce:	68bb      	ldr	r3, [r7, #8]
   271d0:	3301      	adds	r3, #1
   271d2:	781b      	ldrb	r3, [r3, #0]
   271d4:	b29b      	uxth	r3, r3
   271d6:	021b      	lsls	r3, r3, #8
   271d8:	b29b      	uxth	r3, r3
   271da:	4413      	add	r3, r2
   271dc:	b29a      	uxth	r2, r3
   271de:	68fb      	ldr	r3, [r7, #12]
   271e0:	80da      	strh	r2, [r3, #6]
   271e2:	68bb      	ldr	r3, [r7, #8]
   271e4:	3302      	adds	r3, #2
   271e6:	60bb      	str	r3, [r7, #8]

  memcpy(pMsg->readChanMapCmdCmpl.chanMap, p, HCI_CHAN_MAP_LEN);
   271e8:	68fb      	ldr	r3, [r7, #12]
   271ea:	3308      	adds	r3, #8
   271ec:	2205      	movs	r2, #5
   271ee:	68b9      	ldr	r1, [r7, #8]
   271f0:	4618      	mov	r0, r3
   271f2:	f7f1 f82f 	bl	18254 <memcpy>

  pMsg->hdr.param = pMsg->readChanMapCmdCmpl.handle;
   271f6:	68fb      	ldr	r3, [r7, #12]
   271f8:	88da      	ldrh	r2, [r3, #6]
   271fa:	68fb      	ldr	r3, [r7, #12]
   271fc:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->readChanMapCmdCmpl.status;
   271fe:	68fb      	ldr	r3, [r7, #12]
   27200:	791a      	ldrb	r2, [r3, #4]
   27202:	68fb      	ldr	r3, [r7, #12]
   27204:	70da      	strb	r2, [r3, #3]
}
   27206:	bf00      	nop
   27208:	3710      	adds	r7, #16
   2720a:	46bd      	mov	sp, r7
   2720c:	bd80      	pop	{r7, pc}

0002720e <hciEvtParseReadTxPwrLvlCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadTxPwrLvlCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2720e:	b480      	push	{r7}
   27210:	b085      	sub	sp, #20
   27212:	af00      	add	r7, sp, #0
   27214:	60f8      	str	r0, [r7, #12]
   27216:	60b9      	str	r1, [r7, #8]
   27218:	4613      	mov	r3, r2
   2721a:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->readTxPwrLvlCmdCmpl.status, p);
   2721c:	68bb      	ldr	r3, [r7, #8]
   2721e:	1c5a      	adds	r2, r3, #1
   27220:	60ba      	str	r2, [r7, #8]
   27222:	781a      	ldrb	r2, [r3, #0]
   27224:	68fb      	ldr	r3, [r7, #12]
   27226:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->readTxPwrLvlCmdCmpl.handle, p);
   27228:	68bb      	ldr	r3, [r7, #8]
   2722a:	781a      	ldrb	r2, [r3, #0]
   2722c:	68fb      	ldr	r3, [r7, #12]
   2722e:	715a      	strb	r2, [r3, #5]
   27230:	68bb      	ldr	r3, [r7, #8]
   27232:	3302      	adds	r3, #2
   27234:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_INT8(pMsg->readTxPwrLvlCmdCmpl.pwrLvl, p);
   27236:	68bb      	ldr	r3, [r7, #8]
   27238:	1c5a      	adds	r2, r3, #1
   2723a:	60ba      	str	r2, [r7, #8]
   2723c:	781b      	ldrb	r3, [r3, #0]
   2723e:	b25a      	sxtb	r2, r3
   27240:	68fb      	ldr	r3, [r7, #12]
   27242:	719a      	strb	r2, [r3, #6]

  pMsg->hdr.param = pMsg->readTxPwrLvlCmdCmpl.handle;
   27244:	68fb      	ldr	r3, [r7, #12]
   27246:	795b      	ldrb	r3, [r3, #5]
   27248:	b29a      	uxth	r2, r3
   2724a:	68fb      	ldr	r3, [r7, #12]
   2724c:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->readTxPwrLvlCmdCmpl.status;
   2724e:	68fb      	ldr	r3, [r7, #12]
   27250:	791a      	ldrb	r2, [r3, #4]
   27252:	68fb      	ldr	r3, [r7, #12]
   27254:	70da      	strb	r2, [r3, #3]
}
   27256:	bf00      	nop
   27258:	3714      	adds	r7, #20
   2725a:	46bd      	mov	sp, r7
   2725c:	f85d 7b04 	ldr.w	r7, [sp], #4
   27260:	4770      	bx	lr

00027262 <hciEvtParseReadRemoteVerInfoCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadRemoteVerInfoCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27262:	b480      	push	{r7}
   27264:	b085      	sub	sp, #20
   27266:	af00      	add	r7, sp, #0
   27268:	60f8      	str	r0, [r7, #12]
   2726a:	60b9      	str	r1, [r7, #8]
   2726c:	4613      	mov	r3, r2
   2726e:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->readRemoteVerInfoCmpl.status, p);
   27270:	68bb      	ldr	r3, [r7, #8]
   27272:	1c5a      	adds	r2, r3, #1
   27274:	60ba      	str	r2, [r7, #8]
   27276:	781a      	ldrb	r2, [r3, #0]
   27278:	68fb      	ldr	r3, [r7, #12]
   2727a:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->readRemoteVerInfoCmpl.handle, p);
   2727c:	68bb      	ldr	r3, [r7, #8]
   2727e:	781b      	ldrb	r3, [r3, #0]
   27280:	b29a      	uxth	r2, r3
   27282:	68bb      	ldr	r3, [r7, #8]
   27284:	3301      	adds	r3, #1
   27286:	781b      	ldrb	r3, [r3, #0]
   27288:	b29b      	uxth	r3, r3
   2728a:	021b      	lsls	r3, r3, #8
   2728c:	b29b      	uxth	r3, r3
   2728e:	4413      	add	r3, r2
   27290:	b29a      	uxth	r2, r3
   27292:	68fb      	ldr	r3, [r7, #12]
   27294:	80da      	strh	r2, [r3, #6]
   27296:	68bb      	ldr	r3, [r7, #8]
   27298:	3302      	adds	r3, #2
   2729a:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->readRemoteVerInfoCmpl.version, p);
   2729c:	68bb      	ldr	r3, [r7, #8]
   2729e:	1c5a      	adds	r2, r3, #1
   272a0:	60ba      	str	r2, [r7, #8]
   272a2:	781a      	ldrb	r2, [r3, #0]
   272a4:	68fb      	ldr	r3, [r7, #12]
   272a6:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT16(pMsg->readRemoteVerInfoCmpl.mfrName, p);
   272a8:	68bb      	ldr	r3, [r7, #8]
   272aa:	781b      	ldrb	r3, [r3, #0]
   272ac:	b29a      	uxth	r2, r3
   272ae:	68bb      	ldr	r3, [r7, #8]
   272b0:	3301      	adds	r3, #1
   272b2:	781b      	ldrb	r3, [r3, #0]
   272b4:	b29b      	uxth	r3, r3
   272b6:	021b      	lsls	r3, r3, #8
   272b8:	b29b      	uxth	r3, r3
   272ba:	4413      	add	r3, r2
   272bc:	b29a      	uxth	r2, r3
   272be:	68fb      	ldr	r3, [r7, #12]
   272c0:	815a      	strh	r2, [r3, #10]
   272c2:	68bb      	ldr	r3, [r7, #8]
   272c4:	3302      	adds	r3, #2
   272c6:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->readRemoteVerInfoCmpl.subversion, p);
   272c8:	68bb      	ldr	r3, [r7, #8]
   272ca:	781b      	ldrb	r3, [r3, #0]
   272cc:	b29a      	uxth	r2, r3
   272ce:	68bb      	ldr	r3, [r7, #8]
   272d0:	3301      	adds	r3, #1
   272d2:	781b      	ldrb	r3, [r3, #0]
   272d4:	b29b      	uxth	r3, r3
   272d6:	021b      	lsls	r3, r3, #8
   272d8:	b29b      	uxth	r3, r3
   272da:	4413      	add	r3, r2
   272dc:	b29a      	uxth	r2, r3
   272de:	68fb      	ldr	r3, [r7, #12]
   272e0:	819a      	strh	r2, [r3, #12]
   272e2:	68bb      	ldr	r3, [r7, #8]
   272e4:	3302      	adds	r3, #2
   272e6:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->readRemoteVerInfoCmpl.handle;
   272e8:	68fb      	ldr	r3, [r7, #12]
   272ea:	88da      	ldrh	r2, [r3, #6]
   272ec:	68fb      	ldr	r3, [r7, #12]
   272ee:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->readRemoteVerInfoCmpl.status;
   272f0:	68fb      	ldr	r3, [r7, #12]
   272f2:	791a      	ldrb	r2, [r3, #4]
   272f4:	68fb      	ldr	r3, [r7, #12]
   272f6:	70da      	strb	r2, [r3, #3]
}
   272f8:	bf00      	nop
   272fa:	3714      	adds	r7, #20
   272fc:	46bd      	mov	sp, r7
   272fe:	f85d 7b04 	ldr.w	r7, [sp], #4
   27302:	4770      	bx	lr

00027304 <hciEvtParseReadLeRemoteFeatCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadLeRemoteFeatCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27304:	b580      	push	{r7, lr}
   27306:	b084      	sub	sp, #16
   27308:	af00      	add	r7, sp, #0
   2730a:	60f8      	str	r0, [r7, #12]
   2730c:	60b9      	str	r1, [r7, #8]
   2730e:	4613      	mov	r3, r2
   27310:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadRemoteFeatCmpl.status, p);
   27312:	68bb      	ldr	r3, [r7, #8]
   27314:	1c5a      	adds	r2, r3, #1
   27316:	60ba      	str	r2, [r7, #8]
   27318:	781a      	ldrb	r2, [r3, #0]
   2731a:	68fb      	ldr	r3, [r7, #12]
   2731c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leReadRemoteFeatCmpl.handle, p);
   2731e:	68bb      	ldr	r3, [r7, #8]
   27320:	781b      	ldrb	r3, [r3, #0]
   27322:	b29a      	uxth	r2, r3
   27324:	68bb      	ldr	r3, [r7, #8]
   27326:	3301      	adds	r3, #1
   27328:	781b      	ldrb	r3, [r3, #0]
   2732a:	b29b      	uxth	r3, r3
   2732c:	021b      	lsls	r3, r3, #8
   2732e:	b29b      	uxth	r3, r3
   27330:	4413      	add	r3, r2
   27332:	b29a      	uxth	r2, r3
   27334:	68fb      	ldr	r3, [r7, #12]
   27336:	80da      	strh	r2, [r3, #6]
   27338:	68bb      	ldr	r3, [r7, #8]
   2733a:	3302      	adds	r3, #2
   2733c:	60bb      	str	r3, [r7, #8]
  memcpy(&pMsg->leReadRemoteFeatCmpl.features, p, HCI_FEAT_LEN);
   2733e:	68fb      	ldr	r3, [r7, #12]
   27340:	3308      	adds	r3, #8
   27342:	2208      	movs	r2, #8
   27344:	68b9      	ldr	r1, [r7, #8]
   27346:	4618      	mov	r0, r3
   27348:	f7f0 ff84 	bl	18254 <memcpy>

  pMsg->hdr.param = pMsg->leReadRemoteFeatCmpl.handle;
   2734c:	68fb      	ldr	r3, [r7, #12]
   2734e:	88da      	ldrh	r2, [r3, #6]
   27350:	68fb      	ldr	r3, [r7, #12]
   27352:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leReadRemoteFeatCmpl.status;
   27354:	68fb      	ldr	r3, [r7, #12]
   27356:	791a      	ldrb	r2, [r3, #4]
   27358:	68fb      	ldr	r3, [r7, #12]
   2735a:	70da      	strb	r2, [r3, #3]
}
   2735c:	bf00      	nop
   2735e:	3710      	adds	r7, #16
   27360:	46bd      	mov	sp, r7
   27362:	bd80      	pop	{r7, pc}

00027364 <hciEvtParseLeLtkReqReplCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeLtkReqReplCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27364:	b480      	push	{r7}
   27366:	b085      	sub	sp, #20
   27368:	af00      	add	r7, sp, #0
   2736a:	60f8      	str	r0, [r7, #12]
   2736c:	60b9      	str	r1, [r7, #8]
   2736e:	4613      	mov	r3, r2
   27370:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leLtkReqReplCmdCmpl.status, p);
   27372:	68bb      	ldr	r3, [r7, #8]
   27374:	1c5a      	adds	r2, r3, #1
   27376:	60ba      	str	r2, [r7, #8]
   27378:	781a      	ldrb	r2, [r3, #0]
   2737a:	68fb      	ldr	r3, [r7, #12]
   2737c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leLtkReqReplCmdCmpl.handle, p);
   2737e:	68bb      	ldr	r3, [r7, #8]
   27380:	781b      	ldrb	r3, [r3, #0]
   27382:	b29a      	uxth	r2, r3
   27384:	68bb      	ldr	r3, [r7, #8]
   27386:	3301      	adds	r3, #1
   27388:	781b      	ldrb	r3, [r3, #0]
   2738a:	b29b      	uxth	r3, r3
   2738c:	021b      	lsls	r3, r3, #8
   2738e:	b29b      	uxth	r3, r3
   27390:	4413      	add	r3, r2
   27392:	b29a      	uxth	r2, r3
   27394:	68fb      	ldr	r3, [r7, #12]
   27396:	80da      	strh	r2, [r3, #6]
   27398:	68bb      	ldr	r3, [r7, #8]
   2739a:	3302      	adds	r3, #2
   2739c:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leLtkReqReplCmdCmpl.handle;
   2739e:	68fb      	ldr	r3, [r7, #12]
   273a0:	88da      	ldrh	r2, [r3, #6]
   273a2:	68fb      	ldr	r3, [r7, #12]
   273a4:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leLtkReqReplCmdCmpl.status;
   273a6:	68fb      	ldr	r3, [r7, #12]
   273a8:	791a      	ldrb	r2, [r3, #4]
   273aa:	68fb      	ldr	r3, [r7, #12]
   273ac:	70da      	strb	r2, [r3, #3]
}
   273ae:	bf00      	nop
   273b0:	3714      	adds	r7, #20
   273b2:	46bd      	mov	sp, r7
   273b4:	f85d 7b04 	ldr.w	r7, [sp], #4
   273b8:	4770      	bx	lr

000273ba <hciEvtParseLeLtkReqNegReplCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeLtkReqNegReplCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   273ba:	b480      	push	{r7}
   273bc:	b085      	sub	sp, #20
   273be:	af00      	add	r7, sp, #0
   273c0:	60f8      	str	r0, [r7, #12]
   273c2:	60b9      	str	r1, [r7, #8]
   273c4:	4613      	mov	r3, r2
   273c6:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leLtkReqNegReplCmdCmpl.status, p);
   273c8:	68bb      	ldr	r3, [r7, #8]
   273ca:	1c5a      	adds	r2, r3, #1
   273cc:	60ba      	str	r2, [r7, #8]
   273ce:	781a      	ldrb	r2, [r3, #0]
   273d0:	68fb      	ldr	r3, [r7, #12]
   273d2:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leLtkReqNegReplCmdCmpl.handle, p);
   273d4:	68bb      	ldr	r3, [r7, #8]
   273d6:	781b      	ldrb	r3, [r3, #0]
   273d8:	b29a      	uxth	r2, r3
   273da:	68bb      	ldr	r3, [r7, #8]
   273dc:	3301      	adds	r3, #1
   273de:	781b      	ldrb	r3, [r3, #0]
   273e0:	b29b      	uxth	r3, r3
   273e2:	021b      	lsls	r3, r3, #8
   273e4:	b29b      	uxth	r3, r3
   273e6:	4413      	add	r3, r2
   273e8:	b29a      	uxth	r2, r3
   273ea:	68fb      	ldr	r3, [r7, #12]
   273ec:	80da      	strh	r2, [r3, #6]
   273ee:	68bb      	ldr	r3, [r7, #8]
   273f0:	3302      	adds	r3, #2
   273f2:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leLtkReqNegReplCmdCmpl.handle;
   273f4:	68fb      	ldr	r3, [r7, #12]
   273f6:	88da      	ldrh	r2, [r3, #6]
   273f8:	68fb      	ldr	r3, [r7, #12]
   273fa:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->leLtkReqNegReplCmdCmpl.status;
   273fc:	68fb      	ldr	r3, [r7, #12]
   273fe:	791a      	ldrb	r2, [r3, #4]
   27400:	68fb      	ldr	r3, [r7, #12]
   27402:	70da      	strb	r2, [r3, #3]
}
   27404:	bf00      	nop
   27406:	3714      	adds	r7, #20
   27408:	46bd      	mov	sp, r7
   2740a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2740e:	4770      	bx	lr

00027410 <hciEvtParseEncKeyRefreshCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseEncKeyRefreshCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27410:	b480      	push	{r7}
   27412:	b085      	sub	sp, #20
   27414:	af00      	add	r7, sp, #0
   27416:	60f8      	str	r0, [r7, #12]
   27418:	60b9      	str	r1, [r7, #8]
   2741a:	4613      	mov	r3, r2
   2741c:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->encKeyRefreshCmpl.status, p);
   2741e:	68bb      	ldr	r3, [r7, #8]
   27420:	1c5a      	adds	r2, r3, #1
   27422:	60ba      	str	r2, [r7, #8]
   27424:	781a      	ldrb	r2, [r3, #0]
   27426:	68fb      	ldr	r3, [r7, #12]
   27428:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->encKeyRefreshCmpl.handle, p);
   2742a:	68bb      	ldr	r3, [r7, #8]
   2742c:	781b      	ldrb	r3, [r3, #0]
   2742e:	b29a      	uxth	r2, r3
   27430:	68bb      	ldr	r3, [r7, #8]
   27432:	3301      	adds	r3, #1
   27434:	781b      	ldrb	r3, [r3, #0]
   27436:	b29b      	uxth	r3, r3
   27438:	021b      	lsls	r3, r3, #8
   2743a:	b29b      	uxth	r3, r3
   2743c:	4413      	add	r3, r2
   2743e:	b29a      	uxth	r2, r3
   27440:	68fb      	ldr	r3, [r7, #12]
   27442:	80da      	strh	r2, [r3, #6]
   27444:	68bb      	ldr	r3, [r7, #8]
   27446:	3302      	adds	r3, #2
   27448:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->encKeyRefreshCmpl.handle;
   2744a:	68fb      	ldr	r3, [r7, #12]
   2744c:	88da      	ldrh	r2, [r3, #6]
   2744e:	68fb      	ldr	r3, [r7, #12]
   27450:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->encKeyRefreshCmpl.status;
   27452:	68fb      	ldr	r3, [r7, #12]
   27454:	791a      	ldrb	r2, [r3, #4]
   27456:	68fb      	ldr	r3, [r7, #12]
   27458:	70da      	strb	r2, [r3, #3]
}
   2745a:	bf00      	nop
   2745c:	3714      	adds	r7, #20
   2745e:	46bd      	mov	sp, r7
   27460:	f85d 7b04 	ldr.w	r7, [sp], #4
   27464:	4770      	bx	lr

00027466 <hciEvtParseEncChange>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseEncChange(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27466:	b480      	push	{r7}
   27468:	b085      	sub	sp, #20
   2746a:	af00      	add	r7, sp, #0
   2746c:	60f8      	str	r0, [r7, #12]
   2746e:	60b9      	str	r1, [r7, #8]
   27470:	4613      	mov	r3, r2
   27472:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->encChange.status, p);
   27474:	68bb      	ldr	r3, [r7, #8]
   27476:	1c5a      	adds	r2, r3, #1
   27478:	60ba      	str	r2, [r7, #8]
   2747a:	781a      	ldrb	r2, [r3, #0]
   2747c:	68fb      	ldr	r3, [r7, #12]
   2747e:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->encChange.handle, p);
   27480:	68bb      	ldr	r3, [r7, #8]
   27482:	781b      	ldrb	r3, [r3, #0]
   27484:	b29a      	uxth	r2, r3
   27486:	68bb      	ldr	r3, [r7, #8]
   27488:	3301      	adds	r3, #1
   2748a:	781b      	ldrb	r3, [r3, #0]
   2748c:	b29b      	uxth	r3, r3
   2748e:	021b      	lsls	r3, r3, #8
   27490:	b29b      	uxth	r3, r3
   27492:	4413      	add	r3, r2
   27494:	b29a      	uxth	r2, r3
   27496:	68fb      	ldr	r3, [r7, #12]
   27498:	80da      	strh	r2, [r3, #6]
   2749a:	68bb      	ldr	r3, [r7, #8]
   2749c:	3302      	adds	r3, #2
   2749e:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->encChange.enabled, p);
   274a0:	68bb      	ldr	r3, [r7, #8]
   274a2:	1c5a      	adds	r2, r3, #1
   274a4:	60ba      	str	r2, [r7, #8]
   274a6:	781a      	ldrb	r2, [r3, #0]
   274a8:	68fb      	ldr	r3, [r7, #12]
   274aa:	721a      	strb	r2, [r3, #8]

  pMsg->hdr.param = pMsg->encChange.handle;
   274ac:	68fb      	ldr	r3, [r7, #12]
   274ae:	88da      	ldrh	r2, [r3, #6]
   274b0:	68fb      	ldr	r3, [r7, #12]
   274b2:	801a      	strh	r2, [r3, #0]
  pMsg->hdr.status = pMsg->encChange.status;
   274b4:	68fb      	ldr	r3, [r7, #12]
   274b6:	791a      	ldrb	r2, [r3, #4]
   274b8:	68fb      	ldr	r3, [r7, #12]
   274ba:	70da      	strb	r2, [r3, #3]
}
   274bc:	bf00      	nop
   274be:	3714      	adds	r7, #20
   274c0:	46bd      	mov	sp, r7
   274c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   274c6:	4770      	bx	lr

000274c8 <hciEvtParseLeLtkReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeLtkReq(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   274c8:	b580      	push	{r7, lr}
   274ca:	b084      	sub	sp, #16
   274cc:	af00      	add	r7, sp, #0
   274ce:	60f8      	str	r0, [r7, #12]
   274d0:	60b9      	str	r1, [r7, #8]
   274d2:	4613      	mov	r3, r2
   274d4:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->leLtkReq.handle, p);
   274d6:	68bb      	ldr	r3, [r7, #8]
   274d8:	781b      	ldrb	r3, [r3, #0]
   274da:	b29a      	uxth	r2, r3
   274dc:	68bb      	ldr	r3, [r7, #8]
   274de:	3301      	adds	r3, #1
   274e0:	781b      	ldrb	r3, [r3, #0]
   274e2:	b29b      	uxth	r3, r3
   274e4:	021b      	lsls	r3, r3, #8
   274e6:	b29b      	uxth	r3, r3
   274e8:	4413      	add	r3, r2
   274ea:	b29a      	uxth	r2, r3
   274ec:	68fb      	ldr	r3, [r7, #12]
   274ee:	809a      	strh	r2, [r3, #4]
   274f0:	68bb      	ldr	r3, [r7, #8]
   274f2:	3302      	adds	r3, #2
   274f4:	60bb      	str	r3, [r7, #8]

  memcpy(pMsg->leLtkReq.randNum, p, HCI_RAND_LEN);
   274f6:	68fb      	ldr	r3, [r7, #12]
   274f8:	3306      	adds	r3, #6
   274fa:	2208      	movs	r2, #8
   274fc:	68b9      	ldr	r1, [r7, #8]
   274fe:	4618      	mov	r0, r3
   27500:	f7f0 fea8 	bl	18254 <memcpy>
  p += HCI_RAND_LEN;
   27504:	68bb      	ldr	r3, [r7, #8]
   27506:	3308      	adds	r3, #8
   27508:	60bb      	str	r3, [r7, #8]

  BSTREAM_TO_UINT16(pMsg->leLtkReq.encDiversifier, p);
   2750a:	68bb      	ldr	r3, [r7, #8]
   2750c:	781b      	ldrb	r3, [r3, #0]
   2750e:	b29a      	uxth	r2, r3
   27510:	68bb      	ldr	r3, [r7, #8]
   27512:	3301      	adds	r3, #1
   27514:	781b      	ldrb	r3, [r3, #0]
   27516:	b29b      	uxth	r3, r3
   27518:	021b      	lsls	r3, r3, #8
   2751a:	b29b      	uxth	r3, r3
   2751c:	4413      	add	r3, r2
   2751e:	b29a      	uxth	r2, r3
   27520:	68fb      	ldr	r3, [r7, #12]
   27522:	81da      	strh	r2, [r3, #14]
   27524:	68bb      	ldr	r3, [r7, #8]
   27526:	3302      	adds	r3, #2
   27528:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leLtkReq.handle;
   2752a:	68fb      	ldr	r3, [r7, #12]
   2752c:	889a      	ldrh	r2, [r3, #4]
   2752e:	68fb      	ldr	r3, [r7, #12]
   27530:	801a      	strh	r2, [r3, #0]
}
   27532:	bf00      	nop
   27534:	3710      	adds	r7, #16
   27536:	46bd      	mov	sp, r7
   27538:	bd80      	pop	{r7, pc}

0002753a <hciEvtParseVendorSpecCmdStatus>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseVendorSpecCmdStatus(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2753a:	b480      	push	{r7}
   2753c:	b085      	sub	sp, #20
   2753e:	af00      	add	r7, sp, #0
   27540:	60f8      	str	r0, [r7, #12]
   27542:	60b9      	str	r1, [r7, #8]
   27544:	4613      	mov	r3, r2
   27546:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->vendorSpecCmdStatus.opcode, p);
   27548:	68bb      	ldr	r3, [r7, #8]
   2754a:	781b      	ldrb	r3, [r3, #0]
   2754c:	b29a      	uxth	r2, r3
   2754e:	68bb      	ldr	r3, [r7, #8]
   27550:	3301      	adds	r3, #1
   27552:	781b      	ldrb	r3, [r3, #0]
   27554:	b29b      	uxth	r3, r3
   27556:	021b      	lsls	r3, r3, #8
   27558:	b29b      	uxth	r3, r3
   2755a:	4413      	add	r3, r2
   2755c:	b29a      	uxth	r2, r3
   2755e:	68fb      	ldr	r3, [r7, #12]
   27560:	809a      	strh	r2, [r3, #4]
   27562:	68bb      	ldr	r3, [r7, #8]
   27564:	3302      	adds	r3, #2
   27566:	60bb      	str	r3, [r7, #8]
}
   27568:	bf00      	nop
   2756a:	3714      	adds	r7, #20
   2756c:	46bd      	mov	sp, r7
   2756e:	f85d 7b04 	ldr.w	r7, [sp], #4
   27572:	4770      	bx	lr

00027574 <hciEvtParseVendorSpecCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseVendorSpecCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27574:	b580      	push	{r7, lr}
   27576:	b084      	sub	sp, #16
   27578:	af00      	add	r7, sp, #0
   2757a:	60f8      	str	r0, [r7, #12]
   2757c:	60b9      	str	r1, [r7, #8]
   2757e:	4613      	mov	r3, r2
   27580:	71fb      	strb	r3, [r7, #7]
  if ((len > 4) && ((len - 4) <= HCI_EVT_VENDOR_SPEC_CMD_CMPL_PARAM_MAX_LEN))
   27582:	79fb      	ldrb	r3, [r7, #7]
   27584:	2b04      	cmp	r3, #4
   27586:	d923      	bls.n	275d0 <hciEvtParseVendorSpecCmdCmpl+0x5c>
   27588:	79fb      	ldrb	r3, [r7, #7]
   2758a:	2b05      	cmp	r3, #5
   2758c:	d820      	bhi.n	275d0 <hciEvtParseVendorSpecCmdCmpl+0x5c>
  {
    /* roll pointer back to opcode */
    p -= 2;
   2758e:	68bb      	ldr	r3, [r7, #8]
   27590:	3b02      	subs	r3, #2
   27592:	60bb      	str	r3, [r7, #8]

    BSTREAM_TO_UINT16(pMsg->vendorSpecCmdCmpl.opcode, p);
   27594:	68bb      	ldr	r3, [r7, #8]
   27596:	781b      	ldrb	r3, [r3, #0]
   27598:	b29a      	uxth	r2, r3
   2759a:	68bb      	ldr	r3, [r7, #8]
   2759c:	3301      	adds	r3, #1
   2759e:	781b      	ldrb	r3, [r3, #0]
   275a0:	b29b      	uxth	r3, r3
   275a2:	021b      	lsls	r3, r3, #8
   275a4:	b29b      	uxth	r3, r3
   275a6:	4413      	add	r3, r2
   275a8:	b29a      	uxth	r2, r3
   275aa:	68fb      	ldr	r3, [r7, #12]
   275ac:	809a      	strh	r2, [r3, #4]
   275ae:	68bb      	ldr	r3, [r7, #8]
   275b0:	3302      	adds	r3, #2
   275b2:	60bb      	str	r3, [r7, #8]
    BSTREAM_TO_UINT8(pMsg->hdr.status, p);
   275b4:	68bb      	ldr	r3, [r7, #8]
   275b6:	1c5a      	adds	r2, r3, #1
   275b8:	60ba      	str	r2, [r7, #8]
   275ba:	781a      	ldrb	r2, [r3, #0]
   275bc:	68fb      	ldr	r3, [r7, #12]
   275be:	70da      	strb	r2, [r3, #3]
    memcpy(&pMsg->vendorSpecCmdCmpl.param[0], p, len - 4);
   275c0:	68fb      	ldr	r3, [r7, #12]
   275c2:	1d98      	adds	r0, r3, #6
   275c4:	79fb      	ldrb	r3, [r7, #7]
   275c6:	3b04      	subs	r3, #4
   275c8:	461a      	mov	r2, r3
   275ca:	68b9      	ldr	r1, [r7, #8]
   275cc:	f7f0 fe42 	bl	18254 <memcpy>
  }
}
   275d0:	bf00      	nop
   275d2:	3710      	adds	r7, #16
   275d4:	46bd      	mov	sp, r7
   275d6:	bd80      	pop	{r7, pc}

000275d8 <hciEvtParseVendorSpec>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseVendorSpec(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   275d8:	b580      	push	{r7, lr}
   275da:	b084      	sub	sp, #16
   275dc:	af00      	add	r7, sp, #0
   275de:	60f8      	str	r0, [r7, #12]
   275e0:	60b9      	str	r1, [r7, #8]
   275e2:	4613      	mov	r3, r2
   275e4:	71fb      	strb	r3, [r7, #7]
  if ((len > 0) && (len <= HCI_EVt_VENDOR_SPEC_EVT_PARAM_MAX_LEN))
   275e6:	79fb      	ldrb	r3, [r7, #7]
   275e8:	2b00      	cmp	r3, #0
   275ea:	d009      	beq.n	27600 <hciEvtParseVendorSpec+0x28>
   275ec:	79fb      	ldrb	r3, [r7, #7]
   275ee:	2b01      	cmp	r3, #1
   275f0:	d806      	bhi.n	27600 <hciEvtParseVendorSpec+0x28>
  {
    memcpy(pMsg->vendorSpec.param, p, len);
   275f2:	68fb      	ldr	r3, [r7, #12]
   275f4:	3304      	adds	r3, #4
   275f6:	79fa      	ldrb	r2, [r7, #7]
   275f8:	68b9      	ldr	r1, [r7, #8]
   275fa:	4618      	mov	r0, r3
   275fc:	f7f0 fe2a 	bl	18254 <memcpy>
  }
}
   27600:	bf00      	nop
   27602:	3710      	adds	r7, #16
   27604:	46bd      	mov	sp, r7
   27606:	bd80      	pop	{r7, pc}

00027608 <hciEvtParseHwError>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseHwError(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27608:	b480      	push	{r7}
   2760a:	b085      	sub	sp, #20
   2760c:	af00      	add	r7, sp, #0
   2760e:	60f8      	str	r0, [r7, #12]
   27610:	60b9      	str	r1, [r7, #8]
   27612:	4613      	mov	r3, r2
   27614:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->hwError.code, p);
   27616:	68bb      	ldr	r3, [r7, #8]
   27618:	1c5a      	adds	r2, r3, #1
   2761a:	60ba      	str	r2, [r7, #8]
   2761c:	781a      	ldrb	r2, [r3, #0]
   2761e:	68fb      	ldr	r3, [r7, #12]
   27620:	711a      	strb	r2, [r3, #4]
}
   27622:	bf00      	nop
   27624:	3714      	adds	r7, #20
   27626:	46bd      	mov	sp, r7
   27628:	f85d 7b04 	ldr.w	r7, [sp], #4
   2762c:	4770      	bx	lr

0002762e <hciEvtParseLeEncryptCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeEncryptCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2762e:	b580      	push	{r7, lr}
   27630:	b084      	sub	sp, #16
   27632:	af00      	add	r7, sp, #0
   27634:	60f8      	str	r0, [r7, #12]
   27636:	60b9      	str	r1, [r7, #8]
   27638:	4613      	mov	r3, r2
   2763a:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leEncryptCmdCmpl.status, p);
   2763c:	68bb      	ldr	r3, [r7, #8]
   2763e:	1c5a      	adds	r2, r3, #1
   27640:	60ba      	str	r2, [r7, #8]
   27642:	781a      	ldrb	r2, [r3, #0]
   27644:	68fb      	ldr	r3, [r7, #12]
   27646:	711a      	strb	r2, [r3, #4]
  memcpy(pMsg->leEncryptCmdCmpl.data, p, HCI_ENCRYPT_DATA_LEN);
   27648:	68fb      	ldr	r3, [r7, #12]
   2764a:	3305      	adds	r3, #5
   2764c:	2210      	movs	r2, #16
   2764e:	68b9      	ldr	r1, [r7, #8]
   27650:	4618      	mov	r0, r3
   27652:	f7f0 fdff 	bl	18254 <memcpy>

  pMsg->hdr.status = pMsg->leEncryptCmdCmpl.status;
   27656:	68fb      	ldr	r3, [r7, #12]
   27658:	791a      	ldrb	r2, [r3, #4]
   2765a:	68fb      	ldr	r3, [r7, #12]
   2765c:	70da      	strb	r2, [r3, #3]
}
   2765e:	bf00      	nop
   27660:	3710      	adds	r7, #16
   27662:	46bd      	mov	sp, r7
   27664:	bd80      	pop	{r7, pc}

00027666 <hciEvtParseLeRandCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeRandCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27666:	b580      	push	{r7, lr}
   27668:	b084      	sub	sp, #16
   2766a:	af00      	add	r7, sp, #0
   2766c:	60f8      	str	r0, [r7, #12]
   2766e:	60b9      	str	r1, [r7, #8]
   27670:	4613      	mov	r3, r2
   27672:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leRandCmdCmpl.status, p);
   27674:	68bb      	ldr	r3, [r7, #8]
   27676:	1c5a      	adds	r2, r3, #1
   27678:	60ba      	str	r2, [r7, #8]
   2767a:	781a      	ldrb	r2, [r3, #0]
   2767c:	68fb      	ldr	r3, [r7, #12]
   2767e:	711a      	strb	r2, [r3, #4]
  memcpy(pMsg->leRandCmdCmpl.randNum, p, HCI_RAND_LEN);
   27680:	68fb      	ldr	r3, [r7, #12]
   27682:	3305      	adds	r3, #5
   27684:	2208      	movs	r2, #8
   27686:	68b9      	ldr	r1, [r7, #8]
   27688:	4618      	mov	r0, r3
   2768a:	f7f0 fde3 	bl	18254 <memcpy>

  pMsg->hdr.status = pMsg->leRandCmdCmpl.status;
   2768e:	68fb      	ldr	r3, [r7, #12]
   27690:	791a      	ldrb	r2, [r3, #4]
   27692:	68fb      	ldr	r3, [r7, #12]
   27694:	70da      	strb	r2, [r3, #3]
}
   27696:	bf00      	nop
   27698:	3710      	adds	r7, #16
   2769a:	46bd      	mov	sp, r7
   2769c:	bd80      	pop	{r7, pc}

0002769e <hciEvtParseLeAddDevToResListCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeAddDevToResListCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2769e:	b480      	push	{r7}
   276a0:	b085      	sub	sp, #20
   276a2:	af00      	add	r7, sp, #0
   276a4:	60f8      	str	r0, [r7, #12]
   276a6:	60b9      	str	r1, [r7, #8]
   276a8:	4613      	mov	r3, r2
   276aa:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leAddDevToResListCmdCmpl.status, p);
   276ac:	68bb      	ldr	r3, [r7, #8]
   276ae:	1c5a      	adds	r2, r3, #1
   276b0:	60ba      	str	r2, [r7, #8]
   276b2:	781a      	ldrb	r2, [r3, #0]
   276b4:	68fb      	ldr	r3, [r7, #12]
   276b6:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leAddDevToResListCmdCmpl.status;
   276b8:	68fb      	ldr	r3, [r7, #12]
   276ba:	791a      	ldrb	r2, [r3, #4]
   276bc:	68fb      	ldr	r3, [r7, #12]
   276be:	70da      	strb	r2, [r3, #3]
}
   276c0:	bf00      	nop
   276c2:	3714      	adds	r7, #20
   276c4:	46bd      	mov	sp, r7
   276c6:	f85d 7b04 	ldr.w	r7, [sp], #4
   276ca:	4770      	bx	lr

000276cc <hciEvtParseLeRemDevFromResListCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeRemDevFromResListCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   276cc:	b480      	push	{r7}
   276ce:	b085      	sub	sp, #20
   276d0:	af00      	add	r7, sp, #0
   276d2:	60f8      	str	r0, [r7, #12]
   276d4:	60b9      	str	r1, [r7, #8]
   276d6:	4613      	mov	r3, r2
   276d8:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leRemDevFromResListCmdCmpl.status, p);
   276da:	68bb      	ldr	r3, [r7, #8]
   276dc:	1c5a      	adds	r2, r3, #1
   276de:	60ba      	str	r2, [r7, #8]
   276e0:	781a      	ldrb	r2, [r3, #0]
   276e2:	68fb      	ldr	r3, [r7, #12]
   276e4:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leRemDevFromResListCmdCmpl.status;
   276e6:	68fb      	ldr	r3, [r7, #12]
   276e8:	791a      	ldrb	r2, [r3, #4]
   276ea:	68fb      	ldr	r3, [r7, #12]
   276ec:	70da      	strb	r2, [r3, #3]
}
   276ee:	bf00      	nop
   276f0:	3714      	adds	r7, #20
   276f2:	46bd      	mov	sp, r7
   276f4:	f85d 7b04 	ldr.w	r7, [sp], #4
   276f8:	4770      	bx	lr

000276fa <hciEvtParseLeClearResListCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeClearResListCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   276fa:	b480      	push	{r7}
   276fc:	b085      	sub	sp, #20
   276fe:	af00      	add	r7, sp, #0
   27700:	60f8      	str	r0, [r7, #12]
   27702:	60b9      	str	r1, [r7, #8]
   27704:	4613      	mov	r3, r2
   27706:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leClearResListCmdCmpl.status, p);
   27708:	68bb      	ldr	r3, [r7, #8]
   2770a:	1c5a      	adds	r2, r3, #1
   2770c:	60ba      	str	r2, [r7, #8]
   2770e:	781a      	ldrb	r2, [r3, #0]
   27710:	68fb      	ldr	r3, [r7, #12]
   27712:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leClearResListCmdCmpl.status;
   27714:	68fb      	ldr	r3, [r7, #12]
   27716:	791a      	ldrb	r2, [r3, #4]
   27718:	68fb      	ldr	r3, [r7, #12]
   2771a:	70da      	strb	r2, [r3, #3]
}
   2771c:	bf00      	nop
   2771e:	3714      	adds	r7, #20
   27720:	46bd      	mov	sp, r7
   27722:	f85d 7b04 	ldr.w	r7, [sp], #4
   27726:	4770      	bx	lr

00027728 <hciEvtParseLeReadPeerResAddrCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeReadPeerResAddrCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27728:	b580      	push	{r7, lr}
   2772a:	b084      	sub	sp, #16
   2772c:	af00      	add	r7, sp, #0
   2772e:	60f8      	str	r0, [r7, #12]
   27730:	60b9      	str	r1, [r7, #8]
   27732:	4613      	mov	r3, r2
   27734:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadPeerResAddrCmdCmpl.status, p);
   27736:	68bb      	ldr	r3, [r7, #8]
   27738:	1c5a      	adds	r2, r3, #1
   2773a:	60ba      	str	r2, [r7, #8]
   2773c:	781a      	ldrb	r2, [r3, #0]
   2773e:	68fb      	ldr	r3, [r7, #12]
   27740:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_BDA(pMsg->leReadPeerResAddrCmdCmpl.peerRpa, p);
   27742:	68fb      	ldr	r3, [r7, #12]
   27744:	3305      	adds	r3, #5
   27746:	68b9      	ldr	r1, [r7, #8]
   27748:	4618      	mov	r0, r3
   2774a:	f7fa fa1c 	bl	21b86 <BdaCpy>
   2774e:	68bb      	ldr	r3, [r7, #8]
   27750:	3306      	adds	r3, #6
   27752:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leReadPeerResAddrCmdCmpl.status;
   27754:	68fb      	ldr	r3, [r7, #12]
   27756:	791a      	ldrb	r2, [r3, #4]
   27758:	68fb      	ldr	r3, [r7, #12]
   2775a:	70da      	strb	r2, [r3, #3]
}
   2775c:	bf00      	nop
   2775e:	3710      	adds	r7, #16
   27760:	46bd      	mov	sp, r7
   27762:	bd80      	pop	{r7, pc}

00027764 <hciEvtParseLeReadLocalResAddrCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeReadLocalResAddrCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27764:	b580      	push	{r7, lr}
   27766:	b084      	sub	sp, #16
   27768:	af00      	add	r7, sp, #0
   2776a:	60f8      	str	r0, [r7, #12]
   2776c:	60b9      	str	r1, [r7, #8]
   2776e:	4613      	mov	r3, r2
   27770:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadLocalResAddrCmdCmpl.status, p);
   27772:	68bb      	ldr	r3, [r7, #8]
   27774:	1c5a      	adds	r2, r3, #1
   27776:	60ba      	str	r2, [r7, #8]
   27778:	781a      	ldrb	r2, [r3, #0]
   2777a:	68fb      	ldr	r3, [r7, #12]
   2777c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_BDA(pMsg->leReadLocalResAddrCmdCmpl.localRpa, p);
   2777e:	68fb      	ldr	r3, [r7, #12]
   27780:	3305      	adds	r3, #5
   27782:	68b9      	ldr	r1, [r7, #8]
   27784:	4618      	mov	r0, r3
   27786:	f7fa f9fe 	bl	21b86 <BdaCpy>
   2778a:	68bb      	ldr	r3, [r7, #8]
   2778c:	3306      	adds	r3, #6
   2778e:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leReadLocalResAddrCmdCmpl.status;
   27790:	68fb      	ldr	r3, [r7, #12]
   27792:	791a      	ldrb	r2, [r3, #4]
   27794:	68fb      	ldr	r3, [r7, #12]
   27796:	70da      	strb	r2, [r3, #3]
}
   27798:	bf00      	nop
   2779a:	3710      	adds	r7, #16
   2779c:	46bd      	mov	sp, r7
   2779e:	bd80      	pop	{r7, pc}

000277a0 <hciEvtParseLeSetAddrResEnableCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeSetAddrResEnableCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   277a0:	b480      	push	{r7}
   277a2:	b085      	sub	sp, #20
   277a4:	af00      	add	r7, sp, #0
   277a6:	60f8      	str	r0, [r7, #12]
   277a8:	60b9      	str	r1, [r7, #8]
   277aa:	4613      	mov	r3, r2
   277ac:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leSetAddrResEnableCmdCmpl.status, p);
   277ae:	68bb      	ldr	r3, [r7, #8]
   277b0:	1c5a      	adds	r2, r3, #1
   277b2:	60ba      	str	r2, [r7, #8]
   277b4:	781a      	ldrb	r2, [r3, #0]
   277b6:	68fb      	ldr	r3, [r7, #12]
   277b8:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leSetAddrResEnableCmdCmpl.status;
   277ba:	68fb      	ldr	r3, [r7, #12]
   277bc:	791a      	ldrb	r2, [r3, #4]
   277be:	68fb      	ldr	r3, [r7, #12]
   277c0:	70da      	strb	r2, [r3, #3]
}
   277c2:	bf00      	nop
   277c4:	3714      	adds	r7, #20
   277c6:	46bd      	mov	sp, r7
   277c8:	f85d 7b04 	ldr.w	r7, [sp], #4
   277cc:	4770      	bx	lr

000277ce <hciEvtParseRemConnParamRepCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseRemConnParamRepCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   277ce:	b480      	push	{r7}
   277d0:	b085      	sub	sp, #20
   277d2:	af00      	add	r7, sp, #0
   277d4:	60f8      	str	r0, [r7, #12]
   277d6:	60b9      	str	r1, [r7, #8]
   277d8:	4613      	mov	r3, r2
   277da:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leRemConnParamRepCmdCmpl.status, p);
   277dc:	68bb      	ldr	r3, [r7, #8]
   277de:	1c5a      	adds	r2, r3, #1
   277e0:	60ba      	str	r2, [r7, #8]
   277e2:	781a      	ldrb	r2, [r3, #0]
   277e4:	68fb      	ldr	r3, [r7, #12]
   277e6:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamRepCmdCmpl.handle, p);
   277e8:	68bb      	ldr	r3, [r7, #8]
   277ea:	781b      	ldrb	r3, [r3, #0]
   277ec:	b29a      	uxth	r2, r3
   277ee:	68bb      	ldr	r3, [r7, #8]
   277f0:	3301      	adds	r3, #1
   277f2:	781b      	ldrb	r3, [r3, #0]
   277f4:	b29b      	uxth	r3, r3
   277f6:	021b      	lsls	r3, r3, #8
   277f8:	b29b      	uxth	r3, r3
   277fa:	4413      	add	r3, r2
   277fc:	b29a      	uxth	r2, r3
   277fe:	68fb      	ldr	r3, [r7, #12]
   27800:	80da      	strh	r2, [r3, #6]
   27802:	68bb      	ldr	r3, [r7, #8]
   27804:	3302      	adds	r3, #2
   27806:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leRemConnParamRepCmdCmpl.status;
   27808:	68fb      	ldr	r3, [r7, #12]
   2780a:	791a      	ldrb	r2, [r3, #4]
   2780c:	68fb      	ldr	r3, [r7, #12]
   2780e:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->leRemConnParamRepCmdCmpl.handle;
   27810:	68fb      	ldr	r3, [r7, #12]
   27812:	88da      	ldrh	r2, [r3, #6]
   27814:	68fb      	ldr	r3, [r7, #12]
   27816:	801a      	strh	r2, [r3, #0]
}
   27818:	bf00      	nop
   2781a:	3714      	adds	r7, #20
   2781c:	46bd      	mov	sp, r7
   2781e:	f85d 7b04 	ldr.w	r7, [sp], #4
   27822:	4770      	bx	lr

00027824 <hciEvtParseRemConnParamNegRepCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseRemConnParamNegRepCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27824:	b480      	push	{r7}
   27826:	b085      	sub	sp, #20
   27828:	af00      	add	r7, sp, #0
   2782a:	60f8      	str	r0, [r7, #12]
   2782c:	60b9      	str	r1, [r7, #8]
   2782e:	4613      	mov	r3, r2
   27830:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leRemConnParamNegRepCmdCmpl.status, p);
   27832:	68bb      	ldr	r3, [r7, #8]
   27834:	1c5a      	adds	r2, r3, #1
   27836:	60ba      	str	r2, [r7, #8]
   27838:	781a      	ldrb	r2, [r3, #0]
   2783a:	68fb      	ldr	r3, [r7, #12]
   2783c:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamNegRepCmdCmpl.handle, p);
   2783e:	68bb      	ldr	r3, [r7, #8]
   27840:	781b      	ldrb	r3, [r3, #0]
   27842:	b29a      	uxth	r2, r3
   27844:	68bb      	ldr	r3, [r7, #8]
   27846:	3301      	adds	r3, #1
   27848:	781b      	ldrb	r3, [r3, #0]
   2784a:	b29b      	uxth	r3, r3
   2784c:	021b      	lsls	r3, r3, #8
   2784e:	b29b      	uxth	r3, r3
   27850:	4413      	add	r3, r2
   27852:	b29a      	uxth	r2, r3
   27854:	68fb      	ldr	r3, [r7, #12]
   27856:	80da      	strh	r2, [r3, #6]
   27858:	68bb      	ldr	r3, [r7, #8]
   2785a:	3302      	adds	r3, #2
   2785c:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leRemConnParamNegRepCmdCmpl.status;
   2785e:	68fb      	ldr	r3, [r7, #12]
   27860:	791a      	ldrb	r2, [r3, #4]
   27862:	68fb      	ldr	r3, [r7, #12]
   27864:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->leRemConnParamNegRepCmdCmpl.handle;
   27866:	68fb      	ldr	r3, [r7, #12]
   27868:	88da      	ldrh	r2, [r3, #6]
   2786a:	68fb      	ldr	r3, [r7, #12]
   2786c:	801a      	strh	r2, [r3, #0]
}
   2786e:	bf00      	nop
   27870:	3714      	adds	r7, #20
   27872:	46bd      	mov	sp, r7
   27874:	f85d 7b04 	ldr.w	r7, [sp], #4
   27878:	4770      	bx	lr

0002787a <hciEvtParseReadDefDataLenCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadDefDataLenCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2787a:	b480      	push	{r7}
   2787c:	b085      	sub	sp, #20
   2787e:	af00      	add	r7, sp, #0
   27880:	60f8      	str	r0, [r7, #12]
   27882:	60b9      	str	r1, [r7, #8]
   27884:	4613      	mov	r3, r2
   27886:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadDefDataLenCmdCmpl.status, p);
   27888:	68bb      	ldr	r3, [r7, #8]
   2788a:	1c5a      	adds	r2, r3, #1
   2788c:	60ba      	str	r2, [r7, #8]
   2788e:	781a      	ldrb	r2, [r3, #0]
   27890:	68fb      	ldr	r3, [r7, #12]
   27892:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leReadDefDataLenCmdCmpl.suggestedMaxTxOctets, p);
   27894:	68bb      	ldr	r3, [r7, #8]
   27896:	781b      	ldrb	r3, [r3, #0]
   27898:	b29a      	uxth	r2, r3
   2789a:	68bb      	ldr	r3, [r7, #8]
   2789c:	3301      	adds	r3, #1
   2789e:	781b      	ldrb	r3, [r3, #0]
   278a0:	b29b      	uxth	r3, r3
   278a2:	021b      	lsls	r3, r3, #8
   278a4:	b29b      	uxth	r3, r3
   278a6:	4413      	add	r3, r2
   278a8:	b29a      	uxth	r2, r3
   278aa:	68fb      	ldr	r3, [r7, #12]
   278ac:	80da      	strh	r2, [r3, #6]
   278ae:	68bb      	ldr	r3, [r7, #8]
   278b0:	3302      	adds	r3, #2
   278b2:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leReadDefDataLenCmdCmpl.suggestedMaxTxTime, p);
   278b4:	68bb      	ldr	r3, [r7, #8]
   278b6:	781b      	ldrb	r3, [r3, #0]
   278b8:	b29a      	uxth	r2, r3
   278ba:	68bb      	ldr	r3, [r7, #8]
   278bc:	3301      	adds	r3, #1
   278be:	781b      	ldrb	r3, [r3, #0]
   278c0:	b29b      	uxth	r3, r3
   278c2:	021b      	lsls	r3, r3, #8
   278c4:	b29b      	uxth	r3, r3
   278c6:	4413      	add	r3, r2
   278c8:	b29a      	uxth	r2, r3
   278ca:	68fb      	ldr	r3, [r7, #12]
   278cc:	811a      	strh	r2, [r3, #8]
   278ce:	68bb      	ldr	r3, [r7, #8]
   278d0:	3302      	adds	r3, #2
   278d2:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leReadDefDataLenCmdCmpl.status;
   278d4:	68fb      	ldr	r3, [r7, #12]
   278d6:	791a      	ldrb	r2, [r3, #4]
   278d8:	68fb      	ldr	r3, [r7, #12]
   278da:	70da      	strb	r2, [r3, #3]
}
   278dc:	bf00      	nop
   278de:	3714      	adds	r7, #20
   278e0:	46bd      	mov	sp, r7
   278e2:	f85d 7b04 	ldr.w	r7, [sp], #4
   278e6:	4770      	bx	lr

000278e8 <hciEvtParseWriteDefDataLenCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseWriteDefDataLenCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   278e8:	b480      	push	{r7}
   278ea:	b085      	sub	sp, #20
   278ec:	af00      	add	r7, sp, #0
   278ee:	60f8      	str	r0, [r7, #12]
   278f0:	60b9      	str	r1, [r7, #8]
   278f2:	4613      	mov	r3, r2
   278f4:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leWriteDefDataLenCmdCmpl.status, p);
   278f6:	68bb      	ldr	r3, [r7, #8]
   278f8:	1c5a      	adds	r2, r3, #1
   278fa:	60ba      	str	r2, [r7, #8]
   278fc:	781a      	ldrb	r2, [r3, #0]
   278fe:	68fb      	ldr	r3, [r7, #12]
   27900:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leWriteDefDataLenCmdCmpl.status;
   27902:	68fb      	ldr	r3, [r7, #12]
   27904:	791a      	ldrb	r2, [r3, #4]
   27906:	68fb      	ldr	r3, [r7, #12]
   27908:	70da      	strb	r2, [r3, #3]
}
   2790a:	bf00      	nop
   2790c:	3714      	adds	r7, #20
   2790e:	46bd      	mov	sp, r7
   27910:	f85d 7b04 	ldr.w	r7, [sp], #4
   27914:	4770      	bx	lr

00027916 <hciEvtParseSetDataLenCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseSetDataLenCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27916:	b480      	push	{r7}
   27918:	b085      	sub	sp, #20
   2791a:	af00      	add	r7, sp, #0
   2791c:	60f8      	str	r0, [r7, #12]
   2791e:	60b9      	str	r1, [r7, #8]
   27920:	4613      	mov	r3, r2
   27922:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leSetDataLenCmdCmpl.status, p);
   27924:	68bb      	ldr	r3, [r7, #8]
   27926:	1c5a      	adds	r2, r3, #1
   27928:	60ba      	str	r2, [r7, #8]
   2792a:	781a      	ldrb	r2, [r3, #0]
   2792c:	68fb      	ldr	r3, [r7, #12]
   2792e:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leSetDataLenCmdCmpl.handle, p);
   27930:	68bb      	ldr	r3, [r7, #8]
   27932:	781b      	ldrb	r3, [r3, #0]
   27934:	b29a      	uxth	r2, r3
   27936:	68bb      	ldr	r3, [r7, #8]
   27938:	3301      	adds	r3, #1
   2793a:	781b      	ldrb	r3, [r3, #0]
   2793c:	b29b      	uxth	r3, r3
   2793e:	021b      	lsls	r3, r3, #8
   27940:	b29b      	uxth	r3, r3
   27942:	4413      	add	r3, r2
   27944:	b29a      	uxth	r2, r3
   27946:	68fb      	ldr	r3, [r7, #12]
   27948:	80da      	strh	r2, [r3, #6]
   2794a:	68bb      	ldr	r3, [r7, #8]
   2794c:	3302      	adds	r3, #2
   2794e:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leSetDataLenCmdCmpl.status;
   27950:	68fb      	ldr	r3, [r7, #12]
   27952:	791a      	ldrb	r2, [r3, #4]
   27954:	68fb      	ldr	r3, [r7, #12]
   27956:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->leSetDataLenCmdCmpl.handle;
   27958:	68fb      	ldr	r3, [r7, #12]
   2795a:	88da      	ldrh	r2, [r3, #6]
   2795c:	68fb      	ldr	r3, [r7, #12]
   2795e:	801a      	strh	r2, [r3, #0]
}
   27960:	bf00      	nop
   27962:	3714      	adds	r7, #20
   27964:	46bd      	mov	sp, r7
   27966:	f85d 7b04 	ldr.w	r7, [sp], #4
   2796a:	4770      	bx	lr

0002796c <hciEvtParseReadMaxDataLenCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadMaxDataLenCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2796c:	b480      	push	{r7}
   2796e:	b085      	sub	sp, #20
   27970:	af00      	add	r7, sp, #0
   27972:	60f8      	str	r0, [r7, #12]
   27974:	60b9      	str	r1, [r7, #8]
   27976:	4613      	mov	r3, r2
   27978:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadMaxDataLenCmdCmpl.status, p);
   2797a:	68bb      	ldr	r3, [r7, #8]
   2797c:	1c5a      	adds	r2, r3, #1
   2797e:	60ba      	str	r2, [r7, #8]
   27980:	781a      	ldrb	r2, [r3, #0]
   27982:	68fb      	ldr	r3, [r7, #12]
   27984:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leReadMaxDataLenCmdCmpl.supportedMaxTxOctets, p);
   27986:	68bb      	ldr	r3, [r7, #8]
   27988:	781b      	ldrb	r3, [r3, #0]
   2798a:	b29a      	uxth	r2, r3
   2798c:	68bb      	ldr	r3, [r7, #8]
   2798e:	3301      	adds	r3, #1
   27990:	781b      	ldrb	r3, [r3, #0]
   27992:	b29b      	uxth	r3, r3
   27994:	021b      	lsls	r3, r3, #8
   27996:	b29b      	uxth	r3, r3
   27998:	4413      	add	r3, r2
   2799a:	b29a      	uxth	r2, r3
   2799c:	68fb      	ldr	r3, [r7, #12]
   2799e:	80da      	strh	r2, [r3, #6]
   279a0:	68bb      	ldr	r3, [r7, #8]
   279a2:	3302      	adds	r3, #2
   279a4:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leReadMaxDataLenCmdCmpl.supportedMaxTxTime, p);
   279a6:	68bb      	ldr	r3, [r7, #8]
   279a8:	781b      	ldrb	r3, [r3, #0]
   279aa:	b29a      	uxth	r2, r3
   279ac:	68bb      	ldr	r3, [r7, #8]
   279ae:	3301      	adds	r3, #1
   279b0:	781b      	ldrb	r3, [r3, #0]
   279b2:	b29b      	uxth	r3, r3
   279b4:	021b      	lsls	r3, r3, #8
   279b6:	b29b      	uxth	r3, r3
   279b8:	4413      	add	r3, r2
   279ba:	b29a      	uxth	r2, r3
   279bc:	68fb      	ldr	r3, [r7, #12]
   279be:	811a      	strh	r2, [r3, #8]
   279c0:	68bb      	ldr	r3, [r7, #8]
   279c2:	3302      	adds	r3, #2
   279c4:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leReadMaxDataLenCmdCmpl.supportedMaxRxOctets, p);
   279c6:	68bb      	ldr	r3, [r7, #8]
   279c8:	781b      	ldrb	r3, [r3, #0]
   279ca:	b29a      	uxth	r2, r3
   279cc:	68bb      	ldr	r3, [r7, #8]
   279ce:	3301      	adds	r3, #1
   279d0:	781b      	ldrb	r3, [r3, #0]
   279d2:	b29b      	uxth	r3, r3
   279d4:	021b      	lsls	r3, r3, #8
   279d6:	b29b      	uxth	r3, r3
   279d8:	4413      	add	r3, r2
   279da:	b29a      	uxth	r2, r3
   279dc:	68fb      	ldr	r3, [r7, #12]
   279de:	815a      	strh	r2, [r3, #10]
   279e0:	68bb      	ldr	r3, [r7, #8]
   279e2:	3302      	adds	r3, #2
   279e4:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leReadMaxDataLenCmdCmpl.supportedMaxRxTime, p);
   279e6:	68bb      	ldr	r3, [r7, #8]
   279e8:	781b      	ldrb	r3, [r3, #0]
   279ea:	b29a      	uxth	r2, r3
   279ec:	68bb      	ldr	r3, [r7, #8]
   279ee:	3301      	adds	r3, #1
   279f0:	781b      	ldrb	r3, [r3, #0]
   279f2:	b29b      	uxth	r3, r3
   279f4:	021b      	lsls	r3, r3, #8
   279f6:	b29b      	uxth	r3, r3
   279f8:	4413      	add	r3, r2
   279fa:	b29a      	uxth	r2, r3
   279fc:	68fb      	ldr	r3, [r7, #12]
   279fe:	819a      	strh	r2, [r3, #12]
   27a00:	68bb      	ldr	r3, [r7, #8]
   27a02:	3302      	adds	r3, #2
   27a04:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->leReadMaxDataLenCmdCmpl.status;
   27a06:	68fb      	ldr	r3, [r7, #12]
   27a08:	791a      	ldrb	r2, [r3, #4]
   27a0a:	68fb      	ldr	r3, [r7, #12]
   27a0c:	70da      	strb	r2, [r3, #3]
}
   27a0e:	bf00      	nop
   27a10:	3714      	adds	r7, #20
   27a12:	46bd      	mov	sp, r7
   27a14:	f85d 7b04 	ldr.w	r7, [sp], #4
   27a18:	4770      	bx	lr

00027a1a <hciEvtParseRemConnParamReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseRemConnParamReq(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27a1a:	b480      	push	{r7}
   27a1c:	b085      	sub	sp, #20
   27a1e:	af00      	add	r7, sp, #0
   27a20:	60f8      	str	r0, [r7, #12]
   27a22:	60b9      	str	r1, [r7, #8]
   27a24:	4613      	mov	r3, r2
   27a26:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamReq.handle, p);
   27a28:	68bb      	ldr	r3, [r7, #8]
   27a2a:	781b      	ldrb	r3, [r3, #0]
   27a2c:	b29a      	uxth	r2, r3
   27a2e:	68bb      	ldr	r3, [r7, #8]
   27a30:	3301      	adds	r3, #1
   27a32:	781b      	ldrb	r3, [r3, #0]
   27a34:	b29b      	uxth	r3, r3
   27a36:	021b      	lsls	r3, r3, #8
   27a38:	b29b      	uxth	r3, r3
   27a3a:	4413      	add	r3, r2
   27a3c:	b29a      	uxth	r2, r3
   27a3e:	68fb      	ldr	r3, [r7, #12]
   27a40:	809a      	strh	r2, [r3, #4]
   27a42:	68bb      	ldr	r3, [r7, #8]
   27a44:	3302      	adds	r3, #2
   27a46:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamReq.intervalMin, p);
   27a48:	68bb      	ldr	r3, [r7, #8]
   27a4a:	781b      	ldrb	r3, [r3, #0]
   27a4c:	b29a      	uxth	r2, r3
   27a4e:	68bb      	ldr	r3, [r7, #8]
   27a50:	3301      	adds	r3, #1
   27a52:	781b      	ldrb	r3, [r3, #0]
   27a54:	b29b      	uxth	r3, r3
   27a56:	021b      	lsls	r3, r3, #8
   27a58:	b29b      	uxth	r3, r3
   27a5a:	4413      	add	r3, r2
   27a5c:	b29a      	uxth	r2, r3
   27a5e:	68fb      	ldr	r3, [r7, #12]
   27a60:	80da      	strh	r2, [r3, #6]
   27a62:	68bb      	ldr	r3, [r7, #8]
   27a64:	3302      	adds	r3, #2
   27a66:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamReq.intervalMax, p);
   27a68:	68bb      	ldr	r3, [r7, #8]
   27a6a:	781b      	ldrb	r3, [r3, #0]
   27a6c:	b29a      	uxth	r2, r3
   27a6e:	68bb      	ldr	r3, [r7, #8]
   27a70:	3301      	adds	r3, #1
   27a72:	781b      	ldrb	r3, [r3, #0]
   27a74:	b29b      	uxth	r3, r3
   27a76:	021b      	lsls	r3, r3, #8
   27a78:	b29b      	uxth	r3, r3
   27a7a:	4413      	add	r3, r2
   27a7c:	b29a      	uxth	r2, r3
   27a7e:	68fb      	ldr	r3, [r7, #12]
   27a80:	811a      	strh	r2, [r3, #8]
   27a82:	68bb      	ldr	r3, [r7, #8]
   27a84:	3302      	adds	r3, #2
   27a86:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamReq.latency, p);
   27a88:	68bb      	ldr	r3, [r7, #8]
   27a8a:	781b      	ldrb	r3, [r3, #0]
   27a8c:	b29a      	uxth	r2, r3
   27a8e:	68bb      	ldr	r3, [r7, #8]
   27a90:	3301      	adds	r3, #1
   27a92:	781b      	ldrb	r3, [r3, #0]
   27a94:	b29b      	uxth	r3, r3
   27a96:	021b      	lsls	r3, r3, #8
   27a98:	b29b      	uxth	r3, r3
   27a9a:	4413      	add	r3, r2
   27a9c:	b29a      	uxth	r2, r3
   27a9e:	68fb      	ldr	r3, [r7, #12]
   27aa0:	815a      	strh	r2, [r3, #10]
   27aa2:	68bb      	ldr	r3, [r7, #8]
   27aa4:	3302      	adds	r3, #2
   27aa6:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leRemConnParamReq.timeout, p);
   27aa8:	68bb      	ldr	r3, [r7, #8]
   27aaa:	781b      	ldrb	r3, [r3, #0]
   27aac:	b29a      	uxth	r2, r3
   27aae:	68bb      	ldr	r3, [r7, #8]
   27ab0:	3301      	adds	r3, #1
   27ab2:	781b      	ldrb	r3, [r3, #0]
   27ab4:	b29b      	uxth	r3, r3
   27ab6:	021b      	lsls	r3, r3, #8
   27ab8:	b29b      	uxth	r3, r3
   27aba:	4413      	add	r3, r2
   27abc:	b29a      	uxth	r2, r3
   27abe:	68fb      	ldr	r3, [r7, #12]
   27ac0:	819a      	strh	r2, [r3, #12]
   27ac2:	68bb      	ldr	r3, [r7, #8]
   27ac4:	3302      	adds	r3, #2
   27ac6:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leRemConnParamReq.handle;
   27ac8:	68fb      	ldr	r3, [r7, #12]
   27aca:	889a      	ldrh	r2, [r3, #4]
   27acc:	68fb      	ldr	r3, [r7, #12]
   27ace:	801a      	strh	r2, [r3, #0]
}
   27ad0:	bf00      	nop
   27ad2:	3714      	adds	r7, #20
   27ad4:	46bd      	mov	sp, r7
   27ad6:	f85d 7b04 	ldr.w	r7, [sp], #4
   27ada:	4770      	bx	lr

00027adc <hciEvtParseDataLenChange>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseDataLenChange(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27adc:	b480      	push	{r7}
   27ade:	b085      	sub	sp, #20
   27ae0:	af00      	add	r7, sp, #0
   27ae2:	60f8      	str	r0, [r7, #12]
   27ae4:	60b9      	str	r1, [r7, #8]
   27ae6:	4613      	mov	r3, r2
   27ae8:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->leDataLenChange.handle, p);
   27aea:	68bb      	ldr	r3, [r7, #8]
   27aec:	781b      	ldrb	r3, [r3, #0]
   27aee:	b29a      	uxth	r2, r3
   27af0:	68bb      	ldr	r3, [r7, #8]
   27af2:	3301      	adds	r3, #1
   27af4:	781b      	ldrb	r3, [r3, #0]
   27af6:	b29b      	uxth	r3, r3
   27af8:	021b      	lsls	r3, r3, #8
   27afa:	b29b      	uxth	r3, r3
   27afc:	4413      	add	r3, r2
   27afe:	b29a      	uxth	r2, r3
   27b00:	68fb      	ldr	r3, [r7, #12]
   27b02:	809a      	strh	r2, [r3, #4]
   27b04:	68bb      	ldr	r3, [r7, #8]
   27b06:	3302      	adds	r3, #2
   27b08:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leDataLenChange.maxTxOctets, p);
   27b0a:	68bb      	ldr	r3, [r7, #8]
   27b0c:	781b      	ldrb	r3, [r3, #0]
   27b0e:	b29a      	uxth	r2, r3
   27b10:	68bb      	ldr	r3, [r7, #8]
   27b12:	3301      	adds	r3, #1
   27b14:	781b      	ldrb	r3, [r3, #0]
   27b16:	b29b      	uxth	r3, r3
   27b18:	021b      	lsls	r3, r3, #8
   27b1a:	b29b      	uxth	r3, r3
   27b1c:	4413      	add	r3, r2
   27b1e:	b29a      	uxth	r2, r3
   27b20:	68fb      	ldr	r3, [r7, #12]
   27b22:	80da      	strh	r2, [r3, #6]
   27b24:	68bb      	ldr	r3, [r7, #8]
   27b26:	3302      	adds	r3, #2
   27b28:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leDataLenChange.maxTxTime, p);
   27b2a:	68bb      	ldr	r3, [r7, #8]
   27b2c:	781b      	ldrb	r3, [r3, #0]
   27b2e:	b29a      	uxth	r2, r3
   27b30:	68bb      	ldr	r3, [r7, #8]
   27b32:	3301      	adds	r3, #1
   27b34:	781b      	ldrb	r3, [r3, #0]
   27b36:	b29b      	uxth	r3, r3
   27b38:	021b      	lsls	r3, r3, #8
   27b3a:	b29b      	uxth	r3, r3
   27b3c:	4413      	add	r3, r2
   27b3e:	b29a      	uxth	r2, r3
   27b40:	68fb      	ldr	r3, [r7, #12]
   27b42:	811a      	strh	r2, [r3, #8]
   27b44:	68bb      	ldr	r3, [r7, #8]
   27b46:	3302      	adds	r3, #2
   27b48:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leDataLenChange.maxRxOctets, p);
   27b4a:	68bb      	ldr	r3, [r7, #8]
   27b4c:	781b      	ldrb	r3, [r3, #0]
   27b4e:	b29a      	uxth	r2, r3
   27b50:	68bb      	ldr	r3, [r7, #8]
   27b52:	3301      	adds	r3, #1
   27b54:	781b      	ldrb	r3, [r3, #0]
   27b56:	b29b      	uxth	r3, r3
   27b58:	021b      	lsls	r3, r3, #8
   27b5a:	b29b      	uxth	r3, r3
   27b5c:	4413      	add	r3, r2
   27b5e:	b29a      	uxth	r2, r3
   27b60:	68fb      	ldr	r3, [r7, #12]
   27b62:	815a      	strh	r2, [r3, #10]
   27b64:	68bb      	ldr	r3, [r7, #8]
   27b66:	3302      	adds	r3, #2
   27b68:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT16(pMsg->leDataLenChange.maxRxTime, p);
   27b6a:	68bb      	ldr	r3, [r7, #8]
   27b6c:	781b      	ldrb	r3, [r3, #0]
   27b6e:	b29a      	uxth	r2, r3
   27b70:	68bb      	ldr	r3, [r7, #8]
   27b72:	3301      	adds	r3, #1
   27b74:	781b      	ldrb	r3, [r3, #0]
   27b76:	b29b      	uxth	r3, r3
   27b78:	021b      	lsls	r3, r3, #8
   27b7a:	b29b      	uxth	r3, r3
   27b7c:	4413      	add	r3, r2
   27b7e:	b29a      	uxth	r2, r3
   27b80:	68fb      	ldr	r3, [r7, #12]
   27b82:	819a      	strh	r2, [r3, #12]
   27b84:	68bb      	ldr	r3, [r7, #8]
   27b86:	3302      	adds	r3, #2
   27b88:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->leDataLenChange.handle;
   27b8a:	68fb      	ldr	r3, [r7, #12]
   27b8c:	889a      	ldrh	r2, [r3, #4]
   27b8e:	68fb      	ldr	r3, [r7, #12]
   27b90:	801a      	strh	r2, [r3, #0]
}
   27b92:	bf00      	nop
   27b94:	3714      	adds	r7, #20
   27b96:	46bd      	mov	sp, r7
   27b98:	f85d 7b04 	ldr.w	r7, [sp], #4
   27b9c:	4770      	bx	lr

00027b9e <hciEvtParseReadPubKeyCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadPubKeyCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27b9e:	b580      	push	{r7, lr}
   27ba0:	b084      	sub	sp, #16
   27ba2:	af00      	add	r7, sp, #0
   27ba4:	60f8      	str	r0, [r7, #12]
   27ba6:	60b9      	str	r1, [r7, #8]
   27ba8:	4613      	mov	r3, r2
   27baa:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leP256.status, p);
   27bac:	68bb      	ldr	r3, [r7, #8]
   27bae:	1c5a      	adds	r2, r3, #1
   27bb0:	60ba      	str	r2, [r7, #8]
   27bb2:	781a      	ldrb	r2, [r3, #0]
   27bb4:	68fb      	ldr	r3, [r7, #12]
   27bb6:	711a      	strb	r2, [r3, #4]
  memcpy(pMsg->leP256.key, p, HCI_P256_KEY_LEN);
   27bb8:	68fb      	ldr	r3, [r7, #12]
   27bba:	3305      	adds	r3, #5
   27bbc:	2240      	movs	r2, #64	; 0x40
   27bbe:	68b9      	ldr	r1, [r7, #8]
   27bc0:	4618      	mov	r0, r3
   27bc2:	f7f0 fb47 	bl	18254 <memcpy>

  pMsg->hdr.status = pMsg->leP256.status;
   27bc6:	68fb      	ldr	r3, [r7, #12]
   27bc8:	791a      	ldrb	r2, [r3, #4]
   27bca:	68fb      	ldr	r3, [r7, #12]
   27bcc:	70da      	strb	r2, [r3, #3]
}
   27bce:	bf00      	nop
   27bd0:	3710      	adds	r7, #16
   27bd2:	46bd      	mov	sp, r7
   27bd4:	bd80      	pop	{r7, pc}

00027bd6 <hciEvtParseGenDhKeyCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseGenDhKeyCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27bd6:	b580      	push	{r7, lr}
   27bd8:	b084      	sub	sp, #16
   27bda:	af00      	add	r7, sp, #0
   27bdc:	60f8      	str	r0, [r7, #12]
   27bde:	60b9      	str	r1, [r7, #8]
   27be0:	4613      	mov	r3, r2
   27be2:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leGenDHKey.status, p);
   27be4:	68bb      	ldr	r3, [r7, #8]
   27be6:	1c5a      	adds	r2, r3, #1
   27be8:	60ba      	str	r2, [r7, #8]
   27bea:	781a      	ldrb	r2, [r3, #0]
   27bec:	68fb      	ldr	r3, [r7, #12]
   27bee:	711a      	strb	r2, [r3, #4]
  memcpy(pMsg->leGenDHKey.key, p, HCI_DH_KEY_LEN);
   27bf0:	68fb      	ldr	r3, [r7, #12]
   27bf2:	3305      	adds	r3, #5
   27bf4:	2220      	movs	r2, #32
   27bf6:	68b9      	ldr	r1, [r7, #8]
   27bf8:	4618      	mov	r0, r3
   27bfa:	f7f0 fb2b 	bl	18254 <memcpy>

  pMsg->hdr.status = pMsg->leGenDHKey.status;
   27bfe:	68fb      	ldr	r3, [r7, #12]
   27c00:	791a      	ldrb	r2, [r3, #4]
   27c02:	68fb      	ldr	r3, [r7, #12]
   27c04:	70da      	strb	r2, [r3, #3]
}
   27c06:	bf00      	nop
   27c08:	3710      	adds	r7, #16
   27c0a:	46bd      	mov	sp, r7
   27c0c:	bd80      	pop	{r7, pc}

00027c0e <hciEvtParseWriteAuthTimeoutCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtParseWriteAuthTimeoutCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27c0e:	b480      	push	{r7}
   27c10:	b085      	sub	sp, #20
   27c12:	af00      	add	r7, sp, #0
   27c14:	60f8      	str	r0, [r7, #12]
   27c16:	60b9      	str	r1, [r7, #8]
   27c18:	4613      	mov	r3, r2
   27c1a:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->writeAuthPayloadToCmdCmpl.status, p);
   27c1c:	68bb      	ldr	r3, [r7, #8]
   27c1e:	1c5a      	adds	r2, r3, #1
   27c20:	60ba      	str	r2, [r7, #8]
   27c22:	781a      	ldrb	r2, [r3, #0]
   27c24:	68fb      	ldr	r3, [r7, #12]
   27c26:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->writeAuthPayloadToCmdCmpl.handle, p);
   27c28:	68bb      	ldr	r3, [r7, #8]
   27c2a:	781b      	ldrb	r3, [r3, #0]
   27c2c:	b29a      	uxth	r2, r3
   27c2e:	68bb      	ldr	r3, [r7, #8]
   27c30:	3301      	adds	r3, #1
   27c32:	781b      	ldrb	r3, [r3, #0]
   27c34:	b29b      	uxth	r3, r3
   27c36:	021b      	lsls	r3, r3, #8
   27c38:	b29b      	uxth	r3, r3
   27c3a:	4413      	add	r3, r2
   27c3c:	b29a      	uxth	r2, r3
   27c3e:	68fb      	ldr	r3, [r7, #12]
   27c40:	80da      	strh	r2, [r3, #6]
   27c42:	68bb      	ldr	r3, [r7, #8]
   27c44:	3302      	adds	r3, #2
   27c46:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.status = pMsg->writeAuthPayloadToCmdCmpl.status;
   27c48:	68fb      	ldr	r3, [r7, #12]
   27c4a:	791a      	ldrb	r2, [r3, #4]
   27c4c:	68fb      	ldr	r3, [r7, #12]
   27c4e:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->writeAuthPayloadToCmdCmpl.handle;
   27c50:	68fb      	ldr	r3, [r7, #12]
   27c52:	88da      	ldrh	r2, [r3, #6]
   27c54:	68fb      	ldr	r3, [r7, #12]
   27c56:	801a      	strh	r2, [r3, #0]
}
   27c58:	bf00      	nop
   27c5a:	3714      	adds	r7, #20
   27c5c:	46bd      	mov	sp, r7
   27c5e:	f85d 7b04 	ldr.w	r7, [sp], #4
   27c62:	4770      	bx	lr

00027c64 <hciEvtParseAuthTimeoutExpiredEvt>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtParseAuthTimeoutExpiredEvt(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27c64:	b480      	push	{r7}
   27c66:	b085      	sub	sp, #20
   27c68:	af00      	add	r7, sp, #0
   27c6a:	60f8      	str	r0, [r7, #12]
   27c6c:	60b9      	str	r1, [r7, #8]
   27c6e:	4613      	mov	r3, r2
   27c70:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->authPayloadToExpired.handle, p);
   27c72:	68bb      	ldr	r3, [r7, #8]
   27c74:	781b      	ldrb	r3, [r3, #0]
   27c76:	b29a      	uxth	r2, r3
   27c78:	68bb      	ldr	r3, [r7, #8]
   27c7a:	3301      	adds	r3, #1
   27c7c:	781b      	ldrb	r3, [r3, #0]
   27c7e:	b29b      	uxth	r3, r3
   27c80:	021b      	lsls	r3, r3, #8
   27c82:	b29b      	uxth	r3, r3
   27c84:	4413      	add	r3, r2
   27c86:	b29a      	uxth	r2, r3
   27c88:	68fb      	ldr	r3, [r7, #12]
   27c8a:	809a      	strh	r2, [r3, #4]
   27c8c:	68bb      	ldr	r3, [r7, #8]
   27c8e:	3302      	adds	r3, #2
   27c90:	60bb      	str	r3, [r7, #8]

  pMsg->hdr.param = pMsg->authPayloadToExpired.handle;
   27c92:	68fb      	ldr	r3, [r7, #12]
   27c94:	889a      	ldrh	r2, [r3, #4]
   27c96:	68fb      	ldr	r3, [r7, #12]
   27c98:	801a      	strh	r2, [r3, #0]
}
   27c9a:	bf00      	nop
   27c9c:	3714      	adds	r7, #20
   27c9e:	46bd      	mov	sp, r7
   27ca0:	f85d 7b04 	ldr.w	r7, [sp], #4
   27ca4:	4770      	bx	lr

00027ca6 <hciEvtParseReadPhyCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseReadPhyCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27ca6:	b480      	push	{r7}
   27ca8:	b085      	sub	sp, #20
   27caa:	af00      	add	r7, sp, #0
   27cac:	60f8      	str	r0, [r7, #12]
   27cae:	60b9      	str	r1, [r7, #8]
   27cb0:	4613      	mov	r3, r2
   27cb2:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leReadPhyCmdCmpl.status, p);
   27cb4:	68bb      	ldr	r3, [r7, #8]
   27cb6:	1c5a      	adds	r2, r3, #1
   27cb8:	60ba      	str	r2, [r7, #8]
   27cba:	781a      	ldrb	r2, [r3, #0]
   27cbc:	68fb      	ldr	r3, [r7, #12]
   27cbe:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->leReadPhyCmdCmpl.handle, p);
   27cc0:	68bb      	ldr	r3, [r7, #8]
   27cc2:	781b      	ldrb	r3, [r3, #0]
   27cc4:	b29a      	uxth	r2, r3
   27cc6:	68bb      	ldr	r3, [r7, #8]
   27cc8:	3301      	adds	r3, #1
   27cca:	781b      	ldrb	r3, [r3, #0]
   27ccc:	b29b      	uxth	r3, r3
   27cce:	021b      	lsls	r3, r3, #8
   27cd0:	b29b      	uxth	r3, r3
   27cd2:	4413      	add	r3, r2
   27cd4:	b29a      	uxth	r2, r3
   27cd6:	68fb      	ldr	r3, [r7, #12]
   27cd8:	80da      	strh	r2, [r3, #6]
   27cda:	68bb      	ldr	r3, [r7, #8]
   27cdc:	3302      	adds	r3, #2
   27cde:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leReadPhyCmdCmpl.txPhy, p);
   27ce0:	68bb      	ldr	r3, [r7, #8]
   27ce2:	1c5a      	adds	r2, r3, #1
   27ce4:	60ba      	str	r2, [r7, #8]
   27ce6:	781a      	ldrb	r2, [r3, #0]
   27ce8:	68fb      	ldr	r3, [r7, #12]
   27cea:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT8(pMsg->leReadPhyCmdCmpl.rxPhy, p);
   27cec:	68bb      	ldr	r3, [r7, #8]
   27cee:	1c5a      	adds	r2, r3, #1
   27cf0:	60ba      	str	r2, [r7, #8]
   27cf2:	781a      	ldrb	r2, [r3, #0]
   27cf4:	68fb      	ldr	r3, [r7, #12]
   27cf6:	725a      	strb	r2, [r3, #9]

  pMsg->hdr.status = pMsg->leReadPhyCmdCmpl.status;
   27cf8:	68fb      	ldr	r3, [r7, #12]
   27cfa:	791a      	ldrb	r2, [r3, #4]
   27cfc:	68fb      	ldr	r3, [r7, #12]
   27cfe:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->leReadPhyCmdCmpl.handle;
   27d00:	68fb      	ldr	r3, [r7, #12]
   27d02:	88da      	ldrh	r2, [r3, #6]
   27d04:	68fb      	ldr	r3, [r7, #12]
   27d06:	801a      	strh	r2, [r3, #0]
}
   27d08:	bf00      	nop
   27d0a:	3714      	adds	r7, #20
   27d0c:	46bd      	mov	sp, r7
   27d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
   27d12:	4770      	bx	lr

00027d14 <hciEvtParseSetDefPhyCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseSetDefPhyCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27d14:	b480      	push	{r7}
   27d16:	b085      	sub	sp, #20
   27d18:	af00      	add	r7, sp, #0
   27d1a:	60f8      	str	r0, [r7, #12]
   27d1c:	60b9      	str	r1, [r7, #8]
   27d1e:	4613      	mov	r3, r2
   27d20:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leSetDefPhyCmdCmpl.status, p);
   27d22:	68bb      	ldr	r3, [r7, #8]
   27d24:	1c5a      	adds	r2, r3, #1
   27d26:	60ba      	str	r2, [r7, #8]
   27d28:	781a      	ldrb	r2, [r3, #0]
   27d2a:	68fb      	ldr	r3, [r7, #12]
   27d2c:	711a      	strb	r2, [r3, #4]

  pMsg->hdr.status = pMsg->leSetDefPhyCmdCmpl.status;
   27d2e:	68fb      	ldr	r3, [r7, #12]
   27d30:	791a      	ldrb	r2, [r3, #4]
   27d32:	68fb      	ldr	r3, [r7, #12]
   27d34:	70da      	strb	r2, [r3, #3]
}
   27d36:	bf00      	nop
   27d38:	3714      	adds	r7, #20
   27d3a:	46bd      	mov	sp, r7
   27d3c:	f85d 7b04 	ldr.w	r7, [sp], #4
   27d40:	4770      	bx	lr

00027d42 <hciEvtParsePhyUpdateCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParsePhyUpdateCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   27d42:	b480      	push	{r7}
   27d44:	b085      	sub	sp, #20
   27d46:	af00      	add	r7, sp, #0
   27d48:	60f8      	str	r0, [r7, #12]
   27d4a:	60b9      	str	r1, [r7, #8]
   27d4c:	4613      	mov	r3, r2
   27d4e:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->lePhyUpdate.status, p);
   27d50:	68bb      	ldr	r3, [r7, #8]
   27d52:	1c5a      	adds	r2, r3, #1
   27d54:	60ba      	str	r2, [r7, #8]
   27d56:	781a      	ldrb	r2, [r3, #0]
   27d58:	68fb      	ldr	r3, [r7, #12]
   27d5a:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->lePhyUpdate.handle, p);
   27d5c:	68bb      	ldr	r3, [r7, #8]
   27d5e:	781b      	ldrb	r3, [r3, #0]
   27d60:	b29a      	uxth	r2, r3
   27d62:	68bb      	ldr	r3, [r7, #8]
   27d64:	3301      	adds	r3, #1
   27d66:	781b      	ldrb	r3, [r3, #0]
   27d68:	b29b      	uxth	r3, r3
   27d6a:	021b      	lsls	r3, r3, #8
   27d6c:	b29b      	uxth	r3, r3
   27d6e:	4413      	add	r3, r2
   27d70:	b29a      	uxth	r2, r3
   27d72:	68fb      	ldr	r3, [r7, #12]
   27d74:	80da      	strh	r2, [r3, #6]
   27d76:	68bb      	ldr	r3, [r7, #8]
   27d78:	3302      	adds	r3, #2
   27d7a:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->lePhyUpdate.txPhy, p);
   27d7c:	68bb      	ldr	r3, [r7, #8]
   27d7e:	1c5a      	adds	r2, r3, #1
   27d80:	60ba      	str	r2, [r7, #8]
   27d82:	781a      	ldrb	r2, [r3, #0]
   27d84:	68fb      	ldr	r3, [r7, #12]
   27d86:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT8(pMsg->lePhyUpdate.rxPhy, p);
   27d88:	68bb      	ldr	r3, [r7, #8]
   27d8a:	1c5a      	adds	r2, r3, #1
   27d8c:	60ba      	str	r2, [r7, #8]
   27d8e:	781a      	ldrb	r2, [r3, #0]
   27d90:	68fb      	ldr	r3, [r7, #12]
   27d92:	725a      	strb	r2, [r3, #9]

  pMsg->hdr.status = pMsg->lePhyUpdate.status;
   27d94:	68fb      	ldr	r3, [r7, #12]
   27d96:	791a      	ldrb	r2, [r3, #4]
   27d98:	68fb      	ldr	r3, [r7, #12]
   27d9a:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->lePhyUpdate.handle;
   27d9c:	68fb      	ldr	r3, [r7, #12]
   27d9e:	88da      	ldrh	r2, [r3, #6]
   27da0:	68fb      	ldr	r3, [r7, #12]
   27da2:	801a      	strh	r2, [r3, #0]
}
   27da4:	bf00      	nop
   27da6:	3714      	adds	r7, #20
   27da8:	46bd      	mov	sp, r7
   27daa:	f85d 7b04 	ldr.w	r7, [sp], #4
   27dae:	4770      	bx	lr

00027db0 <hciEvtProcessLeAdvReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLeAdvReport(uint8_t *p, uint8_t len)
{
   27db0:	b580      	push	{r7, lr}
   27db2:	b084      	sub	sp, #16
   27db4:	af00      	add	r7, sp, #0
   27db6:	6078      	str	r0, [r7, #4]
   27db8:	460b      	mov	r3, r1
   27dba:	70fb      	strb	r3, [r7, #3]
  hciLeAdvReportEvt_t *pMsg;
  uint8_t             i;

  /* get number of reports */
  BSTREAM_TO_UINT8(i, p);
   27dbc:	687b      	ldr	r3, [r7, #4]
   27dbe:	1c5a      	adds	r2, r3, #1
   27dc0:	607a      	str	r2, [r7, #4]
   27dc2:	781b      	ldrb	r3, [r3, #0]
   27dc4:	73fb      	strb	r3, [r7, #15]

  HCI_TRACE_INFO1("HCI Adv report, num reports: %d", i);

  /* sanity check num reports */
  if (i > HCI_MAX_REPORTS)
   27dc6:	7bfb      	ldrb	r3, [r7, #15]
   27dc8:	2b0f      	cmp	r3, #15
   27dca:	d862      	bhi.n	27e92 <hciEvtProcessLeAdvReport+0xe2>
  {
    return;
  }

  /* allocate temp buffer that can hold max length adv/scan rsp data */
  if ((pMsg = WsfBufAlloc(sizeof(hciLeAdvReportEvt_t) + HCI_ADV_DATA_LEN)) != NULL)
   27dcc:	203b      	movs	r0, #59	; 0x3b
   27dce:	f005 f8df 	bl	2cf90 <WsfBufAlloc>
   27dd2:	60b8      	str	r0, [r7, #8]
   27dd4:	68bb      	ldr	r3, [r7, #8]
   27dd6:	2b00      	cmp	r3, #0
   27dd8:	d05c      	beq.n	27e94 <hciEvtProcessLeAdvReport+0xe4>
  {
    /* parse each report and execute callback */
    while (i-- > 0)
   27dda:	e04f      	b.n	27e7c <hciEvtProcessLeAdvReport+0xcc>
    {
      BSTREAM_TO_UINT8(pMsg->eventType, p);
   27ddc:	687b      	ldr	r3, [r7, #4]
   27dde:	1c5a      	adds	r2, r3, #1
   27de0:	607a      	str	r2, [r7, #4]
   27de2:	781a      	ldrb	r2, [r3, #0]
   27de4:	68bb      	ldr	r3, [r7, #8]
   27de6:	729a      	strb	r2, [r3, #10]
      BSTREAM_TO_UINT8(pMsg->addrType, p);
   27de8:	687b      	ldr	r3, [r7, #4]
   27dea:	1c5a      	adds	r2, r3, #1
   27dec:	607a      	str	r2, [r7, #4]
   27dee:	781a      	ldrb	r2, [r3, #0]
   27df0:	68bb      	ldr	r3, [r7, #8]
   27df2:	72da      	strb	r2, [r3, #11]
      BSTREAM_TO_BDA(pMsg->addr, p);
   27df4:	68bb      	ldr	r3, [r7, #8]
   27df6:	330c      	adds	r3, #12
   27df8:	6879      	ldr	r1, [r7, #4]
   27dfa:	4618      	mov	r0, r3
   27dfc:	f7f9 fec3 	bl	21b86 <BdaCpy>
   27e00:	687b      	ldr	r3, [r7, #4]
   27e02:	3306      	adds	r3, #6
   27e04:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->len, p);
   27e06:	687b      	ldr	r3, [r7, #4]
   27e08:	1c5a      	adds	r2, r3, #1
   27e0a:	607a      	str	r2, [r7, #4]
   27e0c:	781a      	ldrb	r2, [r3, #0]
   27e0e:	68bb      	ldr	r3, [r7, #8]
   27e10:	721a      	strb	r2, [r3, #8]

      HCI_TRACE_INFO1("HCI Adv report, data len: %d", pMsg->len);

      /* sanity check on report length; quit if invalid */
      if (pMsg->len > HCI_ADV_DATA_LEN)
   27e12:	68bb      	ldr	r3, [r7, #8]
   27e14:	7a1b      	ldrb	r3, [r3, #8]
   27e16:	2b1f      	cmp	r3, #31
   27e18:	d836      	bhi.n	27e88 <hciEvtProcessLeAdvReport+0xd8>
        HCI_TRACE_WARN0("Invalid adv report data len");
        break;
      }

      /* Copy data to space after end of report struct */
      pMsg->pData = (uint8_t *) (pMsg + 1);
   27e1a:	68bb      	ldr	r3, [r7, #8]
   27e1c:	f103 021c 	add.w	r2, r3, #28
   27e20:	68bb      	ldr	r3, [r7, #8]
   27e22:	605a      	str	r2, [r3, #4]
      memcpy(pMsg->pData, p, pMsg->len);
   27e24:	68bb      	ldr	r3, [r7, #8]
   27e26:	6858      	ldr	r0, [r3, #4]
   27e28:	68bb      	ldr	r3, [r7, #8]
   27e2a:	7a1b      	ldrb	r3, [r3, #8]
   27e2c:	461a      	mov	r2, r3
   27e2e:	6879      	ldr	r1, [r7, #4]
   27e30:	f7f0 fa10 	bl	18254 <memcpy>
      p += pMsg->len;
   27e34:	68bb      	ldr	r3, [r7, #8]
   27e36:	7a1b      	ldrb	r3, [r3, #8]
   27e38:	461a      	mov	r2, r3
   27e3a:	687b      	ldr	r3, [r7, #4]
   27e3c:	4413      	add	r3, r2
   27e3e:	607b      	str	r3, [r7, #4]

      BSTREAM_TO_UINT8(pMsg->rssi, p);
   27e40:	687b      	ldr	r3, [r7, #4]
   27e42:	1c5a      	adds	r2, r3, #1
   27e44:	607a      	str	r2, [r7, #4]
   27e46:	781b      	ldrb	r3, [r3, #0]
   27e48:	b25a      	sxtb	r2, r3
   27e4a:	68bb      	ldr	r3, [r7, #8]
   27e4c:	725a      	strb	r2, [r3, #9]

      /* zero out unused fields */
      pMsg->directAddrType = 0;
   27e4e:	68bb      	ldr	r3, [r7, #8]
   27e50:	2200      	movs	r2, #0
   27e52:	749a      	strb	r2, [r3, #18]
      memset(pMsg->directAddr, 0, BDA_ADDR_LEN);
   27e54:	68bb      	ldr	r3, [r7, #8]
   27e56:	3313      	adds	r3, #19
   27e58:	2206      	movs	r2, #6
   27e5a:	2100      	movs	r1, #0
   27e5c:	4618      	mov	r0, r3
   27e5e:	f008 f947 	bl	300f0 <memset>

      /* initialize message header */
      pMsg->hdr.param = 0;
   27e62:	68bb      	ldr	r3, [r7, #8]
   27e64:	2200      	movs	r2, #0
   27e66:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = HCI_LE_ADV_REPORT_CBACK_EVT;
   27e68:	68bb      	ldr	r3, [r7, #8]
   27e6a:	2206      	movs	r2, #6
   27e6c:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = 0;
   27e6e:	68bb      	ldr	r3, [r7, #8]
   27e70:	2200      	movs	r2, #0
   27e72:	70da      	strb	r2, [r3, #3]

      /* execute callback */
      (*hciCb.evtCback)((hciEvt_t *) pMsg);
   27e74:	4b09      	ldr	r3, [pc, #36]	; (27e9c <hciEvtProcessLeAdvReport+0xec>)
   27e76:	689b      	ldr	r3, [r3, #8]
   27e78:	68b8      	ldr	r0, [r7, #8]
   27e7a:	4798      	blx	r3
    while (i-- > 0)
   27e7c:	7bfb      	ldrb	r3, [r7, #15]
   27e7e:	1e5a      	subs	r2, r3, #1
   27e80:	73fa      	strb	r2, [r7, #15]
   27e82:	2b00      	cmp	r3, #0
   27e84:	d1aa      	bne.n	27ddc <hciEvtProcessLeAdvReport+0x2c>
   27e86:	e000      	b.n	27e8a <hciEvtProcessLeAdvReport+0xda>
        break;
   27e88:	bf00      	nop
    }

    /* free buffer */
    WsfBufFree(pMsg);
   27e8a:	68b8      	ldr	r0, [r7, #8]
   27e8c:	f005 f8c0 	bl	2d010 <WsfBufFree>
   27e90:	e000      	b.n	27e94 <hciEvtProcessLeAdvReport+0xe4>
    return;
   27e92:	bf00      	nop
  }
}
   27e94:	3710      	adds	r7, #16
   27e96:	46bd      	mov	sp, r7
   27e98:	bd80      	pop	{r7, pc}
   27e9a:	bf00      	nop
   27e9c:	100116ec 	.word	0x100116ec

00027ea0 <hciEvtProcessLeExtAdvReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLeExtAdvReport(uint8_t *p, uint8_t len)
{
   27ea0:	b580      	push	{r7, lr}
   27ea2:	b088      	sub	sp, #32
   27ea4:	af00      	add	r7, sp, #0
   27ea6:	6078      	str	r0, [r7, #4]
   27ea8:	460b      	mov	r3, r1
   27eaa:	70fb      	strb	r3, [r7, #3]
  uint8_t                *ptr;
  uint8_t                maxLen;
  uint8_t                dataLen;

  /* get number of reports without advancing pointer */
  i = *p;
   27eac:	687b      	ldr	r3, [r7, #4]
   27eae:	781b      	ldrb	r3, [r3, #0]
   27eb0:	77fb      	strb	r3, [r7, #31]

  HCI_TRACE_INFO1("HCI Ext Adv report, num reports: %d", i);

  /* sanity check num reports */
  if (i > HCI_MAX_REPORTS)
   27eb2:	7ffb      	ldrb	r3, [r7, #31]
   27eb4:	2b0f      	cmp	r3, #15
   27eb6:	f200 80c5 	bhi.w	28044 <hciEvtProcessLeExtAdvReport+0x1a4>
  {
    return;
  }

  ptr = p + 1;
   27eba:	687b      	ldr	r3, [r7, #4]
   27ebc:	3301      	adds	r3, #1
   27ebe:	61bb      	str	r3, [r7, #24]
  maxLen = 0;
   27ec0:	2300      	movs	r3, #0
   27ec2:	75fb      	strb	r3, [r7, #23]

  /* find out max length ext adv/scan rsp data */
  while (i-- > 0)
   27ec4:	e011      	b.n	27eea <hciEvtProcessLeExtAdvReport+0x4a>
  {
    ptr += HCI_EXT_ADV_RPT_DATA_LEN_OFFSET;
   27ec6:	69bb      	ldr	r3, [r7, #24]
   27ec8:	3317      	adds	r3, #23
   27eca:	61bb      	str	r3, [r7, #24]
    BSTREAM_TO_UINT8(dataLen, ptr);
   27ecc:	69bb      	ldr	r3, [r7, #24]
   27ece:	1c5a      	adds	r2, r3, #1
   27ed0:	61ba      	str	r2, [r7, #24]
   27ed2:	781b      	ldrb	r3, [r3, #0]
   27ed4:	73fb      	strb	r3, [r7, #15]
    ptr += dataLen;
   27ed6:	7bfb      	ldrb	r3, [r7, #15]
   27ed8:	69ba      	ldr	r2, [r7, #24]
   27eda:	4413      	add	r3, r2
   27edc:	61bb      	str	r3, [r7, #24]

    /* if len greater than max len seen so far */
    if (dataLen > maxLen)
   27ede:	7bfa      	ldrb	r2, [r7, #15]
   27ee0:	7dfb      	ldrb	r3, [r7, #23]
   27ee2:	429a      	cmp	r2, r3
   27ee4:	d901      	bls.n	27eea <hciEvtProcessLeExtAdvReport+0x4a>
    {
      /* update max len */
      maxLen = dataLen;
   27ee6:	7bfb      	ldrb	r3, [r7, #15]
   27ee8:	75fb      	strb	r3, [r7, #23]
  while (i-- > 0)
   27eea:	7ffb      	ldrb	r3, [r7, #31]
   27eec:	1e5a      	subs	r2, r3, #1
   27eee:	77fa      	strb	r2, [r7, #31]
   27ef0:	2b00      	cmp	r3, #0
   27ef2:	d1e8      	bne.n	27ec6 <hciEvtProcessLeExtAdvReport+0x26>
    }
  }

  /* allocate temp buffer that can hold max length ext adv/scan rsp data */
  if ((pMsg = WsfBufAlloc(sizeof(hciLeExtAdvReportEvt_t) + maxLen)) != NULL)
   27ef4:	7dfb      	ldrb	r3, [r7, #23]
   27ef6:	b29b      	uxth	r3, r3
   27ef8:	3324      	adds	r3, #36	; 0x24
   27efa:	b29b      	uxth	r3, r3
   27efc:	4618      	mov	r0, r3
   27efe:	f005 f847 	bl	2cf90 <WsfBufAlloc>
   27f02:	6138      	str	r0, [r7, #16]
   27f04:	693b      	ldr	r3, [r7, #16]
   27f06:	2b00      	cmp	r3, #0
   27f08:	f000 809d 	beq.w	28046 <hciEvtProcessLeExtAdvReport+0x1a6>
  {
    /* get number of reports */
    BSTREAM_TO_UINT8(i, p);
   27f0c:	687b      	ldr	r3, [r7, #4]
   27f0e:	1c5a      	adds	r2, r3, #1
   27f10:	607a      	str	r2, [r7, #4]
   27f12:	781b      	ldrb	r3, [r3, #0]
   27f14:	77fb      	strb	r3, [r7, #31]

    /* parse each report and execute callback */
    while (i-- > 0)
   27f16:	e089      	b.n	2802c <hciEvtProcessLeExtAdvReport+0x18c>
    {
      BSTREAM_TO_UINT16(pMsg->eventType, p);
   27f18:	687b      	ldr	r3, [r7, #4]
   27f1a:	781b      	ldrb	r3, [r3, #0]
   27f1c:	b29a      	uxth	r2, r3
   27f1e:	687b      	ldr	r3, [r7, #4]
   27f20:	3301      	adds	r3, #1
   27f22:	781b      	ldrb	r3, [r3, #0]
   27f24:	b29b      	uxth	r3, r3
   27f26:	021b      	lsls	r3, r3, #8
   27f28:	b29b      	uxth	r3, r3
   27f2a:	4413      	add	r3, r2
   27f2c:	b29a      	uxth	r2, r3
   27f2e:	693b      	ldr	r3, [r7, #16]
   27f30:	809a      	strh	r2, [r3, #4]
   27f32:	687b      	ldr	r3, [r7, #4]
   27f34:	3302      	adds	r3, #2
   27f36:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->addrType, p);
   27f38:	687b      	ldr	r3, [r7, #4]
   27f3a:	1c5a      	adds	r2, r3, #1
   27f3c:	607a      	str	r2, [r7, #4]
   27f3e:	781a      	ldrb	r2, [r3, #0]
   27f40:	693b      	ldr	r3, [r7, #16]
   27f42:	719a      	strb	r2, [r3, #6]
      BSTREAM_TO_BDA(pMsg->addr, p);
   27f44:	693b      	ldr	r3, [r7, #16]
   27f46:	3307      	adds	r3, #7
   27f48:	6879      	ldr	r1, [r7, #4]
   27f4a:	4618      	mov	r0, r3
   27f4c:	f7f9 fe1b 	bl	21b86 <BdaCpy>
   27f50:	687b      	ldr	r3, [r7, #4]
   27f52:	3306      	adds	r3, #6
   27f54:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->priPhy, p);
   27f56:	687b      	ldr	r3, [r7, #4]
   27f58:	1c5a      	adds	r2, r3, #1
   27f5a:	607a      	str	r2, [r7, #4]
   27f5c:	781a      	ldrb	r2, [r3, #0]
   27f5e:	693b      	ldr	r3, [r7, #16]
   27f60:	735a      	strb	r2, [r3, #13]
      BSTREAM_TO_UINT8(pMsg->secPhy, p);
   27f62:	687b      	ldr	r3, [r7, #4]
   27f64:	1c5a      	adds	r2, r3, #1
   27f66:	607a      	str	r2, [r7, #4]
   27f68:	781a      	ldrb	r2, [r3, #0]
   27f6a:	693b      	ldr	r3, [r7, #16]
   27f6c:	739a      	strb	r2, [r3, #14]
      BSTREAM_TO_UINT8(pMsg->advSid, p);
   27f6e:	687b      	ldr	r3, [r7, #4]
   27f70:	1c5a      	adds	r2, r3, #1
   27f72:	607a      	str	r2, [r7, #4]
   27f74:	781a      	ldrb	r2, [r3, #0]
   27f76:	693b      	ldr	r3, [r7, #16]
   27f78:	73da      	strb	r2, [r3, #15]
      BSTREAM_TO_INT8(pMsg->txPower, p);
   27f7a:	687b      	ldr	r3, [r7, #4]
   27f7c:	1c5a      	adds	r2, r3, #1
   27f7e:	607a      	str	r2, [r7, #4]
   27f80:	781b      	ldrb	r3, [r3, #0]
   27f82:	b25a      	sxtb	r2, r3
   27f84:	693b      	ldr	r3, [r7, #16]
   27f86:	741a      	strb	r2, [r3, #16]
      BSTREAM_TO_INT8(pMsg->rssi, p);
   27f88:	687b      	ldr	r3, [r7, #4]
   27f8a:	1c5a      	adds	r2, r3, #1
   27f8c:	607a      	str	r2, [r7, #4]
   27f8e:	781b      	ldrb	r3, [r3, #0]
   27f90:	b25a      	sxtb	r2, r3
   27f92:	693b      	ldr	r3, [r7, #16]
   27f94:	745a      	strb	r2, [r3, #17]
      BSTREAM_TO_UINT16(pMsg->perAdvInter, p);
   27f96:	687b      	ldr	r3, [r7, #4]
   27f98:	781b      	ldrb	r3, [r3, #0]
   27f9a:	b29a      	uxth	r2, r3
   27f9c:	687b      	ldr	r3, [r7, #4]
   27f9e:	3301      	adds	r3, #1
   27fa0:	781b      	ldrb	r3, [r3, #0]
   27fa2:	b29b      	uxth	r3, r3
   27fa4:	021b      	lsls	r3, r3, #8
   27fa6:	b29b      	uxth	r3, r3
   27fa8:	4413      	add	r3, r2
   27faa:	b29b      	uxth	r3, r3
   27fac:	b21a      	sxth	r2, r3
   27fae:	693b      	ldr	r3, [r7, #16]
   27fb0:	825a      	strh	r2, [r3, #18]
   27fb2:	687b      	ldr	r3, [r7, #4]
   27fb4:	3302      	adds	r3, #2
   27fb6:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->directAddrType, p);
   27fb8:	687b      	ldr	r3, [r7, #4]
   27fba:	1c5a      	adds	r2, r3, #1
   27fbc:	607a      	str	r2, [r7, #4]
   27fbe:	781a      	ldrb	r2, [r3, #0]
   27fc0:	693b      	ldr	r3, [r7, #16]
   27fc2:	751a      	strb	r2, [r3, #20]
      BSTREAM_TO_BDA(pMsg->directAddr, p);
   27fc4:	693b      	ldr	r3, [r7, #16]
   27fc6:	3315      	adds	r3, #21
   27fc8:	6879      	ldr	r1, [r7, #4]
   27fca:	4618      	mov	r0, r3
   27fcc:	f7f9 fddb 	bl	21b86 <BdaCpy>
   27fd0:	687b      	ldr	r3, [r7, #4]
   27fd2:	3306      	adds	r3, #6
   27fd4:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->len, p);
   27fd6:	687b      	ldr	r3, [r7, #4]
   27fd8:	1c5a      	adds	r2, r3, #1
   27fda:	607a      	str	r2, [r7, #4]
   27fdc:	781b      	ldrb	r3, [r3, #0]
   27fde:	b29a      	uxth	r2, r3
   27fe0:	693b      	ldr	r3, [r7, #16]
   27fe2:	839a      	strh	r2, [r3, #28]

      HCI_TRACE_INFO1("HCI Ext Adv report, data len: %d", pMsg->len);

      /* sanity check on report length; quit if invalid */
      if (pMsg->len > HCI_EXT_ADV_RPT_DATA_LEN)
   27fe4:	693b      	ldr	r3, [r7, #16]
   27fe6:	8b9b      	ldrh	r3, [r3, #28]
   27fe8:	2be5      	cmp	r3, #229	; 0xe5
   27fea:	d826      	bhi.n	2803a <hciEvtProcessLeExtAdvReport+0x19a>
        HCI_TRACE_WARN0("Invalid ext adv report data len");
        break;
      }

      /* Copy data to space after end of report struct */
      pMsg->pData = (uint8_t *)(pMsg + 1);
   27fec:	693b      	ldr	r3, [r7, #16]
   27fee:	f103 0224 	add.w	r2, r3, #36	; 0x24
   27ff2:	693b      	ldr	r3, [r7, #16]
   27ff4:	621a      	str	r2, [r3, #32]
      memcpy(pMsg->pData, p, pMsg->len);
   27ff6:	693b      	ldr	r3, [r7, #16]
   27ff8:	6a18      	ldr	r0, [r3, #32]
   27ffa:	693b      	ldr	r3, [r7, #16]
   27ffc:	8b9b      	ldrh	r3, [r3, #28]
   27ffe:	461a      	mov	r2, r3
   28000:	6879      	ldr	r1, [r7, #4]
   28002:	f7f0 f927 	bl	18254 <memcpy>
      p += pMsg->len;
   28006:	693b      	ldr	r3, [r7, #16]
   28008:	8b9b      	ldrh	r3, [r3, #28]
   2800a:	461a      	mov	r2, r3
   2800c:	687b      	ldr	r3, [r7, #4]
   2800e:	4413      	add	r3, r2
   28010:	607b      	str	r3, [r7, #4]

      /* initialize message header */
      pMsg->hdr.param = 0;
   28012:	693b      	ldr	r3, [r7, #16]
   28014:	2200      	movs	r2, #0
   28016:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = HCI_LE_EXT_ADV_REPORT_CBACK_EVT;
   28018:	693b      	ldr	r3, [r7, #16]
   2801a:	222c      	movs	r2, #44	; 0x2c
   2801c:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = 0;
   2801e:	693b      	ldr	r3, [r7, #16]
   28020:	2200      	movs	r2, #0
   28022:	70da      	strb	r2, [r3, #3]

      /* execute callback */
      (*hciCb.evtCback)((hciEvt_t *)pMsg);
   28024:	4b09      	ldr	r3, [pc, #36]	; (2804c <hciEvtProcessLeExtAdvReport+0x1ac>)
   28026:	689b      	ldr	r3, [r3, #8]
   28028:	6938      	ldr	r0, [r7, #16]
   2802a:	4798      	blx	r3
    while (i-- > 0)
   2802c:	7ffb      	ldrb	r3, [r7, #31]
   2802e:	1e5a      	subs	r2, r3, #1
   28030:	77fa      	strb	r2, [r7, #31]
   28032:	2b00      	cmp	r3, #0
   28034:	f47f af70 	bne.w	27f18 <hciEvtProcessLeExtAdvReport+0x78>
   28038:	e000      	b.n	2803c <hciEvtProcessLeExtAdvReport+0x19c>
        break;
   2803a:	bf00      	nop
    }

    /* free buffer */
    WsfBufFree(pMsg);
   2803c:	6938      	ldr	r0, [r7, #16]
   2803e:	f004 ffe7 	bl	2d010 <WsfBufFree>
   28042:	e000      	b.n	28046 <hciEvtProcessLeExtAdvReport+0x1a6>
    return;
   28044:	bf00      	nop
  }
}
   28046:	3720      	adds	r7, #32
   28048:	46bd      	mov	sp, r7
   2804a:	bd80      	pop	{r7, pc}
   2804c:	100116ec 	.word	0x100116ec

00028050 <hciEvtParseLeScanTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeScanTimeout(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   28050:	b480      	push	{r7}
   28052:	b085      	sub	sp, #20
   28054:	af00      	add	r7, sp, #0
   28056:	60f8      	str	r0, [r7, #12]
   28058:	60b9      	str	r1, [r7, #8]
   2805a:	4613      	mov	r3, r2
   2805c:	71fb      	strb	r3, [r7, #7]
  /* empty */
}
   2805e:	bf00      	nop
   28060:	3714      	adds	r7, #20
   28062:	46bd      	mov	sp, r7
   28064:	f85d 7b04 	ldr.w	r7, [sp], #4
   28068:	4770      	bx	lr

0002806a <hciEvtParseLeAdvSetTerm>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeAdvSetTerm(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2806a:	b480      	push	{r7}
   2806c:	b085      	sub	sp, #20
   2806e:	af00      	add	r7, sp, #0
   28070:	60f8      	str	r0, [r7, #12]
   28072:	60b9      	str	r1, [r7, #8]
   28074:	4613      	mov	r3, r2
   28076:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leAdvSetTerm.status, p);
   28078:	68bb      	ldr	r3, [r7, #8]
   2807a:	1c5a      	adds	r2, r3, #1
   2807c:	60ba      	str	r2, [r7, #8]
   2807e:	781a      	ldrb	r2, [r3, #0]
   28080:	68fb      	ldr	r3, [r7, #12]
   28082:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT8(pMsg->leAdvSetTerm.advHandle, p);
   28084:	68bb      	ldr	r3, [r7, #8]
   28086:	1c5a      	adds	r2, r3, #1
   28088:	60ba      	str	r2, [r7, #8]
   2808a:	781a      	ldrb	r2, [r3, #0]
   2808c:	68fb      	ldr	r3, [r7, #12]
   2808e:	715a      	strb	r2, [r3, #5]
  BSTREAM_TO_UINT16(pMsg->leAdvSetTerm.handle, p);
   28090:	68bb      	ldr	r3, [r7, #8]
   28092:	781b      	ldrb	r3, [r3, #0]
   28094:	b29a      	uxth	r2, r3
   28096:	68bb      	ldr	r3, [r7, #8]
   28098:	3301      	adds	r3, #1
   2809a:	781b      	ldrb	r3, [r3, #0]
   2809c:	b29b      	uxth	r3, r3
   2809e:	021b      	lsls	r3, r3, #8
   280a0:	b29b      	uxth	r3, r3
   280a2:	4413      	add	r3, r2
   280a4:	b29a      	uxth	r2, r3
   280a6:	68fb      	ldr	r3, [r7, #12]
   280a8:	80da      	strh	r2, [r3, #6]
   280aa:	68bb      	ldr	r3, [r7, #8]
   280ac:	3302      	adds	r3, #2
   280ae:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->leAdvSetTerm.numComplEvts, p);
   280b0:	68bb      	ldr	r3, [r7, #8]
   280b2:	1c5a      	adds	r2, r3, #1
   280b4:	60ba      	str	r2, [r7, #8]
   280b6:	781a      	ldrb	r2, [r3, #0]
   280b8:	68fb      	ldr	r3, [r7, #12]
   280ba:	721a      	strb	r2, [r3, #8]

  pMsg->hdr.status = pMsg->leAdvSetTerm.status;
   280bc:	68fb      	ldr	r3, [r7, #12]
   280be:	791a      	ldrb	r2, [r3, #4]
   280c0:	68fb      	ldr	r3, [r7, #12]
   280c2:	70da      	strb	r2, [r3, #3]
  pMsg->hdr.param = pMsg->leAdvSetTerm.handle;
   280c4:	68fb      	ldr	r3, [r7, #12]
   280c6:	88da      	ldrh	r2, [r3, #6]
   280c8:	68fb      	ldr	r3, [r7, #12]
   280ca:	801a      	strh	r2, [r3, #0]
}
   280cc:	bf00      	nop
   280ce:	3714      	adds	r7, #20
   280d0:	46bd      	mov	sp, r7
   280d2:	f85d 7b04 	ldr.w	r7, [sp], #4
   280d6:	4770      	bx	lr

000280d8 <hciEvtParseLeScanReqRcvd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeScanReqRcvd(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   280d8:	b580      	push	{r7, lr}
   280da:	b084      	sub	sp, #16
   280dc:	af00      	add	r7, sp, #0
   280de:	60f8      	str	r0, [r7, #12]
   280e0:	60b9      	str	r1, [r7, #8]
   280e2:	4613      	mov	r3, r2
   280e4:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->leScanReqRcvd.advHandle, p);
   280e6:	68bb      	ldr	r3, [r7, #8]
   280e8:	1c5a      	adds	r2, r3, #1
   280ea:	60ba      	str	r2, [r7, #8]
   280ec:	781a      	ldrb	r2, [r3, #0]
   280ee:	68fb      	ldr	r3, [r7, #12]
   280f0:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT8(pMsg->leScanReqRcvd.scanAddrType, p);
   280f2:	68bb      	ldr	r3, [r7, #8]
   280f4:	1c5a      	adds	r2, r3, #1
   280f6:	60ba      	str	r2, [r7, #8]
   280f8:	781a      	ldrb	r2, [r3, #0]
   280fa:	68fb      	ldr	r3, [r7, #12]
   280fc:	715a      	strb	r2, [r3, #5]
  BSTREAM_TO_BDA(pMsg->leScanReqRcvd.scanAddr, p);
   280fe:	68fb      	ldr	r3, [r7, #12]
   28100:	3306      	adds	r3, #6
   28102:	68b9      	ldr	r1, [r7, #8]
   28104:	4618      	mov	r0, r3
   28106:	f7f9 fd3e 	bl	21b86 <BdaCpy>
   2810a:	68bb      	ldr	r3, [r7, #8]
   2810c:	3306      	adds	r3, #6
   2810e:	60bb      	str	r3, [r7, #8]
}
   28110:	bf00      	nop
   28112:	3710      	adds	r7, #16
   28114:	46bd      	mov	sp, r7
   28116:	bd80      	pop	{r7, pc}

00028118 <hciEvtParseLePerAdvSyncEst>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLePerAdvSyncEst(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   28118:	b580      	push	{r7, lr}
   2811a:	b084      	sub	sp, #16
   2811c:	af00      	add	r7, sp, #0
   2811e:	60f8      	str	r0, [r7, #12]
   28120:	60b9      	str	r1, [r7, #8]
   28122:	4613      	mov	r3, r2
   28124:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->lePerAdvSyncEst.status, p);
   28126:	68bb      	ldr	r3, [r7, #8]
   28128:	1c5a      	adds	r2, r3, #1
   2812a:	60ba      	str	r2, [r7, #8]
   2812c:	781a      	ldrb	r2, [r3, #0]
   2812e:	68fb      	ldr	r3, [r7, #12]
   28130:	711a      	strb	r2, [r3, #4]
  BSTREAM_TO_UINT16(pMsg->lePerAdvSyncEst.syncHandle, p);
   28132:	68bb      	ldr	r3, [r7, #8]
   28134:	781b      	ldrb	r3, [r3, #0]
   28136:	b29a      	uxth	r2, r3
   28138:	68bb      	ldr	r3, [r7, #8]
   2813a:	3301      	adds	r3, #1
   2813c:	781b      	ldrb	r3, [r3, #0]
   2813e:	b29b      	uxth	r3, r3
   28140:	021b      	lsls	r3, r3, #8
   28142:	b29b      	uxth	r3, r3
   28144:	4413      	add	r3, r2
   28146:	b29a      	uxth	r2, r3
   28148:	68fb      	ldr	r3, [r7, #12]
   2814a:	80da      	strh	r2, [r3, #6]
   2814c:	68bb      	ldr	r3, [r7, #8]
   2814e:	3302      	adds	r3, #2
   28150:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->lePerAdvSyncEst.advSid, p);
   28152:	68bb      	ldr	r3, [r7, #8]
   28154:	1c5a      	adds	r2, r3, #1
   28156:	60ba      	str	r2, [r7, #8]
   28158:	781a      	ldrb	r2, [r3, #0]
   2815a:	68fb      	ldr	r3, [r7, #12]
   2815c:	721a      	strb	r2, [r3, #8]
  BSTREAM_TO_UINT8(pMsg->lePerAdvSyncEst.advAddrType, p);
   2815e:	68bb      	ldr	r3, [r7, #8]
   28160:	1c5a      	adds	r2, r3, #1
   28162:	60ba      	str	r2, [r7, #8]
   28164:	781a      	ldrb	r2, [r3, #0]
   28166:	68fb      	ldr	r3, [r7, #12]
   28168:	725a      	strb	r2, [r3, #9]
  BSTREAM_TO_BDA(pMsg->lePerAdvSyncEst.advAddr, p);
   2816a:	68fb      	ldr	r3, [r7, #12]
   2816c:	330a      	adds	r3, #10
   2816e:	68b9      	ldr	r1, [r7, #8]
   28170:	4618      	mov	r0, r3
   28172:	f7f9 fd08 	bl	21b86 <BdaCpy>
   28176:	68bb      	ldr	r3, [r7, #8]
   28178:	3306      	adds	r3, #6
   2817a:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->lePerAdvSyncEst.advPhy, p);
   2817c:	68bb      	ldr	r3, [r7, #8]
   2817e:	1c5a      	adds	r2, r3, #1
   28180:	60ba      	str	r2, [r7, #8]
   28182:	781a      	ldrb	r2, [r3, #0]
   28184:	68fb      	ldr	r3, [r7, #12]
   28186:	741a      	strb	r2, [r3, #16]
  BSTREAM_TO_UINT16(pMsg->lePerAdvSyncEst.perAdvInterval, p);
   28188:	68bb      	ldr	r3, [r7, #8]
   2818a:	781b      	ldrb	r3, [r3, #0]
   2818c:	b29a      	uxth	r2, r3
   2818e:	68bb      	ldr	r3, [r7, #8]
   28190:	3301      	adds	r3, #1
   28192:	781b      	ldrb	r3, [r3, #0]
   28194:	b29b      	uxth	r3, r3
   28196:	021b      	lsls	r3, r3, #8
   28198:	b29b      	uxth	r3, r3
   2819a:	4413      	add	r3, r2
   2819c:	b29a      	uxth	r2, r3
   2819e:	68fb      	ldr	r3, [r7, #12]
   281a0:	825a      	strh	r2, [r3, #18]
   281a2:	68bb      	ldr	r3, [r7, #8]
   281a4:	3302      	adds	r3, #2
   281a6:	60bb      	str	r3, [r7, #8]
  BSTREAM_TO_UINT8(pMsg->lePerAdvSyncEst.clockAccuracy, p);
   281a8:	68bb      	ldr	r3, [r7, #8]
   281aa:	1c5a      	adds	r2, r3, #1
   281ac:	60ba      	str	r2, [r7, #8]
   281ae:	781a      	ldrb	r2, [r3, #0]
   281b0:	68fb      	ldr	r3, [r7, #12]
   281b2:	751a      	strb	r2, [r3, #20]

  pMsg->hdr.status = pMsg->lePerAdvSyncEst.status;
   281b4:	68fb      	ldr	r3, [r7, #12]
   281b6:	791a      	ldrb	r2, [r3, #4]
   281b8:	68fb      	ldr	r3, [r7, #12]
   281ba:	70da      	strb	r2, [r3, #3]
}
   281bc:	bf00      	nop
   281be:	3710      	adds	r7, #16
   281c0:	46bd      	mov	sp, r7
   281c2:	bd80      	pop	{r7, pc}

000281c4 <hciEvtProcessLePerAdvReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLePerAdvReport(uint8_t *p, uint8_t len)
{
   281c4:	b580      	push	{r7, lr}
   281c6:	b084      	sub	sp, #16
   281c8:	af00      	add	r7, sp, #0
   281ca:	6078      	str	r0, [r7, #4]
   281cc:	460b      	mov	r3, r1
   281ce:	70fb      	strb	r3, [r7, #3]
  uint8_t                dataLen;

  HCI_TRACE_INFO0("HCI Per Adv report");

  /* get report data length */
  dataLen = p[HCI_PER_ADV_RPT_DATA_LEN_OFFSET];
   281d0:	687b      	ldr	r3, [r7, #4]
   281d2:	799b      	ldrb	r3, [r3, #6]
   281d4:	73fb      	strb	r3, [r7, #15]

  /* sanity check on report length; quit if invalid */
  if (dataLen > HCI_PER_ADV_RPT_DATA_LEN)
   281d6:	7bfb      	ldrb	r3, [r7, #15]
   281d8:	2bf7      	cmp	r3, #247	; 0xf7
   281da:	d858      	bhi.n	2828e <hciEvtProcessLePerAdvReport+0xca>
    HCI_TRACE_WARN1("Invalid per adv report data len: %d", dataLen);
    return;
  }

  /* allocate temp buffer that can hold max length periodic adv report data */
  if ((pMsg = WsfBufAlloc(sizeof(hciLePerAdvReportEvt_t) + dataLen)) != NULL)
   281dc:	7bfb      	ldrb	r3, [r7, #15]
   281de:	b29b      	uxth	r3, r3
   281e0:	3310      	adds	r3, #16
   281e2:	b29b      	uxth	r3, r3
   281e4:	4618      	mov	r0, r3
   281e6:	f004 fed3 	bl	2cf90 <WsfBufAlloc>
   281ea:	60b8      	str	r0, [r7, #8]
   281ec:	68bb      	ldr	r3, [r7, #8]
   281ee:	2b00      	cmp	r3, #0
   281f0:	d04e      	beq.n	28290 <hciEvtProcessLePerAdvReport+0xcc>
  {
    /* parse report and execute callback */
    BSTREAM_TO_UINT16(pMsg->syncHandle, p);
   281f2:	687b      	ldr	r3, [r7, #4]
   281f4:	781b      	ldrb	r3, [r3, #0]
   281f6:	b29a      	uxth	r2, r3
   281f8:	687b      	ldr	r3, [r7, #4]
   281fa:	3301      	adds	r3, #1
   281fc:	781b      	ldrb	r3, [r3, #0]
   281fe:	b29b      	uxth	r3, r3
   28200:	021b      	lsls	r3, r3, #8
   28202:	b29b      	uxth	r3, r3
   28204:	4413      	add	r3, r2
   28206:	b29a      	uxth	r2, r3
   28208:	68bb      	ldr	r3, [r7, #8]
   2820a:	809a      	strh	r2, [r3, #4]
   2820c:	687b      	ldr	r3, [r7, #4]
   2820e:	3302      	adds	r3, #2
   28210:	607b      	str	r3, [r7, #4]
    BSTREAM_TO_UINT8(pMsg->txPower, p);
   28212:	687b      	ldr	r3, [r7, #4]
   28214:	1c5a      	adds	r2, r3, #1
   28216:	607a      	str	r2, [r7, #4]
   28218:	781a      	ldrb	r2, [r3, #0]
   2821a:	68bb      	ldr	r3, [r7, #8]
   2821c:	719a      	strb	r2, [r3, #6]
    BSTREAM_TO_UINT8(pMsg->rssi, p);
   2821e:	687b      	ldr	r3, [r7, #4]
   28220:	1c5a      	adds	r2, r3, #1
   28222:	607a      	str	r2, [r7, #4]
   28224:	781a      	ldrb	r2, [r3, #0]
   28226:	68bb      	ldr	r3, [r7, #8]
   28228:	71da      	strb	r2, [r3, #7]
    BSTREAM_TO_UINT8(pMsg->unused, p);
   2822a:	687b      	ldr	r3, [r7, #4]
   2822c:	1c5a      	adds	r2, r3, #1
   2822e:	607a      	str	r2, [r7, #4]
   28230:	781a      	ldrb	r2, [r3, #0]
   28232:	68bb      	ldr	r3, [r7, #8]
   28234:	721a      	strb	r2, [r3, #8]
    BSTREAM_TO_UINT8(pMsg->status, p);
   28236:	687b      	ldr	r3, [r7, #4]
   28238:	1c5a      	adds	r2, r3, #1
   2823a:	607a      	str	r2, [r7, #4]
   2823c:	781a      	ldrb	r2, [r3, #0]
   2823e:	68bb      	ldr	r3, [r7, #8]
   28240:	725a      	strb	r2, [r3, #9]
    BSTREAM_TO_UINT8(pMsg->len, p);
   28242:	687b      	ldr	r3, [r7, #4]
   28244:	1c5a      	adds	r2, r3, #1
   28246:	607a      	str	r2, [r7, #4]
   28248:	781b      	ldrb	r3, [r3, #0]
   2824a:	b29a      	uxth	r2, r3
   2824c:	68bb      	ldr	r3, [r7, #8]
   2824e:	815a      	strh	r2, [r3, #10]

    HCI_TRACE_INFO1("HCI Per Adv report, data len: %d", pMsg->len);

    /* Copy data to space after end of report struct */
    pMsg->pData = (uint8_t *)(pMsg + 1);
   28250:	68bb      	ldr	r3, [r7, #8]
   28252:	f103 0210 	add.w	r2, r3, #16
   28256:	68bb      	ldr	r3, [r7, #8]
   28258:	60da      	str	r2, [r3, #12]
    memcpy(pMsg->pData, p, pMsg->len);
   2825a:	68bb      	ldr	r3, [r7, #8]
   2825c:	68d8      	ldr	r0, [r3, #12]
   2825e:	68bb      	ldr	r3, [r7, #8]
   28260:	895b      	ldrh	r3, [r3, #10]
   28262:	461a      	mov	r2, r3
   28264:	6879      	ldr	r1, [r7, #4]
   28266:	f7ef fff5 	bl	18254 <memcpy>

    /* initialize message header */
    pMsg->hdr.param = 0;
   2826a:	68bb      	ldr	r3, [r7, #8]
   2826c:	2200      	movs	r2, #0
   2826e:	801a      	strh	r2, [r3, #0]
    pMsg->hdr.event = HCI_LE_PER_ADV_REPORT_CBACK_EVT;
   28270:	68bb      	ldr	r3, [r7, #8]
   28272:	2231      	movs	r2, #49	; 0x31
   28274:	709a      	strb	r2, [r3, #2]
    pMsg->hdr.status = pMsg->status;
   28276:	68bb      	ldr	r3, [r7, #8]
   28278:	7a5a      	ldrb	r2, [r3, #9]
   2827a:	68bb      	ldr	r3, [r7, #8]
   2827c:	70da      	strb	r2, [r3, #3]

    /* execute callback */
    (*hciCb.evtCback)((hciEvt_t *)pMsg);
   2827e:	4b06      	ldr	r3, [pc, #24]	; (28298 <hciEvtProcessLePerAdvReport+0xd4>)
   28280:	689b      	ldr	r3, [r3, #8]
   28282:	68b8      	ldr	r0, [r7, #8]
   28284:	4798      	blx	r3

    /* free buffer */
    WsfBufFree(pMsg);
   28286:	68b8      	ldr	r0, [r7, #8]
   28288:	f004 fec2 	bl	2d010 <WsfBufFree>
   2828c:	e000      	b.n	28290 <hciEvtProcessLePerAdvReport+0xcc>
    return;
   2828e:	bf00      	nop
  }
}
   28290:	3710      	adds	r7, #16
   28292:	46bd      	mov	sp, r7
   28294:	bd80      	pop	{r7, pc}
   28296:	bf00      	nop
   28298:	100116ec 	.word	0x100116ec

0002829c <hciEvtParseLeCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeCmdCmpl(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2829c:	b480      	push	{r7}
   2829e:	b085      	sub	sp, #20
   282a0:	af00      	add	r7, sp, #0
   282a2:	60f8      	str	r0, [r7, #12]
   282a4:	60b9      	str	r1, [r7, #8]
   282a6:	4613      	mov	r3, r2
   282a8:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT8(pMsg->hdr.status, p);
   282aa:	68bb      	ldr	r3, [r7, #8]
   282ac:	1c5a      	adds	r2, r3, #1
   282ae:	60ba      	str	r2, [r7, #8]
   282b0:	781a      	ldrb	r2, [r3, #0]
   282b2:	68fb      	ldr	r3, [r7, #12]
   282b4:	70da      	strb	r2, [r3, #3]
}
   282b6:	bf00      	nop
   282b8:	3714      	adds	r7, #20
   282ba:	46bd      	mov	sp, r7
   282bc:	f85d 7b04 	ldr.w	r7, [sp], #4
   282c0:	4770      	bx	lr
	...

000282c4 <hciEvtProcessLeConnIQReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLeConnIQReport(uint8_t *p, uint8_t len)
{
   282c4:	b580      	push	{r7, lr}
   282c6:	b084      	sub	sp, #16
   282c8:	af00      	add	r7, sp, #0
   282ca:	6078      	str	r0, [r7, #4]
   282cc:	460b      	mov	r3, r1
   282ce:	70fb      	strb	r3, [r7, #3]
    hciLeConnIQReportEvt_t *pMsg;
    APP_TRACE_INFO0("hciEvtProcessLeConnIQReport");
   282d0:	484f      	ldr	r0, [pc, #316]	; (28410 <hciEvtProcessLeConnIQReport+0x14c>)
   282d2:	f005 fb5d 	bl	2d990 <WsfTrace>

    if ((pMsg = WsfBufAlloc(sizeof(hciLeConnIQReportEvt_t) + HCI_IQ_RPT_SAMPLE_CNT_MAX*2)) != NULL)
   282d6:	20c0      	movs	r0, #192	; 0xc0
   282d8:	f004 fe5a 	bl	2cf90 <WsfBufAlloc>
   282dc:	60f8      	str	r0, [r7, #12]
   282de:	68fb      	ldr	r3, [r7, #12]
   282e0:	2b00      	cmp	r3, #0
   282e2:	f000 8091 	beq.w	28408 <hciEvtProcessLeConnIQReport+0x144>
    {
        APP_TRACE_INFO0("rcv Le ConnIQ Report...");
   282e6:	484b      	ldr	r0, [pc, #300]	; (28414 <hciEvtProcessLeConnIQReport+0x150>)
   282e8:	f005 fb52 	bl	2d990 <WsfTrace>
        BSTREAM_TO_UINT16(pMsg->handle, p);
   282ec:	687b      	ldr	r3, [r7, #4]
   282ee:	781b      	ldrb	r3, [r3, #0]
   282f0:	b29a      	uxth	r2, r3
   282f2:	687b      	ldr	r3, [r7, #4]
   282f4:	3301      	adds	r3, #1
   282f6:	781b      	ldrb	r3, [r3, #0]
   282f8:	b29b      	uxth	r3, r3
   282fa:	021b      	lsls	r3, r3, #8
   282fc:	b29b      	uxth	r3, r3
   282fe:	4413      	add	r3, r2
   28300:	b29a      	uxth	r2, r3
   28302:	68fb      	ldr	r3, [r7, #12]
   28304:	809a      	strh	r2, [r3, #4]
   28306:	687b      	ldr	r3, [r7, #4]
   28308:	3302      	adds	r3, #2
   2830a:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->rxPhy, p);
   2830c:	687b      	ldr	r3, [r7, #4]
   2830e:	1c5a      	adds	r2, r3, #1
   28310:	607a      	str	r2, [r7, #4]
   28312:	781a      	ldrb	r2, [r3, #0]
   28314:	68fb      	ldr	r3, [r7, #12]
   28316:	719a      	strb	r2, [r3, #6]
        BSTREAM_TO_UINT8(pMsg->dataChIdx, p);
   28318:	687b      	ldr	r3, [r7, #4]
   2831a:	1c5a      	adds	r2, r3, #1
   2831c:	607a      	str	r2, [r7, #4]
   2831e:	781a      	ldrb	r2, [r3, #0]
   28320:	68fb      	ldr	r3, [r7, #12]
   28322:	71da      	strb	r2, [r3, #7]
        BSTREAM_TO_UINT16(pMsg->rssi, p);
   28324:	687b      	ldr	r3, [r7, #4]
   28326:	781b      	ldrb	r3, [r3, #0]
   28328:	b29a      	uxth	r2, r3
   2832a:	687b      	ldr	r3, [r7, #4]
   2832c:	3301      	adds	r3, #1
   2832e:	781b      	ldrb	r3, [r3, #0]
   28330:	b29b      	uxth	r3, r3
   28332:	021b      	lsls	r3, r3, #8
   28334:	b29b      	uxth	r3, r3
   28336:	4413      	add	r3, r2
   28338:	b29b      	uxth	r3, r3
   2833a:	b21a      	sxth	r2, r3
   2833c:	68fb      	ldr	r3, [r7, #12]
   2833e:	811a      	strh	r2, [r3, #8]
   28340:	687b      	ldr	r3, [r7, #4]
   28342:	3302      	adds	r3, #2
   28344:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->rssiAntennaId, p);
   28346:	687b      	ldr	r3, [r7, #4]
   28348:	1c5a      	adds	r2, r3, #1
   2834a:	607a      	str	r2, [r7, #4]
   2834c:	781a      	ldrb	r2, [r3, #0]
   2834e:	68fb      	ldr	r3, [r7, #12]
   28350:	729a      	strb	r2, [r3, #10]
        BSTREAM_TO_UINT8(pMsg->cteType, p);
   28352:	687b      	ldr	r3, [r7, #4]
   28354:	1c5a      	adds	r2, r3, #1
   28356:	607a      	str	r2, [r7, #4]
   28358:	781a      	ldrb	r2, [r3, #0]
   2835a:	68fb      	ldr	r3, [r7, #12]
   2835c:	72da      	strb	r2, [r3, #11]
        BSTREAM_TO_UINT8(pMsg->slotDurations, p);
   2835e:	687b      	ldr	r3, [r7, #4]
   28360:	1c5a      	adds	r2, r3, #1
   28362:	607a      	str	r2, [r7, #4]
   28364:	781a      	ldrb	r2, [r3, #0]
   28366:	68fb      	ldr	r3, [r7, #12]
   28368:	731a      	strb	r2, [r3, #12]
        BSTREAM_TO_UINT8(pMsg->pktStatus, p);
   2836a:	687b      	ldr	r3, [r7, #4]
   2836c:	1c5a      	adds	r2, r3, #1
   2836e:	607a      	str	r2, [r7, #4]
   28370:	781a      	ldrb	r2, [r3, #0]
   28372:	68fb      	ldr	r3, [r7, #12]
   28374:	735a      	strb	r2, [r3, #13]
        BSTREAM_TO_UINT16(pMsg->connEvtCnt, p);
   28376:	687b      	ldr	r3, [r7, #4]
   28378:	781b      	ldrb	r3, [r3, #0]
   2837a:	b29a      	uxth	r2, r3
   2837c:	687b      	ldr	r3, [r7, #4]
   2837e:	3301      	adds	r3, #1
   28380:	781b      	ldrb	r3, [r3, #0]
   28382:	b29b      	uxth	r3, r3
   28384:	021b      	lsls	r3, r3, #8
   28386:	b29b      	uxth	r3, r3
   28388:	4413      	add	r3, r2
   2838a:	b29a      	uxth	r2, r3
   2838c:	68fb      	ldr	r3, [r7, #12]
   2838e:	81da      	strh	r2, [r3, #14]
   28390:	687b      	ldr	r3, [r7, #4]
   28392:	3302      	adds	r3, #2
   28394:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->sampleCnt, p);
   28396:	687b      	ldr	r3, [r7, #4]
   28398:	1c5a      	adds	r2, r3, #1
   2839a:	607a      	str	r2, [r7, #4]
   2839c:	781a      	ldrb	r2, [r3, #0]
   2839e:	68fb      	ldr	r3, [r7, #12]
   283a0:	741a      	strb	r2, [r3, #16]

        /* Copy IQ sample data to space after end of report struct */
        pMsg->pISample = (int8_t *) (pMsg + 1);
   283a2:	68fb      	ldr	r3, [r7, #12]
   283a4:	f103 021c 	add.w	r2, r3, #28
   283a8:	68fb      	ldr	r3, [r7, #12]
   283aa:	615a      	str	r2, [r3, #20]
        memcpy(pMsg->pISample, p, pMsg->sampleCnt);
   283ac:	68fb      	ldr	r3, [r7, #12]
   283ae:	6958      	ldr	r0, [r3, #20]
   283b0:	68fb      	ldr	r3, [r7, #12]
   283b2:	7c1b      	ldrb	r3, [r3, #16]
   283b4:	461a      	mov	r2, r3
   283b6:	6879      	ldr	r1, [r7, #4]
   283b8:	f7ef ff4c 	bl	18254 <memcpy>
        p += pMsg->sampleCnt;
   283bc:	68fb      	ldr	r3, [r7, #12]
   283be:	7c1b      	ldrb	r3, [r3, #16]
   283c0:	461a      	mov	r2, r3
   283c2:	687b      	ldr	r3, [r7, #4]
   283c4:	4413      	add	r3, r2
   283c6:	607b      	str	r3, [r7, #4]

        pMsg->pQSample = (int8_t *) (pMsg + 1)+HCI_IQ_RPT_SAMPLE_CNT_MAX;
   283c8:	68fb      	ldr	r3, [r7, #12]
   283ca:	331c      	adds	r3, #28
   283cc:	f103 0252 	add.w	r2, r3, #82	; 0x52
   283d0:	68fb      	ldr	r3, [r7, #12]
   283d2:	619a      	str	r2, [r3, #24]
        memcpy(pMsg->pISample, p, pMsg->sampleCnt);
   283d4:	68fb      	ldr	r3, [r7, #12]
   283d6:	6958      	ldr	r0, [r3, #20]
   283d8:	68fb      	ldr	r3, [r7, #12]
   283da:	7c1b      	ldrb	r3, [r3, #16]
   283dc:	461a      	mov	r2, r3
   283de:	6879      	ldr	r1, [r7, #4]
   283e0:	f7ef ff38 	bl	18254 <memcpy>

        pMsg->hdr.param = pMsg->handle;
   283e4:	68fb      	ldr	r3, [r7, #12]
   283e6:	889a      	ldrh	r2, [r3, #4]
   283e8:	68fb      	ldr	r3, [r7, #12]
   283ea:	801a      	strh	r2, [r3, #0]
        pMsg->hdr.status = pMsg->pktStatus;
   283ec:	68fb      	ldr	r3, [r7, #12]
   283ee:	7b5a      	ldrb	r2, [r3, #13]
   283f0:	68fb      	ldr	r3, [r7, #12]
   283f2:	70da      	strb	r2, [r3, #3]
        pMsg->hdr.event = HCI_LE_CONN_IQ_REPORT_CBACK_EVT;
   283f4:	68fb      	ldr	r3, [r7, #12]
   283f6:	223d      	movs	r2, #61	; 0x3d
   283f8:	709a      	strb	r2, [r3, #2]

        /* execute callback */
        (*hciCb.evtCback)((hciEvt_t *) pMsg);
   283fa:	4b07      	ldr	r3, [pc, #28]	; (28418 <hciEvtProcessLeConnIQReport+0x154>)
   283fc:	689b      	ldr	r3, [r3, #8]
   283fe:	68f8      	ldr	r0, [r7, #12]
   28400:	4798      	blx	r3

        /* free buffer */
        WsfBufFree(pMsg);
   28402:	68f8      	ldr	r0, [r7, #12]
   28404:	f004 fe04 	bl	2d010 <WsfBufFree>
    }
}
   28408:	bf00      	nop
   2840a:	3710      	adds	r7, #16
   2840c:	46bd      	mov	sp, r7
   2840e:	bd80      	pop	{r7, pc}
   28410:	00045058 	.word	0x00045058
   28414:	00045074 	.word	0x00045074
   28418:	100116ec 	.word	0x100116ec

0002841c <hciEvtProcessLeConlessIQReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLeConlessIQReport(uint8_t *p, uint8_t len)
{
   2841c:	b580      	push	{r7, lr}
   2841e:	b084      	sub	sp, #16
   28420:	af00      	add	r7, sp, #0
   28422:	6078      	str	r0, [r7, #4]
   28424:	460b      	mov	r3, r1
   28426:	70fb      	strb	r3, [r7, #3]
    hciLeConlessIQReportEvt_t *pMsg;

    if ((pMsg = WsfBufAlloc(sizeof(hciLeConlessIQReportEvt_t) + HCI_IQ_RPT_SAMPLE_CNT_MAX*2)) != NULL)
   28428:	20c0      	movs	r0, #192	; 0xc0
   2842a:	f004 fdb1 	bl	2cf90 <WsfBufAlloc>
   2842e:	60f8      	str	r0, [r7, #12]
   28430:	68fb      	ldr	r3, [r7, #12]
   28432:	2b00      	cmp	r3, #0
   28434:	f000 808b 	beq.w	2854e <hciEvtProcessLeConlessIQReport+0x132>
    {
        APP_TRACE_INFO0("rcv Le Conntless IQ Report...");
   28438:	4847      	ldr	r0, [pc, #284]	; (28558 <hciEvtProcessLeConlessIQReport+0x13c>)
   2843a:	f005 faa9 	bl	2d990 <WsfTrace>
        BSTREAM_TO_UINT16(pMsg->synHdl, p);
   2843e:	687b      	ldr	r3, [r7, #4]
   28440:	781b      	ldrb	r3, [r3, #0]
   28442:	b29a      	uxth	r2, r3
   28444:	687b      	ldr	r3, [r7, #4]
   28446:	3301      	adds	r3, #1
   28448:	781b      	ldrb	r3, [r3, #0]
   2844a:	b29b      	uxth	r3, r3
   2844c:	021b      	lsls	r3, r3, #8
   2844e:	b29b      	uxth	r3, r3
   28450:	4413      	add	r3, r2
   28452:	b29a      	uxth	r2, r3
   28454:	68fb      	ldr	r3, [r7, #12]
   28456:	809a      	strh	r2, [r3, #4]
   28458:	687b      	ldr	r3, [r7, #4]
   2845a:	3302      	adds	r3, #2
   2845c:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->chIdx, p);
   2845e:	687b      	ldr	r3, [r7, #4]
   28460:	1c5a      	adds	r2, r3, #1
   28462:	607a      	str	r2, [r7, #4]
   28464:	781a      	ldrb	r2, [r3, #0]
   28466:	68fb      	ldr	r3, [r7, #12]
   28468:	719a      	strb	r2, [r3, #6]
        BSTREAM_TO_UINT16(pMsg->rssi, p);
   2846a:	687b      	ldr	r3, [r7, #4]
   2846c:	781b      	ldrb	r3, [r3, #0]
   2846e:	b29a      	uxth	r2, r3
   28470:	687b      	ldr	r3, [r7, #4]
   28472:	3301      	adds	r3, #1
   28474:	781b      	ldrb	r3, [r3, #0]
   28476:	b29b      	uxth	r3, r3
   28478:	021b      	lsls	r3, r3, #8
   2847a:	b29b      	uxth	r3, r3
   2847c:	4413      	add	r3, r2
   2847e:	b29b      	uxth	r3, r3
   28480:	b21a      	sxth	r2, r3
   28482:	68fb      	ldr	r3, [r7, #12]
   28484:	811a      	strh	r2, [r3, #8]
   28486:	687b      	ldr	r3, [r7, #4]
   28488:	3302      	adds	r3, #2
   2848a:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->rssiAntennaId, p);
   2848c:	687b      	ldr	r3, [r7, #4]
   2848e:	1c5a      	adds	r2, r3, #1
   28490:	607a      	str	r2, [r7, #4]
   28492:	781a      	ldrb	r2, [r3, #0]
   28494:	68fb      	ldr	r3, [r7, #12]
   28496:	729a      	strb	r2, [r3, #10]
        BSTREAM_TO_UINT8(pMsg->cteType, p);
   28498:	687b      	ldr	r3, [r7, #4]
   2849a:	1c5a      	adds	r2, r3, #1
   2849c:	607a      	str	r2, [r7, #4]
   2849e:	781a      	ldrb	r2, [r3, #0]
   284a0:	68fb      	ldr	r3, [r7, #12]
   284a2:	72da      	strb	r2, [r3, #11]
        BSTREAM_TO_UINT8(pMsg->slotDurations, p);
   284a4:	687b      	ldr	r3, [r7, #4]
   284a6:	1c5a      	adds	r2, r3, #1
   284a8:	607a      	str	r2, [r7, #4]
   284aa:	781a      	ldrb	r2, [r3, #0]
   284ac:	68fb      	ldr	r3, [r7, #12]
   284ae:	731a      	strb	r2, [r3, #12]
        BSTREAM_TO_UINT8(pMsg->pktStatus, p);
   284b0:	687b      	ldr	r3, [r7, #4]
   284b2:	1c5a      	adds	r2, r3, #1
   284b4:	607a      	str	r2, [r7, #4]
   284b6:	781a      	ldrb	r2, [r3, #0]
   284b8:	68fb      	ldr	r3, [r7, #12]
   284ba:	735a      	strb	r2, [r3, #13]
        BSTREAM_TO_UINT16(pMsg->paEvtCnt, p);
   284bc:	687b      	ldr	r3, [r7, #4]
   284be:	781b      	ldrb	r3, [r3, #0]
   284c0:	b29a      	uxth	r2, r3
   284c2:	687b      	ldr	r3, [r7, #4]
   284c4:	3301      	adds	r3, #1
   284c6:	781b      	ldrb	r3, [r3, #0]
   284c8:	b29b      	uxth	r3, r3
   284ca:	021b      	lsls	r3, r3, #8
   284cc:	b29b      	uxth	r3, r3
   284ce:	4413      	add	r3, r2
   284d0:	b29a      	uxth	r2, r3
   284d2:	68fb      	ldr	r3, [r7, #12]
   284d4:	81da      	strh	r2, [r3, #14]
   284d6:	687b      	ldr	r3, [r7, #4]
   284d8:	3302      	adds	r3, #2
   284da:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(pMsg->sampleCnt, p);
   284dc:	687b      	ldr	r3, [r7, #4]
   284de:	1c5a      	adds	r2, r3, #1
   284e0:	607a      	str	r2, [r7, #4]
   284e2:	781a      	ldrb	r2, [r3, #0]
   284e4:	68fb      	ldr	r3, [r7, #12]
   284e6:	741a      	strb	r2, [r3, #16]

        /* Copy IQ sample data to space after end of report struct */
        pMsg->pISample = (int8_t *) (pMsg + 1);
   284e8:	68fb      	ldr	r3, [r7, #12]
   284ea:	f103 021c 	add.w	r2, r3, #28
   284ee:	68fb      	ldr	r3, [r7, #12]
   284f0:	615a      	str	r2, [r3, #20]
        memcpy(pMsg->pISample, p, pMsg->sampleCnt);
   284f2:	68fb      	ldr	r3, [r7, #12]
   284f4:	6958      	ldr	r0, [r3, #20]
   284f6:	68fb      	ldr	r3, [r7, #12]
   284f8:	7c1b      	ldrb	r3, [r3, #16]
   284fa:	461a      	mov	r2, r3
   284fc:	6879      	ldr	r1, [r7, #4]
   284fe:	f7ef fea9 	bl	18254 <memcpy>
        p += pMsg->sampleCnt;
   28502:	68fb      	ldr	r3, [r7, #12]
   28504:	7c1b      	ldrb	r3, [r3, #16]
   28506:	461a      	mov	r2, r3
   28508:	687b      	ldr	r3, [r7, #4]
   2850a:	4413      	add	r3, r2
   2850c:	607b      	str	r3, [r7, #4]

        pMsg->pQSample = (int8_t *) (pMsg + 1)+HCI_IQ_RPT_SAMPLE_CNT_MAX;
   2850e:	68fb      	ldr	r3, [r7, #12]
   28510:	331c      	adds	r3, #28
   28512:	f103 0252 	add.w	r2, r3, #82	; 0x52
   28516:	68fb      	ldr	r3, [r7, #12]
   28518:	619a      	str	r2, [r3, #24]
        memcpy(pMsg->pISample, p, pMsg->sampleCnt);
   2851a:	68fb      	ldr	r3, [r7, #12]
   2851c:	6958      	ldr	r0, [r3, #20]
   2851e:	68fb      	ldr	r3, [r7, #12]
   28520:	7c1b      	ldrb	r3, [r3, #16]
   28522:	461a      	mov	r2, r3
   28524:	6879      	ldr	r1, [r7, #4]
   28526:	f7ef fe95 	bl	18254 <memcpy>

        pMsg->hdr.param = pMsg->synHdl;
   2852a:	68fb      	ldr	r3, [r7, #12]
   2852c:	889a      	ldrh	r2, [r3, #4]
   2852e:	68fb      	ldr	r3, [r7, #12]
   28530:	801a      	strh	r2, [r3, #0]
        pMsg->hdr.status = pMsg->pktStatus;
   28532:	68fb      	ldr	r3, [r7, #12]
   28534:	7b5a      	ldrb	r2, [r3, #13]
   28536:	68fb      	ldr	r3, [r7, #12]
   28538:	70da      	strb	r2, [r3, #3]
        pMsg->hdr.event = HCI_LE_CONNLESS_IQ_REPORT_CBACK_EVT;
   2853a:	68fb      	ldr	r3, [r7, #12]
   2853c:	2247      	movs	r2, #71	; 0x47
   2853e:	709a      	strb	r2, [r3, #2]

        /* execute callback */
        (*hciCb.evtCback)((hciEvt_t *) pMsg);
   28540:	4b06      	ldr	r3, [pc, #24]	; (2855c <hciEvtProcessLeConlessIQReport+0x140>)
   28542:	689b      	ldr	r3, [r3, #8]
   28544:	68f8      	ldr	r0, [r7, #12]
   28546:	4798      	blx	r3

        /* free buffer */
        WsfBufFree(pMsg);
   28548:	68f8      	ldr	r0, [r7, #12]
   2854a:	f004 fd61 	bl	2d010 <WsfBufFree>
    }
}
   2854e:	bf00      	nop
   28550:	3710      	adds	r7, #16
   28552:	46bd      	mov	sp, r7
   28554:	bd80      	pop	{r7, pc}
   28556:	bf00      	nop
   28558:	0004508c 	.word	0x0004508c
   2855c:	100116ec 	.word	0x100116ec

00028560 <hciEvtParseLeSetConnCteRcvParm>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeSetConnCteRcvParm(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   28560:	b480      	push	{r7}
   28562:	b085      	sub	sp, #20
   28564:	af00      	add	r7, sp, #0
   28566:	60f8      	str	r0, [r7, #12]
   28568:	60b9      	str	r1, [r7, #8]
   2856a:	4613      	mov	r3, r2
   2856c:	71fb      	strb	r3, [r7, #7]
    BSTREAM_TO_UINT8(pMsg->leSetConnCteRxParamsCmdCmpl.status, p);
   2856e:	68bb      	ldr	r3, [r7, #8]
   28570:	1c5a      	adds	r2, r3, #1
   28572:	60ba      	str	r2, [r7, #8]
   28574:	781a      	ldrb	r2, [r3, #0]
   28576:	68fb      	ldr	r3, [r7, #12]
   28578:	711a      	strb	r2, [r3, #4]
    BSTREAM_TO_UINT16(pMsg->leSetConnCteRxParamsCmdCmpl.handle, p);
   2857a:	68bb      	ldr	r3, [r7, #8]
   2857c:	781b      	ldrb	r3, [r3, #0]
   2857e:	b29a      	uxth	r2, r3
   28580:	68bb      	ldr	r3, [r7, #8]
   28582:	3301      	adds	r3, #1
   28584:	781b      	ldrb	r3, [r3, #0]
   28586:	b29b      	uxth	r3, r3
   28588:	021b      	lsls	r3, r3, #8
   2858a:	b29b      	uxth	r3, r3
   2858c:	4413      	add	r3, r2
   2858e:	b29a      	uxth	r2, r3
   28590:	68fb      	ldr	r3, [r7, #12]
   28592:	80da      	strh	r2, [r3, #6]
   28594:	68bb      	ldr	r3, [r7, #8]
   28596:	3302      	adds	r3, #2
   28598:	60bb      	str	r3, [r7, #8]

    pMsg->hdr.status = pMsg->leSetConnCteRxParamsCmdCmpl.status;
   2859a:	68fb      	ldr	r3, [r7, #12]
   2859c:	791a      	ldrb	r2, [r3, #4]
   2859e:	68fb      	ldr	r3, [r7, #12]
   285a0:	70da      	strb	r2, [r3, #3]
    pMsg->hdr.param = pMsg->leSetConnCteRxParamsCmdCmpl.handle;
   285a2:	68fb      	ldr	r3, [r7, #12]
   285a4:	88da      	ldrh	r2, [r3, #6]
   285a6:	68fb      	ldr	r3, [r7, #12]
   285a8:	801a      	strh	r2, [r3, #0]
}
   285aa:	bf00      	nop
   285ac:	3714      	adds	r7, #20
   285ae:	46bd      	mov	sp, r7
   285b0:	f85d 7b04 	ldr.w	r7, [sp], #4
   285b4:	4770      	bx	lr

000285b6 <hciEvtParseLeSetConnCteTxParm>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeSetConnCteTxParm(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   285b6:	b480      	push	{r7}
   285b8:	b085      	sub	sp, #20
   285ba:	af00      	add	r7, sp, #0
   285bc:	60f8      	str	r0, [r7, #12]
   285be:	60b9      	str	r1, [r7, #8]
   285c0:	4613      	mov	r3, r2
   285c2:	71fb      	strb	r3, [r7, #7]
    BSTREAM_TO_UINT8(pMsg->leSetConnCteTxParamsCmdCmpl.status, p);
   285c4:	68bb      	ldr	r3, [r7, #8]
   285c6:	1c5a      	adds	r2, r3, #1
   285c8:	60ba      	str	r2, [r7, #8]
   285ca:	781a      	ldrb	r2, [r3, #0]
   285cc:	68fb      	ldr	r3, [r7, #12]
   285ce:	711a      	strb	r2, [r3, #4]
    BSTREAM_TO_UINT16(pMsg->leSetConnCteTxParamsCmdCmpl.handle, p);
   285d0:	68bb      	ldr	r3, [r7, #8]
   285d2:	781b      	ldrb	r3, [r3, #0]
   285d4:	b29a      	uxth	r2, r3
   285d6:	68bb      	ldr	r3, [r7, #8]
   285d8:	3301      	adds	r3, #1
   285da:	781b      	ldrb	r3, [r3, #0]
   285dc:	b29b      	uxth	r3, r3
   285de:	021b      	lsls	r3, r3, #8
   285e0:	b29b      	uxth	r3, r3
   285e2:	4413      	add	r3, r2
   285e4:	b29a      	uxth	r2, r3
   285e6:	68fb      	ldr	r3, [r7, #12]
   285e8:	80da      	strh	r2, [r3, #6]
   285ea:	68bb      	ldr	r3, [r7, #8]
   285ec:	3302      	adds	r3, #2
   285ee:	60bb      	str	r3, [r7, #8]

    pMsg->hdr.status = pMsg->leSetConnCteTxParamsCmdCmpl.status;
   285f0:	68fb      	ldr	r3, [r7, #12]
   285f2:	791a      	ldrb	r2, [r3, #4]
   285f4:	68fb      	ldr	r3, [r7, #12]
   285f6:	70da      	strb	r2, [r3, #3]
    pMsg->hdr.param = pMsg->leSetConnCteTxParamsCmdCmpl.handle;
   285f8:	68fb      	ldr	r3, [r7, #12]
   285fa:	88da      	ldrh	r2, [r3, #6]
   285fc:	68fb      	ldr	r3, [r7, #12]
   285fe:	801a      	strh	r2, [r3, #0]
}
   28600:	bf00      	nop
   28602:	3714      	adds	r7, #20
   28604:	46bd      	mov	sp, r7
   28606:	f85d 7b04 	ldr.w	r7, [sp], #4
   2860a:	4770      	bx	lr

0002860c <hciEvtParseLeConnCteReqEn>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeConnCteReqEn(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   2860c:	b480      	push	{r7}
   2860e:	b085      	sub	sp, #20
   28610:	af00      	add	r7, sp, #0
   28612:	60f8      	str	r0, [r7, #12]
   28614:	60b9      	str	r1, [r7, #8]
   28616:	4613      	mov	r3, r2
   28618:	71fb      	strb	r3, [r7, #7]
    BSTREAM_TO_UINT8(pMsg->leConnCteReqEnableCmdCmpl.status, p);
   2861a:	68bb      	ldr	r3, [r7, #8]
   2861c:	1c5a      	adds	r2, r3, #1
   2861e:	60ba      	str	r2, [r7, #8]
   28620:	781a      	ldrb	r2, [r3, #0]
   28622:	68fb      	ldr	r3, [r7, #12]
   28624:	711a      	strb	r2, [r3, #4]
    BSTREAM_TO_UINT16(pMsg->leConnCteReqEnableCmdCmpl.handle, p);
   28626:	68bb      	ldr	r3, [r7, #8]
   28628:	781b      	ldrb	r3, [r3, #0]
   2862a:	b29a      	uxth	r2, r3
   2862c:	68bb      	ldr	r3, [r7, #8]
   2862e:	3301      	adds	r3, #1
   28630:	781b      	ldrb	r3, [r3, #0]
   28632:	b29b      	uxth	r3, r3
   28634:	021b      	lsls	r3, r3, #8
   28636:	b29b      	uxth	r3, r3
   28638:	4413      	add	r3, r2
   2863a:	b29a      	uxth	r2, r3
   2863c:	68fb      	ldr	r3, [r7, #12]
   2863e:	80da      	strh	r2, [r3, #6]
   28640:	68bb      	ldr	r3, [r7, #8]
   28642:	3302      	adds	r3, #2
   28644:	60bb      	str	r3, [r7, #8]

    pMsg->hdr.status = pMsg->leConnCteReqEnableCmdCmpl.status;
   28646:	68fb      	ldr	r3, [r7, #12]
   28648:	791a      	ldrb	r2, [r3, #4]
   2864a:	68fb      	ldr	r3, [r7, #12]
   2864c:	70da      	strb	r2, [r3, #3]
    pMsg->hdr.param = pMsg->leConnCteReqEnableCmdCmpl.handle;
   2864e:	68fb      	ldr	r3, [r7, #12]
   28650:	88da      	ldrh	r2, [r3, #6]
   28652:	68fb      	ldr	r3, [r7, #12]
   28654:	801a      	strh	r2, [r3, #0]
}
   28656:	bf00      	nop
   28658:	3714      	adds	r7, #20
   2865a:	46bd      	mov	sp, r7
   2865c:	f85d 7b04 	ldr.w	r7, [sp], #4
   28660:	4770      	bx	lr

00028662 <hciEvtParseLeConnCteRspEn>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLeConnCteRspEn(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   28662:	b480      	push	{r7}
   28664:	b085      	sub	sp, #20
   28666:	af00      	add	r7, sp, #0
   28668:	60f8      	str	r0, [r7, #12]
   2866a:	60b9      	str	r1, [r7, #8]
   2866c:	4613      	mov	r3, r2
   2866e:	71fb      	strb	r3, [r7, #7]
    BSTREAM_TO_UINT8(pMsg->leConnCteRspEnableCmdCmpl.status, p);
   28670:	68bb      	ldr	r3, [r7, #8]
   28672:	1c5a      	adds	r2, r3, #1
   28674:	60ba      	str	r2, [r7, #8]
   28676:	781a      	ldrb	r2, [r3, #0]
   28678:	68fb      	ldr	r3, [r7, #12]
   2867a:	711a      	strb	r2, [r3, #4]
    BSTREAM_TO_UINT16(pMsg->leConnCteRspEnableCmdCmpl.handle, p);
   2867c:	68bb      	ldr	r3, [r7, #8]
   2867e:	781b      	ldrb	r3, [r3, #0]
   28680:	b29a      	uxth	r2, r3
   28682:	68bb      	ldr	r3, [r7, #8]
   28684:	3301      	adds	r3, #1
   28686:	781b      	ldrb	r3, [r3, #0]
   28688:	b29b      	uxth	r3, r3
   2868a:	021b      	lsls	r3, r3, #8
   2868c:	b29b      	uxth	r3, r3
   2868e:	4413      	add	r3, r2
   28690:	b29a      	uxth	r2, r3
   28692:	68fb      	ldr	r3, [r7, #12]
   28694:	80da      	strh	r2, [r3, #6]
   28696:	68bb      	ldr	r3, [r7, #8]
   28698:	3302      	adds	r3, #2
   2869a:	60bb      	str	r3, [r7, #8]

    pMsg->hdr.status = pMsg->leConnCteRspEnableCmdCmpl.status;
   2869c:	68fb      	ldr	r3, [r7, #12]
   2869e:	791a      	ldrb	r2, [r3, #4]
   286a0:	68fb      	ldr	r3, [r7, #12]
   286a2:	70da      	strb	r2, [r3, #3]
    pMsg->hdr.param = pMsg->leConnCteRspEnableCmdCmpl.handle;
   286a4:	68fb      	ldr	r3, [r7, #12]
   286a6:	88da      	ldrh	r2, [r3, #6]
   286a8:	68fb      	ldr	r3, [r7, #12]
   286aa:	801a      	strh	r2, [r3, #0]
}
   286ac:	bf00      	nop
   286ae:	3714      	adds	r7, #20
   286b0:	46bd      	mov	sp, r7
   286b2:	f85d 7b04 	ldr.w	r7, [sp], #4
   286b6:	4770      	bx	lr

000286b8 <hciEvtParseLePerAdvSyncLost>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtParseLePerAdvSyncLost(hciEvt_t *pMsg, uint8_t *p, uint8_t len)
{
   286b8:	b480      	push	{r7}
   286ba:	b085      	sub	sp, #20
   286bc:	af00      	add	r7, sp, #0
   286be:	60f8      	str	r0, [r7, #12]
   286c0:	60b9      	str	r1, [r7, #8]
   286c2:	4613      	mov	r3, r2
   286c4:	71fb      	strb	r3, [r7, #7]
  BSTREAM_TO_UINT16(pMsg->lePerAdvSyncLost.syncHandle, p);
   286c6:	68bb      	ldr	r3, [r7, #8]
   286c8:	781b      	ldrb	r3, [r3, #0]
   286ca:	b29a      	uxth	r2, r3
   286cc:	68bb      	ldr	r3, [r7, #8]
   286ce:	3301      	adds	r3, #1
   286d0:	781b      	ldrb	r3, [r3, #0]
   286d2:	b29b      	uxth	r3, r3
   286d4:	021b      	lsls	r3, r3, #8
   286d6:	b29b      	uxth	r3, r3
   286d8:	4413      	add	r3, r2
   286da:	b29a      	uxth	r2, r3
   286dc:	68fb      	ldr	r3, [r7, #12]
   286de:	809a      	strh	r2, [r3, #4]
   286e0:	68bb      	ldr	r3, [r7, #8]
   286e2:	3302      	adds	r3, #2
   286e4:	60bb      	str	r3, [r7, #8]
}
   286e6:	bf00      	nop
   286e8:	3714      	adds	r7, #20
   286ea:	46bd      	mov	sp, r7
   286ec:	f85d 7b04 	ldr.w	r7, [sp], #4
   286f0:	4770      	bx	lr
	...

000286f4 <hciEvtProcessLeDirectAdvReport>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciEvtProcessLeDirectAdvReport(uint8_t *p, uint8_t len)
{
   286f4:	b580      	push	{r7, lr}
   286f6:	b084      	sub	sp, #16
   286f8:	af00      	add	r7, sp, #0
   286fa:	6078      	str	r0, [r7, #4]
   286fc:	460b      	mov	r3, r1
   286fe:	70fb      	strb	r3, [r7, #3]
  hciLeAdvReportEvt_t *pMsg;
  uint8_t             i;

  /* get number of reports */
  BSTREAM_TO_UINT8(i, p);
   28700:	687b      	ldr	r3, [r7, #4]
   28702:	1c5a      	adds	r2, r3, #1
   28704:	607a      	str	r2, [r7, #4]
   28706:	781b      	ldrb	r3, [r3, #0]
   28708:	73fb      	strb	r3, [r7, #15]

  HCI_TRACE_INFO1("HCI Adv report, num reports: %d", i);

  /* sanity check num reports */
  if (i > HCI_MAX_REPORTS)
   2870a:	7bfb      	ldrb	r3, [r7, #15]
   2870c:	2b0f      	cmp	r3, #15
   2870e:	d84e      	bhi.n	287ae <hciEvtProcessLeDirectAdvReport+0xba>
  {
    return;
  }

  /* allocate temp buffer that can hold max length adv/scan rsp data */
  if ((pMsg = WsfBufAlloc(sizeof(hciLeAdvReportEvt_t))) != NULL)
   28710:	201c      	movs	r0, #28
   28712:	f004 fc3d 	bl	2cf90 <WsfBufAlloc>
   28716:	60b8      	str	r0, [r7, #8]
   28718:	68bb      	ldr	r3, [r7, #8]
   2871a:	2b00      	cmp	r3, #0
   2871c:	d048      	beq.n	287b0 <hciEvtProcessLeDirectAdvReport+0xbc>
  {
    /* parse each report and execute callback */
    while (i-- > 0)
   2871e:	e03d      	b.n	2879c <hciEvtProcessLeDirectAdvReport+0xa8>
    {
      BSTREAM_TO_UINT8(pMsg->eventType, p);
   28720:	687b      	ldr	r3, [r7, #4]
   28722:	1c5a      	adds	r2, r3, #1
   28724:	607a      	str	r2, [r7, #4]
   28726:	781a      	ldrb	r2, [r3, #0]
   28728:	68bb      	ldr	r3, [r7, #8]
   2872a:	729a      	strb	r2, [r3, #10]
      BSTREAM_TO_UINT8(pMsg->addrType, p);
   2872c:	687b      	ldr	r3, [r7, #4]
   2872e:	1c5a      	adds	r2, r3, #1
   28730:	607a      	str	r2, [r7, #4]
   28732:	781a      	ldrb	r2, [r3, #0]
   28734:	68bb      	ldr	r3, [r7, #8]
   28736:	72da      	strb	r2, [r3, #11]
      BSTREAM_TO_BDA(pMsg->addr, p);
   28738:	68bb      	ldr	r3, [r7, #8]
   2873a:	330c      	adds	r3, #12
   2873c:	6879      	ldr	r1, [r7, #4]
   2873e:	4618      	mov	r0, r3
   28740:	f7f9 fa21 	bl	21b86 <BdaCpy>
   28744:	687b      	ldr	r3, [r7, #4]
   28746:	3306      	adds	r3, #6
   28748:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->directAddrType, p);
   2874a:	687b      	ldr	r3, [r7, #4]
   2874c:	1c5a      	adds	r2, r3, #1
   2874e:	607a      	str	r2, [r7, #4]
   28750:	781a      	ldrb	r2, [r3, #0]
   28752:	68bb      	ldr	r3, [r7, #8]
   28754:	749a      	strb	r2, [r3, #18]
      BSTREAM_TO_BDA(pMsg->directAddr, p);
   28756:	68bb      	ldr	r3, [r7, #8]
   28758:	3313      	adds	r3, #19
   2875a:	6879      	ldr	r1, [r7, #4]
   2875c:	4618      	mov	r0, r3
   2875e:	f7f9 fa12 	bl	21b86 <BdaCpy>
   28762:	687b      	ldr	r3, [r7, #4]
   28764:	3306      	adds	r3, #6
   28766:	607b      	str	r3, [r7, #4]
      BSTREAM_TO_UINT8(pMsg->rssi, p);
   28768:	687b      	ldr	r3, [r7, #4]
   2876a:	1c5a      	adds	r2, r3, #1
   2876c:	607a      	str	r2, [r7, #4]
   2876e:	781b      	ldrb	r3, [r3, #0]
   28770:	b25a      	sxtb	r2, r3
   28772:	68bb      	ldr	r3, [r7, #8]
   28774:	725a      	strb	r2, [r3, #9]

      /* zero out unused fields */
      pMsg->len = 0;
   28776:	68bb      	ldr	r3, [r7, #8]
   28778:	2200      	movs	r2, #0
   2877a:	721a      	strb	r2, [r3, #8]
      pMsg->pData = NULL;
   2877c:	68bb      	ldr	r3, [r7, #8]
   2877e:	2200      	movs	r2, #0
   28780:	605a      	str	r2, [r3, #4]

      /* initialize message header */
      pMsg->hdr.param = 0;
   28782:	68bb      	ldr	r3, [r7, #8]
   28784:	2200      	movs	r2, #0
   28786:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = HCI_LE_ADV_REPORT_CBACK_EVT;
   28788:	68bb      	ldr	r3, [r7, #8]
   2878a:	2206      	movs	r2, #6
   2878c:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = 0;
   2878e:	68bb      	ldr	r3, [r7, #8]
   28790:	2200      	movs	r2, #0
   28792:	70da      	strb	r2, [r3, #3]

      /* execute callback */
      (*hciCb.evtCback)((hciEvt_t *) pMsg);
   28794:	4b08      	ldr	r3, [pc, #32]	; (287b8 <hciEvtProcessLeDirectAdvReport+0xc4>)
   28796:	689b      	ldr	r3, [r3, #8]
   28798:	68b8      	ldr	r0, [r7, #8]
   2879a:	4798      	blx	r3
    while (i-- > 0)
   2879c:	7bfb      	ldrb	r3, [r7, #15]
   2879e:	1e5a      	subs	r2, r3, #1
   287a0:	73fa      	strb	r2, [r7, #15]
   287a2:	2b00      	cmp	r3, #0
   287a4:	d1bc      	bne.n	28720 <hciEvtProcessLeDirectAdvReport+0x2c>
    }

    /* free buffer */
    WsfBufFree(pMsg);
   287a6:	68b8      	ldr	r0, [r7, #8]
   287a8:	f004 fc32 	bl	2d010 <WsfBufFree>
   287ac:	e000      	b.n	287b0 <hciEvtProcessLeDirectAdvReport+0xbc>
    return;
   287ae:	bf00      	nop
  }
}
   287b0:	3710      	adds	r7, #16
   287b2:	46bd      	mov	sp, r7
   287b4:	bd80      	pop	{r7, pc}
   287b6:	bf00      	nop
   287b8:	100116ec 	.word	0x100116ec

000287bc <hciEvtCmdStatusFailure>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtCmdStatusFailure(uint8_t status, uint16_t opcode)
{
   287bc:	b580      	push	{r7, lr}
   287be:	b086      	sub	sp, #24
   287c0:	af00      	add	r7, sp, #0
   287c2:	4603      	mov	r3, r0
   287c4:	460a      	mov	r2, r1
   287c6:	71fb      	strb	r3, [r7, #7]
   287c8:	4613      	mov	r3, r2
   287ca:	80bb      	strh	r3, [r7, #4]
  HCI_OPCODE_LE_READ_REMOTE_FEAT
  HCI_OPCODE_LE_START_ENCRYPTION
  HCI_OPCODE_READ_REMOTE_VER_INFO
#endif

  if((opcode == HCI_OPCODE_LE_GENERATE_DHKEY)&&(status==HCI_ERR_INVALID_PARAM))
   287cc:	88bb      	ldrh	r3, [r7, #4]
   287ce:	f242 0226 	movw	r2, #8230	; 0x2026
   287d2:	4293      	cmp	r3, r2
   287d4:	d11f      	bne.n	28816 <hciEvtCmdStatusFailure+0x5a>
   287d6:	79fb      	ldrb	r3, [r7, #7]
   287d8:	2b12      	cmp	r3, #18
   287da:	d11c      	bne.n	28816 <hciEvtCmdStatusFailure+0x5a>
  {
    hciEvt_t      *pMsg;
    uint8_t       cbackEvt = 0;
   287dc:	2300      	movs	r3, #0
   287de:	75fb      	strb	r3, [r7, #23]
    hciEvtCback_t cback = hciCb.secCback;
   287e0:	4b0f      	ldr	r3, [pc, #60]	; (28820 <hciEvtCmdStatusFailure+0x64>)
   287e2:	68db      	ldr	r3, [r3, #12]
   287e4:	613b      	str	r3, [r7, #16]

    cbackEvt = HCI_LE_GENERATE_DHKEY_CMPL_CBACK_EVT;
   287e6:	2326      	movs	r3, #38	; 0x26
   287e8:	75fb      	strb	r3, [r7, #23]

    /* allocate temp buffer */
    if ((pMsg = WsfBufAlloc(sizeof(wsfMsgHdr_t))) != NULL)
   287ea:	2004      	movs	r0, #4
   287ec:	f004 fbd0 	bl	2cf90 <WsfBufAlloc>
   287f0:	60f8      	str	r0, [r7, #12]
   287f2:	68fb      	ldr	r3, [r7, #12]
   287f4:	2b00      	cmp	r3, #0
   287f6:	d00e      	beq.n	28816 <hciEvtCmdStatusFailure+0x5a>
    {
      /* initialize message header */
      pMsg->hdr.param = 0;
   287f8:	68fb      	ldr	r3, [r7, #12]
   287fa:	2200      	movs	r2, #0
   287fc:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = cbackEvt;
   287fe:	68fb      	ldr	r3, [r7, #12]
   28800:	7dfa      	ldrb	r2, [r7, #23]
   28802:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = status;
   28804:	68fb      	ldr	r3, [r7, #12]
   28806:	79fa      	ldrb	r2, [r7, #7]
   28808:	70da      	strb	r2, [r3, #3]

      /* execute callback */
      (*cback)(pMsg);
   2880a:	693b      	ldr	r3, [r7, #16]
   2880c:	68f8      	ldr	r0, [r7, #12]
   2880e:	4798      	blx	r3

      /* free buffer */
      WsfBufFree(pMsg);
   28810:	68f8      	ldr	r0, [r7, #12]
   28812:	f004 fbfd 	bl	2d010 <WsfBufFree>
    }
 }
}
   28816:	bf00      	nop
   28818:	3718      	adds	r7, #24
   2881a:	46bd      	mov	sp, r7
   2881c:	bd80      	pop	{r7, pc}
   2881e:	bf00      	nop
   28820:	100116ec 	.word	0x100116ec

00028824 <hciEvtProcessCmdStatus>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtProcessCmdStatus(uint8_t *p)
{
   28824:	b580      	push	{r7, lr}
   28826:	b084      	sub	sp, #16
   28828:	af00      	add	r7, sp, #0
   2882a:	6078      	str	r0, [r7, #4]
  uint8_t   status;
  uint8_t   numPkts;
  uint16_t  opcode;

  BSTREAM_TO_UINT8(status, p);
   2882c:	687b      	ldr	r3, [r7, #4]
   2882e:	1c5a      	adds	r2, r3, #1
   28830:	607a      	str	r2, [r7, #4]
   28832:	781b      	ldrb	r3, [r3, #0]
   28834:	73fb      	strb	r3, [r7, #15]
  BSTREAM_TO_UINT8(numPkts, p);
   28836:	687b      	ldr	r3, [r7, #4]
   28838:	1c5a      	adds	r2, r3, #1
   2883a:	607a      	str	r2, [r7, #4]
   2883c:	781b      	ldrb	r3, [r3, #0]
   2883e:	73bb      	strb	r3, [r7, #14]
  BSTREAM_TO_UINT16(opcode, p);
   28840:	687b      	ldr	r3, [r7, #4]
   28842:	781b      	ldrb	r3, [r3, #0]
   28844:	b29a      	uxth	r2, r3
   28846:	687b      	ldr	r3, [r7, #4]
   28848:	3301      	adds	r3, #1
   2884a:	781b      	ldrb	r3, [r3, #0]
   2884c:	b29b      	uxth	r3, r3
   2884e:	021b      	lsls	r3, r3, #8
   28850:	b29b      	uxth	r3, r3
   28852:	4413      	add	r3, r2
   28854:	81bb      	strh	r3, [r7, #12]
   28856:	687b      	ldr	r3, [r7, #4]
   28858:	3302      	adds	r3, #2
   2885a:	607b      	str	r3, [r7, #4]

  if (status != HCI_SUCCESS)  /* optional: or vendor specific */
   2885c:	7bfb      	ldrb	r3, [r7, #15]
   2885e:	2b00      	cmp	r3, #0
   28860:	d005      	beq.n	2886e <hciEvtProcessCmdStatus+0x4a>
  {
    hciEvtCmdStatusFailure(status, opcode);
   28862:	89ba      	ldrh	r2, [r7, #12]
   28864:	7bfb      	ldrb	r3, [r7, #15]
   28866:	4611      	mov	r1, r2
   28868:	4618      	mov	r0, r3
   2886a:	f7ff ffa7 	bl	287bc <hciEvtCmdStatusFailure>
  }

  /* optional:  handle vendor-specific command status event */

  hciCmdRecvCmpl(numPkts);
   2886e:	7bbb      	ldrb	r3, [r7, #14]
   28870:	4618      	mov	r0, r3
   28872:	f7fc fab9 	bl	24de8 <hciCmdRecvCmpl>
}
   28876:	bf00      	nop
   28878:	3710      	adds	r7, #16
   2887a:	46bd      	mov	sp, r7
   2887c:	bd80      	pop	{r7, pc}
	...

00028880 <hciEvtProcessCmdCmpl>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtProcessCmdCmpl(uint8_t *p, uint8_t len)
{
   28880:	b580      	push	{r7, lr}
   28882:	b086      	sub	sp, #24
   28884:	af00      	add	r7, sp, #0
   28886:	6078      	str	r0, [r7, #4]
   28888:	460b      	mov	r3, r1
   2888a:	70fb      	strb	r3, [r7, #3]
  uint8_t       numPkts;
  uint16_t      opcode;
  hciEvt_t      *pMsg;
  uint8_t       cbackEvt = 0;
   2888c:	2300      	movs	r3, #0
   2888e:	75fb      	strb	r3, [r7, #23]
  hciEvtCback_t cback = hciCb.evtCback;
   28890:	4bbd      	ldr	r3, [pc, #756]	; (28b88 <hciEvtProcessCmdCmpl+0x308>)
   28892:	689b      	ldr	r3, [r3, #8]
   28894:	613b      	str	r3, [r7, #16]

  BSTREAM_TO_UINT8(numPkts, p);
   28896:	687b      	ldr	r3, [r7, #4]
   28898:	1c5a      	adds	r2, r3, #1
   2889a:	607a      	str	r2, [r7, #4]
   2889c:	781b      	ldrb	r3, [r3, #0]
   2889e:	73fb      	strb	r3, [r7, #15]
  BSTREAM_TO_UINT16(opcode, p);
   288a0:	687b      	ldr	r3, [r7, #4]
   288a2:	781b      	ldrb	r3, [r3, #0]
   288a4:	b29a      	uxth	r2, r3
   288a6:	687b      	ldr	r3, [r7, #4]
   288a8:	3301      	adds	r3, #1
   288aa:	781b      	ldrb	r3, [r3, #0]
   288ac:	b29b      	uxth	r3, r3
   288ae:	021b      	lsls	r3, r3, #8
   288b0:	b29b      	uxth	r3, r3
   288b2:	4413      	add	r3, r2
   288b4:	81bb      	strh	r3, [r7, #12]
   288b6:	687b      	ldr	r3, [r7, #4]
   288b8:	3302      	adds	r3, #2
   288ba:	607b      	str	r3, [r7, #4]

  /* convert opcode to internal event code and perform special handling */
  switch (opcode)
   288bc:	89bb      	ldrh	r3, [r7, #12]
   288be:	f242 0257 	movw	r2, #8279	; 0x2057
   288c2:	4293      	cmp	r3, r2
   288c4:	f300 8124 	bgt.w	28b10 <hciEvtProcessCmdCmpl+0x290>
   288c8:	f242 020a 	movw	r2, #8202	; 0x200a
   288cc:	4293      	cmp	r3, r2
   288ce:	da14      	bge.n	288fa <hciEvtProcessCmdCmpl+0x7a>
   288d0:	f241 4205 	movw	r2, #5125	; 0x1405
   288d4:	4293      	cmp	r3, r2
   288d6:	f000 80df 	beq.w	28a98 <hciEvtProcessCmdCmpl+0x218>
   288da:	f241 4205 	movw	r2, #5125	; 0x1405
   288de:	4293      	cmp	r3, r2
   288e0:	f300 8116 	bgt.w	28b10 <hciEvtProcessCmdCmpl+0x290>
   288e4:	f640 422d 	movw	r2, #3117	; 0xc2d
   288e8:	4293      	cmp	r3, r2
   288ea:	f000 80d8 	beq.w	28a9e <hciEvtProcessCmdCmpl+0x21e>
   288ee:	f640 427c 	movw	r2, #3196	; 0xc7c
   288f2:	4293      	cmp	r3, r2
   288f4:	f000 80e8 	beq.w	28ac8 <hciEvtProcessCmdCmpl+0x248>
   288f8:	e10a      	b.n	28b10 <hciEvtProcessCmdCmpl+0x290>
   288fa:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
   288fe:	3b0a      	subs	r3, #10
   28900:	2b4d      	cmp	r3, #77	; 0x4d
   28902:	f200 8105 	bhi.w	28b10 <hciEvtProcessCmdCmpl+0x290>
   28906:	a201      	add	r2, pc, #4	; (adr r2, 2890c <hciEvtProcessCmdCmpl+0x8c>)
   28908:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2890c:	00028ae1 	.word	0x00028ae1
   28910:	00028b11 	.word	0x00028b11
   28914:	00028adb 	.word	0x00028adb
   28918:	00028b11 	.word	0x00028b11
   2891c:	00028a45 	.word	0x00028a45
   28920:	00028b11 	.word	0x00028b11
   28924:	00028b11 	.word	0x00028b11
   28928:	00028b11 	.word	0x00028b11
   2892c:	00028b11 	.word	0x00028b11
   28930:	00028b11 	.word	0x00028b11
   28934:	00028b11 	.word	0x00028b11
   28938:	00028a93 	.word	0x00028a93
   2893c:	00028b11 	.word	0x00028b11
   28940:	00028a4b 	.word	0x00028a4b
   28944:	00028a87 	.word	0x00028a87
   28948:	00028b11 	.word	0x00028b11
   2894c:	00028a7b 	.word	0x00028a7b
   28950:	00028a81 	.word	0x00028a81
   28954:	00028b11 	.word	0x00028b11
   28958:	00028b11 	.word	0x00028b11
   2895c:	00028b11 	.word	0x00028b11
   28960:	00028b11 	.word	0x00028b11
   28964:	00028a57 	.word	0x00028a57
   28968:	00028a5d 	.word	0x00028a5d
   2896c:	00028a6f 	.word	0x00028a6f
   28970:	00028a63 	.word	0x00028a63
   28974:	00028a69 	.word	0x00028a69
   28978:	00028b11 	.word	0x00028b11
   2897c:	00028b11 	.word	0x00028b11
   28980:	00028aa5 	.word	0x00028aa5
   28984:	00028aab 	.word	0x00028aab
   28988:	00028ab1 	.word	0x00028ab1
   2898c:	00028b11 	.word	0x00028b11
   28990:	00028ab7 	.word	0x00028ab7
   28994:	00028abd 	.word	0x00028abd
   28998:	00028ac3 	.word	0x00028ac3
   2899c:	00028b11 	.word	0x00028b11
   289a0:	00028a75 	.word	0x00028a75
   289a4:	00028acf 	.word	0x00028acf
   289a8:	00028ad5 	.word	0x00028ad5
   289ac:	00028b11 	.word	0x00028b11
   289b0:	00028b11 	.word	0x00028b11
   289b4:	00028b11 	.word	0x00028b11
   289b8:	00028b11 	.word	0x00028b11
   289bc:	00028b11 	.word	0x00028b11
   289c0:	00028b11 	.word	0x00028b11
   289c4:	00028b11 	.word	0x00028b11
   289c8:	00028aed 	.word	0x00028aed
   289cc:	00028b11 	.word	0x00028b11
   289d0:	00028b11 	.word	0x00028b11
   289d4:	00028b11 	.word	0x00028b11
   289d8:	00028b11 	.word	0x00028b11
   289dc:	00028b11 	.word	0x00028b11
   289e0:	00028b11 	.word	0x00028b11
   289e4:	00028af3 	.word	0x00028af3
   289e8:	00028b11 	.word	0x00028b11
   289ec:	00028ae7 	.word	0x00028ae7
   289f0:	00028b11 	.word	0x00028b11
   289f4:	00028b11 	.word	0x00028b11
   289f8:	00028b11 	.word	0x00028b11
   289fc:	00028b11 	.word	0x00028b11
   28a00:	00028b11 	.word	0x00028b11
   28a04:	00028b11 	.word	0x00028b11
   28a08:	00028b11 	.word	0x00028b11
   28a0c:	00028b11 	.word	0x00028b11
   28a10:	00028b11 	.word	0x00028b11
   28a14:	00028b11 	.word	0x00028b11
   28a18:	00028b11 	.word	0x00028b11
   28a1c:	00028b11 	.word	0x00028b11
   28a20:	00028b11 	.word	0x00028b11
   28a24:	00028b11 	.word	0x00028b11
   28a28:	00028b11 	.word	0x00028b11
   28a2c:	00028b11 	.word	0x00028b11
   28a30:	00028b11 	.word	0x00028b11
   28a34:	00028af9 	.word	0x00028af9
   28a38:	00028aff 	.word	0x00028aff
   28a3c:	00028b05 	.word	0x00028b05
   28a40:	00028b0b 	.word	0x00028b0b
  {
  case HCI_OPCODE_LE_CREATE_CONN_CANCEL:
    cbackEvt = HCI_LE_CREATE_CONN_CANCEL_CMD_CMPL_CBACK_EVT;
   28a44:	2305      	movs	r3, #5
   28a46:	75fb      	strb	r3, [r7, #23]
    break;
   28a48:	e070      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_ENCRYPT:
    cbackEvt = HCI_LE_ENCRYPT_CMD_CMPL_CBACK_EVT;
   28a4a:	231b      	movs	r3, #27
   28a4c:	75fb      	strb	r3, [r7, #23]
    cback = hciCb.secCback;
   28a4e:	4b4e      	ldr	r3, [pc, #312]	; (28b88 <hciEvtProcessCmdCmpl+0x308>)
   28a50:	68db      	ldr	r3, [r3, #12]
   28a52:	613b      	str	r3, [r7, #16]
    break;
   28a54:	e06a      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_REM_CONN_PARAM_REP:
    cbackEvt = HCI_LE_REM_CONN_PARAM_REP_CMD_CMPL_CBACK_EVT;
   28a56:	231d      	movs	r3, #29
   28a58:	75fb      	strb	r3, [r7, #23]
    break;
   28a5a:	e067      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_REM_CONN_PARAM_NEG_REP:
    cbackEvt = HCI_LE_REM_CONN_PARAM_NEG_REP_CMD_CMPL_CBACK_EVT;
   28a5c:	231e      	movs	r3, #30
   28a5e:	75fb      	strb	r3, [r7, #23]
    break;
   28a60:	e064      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_DEF_DATA_LEN:
    cbackEvt = HCI_LE_READ_DEF_DATA_LEN_CMD_CMPL_CBACK_EVT;
   28a62:	231f      	movs	r3, #31
   28a64:	75fb      	strb	r3, [r7, #23]
    break;
   28a66:	e061      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_WRITE_DEF_DATA_LEN:
    cbackEvt = HCI_LE_WRITE_DEF_DATA_LEN_CMD_CMPL_CBACK_EVT;
   28a68:	2320      	movs	r3, #32
   28a6a:	75fb      	strb	r3, [r7, #23]
    break;
   28a6c:	e05e      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_DATA_LEN:
    cbackEvt = HCI_LE_SET_DATA_LEN_CMD_CMPL_CBACK_EVT;
   28a6e:	2321      	movs	r3, #33	; 0x21
   28a70:	75fb      	strb	r3, [r7, #23]
    break;
   28a72:	e05b      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_MAX_DATA_LEN:
    cbackEvt = HCI_LE_READ_MAX_DATA_LEN_CMD_CMPL_CBACK_EVT;
   28a74:	2322      	movs	r3, #34	; 0x22
   28a76:	75fb      	strb	r3, [r7, #23]
    break;
   28a78:	e058      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_LTK_REQ_REPL:
    cbackEvt = HCI_LE_LTK_REQ_REPL_CMD_CMPL_CBACK_EVT;
   28a7a:	230c      	movs	r3, #12
   28a7c:	75fb      	strb	r3, [r7, #23]
    break;
   28a7e:	e055      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_LTK_REQ_NEG_REPL:
    cbackEvt = HCI_LE_LTK_REQ_NEG_REPL_CMD_CMPL_CBACK_EVT;
   28a80:	230d      	movs	r3, #13
   28a82:	75fb      	strb	r3, [r7, #23]
    break;
   28a84:	e052      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_RAND:
    cbackEvt = HCI_LE_RAND_CMD_CMPL_CBACK_EVT;
   28a86:	231c      	movs	r3, #28
   28a88:	75fb      	strb	r3, [r7, #23]
    cback = hciCb.secCback;
   28a8a:	4b3f      	ldr	r3, [pc, #252]	; (28b88 <hciEvtProcessCmdCmpl+0x308>)
   28a8c:	68db      	ldr	r3, [r3, #12]
   28a8e:	613b      	str	r3, [r7, #16]
    break;
   28a90:	e04c      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_CHAN_MAP:
    cbackEvt = HCI_LE_READ_CHAN_MAP_CMD_CMPL_CBACK_EVT;
   28a92:	2308      	movs	r3, #8
   28a94:	75fb      	strb	r3, [r7, #23]
    break;
   28a96:	e049      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_READ_RSSI:
    cbackEvt = HCI_READ_RSSI_CMD_CMPL_CBACK_EVT;
   28a98:	2307      	movs	r3, #7
   28a9a:	75fb      	strb	r3, [r7, #23]
    break;
   28a9c:	e046      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_READ_TX_PWR_LVL:
    cbackEvt = HCI_READ_TX_PWR_LVL_CMD_CMPL_CBACK_EVT;
   28a9e:	2309      	movs	r3, #9
   28aa0:	75fb      	strb	r3, [r7, #23]
    break;
   28aa2:	e043      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_ADD_DEV_RES_LIST:
    cbackEvt = HCI_LE_ADD_DEV_TO_RES_LIST_CMD_CMPL_CBACK_EVT;
   28aa4:	2315      	movs	r3, #21
   28aa6:	75fb      	strb	r3, [r7, #23]
    break;
   28aa8:	e040      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_REMOVE_DEV_RES_LIST:
    cbackEvt = HCI_LE_REM_DEV_FROM_RES_LIST_CMD_CMPL_CBACK_EVT;
   28aaa:	2316      	movs	r3, #22
   28aac:	75fb      	strb	r3, [r7, #23]
    break;
   28aae:	e03d      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_CLEAR_RES_LIST:
    cbackEvt = HCI_LE_CLEAR_RES_LIST_CMD_CMPL_CBACK_EVT;
   28ab0:	2317      	movs	r3, #23
   28ab2:	75fb      	strb	r3, [r7, #23]
    break;
   28ab4:	e03a      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_PEER_RES_ADDR:
    cbackEvt = HCI_LE_READ_PEER_RES_ADDR_CMD_CMPL_CBACK_EVT;
   28ab6:	2318      	movs	r3, #24
   28ab8:	75fb      	strb	r3, [r7, #23]
    break;
   28aba:	e037      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_LOCAL_RES_ADDR:
    cbackEvt = HCI_LE_READ_LOCAL_RES_ADDR_CMD_CMPL_CBACK_EVT;
   28abc:	2319      	movs	r3, #25
   28abe:	75fb      	strb	r3, [r7, #23]
    break;
   28ac0:	e034      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_ADDR_RES_ENABLE:
    cbackEvt = HCI_LE_SET_ADDR_RES_ENABLE_CMD_CMPL_CBACK_EVT;
   28ac2:	231a      	movs	r3, #26
   28ac4:	75fb      	strb	r3, [r7, #23]
    break;
   28ac6:	e031      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_WRITE_AUTH_PAYLOAD_TO:
    cbackEvt = HCI_WRITE_AUTH_PAYLOAD_TO_CMD_CMPL_CBACK_EVT;
   28ac8:	2327      	movs	r3, #39	; 0x27
   28aca:	75fb      	strb	r3, [r7, #23]
    break;
   28acc:	e02e      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_READ_PHY:
    cbackEvt = HCI_LE_READ_PHY_CMD_CMPL_CBACK_EVT;
   28ace:	2329      	movs	r3, #41	; 0x29
   28ad0:	75fb      	strb	r3, [r7, #23]
    break;
   28ad2:	e02b      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_DEF_PHY:
    cbackEvt = HCI_LE_SET_DEF_PHY_CMD_CMPL_CBACK_EVT;
   28ad4:	232a      	movs	r3, #42	; 0x2a
   28ad6:	75fb      	strb	r3, [r7, #23]
    break;
   28ad8:	e028      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_SCAN_ENABLE:
    cbackEvt = HCI_LE_SCAN_ENABLE_CMD_CMPL_CBACK_EVT;
   28ada:	2334      	movs	r3, #52	; 0x34
   28adc:	75fb      	strb	r3, [r7, #23]
    break;
   28ade:	e025      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_ADV_ENABLE:
    cbackEvt = HCI_LE_ADV_ENABLE_CMD_CMPL_CBACK_EVT;
   28ae0:	2335      	movs	r3, #53	; 0x35
   28ae2:	75fb      	strb	r3, [r7, #23]
    break;
   28ae4:	e022      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_EXT_SCAN_ENABLE:
    cbackEvt = HCI_LE_EXT_SCAN_ENABLE_CMD_CMPL_CBACK_EVT;
   28ae6:	2336      	movs	r3, #54	; 0x36
   28ae8:	75fb      	strb	r3, [r7, #23]
    break;
   28aea:	e01f      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_EXT_ADV_ENABLE:
    cbackEvt = HCI_LE_EXT_ADV_ENABLE_CMD_CMPL_CBACK_EVT;
   28aec:	2337      	movs	r3, #55	; 0x37
   28aee:	75fb      	strb	r3, [r7, #23]
    break;
   28af0:	e01c      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_PER_ADV_ENABLE:
    cbackEvt = HCI_LE_PER_ADV_ENABLE_CMD_CMPL_CBACK_EVT;
   28af2:	2338      	movs	r3, #56	; 0x38
   28af4:	75fb      	strb	r3, [r7, #23]
    break;
   28af6:	e019      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_CONN_CTE_RX_PARAMS:
    cbackEvt = HCI_LE_SET_CONN_CTE_RX_PARAMS_CMD_CMPL_CBACK_EVT;
   28af8:	233f      	movs	r3, #63	; 0x3f
   28afa:	75fb      	strb	r3, [r7, #23]
    break;
   28afc:	e016      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_SET_CONN_CTE_TX_PARAMS:
    cbackEvt = HCI_LE_SET_CONN_CTE_TX_PARAMS_CMD_CMPL_CBACK_EVT;
   28afe:	2340      	movs	r3, #64	; 0x40
   28b00:	75fb      	strb	r3, [r7, #23]
    break;
   28b02:	e013      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_CONN_CTE_REQ_ENABLE:
    cbackEvt = HCI_LE_CONN_CTE_REQ_ENABLE_CMD_CMPL_CBACK_EVT;
   28b04:	2341      	movs	r3, #65	; 0x41
   28b06:	75fb      	strb	r3, [r7, #23]
    break;
   28b08:	e010      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  case HCI_OPCODE_LE_CONN_CTE_RSP_ENABLE:
    cbackEvt = HCI_LE_CONN_CTE_RSP_ENABLE_CMD_CMPL_CBACK_EVT;
   28b0a:	2342      	movs	r3, #66	; 0x42
   28b0c:	75fb      	strb	r3, [r7, #23]
    break;
   28b0e:	e00d      	b.n	28b2c <hciEvtProcessCmdCmpl+0x2ac>

  default:
    /* test for vendor specific command completion OGF. */
    if (HCI_OGF(opcode) == HCI_OGF_VENDOR_SPEC)
   28b10:	89bb      	ldrh	r3, [r7, #12]
   28b12:	0a9b      	lsrs	r3, r3, #10
   28b14:	b29b      	uxth	r3, r3
   28b16:	2b3f      	cmp	r3, #63	; 0x3f
   28b18:	d107      	bne.n	28b2a <hciEvtProcessCmdCmpl+0x2aa>
    {
      cbackEvt = hciCoreVsCmdCmplRcvd(opcode, p, len);
   28b1a:	78fa      	ldrb	r2, [r7, #3]
   28b1c:	89bb      	ldrh	r3, [r7, #12]
   28b1e:	6879      	ldr	r1, [r7, #4]
   28b20:	4618      	mov	r0, r3
   28b22:	f000 fe73 	bl	2980c <hciCoreVsCmdCmplRcvd>
   28b26:	4603      	mov	r3, r0
   28b28:	75fb      	strb	r3, [r7, #23]
    }
    break;
   28b2a:	bf00      	nop
  }

  /* if callback is executed for this event */
  if (cbackEvt != 0)
   28b2c:	7dfb      	ldrb	r3, [r7, #23]
   28b2e:	2b00      	cmp	r3, #0
   28b30:	d021      	beq.n	28b76 <hciEvtProcessCmdCmpl+0x2f6>
  {
    /* allocate temp buffer */
    if ((pMsg = WsfBufAlloc(hciEvtCbackLen[cbackEvt])) != NULL)
   28b32:	7dfb      	ldrb	r3, [r7, #23]
   28b34:	4a15      	ldr	r2, [pc, #84]	; (28b8c <hciEvtProcessCmdCmpl+0x30c>)
   28b36:	5cd3      	ldrb	r3, [r2, r3]
   28b38:	b29b      	uxth	r3, r3
   28b3a:	4618      	mov	r0, r3
   28b3c:	f004 fa28 	bl	2cf90 <WsfBufAlloc>
   28b40:	60b8      	str	r0, [r7, #8]
   28b42:	68bb      	ldr	r3, [r7, #8]
   28b44:	2b00      	cmp	r3, #0
   28b46:	d016      	beq.n	28b76 <hciEvtProcessCmdCmpl+0x2f6>
    {
      /* initialize message header */
      pMsg->hdr.param = 0;
   28b48:	68bb      	ldr	r3, [r7, #8]
   28b4a:	2200      	movs	r2, #0
   28b4c:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = cbackEvt;
   28b4e:	68bb      	ldr	r3, [r7, #8]
   28b50:	7dfa      	ldrb	r2, [r7, #23]
   28b52:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = 0;
   28b54:	68bb      	ldr	r3, [r7, #8]
   28b56:	2200      	movs	r2, #0
   28b58:	70da      	strb	r2, [r3, #3]

      /* execute parsing function for the event */
      (*hciEvtParseFcnTbl[cbackEvt])(pMsg, p, len);
   28b5a:	7dfb      	ldrb	r3, [r7, #23]
   28b5c:	4a0c      	ldr	r2, [pc, #48]	; (28b90 <hciEvtProcessCmdCmpl+0x310>)
   28b5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   28b62:	78fa      	ldrb	r2, [r7, #3]
   28b64:	6879      	ldr	r1, [r7, #4]
   28b66:	68b8      	ldr	r0, [r7, #8]
   28b68:	4798      	blx	r3

      /* execute callback */
      (*cback)(pMsg);
   28b6a:	693b      	ldr	r3, [r7, #16]
   28b6c:	68b8      	ldr	r0, [r7, #8]
   28b6e:	4798      	blx	r3

      /* free buffer */
      WsfBufFree(pMsg);
   28b70:	68b8      	ldr	r0, [r7, #8]
   28b72:	f004 fa4d 	bl	2d010 <WsfBufFree>
    }
  }

  hciCmdRecvCmpl(numPkts);
   28b76:	7bfb      	ldrb	r3, [r7, #15]
   28b78:	4618      	mov	r0, r3
   28b7a:	f7fc f935 	bl	24de8 <hciCmdRecvCmpl>
}
   28b7e:	bf00      	nop
   28b80:	3718      	adds	r7, #24
   28b82:	46bd      	mov	sp, r7
   28b84:	bd80      	pop	{r7, pc}
   28b86:	bf00      	nop
   28b88:	100116ec 	.word	0x100116ec
   28b8c:	00045e90 	.word	0x00045e90
   28b90:	00045d84 	.word	0x00045d84

00028b94 <hciEvtProcessMsg>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciEvtProcessMsg(uint8_t *pEvt)
{
   28b94:	b580      	push	{r7, lr}
   28b96:	b088      	sub	sp, #32
   28b98:	af00      	add	r7, sp, #0
   28b9a:	6078      	str	r0, [r7, #4]
  uint8_t   evt;
  uint8_t   subEvt;
  uint8_t   len;
  uint8_t   cbackEvt = 0;
   28b9c:	2300      	movs	r3, #0
   28b9e:	77fb      	strb	r3, [r7, #31]
  hciEvt_t  *pMsg;
  uint16_t  handle;
  hciEvtCback_t cback = hciCb.evtCback;
   28ba0:	4bcb      	ldr	r3, [pc, #812]	; (28ed0 <hciEvtProcessMsg+0x33c>)
   28ba2:	689b      	ldr	r3, [r3, #8]
   28ba4:	61bb      	str	r3, [r7, #24]

  /* parse HCI event header */
  BSTREAM_TO_UINT8(evt, pEvt);
   28ba6:	687b      	ldr	r3, [r7, #4]
   28ba8:	1c5a      	adds	r2, r3, #1
   28baa:	607a      	str	r2, [r7, #4]
   28bac:	781b      	ldrb	r3, [r3, #0]
   28bae:	75fb      	strb	r3, [r7, #23]
  BSTREAM_TO_UINT8(len, pEvt);
   28bb0:	687b      	ldr	r3, [r7, #4]
   28bb2:	1c5a      	adds	r2, r3, #1
   28bb4:	607a      	str	r2, [r7, #4]
   28bb6:	781b      	ldrb	r3, [r3, #0]
   28bb8:	75bb      	strb	r3, [r7, #22]

  /* convert hci event code to internal event code and perform special handling */
  switch (evt)
   28bba:	7dfb      	ldrb	r3, [r7, #23]
   28bbc:	2b57      	cmp	r3, #87	; 0x57
   28bbe:	f300 80b1 	bgt.w	28d24 <hciEvtProcessMsg+0x190>
   28bc2:	2b05      	cmp	r3, #5
   28bc4:	f2c0 81e3 	blt.w	28f8e <hciEvtProcessMsg+0x3fa>
   28bc8:	3b05      	subs	r3, #5
   28bca:	2b52      	cmp	r3, #82	; 0x52
   28bcc:	f200 81df 	bhi.w	28f8e <hciEvtProcessMsg+0x3fa>
   28bd0:	a201      	add	r2, pc, #4	; (adr r2, 28bd8 <hciEvtProcessMsg+0x44>)
   28bd2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   28bd6:	bf00      	nop
   28bd8:	00028f03 	.word	0x00028f03
   28bdc:	00028f8f 	.word	0x00028f8f
   28be0:	00028f8f 	.word	0x00028f8f
   28be4:	00028f15 	.word	0x00028f15
   28be8:	00028f8f 	.word	0x00028f8f
   28bec:	00028f8f 	.word	0x00028f8f
   28bf0:	00028f8f 	.word	0x00028f8f
   28bf4:	00028f27 	.word	0x00028f27
   28bf8:	00028f8f 	.word	0x00028f8f
   28bfc:	00028d41 	.word	0x00028d41
   28c00:	00028d2d 	.word	0x00028d2d
   28c04:	00028f59 	.word	0x00028f59
   28c08:	00028f8f 	.word	0x00028f8f
   28c0c:	00028f8f 	.word	0x00028f8f
   28c10:	00028d59 	.word	0x00028d59
   28c14:	00028f8f 	.word	0x00028f8f
   28c18:	00028f8f 	.word	0x00028f8f
   28c1c:	00028f8f 	.word	0x00028f8f
   28c20:	00028f8f 	.word	0x00028f8f
   28c24:	00028f8f 	.word	0x00028f8f
   28c28:	00028f8f 	.word	0x00028f8f
   28c2c:	00028f4b 	.word	0x00028f4b
   28c30:	00028f8f 	.word	0x00028f8f
   28c34:	00028f8f 	.word	0x00028f8f
   28c38:	00028f8f 	.word	0x00028f8f
   28c3c:	00028f8f 	.word	0x00028f8f
   28c40:	00028f8f 	.word	0x00028f8f
   28c44:	00028f8f 	.word	0x00028f8f
   28c48:	00028f8f 	.word	0x00028f8f
   28c4c:	00028f8f 	.word	0x00028f8f
   28c50:	00028f8f 	.word	0x00028f8f
   28c54:	00028f8f 	.word	0x00028f8f
   28c58:	00028f8f 	.word	0x00028f8f
   28c5c:	00028f8f 	.word	0x00028f8f
   28c60:	00028f8f 	.word	0x00028f8f
   28c64:	00028f8f 	.word	0x00028f8f
   28c68:	00028f8f 	.word	0x00028f8f
   28c6c:	00028f8f 	.word	0x00028f8f
   28c70:	00028f8f 	.word	0x00028f8f
   28c74:	00028f8f 	.word	0x00028f8f
   28c78:	00028f8f 	.word	0x00028f8f
   28c7c:	00028f8f 	.word	0x00028f8f
   28c80:	00028f8f 	.word	0x00028f8f
   28c84:	00028f39 	.word	0x00028f39
   28c88:	00028f8f 	.word	0x00028f8f
   28c8c:	00028f8f 	.word	0x00028f8f
   28c90:	00028f8f 	.word	0x00028f8f
   28c94:	00028f8f 	.word	0x00028f8f
   28c98:	00028f8f 	.word	0x00028f8f
   28c9c:	00028f8f 	.word	0x00028f8f
   28ca0:	00028f8f 	.word	0x00028f8f
   28ca4:	00028f8f 	.word	0x00028f8f
   28ca8:	00028f8f 	.word	0x00028f8f
   28cac:	00028f8f 	.word	0x00028f8f
   28cb0:	00028f8f 	.word	0x00028f8f
   28cb4:	00028f8f 	.word	0x00028f8f
   28cb8:	00028f8f 	.word	0x00028f8f
   28cbc:	00028d6d 	.word	0x00028d6d
   28cc0:	00028f8f 	.word	0x00028f8f
   28cc4:	00028f8f 	.word	0x00028f8f
   28cc8:	00028f8f 	.word	0x00028f8f
   28ccc:	00028f8f 	.word	0x00028f8f
   28cd0:	00028f8f 	.word	0x00028f8f
   28cd4:	00028f8f 	.word	0x00028f8f
   28cd8:	00028f8f 	.word	0x00028f8f
   28cdc:	00028f8f 	.word	0x00028f8f
   28ce0:	00028f8f 	.word	0x00028f8f
   28ce4:	00028f8f 	.word	0x00028f8f
   28ce8:	00028f8f 	.word	0x00028f8f
   28cec:	00028f8f 	.word	0x00028f8f
   28cf0:	00028f8f 	.word	0x00028f8f
   28cf4:	00028f8f 	.word	0x00028f8f
   28cf8:	00028f8f 	.word	0x00028f8f
   28cfc:	00028f8f 	.word	0x00028f8f
   28d00:	00028f8f 	.word	0x00028f8f
   28d04:	00028f8f 	.word	0x00028f8f
   28d08:	00028f8f 	.word	0x00028f8f
   28d0c:	00028f8f 	.word	0x00028f8f
   28d10:	00028f8f 	.word	0x00028f8f
   28d14:	00028f8f 	.word	0x00028f8f
   28d18:	00028f8f 	.word	0x00028f8f
   28d1c:	00028f8f 	.word	0x00028f8f
   28d20:	00028f6b 	.word	0x00028f6b
   28d24:	2bff      	cmp	r3, #255	; 0xff
   28d26:	f000 8129 	beq.w	28f7c <hciEvtProcessMsg+0x3e8>
      hciEvtStats.numVendorSpecEvt++;
      cbackEvt = HCI_VENDOR_SPEC_CBACK_EVT;
      break;

    default:
      break;
   28d2a:	e130      	b.n	28f8e <hciEvtProcessMsg+0x3fa>
      hciEvtStats.numCmdStatusEvt++;
   28d2c:	4b69      	ldr	r3, [pc, #420]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d2e:	891b      	ldrh	r3, [r3, #8]
   28d30:	3301      	adds	r3, #1
   28d32:	b29a      	uxth	r2, r3
   28d34:	4b67      	ldr	r3, [pc, #412]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d36:	811a      	strh	r2, [r3, #8]
      hciEvtProcessCmdStatus(pEvt);
   28d38:	6878      	ldr	r0, [r7, #4]
   28d3a:	f7ff fd73 	bl	28824 <hciEvtProcessCmdStatus>
      break;
   28d3e:	e127      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numCmdCmplEvt++;
   28d40:	4b64      	ldr	r3, [pc, #400]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d42:	88db      	ldrh	r3, [r3, #6]
   28d44:	3301      	adds	r3, #1
   28d46:	b29a      	uxth	r2, r3
   28d48:	4b62      	ldr	r3, [pc, #392]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d4a:	80da      	strh	r2, [r3, #6]
      hciEvtProcessCmdCmpl(pEvt, len);
   28d4c:	7dbb      	ldrb	r3, [r7, #22]
   28d4e:	4619      	mov	r1, r3
   28d50:	6878      	ldr	r0, [r7, #4]
   28d52:	f7ff fd95 	bl	28880 <hciEvtProcessCmdCmpl>
      break;
   28d56:	e11b      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciCoreNumCmplPkts(pEvt);
   28d58:	6878      	ldr	r0, [r7, #4]
   28d5a:	f7fd fa9b 	bl	26294 <hciCoreNumCmplPkts>
      hciEvtStats.numCmplPktsEvt++;
   28d5e:	4b5d      	ldr	r3, [pc, #372]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d60:	899b      	ldrh	r3, [r3, #12]
   28d62:	3301      	adds	r3, #1
   28d64:	b29a      	uxth	r2, r3
   28d66:	4b5b      	ldr	r3, [pc, #364]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d68:	819a      	strh	r2, [r3, #12]
      break;
   28d6a:	e111      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      BSTREAM_TO_UINT8(subEvt, pEvt);
   28d6c:	687b      	ldr	r3, [r7, #4]
   28d6e:	1c5a      	adds	r2, r3, #1
   28d70:	607a      	str	r2, [r7, #4]
   28d72:	781b      	ldrb	r3, [r3, #0]
   28d74:	757b      	strb	r3, [r7, #21]
      hciEvtStats.numLeMetaEvt++;
   28d76:	4b57      	ldr	r3, [pc, #348]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d78:	8a5b      	ldrh	r3, [r3, #18]
   28d7a:	3301      	adds	r3, #1
   28d7c:	b29a      	uxth	r2, r3
   28d7e:	4b55      	ldr	r3, [pc, #340]	; (28ed4 <hciEvtProcessMsg+0x340>)
   28d80:	825a      	strh	r2, [r3, #18]
      switch (subEvt)
   28d82:	7d7b      	ldrb	r3, [r7, #21]
   28d84:	3b01      	subs	r3, #1
   28d86:	2b16      	cmp	r3, #22
   28d88:	f200 80b9 	bhi.w	28efe <hciEvtProcessMsg+0x36a>
   28d8c:	a201      	add	r2, pc, #4	; (adr r2, 28d94 <hciEvtProcessMsg+0x200>)
   28d8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   28d92:	bf00      	nop
   28d94:	00028df1 	.word	0x00028df1
   28d98:	00028e1f 	.word	0x00028e1f
   28d9c:	00028e2b 	.word	0x00028e2b
   28da0:	00028e31 	.word	0x00028e31
   28da4:	00028e37 	.word	0x00028e37
   28da8:	00028e77 	.word	0x00028e77
   28dac:	00028e7d 	.word	0x00028e7d
   28db0:	00028e83 	.word	0x00028e83
   28db4:	00028e8f 	.word	0x00028e8f
   28db8:	00028e3d 	.word	0x00028e3d
   28dbc:	00028e6b 	.word	0x00028e6b
   28dc0:	00028e9b 	.word	0x00028e9b
   28dc4:	00028ea1 	.word	0x00028ea1
   28dc8:	00028ebf 	.word	0x00028ebf
   28dcc:	00028ec5 	.word	0x00028ec5
   28dd0:	00028ed9 	.word	0x00028ed9
   28dd4:	00028ead 	.word	0x00028ead
   28dd8:	00028eb3 	.word	0x00028eb3
   28ddc:	00028eb9 	.word	0x00028eb9
   28de0:	00028eff 	.word	0x00028eff
   28de4:	00028ef3 	.word	0x00028ef3
   28de8:	00028edf 	.word	0x00028edf
   28dec:	00028eeb 	.word	0x00028eeb
          if (*pEvt == HCI_SUCCESS)
   28df0:	687b      	ldr	r3, [r7, #4]
   28df2:	781b      	ldrb	r3, [r3, #0]
   28df4:	2b00      	cmp	r3, #0
   28df6:	d10f      	bne.n	28e18 <hciEvtProcessMsg+0x284>
            BYTES_TO_UINT16(handle, (pEvt + 1));
   28df8:	687b      	ldr	r3, [r7, #4]
   28dfa:	3301      	adds	r3, #1
   28dfc:	781b      	ldrb	r3, [r3, #0]
   28dfe:	b29a      	uxth	r2, r3
   28e00:	687b      	ldr	r3, [r7, #4]
   28e02:	3302      	adds	r3, #2
   28e04:	781b      	ldrb	r3, [r3, #0]
   28e06:	b29b      	uxth	r3, r3
   28e08:	021b      	lsls	r3, r3, #8
   28e0a:	b29b      	uxth	r3, r3
   28e0c:	4413      	add	r3, r2
   28e0e:	827b      	strh	r3, [r7, #18]
            hciCoreConnOpen(handle);
   28e10:	8a7b      	ldrh	r3, [r7, #18]
   28e12:	4618      	mov	r0, r3
   28e14:	f7fc feae 	bl	25b74 <hciCoreConnOpen>
          cbackEvt = HCI_LE_CONN_CMPL_CBACK_EVT;
   28e18:	2301      	movs	r3, #1
   28e1a:	77fb      	strb	r3, [r7, #31]
          break;
   28e1c:	e070      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLeAdvReport(pEvt, len);
   28e1e:	7dbb      	ldrb	r3, [r7, #22]
   28e20:	4619      	mov	r1, r3
   28e22:	6878      	ldr	r0, [r7, #4]
   28e24:	f7fe ffc4 	bl	27db0 <hciEvtProcessLeAdvReport>
          break;
   28e28:	e06a      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_CONN_UPDATE_CMPL_CBACK_EVT;
   28e2a:	2304      	movs	r3, #4
   28e2c:	77fb      	strb	r3, [r7, #31]
          break;
   28e2e:	e067      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_READ_REMOTE_FEAT_CMPL_CBACK_EVT;
   28e30:	230b      	movs	r3, #11
   28e32:	77fb      	strb	r3, [r7, #31]
          break;
   28e34:	e064      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_LTK_REQ_CBACK_EVT;
   28e36:	2310      	movs	r3, #16
   28e38:	77fb      	strb	r3, [r7, #31]
          break;
   28e3a:	e061      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          if (*pEvt == HCI_SUCCESS)
   28e3c:	687b      	ldr	r3, [r7, #4]
   28e3e:	781b      	ldrb	r3, [r3, #0]
   28e40:	2b00      	cmp	r3, #0
   28e42:	d10f      	bne.n	28e64 <hciEvtProcessMsg+0x2d0>
            BYTES_TO_UINT16(handle, (pEvt + 1));
   28e44:	687b      	ldr	r3, [r7, #4]
   28e46:	3301      	adds	r3, #1
   28e48:	781b      	ldrb	r3, [r3, #0]
   28e4a:	b29a      	uxth	r2, r3
   28e4c:	687b      	ldr	r3, [r7, #4]
   28e4e:	3302      	adds	r3, #2
   28e50:	781b      	ldrb	r3, [r3, #0]
   28e52:	b29b      	uxth	r3, r3
   28e54:	021b      	lsls	r3, r3, #8
   28e56:	b29b      	uxth	r3, r3
   28e58:	4413      	add	r3, r2
   28e5a:	827b      	strh	r3, [r7, #18]
            hciCoreConnOpen(handle);
   28e5c:	8a7b      	ldrh	r3, [r7, #18]
   28e5e:	4618      	mov	r0, r3
   28e60:	f7fc fe88 	bl	25b74 <hciCoreConnOpen>
          cbackEvt = HCI_LE_ENHANCED_CONN_CMPL_CBACK_EVT;
   28e64:	2302      	movs	r3, #2
   28e66:	77fb      	strb	r3, [r7, #31]
          break;
   28e68:	e04a      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLeDirectAdvReport(pEvt, len);
   28e6a:	7dbb      	ldrb	r3, [r7, #22]
   28e6c:	4619      	mov	r1, r3
   28e6e:	6878      	ldr	r0, [r7, #4]
   28e70:	f7ff fc40 	bl	286f4 <hciEvtProcessLeDirectAdvReport>
          break;
   28e74:	e044      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_REM_CONN_PARAM_REQ_CBACK_EVT;
   28e76:	2323      	movs	r3, #35	; 0x23
   28e78:	77fb      	strb	r3, [r7, #31]
          break;
   28e7a:	e041      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_DATA_LEN_CHANGE_CBACK_EVT;
   28e7c:	2324      	movs	r3, #36	; 0x24
   28e7e:	77fb      	strb	r3, [r7, #31]
          break;
   28e80:	e03e      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cback = hciCb.secCback;
   28e82:	4b13      	ldr	r3, [pc, #76]	; (28ed0 <hciEvtProcessMsg+0x33c>)
   28e84:	68db      	ldr	r3, [r3, #12]
   28e86:	61bb      	str	r3, [r7, #24]
          cbackEvt = HCI_LE_READ_LOCAL_P256_PUB_KEY_CMPL_CBACK_EVT;
   28e88:	2325      	movs	r3, #37	; 0x25
   28e8a:	77fb      	strb	r3, [r7, #31]
          break;
   28e8c:	e038      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cback = hciCb.secCback;
   28e8e:	4b10      	ldr	r3, [pc, #64]	; (28ed0 <hciEvtProcessMsg+0x33c>)
   28e90:	68db      	ldr	r3, [r3, #12]
   28e92:	61bb      	str	r3, [r7, #24]
          cbackEvt = HCI_LE_GENERATE_DHKEY_CMPL_CBACK_EVT;
   28e94:	2326      	movs	r3, #38	; 0x26
   28e96:	77fb      	strb	r3, [r7, #31]
          break;
   28e98:	e032      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_PHY_UPDATE_CMPL_CBACK_EVT;
   28e9a:	232b      	movs	r3, #43	; 0x2b
   28e9c:	77fb      	strb	r3, [r7, #31]
          break;
   28e9e:	e02f      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLeExtAdvReport(pEvt, len);
   28ea0:	7dbb      	ldrb	r3, [r7, #22]
   28ea2:	4619      	mov	r1, r3
   28ea4:	6878      	ldr	r0, [r7, #4]
   28ea6:	f7fe fffb 	bl	27ea0 <hciEvtProcessLeExtAdvReport>
          break;
   28eaa:	e029      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_SCAN_TIMEOUT_CBACK_EVT;
   28eac:	232d      	movs	r3, #45	; 0x2d
   28eae:	77fb      	strb	r3, [r7, #31]
          break;
   28eb0:	e026      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_ADV_SET_TERM_CBACK_EVT;
   28eb2:	232e      	movs	r3, #46	; 0x2e
   28eb4:	77fb      	strb	r3, [r7, #31]
          break;
   28eb6:	e023      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_SCAN_REQ_RCVD_CBACK_EVT;
   28eb8:	232f      	movs	r3, #47	; 0x2f
   28eba:	77fb      	strb	r3, [r7, #31]
          break;
   28ebc:	e020      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          cbackEvt = HCI_LE_PER_ADV_SYNC_EST_CBACK_EVT;
   28ebe:	2330      	movs	r3, #48	; 0x30
   28ec0:	77fb      	strb	r3, [r7, #31]
          break;
   28ec2:	e01d      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLePerAdvReport(pEvt, len);
   28ec4:	7dbb      	ldrb	r3, [r7, #22]
   28ec6:	4619      	mov	r1, r3
   28ec8:	6878      	ldr	r0, [r7, #4]
   28eca:	f7ff f97b 	bl	281c4 <hciEvtProcessLePerAdvReport>
          break;
   28ece:	e017      	b.n	28f00 <hciEvtProcessMsg+0x36c>
   28ed0:	100116ec 	.word	0x100116ec
   28ed4:	10003f80 	.word	0x10003f80
          cbackEvt = HCI_LE_PER_ADV_SYNC_LOST_CBACK_EVT;
   28ed8:	2332      	movs	r3, #50	; 0x32
   28eda:	77fb      	strb	r3, [r7, #31]
          break;
   28edc:	e010      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLeConnIQReport(pEvt, len);
   28ede:	7dbb      	ldrb	r3, [r7, #22]
   28ee0:	4619      	mov	r1, r3
   28ee2:	6878      	ldr	r0, [r7, #4]
   28ee4:	f7ff f9ee 	bl	282c4 <hciEvtProcessLeConnIQReport>
          break;
   28ee8:	e00a      	b.n	28f00 <hciEvtProcessMsg+0x36c>
        APP_TRACE_INFO0("cte req failed....");
   28eea:	4847      	ldr	r0, [pc, #284]	; (29008 <hciEvtProcessMsg+0x474>)
   28eec:	f004 fd50 	bl	2d990 <WsfTrace>
        break;
   28ef0:	e006      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          hciEvtProcessLeConlessIQReport(pEvt, len);
   28ef2:	7dbb      	ldrb	r3, [r7, #22]
   28ef4:	4619      	mov	r1, r3
   28ef6:	6878      	ldr	r0, [r7, #4]
   28ef8:	f7ff fa90 	bl	2841c <hciEvtProcessLeConlessIQReport>
          break;
   28efc:	e000      	b.n	28f00 <hciEvtProcessMsg+0x36c>
          break;
   28efe:	bf00      	nop
      break;
   28f00:	e046      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numDiscCmplEvt++;
   28f02:	4b42      	ldr	r3, [pc, #264]	; (2900c <hciEvtProcessMsg+0x478>)
   28f04:	881b      	ldrh	r3, [r3, #0]
   28f06:	3301      	adds	r3, #1
   28f08:	b29a      	uxth	r2, r3
   28f0a:	4b40      	ldr	r3, [pc, #256]	; (2900c <hciEvtProcessMsg+0x478>)
   28f0c:	801a      	strh	r2, [r3, #0]
      cbackEvt = HCI_DISCONNECT_CMPL_CBACK_EVT;
   28f0e:	2303      	movs	r3, #3
   28f10:	77fb      	strb	r3, [r7, #31]
      break;
   28f12:	e03d      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numEncChangeEvt++;
   28f14:	4b3d      	ldr	r3, [pc, #244]	; (2900c <hciEvtProcessMsg+0x478>)
   28f16:	885b      	ldrh	r3, [r3, #2]
   28f18:	3301      	adds	r3, #1
   28f1a:	b29a      	uxth	r2, r3
   28f1c:	4b3b      	ldr	r3, [pc, #236]	; (2900c <hciEvtProcessMsg+0x478>)
   28f1e:	805a      	strh	r2, [r3, #2]
      cbackEvt = HCI_ENC_CHANGE_CBACK_EVT;
   28f20:	230f      	movs	r3, #15
   28f22:	77fb      	strb	r3, [r7, #31]
      break;
   28f24:	e034      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numReadRemoteVerInfoCmpEvt++;
   28f26:	4b39      	ldr	r3, [pc, #228]	; (2900c <hciEvtProcessMsg+0x478>)
   28f28:	889b      	ldrh	r3, [r3, #4]
   28f2a:	3301      	adds	r3, #1
   28f2c:	b29a      	uxth	r2, r3
   28f2e:	4b37      	ldr	r3, [pc, #220]	; (2900c <hciEvtProcessMsg+0x478>)
   28f30:	809a      	strh	r2, [r3, #4]
      cbackEvt = HCI_READ_REMOTE_VER_INFO_CMPL_CBACK_EVT;
   28f32:	230a      	movs	r3, #10
   28f34:	77fb      	strb	r3, [r7, #31]
      break;
   28f36:	e02b      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numEncKeyRefreshCmplEvt++;
   28f38:	4b34      	ldr	r3, [pc, #208]	; (2900c <hciEvtProcessMsg+0x478>)
   28f3a:	8a1b      	ldrh	r3, [r3, #16]
   28f3c:	3301      	adds	r3, #1
   28f3e:	b29a      	uxth	r2, r3
   28f40:	4b32      	ldr	r3, [pc, #200]	; (2900c <hciEvtProcessMsg+0x478>)
   28f42:	821a      	strh	r2, [r3, #16]
      cbackEvt = HCI_ENC_KEY_REFRESH_CMPL_CBACK_EVT;
   28f44:	230e      	movs	r3, #14
   28f46:	77fb      	strb	r3, [r7, #31]
      break;
   28f48:	e022      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numDataBufOverflowEvt++;
   28f4a:	4b30      	ldr	r3, [pc, #192]	; (2900c <hciEvtProcessMsg+0x478>)
   28f4c:	89db      	ldrh	r3, [r3, #14]
   28f4e:	3301      	adds	r3, #1
   28f50:	b29a      	uxth	r2, r3
   28f52:	4b2e      	ldr	r3, [pc, #184]	; (2900c <hciEvtProcessMsg+0x478>)
   28f54:	81da      	strh	r2, [r3, #14]
      break;
   28f56:	e01b      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numHwErrorEvt++;
   28f58:	4b2c      	ldr	r3, [pc, #176]	; (2900c <hciEvtProcessMsg+0x478>)
   28f5a:	895b      	ldrh	r3, [r3, #10]
   28f5c:	3301      	adds	r3, #1
   28f5e:	b29a      	uxth	r2, r3
   28f60:	4b2a      	ldr	r3, [pc, #168]	; (2900c <hciEvtProcessMsg+0x478>)
   28f62:	815a      	strh	r2, [r3, #10]
      cbackEvt = HCI_HW_ERROR_CBACK_EVT;
   28f64:	2314      	movs	r3, #20
   28f66:	77fb      	strb	r3, [r7, #31]
      break;
   28f68:	e012      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numAuthToEvt++;
   28f6a:	4b28      	ldr	r3, [pc, #160]	; (2900c <hciEvtProcessMsg+0x478>)
   28f6c:	8adb      	ldrh	r3, [r3, #22]
   28f6e:	3301      	adds	r3, #1
   28f70:	b29a      	uxth	r2, r3
   28f72:	4b26      	ldr	r3, [pc, #152]	; (2900c <hciEvtProcessMsg+0x478>)
   28f74:	82da      	strh	r2, [r3, #22]
      cbackEvt = HCI_AUTH_PAYLOAD_TO_EXPIRED_CBACK_EVT;
   28f76:	2328      	movs	r3, #40	; 0x28
   28f78:	77fb      	strb	r3, [r7, #31]
      break;
   28f7a:	e009      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      hciEvtStats.numVendorSpecEvt++;
   28f7c:	4b23      	ldr	r3, [pc, #140]	; (2900c <hciEvtProcessMsg+0x478>)
   28f7e:	8a9b      	ldrh	r3, [r3, #20]
   28f80:	3301      	adds	r3, #1
   28f82:	b29a      	uxth	r2, r3
   28f84:	4b21      	ldr	r3, [pc, #132]	; (2900c <hciEvtProcessMsg+0x478>)
   28f86:	829a      	strh	r2, [r3, #20]
      cbackEvt = HCI_VENDOR_SPEC_CBACK_EVT;
   28f88:	2313      	movs	r3, #19
   28f8a:	77fb      	strb	r3, [r7, #31]
      break;
   28f8c:	e000      	b.n	28f90 <hciEvtProcessMsg+0x3fc>
      break;
   28f8e:	bf00      	nop
  }

  /* if callback is executed for this event */
  if (cbackEvt != 0)
   28f90:	7ffb      	ldrb	r3, [r7, #31]
   28f92:	2b00      	cmp	r3, #0
   28f94:	d034      	beq.n	29000 <hciEvtProcessMsg+0x46c>
  {
    /* allocate temp buffer */
    if ((pMsg = WsfBufAlloc(hciEvtCbackLen[cbackEvt])) != NULL)
   28f96:	7ffb      	ldrb	r3, [r7, #31]
   28f98:	4a1d      	ldr	r2, [pc, #116]	; (29010 <hciEvtProcessMsg+0x47c>)
   28f9a:	5cd3      	ldrb	r3, [r2, r3]
   28f9c:	b29b      	uxth	r3, r3
   28f9e:	4618      	mov	r0, r3
   28fa0:	f003 fff6 	bl	2cf90 <WsfBufAlloc>
   28fa4:	60f8      	str	r0, [r7, #12]
   28fa6:	68fb      	ldr	r3, [r7, #12]
   28fa8:	2b00      	cmp	r3, #0
   28faa:	d016      	beq.n	28fda <hciEvtProcessMsg+0x446>
    {
      /* initialize message header */
      pMsg->hdr.param = 0;
   28fac:	68fb      	ldr	r3, [r7, #12]
   28fae:	2200      	movs	r2, #0
   28fb0:	801a      	strh	r2, [r3, #0]
      pMsg->hdr.event = cbackEvt;
   28fb2:	68fb      	ldr	r3, [r7, #12]
   28fb4:	7ffa      	ldrb	r2, [r7, #31]
   28fb6:	709a      	strb	r2, [r3, #2]
      pMsg->hdr.status = 0;
   28fb8:	68fb      	ldr	r3, [r7, #12]
   28fba:	2200      	movs	r2, #0
   28fbc:	70da      	strb	r2, [r3, #3]

      /* execute parsing function for the event */
      (*hciEvtParseFcnTbl[cbackEvt])(pMsg, pEvt, len);
   28fbe:	7ffb      	ldrb	r3, [r7, #31]
   28fc0:	4a14      	ldr	r2, [pc, #80]	; (29014 <hciEvtProcessMsg+0x480>)
   28fc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   28fc6:	7dba      	ldrb	r2, [r7, #22]
   28fc8:	6879      	ldr	r1, [r7, #4]
   28fca:	68f8      	ldr	r0, [r7, #12]
   28fcc:	4798      	blx	r3

      /* execute callback */
      (*cback)(pMsg);
   28fce:	69bb      	ldr	r3, [r7, #24]
   28fd0:	68f8      	ldr	r0, [r7, #12]
   28fd2:	4798      	blx	r3

      /* free buffer */
      WsfBufFree(pMsg);
   28fd4:	68f8      	ldr	r0, [r7, #12]
   28fd6:	f004 f81b 	bl	2d010 <WsfBufFree>
    }

    /* execute core procedure for connection close after callback */
    if (cbackEvt == HCI_DISCONNECT_CMPL_CBACK_EVT)
   28fda:	7ffb      	ldrb	r3, [r7, #31]
   28fdc:	2b03      	cmp	r3, #3
   28fde:	d10f      	bne.n	29000 <hciEvtProcessMsg+0x46c>
    {
      BYTES_TO_UINT16(handle, (pEvt + 1));
   28fe0:	687b      	ldr	r3, [r7, #4]
   28fe2:	3301      	adds	r3, #1
   28fe4:	781b      	ldrb	r3, [r3, #0]
   28fe6:	b29a      	uxth	r2, r3
   28fe8:	687b      	ldr	r3, [r7, #4]
   28fea:	3302      	adds	r3, #2
   28fec:	781b      	ldrb	r3, [r3, #0]
   28fee:	b29b      	uxth	r3, r3
   28ff0:	021b      	lsls	r3, r3, #8
   28ff2:	b29b      	uxth	r3, r3
   28ff4:	4413      	add	r3, r2
   28ff6:	827b      	strh	r3, [r7, #18]
      hciCoreConnClose(handle);
   28ff8:	8a7b      	ldrh	r3, [r7, #18]
   28ffa:	4618      	mov	r0, r3
   28ffc:	f7fc fdc7 	bl	25b8e <hciCoreConnClose>
    }
  }
}
   29000:	bf00      	nop
   29002:	3720      	adds	r7, #32
   29004:	46bd      	mov	sp, r7
   29006:	bd80      	pop	{r7, pc}
   29008:	000450ac 	.word	0x000450ac
   2900c:	10003f80 	.word	0x10003f80
   29010:	00045e90 	.word	0x00045e90
   29014:	00045d84 	.word	0x00045d84

00029018 <HciEvtRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciEvtRegister(hciEvtCback_t evtCback)
{
   29018:	b480      	push	{r7}
   2901a:	b083      	sub	sp, #12
   2901c:	af00      	add	r7, sp, #0
   2901e:	6078      	str	r0, [r7, #4]
  hciCb.evtCback = evtCback;
   29020:	4a04      	ldr	r2, [pc, #16]	; (29034 <HciEvtRegister+0x1c>)
   29022:	687b      	ldr	r3, [r7, #4]
   29024:	6093      	str	r3, [r2, #8]
}
   29026:	bf00      	nop
   29028:	370c      	adds	r7, #12
   2902a:	46bd      	mov	sp, r7
   2902c:	f85d 7b04 	ldr.w	r7, [sp], #4
   29030:	4770      	bx	lr
   29032:	bf00      	nop
   29034:	100116ec 	.word	0x100116ec

00029038 <HciSecRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciSecRegister(hciSecCback_t secCback)
{
   29038:	b480      	push	{r7}
   2903a:	b083      	sub	sp, #12
   2903c:	af00      	add	r7, sp, #0
   2903e:	6078      	str	r0, [r7, #4]
  hciCb.secCback = secCback;
   29040:	4a04      	ldr	r2, [pc, #16]	; (29054 <HciSecRegister+0x1c>)
   29042:	687b      	ldr	r3, [r7, #4]
   29044:	60d3      	str	r3, [r2, #12]
}
   29046:	bf00      	nop
   29048:	370c      	adds	r7, #12
   2904a:	46bd      	mov	sp, r7
   2904c:	f85d 7b04 	ldr.w	r7, [sp], #4
   29050:	4770      	bx	lr
   29052:	bf00      	nop
   29054:	100116ec 	.word	0x100116ec

00029058 <HciAclRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciAclRegister(hciAclCback_t aclCback, hciFlowCback_t flowCback)
{
   29058:	b480      	push	{r7}
   2905a:	b083      	sub	sp, #12
   2905c:	af00      	add	r7, sp, #0
   2905e:	6078      	str	r0, [r7, #4]
   29060:	6039      	str	r1, [r7, #0]
  hciCb.aclCback = aclCback;
   29062:	4a06      	ldr	r2, [pc, #24]	; (2907c <HciAclRegister+0x24>)
   29064:	687b      	ldr	r3, [r7, #4]
   29066:	6113      	str	r3, [r2, #16]
  hciCb.flowCback = flowCback;
   29068:	4a04      	ldr	r2, [pc, #16]	; (2907c <HciAclRegister+0x24>)
   2906a:	683b      	ldr	r3, [r7, #0]
   2906c:	6153      	str	r3, [r2, #20]
}
   2906e:	bf00      	nop
   29070:	370c      	adds	r7, #12
   29072:	46bd      	mov	sp, r7
   29074:	f85d 7b04 	ldr.w	r7, [sp], #4
   29078:	4770      	bx	lr
   2907a:	bf00      	nop
   2907c:	100116ec 	.word	0x100116ec

00029080 <HciHandlerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciHandlerInit(wsfHandlerId_t handlerId)
{
   29080:	b580      	push	{r7, lr}
   29082:	b082      	sub	sp, #8
   29084:	af00      	add	r7, sp, #0
   29086:	4603      	mov	r3, r0
   29088:	71fb      	strb	r3, [r7, #7]
  /* store handler ID */
  hciCb.handlerId = handlerId;
   2908a:	4a07      	ldr	r2, [pc, #28]	; (290a8 <HciHandlerInit+0x28>)
   2908c:	79fb      	ldrb	r3, [r7, #7]
   2908e:	7613      	strb	r3, [r2, #24]

  /* init rx queue */
  WSF_QUEUE_INIT(&hciCb.rxQueue);
   29090:	4b05      	ldr	r3, [pc, #20]	; (290a8 <HciHandlerInit+0x28>)
   29092:	2200      	movs	r2, #0
   29094:	601a      	str	r2, [r3, #0]
   29096:	4b04      	ldr	r3, [pc, #16]	; (290a8 <HciHandlerInit+0x28>)
   29098:	2200      	movs	r2, #0
   2909a:	605a      	str	r2, [r3, #4]

  /* perform other hci initialization */
  HciCoreInit();
   2909c:	f7fc fff4 	bl	26088 <HciCoreInit>
}
   290a0:	bf00      	nop
   290a2:	3708      	adds	r7, #8
   290a4:	46bd      	mov	sp, r7
   290a6:	bd80      	pop	{r7, pc}
   290a8:	100116ec 	.word	0x100116ec

000290ac <HciHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   290ac:	b580      	push	{r7, lr}
   290ae:	b082      	sub	sp, #8
   290b0:	af00      	add	r7, sp, #0
   290b2:	4603      	mov	r3, r0
   290b4:	6039      	str	r1, [r7, #0]
   290b6:	71fb      	strb	r3, [r7, #7]
  HciCoreHandler(event, pMsg);
   290b8:	79fb      	ldrb	r3, [r7, #7]
   290ba:	6839      	ldr	r1, [r7, #0]
   290bc:	4618      	mov	r0, r3
   290be:	f7fd f96b 	bl	26398 <HciCoreHandler>
}
   290c2:	bf00      	nop
   290c4:	3708      	adds	r7, #8
   290c6:	46bd      	mov	sp, r7
   290c8:	bd80      	pop	{r7, pc}

000290ca <hciTrSendAclData>:
 *
 *  \return The length of ACL packet.
 */
/*************************************************************************************************/
uint16_t hciTrSendAclData(void *pContext, uint8_t *pData)
{
   290ca:	b580      	push	{r7, lr}
   290cc:	b084      	sub	sp, #16
   290ce:	af00      	add	r7, sp, #0
   290d0:	6078      	str	r0, [r7, #4]
   290d2:	6039      	str	r1, [r7, #0]
  uint16_t   len;

  /* get 16-bit length */
  BYTES_TO_UINT16(len, &pData[2]);
   290d4:	683b      	ldr	r3, [r7, #0]
   290d6:	3302      	adds	r3, #2
   290d8:	781b      	ldrb	r3, [r3, #0]
   290da:	b29a      	uxth	r2, r3
   290dc:	683b      	ldr	r3, [r7, #0]
   290de:	3303      	adds	r3, #3
   290e0:	781b      	ldrb	r3, [r3, #0]
   290e2:	b29b      	uxth	r3, r3
   290e4:	021b      	lsls	r3, r3, #8
   290e6:	b29b      	uxth	r3, r3
   290e8:	4413      	add	r3, r2
   290ea:	81fb      	strh	r3, [r7, #14]
  len += HCI_ACL_HDR_LEN;
   290ec:	89fb      	ldrh	r3, [r7, #14]
   290ee:	3304      	adds	r3, #4
   290f0:	81fb      	strh	r3, [r7, #14]

  /* transmit ACL header and data */
  if (hciDrvWrite(HCI_ACL_TYPE, len, pData) == len)
   290f2:	89fb      	ldrh	r3, [r7, #14]
   290f4:	683a      	ldr	r2, [r7, #0]
   290f6:	4619      	mov	r1, r3
   290f8:	2002      	movs	r0, #2
   290fa:	f7fd fcc1 	bl	26a80 <hciDrvWrite>
   290fe:	4603      	mov	r3, r0
   29100:	461a      	mov	r2, r3
   29102:	89fb      	ldrh	r3, [r7, #14]
   29104:	4293      	cmp	r3, r2
   29106:	d101      	bne.n	2910c <hciTrSendAclData+0x42>
  {
      /* dump event for protocol analysis */
      HCI_PDUMP_TX_ACL(len, pData);
      return len;
   29108:	89fb      	ldrh	r3, [r7, #14]
   2910a:	e000      	b.n	2910e <hciTrSendAclData+0x44>
  }
  else
  {
      return 0;
   2910c:	2300      	movs	r3, #0
  }
}
   2910e:	4618      	mov	r0, r3
   29110:	3710      	adds	r7, #16
   29112:	46bd      	mov	sp, r7
   29114:	bd80      	pop	{r7, pc}

00029116 <hciTrSendCmd>:
 *
 *  \return TRUE if packet sent, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t hciTrSendCmd(uint8_t *pData)
{
   29116:	b580      	push	{r7, lr}
   29118:	b084      	sub	sp, #16
   2911a:	af00      	add	r7, sp, #0
   2911c:	6078      	str	r0, [r7, #4]
  uint16_t   len;  // in case like LE set periodic advertising data, the maximum HCI command parameter length is 255

  /* get length */
  len = pData[2] + HCI_CMD_HDR_LEN;
   2911e:	687b      	ldr	r3, [r7, #4]
   29120:	3302      	adds	r3, #2
   29122:	781b      	ldrb	r3, [r3, #0]
   29124:	b29b      	uxth	r3, r3
   29126:	3303      	adds	r3, #3
   29128:	81fb      	strh	r3, [r7, #14]

  /* transmit ACL header and data */
  if (hciDrvWrite(HCI_CMD_TYPE, len, pData) == len)
   2912a:	89fb      	ldrh	r3, [r7, #14]
   2912c:	687a      	ldr	r2, [r7, #4]
   2912e:	4619      	mov	r1, r3
   29130:	2001      	movs	r0, #1
   29132:	f7fd fca5 	bl	26a80 <hciDrvWrite>
   29136:	4603      	mov	r3, r0
   29138:	461a      	mov	r2, r3
   2913a:	89fb      	ldrh	r3, [r7, #14]
   2913c:	4293      	cmp	r3, r2
   2913e:	d101      	bne.n	29144 <hciTrSendCmd+0x2e>
  {
      /* dump event for protocol analysis */
      HCI_PDUMP_CMD(len, pData);
      return TRUE;
   29140:	2301      	movs	r3, #1
   29142:	e000      	b.n	29146 <hciTrSendCmd+0x30>
  }
  return FALSE;
   29144:	2300      	movs	r3, #0
}
   29146:	4618      	mov	r0, r3
   29148:	3710      	adds	r7, #16
   2914a:	46bd      	mov	sp, r7
   2914c:	bd80      	pop	{r7, pc}
	...

00029150 <hciTrSerialRxIncoming>:
 *
 *  \return The number of bytes consumed.
 */
/*************************************************************************************************/
uint16_t hciTrSerialRxIncoming(uint8_t *pBuf, uint16_t len)
{
   29150:	b580      	push	{r7, lr}
   29152:	b086      	sub	sp, #24
   29154:	af00      	add	r7, sp, #0
   29156:	6078      	str	r0, [r7, #4]
   29158:	460b      	mov	r3, r1
   2915a:	807b      	strh	r3, [r7, #2]
  static uint8_t    *pPktRx;
  static uint8_t    *pDataRx;

  uint8_t   dataByte;
  uint16_t  consumed_bytes;
  uint16_t  received_bytes = len;
   2915c:	887b      	ldrh	r3, [r7, #2]
   2915e:	81fb      	strh	r3, [r7, #14]

  consumed_bytes = 0;
   29160:	2300      	movs	r3, #0
   29162:	82fb      	strh	r3, [r7, #22]
  /* loop until all bytes of incoming buffer are handled */
  while (len)
   29164:	e102      	b.n	2936c <hciTrSerialRxIncoming+0x21c>
  {
    /* read single byte from incoming buffer and advance to next byte */
    dataByte = *pBuf;
   29166:	687b      	ldr	r3, [r7, #4]
   29168:	781b      	ldrb	r3, [r3, #0]
   2916a:	737b      	strb	r3, [r7, #13]

    /* --- Idle State --- */
    if (stateRx == HCI_RX_STATE_IDLE)
   2916c:	4b84      	ldr	r3, [pc, #528]	; (29380 <hciTrSerialRxIncoming+0x230>)
   2916e:	781b      	ldrb	r3, [r3, #0]
   29170:	2b00      	cmp	r3, #0
   29172:	d115      	bne.n	291a0 <hciTrSerialRxIncoming+0x50>
    {
      /* save the packet type */
      pktIndRx = dataByte;
   29174:	4a83      	ldr	r2, [pc, #524]	; (29384 <hciTrSerialRxIncoming+0x234>)
   29176:	7b7b      	ldrb	r3, [r7, #13]
   29178:	7013      	strb	r3, [r2, #0]
      iRx      = 0;
   2917a:	4b83      	ldr	r3, [pc, #524]	; (29388 <hciTrSerialRxIncoming+0x238>)
   2917c:	2200      	movs	r2, #0
   2917e:	801a      	strh	r2, [r3, #0]
      stateRx  = HCI_RX_STATE_HEADER;
   29180:	4b7f      	ldr	r3, [pc, #508]	; (29380 <hciTrSerialRxIncoming+0x230>)
   29182:	2201      	movs	r2, #1
   29184:	701a      	strb	r2, [r3, #0]
      g_bHCIReceivingPacket = TRUE;
   29186:	4b81      	ldr	r3, [pc, #516]	; (2938c <hciTrSerialRxIncoming+0x23c>)
   29188:	2201      	movs	r2, #1
   2918a:	701a      	strb	r2, [r3, #0]
      pBuf++;
   2918c:	687b      	ldr	r3, [r7, #4]
   2918e:	3301      	adds	r3, #1
   29190:	607b      	str	r3, [r7, #4]
      consumed_bytes++;
   29192:	8afb      	ldrh	r3, [r7, #22]
   29194:	3301      	adds	r3, #1
   29196:	82fb      	strh	r3, [r7, #22]
      len--;
   29198:	887b      	ldrh	r3, [r7, #2]
   2919a:	3b01      	subs	r3, #1
   2919c:	807b      	strh	r3, [r7, #2]
   2919e:	e0cf      	b.n	29340 <hciTrSerialRxIncoming+0x1f0>
    }

    /* --- Header State --- */
    else if (stateRx == HCI_RX_STATE_HEADER)
   291a0:	4b77      	ldr	r3, [pc, #476]	; (29380 <hciTrSerialRxIncoming+0x230>)
   291a2:	781b      	ldrb	r3, [r3, #0]
   291a4:	2b01      	cmp	r3, #1
   291a6:	f040 80aa 	bne.w	292fe <hciTrSerialRxIncoming+0x1ae>
    {
      uint8_t  hdrLen = 0;
   291aa:	2300      	movs	r3, #0
   291ac:	757b      	strb	r3, [r7, #21]
      uint16_t dataLen = 0;
   291ae:	2300      	movs	r3, #0
   291b0:	827b      	strh	r3, [r7, #18]

      /* determine header length based on packet type */
      if (pktIndRx == HCI_EVT_TYPE)
   291b2:	4b74      	ldr	r3, [pc, #464]	; (29384 <hciTrSerialRxIncoming+0x234>)
   291b4:	781b      	ldrb	r3, [r3, #0]
   291b6:	2b04      	cmp	r3, #4
   291b8:	d102      	bne.n	291c0 <hciTrSerialRxIncoming+0x70>
      {
        hdrLen = HCI_EVT_HDR_LEN;
   291ba:	2302      	movs	r3, #2
   291bc:	757b      	strb	r3, [r7, #21]
   291be:	e00d      	b.n	291dc <hciTrSerialRxIncoming+0x8c>
      }
      else if (pktIndRx == HCI_ACL_TYPE)
   291c0:	4b70      	ldr	r3, [pc, #448]	; (29384 <hciTrSerialRxIncoming+0x234>)
   291c2:	781b      	ldrb	r3, [r3, #0]
   291c4:	2b02      	cmp	r3, #2
   291c6:	d102      	bne.n	291ce <hciTrSerialRxIncoming+0x7e>
      {
        hdrLen = HCI_ACL_HDR_LEN;
   291c8:	2304      	movs	r3, #4
   291ca:	757b      	strb	r3, [r7, #21]
   291cc:	e006      	b.n	291dc <hciTrSerialRxIncoming+0x8c>
      }
      else
      {
        /* invalid packet type, discard this packet */
        stateRx = HCI_RX_STATE_IDLE;
   291ce:	4b6c      	ldr	r3, [pc, #432]	; (29380 <hciTrSerialRxIncoming+0x230>)
   291d0:	2200      	movs	r2, #0
   291d2:	701a      	strb	r2, [r3, #0]
        consumed_bytes = received_bytes;
   291d4:	89fb      	ldrh	r3, [r7, #14]
   291d6:	82fb      	strh	r3, [r7, #22]
        return consumed_bytes;
   291d8:	8afb      	ldrh	r3, [r7, #22]
   291da:	e0cc      	b.n	29376 <hciTrSerialRxIncoming+0x226>
      }

      if (iRx != hdrLen) {
   291dc:	7d7b      	ldrb	r3, [r7, #21]
   291de:	b29a      	uxth	r2, r3
   291e0:	4b69      	ldr	r3, [pc, #420]	; (29388 <hciTrSerialRxIncoming+0x238>)
   291e2:	881b      	ldrh	r3, [r3, #0]
   291e4:	429a      	cmp	r2, r3
   291e6:	d012      	beq.n	2920e <hciTrSerialRxIncoming+0xbe>
        /* copy current byte into the temp header buffer */
        hdrRx[iRx++] = dataByte;
   291e8:	4b67      	ldr	r3, [pc, #412]	; (29388 <hciTrSerialRxIncoming+0x238>)
   291ea:	881b      	ldrh	r3, [r3, #0]
   291ec:	1c5a      	adds	r2, r3, #1
   291ee:	b291      	uxth	r1, r2
   291f0:	4a65      	ldr	r2, [pc, #404]	; (29388 <hciTrSerialRxIncoming+0x238>)
   291f2:	8011      	strh	r1, [r2, #0]
   291f4:	4619      	mov	r1, r3
   291f6:	4a66      	ldr	r2, [pc, #408]	; (29390 <hciTrSerialRxIncoming+0x240>)
   291f8:	7b7b      	ldrb	r3, [r7, #13]
   291fa:	5453      	strb	r3, [r2, r1]
        pBuf++;
   291fc:	687b      	ldr	r3, [r7, #4]
   291fe:	3301      	adds	r3, #1
   29200:	607b      	str	r3, [r7, #4]
        consumed_bytes++;
   29202:	8afb      	ldrh	r3, [r7, #22]
   29204:	3301      	adds	r3, #1
   29206:	82fb      	strh	r3, [r7, #22]
        len--;
   29208:	887b      	ldrh	r3, [r7, #2]
   2920a:	3b01      	subs	r3, #1
   2920c:	807b      	strh	r3, [r7, #2]
      }

      /* see if entire header has been read */
      if (iRx == hdrLen)
   2920e:	7d7b      	ldrb	r3, [r7, #21]
   29210:	b29a      	uxth	r2, r3
   29212:	4b5d      	ldr	r3, [pc, #372]	; (29388 <hciTrSerialRxIncoming+0x238>)
   29214:	881b      	ldrh	r3, [r3, #0]
   29216:	429a      	cmp	r2, r3
   29218:	f040 8092 	bne.w	29340 <hciTrSerialRxIncoming+0x1f0>
      {
        /* extract data length from header */
        if (pktIndRx == HCI_EVT_TYPE)
   2921c:	4b59      	ldr	r3, [pc, #356]	; (29384 <hciTrSerialRxIncoming+0x234>)
   2921e:	781b      	ldrb	r3, [r3, #0]
   29220:	2b04      	cmp	r3, #4
   29222:	d103      	bne.n	2922c <hciTrSerialRxIncoming+0xdc>
        {
          dataLen = hdrRx[1];
   29224:	4b5a      	ldr	r3, [pc, #360]	; (29390 <hciTrSerialRxIncoming+0x240>)
   29226:	785b      	ldrb	r3, [r3, #1]
   29228:	827b      	strh	r3, [r7, #18]
   2922a:	e00d      	b.n	29248 <hciTrSerialRxIncoming+0xf8>
        }
        else if (pktIndRx == HCI_ACL_TYPE)
   2922c:	4b55      	ldr	r3, [pc, #340]	; (29384 <hciTrSerialRxIncoming+0x234>)
   2922e:	781b      	ldrb	r3, [r3, #0]
   29230:	2b02      	cmp	r3, #2
   29232:	d109      	bne.n	29248 <hciTrSerialRxIncoming+0xf8>
        {
          BYTES_TO_UINT16(dataLen, &hdrRx[2]);
   29234:	4b56      	ldr	r3, [pc, #344]	; (29390 <hciTrSerialRxIncoming+0x240>)
   29236:	789b      	ldrb	r3, [r3, #2]
   29238:	b29a      	uxth	r2, r3
   2923a:	4b56      	ldr	r3, [pc, #344]	; (29394 <hciTrSerialRxIncoming+0x244>)
   2923c:	781b      	ldrb	r3, [r3, #0]
   2923e:	b29b      	uxth	r3, r3
   29240:	021b      	lsls	r3, r3, #8
   29242:	b29b      	uxth	r3, r3
   29244:	4413      	add	r3, r2
   29246:	827b      	strh	r3, [r7, #18]
        }

        /* allocate data buffer to hold entire packet */
        if ((pktIndRx == HCI_ACL_TYPE) && (dataLen <= HciGetMaxRxAclLen()))
   29248:	4b4e      	ldr	r3, [pc, #312]	; (29384 <hciTrSerialRxIncoming+0x234>)
   2924a:	781b      	ldrb	r3, [r3, #0]
   2924c:	2b02      	cmp	r3, #2
   2924e:	d113      	bne.n	29278 <hciTrSerialRxIncoming+0x128>
   29250:	f7fd f90a 	bl	26468 <HciGetMaxRxAclLen>
   29254:	4603      	mov	r3, r0
   29256:	461a      	mov	r2, r3
   29258:	8a7b      	ldrh	r3, [r7, #18]
   2925a:	4293      	cmp	r3, r2
   2925c:	d80c      	bhi.n	29278 <hciTrSerialRxIncoming+0x128>
        {
          pPktRx = (uint8_t*)WsfMsgDataAlloc(hdrLen + dataLen, 0);
   2925e:	7d7b      	ldrb	r3, [r7, #21]
   29260:	b29a      	uxth	r2, r3
   29262:	8a7b      	ldrh	r3, [r7, #18]
   29264:	4413      	add	r3, r2
   29266:	b29b      	uxth	r3, r3
   29268:	2100      	movs	r1, #0
   2926a:	4618      	mov	r0, r3
   2926c:	f003 ff0a 	bl	2d084 <WsfMsgDataAlloc>
   29270:	4603      	mov	r3, r0
   29272:	4a49      	ldr	r2, [pc, #292]	; (29398 <hciTrSerialRxIncoming+0x248>)
   29274:	6013      	str	r3, [r2, #0]
   29276:	e011      	b.n	2929c <hciTrSerialRxIncoming+0x14c>
        }
        else if ((pktIndRx == HCI_EVT_TYPE) && (dataLen <= HCI_EVT_PARAM_MAX_LEN))
   29278:	4b42      	ldr	r3, [pc, #264]	; (29384 <hciTrSerialRxIncoming+0x234>)
   2927a:	781b      	ldrb	r3, [r3, #0]
   2927c:	2b04      	cmp	r3, #4
   2927e:	d10d      	bne.n	2929c <hciTrSerialRxIncoming+0x14c>
   29280:	8a7b      	ldrh	r3, [r7, #18]
   29282:	2bff      	cmp	r3, #255	; 0xff
   29284:	d80a      	bhi.n	2929c <hciTrSerialRxIncoming+0x14c>
        {
          pPktRx = (uint8_t*)WsfMsgAlloc(hdrLen + dataLen);
   29286:	7d7b      	ldrb	r3, [r7, #21]
   29288:	b29a      	uxth	r2, r3
   2928a:	8a7b      	ldrh	r3, [r7, #18]
   2928c:	4413      	add	r3, r2
   2928e:	b29b      	uxth	r3, r3
   29290:	4618      	mov	r0, r3
   29292:	f003 ff0c 	bl	2d0ae <WsfMsgAlloc>
   29296:	4603      	mov	r3, r0
   29298:	4a3f      	ldr	r2, [pc, #252]	; (29398 <hciTrSerialRxIncoming+0x248>)
   2929a:	6013      	str	r3, [r2, #0]
        }

        if (pPktRx != NULL)
   2929c:	4b3e      	ldr	r3, [pc, #248]	; (29398 <hciTrSerialRxIncoming+0x248>)
   2929e:	681b      	ldr	r3, [r3, #0]
   292a0:	2b00      	cmp	r3, #0
   292a2:	d025      	beq.n	292f0 <hciTrSerialRxIncoming+0x1a0>
        {
          pDataRx = pPktRx;
   292a4:	4b3c      	ldr	r3, [pc, #240]	; (29398 <hciTrSerialRxIncoming+0x248>)
   292a6:	681b      	ldr	r3, [r3, #0]
   292a8:	4a3c      	ldr	r2, [pc, #240]	; (2939c <hciTrSerialRxIncoming+0x24c>)
   292aa:	6013      	str	r3, [r2, #0]

          /* copy header into data packet (note: memcpy is not so portable) */
          {
            uint8_t  i;
            for (i = 0; i < hdrLen; i++)
   292ac:	2300      	movs	r3, #0
   292ae:	747b      	strb	r3, [r7, #17]
   292b0:	e00b      	b.n	292ca <hciTrSerialRxIncoming+0x17a>
            {
              *pDataRx++ = hdrRx[i];
   292b2:	7c7a      	ldrb	r2, [r7, #17]
   292b4:	4b39      	ldr	r3, [pc, #228]	; (2939c <hciTrSerialRxIncoming+0x24c>)
   292b6:	681b      	ldr	r3, [r3, #0]
   292b8:	1c59      	adds	r1, r3, #1
   292ba:	4838      	ldr	r0, [pc, #224]	; (2939c <hciTrSerialRxIncoming+0x24c>)
   292bc:	6001      	str	r1, [r0, #0]
   292be:	4934      	ldr	r1, [pc, #208]	; (29390 <hciTrSerialRxIncoming+0x240>)
   292c0:	5c8a      	ldrb	r2, [r1, r2]
   292c2:	701a      	strb	r2, [r3, #0]
            for (i = 0; i < hdrLen; i++)
   292c4:	7c7b      	ldrb	r3, [r7, #17]
   292c6:	3301      	adds	r3, #1
   292c8:	747b      	strb	r3, [r7, #17]
   292ca:	7c7a      	ldrb	r2, [r7, #17]
   292cc:	7d7b      	ldrb	r3, [r7, #21]
   292ce:	429a      	cmp	r2, r3
   292d0:	d3ef      	bcc.n	292b2 <hciTrSerialRxIncoming+0x162>
            }
          }

          /* save number of bytes left to read */
          iRx = dataLen;
   292d2:	4a2d      	ldr	r2, [pc, #180]	; (29388 <hciTrSerialRxIncoming+0x238>)
   292d4:	8a7b      	ldrh	r3, [r7, #18]
   292d6:	8013      	strh	r3, [r2, #0]
          if (iRx == 0)
   292d8:	4b2b      	ldr	r3, [pc, #172]	; (29388 <hciTrSerialRxIncoming+0x238>)
   292da:	881b      	ldrh	r3, [r3, #0]
   292dc:	2b00      	cmp	r3, #0
   292de:	d103      	bne.n	292e8 <hciTrSerialRxIncoming+0x198>
          {
            stateRx = HCI_RX_STATE_COMPLETE;
   292e0:	4b27      	ldr	r3, [pc, #156]	; (29380 <hciTrSerialRxIncoming+0x230>)
   292e2:	2203      	movs	r2, #3
   292e4:	701a      	strb	r2, [r3, #0]
   292e6:	e02b      	b.n	29340 <hciTrSerialRxIncoming+0x1f0>
          }
          else
          {
            stateRx = HCI_RX_STATE_DATA;
   292e8:	4b25      	ldr	r3, [pc, #148]	; (29380 <hciTrSerialRxIncoming+0x230>)
   292ea:	2202      	movs	r2, #2
   292ec:	701a      	strb	r2, [r3, #0]
   292ee:	e027      	b.n	29340 <hciTrSerialRxIncoming+0x1f0>
          }
        }
        else
        {
          /* allocate fails or gets invalid data length, discard this packet */
          stateRx = HCI_RX_STATE_IDLE;
   292f0:	4b23      	ldr	r3, [pc, #140]	; (29380 <hciTrSerialRxIncoming+0x230>)
   292f2:	2200      	movs	r2, #0
   292f4:	701a      	strb	r2, [r3, #0]
          consumed_bytes = received_bytes;
   292f6:	89fb      	ldrh	r3, [r7, #14]
   292f8:	82fb      	strh	r3, [r7, #22]
          return consumed_bytes;
   292fa:	8afb      	ldrh	r3, [r7, #22]
   292fc:	e03b      	b.n	29376 <hciTrSerialRxIncoming+0x226>

      }
    }

    /* --- Data State --- */
    else if (stateRx == HCI_RX_STATE_DATA)
   292fe:	4b20      	ldr	r3, [pc, #128]	; (29380 <hciTrSerialRxIncoming+0x230>)
   29300:	781b      	ldrb	r3, [r3, #0]
   29302:	2b02      	cmp	r3, #2
   29304:	d11c      	bne.n	29340 <hciTrSerialRxIncoming+0x1f0>
    {
      /* write incoming byte to allocated buffer */
      *pDataRx++ = dataByte;
   29306:	4b25      	ldr	r3, [pc, #148]	; (2939c <hciTrSerialRxIncoming+0x24c>)
   29308:	681b      	ldr	r3, [r3, #0]
   2930a:	1c5a      	adds	r2, r3, #1
   2930c:	4923      	ldr	r1, [pc, #140]	; (2939c <hciTrSerialRxIncoming+0x24c>)
   2930e:	600a      	str	r2, [r1, #0]
   29310:	7b7a      	ldrb	r2, [r7, #13]
   29312:	701a      	strb	r2, [r3, #0]

      /* determine if entire packet has been read */
      iRx--;
   29314:	4b1c      	ldr	r3, [pc, #112]	; (29388 <hciTrSerialRxIncoming+0x238>)
   29316:	881b      	ldrh	r3, [r3, #0]
   29318:	3b01      	subs	r3, #1
   2931a:	b29a      	uxth	r2, r3
   2931c:	4b1a      	ldr	r3, [pc, #104]	; (29388 <hciTrSerialRxIncoming+0x238>)
   2931e:	801a      	strh	r2, [r3, #0]
      if (iRx == 0)
   29320:	4b19      	ldr	r3, [pc, #100]	; (29388 <hciTrSerialRxIncoming+0x238>)
   29322:	881b      	ldrh	r3, [r3, #0]
   29324:	2b00      	cmp	r3, #0
   29326:	d102      	bne.n	2932e <hciTrSerialRxIncoming+0x1de>
      {
        stateRx = HCI_RX_STATE_COMPLETE;
   29328:	4b15      	ldr	r3, [pc, #84]	; (29380 <hciTrSerialRxIncoming+0x230>)
   2932a:	2203      	movs	r2, #3
   2932c:	701a      	strb	r2, [r3, #0]
      }
      pBuf++;
   2932e:	687b      	ldr	r3, [r7, #4]
   29330:	3301      	adds	r3, #1
   29332:	607b      	str	r3, [r7, #4]
      consumed_bytes++;
   29334:	8afb      	ldrh	r3, [r7, #22]
   29336:	3301      	adds	r3, #1
   29338:	82fb      	strh	r3, [r7, #22]
      len--;
   2933a:	887b      	ldrh	r3, [r7, #2]
   2933c:	3b01      	subs	r3, #1
   2933e:	807b      	strh	r3, [r7, #2]
    }

    /* --- Complete State --- */
    /* ( Note Well!  There is no else-if construct by design. ) */
    if (stateRx == HCI_RX_STATE_COMPLETE)
   29340:	4b0f      	ldr	r3, [pc, #60]	; (29380 <hciTrSerialRxIncoming+0x230>)
   29342:	781b      	ldrb	r3, [r3, #0]
   29344:	2b03      	cmp	r3, #3
   29346:	d111      	bne.n	2936c <hciTrSerialRxIncoming+0x21c>
    {
      g_bHCIReceivingPacket = FALSE;
   29348:	4b10      	ldr	r3, [pc, #64]	; (2938c <hciTrSerialRxIncoming+0x23c>)
   2934a:	2200      	movs	r2, #0
   2934c:	701a      	strb	r2, [r3, #0]

      /* deliver data */
      if (pPktRx != NULL)
   2934e:	4b12      	ldr	r3, [pc, #72]	; (29398 <hciTrSerialRxIncoming+0x248>)
   29350:	681b      	ldr	r3, [r3, #0]
   29352:	2b00      	cmp	r3, #0
   29354:	d007      	beq.n	29366 <hciTrSerialRxIncoming+0x216>
      {
        //am_hal_gpio_out_bit_set(13);
        hciCoreRecv(pktIndRx, pPktRx);
   29356:	4b0b      	ldr	r3, [pc, #44]	; (29384 <hciTrSerialRxIncoming+0x234>)
   29358:	781b      	ldrb	r3, [r3, #0]
   2935a:	4a0f      	ldr	r2, [pc, #60]	; (29398 <hciTrSerialRxIncoming+0x248>)
   2935c:	6812      	ldr	r2, [r2, #0]
   2935e:	4611      	mov	r1, r2
   29360:	4618      	mov	r0, r3
   29362:	f7fd f801 	bl	26368 <hciCoreRecv>
        //am_hal_gpio_out_bit_clear(13);
      }

      /* reset state machine */
      stateRx = HCI_RX_STATE_IDLE;
   29366:	4b06      	ldr	r3, [pc, #24]	; (29380 <hciTrSerialRxIncoming+0x230>)
   29368:	2200      	movs	r2, #0
   2936a:	701a      	strb	r2, [r3, #0]
  while (len)
   2936c:	887b      	ldrh	r3, [r7, #2]
   2936e:	2b00      	cmp	r3, #0
   29370:	f47f aef9 	bne.w	29166 <hciTrSerialRxIncoming+0x16>
    }
  }
  return consumed_bytes;
   29374:	8afb      	ldrh	r3, [r7, #22]
}
   29376:	4618      	mov	r0, r3
   29378:	3718      	adds	r7, #24
   2937a:	46bd      	mov	sp, r7
   2937c:	bd80      	pop	{r7, pc}
   2937e:	bf00      	nop
   29380:	10003f99 	.word	0x10003f99
   29384:	10003f9a 	.word	0x10003f9a
   29388:	10003f9c 	.word	0x10003f9c
   2938c:	10003f98 	.word	0x10003f98
   29390:	10003fa0 	.word	0x10003fa0
   29394:	10003fa3 	.word	0x10003fa3
   29398:	10003fa4 	.word	0x10003fa4
   2939c:	10003fa8 	.word	0x10003fa8

000293a0 <hciCoreReadResolvingListSize>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciCoreReadResolvingListSize(void)
{
   293a0:	b580      	push	{r7, lr}
   293a2:	af00      	add	r7, sp, #0
  /* if LL Privacy is supported by Controller and included */
  if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_PRIVACY) &&
   293a4:	4b0b      	ldr	r3, [pc, #44]	; (293d4 <hciCoreReadResolvingListSize+0x34>)
   293a6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   293a8:	f003 0340 	and.w	r3, r3, #64	; 0x40
   293ac:	2b00      	cmp	r3, #0
   293ae:	d008      	beq.n	293c2 <hciCoreReadResolvingListSize+0x22>
      (hciLeSupFeatCfg & HCI_LE_SUP_FEAT_PRIVACY))
   293b0:	4b09      	ldr	r3, [pc, #36]	; (293d8 <hciCoreReadResolvingListSize+0x38>)
   293b2:	681b      	ldr	r3, [r3, #0]
   293b4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_PRIVACY) &&
   293b8:	2b00      	cmp	r3, #0
   293ba:	d002      	beq.n	293c2 <hciCoreReadResolvingListSize+0x22>
  {
    /* send next command in sequence */
    HciLeReadResolvingListSize();
   293bc:	f7fc fae9 	bl	25992 <HciLeReadResolvingListSize>
   293c0:	e006      	b.n	293d0 <hciCoreReadResolvingListSize+0x30>
  }
  else
  {
    hciCoreCb.resListSize = 0;
   293c2:	4b04      	ldr	r3, [pc, #16]	; (293d4 <hciCoreReadResolvingListSize+0x34>)
   293c4:	2200      	movs	r2, #0
   293c6:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81

    /* send next command in sequence */
    hciCoreReadMaxDataLen();
   293ca:	f000 f807 	bl	293dc <hciCoreReadMaxDataLen>
  }
}
   293ce:	bf00      	nop
   293d0:	bf00      	nop
   293d2:	bd80      	pop	{r7, pc}
   293d4:	1001134c 	.word	0x1001134c
   293d8:	10002bc8 	.word	0x10002bc8

000293dc <hciCoreReadMaxDataLen>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void hciCoreReadMaxDataLen(void)
{
   293dc:	b580      	push	{r7, lr}
   293de:	af00      	add	r7, sp, #0
  /* if LE Data Packet Length Extensions is supported by Controller and included */
  if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_DATA_LEN_EXT) &&
   293e0:	4b09      	ldr	r3, [pc, #36]	; (29408 <hciCoreReadMaxDataLen+0x2c>)
   293e2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
   293e4:	f003 0320 	and.w	r3, r3, #32
   293e8:	2b00      	cmp	r3, #0
   293ea:	d008      	beq.n	293fe <hciCoreReadMaxDataLen+0x22>
      (hciLeSupFeatCfg & HCI_LE_SUP_FEAT_DATA_LEN_EXT))
   293ec:	4b07      	ldr	r3, [pc, #28]	; (2940c <hciCoreReadMaxDataLen+0x30>)
   293ee:	681b      	ldr	r3, [r3, #0]
   293f0:	f003 0320 	and.w	r3, r3, #32
  if ((hciCoreCb.leSupFeat & HCI_LE_SUP_FEAT_DATA_LEN_EXT) &&
   293f4:	2b00      	cmp	r3, #0
   293f6:	d002      	beq.n	293fe <hciCoreReadMaxDataLen+0x22>
  {
    /* send next command in sequence */
    HciLeReadMaxDataLen();
   293f8:	f7fb ffb7 	bl	2536a <HciLeReadMaxDataLen>
   293fc:	e002      	b.n	29404 <hciCoreReadMaxDataLen+0x28>
  }
  else
  {
    /* send next command in sequence */
    HciLeRandCmd();
   293fe:	f7fb ffec 	bl	253da <HciLeRandCmd>
  }
}
   29402:	bf00      	nop
   29404:	bf00      	nop
   29406:	bd80      	pop	{r7, pc}
   29408:	1001134c 	.word	0x1001134c
   2940c:	10002bc8 	.word	0x10002bc8

00029410 <hciCoreResetStart>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreResetStart(void)
{
   29410:	b580      	push	{r7, lr}
   29412:	af00      	add	r7, sp, #0
  /* send an HCI Reset command to start the sequence */
  //HciResetCmd();

  //Free up any unsent HCI commandss
  hciClearCmdQueue();
   29414:	f7fc fa14 	bl	25840 <hciClearCmdQueue>

  /* send VS NVDS command to start the sequence */
  HciVscUpdateNvdsParam();
   29418:	f7fd fcc8 	bl	26dac <HciVscUpdateNvdsParam>

  // update Bluetooth Address to controller
  //HciVscUpdateBDAddress();

}
   2941c:	bf00      	nop
   2941e:	bd80      	pop	{r7, pc}

00029420 <hciCoreResetSequence>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void hciCoreResetSequence(uint8_t *pMsg)
{
   29420:	b580      	push	{r7, lr}
   29422:	b086      	sub	sp, #24
   29424:	af00      	add	r7, sp, #0
   29426:	6078      	str	r0, [r7, #4]
  uint16_t       opcode;
  wsfMsgHdr_t    hdr;
  static uint8_t randCnt;

  /* if event is a command complete event */
  if (*pMsg == HCI_CMD_CMPL_EVT)
   29428:	687b      	ldr	r3, [r7, #4]
   2942a:	781b      	ldrb	r3, [r3, #0]
   2942c:	2b0e      	cmp	r3, #14
   2942e:	f040 81d6 	bne.w	297de <hciCoreResetSequence+0x3be>
  {
    /* parse parameters */
    pMsg += HCI_EVT_HDR_LEN;
   29432:	687b      	ldr	r3, [r7, #4]
   29434:	3302      	adds	r3, #2
   29436:	607b      	str	r3, [r7, #4]
    pMsg++;                   /* skip num packets */
   29438:	687b      	ldr	r3, [r7, #4]
   2943a:	3301      	adds	r3, #1
   2943c:	607b      	str	r3, [r7, #4]
    BSTREAM_TO_UINT16(opcode, pMsg);
   2943e:	687b      	ldr	r3, [r7, #4]
   29440:	781b      	ldrb	r3, [r3, #0]
   29442:	b29a      	uxth	r2, r3
   29444:	687b      	ldr	r3, [r7, #4]
   29446:	3301      	adds	r3, #1
   29448:	781b      	ldrb	r3, [r3, #0]
   2944a:	b29b      	uxth	r3, r3
   2944c:	021b      	lsls	r3, r3, #8
   2944e:	b29b      	uxth	r3, r3
   29450:	4413      	add	r3, r2
   29452:	82fb      	strh	r3, [r7, #22]
   29454:	687b      	ldr	r3, [r7, #4]
   29456:	3302      	adds	r3, #2
   29458:	607b      	str	r3, [r7, #4]
    pMsg++;                   /* skip status */
   2945a:	687b      	ldr	r3, [r7, #4]
   2945c:	3301      	adds	r3, #1
   2945e:	607b      	str	r3, [r7, #4]

    /* decode opcode */
    switch (opcode)
   29460:	8afb      	ldrh	r3, [r7, #22]
   29462:	f64f 4278 	movw	r2, #64632	; 0xfc78
   29466:	4293      	cmp	r3, r2
   29468:	f000 80e1 	beq.w	2962e <hciCoreResetSequence+0x20e>
   2946c:	f64f 4278 	movw	r2, #64632	; 0xfc78
   29470:	4293      	cmp	r3, r2
   29472:	f300 81b6 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   29476:	f64f 4277 	movw	r2, #64631	; 0xfc77
   2947a:	4293      	cmp	r3, r2
   2947c:	f000 80d4 	beq.w	29628 <hciCoreResetSequence+0x208>
   29480:	f64f 4277 	movw	r2, #64631	; 0xfc77
   29484:	4293      	cmp	r3, r2
   29486:	f300 81ac 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   2948a:	f242 024a 	movw	r2, #8266	; 0x204a
   2948e:	4293      	cmp	r3, r2
   29490:	f300 81a7 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   29494:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
   29498:	dc28      	bgt.n	294ec <hciCoreResetSequence+0xcc>
   2949a:	f241 0209 	movw	r2, #4105	; 0x1009
   2949e:	4293      	cmp	r3, r2
   294a0:	f000 80e0 	beq.w	29664 <hciCoreResetSequence+0x244>
   294a4:	f241 0209 	movw	r2, #4105	; 0x1009
   294a8:	4293      	cmp	r3, r2
   294aa:	f300 819a 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   294ae:	f241 0201 	movw	r2, #4097	; 0x1001
   294b2:	4293      	cmp	r3, r2
   294b4:	f000 816b 	beq.w	2978e <hciCoreResetSequence+0x36e>
   294b8:	f241 0201 	movw	r2, #4097	; 0x1001
   294bc:	4293      	cmp	r3, r2
   294be:	f300 8190 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   294c2:	f640 4263 	movw	r2, #3171	; 0xc63
   294c6:	4293      	cmp	r3, r2
   294c8:	f000 80c9 	beq.w	2965e <hciCoreResetSequence+0x23e>
   294cc:	f640 4263 	movw	r2, #3171	; 0xc63
   294d0:	4293      	cmp	r3, r2
   294d2:	f300 8186 	bgt.w	297e2 <hciCoreResetSequence+0x3c2>
   294d6:	f640 4201 	movw	r2, #3073	; 0xc01
   294da:	4293      	cmp	r3, r2
   294dc:	f000 80b7 	beq.w	2964e <hciCoreResetSequence+0x22e>
   294e0:	f640 4203 	movw	r2, #3075	; 0xc03
   294e4:	4293      	cmp	r3, r2
   294e6:	f000 80a7 	beq.w	29638 <hciCoreResetSequence+0x218>
          (*hciCb.evtCback)((hciEvt_t *) &hdr);
        }
        break;

      default:
        break;
   294ea:	e17a      	b.n	297e2 <hciCoreResetSequence+0x3c2>
   294ec:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
   294f0:	3b01      	subs	r3, #1
   294f2:	2b49      	cmp	r3, #73	; 0x49
   294f4:	f200 8175 	bhi.w	297e2 <hciCoreResetSequence+0x3c2>
   294f8:	a201      	add	r2, pc, #4	; (adr r2, 29500 <hciCoreResetSequence+0xe0>)
   294fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   294fe:	bf00      	nop
   29500:	00029657 	.word	0x00029657
   29504:	00029673 	.word	0x00029673
   29508:	000296db 	.word	0x000296db
   2950c:	000297e3 	.word	0x000297e3
   29510:	000297e3 	.word	0x000297e3
   29514:	000297e3 	.word	0x000297e3
   29518:	000297e3 	.word	0x000297e3
   2951c:	000297e3 	.word	0x000297e3
   29520:	000297e3 	.word	0x000297e3
   29524:	000297e3 	.word	0x000297e3
   29528:	000297e3 	.word	0x000297e3
   2952c:	000297e3 	.word	0x000297e3
   29530:	000297e3 	.word	0x000297e3
   29534:	000297e3 	.word	0x000297e3
   29538:	000296c7 	.word	0x000296c7
   2953c:	000297e3 	.word	0x000297e3
   29540:	000297e3 	.word	0x000297e3
   29544:	000297e3 	.word	0x000297e3
   29548:	000297e3 	.word	0x000297e3
   2954c:	000297e3 	.word	0x000297e3
   29550:	000297e3 	.word	0x000297e3
   29554:	000297e3 	.word	0x000297e3
   29558:	000297e3 	.word	0x000297e3
   2955c:	000297a9 	.word	0x000297a9
   29560:	000297e3 	.word	0x000297e3
   29564:	000297e3 	.word	0x000297e3
   29568:	000297e3 	.word	0x000297e3
   2956c:	000296b5 	.word	0x000296b5
   29570:	000297e3 	.word	0x000297e3
   29574:	000297e3 	.word	0x000297e3
   29578:	000297e3 	.word	0x000297e3
   2957c:	000297e3 	.word	0x000297e3
   29580:	000297e3 	.word	0x000297e3
   29584:	000297e3 	.word	0x000297e3
   29588:	000297e3 	.word	0x000297e3
   2958c:	00029757 	.word	0x00029757
   29590:	000297e3 	.word	0x000297e3
   29594:	000297e3 	.word	0x000297e3
   29598:	000297e3 	.word	0x000297e3
   2959c:	000297e3 	.word	0x000297e3
   295a0:	000297e3 	.word	0x000297e3
   295a4:	000296fd 	.word	0x000296fd
   295a8:	000297e3 	.word	0x000297e3
   295ac:	000297e3 	.word	0x000297e3
   295b0:	000297e3 	.word	0x000297e3
   295b4:	000297e3 	.word	0x000297e3
   295b8:	00029711 	.word	0x00029711
   295bc:	000297e3 	.word	0x000297e3
   295c0:	000297e3 	.word	0x000297e3
   295c4:	000297e3 	.word	0x000297e3
   295c8:	000297e3 	.word	0x000297e3
   295cc:	000297e3 	.word	0x000297e3
   295d0:	000297e3 	.word	0x000297e3
   295d4:	000297e3 	.word	0x000297e3
   295d8:	000297e3 	.word	0x000297e3
   295dc:	000297e3 	.word	0x000297e3
   295e0:	000297e3 	.word	0x000297e3
   295e4:	0002978f 	.word	0x0002978f
   295e8:	0002978f 	.word	0x0002978f
   295ec:	000297e3 	.word	0x000297e3
   295f0:	000297e3 	.word	0x000297e3
   295f4:	000297e3 	.word	0x000297e3
   295f8:	000297e3 	.word	0x000297e3
   295fc:	000297e3 	.word	0x000297e3
   29600:	000297e3 	.word	0x000297e3
   29604:	000297e3 	.word	0x000297e3
   29608:	000297e3 	.word	0x000297e3
   2960c:	000297e3 	.word	0x000297e3
   29610:	000297e3 	.word	0x000297e3
   29614:	000297e3 	.word	0x000297e3
   29618:	000297e3 	.word	0x000297e3
   2961c:	000297e3 	.word	0x000297e3
   29620:	000297e3 	.word	0x000297e3
   29624:	0002978f 	.word	0x0002978f
        HciVscUpdateLinklayerFeature();
   29628:	f7fd fbcc 	bl	26dc4 <HciVscUpdateLinklayerFeature>
      break;
   2962c:	e0dc      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        HciResetCmd();
   2962e:	f7fc f923 	bl	25878 <HciResetCmd>
        HciVscUpdateBDAddress();
   29632:	f7fd fbaf 	bl	26d94 <HciVscUpdateBDAddress>
      break;
   29636:	e0d7      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        randCnt = 0;
   29638:	4b6d      	ldr	r3, [pc, #436]	; (297f0 <hciCoreResetSequence+0x3d0>)
   2963a:	2200      	movs	r2, #0
   2963c:	701a      	strb	r2, [r3, #0]
        HciVscSetTraceBitMap(TRACE_BITMAP);
   2963e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   29642:	f7fd fb74 	bl	26d2e <HciVscSetTraceBitMap>
        HciSetEventMaskCmd((uint8_t *) hciEventMask);
   29646:	486b      	ldr	r0, [pc, #428]	; (297f4 <hciCoreResetSequence+0x3d4>)
   29648:	f7fc f934 	bl	258b4 <HciSetEventMaskCmd>
        break;
   2964c:	e0cc      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        HciLeSetEventMaskCmd((uint8_t *) hciLeEventMask);
   2964e:	486a      	ldr	r0, [pc, #424]	; (297f8 <hciCoreResetSequence+0x3d8>)
   29650:	f7fb fffe 	bl	25650 <HciLeSetEventMaskCmd>
        break;
   29654:	e0c8      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        HciSetEventMaskPage2Cmd((uint8_t *) hciEventMaskPage2);
   29656:	4869      	ldr	r0, [pc, #420]	; (297fc <hciCoreResetSequence+0x3dc>)
   29658:	f7fc f948 	bl	258ec <HciSetEventMaskPage2Cmd>
        break;
   2965c:	e0c4      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        HciReadBdAddrCmd();
   2965e:	f7fc f8b6 	bl	257ce <HciReadBdAddrCmd>
        break;
   29662:	e0c1      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        BdaCpy(hciCoreCb.bdAddr, pMsg);
   29664:	6879      	ldr	r1, [r7, #4]
   29666:	4866      	ldr	r0, [pc, #408]	; (29800 <hciCoreResetSequence+0x3e0>)
   29668:	f7f8 fa8d 	bl	21b86 <BdaCpy>
        HciLeReadBufSizeCmd();
   2966c:	f7fb fec8 	bl	25400 <HciLeReadBufSizeCmd>
        break;
   29670:	e0ba      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        BSTREAM_TO_UINT16(hciCoreCb.bufSize, pMsg);
   29672:	687b      	ldr	r3, [r7, #4]
   29674:	781b      	ldrb	r3, [r3, #0]
   29676:	b29a      	uxth	r2, r3
   29678:	687b      	ldr	r3, [r7, #4]
   2967a:	3301      	adds	r3, #1
   2967c:	781b      	ldrb	r3, [r3, #0]
   2967e:	b29b      	uxth	r3, r3
   29680:	021b      	lsls	r3, r3, #8
   29682:	b29b      	uxth	r3, r3
   29684:	4413      	add	r3, r2
   29686:	b29a      	uxth	r2, r3
   29688:	4b5e      	ldr	r3, [pc, #376]	; (29804 <hciCoreResetSequence+0x3e4>)
   2968a:	f8a3 2072 	strh.w	r2, [r3, #114]	; 0x72
   2968e:	687b      	ldr	r3, [r7, #4]
   29690:	3302      	adds	r3, #2
   29692:	607b      	str	r3, [r7, #4]
        BSTREAM_TO_UINT8(hciCoreCb.numBufs, pMsg);
   29694:	687b      	ldr	r3, [r7, #4]
   29696:	1c5a      	adds	r2, r3, #1
   29698:	607a      	str	r2, [r7, #4]
   2969a:	781a      	ldrb	r2, [r3, #0]
   2969c:	4b59      	ldr	r3, [pc, #356]	; (29804 <hciCoreResetSequence+0x3e4>)
   2969e:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
        hciCoreCb.availBufs = hciCoreCb.numBufs;
   296a2:	4b58      	ldr	r3, [pc, #352]	; (29804 <hciCoreResetSequence+0x3e4>)
   296a4:	f893 2077 	ldrb.w	r2, [r3, #119]	; 0x77
   296a8:	4b56      	ldr	r3, [pc, #344]	; (29804 <hciCoreResetSequence+0x3e4>)
   296aa:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
        HciLeReadSupStatesCmd();
   296ae:	f7fb fef3 	bl	25498 <HciLeReadSupStatesCmd>
        break;
   296b2:	e099      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        memcpy(hciCoreCb.leStates, pMsg, HCI_LE_STATES_LEN);
   296b4:	4b53      	ldr	r3, [pc, #332]	; (29804 <hciCoreResetSequence+0x3e4>)
   296b6:	687a      	ldr	r2, [r7, #4]
   296b8:	3354      	adds	r3, #84	; 0x54
   296ba:	6810      	ldr	r0, [r2, #0]
   296bc:	6851      	ldr	r1, [r2, #4]
   296be:	c303      	stmia	r3!, {r0, r1}
        HciLeReadWhiteListSizeCmd();
   296c0:	f7fb fefd 	bl	254be <HciLeReadWhiteListSizeCmd>
        break;
   296c4:	e090      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        BSTREAM_TO_UINT8(hciCoreCb.whiteListSize, pMsg);
   296c6:	687b      	ldr	r3, [r7, #4]
   296c8:	1c5a      	adds	r2, r3, #1
   296ca:	607a      	str	r2, [r7, #4]
   296cc:	781a      	ldrb	r2, [r3, #0]
   296ce:	4b4d      	ldr	r3, [pc, #308]	; (29804 <hciCoreResetSequence+0x3e4>)
   296d0:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
        HciLeReadLocalSupFeatCmd();
   296d4:	f7fb fea7 	bl	25426 <HciLeReadLocalSupFeatCmd>
        break;
   296d8:	e086      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        BSTREAM_TO_UINT16(hciCoreCb.leSupFeat, pMsg);
   296da:	687b      	ldr	r3, [r7, #4]
   296dc:	781b      	ldrb	r3, [r3, #0]
   296de:	461a      	mov	r2, r3
   296e0:	687b      	ldr	r3, [r7, #4]
   296e2:	3301      	adds	r3, #1
   296e4:	781b      	ldrb	r3, [r3, #0]
   296e6:	021b      	lsls	r3, r3, #8
   296e8:	4413      	add	r3, r2
   296ea:	461a      	mov	r2, r3
   296ec:	4b45      	ldr	r3, [pc, #276]	; (29804 <hciCoreResetSequence+0x3e4>)
   296ee:	67da      	str	r2, [r3, #124]	; 0x7c
   296f0:	687b      	ldr	r3, [r7, #4]
   296f2:	3302      	adds	r3, #2
   296f4:	607b      	str	r3, [r7, #4]
        hciCoreReadResolvingListSize();
   296f6:	f7ff fe53 	bl	293a0 <hciCoreReadResolvingListSize>
        break;
   296fa:	e075      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        BSTREAM_TO_UINT8(hciCoreCb.resListSize, pMsg);
   296fc:	687b      	ldr	r3, [r7, #4]
   296fe:	1c5a      	adds	r2, r3, #1
   29700:	607a      	str	r2, [r7, #4]
   29702:	781a      	ldrb	r2, [r3, #0]
   29704:	4b3f      	ldr	r3, [pc, #252]	; (29804 <hciCoreResetSequence+0x3e4>)
   29706:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
        hciCoreReadMaxDataLen();
   2970a:	f7ff fe67 	bl	293dc <hciCoreReadMaxDataLen>
        break;
   2970e:	e06b      	b.n	297e8 <hciCoreResetSequence+0x3c8>
          BSTREAM_TO_UINT16(maxTxOctets, pMsg);
   29710:	687b      	ldr	r3, [r7, #4]
   29712:	781b      	ldrb	r3, [r3, #0]
   29714:	b29a      	uxth	r2, r3
   29716:	687b      	ldr	r3, [r7, #4]
   29718:	3301      	adds	r3, #1
   2971a:	781b      	ldrb	r3, [r3, #0]
   2971c:	b29b      	uxth	r3, r3
   2971e:	021b      	lsls	r3, r3, #8
   29720:	b29b      	uxth	r3, r3
   29722:	4413      	add	r3, r2
   29724:	82bb      	strh	r3, [r7, #20]
   29726:	687b      	ldr	r3, [r7, #4]
   29728:	3302      	adds	r3, #2
   2972a:	607b      	str	r3, [r7, #4]
          BSTREAM_TO_UINT16(maxTxTime, pMsg);
   2972c:	687b      	ldr	r3, [r7, #4]
   2972e:	781b      	ldrb	r3, [r3, #0]
   29730:	b29a      	uxth	r2, r3
   29732:	687b      	ldr	r3, [r7, #4]
   29734:	3301      	adds	r3, #1
   29736:	781b      	ldrb	r3, [r3, #0]
   29738:	b29b      	uxth	r3, r3
   2973a:	021b      	lsls	r3, r3, #8
   2973c:	b29b      	uxth	r3, r3
   2973e:	4413      	add	r3, r2
   29740:	827b      	strh	r3, [r7, #18]
   29742:	687b      	ldr	r3, [r7, #4]
   29744:	3302      	adds	r3, #2
   29746:	607b      	str	r3, [r7, #4]
          HciLeWriteDefDataLen(maxTxOctets, maxTxTime);
   29748:	8a7a      	ldrh	r2, [r7, #18]
   2974a:	8abb      	ldrh	r3, [r7, #20]
   2974c:	4611      	mov	r1, r2
   2974e:	4618      	mov	r0, r3
   29750:	f7fb fdd4 	bl	252fc <HciLeWriteDefDataLen>
        break;
   29754:	e048      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        if (hciCoreCb.extResetSeq)
   29756:	4b2b      	ldr	r3, [pc, #172]	; (29804 <hciCoreResetSequence+0x3e4>)
   29758:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   2975c:	2b00      	cmp	r3, #0
   2975e:	d007      	beq.n	29770 <hciCoreResetSequence+0x350>
          (*hciCoreCb.extResetSeq)(pMsg, opcode);
   29760:	4b28      	ldr	r3, [pc, #160]	; (29804 <hciCoreResetSequence+0x3e4>)
   29762:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   29766:	8afa      	ldrh	r2, [r7, #22]
   29768:	4611      	mov	r1, r2
   2976a:	6878      	ldr	r0, [r7, #4]
   2976c:	4798      	blx	r3
        break;
   2976e:	e03b      	b.n	297e8 <hciCoreResetSequence+0x3c8>
          hciCoreCb.maxAdvDataLen = 0;
   29770:	4b24      	ldr	r3, [pc, #144]	; (29804 <hciCoreResetSequence+0x3e4>)
   29772:	2200      	movs	r2, #0
   29774:	f8a3 2082 	strh.w	r2, [r3, #130]	; 0x82
          hciCoreCb.numSupAdvSets = 0;
   29778:	4b22      	ldr	r3, [pc, #136]	; (29804 <hciCoreResetSequence+0x3e4>)
   2977a:	2200      	movs	r2, #0
   2977c:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
          hciCoreCb.perAdvListSize = 0;
   29780:	4b20      	ldr	r3, [pc, #128]	; (29804 <hciCoreResetSequence+0x3e4>)
   29782:	2200      	movs	r2, #0
   29784:	f883 2085 	strb.w	r2, [r3, #133]	; 0x85
          HciLeRandCmd();
   29788:	f7fb fe27 	bl	253da <HciLeRandCmd>
        break;
   2978c:	e02c      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        if (hciCoreCb.extResetSeq)
   2978e:	4b1d      	ldr	r3, [pc, #116]	; (29804 <hciCoreResetSequence+0x3e4>)
   29790:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   29794:	2b00      	cmp	r3, #0
   29796:	d026      	beq.n	297e6 <hciCoreResetSequence+0x3c6>
          (*hciCoreCb.extResetSeq)(pMsg, opcode);
   29798:	4b1a      	ldr	r3, [pc, #104]	; (29804 <hciCoreResetSequence+0x3e4>)
   2979a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   2979e:	8afa      	ldrh	r2, [r7, #22]
   297a0:	4611      	mov	r1, r2
   297a2:	6878      	ldr	r0, [r7, #4]
   297a4:	4798      	blx	r3
        break;
   297a6:	e01e      	b.n	297e6 <hciCoreResetSequence+0x3c6>
        if (randCnt < (HCI_RESET_RAND_CNT-1))
   297a8:	4b11      	ldr	r3, [pc, #68]	; (297f0 <hciCoreResetSequence+0x3d0>)
   297aa:	781b      	ldrb	r3, [r3, #0]
   297ac:	2b02      	cmp	r3, #2
   297ae:	d808      	bhi.n	297c2 <hciCoreResetSequence+0x3a2>
          randCnt++;
   297b0:	4b0f      	ldr	r3, [pc, #60]	; (297f0 <hciCoreResetSequence+0x3d0>)
   297b2:	781b      	ldrb	r3, [r3, #0]
   297b4:	3301      	adds	r3, #1
   297b6:	b2da      	uxtb	r2, r3
   297b8:	4b0d      	ldr	r3, [pc, #52]	; (297f0 <hciCoreResetSequence+0x3d0>)
   297ba:	701a      	strb	r2, [r3, #0]
          HciLeRandCmd();
   297bc:	f7fb fe0d 	bl	253da <HciLeRandCmd>
        break;
   297c0:	e012      	b.n	297e8 <hciCoreResetSequence+0x3c8>
          hciCb.resetting = FALSE;
   297c2:	4b11      	ldr	r3, [pc, #68]	; (29808 <hciCoreResetSequence+0x3e8>)
   297c4:	2200      	movs	r2, #0
   297c6:	765a      	strb	r2, [r3, #25]
          hdr.param = 0;
   297c8:	2300      	movs	r3, #0
   297ca:	81bb      	strh	r3, [r7, #12]
          hdr.event = HCI_RESET_SEQ_CMPL_CBACK_EVT;
   297cc:	2300      	movs	r3, #0
   297ce:	73bb      	strb	r3, [r7, #14]
          (*hciCb.evtCback)((hciEvt_t *) &hdr);
   297d0:	4b0d      	ldr	r3, [pc, #52]	; (29808 <hciCoreResetSequence+0x3e8>)
   297d2:	689b      	ldr	r3, [r3, #8]
   297d4:	f107 020c 	add.w	r2, r7, #12
   297d8:	4610      	mov	r0, r2
   297da:	4798      	blx	r3
        break;
   297dc:	e004      	b.n	297e8 <hciCoreResetSequence+0x3c8>
    }
  }
   297de:	bf00      	nop
   297e0:	e002      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        break;
   297e2:	bf00      	nop
   297e4:	e000      	b.n	297e8 <hciCoreResetSequence+0x3c8>
        break;
   297e6:	bf00      	nop
}
   297e8:	bf00      	nop
   297ea:	3718      	adds	r7, #24
   297ec:	46bd      	mov	sp, r7
   297ee:	bd80      	pop	{r7, pc}
   297f0:	10003fac 	.word	0x10003fac
   297f4:	00045d6c 	.word	0x00045d6c
   297f8:	00045d74 	.word	0x00045d74
   297fc:	00045d7c 	.word	0x00045d7c
   29800:	100113a8 	.word	0x100113a8
   29804:	1001134c 	.word	0x1001134c
   29808:	100116ec 	.word	0x100116ec

0002980c <hciCoreVsCmdCmplRcvd>:
 *
 *  \return HCI callback event code or zero.
 */
/*************************************************************************************************/
uint8_t hciCoreVsCmdCmplRcvd(uint16_t opcode, uint8_t *pMsg, uint8_t len)
{
   2980c:	b480      	push	{r7}
   2980e:	b083      	sub	sp, #12
   29810:	af00      	add	r7, sp, #0
   29812:	4603      	mov	r3, r0
   29814:	6039      	str	r1, [r7, #0]
   29816:	80fb      	strh	r3, [r7, #6]
   29818:	4613      	mov	r3, r2
   2981a:	717b      	strb	r3, [r7, #5]
  return HCI_VENDOR_SPEC_CMD_CMPL_CBACK_EVT;
   2981c:	2312      	movs	r3, #18
}
   2981e:	4618      	mov	r0, r3
   29820:	370c      	adds	r7, #12
   29822:	46bd      	mov	sp, r7
   29824:	f85d 7b04 	ldr.w	r7, [sp], #4
   29828:	4770      	bx	lr

0002982a <HciVsInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void HciVsInit(uint8_t param)
{
   2982a:	b480      	push	{r7}
   2982c:	b083      	sub	sp, #12
   2982e:	af00      	add	r7, sp, #0
   29830:	4603      	mov	r3, r0
   29832:	71fb      	strb	r3, [r7, #7]

}
   29834:	bf00      	nop
   29836:	370c      	adds	r7, #12
   29838:	46bd      	mov	sp, r7
   2983a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2983e:	4770      	bx	lr

00029840 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   29840:	b580      	push	{r7, lr}
   29842:	b086      	sub	sp, #24
   29844:	af00      	add	r7, sp, #0
   29846:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
   29848:	2300      	movs	r3, #0
   2984a:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
   2984c:	f002 fa52 	bl	2bcf4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
   29850:	4b40      	ldr	r3, [pc, #256]	; (29954 <pvPortMalloc+0x114>)
   29852:	681b      	ldr	r3, [r3, #0]
   29854:	2b00      	cmp	r3, #0
   29856:	d101      	bne.n	2985c <pvPortMalloc+0x1c>
		{
			prvHeapInit();
   29858:	f000 f8c0 	bl	299dc <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
   2985c:	4b3e      	ldr	r3, [pc, #248]	; (29958 <pvPortMalloc+0x118>)
   2985e:	681a      	ldr	r2, [r3, #0]
   29860:	687b      	ldr	r3, [r7, #4]
   29862:	4013      	ands	r3, r2
   29864:	2b00      	cmp	r3, #0
   29866:	d16d      	bne.n	29944 <pvPortMalloc+0x104>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
   29868:	687b      	ldr	r3, [r7, #4]
   2986a:	2b00      	cmp	r3, #0
   2986c:	d00d      	beq.n	2988a <pvPortMalloc+0x4a>
			{
				xWantedSize += xHeapStructSize;
   2986e:	2208      	movs	r2, #8
   29870:	687b      	ldr	r3, [r7, #4]
   29872:	4413      	add	r3, r2
   29874:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
   29876:	687b      	ldr	r3, [r7, #4]
   29878:	f003 0307 	and.w	r3, r3, #7
   2987c:	2b00      	cmp	r3, #0
   2987e:	d004      	beq.n	2988a <pvPortMalloc+0x4a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   29880:	687b      	ldr	r3, [r7, #4]
   29882:	f023 0307 	bic.w	r3, r3, #7
   29886:	3308      	adds	r3, #8
   29888:	607b      	str	r3, [r7, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
   2988a:	687b      	ldr	r3, [r7, #4]
   2988c:	2b00      	cmp	r3, #0
   2988e:	d059      	beq.n	29944 <pvPortMalloc+0x104>
   29890:	4b32      	ldr	r3, [pc, #200]	; (2995c <pvPortMalloc+0x11c>)
   29892:	681b      	ldr	r3, [r3, #0]
   29894:	687a      	ldr	r2, [r7, #4]
   29896:	429a      	cmp	r2, r3
   29898:	d854      	bhi.n	29944 <pvPortMalloc+0x104>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
   2989a:	4b31      	ldr	r3, [pc, #196]	; (29960 <pvPortMalloc+0x120>)
   2989c:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
   2989e:	4b30      	ldr	r3, [pc, #192]	; (29960 <pvPortMalloc+0x120>)
   298a0:	681b      	ldr	r3, [r3, #0]
   298a2:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   298a4:	e004      	b.n	298b0 <pvPortMalloc+0x70>
				{
					pxPreviousBlock = pxBlock;
   298a6:	697b      	ldr	r3, [r7, #20]
   298a8:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
   298aa:	697b      	ldr	r3, [r7, #20]
   298ac:	681b      	ldr	r3, [r3, #0]
   298ae:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   298b0:	697b      	ldr	r3, [r7, #20]
   298b2:	685b      	ldr	r3, [r3, #4]
   298b4:	687a      	ldr	r2, [r7, #4]
   298b6:	429a      	cmp	r2, r3
   298b8:	d903      	bls.n	298c2 <pvPortMalloc+0x82>
   298ba:	697b      	ldr	r3, [r7, #20]
   298bc:	681b      	ldr	r3, [r3, #0]
   298be:	2b00      	cmp	r3, #0
   298c0:	d1f1      	bne.n	298a6 <pvPortMalloc+0x66>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
   298c2:	4b24      	ldr	r3, [pc, #144]	; (29954 <pvPortMalloc+0x114>)
   298c4:	681b      	ldr	r3, [r3, #0]
   298c6:	697a      	ldr	r2, [r7, #20]
   298c8:	429a      	cmp	r2, r3
   298ca:	d03b      	beq.n	29944 <pvPortMalloc+0x104>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
   298cc:	693b      	ldr	r3, [r7, #16]
   298ce:	681b      	ldr	r3, [r3, #0]
   298d0:	2208      	movs	r2, #8
   298d2:	4413      	add	r3, r2
   298d4:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   298d6:	697b      	ldr	r3, [r7, #20]
   298d8:	681a      	ldr	r2, [r3, #0]
   298da:	693b      	ldr	r3, [r7, #16]
   298dc:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   298de:	697b      	ldr	r3, [r7, #20]
   298e0:	685a      	ldr	r2, [r3, #4]
   298e2:	687b      	ldr	r3, [r7, #4]
   298e4:	1ad2      	subs	r2, r2, r3
   298e6:	2308      	movs	r3, #8
   298e8:	005b      	lsls	r3, r3, #1
   298ea:	429a      	cmp	r2, r3
   298ec:	d90f      	bls.n	2990e <pvPortMalloc+0xce>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   298ee:	697a      	ldr	r2, [r7, #20]
   298f0:	687b      	ldr	r3, [r7, #4]
   298f2:	4413      	add	r3, r2
   298f4:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   298f6:	697b      	ldr	r3, [r7, #20]
   298f8:	685a      	ldr	r2, [r3, #4]
   298fa:	687b      	ldr	r3, [r7, #4]
   298fc:	1ad2      	subs	r2, r2, r3
   298fe:	68bb      	ldr	r3, [r7, #8]
   29900:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
   29902:	697b      	ldr	r3, [r7, #20]
   29904:	687a      	ldr	r2, [r7, #4]
   29906:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
   29908:	68b8      	ldr	r0, [r7, #8]
   2990a:	f000 f8c9 	bl	29aa0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
   2990e:	4b13      	ldr	r3, [pc, #76]	; (2995c <pvPortMalloc+0x11c>)
   29910:	681a      	ldr	r2, [r3, #0]
   29912:	697b      	ldr	r3, [r7, #20]
   29914:	685b      	ldr	r3, [r3, #4]
   29916:	1ad3      	subs	r3, r2, r3
   29918:	4a10      	ldr	r2, [pc, #64]	; (2995c <pvPortMalloc+0x11c>)
   2991a:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
   2991c:	4b0f      	ldr	r3, [pc, #60]	; (2995c <pvPortMalloc+0x11c>)
   2991e:	681a      	ldr	r2, [r3, #0]
   29920:	4b10      	ldr	r3, [pc, #64]	; (29964 <pvPortMalloc+0x124>)
   29922:	681b      	ldr	r3, [r3, #0]
   29924:	429a      	cmp	r2, r3
   29926:	d203      	bcs.n	29930 <pvPortMalloc+0xf0>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
   29928:	4b0c      	ldr	r3, [pc, #48]	; (2995c <pvPortMalloc+0x11c>)
   2992a:	681b      	ldr	r3, [r3, #0]
   2992c:	4a0d      	ldr	r2, [pc, #52]	; (29964 <pvPortMalloc+0x124>)
   2992e:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
   29930:	697b      	ldr	r3, [r7, #20]
   29932:	685a      	ldr	r2, [r3, #4]
   29934:	4b08      	ldr	r3, [pc, #32]	; (29958 <pvPortMalloc+0x118>)
   29936:	681b      	ldr	r3, [r3, #0]
   29938:	431a      	orrs	r2, r3
   2993a:	697b      	ldr	r3, [r7, #20]
   2993c:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
   2993e:	697b      	ldr	r3, [r7, #20]
   29940:	2200      	movs	r2, #0
   29942:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   29944:	f002 fa1c 	bl	2bd80 <xTaskResumeAll>
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
   29948:	68fb      	ldr	r3, [r7, #12]
}
   2994a:	4618      	mov	r0, r3
   2994c:	3718      	adds	r7, #24
   2994e:	46bd      	mov	sp, r7
   29950:	bd80      	pop	{r7, pc}
   29952:	bf00      	nop
   29954:	10007fb8 	.word	0x10007fb8
   29958:	10007fc4 	.word	0x10007fc4
   2995c:	10007fbc 	.word	0x10007fbc
   29960:	10007fb0 	.word	0x10007fb0
   29964:	10007fc0 	.word	0x10007fc0

00029968 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   29968:	b580      	push	{r7, lr}
   2996a:	b084      	sub	sp, #16
   2996c:	af00      	add	r7, sp, #0
   2996e:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   29970:	687b      	ldr	r3, [r7, #4]
   29972:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
   29974:	687b      	ldr	r3, [r7, #4]
   29976:	2b00      	cmp	r3, #0
   29978:	d027      	beq.n	299ca <vPortFree+0x62>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
   2997a:	2308      	movs	r3, #8
   2997c:	425b      	negs	r3, r3
   2997e:	68fa      	ldr	r2, [r7, #12]
   29980:	4413      	add	r3, r2
   29982:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
   29984:	68fb      	ldr	r3, [r7, #12]
   29986:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
   29988:	68bb      	ldr	r3, [r7, #8]
   2998a:	685a      	ldr	r2, [r3, #4]
   2998c:	4b11      	ldr	r3, [pc, #68]	; (299d4 <vPortFree+0x6c>)
   2998e:	681b      	ldr	r3, [r3, #0]
   29990:	4013      	ands	r3, r2
   29992:	2b00      	cmp	r3, #0
   29994:	d019      	beq.n	299ca <vPortFree+0x62>
		{
			if( pxLink->pxNextFreeBlock == NULL )
   29996:	68bb      	ldr	r3, [r7, #8]
   29998:	681b      	ldr	r3, [r3, #0]
   2999a:	2b00      	cmp	r3, #0
   2999c:	d115      	bne.n	299ca <vPortFree+0x62>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
   2999e:	68bb      	ldr	r3, [r7, #8]
   299a0:	685a      	ldr	r2, [r3, #4]
   299a2:	4b0c      	ldr	r3, [pc, #48]	; (299d4 <vPortFree+0x6c>)
   299a4:	681b      	ldr	r3, [r3, #0]
   299a6:	43db      	mvns	r3, r3
   299a8:	401a      	ands	r2, r3
   299aa:	68bb      	ldr	r3, [r7, #8]
   299ac:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
   299ae:	f002 f9a1 	bl	2bcf4 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
   299b2:	68bb      	ldr	r3, [r7, #8]
   299b4:	685a      	ldr	r2, [r3, #4]
   299b6:	4b08      	ldr	r3, [pc, #32]	; (299d8 <vPortFree+0x70>)
   299b8:	681b      	ldr	r3, [r3, #0]
   299ba:	4413      	add	r3, r2
   299bc:	4a06      	ldr	r2, [pc, #24]	; (299d8 <vPortFree+0x70>)
   299be:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   299c0:	68b8      	ldr	r0, [r7, #8]
   299c2:	f000 f86d 	bl	29aa0 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
   299c6:	f002 f9db 	bl	2bd80 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   299ca:	bf00      	nop
   299cc:	3710      	adds	r7, #16
   299ce:	46bd      	mov	sp, r7
   299d0:	bd80      	pop	{r7, pc}
   299d2:	bf00      	nop
   299d4:	10007fc4 	.word	0x10007fc4
   299d8:	10007fbc 	.word	0x10007fbc

000299dc <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   299dc:	b480      	push	{r7}
   299de:	b085      	sub	sp, #20
   299e0:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
   299e2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   299e6:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
   299e8:	4b27      	ldr	r3, [pc, #156]	; (29a88 <prvHeapInit+0xac>)
   299ea:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
   299ec:	68fb      	ldr	r3, [r7, #12]
   299ee:	f003 0307 	and.w	r3, r3, #7
   299f2:	2b00      	cmp	r3, #0
   299f4:	d00c      	beq.n	29a10 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
   299f6:	68fb      	ldr	r3, [r7, #12]
   299f8:	3307      	adds	r3, #7
   299fa:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   299fc:	68fb      	ldr	r3, [r7, #12]
   299fe:	f023 0307 	bic.w	r3, r3, #7
   29a02:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
   29a04:	68ba      	ldr	r2, [r7, #8]
   29a06:	68fb      	ldr	r3, [r7, #12]
   29a08:	1ad3      	subs	r3, r2, r3
   29a0a:	4a1f      	ldr	r2, [pc, #124]	; (29a88 <prvHeapInit+0xac>)
   29a0c:	4413      	add	r3, r2
   29a0e:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
   29a10:	68fb      	ldr	r3, [r7, #12]
   29a12:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   29a14:	4a1d      	ldr	r2, [pc, #116]	; (29a8c <prvHeapInit+0xb0>)
   29a16:	687b      	ldr	r3, [r7, #4]
   29a18:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
   29a1a:	4b1c      	ldr	r3, [pc, #112]	; (29a8c <prvHeapInit+0xb0>)
   29a1c:	2200      	movs	r2, #0
   29a1e:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
   29a20:	687b      	ldr	r3, [r7, #4]
   29a22:	68ba      	ldr	r2, [r7, #8]
   29a24:	4413      	add	r3, r2
   29a26:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
   29a28:	2208      	movs	r2, #8
   29a2a:	68fb      	ldr	r3, [r7, #12]
   29a2c:	1a9b      	subs	r3, r3, r2
   29a2e:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
   29a30:	68fb      	ldr	r3, [r7, #12]
   29a32:	f023 0307 	bic.w	r3, r3, #7
   29a36:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
   29a38:	68fb      	ldr	r3, [r7, #12]
   29a3a:	4a15      	ldr	r2, [pc, #84]	; (29a90 <prvHeapInit+0xb4>)
   29a3c:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
   29a3e:	4b14      	ldr	r3, [pc, #80]	; (29a90 <prvHeapInit+0xb4>)
   29a40:	681b      	ldr	r3, [r3, #0]
   29a42:	2200      	movs	r2, #0
   29a44:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
   29a46:	4b12      	ldr	r3, [pc, #72]	; (29a90 <prvHeapInit+0xb4>)
   29a48:	681b      	ldr	r3, [r3, #0]
   29a4a:	2200      	movs	r2, #0
   29a4c:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   29a4e:	687b      	ldr	r3, [r7, #4]
   29a50:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
   29a52:	683b      	ldr	r3, [r7, #0]
   29a54:	68fa      	ldr	r2, [r7, #12]
   29a56:	1ad2      	subs	r2, r2, r3
   29a58:	683b      	ldr	r3, [r7, #0]
   29a5a:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   29a5c:	4b0c      	ldr	r3, [pc, #48]	; (29a90 <prvHeapInit+0xb4>)
   29a5e:	681a      	ldr	r2, [r3, #0]
   29a60:	683b      	ldr	r3, [r7, #0]
   29a62:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   29a64:	683b      	ldr	r3, [r7, #0]
   29a66:	685b      	ldr	r3, [r3, #4]
   29a68:	4a0a      	ldr	r2, [pc, #40]	; (29a94 <prvHeapInit+0xb8>)
   29a6a:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   29a6c:	683b      	ldr	r3, [r7, #0]
   29a6e:	685b      	ldr	r3, [r3, #4]
   29a70:	4a09      	ldr	r2, [pc, #36]	; (29a98 <prvHeapInit+0xbc>)
   29a72:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
   29a74:	4b09      	ldr	r3, [pc, #36]	; (29a9c <prvHeapInit+0xc0>)
   29a76:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   29a7a:	601a      	str	r2, [r3, #0]
}
   29a7c:	bf00      	nop
   29a7e:	3714      	adds	r7, #20
   29a80:	46bd      	mov	sp, r7
   29a82:	f85d 7b04 	ldr.w	r7, [sp], #4
   29a86:	4770      	bx	lr
   29a88:	10003fb0 	.word	0x10003fb0
   29a8c:	10007fb0 	.word	0x10007fb0
   29a90:	10007fb8 	.word	0x10007fb8
   29a94:	10007fc0 	.word	0x10007fc0
   29a98:	10007fbc 	.word	0x10007fbc
   29a9c:	10007fc4 	.word	0x10007fc4

00029aa0 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
   29aa0:	b480      	push	{r7}
   29aa2:	b085      	sub	sp, #20
   29aa4:	af00      	add	r7, sp, #0
   29aa6:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   29aa8:	4b28      	ldr	r3, [pc, #160]	; (29b4c <prvInsertBlockIntoFreeList+0xac>)
   29aaa:	60fb      	str	r3, [r7, #12]
   29aac:	e002      	b.n	29ab4 <prvInsertBlockIntoFreeList+0x14>
   29aae:	68fb      	ldr	r3, [r7, #12]
   29ab0:	681b      	ldr	r3, [r3, #0]
   29ab2:	60fb      	str	r3, [r7, #12]
   29ab4:	68fb      	ldr	r3, [r7, #12]
   29ab6:	681b      	ldr	r3, [r3, #0]
   29ab8:	687a      	ldr	r2, [r7, #4]
   29aba:	429a      	cmp	r2, r3
   29abc:	d8f7      	bhi.n	29aae <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
   29abe:	68fb      	ldr	r3, [r7, #12]
   29ac0:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
   29ac2:	68fb      	ldr	r3, [r7, #12]
   29ac4:	685b      	ldr	r3, [r3, #4]
   29ac6:	68ba      	ldr	r2, [r7, #8]
   29ac8:	4413      	add	r3, r2
   29aca:	687a      	ldr	r2, [r7, #4]
   29acc:	429a      	cmp	r2, r3
   29ace:	d108      	bne.n	29ae2 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   29ad0:	68fb      	ldr	r3, [r7, #12]
   29ad2:	685a      	ldr	r2, [r3, #4]
   29ad4:	687b      	ldr	r3, [r7, #4]
   29ad6:	685b      	ldr	r3, [r3, #4]
   29ad8:	441a      	add	r2, r3
   29ada:	68fb      	ldr	r3, [r7, #12]
   29adc:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
   29ade:	68fb      	ldr	r3, [r7, #12]
   29ae0:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
   29ae2:	687b      	ldr	r3, [r7, #4]
   29ae4:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
   29ae6:	687b      	ldr	r3, [r7, #4]
   29ae8:	685b      	ldr	r3, [r3, #4]
   29aea:	68ba      	ldr	r2, [r7, #8]
   29aec:	441a      	add	r2, r3
   29aee:	68fb      	ldr	r3, [r7, #12]
   29af0:	681b      	ldr	r3, [r3, #0]
   29af2:	429a      	cmp	r2, r3
   29af4:	d118      	bne.n	29b28 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
   29af6:	68fb      	ldr	r3, [r7, #12]
   29af8:	681a      	ldr	r2, [r3, #0]
   29afa:	4b15      	ldr	r3, [pc, #84]	; (29b50 <prvInsertBlockIntoFreeList+0xb0>)
   29afc:	681b      	ldr	r3, [r3, #0]
   29afe:	429a      	cmp	r2, r3
   29b00:	d00d      	beq.n	29b1e <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   29b02:	687b      	ldr	r3, [r7, #4]
   29b04:	685a      	ldr	r2, [r3, #4]
   29b06:	68fb      	ldr	r3, [r7, #12]
   29b08:	681b      	ldr	r3, [r3, #0]
   29b0a:	685b      	ldr	r3, [r3, #4]
   29b0c:	441a      	add	r2, r3
   29b0e:	687b      	ldr	r3, [r7, #4]
   29b10:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   29b12:	68fb      	ldr	r3, [r7, #12]
   29b14:	681b      	ldr	r3, [r3, #0]
   29b16:	681a      	ldr	r2, [r3, #0]
   29b18:	687b      	ldr	r3, [r7, #4]
   29b1a:	601a      	str	r2, [r3, #0]
   29b1c:	e008      	b.n	29b30 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   29b1e:	4b0c      	ldr	r3, [pc, #48]	; (29b50 <prvInsertBlockIntoFreeList+0xb0>)
   29b20:	681a      	ldr	r2, [r3, #0]
   29b22:	687b      	ldr	r3, [r7, #4]
   29b24:	601a      	str	r2, [r3, #0]
   29b26:	e003      	b.n	29b30 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
   29b28:	68fb      	ldr	r3, [r7, #12]
   29b2a:	681a      	ldr	r2, [r3, #0]
   29b2c:	687b      	ldr	r3, [r7, #4]
   29b2e:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   29b30:	68fa      	ldr	r2, [r7, #12]
   29b32:	687b      	ldr	r3, [r7, #4]
   29b34:	429a      	cmp	r2, r3
   29b36:	d002      	beq.n	29b3e <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   29b38:	68fb      	ldr	r3, [r7, #12]
   29b3a:	687a      	ldr	r2, [r7, #4]
   29b3c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   29b3e:	bf00      	nop
   29b40:	3714      	adds	r7, #20
   29b42:	46bd      	mov	sp, r7
   29b44:	f85d 7b04 	ldr.w	r7, [sp], #4
   29b48:	4770      	bx	lr
   29b4a:	bf00      	nop
   29b4c:	10007fb0 	.word	0x10007fb0
   29b50:	10007fb8 	.word	0x10007fb8

00029b54 <l2cDefaultDataCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cDefaultDataCback(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   29b54:	b580      	push	{r7, lr}
   29b56:	b082      	sub	sp, #8
   29b58:	af00      	add	r7, sp, #0
   29b5a:	4603      	mov	r3, r0
   29b5c:	603a      	str	r2, [r7, #0]
   29b5e:	80fb      	strh	r3, [r7, #6]
   29b60:	460b      	mov	r3, r1
   29b62:	80bb      	strh	r3, [r7, #4]
  L2C_TRACE_WARN0("rcvd data on uregistered cid");
   29b64:	4803      	ldr	r0, [pc, #12]	; (29b74 <l2cDefaultDataCback+0x20>)
   29b66:	f003 ff13 	bl	2d990 <WsfTrace>
}
   29b6a:	bf00      	nop
   29b6c:	3708      	adds	r7, #8
   29b6e:	46bd      	mov	sp, r7
   29b70:	bd80      	pop	{r7, pc}
   29b72:	bf00      	nop
   29b74:	000450c0 	.word	0x000450c0

00029b78 <l2cDefaultDataCidCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cDefaultDataCidCback(uint16_t handle, uint16_t cid, uint16_t len, uint8_t *pPacket)
{
   29b78:	b580      	push	{r7, lr}
   29b7a:	b084      	sub	sp, #16
   29b7c:	af00      	add	r7, sp, #0
   29b7e:	607b      	str	r3, [r7, #4]
   29b80:	4603      	mov	r3, r0
   29b82:	81fb      	strh	r3, [r7, #14]
   29b84:	460b      	mov	r3, r1
   29b86:	81bb      	strh	r3, [r7, #12]
   29b88:	4613      	mov	r3, r2
   29b8a:	817b      	strh	r3, [r7, #10]
  L2C_TRACE_WARN1("unknown cid=0x%04x", cid);
   29b8c:	89bb      	ldrh	r3, [r7, #12]
   29b8e:	4619      	mov	r1, r3
   29b90:	4803      	ldr	r0, [pc, #12]	; (29ba0 <l2cDefaultDataCidCback+0x28>)
   29b92:	f003 fefd 	bl	2d990 <WsfTrace>
}
   29b96:	bf00      	nop
   29b98:	3710      	adds	r7, #16
   29b9a:	46bd      	mov	sp, r7
   29b9c:	bd80      	pop	{r7, pc}
   29b9e:	bf00      	nop
   29ba0:	000450e0 	.word	0x000450e0

00029ba4 <l2cDefaultCtrlCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cDefaultCtrlCback(wsfMsgHdr_t *pMsg)
{
   29ba4:	b480      	push	{r7}
   29ba6:	b083      	sub	sp, #12
   29ba8:	af00      	add	r7, sp, #0
   29baa:	6078      	str	r0, [r7, #4]
  return;
   29bac:	bf00      	nop
}
   29bae:	370c      	adds	r7, #12
   29bb0:	46bd      	mov	sp, r7
   29bb2:	f85d 7b04 	ldr.w	r7, [sp], #4
   29bb6:	4770      	bx	lr

00029bb8 <l2cRxSignalingPkt>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void l2cRxSignalingPkt(uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   29bb8:	b580      	push	{r7, lr}
   29bba:	b084      	sub	sp, #16
   29bbc:	af00      	add	r7, sp, #0
   29bbe:	4603      	mov	r3, r0
   29bc0:	603a      	str	r2, [r7, #0]
   29bc2:	80fb      	strh	r3, [r7, #6]
   29bc4:	460b      	mov	r3, r1
   29bc6:	80bb      	strh	r3, [r7, #4]
  uint8_t role;
  dmConnId_t connId;

  /* check the validity of data length */
  L2C_CHECK_DATA_LENGTH(len, L2C_SIG_HDR_LEN);
   29bc8:	88bb      	ldrh	r3, [r7, #4]
   29bca:	2b03      	cmp	r3, #3
   29bcc:	d930      	bls.n	29c30 <l2cRxSignalingPkt+0x78>

  if ((connId = DmConnIdByHandle(handle)) == DM_CONN_ID_NONE)
   29bce:	88fb      	ldrh	r3, [r7, #6]
   29bd0:	4618      	mov	r0, r3
   29bd2:	f7f9 fc51 	bl	23478 <DmConnIdByHandle>
   29bd6:	4603      	mov	r3, r0
   29bd8:	73fb      	strb	r3, [r7, #15]
   29bda:	7bfb      	ldrb	r3, [r7, #15]
   29bdc:	2b00      	cmp	r3, #0
   29bde:	d029      	beq.n	29c34 <l2cRxSignalingPkt+0x7c>
  {
    return;
  }

  role = DmConnRole(connId);
   29be0:	7bfb      	ldrb	r3, [r7, #15]
   29be2:	4618      	mov	r0, r3
   29be4:	f7f9 fd4e 	bl	23684 <DmConnRole>
   29be8:	4603      	mov	r3, r0
   29bea:	73bb      	strb	r3, [r7, #14]

  if ((role == DM_ROLE_MASTER) && (l2cCb.masterRxSignalingPkt != NULL))
   29bec:	7bbb      	ldrb	r3, [r7, #14]
   29bee:	2b00      	cmp	r3, #0
   29bf0:	d10a      	bne.n	29c08 <l2cRxSignalingPkt+0x50>
   29bf2:	4b12      	ldr	r3, [pc, #72]	; (29c3c <l2cRxSignalingPkt+0x84>)
   29bf4:	699b      	ldr	r3, [r3, #24]
   29bf6:	2b00      	cmp	r3, #0
   29bf8:	d006      	beq.n	29c08 <l2cRxSignalingPkt+0x50>
  {
    (*l2cCb.masterRxSignalingPkt)(handle, len, pPacket);
   29bfa:	4b10      	ldr	r3, [pc, #64]	; (29c3c <l2cRxSignalingPkt+0x84>)
   29bfc:	699b      	ldr	r3, [r3, #24]
   29bfe:	88b9      	ldrh	r1, [r7, #4]
   29c00:	88f8      	ldrh	r0, [r7, #6]
   29c02:	683a      	ldr	r2, [r7, #0]
   29c04:	4798      	blx	r3
   29c06:	e016      	b.n	29c36 <l2cRxSignalingPkt+0x7e>
  }
  else if ((role == DM_ROLE_SLAVE) && (l2cCb.slaveRxSignalingPkt != NULL))
   29c08:	7bbb      	ldrb	r3, [r7, #14]
   29c0a:	2b01      	cmp	r3, #1
   29c0c:	d10a      	bne.n	29c24 <l2cRxSignalingPkt+0x6c>
   29c0e:	4b0b      	ldr	r3, [pc, #44]	; (29c3c <l2cRxSignalingPkt+0x84>)
   29c10:	69db      	ldr	r3, [r3, #28]
   29c12:	2b00      	cmp	r3, #0
   29c14:	d006      	beq.n	29c24 <l2cRxSignalingPkt+0x6c>
  {
    (*l2cCb.slaveRxSignalingPkt)(handle, len, pPacket);
   29c16:	4b09      	ldr	r3, [pc, #36]	; (29c3c <l2cRxSignalingPkt+0x84>)
   29c18:	69db      	ldr	r3, [r3, #28]
   29c1a:	88b9      	ldrh	r1, [r7, #4]
   29c1c:	88f8      	ldrh	r0, [r7, #6]
   29c1e:	683a      	ldr	r2, [r7, #0]
   29c20:	4798      	blx	r3
   29c22:	e008      	b.n	29c36 <l2cRxSignalingPkt+0x7e>
  }
  else
  {
    L2C_TRACE_ERR1("Invalid role configuration: role=%d", role);
   29c24:	7bbb      	ldrb	r3, [r7, #14]
   29c26:	4619      	mov	r1, r3
   29c28:	4805      	ldr	r0, [pc, #20]	; (29c40 <l2cRxSignalingPkt+0x88>)
   29c2a:	f003 feb1 	bl	2d990 <WsfTrace>
   29c2e:	e002      	b.n	29c36 <l2cRxSignalingPkt+0x7e>
  L2C_CHECK_DATA_LENGTH(len, L2C_SIG_HDR_LEN);
   29c30:	bf00      	nop
   29c32:	e000      	b.n	29c36 <l2cRxSignalingPkt+0x7e>
    return;
   29c34:	bf00      	nop
  }
}
   29c36:	3710      	adds	r7, #16
   29c38:	46bd      	mov	sp, r7
   29c3a:	bd80      	pop	{r7, pc}
   29c3c:	10011708 	.word	0x10011708
   29c40:	000450f4 	.word	0x000450f4

00029c44 <l2cHciAclCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cHciAclCback(uint8_t *pPacket)
{
   29c44:	b590      	push	{r4, r7, lr}
   29c46:	b087      	sub	sp, #28
   29c48:	af00      	add	r7, sp, #0
   29c4a:	6078      	str	r0, [r7, #4]
  uint16_t  handle;
  uint16_t  hciLen;
  uint16_t  cid;
  uint16_t  l2cLen;
  uint8_t   *p = pPacket;
   29c4c:	687b      	ldr	r3, [r7, #4]
   29c4e:	613b      	str	r3, [r7, #16]

  /* parse HCI handle and length */
  BSTREAM_TO_UINT16(handle, p);
   29c50:	693b      	ldr	r3, [r7, #16]
   29c52:	781b      	ldrb	r3, [r3, #0]
   29c54:	b29a      	uxth	r2, r3
   29c56:	693b      	ldr	r3, [r7, #16]
   29c58:	3301      	adds	r3, #1
   29c5a:	781b      	ldrb	r3, [r3, #0]
   29c5c:	b29b      	uxth	r3, r3
   29c5e:	021b      	lsls	r3, r3, #8
   29c60:	b29b      	uxth	r3, r3
   29c62:	4413      	add	r3, r2
   29c64:	81fb      	strh	r3, [r7, #14]
   29c66:	693b      	ldr	r3, [r7, #16]
   29c68:	3302      	adds	r3, #2
   29c6a:	613b      	str	r3, [r7, #16]
  handle &= HCI_HANDLE_MASK;
   29c6c:	89fb      	ldrh	r3, [r7, #14]
   29c6e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   29c72:	81fb      	strh	r3, [r7, #14]
  BSTREAM_TO_UINT16(hciLen, p);
   29c74:	693b      	ldr	r3, [r7, #16]
   29c76:	781b      	ldrb	r3, [r3, #0]
   29c78:	b29a      	uxth	r2, r3
   29c7a:	693b      	ldr	r3, [r7, #16]
   29c7c:	3301      	adds	r3, #1
   29c7e:	781b      	ldrb	r3, [r3, #0]
   29c80:	b29b      	uxth	r3, r3
   29c82:	021b      	lsls	r3, r3, #8
   29c84:	b29b      	uxth	r3, r3
   29c86:	4413      	add	r3, r2
   29c88:	81bb      	strh	r3, [r7, #12]
   29c8a:	693b      	ldr	r3, [r7, #16]
   29c8c:	3302      	adds	r3, #2
   29c8e:	613b      	str	r3, [r7, #16]

  /* parse L2CAP length */
  if (hciLen >= L2C_HDR_LEN)
   29c90:	89bb      	ldrh	r3, [r7, #12]
   29c92:	2b03      	cmp	r3, #3
   29c94:	d90e      	bls.n	29cb4 <l2cHciAclCback+0x70>
  {
    BSTREAM_TO_UINT16(l2cLen, p);
   29c96:	693b      	ldr	r3, [r7, #16]
   29c98:	781b      	ldrb	r3, [r3, #0]
   29c9a:	b29a      	uxth	r2, r3
   29c9c:	693b      	ldr	r3, [r7, #16]
   29c9e:	3301      	adds	r3, #1
   29ca0:	781b      	ldrb	r3, [r3, #0]
   29ca2:	b29b      	uxth	r3, r3
   29ca4:	021b      	lsls	r3, r3, #8
   29ca6:	b29b      	uxth	r3, r3
   29ca8:	4413      	add	r3, r2
   29caa:	82fb      	strh	r3, [r7, #22]
   29cac:	693b      	ldr	r3, [r7, #16]
   29cae:	3302      	adds	r3, #2
   29cb0:	613b      	str	r3, [r7, #16]
   29cb2:	e001      	b.n	29cb8 <l2cHciAclCback+0x74>
  }
  else
  {
    l2cLen = 0;
   29cb4:	2300      	movs	r3, #0
   29cb6:	82fb      	strh	r3, [r7, #22]
  }

  /* verify L2CAP length vs HCI length */
  if (hciLen == (l2cLen + L2C_HDR_LEN))
   29cb8:	89ba      	ldrh	r2, [r7, #12]
   29cba:	8afb      	ldrh	r3, [r7, #22]
   29cbc:	3304      	adds	r3, #4
   29cbe:	429a      	cmp	r2, r3
   29cc0:	d133      	bne.n	29d2a <l2cHciAclCback+0xe6>
  {
    /* parse CID */
    BSTREAM_TO_UINT16(cid, p);
   29cc2:	693b      	ldr	r3, [r7, #16]
   29cc4:	781b      	ldrb	r3, [r3, #0]
   29cc6:	b29a      	uxth	r2, r3
   29cc8:	693b      	ldr	r3, [r7, #16]
   29cca:	3301      	adds	r3, #1
   29ccc:	781b      	ldrb	r3, [r3, #0]
   29cce:	b29b      	uxth	r3, r3
   29cd0:	021b      	lsls	r3, r3, #8
   29cd2:	b29b      	uxth	r3, r3
   29cd4:	4413      	add	r3, r2
   29cd6:	817b      	strh	r3, [r7, #10]
   29cd8:	693b      	ldr	r3, [r7, #16]
   29cda:	3302      	adds	r3, #2
   29cdc:	613b      	str	r3, [r7, #16]

    switch (cid)
   29cde:	897b      	ldrh	r3, [r7, #10]
   29ce0:	2b06      	cmp	r3, #6
   29ce2:	d013      	beq.n	29d0c <l2cHciAclCback+0xc8>
   29ce4:	2b06      	cmp	r3, #6
   29ce6:	dc18      	bgt.n	29d1a <l2cHciAclCback+0xd6>
   29ce8:	2b04      	cmp	r3, #4
   29cea:	d008      	beq.n	29cfe <l2cHciAclCback+0xba>
   29cec:	2b05      	cmp	r3, #5
   29cee:	d114      	bne.n	29d1a <l2cHciAclCback+0xd6>
    {
      case L2C_CID_LE_SIGNALING:
        (*l2cCb.l2cSignalingCback)(handle, l2cLen, pPacket);
   29cf0:	4b14      	ldr	r3, [pc, #80]	; (29d44 <l2cHciAclCback+0x100>)
   29cf2:	689b      	ldr	r3, [r3, #8]
   29cf4:	8af9      	ldrh	r1, [r7, #22]
   29cf6:	89f8      	ldrh	r0, [r7, #14]
   29cf8:	687a      	ldr	r2, [r7, #4]
   29cfa:	4798      	blx	r3
        break;
   29cfc:	e01b      	b.n	29d36 <l2cHciAclCback+0xf2>

      case L2C_CID_ATT:
        (*l2cCb.attDataCback)(handle, l2cLen, pPacket);
   29cfe:	4b11      	ldr	r3, [pc, #68]	; (29d44 <l2cHciAclCback+0x100>)
   29d00:	681b      	ldr	r3, [r3, #0]
   29d02:	8af9      	ldrh	r1, [r7, #22]
   29d04:	89f8      	ldrh	r0, [r7, #14]
   29d06:	687a      	ldr	r2, [r7, #4]
   29d08:	4798      	blx	r3
        break;
   29d0a:	e014      	b.n	29d36 <l2cHciAclCback+0xf2>

      case L2C_CID_SMP:
        (*l2cCb.smpDataCback)(handle, l2cLen, pPacket);
   29d0c:	4b0d      	ldr	r3, [pc, #52]	; (29d44 <l2cHciAclCback+0x100>)
   29d0e:	685b      	ldr	r3, [r3, #4]
   29d10:	8af9      	ldrh	r1, [r7, #22]
   29d12:	89f8      	ldrh	r0, [r7, #14]
   29d14:	687a      	ldr	r2, [r7, #4]
   29d16:	4798      	blx	r3
        break;
   29d18:	e00d      	b.n	29d36 <l2cHciAclCback+0xf2>

      default:
        (*l2cCb.l2cDataCidCback)(handle, cid, l2cLen, pPacket);
   29d1a:	4b0a      	ldr	r3, [pc, #40]	; (29d44 <l2cHciAclCback+0x100>)
   29d1c:	6a1c      	ldr	r4, [r3, #32]
   29d1e:	8afa      	ldrh	r2, [r7, #22]
   29d20:	8979      	ldrh	r1, [r7, #10]
   29d22:	89f8      	ldrh	r0, [r7, #14]
   29d24:	687b      	ldr	r3, [r7, #4]
   29d26:	47a0      	blx	r4
        break;
   29d28:	e005      	b.n	29d36 <l2cHciAclCback+0xf2>
    }
  }
  /* else length mismatch */
  else
  {
    L2C_TRACE_WARN2("length mismatch: l2c=%u hci=%u", l2cLen, hciLen);
   29d2a:	8afb      	ldrh	r3, [r7, #22]
   29d2c:	89ba      	ldrh	r2, [r7, #12]
   29d2e:	4619      	mov	r1, r3
   29d30:	4805      	ldr	r0, [pc, #20]	; (29d48 <l2cHciAclCback+0x104>)
   29d32:	f003 fe2d 	bl	2d990 <WsfTrace>
  }

  /* deallocate buffer */
  WsfMsgFree(pPacket);
   29d36:	6878      	ldr	r0, [r7, #4]
   29d38:	f003 f9d0 	bl	2d0dc <WsfMsgFree>
}
   29d3c:	bf00      	nop
   29d3e:	371c      	adds	r7, #28
   29d40:	46bd      	mov	sp, r7
   29d42:	bd90      	pop	{r4, r7, pc}
   29d44:	10011708 	.word	0x10011708
   29d48:	00045118 	.word	0x00045118

00029d4c <l2cHciFlowCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cHciFlowCback(uint16_t handle, bool_t flowDisabled)
{
   29d4c:	b580      	push	{r7, lr}
   29d4e:	b084      	sub	sp, #16
   29d50:	af00      	add	r7, sp, #0
   29d52:	4603      	mov	r3, r0
   29d54:	460a      	mov	r2, r1
   29d56:	80fb      	strh	r3, [r7, #6]
   29d58:	4613      	mov	r3, r2
   29d5a:	717b      	strb	r3, [r7, #5]
  wsfMsgHdr_t hdr;

  /* get conn ID for handle */
  if ((hdr.param = DmConnIdByHandle(handle)) != DM_CONN_ID_NONE)
   29d5c:	88fb      	ldrh	r3, [r7, #6]
   29d5e:	4618      	mov	r0, r3
   29d60:	f7f9 fb8a 	bl	23478 <DmConnIdByHandle>
   29d64:	4603      	mov	r3, r0
   29d66:	b29b      	uxth	r3, r3
   29d68:	81bb      	strh	r3, [r7, #12]
   29d6a:	89bb      	ldrh	r3, [r7, #12]
   29d6c:	2b00      	cmp	r3, #0
   29d6e:	d017      	beq.n	29da0 <l2cHciFlowCback+0x54>
  {
    /* execute higher layer flow control callbacks */
    hdr.event = flowDisabled;
   29d70:	797b      	ldrb	r3, [r7, #5]
   29d72:	73bb      	strb	r3, [r7, #14]
    (*l2cCb.attCtrlCback)(&hdr);
   29d74:	4b0c      	ldr	r3, [pc, #48]	; (29da8 <l2cHciFlowCback+0x5c>)
   29d76:	68db      	ldr	r3, [r3, #12]
   29d78:	f107 020c 	add.w	r2, r7, #12
   29d7c:	4610      	mov	r0, r2
   29d7e:	4798      	blx	r3
    hdr.event = flowDisabled;
   29d80:	797b      	ldrb	r3, [r7, #5]
   29d82:	73bb      	strb	r3, [r7, #14]
    (*l2cCb.smpCtrlCback)(&hdr);
   29d84:	4b08      	ldr	r3, [pc, #32]	; (29da8 <l2cHciFlowCback+0x5c>)
   29d86:	691b      	ldr	r3, [r3, #16]
   29d88:	f107 020c 	add.w	r2, r7, #12
   29d8c:	4610      	mov	r0, r2
   29d8e:	4798      	blx	r3

    /* execute connection oriented channel flow control callback */
    hdr.event = flowDisabled;
   29d90:	797b      	ldrb	r3, [r7, #5]
   29d92:	73bb      	strb	r3, [r7, #14]
    (*l2cCb.l2cCocCtrlCback)(&hdr);
   29d94:	4b04      	ldr	r3, [pc, #16]	; (29da8 <l2cHciFlowCback+0x5c>)
   29d96:	695b      	ldr	r3, [r3, #20]
   29d98:	f107 020c 	add.w	r2, r7, #12
   29d9c:	4610      	mov	r0, r2
   29d9e:	4798      	blx	r3
  }
}
   29da0:	bf00      	nop
   29da2:	3710      	adds	r7, #16
   29da4:	46bd      	mov	sp, r7
   29da6:	bd80      	pop	{r7, pc}
   29da8:	10011708 	.word	0x10011708

00029dac <l2cSendCmdReject>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void l2cSendCmdReject(uint16_t handle, uint8_t identifier, uint16_t reason)
{
   29dac:	b580      	push	{r7, lr}
   29dae:	b084      	sub	sp, #16
   29db0:	af00      	add	r7, sp, #0
   29db2:	4603      	mov	r3, r0
   29db4:	80fb      	strh	r3, [r7, #6]
   29db6:	460b      	mov	r3, r1
   29db8:	717b      	strb	r3, [r7, #5]
   29dba:	4613      	mov	r3, r2
   29dbc:	807b      	strh	r3, [r7, #2]
  uint8_t *pPacket;
  uint8_t *p;

  /* allocate msg buffer */
  if ((pPacket = l2cMsgAlloc(L2C_SIG_PKT_BASE_LEN + L2C_SIG_CMD_REJ_LEN)) != NULL)
   29dbe:	200e      	movs	r0, #14
   29dc0:	f000 f833 	bl	29e2a <l2cMsgAlloc>
   29dc4:	60f8      	str	r0, [r7, #12]
   29dc6:	68fb      	ldr	r3, [r7, #12]
   29dc8:	2b00      	cmp	r3, #0
   29dca:	d02a      	beq.n	29e22 <l2cSendCmdReject+0x76>
  {
    /* build message */
    p = pPacket + L2C_PAYLOAD_START;
   29dcc:	68fb      	ldr	r3, [r7, #12]
   29dce:	3308      	adds	r3, #8
   29dd0:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, L2C_SIG_CMD_REJ);         /* command code */
   29dd2:	68bb      	ldr	r3, [r7, #8]
   29dd4:	1c5a      	adds	r2, r3, #1
   29dd6:	60ba      	str	r2, [r7, #8]
   29dd8:	2201      	movs	r2, #1
   29dda:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, identifier);              /* identifier */
   29ddc:	68bb      	ldr	r3, [r7, #8]
   29dde:	1c5a      	adds	r2, r3, #1
   29de0:	60ba      	str	r2, [r7, #8]
   29de2:	797a      	ldrb	r2, [r7, #5]
   29de4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, L2C_SIG_CMD_REJ_LEN);    /* parameter length */
   29de6:	68bb      	ldr	r3, [r7, #8]
   29de8:	1c5a      	adds	r2, r3, #1
   29dea:	60ba      	str	r2, [r7, #8]
   29dec:	2202      	movs	r2, #2
   29dee:	701a      	strb	r2, [r3, #0]
   29df0:	68bb      	ldr	r3, [r7, #8]
   29df2:	1c5a      	adds	r2, r3, #1
   29df4:	60ba      	str	r2, [r7, #8]
   29df6:	2200      	movs	r2, #0
   29df8:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, reason);                 /* reason */
   29dfa:	68bb      	ldr	r3, [r7, #8]
   29dfc:	1c5a      	adds	r2, r3, #1
   29dfe:	60ba      	str	r2, [r7, #8]
   29e00:	887a      	ldrh	r2, [r7, #2]
   29e02:	b2d2      	uxtb	r2, r2
   29e04:	701a      	strb	r2, [r3, #0]
   29e06:	887b      	ldrh	r3, [r7, #2]
   29e08:	0a1b      	lsrs	r3, r3, #8
   29e0a:	b299      	uxth	r1, r3
   29e0c:	68bb      	ldr	r3, [r7, #8]
   29e0e:	1c5a      	adds	r2, r3, #1
   29e10:	60ba      	str	r2, [r7, #8]
   29e12:	b2ca      	uxtb	r2, r1
   29e14:	701a      	strb	r2, [r3, #0]

    /* send packet */
    L2cDataReq(L2C_CID_LE_SIGNALING, handle, (L2C_SIG_HDR_LEN + L2C_SIG_CMD_REJ_LEN), pPacket);
   29e16:	88f9      	ldrh	r1, [r7, #6]
   29e18:	68fb      	ldr	r3, [r7, #12]
   29e1a:	2206      	movs	r2, #6
   29e1c:	2005      	movs	r0, #5
   29e1e:	f000 f863 	bl	29ee8 <L2cDataReq>
  }
}
   29e22:	bf00      	nop
   29e24:	3710      	adds	r7, #16
   29e26:	46bd      	mov	sp, r7
   29e28:	bd80      	pop	{r7, pc}

00029e2a <l2cMsgAlloc>:
 *
 *  \return Pointer to data message buffer or NULL if allocation failed.
 */
/*************************************************************************************************/
void *l2cMsgAlloc(uint16_t len)
{
   29e2a:	b580      	push	{r7, lr}
   29e2c:	b082      	sub	sp, #8
   29e2e:	af00      	add	r7, sp, #0
   29e30:	4603      	mov	r3, r0
   29e32:	80fb      	strh	r3, [r7, #6]
  return WsfMsgDataAlloc(len, HCI_TX_DATA_TAILROOM);
   29e34:	88fb      	ldrh	r3, [r7, #6]
   29e36:	2100      	movs	r1, #0
   29e38:	4618      	mov	r0, r3
   29e3a:	f003 f923 	bl	2d084 <WsfMsgDataAlloc>
   29e3e:	4603      	mov	r3, r0
}
   29e40:	4618      	mov	r0, r3
   29e42:	3708      	adds	r7, #8
   29e44:	46bd      	mov	sp, r7
   29e46:	bd80      	pop	{r7, pc}

00029e48 <L2cInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cInit(void)
{
   29e48:	b580      	push	{r7, lr}
   29e4a:	af00      	add	r7, sp, #0
  /* Initialize control block */
  l2cCb.attDataCback = l2cDefaultDataCback;
   29e4c:	4b0f      	ldr	r3, [pc, #60]	; (29e8c <L2cInit+0x44>)
   29e4e:	4a10      	ldr	r2, [pc, #64]	; (29e90 <L2cInit+0x48>)
   29e50:	601a      	str	r2, [r3, #0]
  l2cCb.smpDataCback = l2cDefaultDataCback;
   29e52:	4b0e      	ldr	r3, [pc, #56]	; (29e8c <L2cInit+0x44>)
   29e54:	4a0e      	ldr	r2, [pc, #56]	; (29e90 <L2cInit+0x48>)
   29e56:	605a      	str	r2, [r3, #4]
  l2cCb.l2cSignalingCback = l2cRxSignalingPkt;
   29e58:	4b0c      	ldr	r3, [pc, #48]	; (29e8c <L2cInit+0x44>)
   29e5a:	4a0e      	ldr	r2, [pc, #56]	; (29e94 <L2cInit+0x4c>)
   29e5c:	609a      	str	r2, [r3, #8]
  l2cCb.attCtrlCback = l2cDefaultCtrlCback;
   29e5e:	4b0b      	ldr	r3, [pc, #44]	; (29e8c <L2cInit+0x44>)
   29e60:	4a0d      	ldr	r2, [pc, #52]	; (29e98 <L2cInit+0x50>)
   29e62:	60da      	str	r2, [r3, #12]
  l2cCb.smpCtrlCback = l2cDefaultCtrlCback;
   29e64:	4b09      	ldr	r3, [pc, #36]	; (29e8c <L2cInit+0x44>)
   29e66:	4a0c      	ldr	r2, [pc, #48]	; (29e98 <L2cInit+0x50>)
   29e68:	611a      	str	r2, [r3, #16]
  l2cCb.l2cCocCtrlCback = l2cDefaultCtrlCback;
   29e6a:	4b08      	ldr	r3, [pc, #32]	; (29e8c <L2cInit+0x44>)
   29e6c:	4a0a      	ldr	r2, [pc, #40]	; (29e98 <L2cInit+0x50>)
   29e6e:	615a      	str	r2, [r3, #20]
  l2cCb.l2cDataCidCback = l2cDefaultDataCidCback;
   29e70:	4b06      	ldr	r3, [pc, #24]	; (29e8c <L2cInit+0x44>)
   29e72:	4a0a      	ldr	r2, [pc, #40]	; (29e9c <L2cInit+0x54>)
   29e74:	621a      	str	r2, [r3, #32]
  l2cCb.identifier = 1;
   29e76:	4b05      	ldr	r3, [pc, #20]	; (29e8c <L2cInit+0x44>)
   29e78:	2201      	movs	r2, #1
   29e7a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Register with HCI */
  HciAclRegister(l2cHciAclCback, l2cHciFlowCback);
   29e7e:	4908      	ldr	r1, [pc, #32]	; (29ea0 <L2cInit+0x58>)
   29e80:	4808      	ldr	r0, [pc, #32]	; (29ea4 <L2cInit+0x5c>)
   29e82:	f7ff f8e9 	bl	29058 <HciAclRegister>
}
   29e86:	bf00      	nop
   29e88:	bd80      	pop	{r7, pc}
   29e8a:	bf00      	nop
   29e8c:	10011708 	.word	0x10011708
   29e90:	00029b55 	.word	0x00029b55
   29e94:	00029bb9 	.word	0x00029bb9
   29e98:	00029ba5 	.word	0x00029ba5
   29e9c:	00029b79 	.word	0x00029b79
   29ea0:	00029d4d 	.word	0x00029d4d
   29ea4:	00029c45 	.word	0x00029c45

00029ea8 <L2cRegister>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cRegister(uint16_t cid, l2cDataCback_t dataCback, l2cCtrlCback_t ctrlCback)
{
   29ea8:	b480      	push	{r7}
   29eaa:	b085      	sub	sp, #20
   29eac:	af00      	add	r7, sp, #0
   29eae:	4603      	mov	r3, r0
   29eb0:	60b9      	str	r1, [r7, #8]
   29eb2:	607a      	str	r2, [r7, #4]
   29eb4:	81fb      	strh	r3, [r7, #14]
  WSF_ASSERT((cid == L2C_CID_ATT) || (cid == L2C_CID_SMP));

  /* store the callbacks */
  if (cid == L2C_CID_ATT)
   29eb6:	89fb      	ldrh	r3, [r7, #14]
   29eb8:	2b04      	cmp	r3, #4
   29eba:	d106      	bne.n	29eca <L2cRegister+0x22>
  {
    /* registering for attribute protocol */
    l2cCb.attDataCback = dataCback;
   29ebc:	4a09      	ldr	r2, [pc, #36]	; (29ee4 <L2cRegister+0x3c>)
   29ebe:	68bb      	ldr	r3, [r7, #8]
   29ec0:	6013      	str	r3, [r2, #0]
    l2cCb.attCtrlCback = ctrlCback;
   29ec2:	4a08      	ldr	r2, [pc, #32]	; (29ee4 <L2cRegister+0x3c>)
   29ec4:	687b      	ldr	r3, [r7, #4]
   29ec6:	60d3      	str	r3, [r2, #12]
  {
    /* registering for security manager protocol */
    l2cCb.smpDataCback = dataCback;
    l2cCb.smpCtrlCback = ctrlCback;
  }
}
   29ec8:	e005      	b.n	29ed6 <L2cRegister+0x2e>
    l2cCb.smpDataCback = dataCback;
   29eca:	4a06      	ldr	r2, [pc, #24]	; (29ee4 <L2cRegister+0x3c>)
   29ecc:	68bb      	ldr	r3, [r7, #8]
   29ece:	6053      	str	r3, [r2, #4]
    l2cCb.smpCtrlCback = ctrlCback;
   29ed0:	4a04      	ldr	r2, [pc, #16]	; (29ee4 <L2cRegister+0x3c>)
   29ed2:	687b      	ldr	r3, [r7, #4]
   29ed4:	6113      	str	r3, [r2, #16]
}
   29ed6:	bf00      	nop
   29ed8:	3714      	adds	r7, #20
   29eda:	46bd      	mov	sp, r7
   29edc:	f85d 7b04 	ldr.w	r7, [sp], #4
   29ee0:	4770      	bx	lr
   29ee2:	bf00      	nop
   29ee4:	10011708 	.word	0x10011708

00029ee8 <L2cDataReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cDataReq(uint16_t cid, uint16_t handle, uint16_t len, uint8_t *pPacket)
{
   29ee8:	b580      	push	{r7, lr}
   29eea:	b086      	sub	sp, #24
   29eec:	af00      	add	r7, sp, #0
   29eee:	607b      	str	r3, [r7, #4]
   29ef0:	4603      	mov	r3, r0
   29ef2:	81fb      	strh	r3, [r7, #14]
   29ef4:	460b      	mov	r3, r1
   29ef6:	81bb      	strh	r3, [r7, #12]
   29ef8:	4613      	mov	r3, r2
   29efa:	817b      	strh	r3, [r7, #10]
  uint8_t *p = pPacket;
   29efc:	687b      	ldr	r3, [r7, #4]
   29efe:	617b      	str	r3, [r7, #20]

  /* Set HCI header */
  UINT16_TO_BSTREAM(p, handle);
   29f00:	697b      	ldr	r3, [r7, #20]
   29f02:	1c5a      	adds	r2, r3, #1
   29f04:	617a      	str	r2, [r7, #20]
   29f06:	89ba      	ldrh	r2, [r7, #12]
   29f08:	b2d2      	uxtb	r2, r2
   29f0a:	701a      	strb	r2, [r3, #0]
   29f0c:	89bb      	ldrh	r3, [r7, #12]
   29f0e:	0a1b      	lsrs	r3, r3, #8
   29f10:	b299      	uxth	r1, r3
   29f12:	697b      	ldr	r3, [r7, #20]
   29f14:	1c5a      	adds	r2, r3, #1
   29f16:	617a      	str	r2, [r7, #20]
   29f18:	b2ca      	uxtb	r2, r1
   29f1a:	701a      	strb	r2, [r3, #0]
  UINT16_TO_BSTREAM(p, (len + L2C_HDR_LEN));
   29f1c:	897b      	ldrh	r3, [r7, #10]
   29f1e:	b2da      	uxtb	r2, r3
   29f20:	697b      	ldr	r3, [r7, #20]
   29f22:	1c59      	adds	r1, r3, #1
   29f24:	6179      	str	r1, [r7, #20]
   29f26:	3204      	adds	r2, #4
   29f28:	b2d2      	uxtb	r2, r2
   29f2a:	701a      	strb	r2, [r3, #0]
   29f2c:	897b      	ldrh	r3, [r7, #10]
   29f2e:	3304      	adds	r3, #4
   29f30:	1219      	asrs	r1, r3, #8
   29f32:	697b      	ldr	r3, [r7, #20]
   29f34:	1c5a      	adds	r2, r3, #1
   29f36:	617a      	str	r2, [r7, #20]
   29f38:	b2ca      	uxtb	r2, r1
   29f3a:	701a      	strb	r2, [r3, #0]

  /* Set L2CAP header */
  UINT16_TO_BSTREAM(p, len);
   29f3c:	697b      	ldr	r3, [r7, #20]
   29f3e:	1c5a      	adds	r2, r3, #1
   29f40:	617a      	str	r2, [r7, #20]
   29f42:	897a      	ldrh	r2, [r7, #10]
   29f44:	b2d2      	uxtb	r2, r2
   29f46:	701a      	strb	r2, [r3, #0]
   29f48:	897b      	ldrh	r3, [r7, #10]
   29f4a:	0a1b      	lsrs	r3, r3, #8
   29f4c:	b299      	uxth	r1, r3
   29f4e:	697b      	ldr	r3, [r7, #20]
   29f50:	1c5a      	adds	r2, r3, #1
   29f52:	617a      	str	r2, [r7, #20]
   29f54:	b2ca      	uxtb	r2, r1
   29f56:	701a      	strb	r2, [r3, #0]
  UINT16_TO_BSTREAM(p, cid);
   29f58:	697b      	ldr	r3, [r7, #20]
   29f5a:	1c5a      	adds	r2, r3, #1
   29f5c:	617a      	str	r2, [r7, #20]
   29f5e:	89fa      	ldrh	r2, [r7, #14]
   29f60:	b2d2      	uxtb	r2, r2
   29f62:	701a      	strb	r2, [r3, #0]
   29f64:	89fb      	ldrh	r3, [r7, #14]
   29f66:	0a1b      	lsrs	r3, r3, #8
   29f68:	b299      	uxth	r1, r3
   29f6a:	697b      	ldr	r3, [r7, #20]
   29f6c:	1c5a      	adds	r2, r3, #1
   29f6e:	617a      	str	r2, [r7, #20]
   29f70:	b2ca      	uxtb	r2, r1
   29f72:	701a      	strb	r2, [r3, #0]

  /* Send to HCI */
  HciSendAclData(pPacket);
   29f74:	6878      	ldr	r0, [r7, #4]
   29f76:	f7fc f91f 	bl	261b8 <HciSendAclData>
}
   29f7a:	bf00      	nop
   29f7c:	3718      	adds	r7, #24
   29f7e:	46bd      	mov	sp, r7
   29f80:	bd80      	pop	{r7, pc}
	...

00029f84 <l2cMasterRxSignalingPkt>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cMasterRxSignalingPkt(uint16_t handle, uint16_t l2cLen, uint8_t *pPacket)
{
   29f84:	b580      	push	{r7, lr}
   29f86:	b086      	sub	sp, #24
   29f88:	af00      	add	r7, sp, #0
   29f8a:	4603      	mov	r3, r0
   29f8c:	603a      	str	r2, [r7, #0]
   29f8e:	80fb      	strh	r3, [r7, #6]
   29f90:	460b      	mov	r3, r1
   29f92:	80bb      	strh	r3, [r7, #4]
  uint8_t       id;
  uint16_t      len;
  hciConnSpec_t connSpec;

  /* parse code, len, and identifier */
  pPacket += L2C_PAYLOAD_START;
   29f94:	683b      	ldr	r3, [r7, #0]
   29f96:	3308      	adds	r3, #8
   29f98:	603b      	str	r3, [r7, #0]
  BSTREAM_TO_UINT8(code, pPacket);
   29f9a:	683b      	ldr	r3, [r7, #0]
   29f9c:	1c5a      	adds	r2, r3, #1
   29f9e:	603a      	str	r2, [r7, #0]
   29fa0:	781b      	ldrb	r3, [r3, #0]
   29fa2:	75fb      	strb	r3, [r7, #23]
  BSTREAM_TO_UINT8(id, pPacket);
   29fa4:	683b      	ldr	r3, [r7, #0]
   29fa6:	1c5a      	adds	r2, r3, #1
   29fa8:	603a      	str	r2, [r7, #0]
   29faa:	781b      	ldrb	r3, [r3, #0]
   29fac:	75bb      	strb	r3, [r7, #22]
  BSTREAM_TO_UINT16(len, pPacket);
   29fae:	683b      	ldr	r3, [r7, #0]
   29fb0:	781b      	ldrb	r3, [r3, #0]
   29fb2:	b29a      	uxth	r2, r3
   29fb4:	683b      	ldr	r3, [r7, #0]
   29fb6:	3301      	adds	r3, #1
   29fb8:	781b      	ldrb	r3, [r3, #0]
   29fba:	b29b      	uxth	r3, r3
   29fbc:	021b      	lsls	r3, r3, #8
   29fbe:	b29b      	uxth	r3, r3
   29fc0:	4413      	add	r3, r2
   29fc2:	82bb      	strh	r3, [r7, #20]
   29fc4:	683b      	ldr	r3, [r7, #0]
   29fc6:	3302      	adds	r3, #2
   29fc8:	603b      	str	r3, [r7, #0]

  /* verify signaling length vs. l2c length
   * verify this is a conn param update rsp
   * verify parameter length
   */
  if ((l2cLen != (len + L2C_SIG_HDR_LEN)) ||
   29fca:	88ba      	ldrh	r2, [r7, #4]
   29fcc:	8abb      	ldrh	r3, [r7, #20]
   29fce:	3304      	adds	r3, #4
   29fd0:	429a      	cmp	r2, r3
   29fd2:	d105      	bne.n	29fe0 <l2cMasterRxSignalingPkt+0x5c>
   29fd4:	7dfb      	ldrb	r3, [r7, #23]
   29fd6:	2b12      	cmp	r3, #18
   29fd8:	d102      	bne.n	29fe0 <l2cMasterRxSignalingPkt+0x5c>
      (code != L2C_SIG_CONN_UPDATE_REQ) ||
   29fda:	8abb      	ldrh	r3, [r7, #20]
   29fdc:	2b08      	cmp	r3, #8
   29fde:	d00f      	beq.n	2a000 <l2cMasterRxSignalingPkt+0x7c>
      (len != L2C_SIG_CONN_UPDATE_REQ_LEN))
  {
    L2C_TRACE_WARN3("invalid msg code:%d len:%d l2cLen:%d", code, len, l2cLen);
   29fe0:	7df9      	ldrb	r1, [r7, #23]
   29fe2:	8aba      	ldrh	r2, [r7, #20]
   29fe4:	88bb      	ldrh	r3, [r7, #4]
   29fe6:	4841      	ldr	r0, [pc, #260]	; (2a0ec <l2cMasterRxSignalingPkt+0x168>)
   29fe8:	f003 fcd2 	bl	2d990 <WsfTrace>

    /* reject all unknown or invalid commands except command reject. */
    if (code != L2C_SIG_CMD_REJ)
   29fec:	7dfb      	ldrb	r3, [r7, #23]
   29fee:	2b01      	cmp	r3, #1
   29ff0:	d075      	beq.n	2a0de <l2cMasterRxSignalingPkt+0x15a>
    {
      l2cSendCmdReject(handle, id, L2C_REJ_NOT_UNDERSTOOD);
   29ff2:	7db9      	ldrb	r1, [r7, #22]
   29ff4:	88fb      	ldrh	r3, [r7, #6]
   29ff6:	2200      	movs	r2, #0
   29ff8:	4618      	mov	r0, r3
   29ffa:	f7ff fed7 	bl	29dac <l2cSendCmdReject>
    }

    return;
   29ffe:	e06e      	b.n	2a0de <l2cMasterRxSignalingPkt+0x15a>
  }

  /* check the validity of data length */
  L2C_CHECK_DATA_LENGTH(len, L2C_SIG_CONN_UPDATE_REQ_LEN);
   2a000:	8abb      	ldrh	r3, [r7, #20]
   2a002:	2b07      	cmp	r3, #7
   2a004:	d96d      	bls.n	2a0e2 <l2cMasterRxSignalingPkt+0x15e>

  /* parse parameters */
  BSTREAM_TO_UINT16(connSpec.connIntervalMin, pPacket);
   2a006:	683b      	ldr	r3, [r7, #0]
   2a008:	781b      	ldrb	r3, [r3, #0]
   2a00a:	b29a      	uxth	r2, r3
   2a00c:	683b      	ldr	r3, [r7, #0]
   2a00e:	3301      	adds	r3, #1
   2a010:	781b      	ldrb	r3, [r3, #0]
   2a012:	b29b      	uxth	r3, r3
   2a014:	021b      	lsls	r3, r3, #8
   2a016:	b29b      	uxth	r3, r3
   2a018:	4413      	add	r3, r2
   2a01a:	b29b      	uxth	r3, r3
   2a01c:	813b      	strh	r3, [r7, #8]
   2a01e:	683b      	ldr	r3, [r7, #0]
   2a020:	3302      	adds	r3, #2
   2a022:	603b      	str	r3, [r7, #0]
  BSTREAM_TO_UINT16(connSpec.connIntervalMax, pPacket);
   2a024:	683b      	ldr	r3, [r7, #0]
   2a026:	781b      	ldrb	r3, [r3, #0]
   2a028:	b29a      	uxth	r2, r3
   2a02a:	683b      	ldr	r3, [r7, #0]
   2a02c:	3301      	adds	r3, #1
   2a02e:	781b      	ldrb	r3, [r3, #0]
   2a030:	b29b      	uxth	r3, r3
   2a032:	021b      	lsls	r3, r3, #8
   2a034:	b29b      	uxth	r3, r3
   2a036:	4413      	add	r3, r2
   2a038:	b29b      	uxth	r3, r3
   2a03a:	817b      	strh	r3, [r7, #10]
   2a03c:	683b      	ldr	r3, [r7, #0]
   2a03e:	3302      	adds	r3, #2
   2a040:	603b      	str	r3, [r7, #0]
  BSTREAM_TO_UINT16(connSpec.connLatency, pPacket);
   2a042:	683b      	ldr	r3, [r7, #0]
   2a044:	781b      	ldrb	r3, [r3, #0]
   2a046:	b29a      	uxth	r2, r3
   2a048:	683b      	ldr	r3, [r7, #0]
   2a04a:	3301      	adds	r3, #1
   2a04c:	781b      	ldrb	r3, [r3, #0]
   2a04e:	b29b      	uxth	r3, r3
   2a050:	021b      	lsls	r3, r3, #8
   2a052:	b29b      	uxth	r3, r3
   2a054:	4413      	add	r3, r2
   2a056:	b29b      	uxth	r3, r3
   2a058:	81bb      	strh	r3, [r7, #12]
   2a05a:	683b      	ldr	r3, [r7, #0]
   2a05c:	3302      	adds	r3, #2
   2a05e:	603b      	str	r3, [r7, #0]
  BSTREAM_TO_UINT16(connSpec.supTimeout, pPacket);
   2a060:	683b      	ldr	r3, [r7, #0]
   2a062:	781b      	ldrb	r3, [r3, #0]
   2a064:	b29a      	uxth	r2, r3
   2a066:	683b      	ldr	r3, [r7, #0]
   2a068:	3301      	adds	r3, #1
   2a06a:	781b      	ldrb	r3, [r3, #0]
   2a06c:	b29b      	uxth	r3, r3
   2a06e:	021b      	lsls	r3, r3, #8
   2a070:	b29b      	uxth	r3, r3
   2a072:	4413      	add	r3, r2
   2a074:	b29b      	uxth	r3, r3
   2a076:	81fb      	strh	r3, [r7, #14]
   2a078:	683b      	ldr	r3, [r7, #0]
   2a07a:	3302      	adds	r3, #2
   2a07c:	603b      	str	r3, [r7, #0]
  connSpec.minCeLen = 0;
   2a07e:	2300      	movs	r3, #0
   2a080:	823b      	strh	r3, [r7, #16]
  connSpec.maxCeLen = 0;
   2a082:	2300      	movs	r3, #0
   2a084:	827b      	strh	r3, [r7, #18]

  /* check parameter range */
  if ((connSpec.connIntervalMin < HCI_CONN_INTERVAL_MIN) ||
   2a086:	893b      	ldrh	r3, [r7, #8]
   2a088:	2b05      	cmp	r3, #5
   2a08a:	d919      	bls.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.connIntervalMin > HCI_CONN_INTERVAL_MAX) ||
   2a08c:	893b      	ldrh	r3, [r7, #8]
  if ((connSpec.connIntervalMin < HCI_CONN_INTERVAL_MIN) ||
   2a08e:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2a092:	d815      	bhi.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.connIntervalMin > connSpec.connIntervalMax) ||
   2a094:	893a      	ldrh	r2, [r7, #8]
   2a096:	897b      	ldrh	r3, [r7, #10]
      (connSpec.connIntervalMin > HCI_CONN_INTERVAL_MAX) ||
   2a098:	429a      	cmp	r2, r3
   2a09a:	d811      	bhi.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.connIntervalMax < HCI_CONN_INTERVAL_MIN) ||
   2a09c:	897b      	ldrh	r3, [r7, #10]
      (connSpec.connIntervalMin > connSpec.connIntervalMax) ||
   2a09e:	2b05      	cmp	r3, #5
   2a0a0:	d90e      	bls.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.connIntervalMax > HCI_CONN_INTERVAL_MAX) ||
   2a0a2:	897b      	ldrh	r3, [r7, #10]
      (connSpec.connIntervalMax < HCI_CONN_INTERVAL_MIN) ||
   2a0a4:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2a0a8:	d80a      	bhi.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.connLatency > HCI_CONN_LATENCY_MAX) ||
   2a0aa:	89bb      	ldrh	r3, [r7, #12]
      (connSpec.connIntervalMax > HCI_CONN_INTERVAL_MAX) ||
   2a0ac:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
   2a0b0:	d206      	bcs.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.supTimeout < HCI_SUP_TIMEOUT_MIN) ||
   2a0b2:	89fb      	ldrh	r3, [r7, #14]
      (connSpec.connLatency > HCI_CONN_LATENCY_MAX) ||
   2a0b4:	2b09      	cmp	r3, #9
   2a0b6:	d903      	bls.n	2a0c0 <l2cMasterRxSignalingPkt+0x13c>
      (connSpec.supTimeout > HCI_SUP_TIMEOUT_MAX))
   2a0b8:	89fb      	ldrh	r3, [r7, #14]
      (connSpec.supTimeout < HCI_SUP_TIMEOUT_MIN) ||
   2a0ba:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
   2a0be:	d906      	bls.n	2a0ce <l2cMasterRxSignalingPkt+0x14a>
  {
    L2cDmConnUpdateRsp(id, handle, L2C_CONN_PARAM_REJECTED);
   2a0c0:	88f9      	ldrh	r1, [r7, #6]
   2a0c2:	7dbb      	ldrb	r3, [r7, #22]
   2a0c4:	2201      	movs	r2, #1
   2a0c6:	4618      	mov	r0, r3
   2a0c8:	f000 f820 	bl	2a10c <L2cDmConnUpdateRsp>
    return;
   2a0cc:	e00a      	b.n	2a0e4 <l2cMasterRxSignalingPkt+0x160>
  }

  DmL2cConnUpdateInd(id, handle, &connSpec);
   2a0ce:	f107 0208 	add.w	r2, r7, #8
   2a0d2:	88f9      	ldrh	r1, [r7, #6]
   2a0d4:	7dbb      	ldrb	r3, [r7, #22]
   2a0d6:	4618      	mov	r0, r3
   2a0d8:	f7f9 fb27 	bl	2372a <DmL2cConnUpdateInd>
   2a0dc:	e002      	b.n	2a0e4 <l2cMasterRxSignalingPkt+0x160>
    return;
   2a0de:	bf00      	nop
   2a0e0:	e000      	b.n	2a0e4 <l2cMasterRxSignalingPkt+0x160>
  L2C_CHECK_DATA_LENGTH(len, L2C_SIG_CONN_UPDATE_REQ_LEN);
   2a0e2:	bf00      	nop
}
   2a0e4:	3718      	adds	r7, #24
   2a0e6:	46bd      	mov	sp, r7
   2a0e8:	bd80      	pop	{r7, pc}
   2a0ea:	bf00      	nop
   2a0ec:	00045138 	.word	0x00045138

0002a0f0 <L2cMasterInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cMasterInit(void)
{
   2a0f0:	b480      	push	{r7}
   2a0f2:	af00      	add	r7, sp, #0
  l2cCb.masterRxSignalingPkt = l2cMasterRxSignalingPkt;
   2a0f4:	4b03      	ldr	r3, [pc, #12]	; (2a104 <L2cMasterInit+0x14>)
   2a0f6:	4a04      	ldr	r2, [pc, #16]	; (2a108 <L2cMasterInit+0x18>)
   2a0f8:	619a      	str	r2, [r3, #24]
}
   2a0fa:	bf00      	nop
   2a0fc:	46bd      	mov	sp, r7
   2a0fe:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a102:	4770      	bx	lr
   2a104:	10011708 	.word	0x10011708
   2a108:	00029f85 	.word	0x00029f85

0002a10c <L2cDmConnUpdateRsp>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cDmConnUpdateRsp(uint8_t identifier, uint16_t handle, uint16_t result)
{
   2a10c:	b580      	push	{r7, lr}
   2a10e:	b084      	sub	sp, #16
   2a110:	af00      	add	r7, sp, #0
   2a112:	4603      	mov	r3, r0
   2a114:	71fb      	strb	r3, [r7, #7]
   2a116:	460b      	mov	r3, r1
   2a118:	80bb      	strh	r3, [r7, #4]
   2a11a:	4613      	mov	r3, r2
   2a11c:	807b      	strh	r3, [r7, #2]
  uint8_t *pPacket;
  uint8_t *p;

  /* allocate msg buffer */
  if ((pPacket = l2cMsgAlloc(L2C_SIG_PKT_BASE_LEN + L2C_SIG_CONN_UPDATE_RSP_LEN)) != NULL)
   2a11e:	200e      	movs	r0, #14
   2a120:	f7ff fe83 	bl	29e2a <l2cMsgAlloc>
   2a124:	60f8      	str	r0, [r7, #12]
   2a126:	68fb      	ldr	r3, [r7, #12]
   2a128:	2b00      	cmp	r3, #0
   2a12a:	d02a      	beq.n	2a182 <L2cDmConnUpdateRsp+0x76>
  {
    /* build message */
    p = pPacket + L2C_PAYLOAD_START;
   2a12c:	68fb      	ldr	r3, [r7, #12]
   2a12e:	3308      	adds	r3, #8
   2a130:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, L2C_SIG_CONN_UPDATE_RSP);       /* command code */
   2a132:	68bb      	ldr	r3, [r7, #8]
   2a134:	1c5a      	adds	r2, r3, #1
   2a136:	60ba      	str	r2, [r7, #8]
   2a138:	2213      	movs	r2, #19
   2a13a:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, identifier);                    /* identifier */
   2a13c:	68bb      	ldr	r3, [r7, #8]
   2a13e:	1c5a      	adds	r2, r3, #1
   2a140:	60ba      	str	r2, [r7, #8]
   2a142:	79fa      	ldrb	r2, [r7, #7]
   2a144:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, L2C_SIG_CONN_UPDATE_RSP_LEN);  /* parameter length */
   2a146:	68bb      	ldr	r3, [r7, #8]
   2a148:	1c5a      	adds	r2, r3, #1
   2a14a:	60ba      	str	r2, [r7, #8]
   2a14c:	2202      	movs	r2, #2
   2a14e:	701a      	strb	r2, [r3, #0]
   2a150:	68bb      	ldr	r3, [r7, #8]
   2a152:	1c5a      	adds	r2, r3, #1
   2a154:	60ba      	str	r2, [r7, #8]
   2a156:	2200      	movs	r2, #0
   2a158:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, result);                       /* result */
   2a15a:	68bb      	ldr	r3, [r7, #8]
   2a15c:	1c5a      	adds	r2, r3, #1
   2a15e:	60ba      	str	r2, [r7, #8]
   2a160:	887a      	ldrh	r2, [r7, #2]
   2a162:	b2d2      	uxtb	r2, r2
   2a164:	701a      	strb	r2, [r3, #0]
   2a166:	887b      	ldrh	r3, [r7, #2]
   2a168:	0a1b      	lsrs	r3, r3, #8
   2a16a:	b299      	uxth	r1, r3
   2a16c:	68bb      	ldr	r3, [r7, #8]
   2a16e:	1c5a      	adds	r2, r3, #1
   2a170:	60ba      	str	r2, [r7, #8]
   2a172:	b2ca      	uxtb	r2, r1
   2a174:	701a      	strb	r2, [r3, #0]

    /* send packet */
    L2cDataReq(L2C_CID_LE_SIGNALING, handle, (L2C_SIG_HDR_LEN + L2C_SIG_CONN_UPDATE_RSP_LEN), pPacket);
   2a176:	88b9      	ldrh	r1, [r7, #4]
   2a178:	68fb      	ldr	r3, [r7, #12]
   2a17a:	2206      	movs	r2, #6
   2a17c:	2005      	movs	r0, #5
   2a17e:	f7ff feb3 	bl	29ee8 <L2cDataReq>
  }
}
   2a182:	bf00      	nop
   2a184:	3710      	adds	r7, #16
   2a186:	46bd      	mov	sp, r7
   2a188:	bd80      	pop	{r7, pc}
	...

0002a18c <l2cSlaveReqTimeout>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cSlaveReqTimeout(wsfMsgHdr_t *pMsg)
{
   2a18c:	b580      	push	{r7, lr}
   2a18e:	b082      	sub	sp, #8
   2a190:	af00      	add	r7, sp, #0
   2a192:	6078      	str	r0, [r7, #4]
  L2C_TRACE_WARN0("conn update req timeout");
   2a194:	4806      	ldr	r0, [pc, #24]	; (2a1b0 <l2cSlaveReqTimeout+0x24>)
   2a196:	f003 fbfb 	bl	2d990 <WsfTrace>

  /* Notify DM that connection update has failed (handle is stored in param) */
  DmL2cConnUpdateCnf(pMsg->param, L2C_CONN_PARAM_REJECTED);
   2a19a:	687b      	ldr	r3, [r7, #4]
   2a19c:	881b      	ldrh	r3, [r3, #0]
   2a19e:	2101      	movs	r1, #1
   2a1a0:	4618      	mov	r0, r3
   2a1a2:	f7f9 fbd3 	bl	2394c <DmL2cConnUpdateCnf>
}
   2a1a6:	bf00      	nop
   2a1a8:	3708      	adds	r7, #8
   2a1aa:	46bd      	mov	sp, r7
   2a1ac:	bd80      	pop	{r7, pc}
   2a1ae:	bf00      	nop
   2a1b0:	00045160 	.word	0x00045160

0002a1b4 <l2cSlaveRxSignalingPkt>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void l2cSlaveRxSignalingPkt(uint16_t handle, uint16_t l2cLen, uint8_t *pPacket)
{
   2a1b4:	b580      	push	{r7, lr}
   2a1b6:	b084      	sub	sp, #16
   2a1b8:	af00      	add	r7, sp, #0
   2a1ba:	4603      	mov	r3, r0
   2a1bc:	603a      	str	r2, [r7, #0]
   2a1be:	80fb      	strh	r3, [r7, #6]
   2a1c0:	460b      	mov	r3, r1
   2a1c2:	80bb      	strh	r3, [r7, #4]
  uint8_t   id;
  uint16_t  len;
  uint16_t  result;

  /* parse code, len, and identifier */
  pPacket += L2C_PAYLOAD_START;
   2a1c4:	683b      	ldr	r3, [r7, #0]
   2a1c6:	3308      	adds	r3, #8
   2a1c8:	603b      	str	r3, [r7, #0]
  BSTREAM_TO_UINT8(code, pPacket);
   2a1ca:	683b      	ldr	r3, [r7, #0]
   2a1cc:	1c5a      	adds	r2, r3, #1
   2a1ce:	603a      	str	r2, [r7, #0]
   2a1d0:	781b      	ldrb	r3, [r3, #0]
   2a1d2:	737b      	strb	r3, [r7, #13]
  BSTREAM_TO_UINT8(id, pPacket);
   2a1d4:	683b      	ldr	r3, [r7, #0]
   2a1d6:	1c5a      	adds	r2, r3, #1
   2a1d8:	603a      	str	r2, [r7, #0]
   2a1da:	781b      	ldrb	r3, [r3, #0]
   2a1dc:	733b      	strb	r3, [r7, #12]
  BSTREAM_TO_UINT16(len, pPacket);
   2a1de:	683b      	ldr	r3, [r7, #0]
   2a1e0:	781b      	ldrb	r3, [r3, #0]
   2a1e2:	b29a      	uxth	r2, r3
   2a1e4:	683b      	ldr	r3, [r7, #0]
   2a1e6:	3301      	adds	r3, #1
   2a1e8:	781b      	ldrb	r3, [r3, #0]
   2a1ea:	b29b      	uxth	r3, r3
   2a1ec:	021b      	lsls	r3, r3, #8
   2a1ee:	b29b      	uxth	r3, r3
   2a1f0:	4413      	add	r3, r2
   2a1f2:	817b      	strh	r3, [r7, #10]
   2a1f4:	683b      	ldr	r3, [r7, #0]
   2a1f6:	3302      	adds	r3, #2
   2a1f8:	603b      	str	r3, [r7, #0]

  /* verify signal identifier is valid */
  if (id == L2C_SIGNAL_ID_INVALID)
   2a1fa:	7b3b      	ldrb	r3, [r7, #12]
   2a1fc:	2b00      	cmp	r3, #0
   2a1fe:	d055      	beq.n	2a2ac <l2cSlaveRxSignalingPkt+0xf8>
  /* verify signal identifier is expected
   * verify signaling length vs. l2c length
   * verify this is a conn param update rsp or command reject
   * verify parameter length
   */
  if ((id == l2cSlaveCb.signId[handle])   &&
   2a200:	88fb      	ldrh	r3, [r7, #6]
   2a202:	4a2d      	ldr	r2, [pc, #180]	; (2a2b8 <l2cSlaveRxSignalingPkt+0x104>)
   2a204:	4413      	add	r3, r2
   2a206:	7d1b      	ldrb	r3, [r3, #20]
   2a208:	7b3a      	ldrb	r2, [r7, #12]
   2a20a:	429a      	cmp	r2, r3
   2a20c:	d13e      	bne.n	2a28c <l2cSlaveRxSignalingPkt+0xd8>
      (l2cLen == (len + L2C_SIG_HDR_LEN)) &&
   2a20e:	88ba      	ldrh	r2, [r7, #4]
   2a210:	897b      	ldrh	r3, [r7, #10]
   2a212:	3304      	adds	r3, #4
  if ((id == l2cSlaveCb.signId[handle])   &&
   2a214:	429a      	cmp	r2, r3
   2a216:	d139      	bne.n	2a28c <l2cSlaveRxSignalingPkt+0xd8>
      (l2cLen == (len + L2C_SIG_HDR_LEN)) &&
   2a218:	7b7b      	ldrb	r3, [r7, #13]
   2a21a:	2b13      	cmp	r3, #19
   2a21c:	d102      	bne.n	2a224 <l2cSlaveRxSignalingPkt+0x70>
      (((code == L2C_SIG_CONN_UPDATE_RSP) && (len == L2C_SIG_CONN_UPDATE_RSP_LEN)) ||
   2a21e:	897b      	ldrh	r3, [r7, #10]
   2a220:	2b02      	cmp	r3, #2
   2a222:	d002      	beq.n	2a22a <l2cSlaveRxSignalingPkt+0x76>
   2a224:	7b7b      	ldrb	r3, [r7, #13]
   2a226:	2b01      	cmp	r3, #1
   2a228:	d130      	bne.n	2a28c <l2cSlaveRxSignalingPkt+0xd8>
       (code == L2C_SIG_CMD_REJ)))
  {
    /* get last sent code */
    uint8_t lastCode = l2cSlaveCb.lastCode[handle];
   2a22a:	88fb      	ldrh	r3, [r7, #6]
   2a22c:	4a22      	ldr	r2, [pc, #136]	; (2a2b8 <l2cSlaveRxSignalingPkt+0x104>)
   2a22e:	4413      	add	r3, r2
   2a230:	7c5b      	ldrb	r3, [r3, #17]
   2a232:	727b      	strb	r3, [r7, #9]

    /* clear pending signal id */
    l2cSlaveCb.signId[handle] = L2C_SIGNAL_ID_INVALID;
   2a234:	88fb      	ldrh	r3, [r7, #6]
   2a236:	4a20      	ldr	r2, [pc, #128]	; (2a2b8 <l2cSlaveRxSignalingPkt+0x104>)
   2a238:	4413      	add	r3, r2
   2a23a:	2200      	movs	r2, #0
   2a23c:	751a      	strb	r2, [r3, #20]

    /* parse result parameter */
    BSTREAM_TO_UINT16(result, pPacket);
   2a23e:	683b      	ldr	r3, [r7, #0]
   2a240:	781b      	ldrb	r3, [r3, #0]
   2a242:	b29a      	uxth	r2, r3
   2a244:	683b      	ldr	r3, [r7, #0]
   2a246:	3301      	adds	r3, #1
   2a248:	781b      	ldrb	r3, [r3, #0]
   2a24a:	b29b      	uxth	r3, r3
   2a24c:	021b      	lsls	r3, r3, #8
   2a24e:	b29b      	uxth	r3, r3
   2a250:	4413      	add	r3, r2
   2a252:	81fb      	strh	r3, [r7, #14]
   2a254:	683b      	ldr	r3, [r7, #0]
   2a256:	3302      	adds	r3, #2
   2a258:	603b      	str	r3, [r7, #0]

    /* stop req timer */
    WsfTimerStop(&l2cSlaveCb.reqTimer);
   2a25a:	4817      	ldr	r0, [pc, #92]	; (2a2b8 <l2cSlaveRxSignalingPkt+0x104>)
   2a25c:	f003 faec 	bl	2d838 <WsfTimerStop>

    if (lastCode == L2C_SIG_CONN_UPDATE_REQ)
   2a260:	7a7b      	ldrb	r3, [r7, #9]
   2a262:	2b12      	cmp	r3, #18
   2a264:	d10b      	bne.n	2a27e <l2cSlaveRxSignalingPkt+0xca>
    {
      if (code == L2C_SIG_CMD_REJ)
   2a266:	7b7b      	ldrb	r3, [r7, #13]
   2a268:	2b01      	cmp	r3, #1
   2a26a:	d101      	bne.n	2a270 <l2cSlaveRxSignalingPkt+0xbc>
      {
        /* got command reject */
        result = L2C_CONN_PARAM_REJECTED;
   2a26c:	2301      	movs	r3, #1
   2a26e:	81fb      	strh	r3, [r7, #14]
      }

      /* send to DM */
      DmL2cConnUpdateCnf(handle, result);
   2a270:	89fa      	ldrh	r2, [r7, #14]
   2a272:	88fb      	ldrh	r3, [r7, #6]
   2a274:	4611      	mov	r1, r2
   2a276:	4618      	mov	r0, r3
   2a278:	f7f9 fb68 	bl	2394c <DmL2cConnUpdateCnf>
  {
   2a27c:	e019      	b.n	2a2b2 <l2cSlaveRxSignalingPkt+0xfe>
    }
    else
    {
      /* send to DM */
      DmL2cCmdRejInd(handle, result);
   2a27e:	89fa      	ldrh	r2, [r7, #14]
   2a280:	88fb      	ldrh	r3, [r7, #6]
   2a282:	4611      	mov	r1, r2
   2a284:	4618      	mov	r0, r3
   2a286:	f7f9 fb7f 	bl	23988 <DmL2cCmdRejInd>
  {
   2a28a:	e012      	b.n	2a2b2 <l2cSlaveRxSignalingPkt+0xfe>
    }
  }
  else
  {
    L2C_TRACE_WARN3("invalid msg code:%d len:%d l2cLen:%d", code, len, l2cLen);
   2a28c:	7b79      	ldrb	r1, [r7, #13]
   2a28e:	897a      	ldrh	r2, [r7, #10]
   2a290:	88bb      	ldrh	r3, [r7, #4]
   2a292:	480a      	ldr	r0, [pc, #40]	; (2a2bc <l2cSlaveRxSignalingPkt+0x108>)
   2a294:	f003 fb7c 	bl	2d990 <WsfTrace>

    /* reject all unknown, invalid or unidentified commands except command reject. */
    if (code != L2C_SIG_CMD_REJ)
   2a298:	7b7b      	ldrb	r3, [r7, #13]
   2a29a:	2b01      	cmp	r3, #1
   2a29c:	d008      	beq.n	2a2b0 <l2cSlaveRxSignalingPkt+0xfc>
    {
      l2cSendCmdReject(handle, id, L2C_REJ_NOT_UNDERSTOOD);
   2a29e:	7b39      	ldrb	r1, [r7, #12]
   2a2a0:	88fb      	ldrh	r3, [r7, #6]
   2a2a2:	2200      	movs	r2, #0
   2a2a4:	4618      	mov	r0, r3
   2a2a6:	f7ff fd81 	bl	29dac <l2cSendCmdReject>
    }

    return;
   2a2aa:	e001      	b.n	2a2b0 <l2cSlaveRxSignalingPkt+0xfc>
    return;
   2a2ac:	bf00      	nop
   2a2ae:	e000      	b.n	2a2b2 <l2cSlaveRxSignalingPkt+0xfe>
    return;
   2a2b0:	bf00      	nop
  }
}
   2a2b2:	3710      	adds	r7, #16
   2a2b4:	46bd      	mov	sp, r7
   2a2b6:	bd80      	pop	{r7, pc}
   2a2b8:	10007fc8 	.word	0x10007fc8
   2a2bc:	00045178 	.word	0x00045178

0002a2c0 <L2cSlaveInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cSlaveInit(void)
{
   2a2c0:	b480      	push	{r7}
   2a2c2:	b083      	sub	sp, #12
   2a2c4:	af00      	add	r7, sp, #0
  l2cCb.slaveRxSignalingPkt = l2cSlaveRxSignalingPkt;
   2a2c6:	4b0c      	ldr	r3, [pc, #48]	; (2a2f8 <L2cSlaveInit+0x38>)
   2a2c8:	4a0c      	ldr	r2, [pc, #48]	; (2a2fc <L2cSlaveInit+0x3c>)
   2a2ca:	61da      	str	r2, [r3, #28]

  for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   2a2cc:	2300      	movs	r3, #0
   2a2ce:	71fb      	strb	r3, [r7, #7]
   2a2d0:	e007      	b.n	2a2e2 <L2cSlaveInit+0x22>
  {
    l2cSlaveCb.signId[i] = L2C_SIGNAL_ID_INVALID;
   2a2d2:	79fb      	ldrb	r3, [r7, #7]
   2a2d4:	4a0a      	ldr	r2, [pc, #40]	; (2a300 <L2cSlaveInit+0x40>)
   2a2d6:	4413      	add	r3, r2
   2a2d8:	2200      	movs	r2, #0
   2a2da:	751a      	strb	r2, [r3, #20]
  for (uint8_t i = 0; i < DM_CONN_MAX; i++)
   2a2dc:	79fb      	ldrb	r3, [r7, #7]
   2a2de:	3301      	adds	r3, #1
   2a2e0:	71fb      	strb	r3, [r7, #7]
   2a2e2:	79fb      	ldrb	r3, [r7, #7]
   2a2e4:	2b02      	cmp	r3, #2
   2a2e6:	d9f4      	bls.n	2a2d2 <L2cSlaveInit+0x12>
  }
}
   2a2e8:	bf00      	nop
   2a2ea:	bf00      	nop
   2a2ec:	370c      	adds	r7, #12
   2a2ee:	46bd      	mov	sp, r7
   2a2f0:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a2f4:	4770      	bx	lr
   2a2f6:	bf00      	nop
   2a2f8:	10011708 	.word	0x10011708
   2a2fc:	0002a1b5 	.word	0x0002a1b5
   2a300:	10007fc8 	.word	0x10007fc8

0002a304 <L2cDmConnUpdateReq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cDmConnUpdateReq(uint16_t handle, hciConnSpec_t *pConnSpec)
{
   2a304:	b580      	push	{r7, lr}
   2a306:	b084      	sub	sp, #16
   2a308:	af00      	add	r7, sp, #0
   2a30a:	4603      	mov	r3, r0
   2a30c:	6039      	str	r1, [r7, #0]
   2a30e:	80fb      	strh	r3, [r7, #6]
  uint8_t *pPacket;
  uint8_t *p;

  /* record code */
  l2cSlaveCb.lastCode[handle] = L2C_SIG_CONN_UPDATE_REQ;
   2a310:	88fb      	ldrh	r3, [r7, #6]
   2a312:	4a46      	ldr	r2, [pc, #280]	; (2a42c <L2cDmConnUpdateReq+0x128>)
   2a314:	4413      	add	r3, r2
   2a316:	2212      	movs	r2, #18
   2a318:	745a      	strb	r2, [r3, #17]

  /* Start signaling request timer and store handle */
  WsfTimerStartSec(&l2cSlaveCb.reqTimer, L2C_SIG_REQ_TIMEOUT);
   2a31a:	211e      	movs	r1, #30
   2a31c:	4843      	ldr	r0, [pc, #268]	; (2a42c <L2cDmConnUpdateReq+0x128>)
   2a31e:	f003 fa65 	bl	2d7ec <WsfTimerStartSec>
  l2cSlaveCb.reqTimer.msg.param = handle;
   2a322:	4a42      	ldr	r2, [pc, #264]	; (2a42c <L2cDmConnUpdateReq+0x128>)
   2a324:	88fb      	ldrh	r3, [r7, #6]
   2a326:	8113      	strh	r3, [r2, #8]

  /* allocate msg buffer */
  if ((pPacket = l2cMsgAlloc(L2C_SIG_PKT_BASE_LEN + L2C_SIG_CONN_UPDATE_REQ_LEN)) != NULL)
   2a328:	2014      	movs	r0, #20
   2a32a:	f7ff fd7e 	bl	29e2a <l2cMsgAlloc>
   2a32e:	60f8      	str	r0, [r7, #12]
   2a330:	68fb      	ldr	r3, [r7, #12]
   2a332:	2b00      	cmp	r3, #0
   2a334:	d075      	beq.n	2a422 <L2cDmConnUpdateReq+0x11e>
  {
    /* build message */
    p = pPacket + L2C_PAYLOAD_START;
   2a336:	68fb      	ldr	r3, [r7, #12]
   2a338:	3308      	adds	r3, #8
   2a33a:	60bb      	str	r3, [r7, #8]
    UINT8_TO_BSTREAM(p, L2C_SIG_CONN_UPDATE_REQ);       /* command code */
   2a33c:	68bb      	ldr	r3, [r7, #8]
   2a33e:	1c5a      	adds	r2, r3, #1
   2a340:	60ba      	str	r2, [r7, #8]
   2a342:	2212      	movs	r2, #18
   2a344:	701a      	strb	r2, [r3, #0]
    UINT8_TO_BSTREAM(p, l2cCb.identifier);              /* identifier */
   2a346:	68bb      	ldr	r3, [r7, #8]
   2a348:	1c5a      	adds	r2, r3, #1
   2a34a:	60ba      	str	r2, [r7, #8]
   2a34c:	4a38      	ldr	r2, [pc, #224]	; (2a430 <L2cDmConnUpdateReq+0x12c>)
   2a34e:	f892 2024 	ldrb.w	r2, [r2, #36]	; 0x24
   2a352:	701a      	strb	r2, [r3, #0]
    l2cSlaveCb.signId[handle] = l2cCb.identifier;
   2a354:	88fb      	ldrh	r3, [r7, #6]
   2a356:	4a36      	ldr	r2, [pc, #216]	; (2a430 <L2cDmConnUpdateReq+0x12c>)
   2a358:	f892 1024 	ldrb.w	r1, [r2, #36]	; 0x24
   2a35c:	4a33      	ldr	r2, [pc, #204]	; (2a42c <L2cDmConnUpdateReq+0x128>)
   2a35e:	4413      	add	r3, r2
   2a360:	460a      	mov	r2, r1
   2a362:	751a      	strb	r2, [r3, #20]
    l2cCb.identifier = L2C_NEXT_ID(l2cCb.identifier);
   2a364:	4b32      	ldr	r3, [pc, #200]	; (2a430 <L2cDmConnUpdateReq+0x12c>)
   2a366:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   2a36a:	2bff      	cmp	r3, #255	; 0xff
   2a36c:	d005      	beq.n	2a37a <L2cDmConnUpdateReq+0x76>
   2a36e:	4b30      	ldr	r3, [pc, #192]	; (2a430 <L2cDmConnUpdateReq+0x12c>)
   2a370:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   2a374:	3301      	adds	r3, #1
   2a376:	b2db      	uxtb	r3, r3
   2a378:	e000      	b.n	2a37c <L2cDmConnUpdateReq+0x78>
   2a37a:	2301      	movs	r3, #1
   2a37c:	4a2c      	ldr	r2, [pc, #176]	; (2a430 <L2cDmConnUpdateReq+0x12c>)
   2a37e:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    UINT16_TO_BSTREAM(p, L2C_SIG_CONN_UPDATE_REQ_LEN);  /* parameter length */
   2a382:	68bb      	ldr	r3, [r7, #8]
   2a384:	1c5a      	adds	r2, r3, #1
   2a386:	60ba      	str	r2, [r7, #8]
   2a388:	2208      	movs	r2, #8
   2a38a:	701a      	strb	r2, [r3, #0]
   2a38c:	68bb      	ldr	r3, [r7, #8]
   2a38e:	1c5a      	adds	r2, r3, #1
   2a390:	60ba      	str	r2, [r7, #8]
   2a392:	2200      	movs	r2, #0
   2a394:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMin);   /* interval min */
   2a396:	683b      	ldr	r3, [r7, #0]
   2a398:	8819      	ldrh	r1, [r3, #0]
   2a39a:	68bb      	ldr	r3, [r7, #8]
   2a39c:	1c5a      	adds	r2, r3, #1
   2a39e:	60ba      	str	r2, [r7, #8]
   2a3a0:	b2ca      	uxtb	r2, r1
   2a3a2:	701a      	strb	r2, [r3, #0]
   2a3a4:	683b      	ldr	r3, [r7, #0]
   2a3a6:	881b      	ldrh	r3, [r3, #0]
   2a3a8:	0a1b      	lsrs	r3, r3, #8
   2a3aa:	b299      	uxth	r1, r3
   2a3ac:	68bb      	ldr	r3, [r7, #8]
   2a3ae:	1c5a      	adds	r2, r3, #1
   2a3b0:	60ba      	str	r2, [r7, #8]
   2a3b2:	b2ca      	uxtb	r2, r1
   2a3b4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connIntervalMax);   /* interval max */
   2a3b6:	683b      	ldr	r3, [r7, #0]
   2a3b8:	8859      	ldrh	r1, [r3, #2]
   2a3ba:	68bb      	ldr	r3, [r7, #8]
   2a3bc:	1c5a      	adds	r2, r3, #1
   2a3be:	60ba      	str	r2, [r7, #8]
   2a3c0:	b2ca      	uxtb	r2, r1
   2a3c2:	701a      	strb	r2, [r3, #0]
   2a3c4:	683b      	ldr	r3, [r7, #0]
   2a3c6:	885b      	ldrh	r3, [r3, #2]
   2a3c8:	0a1b      	lsrs	r3, r3, #8
   2a3ca:	b299      	uxth	r1, r3
   2a3cc:	68bb      	ldr	r3, [r7, #8]
   2a3ce:	1c5a      	adds	r2, r3, #1
   2a3d0:	60ba      	str	r2, [r7, #8]
   2a3d2:	b2ca      	uxtb	r2, r1
   2a3d4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->connLatency);       /* slave latency */
   2a3d6:	683b      	ldr	r3, [r7, #0]
   2a3d8:	8899      	ldrh	r1, [r3, #4]
   2a3da:	68bb      	ldr	r3, [r7, #8]
   2a3dc:	1c5a      	adds	r2, r3, #1
   2a3de:	60ba      	str	r2, [r7, #8]
   2a3e0:	b2ca      	uxtb	r2, r1
   2a3e2:	701a      	strb	r2, [r3, #0]
   2a3e4:	683b      	ldr	r3, [r7, #0]
   2a3e6:	889b      	ldrh	r3, [r3, #4]
   2a3e8:	0a1b      	lsrs	r3, r3, #8
   2a3ea:	b299      	uxth	r1, r3
   2a3ec:	68bb      	ldr	r3, [r7, #8]
   2a3ee:	1c5a      	adds	r2, r3, #1
   2a3f0:	60ba      	str	r2, [r7, #8]
   2a3f2:	b2ca      	uxtb	r2, r1
   2a3f4:	701a      	strb	r2, [r3, #0]
    UINT16_TO_BSTREAM(p, pConnSpec->supTimeout);        /* timeout multiplier */
   2a3f6:	683b      	ldr	r3, [r7, #0]
   2a3f8:	88d9      	ldrh	r1, [r3, #6]
   2a3fa:	68bb      	ldr	r3, [r7, #8]
   2a3fc:	1c5a      	adds	r2, r3, #1
   2a3fe:	60ba      	str	r2, [r7, #8]
   2a400:	b2ca      	uxtb	r2, r1
   2a402:	701a      	strb	r2, [r3, #0]
   2a404:	683b      	ldr	r3, [r7, #0]
   2a406:	88db      	ldrh	r3, [r3, #6]
   2a408:	0a1b      	lsrs	r3, r3, #8
   2a40a:	b299      	uxth	r1, r3
   2a40c:	68bb      	ldr	r3, [r7, #8]
   2a40e:	1c5a      	adds	r2, r3, #1
   2a410:	60ba      	str	r2, [r7, #8]
   2a412:	b2ca      	uxtb	r2, r1
   2a414:	701a      	strb	r2, [r3, #0]

    /* send packet */
    L2cDataReq(L2C_CID_LE_SIGNALING, handle, (L2C_SIG_HDR_LEN + L2C_SIG_CONN_UPDATE_REQ_LEN), pPacket);
   2a416:	88f9      	ldrh	r1, [r7, #6]
   2a418:	68fb      	ldr	r3, [r7, #12]
   2a41a:	220c      	movs	r2, #12
   2a41c:	2005      	movs	r0, #5
   2a41e:	f7ff fd63 	bl	29ee8 <L2cDataReq>
  }
}
   2a422:	bf00      	nop
   2a424:	3710      	adds	r7, #16
   2a426:	46bd      	mov	sp, r7
   2a428:	bd80      	pop	{r7, pc}
   2a42a:	bf00      	nop
   2a42c:	10007fc8 	.word	0x10007fc8
   2a430:	10011708 	.word	0x10011708

0002a434 <L2cSlaveHandlerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cSlaveHandlerInit(wsfHandlerId_t handlerId)
{
   2a434:	b480      	push	{r7}
   2a436:	b083      	sub	sp, #12
   2a438:	af00      	add	r7, sp, #0
   2a43a:	4603      	mov	r3, r0
   2a43c:	71fb      	strb	r3, [r7, #7]
  l2cSlaveCb.reqTimer.msg.event = L2C_MSG_REQ_TIMEOUT;
   2a43e:	4b07      	ldr	r3, [pc, #28]	; (2a45c <L2cSlaveHandlerInit+0x28>)
   2a440:	2201      	movs	r2, #1
   2a442:	729a      	strb	r2, [r3, #10]
  l2cSlaveCb.reqTimer.handlerId = handlerId;
   2a444:	4a05      	ldr	r2, [pc, #20]	; (2a45c <L2cSlaveHandlerInit+0x28>)
   2a446:	79fb      	ldrb	r3, [r7, #7]
   2a448:	7313      	strb	r3, [r2, #12]
  l2cSlaveCb.handlerId = handlerId;
   2a44a:	4a04      	ldr	r2, [pc, #16]	; (2a45c <L2cSlaveHandlerInit+0x28>)
   2a44c:	79fb      	ldrb	r3, [r7, #7]
   2a44e:	7413      	strb	r3, [r2, #16]
}
   2a450:	bf00      	nop
   2a452:	370c      	adds	r7, #12
   2a454:	46bd      	mov	sp, r7
   2a456:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a45a:	4770      	bx	lr
   2a45c:	10007fc8 	.word	0x10007fc8

0002a460 <L2cSlaveHandler>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void L2cSlaveHandler(wsfEventMask_t event, wsfMsgHdr_t *pMsg)
{
   2a460:	b580      	push	{r7, lr}
   2a462:	b082      	sub	sp, #8
   2a464:	af00      	add	r7, sp, #0
   2a466:	4603      	mov	r3, r0
   2a468:	6039      	str	r1, [r7, #0]
   2a46a:	71fb      	strb	r3, [r7, #7]
  /* Handle message */
  if (pMsg != NULL)
   2a46c:	683b      	ldr	r3, [r7, #0]
   2a46e:	2b00      	cmp	r3, #0
   2a470:	d006      	beq.n	2a480 <L2cSlaveHandler+0x20>
  {
    WSF_ASSERT(pMsg->event > 0 && pMsg->event <= L2C_MSG_TYPE_MAX);

    /* handle slave signaling request timeout */
    if (pMsg->event == L2C_MSG_REQ_TIMEOUT)
   2a472:	683b      	ldr	r3, [r7, #0]
   2a474:	789b      	ldrb	r3, [r3, #2]
   2a476:	2b01      	cmp	r3, #1
   2a478:	d102      	bne.n	2a480 <L2cSlaveHandler+0x20>
    {
      l2cSlaveReqTimeout(pMsg);
   2a47a:	6838      	ldr	r0, [r7, #0]
   2a47c:	f7ff fe86 	bl	2a18c <l2cSlaveReqTimeout>
  /* Handle events */
  else if (event)
  {

  }
}
   2a480:	bf00      	nop
   2a482:	3708      	adds	r7, #8
   2a484:	46bd      	mov	sp, r7
   2a486:	bd80      	pop	{r7, pc}

0002a488 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
   2a488:	b480      	push	{r7}
   2a48a:	b083      	sub	sp, #12
   2a48c:	af00      	add	r7, sp, #0
   2a48e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2a490:	687b      	ldr	r3, [r7, #4]
   2a492:	f103 0208 	add.w	r2, r3, #8
   2a496:	687b      	ldr	r3, [r7, #4]
   2a498:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   2a49a:	687b      	ldr	r3, [r7, #4]
   2a49c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2a4a0:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2a4a2:	687b      	ldr	r3, [r7, #4]
   2a4a4:	f103 0208 	add.w	r2, r3, #8
   2a4a8:	687b      	ldr	r3, [r7, #4]
   2a4aa:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   2a4ac:	687b      	ldr	r3, [r7, #4]
   2a4ae:	f103 0208 	add.w	r2, r3, #8
   2a4b2:	687b      	ldr	r3, [r7, #4]
   2a4b4:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   2a4b6:	687b      	ldr	r3, [r7, #4]
   2a4b8:	2200      	movs	r2, #0
   2a4ba:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
   2a4bc:	bf00      	nop
   2a4be:	370c      	adds	r7, #12
   2a4c0:	46bd      	mov	sp, r7
   2a4c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a4c6:	4770      	bx	lr

0002a4c8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   2a4c8:	b480      	push	{r7}
   2a4ca:	b083      	sub	sp, #12
   2a4cc:	af00      	add	r7, sp, #0
   2a4ce:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
   2a4d0:	687b      	ldr	r3, [r7, #4]
   2a4d2:	2200      	movs	r2, #0
   2a4d4:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
   2a4d6:	bf00      	nop
   2a4d8:	370c      	adds	r7, #12
   2a4da:	46bd      	mov	sp, r7
   2a4dc:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a4e0:	4770      	bx	lr

0002a4e2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   2a4e2:	b480      	push	{r7}
   2a4e4:	b085      	sub	sp, #20
   2a4e6:	af00      	add	r7, sp, #0
   2a4e8:	6078      	str	r0, [r7, #4]
   2a4ea:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   2a4ec:	687b      	ldr	r3, [r7, #4]
   2a4ee:	685b      	ldr	r3, [r3, #4]
   2a4f0:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   2a4f2:	683b      	ldr	r3, [r7, #0]
   2a4f4:	68fa      	ldr	r2, [r7, #12]
   2a4f6:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   2a4f8:	68fb      	ldr	r3, [r7, #12]
   2a4fa:	689a      	ldr	r2, [r3, #8]
   2a4fc:	683b      	ldr	r3, [r7, #0]
   2a4fe:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   2a500:	68fb      	ldr	r3, [r7, #12]
   2a502:	689b      	ldr	r3, [r3, #8]
   2a504:	683a      	ldr	r2, [r7, #0]
   2a506:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   2a508:	68fb      	ldr	r3, [r7, #12]
   2a50a:	683a      	ldr	r2, [r7, #0]
   2a50c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
   2a50e:	683b      	ldr	r3, [r7, #0]
   2a510:	687a      	ldr	r2, [r7, #4]
   2a512:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   2a514:	687b      	ldr	r3, [r7, #4]
   2a516:	681b      	ldr	r3, [r3, #0]
   2a518:	1c5a      	adds	r2, r3, #1
   2a51a:	687b      	ldr	r3, [r7, #4]
   2a51c:	601a      	str	r2, [r3, #0]
}
   2a51e:	bf00      	nop
   2a520:	3714      	adds	r7, #20
   2a522:	46bd      	mov	sp, r7
   2a524:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a528:	4770      	bx	lr

0002a52a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   2a52a:	b480      	push	{r7}
   2a52c:	b085      	sub	sp, #20
   2a52e:	af00      	add	r7, sp, #0
   2a530:	6078      	str	r0, [r7, #4]
   2a532:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   2a534:	683b      	ldr	r3, [r7, #0]
   2a536:	681b      	ldr	r3, [r3, #0]
   2a538:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   2a53a:	68bb      	ldr	r3, [r7, #8]
   2a53c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2a540:	d103      	bne.n	2a54a <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   2a542:	687b      	ldr	r3, [r7, #4]
   2a544:	691b      	ldr	r3, [r3, #16]
   2a546:	60fb      	str	r3, [r7, #12]
   2a548:	e00c      	b.n	2a564 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
   2a54a:	687b      	ldr	r3, [r7, #4]
   2a54c:	3308      	adds	r3, #8
   2a54e:	60fb      	str	r3, [r7, #12]
   2a550:	e002      	b.n	2a558 <vListInsert+0x2e>
   2a552:	68fb      	ldr	r3, [r7, #12]
   2a554:	685b      	ldr	r3, [r3, #4]
   2a556:	60fb      	str	r3, [r7, #12]
   2a558:	68fb      	ldr	r3, [r7, #12]
   2a55a:	685b      	ldr	r3, [r3, #4]
   2a55c:	681b      	ldr	r3, [r3, #0]
   2a55e:	68ba      	ldr	r2, [r7, #8]
   2a560:	429a      	cmp	r2, r3
   2a562:	d2f6      	bcs.n	2a552 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   2a564:	68fb      	ldr	r3, [r7, #12]
   2a566:	685a      	ldr	r2, [r3, #4]
   2a568:	683b      	ldr	r3, [r7, #0]
   2a56a:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   2a56c:	683b      	ldr	r3, [r7, #0]
   2a56e:	685b      	ldr	r3, [r3, #4]
   2a570:	683a      	ldr	r2, [r7, #0]
   2a572:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   2a574:	683b      	ldr	r3, [r7, #0]
   2a576:	68fa      	ldr	r2, [r7, #12]
   2a578:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   2a57a:	68fb      	ldr	r3, [r7, #12]
   2a57c:	683a      	ldr	r2, [r7, #0]
   2a57e:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
   2a580:	683b      	ldr	r3, [r7, #0]
   2a582:	687a      	ldr	r2, [r7, #4]
   2a584:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   2a586:	687b      	ldr	r3, [r7, #4]
   2a588:	681b      	ldr	r3, [r3, #0]
   2a58a:	1c5a      	adds	r2, r3, #1
   2a58c:	687b      	ldr	r3, [r7, #4]
   2a58e:	601a      	str	r2, [r3, #0]
}
   2a590:	bf00      	nop
   2a592:	3714      	adds	r7, #20
   2a594:	46bd      	mov	sp, r7
   2a596:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a59a:	4770      	bx	lr

0002a59c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   2a59c:	b480      	push	{r7}
   2a59e:	b085      	sub	sp, #20
   2a5a0:	af00      	add	r7, sp, #0
   2a5a2:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
   2a5a4:	687b      	ldr	r3, [r7, #4]
   2a5a6:	691b      	ldr	r3, [r3, #16]
   2a5a8:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   2a5aa:	687b      	ldr	r3, [r7, #4]
   2a5ac:	685b      	ldr	r3, [r3, #4]
   2a5ae:	687a      	ldr	r2, [r7, #4]
   2a5b0:	6892      	ldr	r2, [r2, #8]
   2a5b2:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   2a5b4:	687b      	ldr	r3, [r7, #4]
   2a5b6:	689b      	ldr	r3, [r3, #8]
   2a5b8:	687a      	ldr	r2, [r7, #4]
   2a5ba:	6852      	ldr	r2, [r2, #4]
   2a5bc:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   2a5be:	68fb      	ldr	r3, [r7, #12]
   2a5c0:	685b      	ldr	r3, [r3, #4]
   2a5c2:	687a      	ldr	r2, [r7, #4]
   2a5c4:	429a      	cmp	r2, r3
   2a5c6:	d103      	bne.n	2a5d0 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   2a5c8:	687b      	ldr	r3, [r7, #4]
   2a5ca:	689a      	ldr	r2, [r3, #8]
   2a5cc:	68fb      	ldr	r3, [r7, #12]
   2a5ce:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
   2a5d0:	687b      	ldr	r3, [r7, #4]
   2a5d2:	2200      	movs	r2, #0
   2a5d4:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   2a5d6:	68fb      	ldr	r3, [r7, #12]
   2a5d8:	681b      	ldr	r3, [r3, #0]
   2a5da:	1e5a      	subs	r2, r3, #1
   2a5dc:	68fb      	ldr	r3, [r7, #12]
   2a5de:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   2a5e0:	68fb      	ldr	r3, [r7, #12]
   2a5e2:	681b      	ldr	r3, [r3, #0]
}
   2a5e4:	4618      	mov	r0, r3
   2a5e6:	3714      	adds	r7, #20
   2a5e8:	46bd      	mov	sp, r7
   2a5ea:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a5ee:	4770      	bx	lr

0002a5f0 <__NVIC_EnableIRQ>:
{
   2a5f0:	b480      	push	{r7}
   2a5f2:	b083      	sub	sp, #12
   2a5f4:	af00      	add	r7, sp, #0
   2a5f6:	4603      	mov	r3, r0
   2a5f8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2a5fa:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2a5fe:	2b00      	cmp	r3, #0
   2a600:	db0b      	blt.n	2a61a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2a602:	79fb      	ldrb	r3, [r7, #7]
   2a604:	f003 021f 	and.w	r2, r3, #31
   2a608:	4907      	ldr	r1, [pc, #28]	; (2a628 <__NVIC_EnableIRQ+0x38>)
   2a60a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2a60e:	095b      	lsrs	r3, r3, #5
   2a610:	2001      	movs	r0, #1
   2a612:	fa00 f202 	lsl.w	r2, r0, r2
   2a616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   2a61a:	bf00      	nop
   2a61c:	370c      	adds	r7, #12
   2a61e:	46bd      	mov	sp, r7
   2a620:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a624:	4770      	bx	lr
   2a626:	bf00      	nop
   2a628:	e000e100 	.word	0xe000e100

0002a62c <__NVIC_SetPriority>:
{
   2a62c:	b480      	push	{r7}
   2a62e:	b083      	sub	sp, #12
   2a630:	af00      	add	r7, sp, #0
   2a632:	4603      	mov	r3, r0
   2a634:	6039      	str	r1, [r7, #0]
   2a636:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2a638:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2a63c:	2b00      	cmp	r3, #0
   2a63e:	db0a      	blt.n	2a656 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2a640:	683b      	ldr	r3, [r7, #0]
   2a642:	b2da      	uxtb	r2, r3
   2a644:	490c      	ldr	r1, [pc, #48]	; (2a678 <__NVIC_SetPriority+0x4c>)
   2a646:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2a64a:	0152      	lsls	r2, r2, #5
   2a64c:	b2d2      	uxtb	r2, r2
   2a64e:	440b      	add	r3, r1
   2a650:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   2a654:	e00a      	b.n	2a66c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2a656:	683b      	ldr	r3, [r7, #0]
   2a658:	b2da      	uxtb	r2, r3
   2a65a:	4908      	ldr	r1, [pc, #32]	; (2a67c <__NVIC_SetPriority+0x50>)
   2a65c:	79fb      	ldrb	r3, [r7, #7]
   2a65e:	f003 030f 	and.w	r3, r3, #15
   2a662:	3b04      	subs	r3, #4
   2a664:	0152      	lsls	r2, r2, #5
   2a666:	b2d2      	uxtb	r2, r2
   2a668:	440b      	add	r3, r1
   2a66a:	761a      	strb	r2, [r3, #24]
}
   2a66c:	bf00      	nop
   2a66e:	370c      	adds	r7, #12
   2a670:	46bd      	mov	sp, r7
   2a672:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a676:	4770      	bx	lr
   2a678:	e000e100 	.word	0xe000e100
   2a67c:	e000ed00 	.word	0xe000ed00

0002a680 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   2a680:	b480      	push	{r7}
   2a682:	b085      	sub	sp, #20
   2a684:	af00      	add	r7, sp, #0
   2a686:	60f8      	str	r0, [r7, #12]
   2a688:	60b9      	str	r1, [r7, #8]
   2a68a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
   2a68c:	68fb      	ldr	r3, [r7, #12]
   2a68e:	3b04      	subs	r3, #4
   2a690:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   2a692:	68fb      	ldr	r3, [r7, #12]
   2a694:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   2a698:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   2a69a:	68fb      	ldr	r3, [r7, #12]
   2a69c:	3b04      	subs	r3, #4
   2a69e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   2a6a0:	68bb      	ldr	r3, [r7, #8]
   2a6a2:	f023 0201 	bic.w	r2, r3, #1
   2a6a6:	68fb      	ldr	r3, [r7, #12]
   2a6a8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   2a6aa:	68fb      	ldr	r3, [r7, #12]
   2a6ac:	3b04      	subs	r3, #4
   2a6ae:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   2a6b0:	4a0c      	ldr	r2, [pc, #48]	; (2a6e4 <pxPortInitialiseStack+0x64>)
   2a6b2:	68fb      	ldr	r3, [r7, #12]
   2a6b4:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   2a6b6:	68fb      	ldr	r3, [r7, #12]
   2a6b8:	3b14      	subs	r3, #20
   2a6ba:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   2a6bc:	687a      	ldr	r2, [r7, #4]
   2a6be:	68fb      	ldr	r3, [r7, #12]
   2a6c0:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
   2a6c2:	68fb      	ldr	r3, [r7, #12]
   2a6c4:	3b04      	subs	r3, #4
   2a6c6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
   2a6c8:	68fb      	ldr	r3, [r7, #12]
   2a6ca:	f06f 0202 	mvn.w	r2, #2
   2a6ce:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   2a6d0:	68fb      	ldr	r3, [r7, #12]
   2a6d2:	3b20      	subs	r3, #32
   2a6d4:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   2a6d6:	68fb      	ldr	r3, [r7, #12]
}
   2a6d8:	4618      	mov	r0, r3
   2a6da:	3714      	adds	r7, #20
   2a6dc:	46bd      	mov	sp, r7
   2a6de:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a6e2:	4770      	bx	lr
   2a6e4:	0002a6e9 	.word	0x0002a6e9

0002a6e8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   2a6e8:	b480      	push	{r7}
   2a6ea:	b083      	sub	sp, #12
   2a6ec:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
   2a6ee:	2300      	movs	r3, #0
   2a6f0:	603b      	str	r3, [r7, #0]

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   2a6f2:	f04f 0360 	mov.w	r3, #96	; 0x60
   2a6f6:	f383 8811 	msr	BASEPRI, r3
   2a6fa:	f3bf 8f6f 	isb	sy
   2a6fe:	f3bf 8f4f 	dsb	sy
   2a702:	607b      	str	r3, [r7, #4]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
   2a704:	bf00      	nop

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
   2a706:	bf00      	nop
   2a708:	683b      	ldr	r3, [r7, #0]
   2a70a:	2b00      	cmp	r3, #0
   2a70c:	d0fc      	beq.n	2a708 <prvTaskExitError+0x20>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
   2a70e:	bf00      	nop
   2a710:	bf00      	nop
   2a712:	370c      	adds	r7, #12
   2a714:	46bd      	mov	sp, r7
   2a716:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a71a:	4770      	bx	lr
   2a71c:	0000      	movs	r0, r0
	...

0002a720 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   2a720:	4b07      	ldr	r3, [pc, #28]	; (2a740 <pxCurrentTCBConst2>)
   2a722:	6819      	ldr	r1, [r3, #0]
   2a724:	6808      	ldr	r0, [r1, #0]
   2a726:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a72a:	f380 8809 	msr	PSP, r0
   2a72e:	f3bf 8f6f 	isb	sy
   2a732:	f04f 0000 	mov.w	r0, #0
   2a736:	f380 8811 	msr	BASEPRI, r0
   2a73a:	4770      	bx	lr
   2a73c:	f3af 8000 	nop.w

0002a740 <pxCurrentTCBConst2>:
   2a740:	10007ff0 	.word	0x10007ff0
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
   2a744:	bf00      	nop
   2a746:	bf00      	nop

0002a748 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
   2a748:	4808      	ldr	r0, [pc, #32]	; (2a76c <prvPortStartFirstTask+0x24>)
   2a74a:	6800      	ldr	r0, [r0, #0]
   2a74c:	6800      	ldr	r0, [r0, #0]
   2a74e:	f380 8808 	msr	MSP, r0
   2a752:	f04f 0000 	mov.w	r0, #0
   2a756:	f380 8814 	msr	CONTROL, r0
   2a75a:	b662      	cpsie	i
   2a75c:	b661      	cpsie	f
   2a75e:	f3bf 8f4f 	dsb	sy
   2a762:	f3bf 8f6f 	isb	sy
   2a766:	df00      	svc	0
   2a768:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
   2a76a:	bf00      	nop
   2a76c:	e000ed08 	.word	0xe000ed08

0002a770 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   2a770:	b580      	push	{r7, lr}
   2a772:	af00      	add	r7, sp, #0
		*pucFirstUserPriorityRegister = ulOriginalPriority;
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   2a774:	4b10      	ldr	r3, [pc, #64]	; (2a7b8 <xPortStartScheduler+0x48>)
   2a776:	681b      	ldr	r3, [r3, #0]
   2a778:	4a0f      	ldr	r2, [pc, #60]	; (2a7b8 <xPortStartScheduler+0x48>)
   2a77a:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
   2a77e:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   2a780:	4b0d      	ldr	r3, [pc, #52]	; (2a7b8 <xPortStartScheduler+0x48>)
   2a782:	681b      	ldr	r3, [r3, #0]
   2a784:	4a0c      	ldr	r2, [pc, #48]	; (2a7b8 <xPortStartScheduler+0x48>)
   2a786:	f043 4360 	orr.w	r3, r3, #3758096384	; 0xe0000000
   2a78a:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   2a78c:	f000 f9d2 	bl	2ab34 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   2a790:	4b0a      	ldr	r3, [pc, #40]	; (2a7bc <xPortStartScheduler+0x4c>)
   2a792:	2200      	movs	r2, #0
   2a794:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
   2a796:	f000 f8a1 	bl	2a8dc <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
   2a79a:	4b09      	ldr	r3, [pc, #36]	; (2a7c0 <xPortStartScheduler+0x50>)
   2a79c:	681b      	ldr	r3, [r3, #0]
   2a79e:	4a08      	ldr	r2, [pc, #32]	; (2a7c0 <xPortStartScheduler+0x50>)
   2a7a0:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   2a7a4:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   2a7a6:	f7ff ffcf 	bl	2a748 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
   2a7aa:	f001 fc33 	bl	2c014 <vTaskSwitchContext>
	prvTaskExitError();
   2a7ae:	f7ff ff9b 	bl	2a6e8 <prvTaskExitError>

	/* Should not get here! */
	return 0;
   2a7b2:	2300      	movs	r3, #0
}
   2a7b4:	4618      	mov	r0, r3
   2a7b6:	bd80      	pop	{r7, pc}
   2a7b8:	e000ed20 	.word	0xe000ed20
   2a7bc:	10002ce8 	.word	0x10002ce8
   2a7c0:	e000ef34 	.word	0xe000ef34

0002a7c4 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   2a7c4:	b480      	push	{r7}
   2a7c6:	b083      	sub	sp, #12
   2a7c8:	af00      	add	r7, sp, #0
	__asm volatile
   2a7ca:	f04f 0360 	mov.w	r3, #96	; 0x60
   2a7ce:	f383 8811 	msr	BASEPRI, r3
   2a7d2:	f3bf 8f6f 	isb	sy
   2a7d6:	f3bf 8f4f 	dsb	sy
   2a7da:	607b      	str	r3, [r7, #4]
}
   2a7dc:	bf00      	nop
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   2a7de:	4b05      	ldr	r3, [pc, #20]	; (2a7f4 <vPortEnterCritical+0x30>)
   2a7e0:	681b      	ldr	r3, [r3, #0]
   2a7e2:	3301      	adds	r3, #1
   2a7e4:	4a03      	ldr	r2, [pc, #12]	; (2a7f4 <vPortEnterCritical+0x30>)
   2a7e6:	6013      	str	r3, [r2, #0]
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
	}
}
   2a7e8:	bf00      	nop
   2a7ea:	370c      	adds	r7, #12
   2a7ec:	46bd      	mov	sp, r7
   2a7ee:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a7f2:	4770      	bx	lr
   2a7f4:	10002ce8 	.word	0x10002ce8

0002a7f8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   2a7f8:	b480      	push	{r7}
   2a7fa:	b083      	sub	sp, #12
   2a7fc:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
	uxCriticalNesting--;
   2a7fe:	4b0a      	ldr	r3, [pc, #40]	; (2a828 <vPortExitCritical+0x30>)
   2a800:	681b      	ldr	r3, [r3, #0]
   2a802:	3b01      	subs	r3, #1
   2a804:	4a08      	ldr	r2, [pc, #32]	; (2a828 <vPortExitCritical+0x30>)
   2a806:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   2a808:	4b07      	ldr	r3, [pc, #28]	; (2a828 <vPortExitCritical+0x30>)
   2a80a:	681b      	ldr	r3, [r3, #0]
   2a80c:	2b00      	cmp	r3, #0
   2a80e:	d105      	bne.n	2a81c <vPortExitCritical+0x24>
   2a810:	2300      	movs	r3, #0
   2a812:	607b      	str	r3, [r7, #4]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   2a814:	687b      	ldr	r3, [r7, #4]
   2a816:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
   2a81a:	bf00      	nop
	{
		portENABLE_INTERRUPTS();
	}
}
   2a81c:	bf00      	nop
   2a81e:	370c      	adds	r7, #12
   2a820:	46bd      	mov	sp, r7
   2a822:	f85d 7b04 	ldr.w	r7, [sp], #4
   2a826:	4770      	bx	lr
   2a828:	10002ce8 	.word	0x10002ce8
   2a82c:	00000000 	.word	0x00000000

0002a830 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   2a830:	f3ef 8009 	mrs	r0, PSP
   2a834:	f3bf 8f6f 	isb	sy
   2a838:	4b15      	ldr	r3, [pc, #84]	; (2a890 <pxCurrentTCBConst>)
   2a83a:	681a      	ldr	r2, [r3, #0]
   2a83c:	f01e 0f10 	tst.w	lr, #16
   2a840:	bf08      	it	eq
   2a842:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
   2a846:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a84a:	6010      	str	r0, [r2, #0]
   2a84c:	e92d 0009 	stmdb	sp!, {r0, r3}
   2a850:	f04f 0060 	mov.w	r0, #96	; 0x60
   2a854:	f380 8811 	msr	BASEPRI, r0
   2a858:	f3bf 8f4f 	dsb	sy
   2a85c:	f3bf 8f6f 	isb	sy
   2a860:	f001 fbd8 	bl	2c014 <vTaskSwitchContext>
   2a864:	f04f 0000 	mov.w	r0, #0
   2a868:	f380 8811 	msr	BASEPRI, r0
   2a86c:	bc09      	pop	{r0, r3}
   2a86e:	6819      	ldr	r1, [r3, #0]
   2a870:	6808      	ldr	r0, [r1, #0]
   2a872:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2a876:	f01e 0f10 	tst.w	lr, #16
   2a87a:	bf08      	it	eq
   2a87c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
   2a880:	f380 8809 	msr	PSP, r0
   2a884:	f3bf 8f6f 	isb	sy
   2a888:	4770      	bx	lr
   2a88a:	bf00      	nop
   2a88c:	f3af 8000 	nop.w

0002a890 <pxCurrentTCBConst>:
   2a890:	10007ff0 	.word	0x10007ff0
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
   2a894:	bf00      	nop
   2a896:	bf00      	nop

0002a898 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   2a898:	b580      	push	{r7, lr}
   2a89a:	b082      	sub	sp, #8
   2a89c:	af00      	add	r7, sp, #0
	__asm volatile
   2a89e:	f04f 0360 	mov.w	r3, #96	; 0x60
   2a8a2:	f383 8811 	msr	BASEPRI, r3
   2a8a6:	f3bf 8f6f 	isb	sy
   2a8aa:	f3bf 8f4f 	dsb	sy
   2a8ae:	607b      	str	r3, [r7, #4]
}
   2a8b0:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   2a8b2:	f001 fb15 	bl	2bee0 <xTaskIncrementTick>
   2a8b6:	4603      	mov	r3, r0
   2a8b8:	2b00      	cmp	r3, #0
   2a8ba:	d003      	beq.n	2a8c4 <SysTick_Handler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   2a8bc:	4b06      	ldr	r3, [pc, #24]	; (2a8d8 <SysTick_Handler+0x40>)
   2a8be:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2a8c2:	601a      	str	r2, [r3, #0]
   2a8c4:	2300      	movs	r3, #0
   2a8c6:	603b      	str	r3, [r7, #0]
	__asm volatile
   2a8c8:	683b      	ldr	r3, [r7, #0]
   2a8ca:	f383 8811 	msr	BASEPRI, r3
}
   2a8ce:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
   2a8d0:	bf00      	nop
   2a8d2:	3708      	adds	r7, #8
   2a8d4:	46bd      	mov	sp, r7
   2a8d6:	bd80      	pop	{r7, pc}
   2a8d8:	e000ed04 	.word	0xe000ed04

0002a8dc <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
   2a8dc:	f8df 000c 	ldr.w	r0, [pc, #12]	; 2a8ec <vPortEnableVFP+0x10>
   2a8e0:	6801      	ldr	r1, [r0, #0]
   2a8e2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2a8e6:	6001      	str	r1, [r0, #0]
   2a8e8:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
   2a8ea:	bf00      	nop
   2a8ec:	e000ed88 	.word	0xe000ed88

0002a8f0 <vPortSuppressTicksAndSleep>:
 * resolution of the Tick timer.
 */
	static uint32_t xMaximumPossibleSuppressedTicks = 0;

void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
{
   2a8f0:	b580      	push	{r7, lr}
   2a8f2:	b088      	sub	sp, #32
   2a8f4:	af00      	add	r7, sp, #0
   2a8f6:	6078      	str	r0, [r7, #4]
    uint32_t New_Timer, Delta_Sleep;
	TickType_t xModifiableIdleTime;
    uint32_t elapsed_time;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if( xExpectedIdleTime > xMaximumPossibleSuppressedTicks )
   2a8f8:	4b3d      	ldr	r3, [pc, #244]	; (2a9f0 <vPortSuppressTicksAndSleep+0x100>)
   2a8fa:	681b      	ldr	r3, [r3, #0]
   2a8fc:	687a      	ldr	r2, [r7, #4]
   2a8fe:	429a      	cmp	r2, r3
   2a900:	d902      	bls.n	2a908 <vPortSuppressTicksAndSleep+0x18>
	{
		xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
   2a902:	4b3b      	ldr	r3, [pc, #236]	; (2a9f0 <vPortSuppressTicksAndSleep+0x100>)
   2a904:	681b      	ldr	r3, [r3, #0]
   2a906:	607b      	str	r3, [r7, #4]


	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue =  ulTimerCountsForOneTick * ( xExpectedIdleTime - 1 );
   2a908:	687b      	ldr	r3, [r7, #4]
   2a90a:	3b01      	subs	r3, #1
   2a90c:	4a39      	ldr	r2, [pc, #228]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a90e:	6812      	ldr	r2, [r2, #0]
   2a910:	fb02 f303 	mul.w	r3, r2, r3
   2a914:	61fb      	str	r3, [r7, #28]

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile( "cpsid i" );
   2a916:	b672      	cpsid	i
	__asm volatile( "dsb" );
   2a918:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   2a91c:	f3bf 8f6f 	isb	sy
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
    // Adjust for the time already elapsed
    uint32_t curTime = am_hal_stimer_counter_get();
   2a920:	f00c f88c 	bl	36a3c <am_hal_stimer_counter_get>
   2a924:	61b8      	str	r0, [r7, #24]
    gF_stimerGetHistory[gF_stimerGetHistoryCount][1] = curTime;
    gF_stimerGetHistory[gF_stimerGetHistoryCount][2] = AM_REGVAL(AM_REG_STIMER_COMPARE(0, 0));
    gF_stimerGetHistory[gF_stimerGetHistoryCount][3] = gF_stimerHistoryCount;
    gF_stimerGetHistoryCount++;
#endif
    elapsed_time = curTime - g_lastSTimerVal;
   2a926:	4b34      	ldr	r3, [pc, #208]	; (2a9f8 <vPortSuppressTicksAndSleep+0x108>)
   2a928:	681b      	ldr	r3, [r3, #0]
   2a92a:	69ba      	ldr	r2, [r7, #24]
   2a92c:	1ad3      	subs	r3, r2, r3
   2a92e:	617b      	str	r3, [r7, #20]


	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
    /* Abandon low power entry if the sleep time is too short */
	if( (eTaskConfirmSleepModeStatus() == eAbortSleep) || ((elapsed_time + ulTimerCountsForOneTick) > ulReloadValue) )
   2a930:	f001 fd40 	bl	2c3b4 <eTaskConfirmSleepModeStatus>
   2a934:	4603      	mov	r3, r0
   2a936:	2b00      	cmp	r3, #0
   2a938:	d006      	beq.n	2a948 <vPortSuppressTicksAndSleep+0x58>
   2a93a:	4b2e      	ldr	r3, [pc, #184]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a93c:	681a      	ldr	r2, [r3, #0]
   2a93e:	697b      	ldr	r3, [r7, #20]
   2a940:	4413      	add	r3, r2
   2a942:	69fa      	ldr	r2, [r7, #28]
   2a944:	429a      	cmp	r2, r3
   2a946:	d201      	bcs.n	2a94c <vPortSuppressTicksAndSleep+0x5c>
#ifndef AM_FREERTOS_USE_STIMER_FOR_TICK
        am_hal_timer_start(configTIMER_NUM);
#endif
		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile( "cpsie i" );
   2a948:	b662      	cpsie	i
   2a94a:	e04d      	b.n	2a9e8 <vPortSuppressTicksAndSleep+0xf8>
	}
	else
	{
        // Adjust for the time already elapsed
        ulReloadValue -= elapsed_time;
   2a94c:	69fa      	ldr	r2, [r7, #28]
   2a94e:	697b      	ldr	r3, [r7, #20]
   2a950:	1ad3      	subs	r3, r2, r3
   2a952:	61fb      	str	r3, [r7, #28]
        // Initialize new timeout value
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
        am_hal_stimer_compare_delta_set(0, ulReloadValue);
   2a954:	69f9      	ldr	r1, [r7, #28]
   2a956:	2000      	movs	r0, #0
   2a958:	f00c f880 	bl	36a5c <am_hal_stimer_compare_delta_set>
#ifdef AM_FREERTOS_STIMER_BACKUP
        am_hal_stimer_compare_delta_set(1, ulReloadValue+1);
   2a95c:	69fb      	ldr	r3, [r7, #28]
   2a95e:	3301      	adds	r3, #1
   2a960:	4619      	mov	r1, r3
   2a962:	2001      	movs	r0, #1
   2a964:	f00c f87a 	bl	36a5c <am_hal_stimer_compare_delta_set>
		/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
		set its parameter to 0 to indicate that its implementation contains
		its own wait for interrupt or wait for event instruction, and so wfi
		should not be executed again.  However, the original expected idle
		time variable must remain unmodified, so a copy is taken. */
		xModifiableIdleTime = xExpectedIdleTime;
   2a968:	687b      	ldr	r3, [r7, #4]
   2a96a:	613b      	str	r3, [r7, #16]

		configPRE_SLEEP_PROCESSING( xModifiableIdleTime );       // Turn OFF all Periphials in this function
   2a96c:	6938      	ldr	r0, [r7, #16]
   2a96e:	f004 fc65 	bl	2f23c <am_freertos_sleep>
   2a972:	6138      	str	r0, [r7, #16]

		if( xModifiableIdleTime > 0 )
   2a974:	693b      	ldr	r3, [r7, #16]
   2a976:	2b00      	cmp	r3, #0
   2a978:	d004      	beq.n	2a984 <vPortSuppressTicksAndSleep+0x94>
		{
			__asm volatile( "dsb" );
   2a97a:	f3bf 8f4f 	dsb	sy
			__asm volatile( "wfi" );
   2a97e:	bf30      	wfi
			__asm volatile( "isb" );
   2a980:	f3bf 8f6f 	isb	sy
		}

		configPOST_SLEEP_PROCESSING( xExpectedIdleTime );       // Turn ON all Periphials in this function
   2a984:	6878      	ldr	r0, [r7, #4]
   2a986:	f004 fc65 	bl	2f254 <am_freertos_wakeup>
        // Before renable interrupts, check how many ticks the processor has been in SLEEP
        // Adjust xTickCount via vTaskStepTick( Delta_Sleep )
        // to keep xTickCount up to date, as if ticks have been running all along

#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK
        New_Timer = am_hal_stimer_counter_get();
   2a98a:	f00c f857 	bl	36a3c <am_hal_stimer_counter_get>
   2a98e:	60f8      	str	r0, [r7, #12]
        Delta_Sleep = (signed long) New_Timer - (signed long) g_lastSTimerVal;
   2a990:	68fb      	ldr	r3, [r7, #12]
   2a992:	4a19      	ldr	r2, [pc, #100]	; (2a9f8 <vPortSuppressTicksAndSleep+0x108>)
   2a994:	6812      	ldr	r2, [r2, #0]
   2a996:	1a9b      	subs	r3, r3, r2
   2a998:	60bb      	str	r3, [r7, #8]
        g_lastSTimerVal = New_Timer - Delta_Sleep%ulTimerCountsForOneTick;
   2a99a:	4b16      	ldr	r3, [pc, #88]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a99c:	681a      	ldr	r2, [r3, #0]
   2a99e:	68bb      	ldr	r3, [r7, #8]
   2a9a0:	fbb3 f1f2 	udiv	r1, r3, r2
   2a9a4:	fb02 f201 	mul.w	r2, r2, r1
   2a9a8:	1a9b      	subs	r3, r3, r2
   2a9aa:	68fa      	ldr	r2, [r7, #12]
   2a9ac:	1ad3      	subs	r3, r2, r3
   2a9ae:	4a12      	ldr	r2, [pc, #72]	; (2a9f8 <vPortSuppressTicksAndSleep+0x108>)
   2a9b0:	6013      	str	r3, [r2, #0]
        {
            Delta_Sleep = New_Timer; // Indicates the time elapsed since we slept
        }
#endif

        Delta_Sleep /= ulTimerCountsForOneTick;
   2a9b2:	4b10      	ldr	r3, [pc, #64]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a9b4:	681b      	ldr	r3, [r3, #0]
   2a9b6:	68ba      	ldr	r2, [r7, #8]
   2a9b8:	fbb2 f3f3 	udiv	r3, r2, r3
   2a9bc:	60bb      	str	r3, [r7, #8]

        // Correct System Tick after Sleep
        vTaskStepTick( Delta_Sleep );
   2a9be:	68b8      	ldr	r0, [r7, #8]
   2a9c0:	f001 fa7c 	bl	2bebc <vTaskStepTick>
		/* Restart System Tick */
#ifdef AM_FREERTOS_USE_STIMER_FOR_TICK

        // Clear the interrupt - to avoid extra tick counting in ISR
#ifdef AM_FREERTOS_STIMER_BACKUP
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA | AM_HAL_STIMER_INT_COMPAREB);
   2a9c4:	2003      	movs	r0, #3
   2a9c6:	f00c f8c3 	bl	36b50 <am_hal_stimer_int_clear>
#else
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
#endif
        am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
   2a9ca:	4b0a      	ldr	r3, [pc, #40]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a9cc:	681b      	ldr	r3, [r3, #0]
   2a9ce:	4619      	mov	r1, r3
   2a9d0:	2000      	movs	r0, #0
   2a9d2:	f00c f843 	bl	36a5c <am_hal_stimer_compare_delta_set>
#ifdef AM_FREERTOS_STIMER_BACKUP
        am_hal_stimer_compare_delta_set(1, ulTimerCountsForOneTick+1);
   2a9d6:	4b07      	ldr	r3, [pc, #28]	; (2a9f4 <vPortSuppressTicksAndSleep+0x104>)
   2a9d8:	681b      	ldr	r3, [r3, #0]
   2a9da:	3301      	adds	r3, #1
   2a9dc:	4619      	mov	r1, r3
   2a9de:	2001      	movs	r0, #1
   2a9e0:	f00c f83c 	bl	36a5c <am_hal_stimer_compare_delta_set>

        am_hal_timer_start(configTIMER_NUM);
#endif
		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile( "cpsie i" );
   2a9e4:	b662      	cpsie	i

	}
}
   2a9e6:	bf00      	nop
   2a9e8:	bf00      	nop
   2a9ea:	3720      	adds	r7, #32
   2a9ec:	46bd      	mov	sp, r7
   2a9ee:	bd80      	pop	{r7, pc}
   2a9f0:	10007fe8 	.word	0x10007fe8
   2a9f4:	10007fe4 	.word	0x10007fe4
   2a9f8:	10007fe0 	.word	0x10007fe0

0002a9fc <xPortStimerTickHandler>:
//
//
//*****************************************************************************
void
xPortStimerTickHandler(uint32_t delta)
{
   2a9fc:	b580      	push	{r7, lr}
   2a9fe:	b08a      	sub	sp, #40	; 0x28
   2aa00:	af00      	add	r7, sp, #0
   2aa02:	6078      	str	r0, [r7, #4]
    uint32_t remainder = 0;
   2aa04:	2300      	movs	r3, #0
   2aa06:	61fb      	str	r3, [r7, #28]
    uint32_t curSTimer;
    uint32_t timerCounts;
    uint32_t numTicksElapsed;
    BaseType_t ctxtSwitchReqd = pdFALSE;
   2aa08:	2300      	movs	r3, #0
   2aa0a:	623b      	str	r3, [r7, #32]

    curSTimer = am_hal_stimer_counter_get();
   2aa0c:	f00c f816 	bl	36a3c <am_hal_stimer_counter_get>
   2aa10:	61b8      	str	r0, [r7, #24]
    //
    // Configure the STIMER->COMPARE_0
    //
    am_hal_stimer_compare_delta_set(0, (ulTimerCountsForOneTick-delta));
   2aa12:	4b2b      	ldr	r3, [pc, #172]	; (2aac0 <xPortStimerTickHandler+0xc4>)
   2aa14:	681a      	ldr	r2, [r3, #0]
   2aa16:	687b      	ldr	r3, [r7, #4]
   2aa18:	1ad3      	subs	r3, r2, r3
   2aa1a:	4619      	mov	r1, r3
   2aa1c:	2000      	movs	r0, #0
   2aa1e:	f00c f81d 	bl	36a5c <am_hal_stimer_compare_delta_set>
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_compare_delta_set(1, (ulTimerCountsForOneTick-delta+1));
   2aa22:	4b27      	ldr	r3, [pc, #156]	; (2aac0 <xPortStimerTickHandler+0xc4>)
   2aa24:	681a      	ldr	r2, [r3, #0]
   2aa26:	687b      	ldr	r3, [r7, #4]
   2aa28:	1ad3      	subs	r3, r2, r3
   2aa2a:	3301      	adds	r3, #1
   2aa2c:	4619      	mov	r1, r3
   2aa2e:	2001      	movs	r0, #1
   2aa30:	f00c f814 	bl	36a5c <am_hal_stimer_compare_delta_set>
#endif

    timerCounts = curSTimer - g_lastSTimerVal;
   2aa34:	4b23      	ldr	r3, [pc, #140]	; (2aac4 <xPortStimerTickHandler+0xc8>)
   2aa36:	681b      	ldr	r3, [r3, #0]
   2aa38:	69ba      	ldr	r2, [r7, #24]
   2aa3a:	1ad3      	subs	r3, r2, r3
   2aa3c:	617b      	str	r3, [r7, #20]
    numTicksElapsed = timerCounts/ulTimerCountsForOneTick;
   2aa3e:	4b20      	ldr	r3, [pc, #128]	; (2aac0 <xPortStimerTickHandler+0xc4>)
   2aa40:	681b      	ldr	r3, [r3, #0]
   2aa42:	697a      	ldr	r2, [r7, #20]
   2aa44:	fbb2 f3f3 	udiv	r3, r2, r3
   2aa48:	627b      	str	r3, [r7, #36]	; 0x24
    remainder = timerCounts % ulTimerCountsForOneTick;
   2aa4a:	4b1d      	ldr	r3, [pc, #116]	; (2aac0 <xPortStimerTickHandler+0xc4>)
   2aa4c:	681a      	ldr	r2, [r3, #0]
   2aa4e:	697b      	ldr	r3, [r7, #20]
   2aa50:	fbb3 f1f2 	udiv	r1, r3, r2
   2aa54:	fb02 f201 	mul.w	r2, r2, r1
   2aa58:	1a9b      	subs	r3, r3, r2
   2aa5a:	61fb      	str	r3, [r7, #28]
    g_lastSTimerVal = curSTimer - remainder;
   2aa5c:	69ba      	ldr	r2, [r7, #24]
   2aa5e:	69fb      	ldr	r3, [r7, #28]
   2aa60:	1ad3      	subs	r3, r2, r3
   2aa62:	4a18      	ldr	r2, [pc, #96]	; (2aac4 <xPortStimerTickHandler+0xc8>)
   2aa64:	6013      	str	r3, [r2, #0]
	__asm volatile
   2aa66:	f3ef 8211 	mrs	r2, BASEPRI
   2aa6a:	f04f 0360 	mov.w	r3, #96	; 0x60
   2aa6e:	f383 8811 	msr	BASEPRI, r3
   2aa72:	f3bf 8f6f 	isb	sy
   2aa76:	f3bf 8f4f 	dsb	sy
   2aa7a:	613a      	str	r2, [r7, #16]
   2aa7c:	60fb      	str	r3, [r7, #12]
        //
        // Increment RTOS tick
        // Allowing for need to increment the tick more than one... to avoid accumulation of
        // error in case of interrupt latencies
        //
        while (numTicksElapsed--)
   2aa7e:	e008      	b.n	2aa92 <xPortStimerTickHandler+0x96>
        {
            ctxtSwitchReqd = (( xTaskIncrementTick() != pdFALSE ) ? pdTRUE : ctxtSwitchReqd);
   2aa80:	f001 fa2e 	bl	2bee0 <xTaskIncrementTick>
   2aa84:	4603      	mov	r3, r0
   2aa86:	2b00      	cmp	r3, #0
   2aa88:	d101      	bne.n	2aa8e <xPortStimerTickHandler+0x92>
   2aa8a:	6a3b      	ldr	r3, [r7, #32]
   2aa8c:	e000      	b.n	2aa90 <xPortStimerTickHandler+0x94>
   2aa8e:	2301      	movs	r3, #1
   2aa90:	623b      	str	r3, [r7, #32]
        while (numTicksElapsed--)
   2aa92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2aa94:	1e5a      	subs	r2, r3, #1
   2aa96:	627a      	str	r2, [r7, #36]	; 0x24
   2aa98:	2b00      	cmp	r3, #0
   2aa9a:	d1f1      	bne.n	2aa80 <xPortStimerTickHandler+0x84>
        }
        if ( ctxtSwitchReqd != pdFALSE )
   2aa9c:	6a3b      	ldr	r3, [r7, #32]
   2aa9e:	2b00      	cmp	r3, #0
   2aaa0:	d003      	beq.n	2aaaa <xPortStimerTickHandler+0xae>
            //
            // A context switch is required.  Context switching is
            // performed in the PendSV interrupt. Pend the PendSV
            // interrupt.
            //
            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   2aaa2:	4b09      	ldr	r3, [pc, #36]	; (2aac8 <xPortStimerTickHandler+0xcc>)
   2aaa4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2aaa8:	601a      	str	r2, [r3, #0]
   2aaaa:	2300      	movs	r3, #0
   2aaac:	60bb      	str	r3, [r7, #8]
	__asm volatile
   2aaae:	68bb      	ldr	r3, [r7, #8]
   2aab0:	f383 8811 	msr	BASEPRI, r3
}
   2aab4:	bf00      	nop
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR(0);
}
   2aab6:	bf00      	nop
   2aab8:	3728      	adds	r7, #40	; 0x28
   2aaba:	46bd      	mov	sp, r7
   2aabc:	bd80      	pop	{r7, pc}
   2aabe:	bf00      	nop
   2aac0:	10007fe4 	.word	0x10007fe4
   2aac4:	10007fe0 	.word	0x10007fe0
   2aac8:	e000ed04 	.word	0xe000ed04

0002aacc <am_stimer_cmpr0_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr0_isr(void)
{
   2aacc:	b580      	push	{r7, lr}
   2aace:	b082      	sub	sp, #8
   2aad0:	af00      	add	r7, sp, #0

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
   2aad2:	2000      	movs	r0, #0
   2aad4:	f00c f842 	bl	36b5c <am_hal_stimer_int_status_get>
   2aad8:	6078      	str	r0, [r7, #4]
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREA)
   2aada:	687b      	ldr	r3, [r7, #4]
   2aadc:	f003 0301 	and.w	r3, r3, #1
   2aae0:	2b00      	cmp	r3, #0
   2aae2:	d005      	beq.n	2aaf0 <am_stimer_cmpr0_isr+0x24>
    {
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREA);
   2aae4:	2001      	movs	r0, #1
   2aae6:	f00c f833 	bl	36b50 <am_hal_stimer_int_clear>

        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler(0);
   2aaea:	2000      	movs	r0, #0
   2aaec:	f7ff ff86 	bl	2a9fc <xPortStimerTickHandler>
    }
}
   2aaf0:	bf00      	nop
   2aaf2:	3708      	adds	r7, #8
   2aaf4:	46bd      	mov	sp, r7
   2aaf6:	bd80      	pop	{r7, pc}

0002aaf8 <am_stimer_cmpr1_isr>:
// Interrupt handler for the STIMER module Compare 0.
//
//*****************************************************************************
void
am_stimer_cmpr1_isr(void)
{
   2aaf8:	b580      	push	{r7, lr}
   2aafa:	b082      	sub	sp, #8
   2aafc:	af00      	add	r7, sp, #0

    //
    // Check the timer interrupt status.
    //
    uint32_t ui32Status = am_hal_stimer_int_status_get(false);
   2aafe:	2000      	movs	r0, #0
   2ab00:	f00c f82c 	bl	36b5c <am_hal_stimer_int_status_get>
   2ab04:	6078      	str	r0, [r7, #4]
    if (ui32Status & AM_HAL_STIMER_INT_COMPAREB)
   2ab06:	687b      	ldr	r3, [r7, #4]
   2ab08:	f003 0302 	and.w	r3, r3, #2
   2ab0c:	2b00      	cmp	r3, #0
   2ab0e:	d00a      	beq.n	2ab26 <am_stimer_cmpr1_isr+0x2e>
    {
        am_hal_stimer_int_clear(AM_HAL_STIMER_INT_COMPAREB);
   2ab10:	2002      	movs	r0, #2
   2ab12:	f00c f81d 	bl	36b50 <am_hal_stimer_int_clear>
        gNumCmpB++;
   2ab16:	4b06      	ldr	r3, [pc, #24]	; (2ab30 <am_stimer_cmpr1_isr+0x38>)
   2ab18:	681b      	ldr	r3, [r3, #0]
   2ab1a:	3301      	adds	r3, #1
   2ab1c:	4a04      	ldr	r2, [pc, #16]	; (2ab30 <am_stimer_cmpr1_isr+0x38>)
   2ab1e:	6013      	str	r3, [r2, #0]
        //
        // Run handlers for the various possible timer events.
        //
        xPortStimerTickHandler(1);
   2ab20:	2001      	movs	r0, #1
   2ab22:	f7ff ff6b 	bl	2a9fc <xPortStimerTickHandler>
    }
}
   2ab26:	bf00      	nop
   2ab28:	3708      	adds	r7, #8
   2ab2a:	46bd      	mov	sp, r7
   2ab2c:	bd80      	pop	{r7, pc}
   2ab2e:	bf00      	nop
   2ab30:	10007fec 	.word	0x10007fec

0002ab34 <vPortSetupTimerInterrupt>:

#endif // AM_FREERTOS_USE_STIMER_FOR_TICK


void vPortSetupTimerInterrupt( void )
{
   2ab34:	b580      	push	{r7, lr}
   2ab36:	b082      	sub	sp, #8
   2ab38:	af00      	add	r7, sp, #0
        	ulTimerCountsForOneTick = (375000 /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
		}
		else
#endif
		{
        	ulTimerCountsForOneTick = (configSTIMER_CLOCK_HZ /configTICK_RATE_HZ) ; //( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
   2ab3a:	4b23      	ldr	r3, [pc, #140]	; (2abc8 <vPortSetupTimerInterrupt+0x94>)
   2ab3c:	2220      	movs	r2, #32
   2ab3e:	601a      	str	r2, [r3, #0]
		}
#ifdef AM_FREERTOS_STIMER_BACKUP
        xMaximumPossibleSuppressedTicks = portMAX_32_BIT_NUMBER / ulTimerCountsForOneTick - 1;
   2ab40:	4b21      	ldr	r3, [pc, #132]	; (2abc8 <vPortSetupTimerInterrupt+0x94>)
   2ab42:	681b      	ldr	r3, [r3, #0]
   2ab44:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2ab48:	fbb2 f3f3 	udiv	r3, r2, r3
   2ab4c:	3b01      	subs	r3, #1
   2ab4e:	4a1f      	ldr	r2, [pc, #124]	; (2abcc <vPortSetupTimerInterrupt+0x98>)
   2ab50:	6013      	str	r3, [r2, #0]
    #endif /* configUSE_TICKLESS_IDLE */
    //
    //
    //
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_int_enable(AM_HAL_STIMER_INT_COMPAREA | AM_HAL_STIMER_INT_COMPAREB);
   2ab52:	2003      	movs	r0, #3
   2ab54:	f00b fff2 	bl	36b3c <am_hal_stimer_int_enable>
    //
    // Enable the timer interrupt in the NVIC, making sure to use the
    // appropriate priority level.
    //
#if AM_CMSIS_REGS
    NVIC_SetPriority(STIMER_CMPR0_IRQn, NVIC_configKERNEL_INTERRUPT_PRIORITY);
   2ab58:	2107      	movs	r1, #7
   2ab5a:	2020      	movs	r0, #32
   2ab5c:	f7ff fd66 	bl	2a62c <__NVIC_SetPriority>
    NVIC_EnableIRQ(STIMER_CMPR0_IRQn);
   2ab60:	2020      	movs	r0, #32
   2ab62:	f7ff fd45 	bl	2a5f0 <__NVIC_EnableIRQ>
    am_hal_interrupt_priority_set(AM_HAL_INTERRUPT_STIMER_CMPR0, configKERNEL_INTERRUPT_PRIORITY);
    am_hal_interrupt_enable(AM_HAL_INTERRUPT_STIMER_CMPR0);
#endif // AM_CMSIS_REGS
#ifdef AM_FREERTOS_STIMER_BACKUP
#if AM_CMSIS_REGS
    NVIC_SetPriority(STIMER_CMPR1_IRQn, NVIC_configKERNEL_INTERRUPT_PRIORITY);
   2ab66:	2107      	movs	r1, #7
   2ab68:	2021      	movs	r0, #33	; 0x21
   2ab6a:	f7ff fd5f 	bl	2a62c <__NVIC_SetPriority>
    NVIC_EnableIRQ(STIMER_CMPR1_IRQn);
   2ab6e:	2021      	movs	r0, #33	; 0x21
   2ab70:	f7ff fd3e 	bl	2a5f0 <__NVIC_EnableIRQ>
#endif // AM_CMSIS_REGS
#endif
    //
    // Configure the STIMER
    //
    oldCfg = am_hal_stimer_config(AM_HAL_STIMER_CFG_FREEZE);
   2ab74:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
   2ab78:	f00b ff52 	bl	36a20 <am_hal_stimer_config>
   2ab7c:	6078      	str	r0, [r7, #4]
    g_lastSTimerVal = am_hal_stimer_counter_get();
   2ab7e:	f00b ff5d 	bl	36a3c <am_hal_stimer_counter_get>
   2ab82:	4603      	mov	r3, r0
   2ab84:	4a12      	ldr	r2, [pc, #72]	; (2abd0 <vPortSetupTimerInterrupt+0x9c>)
   2ab86:	6013      	str	r3, [r2, #0]
    am_hal_stimer_compare_delta_set(0, ulTimerCountsForOneTick);
   2ab88:	4b0f      	ldr	r3, [pc, #60]	; (2abc8 <vPortSetupTimerInterrupt+0x94>)
   2ab8a:	681b      	ldr	r3, [r3, #0]
   2ab8c:	4619      	mov	r1, r3
   2ab8e:	2000      	movs	r0, #0
   2ab90:	f00b ff64 	bl	36a5c <am_hal_stimer_compare_delta_set>
		stimer_src = AM_HAL_STIMER_HFRC_375KHZ;
	}
	else
#endif
	{
		stimer_src = configSTIMER_CLOCK;
   2ab94:	2303      	movs	r3, #3
   2ab96:	603b      	str	r3, [r7, #0]
	}
#ifdef AM_FREERTOS_STIMER_BACKUP
    am_hal_stimer_compare_delta_set(1, ulTimerCountsForOneTick+1);
   2ab98:	4b0b      	ldr	r3, [pc, #44]	; (2abc8 <vPortSetupTimerInterrupt+0x94>)
   2ab9a:	681b      	ldr	r3, [r3, #0]
   2ab9c:	3301      	adds	r3, #1
   2ab9e:	4619      	mov	r1, r3
   2aba0:	2001      	movs	r0, #1
   2aba2:	f00b ff5b 	bl	36a5c <am_hal_stimer_compare_delta_set>
#if AM_CMSIS_REGS
    am_hal_stimer_config((oldCfg & ~(AM_HAL_STIMER_CFG_FREEZE | STIMER_STCFG_CLKSEL_Msk)) | stimer_src | AM_HAL_STIMER_CFG_COMPARE_A_ENABLE | AM_HAL_STIMER_CFG_COMPARE_B_ENABLE);
   2aba6:	687b      	ldr	r3, [r7, #4]
   2aba8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   2abac:	f023 030f 	bic.w	r3, r3, #15
   2abb0:	683a      	ldr	r2, [r7, #0]
   2abb2:	4313      	orrs	r3, r2
   2abb4:	f443 7340 	orr.w	r3, r3, #768	; 0x300
   2abb8:	4618      	mov	r0, r3
   2abba:	f00b ff31 	bl	36a20 <am_hal_stimer_config>
    //
    am_hal_timer_start(configTIMER_NUM);


#endif // AM_FREERTOS_USE_STIMER_FOR_TICK
}
   2abbe:	bf00      	nop
   2abc0:	3708      	adds	r7, #8
   2abc2:	46bd      	mov	sp, r7
   2abc4:	bd80      	pop	{r7, pc}
   2abc6:	bf00      	nop
   2abc8:	10007fe4 	.word	0x10007fe4
   2abcc:	10007fe8 	.word	0x10007fe8
   2abd0:	10007fe0 	.word	0x10007fe0

0002abd4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   2abd4:	b580      	push	{r7, lr}
   2abd6:	b084      	sub	sp, #16
   2abd8:	af00      	add	r7, sp, #0
   2abda:	6078      	str	r0, [r7, #4]
   2abdc:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
   2abde:	687b      	ldr	r3, [r7, #4]
   2abe0:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
   2abe2:	f7ff fdef 	bl	2a7c4 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   2abe6:	68fb      	ldr	r3, [r7, #12]
   2abe8:	681a      	ldr	r2, [r3, #0]
   2abea:	68fb      	ldr	r3, [r7, #12]
   2abec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   2abee:	68f9      	ldr	r1, [r7, #12]
   2abf0:	6c09      	ldr	r1, [r1, #64]	; 0x40
   2abf2:	fb01 f303 	mul.w	r3, r1, r3
   2abf6:	441a      	add	r2, r3
   2abf8:	68fb      	ldr	r3, [r7, #12]
   2abfa:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   2abfc:	68fb      	ldr	r3, [r7, #12]
   2abfe:	2200      	movs	r2, #0
   2ac00:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   2ac02:	68fb      	ldr	r3, [r7, #12]
   2ac04:	681a      	ldr	r2, [r3, #0]
   2ac06:	68fb      	ldr	r3, [r7, #12]
   2ac08:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   2ac0a:	68fb      	ldr	r3, [r7, #12]
   2ac0c:	681a      	ldr	r2, [r3, #0]
   2ac0e:	68fb      	ldr	r3, [r7, #12]
   2ac10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   2ac12:	3b01      	subs	r3, #1
   2ac14:	68f9      	ldr	r1, [r7, #12]
   2ac16:	6c09      	ldr	r1, [r1, #64]	; 0x40
   2ac18:	fb01 f303 	mul.w	r3, r1, r3
   2ac1c:	441a      	add	r2, r3
   2ac1e:	68fb      	ldr	r3, [r7, #12]
   2ac20:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   2ac22:	68fb      	ldr	r3, [r7, #12]
   2ac24:	22ff      	movs	r2, #255	; 0xff
   2ac26:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   2ac2a:	68fb      	ldr	r3, [r7, #12]
   2ac2c:	22ff      	movs	r2, #255	; 0xff
   2ac2e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
   2ac32:	683b      	ldr	r3, [r7, #0]
   2ac34:	2b00      	cmp	r3, #0
   2ac36:	d114      	bne.n	2ac62 <xQueueGenericReset+0x8e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2ac38:	68fb      	ldr	r3, [r7, #12]
   2ac3a:	691b      	ldr	r3, [r3, #16]
   2ac3c:	2b00      	cmp	r3, #0
   2ac3e:	d01a      	beq.n	2ac76 <xQueueGenericReset+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2ac40:	68fb      	ldr	r3, [r7, #12]
   2ac42:	3310      	adds	r3, #16
   2ac44:	4618      	mov	r0, r3
   2ac46:	f001 fa87 	bl	2c158 <xTaskRemoveFromEventList>
   2ac4a:	4603      	mov	r3, r0
   2ac4c:	2b00      	cmp	r3, #0
   2ac4e:	d012      	beq.n	2ac76 <xQueueGenericReset+0xa2>
				{
					queueYIELD_IF_USING_PREEMPTION();
   2ac50:	4b0c      	ldr	r3, [pc, #48]	; (2ac84 <xQueueGenericReset+0xb0>)
   2ac52:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2ac56:	601a      	str	r2, [r3, #0]
   2ac58:	f3bf 8f4f 	dsb	sy
   2ac5c:	f3bf 8f6f 	isb	sy
   2ac60:	e009      	b.n	2ac76 <xQueueGenericReset+0xa2>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   2ac62:	68fb      	ldr	r3, [r7, #12]
   2ac64:	3310      	adds	r3, #16
   2ac66:	4618      	mov	r0, r3
   2ac68:	f7ff fc0e 	bl	2a488 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   2ac6c:	68fb      	ldr	r3, [r7, #12]
   2ac6e:	3324      	adds	r3, #36	; 0x24
   2ac70:	4618      	mov	r0, r3
   2ac72:	f7ff fc09 	bl	2a488 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
   2ac76:	f7ff fdbf 	bl	2a7f8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   2ac7a:	2301      	movs	r3, #1
}
   2ac7c:	4618      	mov	r0, r3
   2ac7e:	3710      	adds	r7, #16
   2ac80:	46bd      	mov	sp, r7
   2ac82:	bd80      	pop	{r7, pc}
   2ac84:	e000ed04 	.word	0xe000ed04

0002ac88 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
   2ac88:	b580      	push	{r7, lr}
   2ac8a:	b08a      	sub	sp, #40	; 0x28
   2ac8c:	af02      	add	r7, sp, #8
   2ac8e:	60f8      	str	r0, [r7, #12]
   2ac90:	60b9      	str	r1, [r7, #8]
   2ac92:	4613      	mov	r3, r2
   2ac94:	71fb      	strb	r3, [r7, #7]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
   2ac96:	68bb      	ldr	r3, [r7, #8]
   2ac98:	2b00      	cmp	r3, #0
   2ac9a:	d102      	bne.n	2aca2 <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
   2ac9c:	2300      	movs	r3, #0
   2ac9e:	61fb      	str	r3, [r7, #28]
   2aca0:	e004      	b.n	2acac <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2aca2:	68fb      	ldr	r3, [r7, #12]
   2aca4:	68ba      	ldr	r2, [r7, #8]
   2aca6:	fb02 f303 	mul.w	r3, r2, r3
   2acaa:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
   2acac:	69fb      	ldr	r3, [r7, #28]
   2acae:	3348      	adds	r3, #72	; 0x48
   2acb0:	4618      	mov	r0, r3
   2acb2:	f7fe fdc5 	bl	29840 <pvPortMalloc>
   2acb6:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
   2acb8:	69bb      	ldr	r3, [r7, #24]
   2acba:	2b00      	cmp	r3, #0
   2acbc:	d00d      	beq.n	2acda <xQueueGenericCreate+0x52>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
   2acbe:	69bb      	ldr	r3, [r7, #24]
   2acc0:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
   2acc2:	697b      	ldr	r3, [r7, #20]
   2acc4:	3348      	adds	r3, #72	; 0x48
   2acc6:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
   2acc8:	79fa      	ldrb	r2, [r7, #7]
   2acca:	69bb      	ldr	r3, [r7, #24]
   2accc:	9300      	str	r3, [sp, #0]
   2acce:	4613      	mov	r3, r2
   2acd0:	697a      	ldr	r2, [r7, #20]
   2acd2:	68b9      	ldr	r1, [r7, #8]
   2acd4:	68f8      	ldr	r0, [r7, #12]
   2acd6:	f000 f805 	bl	2ace4 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
   2acda:	69bb      	ldr	r3, [r7, #24]
	}
   2acdc:	4618      	mov	r0, r3
   2acde:	3720      	adds	r7, #32
   2ace0:	46bd      	mov	sp, r7
   2ace2:	bd80      	pop	{r7, pc}

0002ace4 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
   2ace4:	b580      	push	{r7, lr}
   2ace6:	b084      	sub	sp, #16
   2ace8:	af00      	add	r7, sp, #0
   2acea:	60f8      	str	r0, [r7, #12]
   2acec:	60b9      	str	r1, [r7, #8]
   2acee:	607a      	str	r2, [r7, #4]
   2acf0:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
   2acf2:	68bb      	ldr	r3, [r7, #8]
   2acf4:	2b00      	cmp	r3, #0
   2acf6:	d103      	bne.n	2ad00 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   2acf8:	69bb      	ldr	r3, [r7, #24]
   2acfa:	69ba      	ldr	r2, [r7, #24]
   2acfc:	601a      	str	r2, [r3, #0]
   2acfe:	e002      	b.n	2ad06 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   2ad00:	69bb      	ldr	r3, [r7, #24]
   2ad02:	687a      	ldr	r2, [r7, #4]
   2ad04:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
   2ad06:	69bb      	ldr	r3, [r7, #24]
   2ad08:	68fa      	ldr	r2, [r7, #12]
   2ad0a:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   2ad0c:	69bb      	ldr	r3, [r7, #24]
   2ad0e:	68ba      	ldr	r2, [r7, #8]
   2ad10:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   2ad12:	2101      	movs	r1, #1
   2ad14:	69b8      	ldr	r0, [r7, #24]
   2ad16:	f7ff ff5d 	bl	2abd4 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
   2ad1a:	bf00      	nop
   2ad1c:	3710      	adds	r7, #16
   2ad1e:	46bd      	mov	sp, r7
   2ad20:	bd80      	pop	{r7, pc}
	...

0002ad24 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   2ad24:	b580      	push	{r7, lr}
   2ad26:	b08a      	sub	sp, #40	; 0x28
   2ad28:	af00      	add	r7, sp, #0
   2ad2a:	60f8      	str	r0, [r7, #12]
   2ad2c:	60b9      	str	r1, [r7, #8]
   2ad2e:	607a      	str	r2, [r7, #4]
   2ad30:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   2ad32:	2300      	movs	r3, #0
   2ad34:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
   2ad36:	68fb      	ldr	r3, [r7, #12]
   2ad38:	623b      	str	r3, [r7, #32]
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   2ad3a:	f7ff fd43 	bl	2a7c4 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   2ad3e:	6a3b      	ldr	r3, [r7, #32]
   2ad40:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   2ad42:	6a3b      	ldr	r3, [r7, #32]
   2ad44:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   2ad46:	429a      	cmp	r2, r3
   2ad48:	d302      	bcc.n	2ad50 <xQueueGenericSend+0x2c>
   2ad4a:	683b      	ldr	r3, [r7, #0]
   2ad4c:	2b02      	cmp	r3, #2
   2ad4e:	d129      	bne.n	2ada4 <xQueueGenericSend+0x80>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   2ad50:	683a      	ldr	r2, [r7, #0]
   2ad52:	68b9      	ldr	r1, [r7, #8]
   2ad54:	6a38      	ldr	r0, [r7, #32]
   2ad56:	f000 f98b 	bl	2b070 <prvCopyDataToQueue>
   2ad5a:	61f8      	str	r0, [r7, #28]

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2ad5c:	6a3b      	ldr	r3, [r7, #32]
   2ad5e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2ad60:	2b00      	cmp	r3, #0
   2ad62:	d010      	beq.n	2ad86 <xQueueGenericSend+0x62>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2ad64:	6a3b      	ldr	r3, [r7, #32]
   2ad66:	3324      	adds	r3, #36	; 0x24
   2ad68:	4618      	mov	r0, r3
   2ad6a:	f001 f9f5 	bl	2c158 <xTaskRemoveFromEventList>
   2ad6e:	4603      	mov	r3, r0
   2ad70:	2b00      	cmp	r3, #0
   2ad72:	d013      	beq.n	2ad9c <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   2ad74:	4b3f      	ldr	r3, [pc, #252]	; (2ae74 <xQueueGenericSend+0x150>)
   2ad76:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2ad7a:	601a      	str	r2, [r3, #0]
   2ad7c:	f3bf 8f4f 	dsb	sy
   2ad80:	f3bf 8f6f 	isb	sy
   2ad84:	e00a      	b.n	2ad9c <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   2ad86:	69fb      	ldr	r3, [r7, #28]
   2ad88:	2b00      	cmp	r3, #0
   2ad8a:	d007      	beq.n	2ad9c <xQueueGenericSend+0x78>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   2ad8c:	4b39      	ldr	r3, [pc, #228]	; (2ae74 <xQueueGenericSend+0x150>)
   2ad8e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2ad92:	601a      	str	r2, [r3, #0]
   2ad94:	f3bf 8f4f 	dsb	sy
   2ad98:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   2ad9c:	f7ff fd2c 	bl	2a7f8 <vPortExitCritical>
				return pdPASS;
   2ada0:	2301      	movs	r3, #1
   2ada2:	e063      	b.n	2ae6c <xQueueGenericSend+0x148>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   2ada4:	687b      	ldr	r3, [r7, #4]
   2ada6:	2b00      	cmp	r3, #0
   2ada8:	d103      	bne.n	2adb2 <xQueueGenericSend+0x8e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   2adaa:	f7ff fd25 	bl	2a7f8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   2adae:	2300      	movs	r3, #0
   2adb0:	e05c      	b.n	2ae6c <xQueueGenericSend+0x148>
				}
				else if( xEntryTimeSet == pdFALSE )
   2adb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2adb4:	2b00      	cmp	r3, #0
   2adb6:	d106      	bne.n	2adc6 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   2adb8:	f107 0314 	add.w	r3, r7, #20
   2adbc:	4618      	mov	r0, r3
   2adbe:	f001 fa67 	bl	2c290 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   2adc2:	2301      	movs	r3, #1
   2adc4:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   2adc6:	f7ff fd17 	bl	2a7f8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   2adca:	f000 ff93 	bl	2bcf4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   2adce:	f7ff fcf9 	bl	2a7c4 <vPortEnterCritical>
   2add2:	6a3b      	ldr	r3, [r7, #32]
   2add4:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   2add8:	b25b      	sxtb	r3, r3
   2adda:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2adde:	d103      	bne.n	2ade8 <xQueueGenericSend+0xc4>
   2ade0:	6a3b      	ldr	r3, [r7, #32]
   2ade2:	2200      	movs	r2, #0
   2ade4:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   2ade8:	6a3b      	ldr	r3, [r7, #32]
   2adea:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   2adee:	b25b      	sxtb	r3, r3
   2adf0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2adf4:	d103      	bne.n	2adfe <xQueueGenericSend+0xda>
   2adf6:	6a3b      	ldr	r3, [r7, #32]
   2adf8:	2200      	movs	r2, #0
   2adfa:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   2adfe:	f7ff fcfb 	bl	2a7f8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   2ae02:	1d3a      	adds	r2, r7, #4
   2ae04:	f107 0314 	add.w	r3, r7, #20
   2ae08:	4611      	mov	r1, r2
   2ae0a:	4618      	mov	r0, r3
   2ae0c:	f001 fa56 	bl	2c2bc <xTaskCheckForTimeOut>
   2ae10:	4603      	mov	r3, r0
   2ae12:	2b00      	cmp	r3, #0
   2ae14:	d124      	bne.n	2ae60 <xQueueGenericSend+0x13c>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   2ae16:	6a38      	ldr	r0, [r7, #32]
   2ae18:	f000 fa14 	bl	2b244 <prvIsQueueFull>
   2ae1c:	4603      	mov	r3, r0
   2ae1e:	2b00      	cmp	r3, #0
   2ae20:	d018      	beq.n	2ae54 <xQueueGenericSend+0x130>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   2ae22:	6a3b      	ldr	r3, [r7, #32]
   2ae24:	3310      	adds	r3, #16
   2ae26:	687a      	ldr	r2, [r7, #4]
   2ae28:	4611      	mov	r1, r2
   2ae2a:	4618      	mov	r0, r3
   2ae2c:	f001 f942 	bl	2c0b4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   2ae30:	6a38      	ldr	r0, [r7, #32]
   2ae32:	f000 f99f 	bl	2b174 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   2ae36:	f000 ffa3 	bl	2bd80 <xTaskResumeAll>
   2ae3a:	4603      	mov	r3, r0
   2ae3c:	2b00      	cmp	r3, #0
   2ae3e:	f47f af7c 	bne.w	2ad3a <xQueueGenericSend+0x16>
				{
					portYIELD_WITHIN_API();
   2ae42:	4b0c      	ldr	r3, [pc, #48]	; (2ae74 <xQueueGenericSend+0x150>)
   2ae44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2ae48:	601a      	str	r2, [r3, #0]
   2ae4a:	f3bf 8f4f 	dsb	sy
   2ae4e:	f3bf 8f6f 	isb	sy
   2ae52:	e772      	b.n	2ad3a <xQueueGenericSend+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   2ae54:	6a38      	ldr	r0, [r7, #32]
   2ae56:	f000 f98d 	bl	2b174 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   2ae5a:	f000 ff91 	bl	2bd80 <xTaskResumeAll>
   2ae5e:	e76c      	b.n	2ad3a <xQueueGenericSend+0x16>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   2ae60:	6a38      	ldr	r0, [r7, #32]
   2ae62:	f000 f987 	bl	2b174 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   2ae66:	f000 ff8b 	bl	2bd80 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   2ae6a:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
   2ae6c:	4618      	mov	r0, r3
   2ae6e:	3728      	adds	r7, #40	; 0x28
   2ae70:	46bd      	mov	sp, r7
   2ae72:	bd80      	pop	{r7, pc}
   2ae74:	e000ed04 	.word	0xe000ed04

0002ae78 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   2ae78:	b580      	push	{r7, lr}
   2ae7a:	b08c      	sub	sp, #48	; 0x30
   2ae7c:	af00      	add	r7, sp, #0
   2ae7e:	60f8      	str	r0, [r7, #12]
   2ae80:	60b9      	str	r1, [r7, #8]
   2ae82:	607a      	str	r2, [r7, #4]
   2ae84:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
   2ae86:	68fb      	ldr	r3, [r7, #12]
   2ae88:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm volatile
   2ae8a:	f3ef 8211 	mrs	r2, BASEPRI
   2ae8e:	f04f 0360 	mov.w	r3, #96	; 0x60
   2ae92:	f383 8811 	msr	BASEPRI, r3
   2ae96:	f3bf 8f6f 	isb	sy
   2ae9a:	f3bf 8f4f 	dsb	sy
   2ae9e:	61fa      	str	r2, [r7, #28]
   2aea0:	61bb      	str	r3, [r7, #24]
	return ulOriginalBASEPRI;
   2aea2:	69fb      	ldr	r3, [r7, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   2aea4:	627b      	str	r3, [r7, #36]	; 0x24
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   2aea6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2aea8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   2aeaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2aeac:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   2aeae:	429a      	cmp	r2, r3
   2aeb0:	d302      	bcc.n	2aeb8 <xQueueGenericSendFromISR+0x40>
   2aeb2:	683b      	ldr	r3, [r7, #0]
   2aeb4:	2b02      	cmp	r3, #2
   2aeb6:	d12c      	bne.n	2af12 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
   2aeb8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2aeba:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   2aebe:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   2aec2:	683a      	ldr	r2, [r7, #0]
   2aec4:	68b9      	ldr	r1, [r7, #8]
   2aec6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   2aec8:	f000 f8d2 	bl	2b070 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
   2aecc:	f997 3023 	ldrsb.w	r3, [r7, #35]	; 0x23
   2aed0:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2aed4:	d112      	bne.n	2aefc <xQueueGenericSendFromISR+0x84>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2aed6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2aed8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2aeda:	2b00      	cmp	r3, #0
   2aedc:	d016      	beq.n	2af0c <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2aede:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2aee0:	3324      	adds	r3, #36	; 0x24
   2aee2:	4618      	mov	r0, r3
   2aee4:	f001 f938 	bl	2c158 <xTaskRemoveFromEventList>
   2aee8:	4603      	mov	r3, r0
   2aeea:	2b00      	cmp	r3, #0
   2aeec:	d00e      	beq.n	2af0c <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   2aeee:	687b      	ldr	r3, [r7, #4]
   2aef0:	2b00      	cmp	r3, #0
   2aef2:	d00b      	beq.n	2af0c <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   2aef4:	687b      	ldr	r3, [r7, #4]
   2aef6:	2201      	movs	r2, #1
   2aef8:	601a      	str	r2, [r3, #0]
   2aefa:	e007      	b.n	2af0c <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   2aefc:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   2af00:	3301      	adds	r3, #1
   2af02:	b2db      	uxtb	r3, r3
   2af04:	b25a      	sxtb	r2, r3
   2af06:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2af08:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
   2af0c:	2301      	movs	r3, #1
   2af0e:	62fb      	str	r3, [r7, #44]	; 0x2c
		{
   2af10:	e001      	b.n	2af16 <xQueueGenericSendFromISR+0x9e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   2af12:	2300      	movs	r3, #0
   2af14:	62fb      	str	r3, [r7, #44]	; 0x2c
   2af16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2af18:	617b      	str	r3, [r7, #20]
	__asm volatile
   2af1a:	697b      	ldr	r3, [r7, #20]
   2af1c:	f383 8811 	msr	BASEPRI, r3
}
   2af20:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
   2af22:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
   2af24:	4618      	mov	r0, r3
   2af26:	3730      	adds	r7, #48	; 0x30
   2af28:	46bd      	mov	sp, r7
   2af2a:	bd80      	pop	{r7, pc}

0002af2c <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
   2af2c:	b580      	push	{r7, lr}
   2af2e:	b08a      	sub	sp, #40	; 0x28
   2af30:	af00      	add	r7, sp, #0
   2af32:	60f8      	str	r0, [r7, #12]
   2af34:	60b9      	str	r1, [r7, #8]
   2af36:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
   2af38:	2300      	movs	r3, #0
   2af3a:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
   2af3c:	68fb      	ldr	r3, [r7, #12]
   2af3e:	623b      	str	r3, [r7, #32]
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   2af40:	f7ff fc40 	bl	2a7c4 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   2af44:	6a3b      	ldr	r3, [r7, #32]
   2af46:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2af48:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   2af4a:	69fb      	ldr	r3, [r7, #28]
   2af4c:	2b00      	cmp	r3, #0
   2af4e:	d01f      	beq.n	2af90 <xQueueReceive+0x64>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   2af50:	68b9      	ldr	r1, [r7, #8]
   2af52:	6a38      	ldr	r0, [r7, #32]
   2af54:	f000 f8e8 	bl	2b128 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   2af58:	69fb      	ldr	r3, [r7, #28]
   2af5a:	1e5a      	subs	r2, r3, #1
   2af5c:	6a3b      	ldr	r3, [r7, #32]
   2af5e:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2af60:	6a3b      	ldr	r3, [r7, #32]
   2af62:	691b      	ldr	r3, [r3, #16]
   2af64:	2b00      	cmp	r3, #0
   2af66:	d00f      	beq.n	2af88 <xQueueReceive+0x5c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2af68:	6a3b      	ldr	r3, [r7, #32]
   2af6a:	3310      	adds	r3, #16
   2af6c:	4618      	mov	r0, r3
   2af6e:	f001 f8f3 	bl	2c158 <xTaskRemoveFromEventList>
   2af72:	4603      	mov	r3, r0
   2af74:	2b00      	cmp	r3, #0
   2af76:	d007      	beq.n	2af88 <xQueueReceive+0x5c>
					{
						queueYIELD_IF_USING_PREEMPTION();
   2af78:	4b3c      	ldr	r3, [pc, #240]	; (2b06c <xQueueReceive+0x140>)
   2af7a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2af7e:	601a      	str	r2, [r3, #0]
   2af80:	f3bf 8f4f 	dsb	sy
   2af84:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
   2af88:	f7ff fc36 	bl	2a7f8 <vPortExitCritical>
				return pdPASS;
   2af8c:	2301      	movs	r3, #1
   2af8e:	e069      	b.n	2b064 <xQueueReceive+0x138>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   2af90:	687b      	ldr	r3, [r7, #4]
   2af92:	2b00      	cmp	r3, #0
   2af94:	d103      	bne.n	2af9e <xQueueReceive+0x72>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   2af96:	f7ff fc2f 	bl	2a7f8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   2af9a:	2300      	movs	r3, #0
   2af9c:	e062      	b.n	2b064 <xQueueReceive+0x138>
				}
				else if( xEntryTimeSet == pdFALSE )
   2af9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2afa0:	2b00      	cmp	r3, #0
   2afa2:	d106      	bne.n	2afb2 <xQueueReceive+0x86>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
   2afa4:	f107 0314 	add.w	r3, r7, #20
   2afa8:	4618      	mov	r0, r3
   2afaa:	f001 f971 	bl	2c290 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
   2afae:	2301      	movs	r3, #1
   2afb0:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   2afb2:	f7ff fc21 	bl	2a7f8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   2afb6:	f000 fe9d 	bl	2bcf4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
   2afba:	f7ff fc03 	bl	2a7c4 <vPortEnterCritical>
   2afbe:	6a3b      	ldr	r3, [r7, #32]
   2afc0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   2afc4:	b25b      	sxtb	r3, r3
   2afc6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2afca:	d103      	bne.n	2afd4 <xQueueReceive+0xa8>
   2afcc:	6a3b      	ldr	r3, [r7, #32]
   2afce:	2200      	movs	r2, #0
   2afd0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   2afd4:	6a3b      	ldr	r3, [r7, #32]
   2afd6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   2afda:	b25b      	sxtb	r3, r3
   2afdc:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2afe0:	d103      	bne.n	2afea <xQueueReceive+0xbe>
   2afe2:	6a3b      	ldr	r3, [r7, #32]
   2afe4:	2200      	movs	r2, #0
   2afe6:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   2afea:	f7ff fc05 	bl	2a7f8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   2afee:	1d3a      	adds	r2, r7, #4
   2aff0:	f107 0314 	add.w	r3, r7, #20
   2aff4:	4611      	mov	r1, r2
   2aff6:	4618      	mov	r0, r3
   2aff8:	f001 f960 	bl	2c2bc <xTaskCheckForTimeOut>
   2affc:	4603      	mov	r3, r0
   2affe:	2b00      	cmp	r3, #0
   2b000:	d123      	bne.n	2b04a <xQueueReceive+0x11e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   2b002:	6a38      	ldr	r0, [r7, #32]
   2b004:	f000 f908 	bl	2b218 <prvIsQueueEmpty>
   2b008:	4603      	mov	r3, r0
   2b00a:	2b00      	cmp	r3, #0
   2b00c:	d017      	beq.n	2b03e <xQueueReceive+0x112>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   2b00e:	6a3b      	ldr	r3, [r7, #32]
   2b010:	3324      	adds	r3, #36	; 0x24
   2b012:	687a      	ldr	r2, [r7, #4]
   2b014:	4611      	mov	r1, r2
   2b016:	4618      	mov	r0, r3
   2b018:	f001 f84c 	bl	2c0b4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
   2b01c:	6a38      	ldr	r0, [r7, #32]
   2b01e:	f000 f8a9 	bl	2b174 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
   2b022:	f000 fead 	bl	2bd80 <xTaskResumeAll>
   2b026:	4603      	mov	r3, r0
   2b028:	2b00      	cmp	r3, #0
   2b02a:	d189      	bne.n	2af40 <xQueueReceive+0x14>
				{
					portYIELD_WITHIN_API();
   2b02c:	4b0f      	ldr	r3, [pc, #60]	; (2b06c <xQueueReceive+0x140>)
   2b02e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2b032:	601a      	str	r2, [r3, #0]
   2b034:	f3bf 8f4f 	dsb	sy
   2b038:	f3bf 8f6f 	isb	sy
   2b03c:	e780      	b.n	2af40 <xQueueReceive+0x14>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
   2b03e:	6a38      	ldr	r0, [r7, #32]
   2b040:	f000 f898 	bl	2b174 <prvUnlockQueue>
				( void ) xTaskResumeAll();
   2b044:	f000 fe9c 	bl	2bd80 <xTaskResumeAll>
   2b048:	e77a      	b.n	2af40 <xQueueReceive+0x14>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
   2b04a:	6a38      	ldr	r0, [r7, #32]
   2b04c:	f000 f892 	bl	2b174 <prvUnlockQueue>
			( void ) xTaskResumeAll();
   2b050:	f000 fe96 	bl	2bd80 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   2b054:	6a38      	ldr	r0, [r7, #32]
   2b056:	f000 f8df 	bl	2b218 <prvIsQueueEmpty>
   2b05a:	4603      	mov	r3, r0
   2b05c:	2b00      	cmp	r3, #0
   2b05e:	f43f af6f 	beq.w	2af40 <xQueueReceive+0x14>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
   2b062:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
   2b064:	4618      	mov	r0, r3
   2b066:	3728      	adds	r7, #40	; 0x28
   2b068:	46bd      	mov	sp, r7
   2b06a:	bd80      	pop	{r7, pc}
   2b06c:	e000ed04 	.word	0xe000ed04

0002b070 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   2b070:	b580      	push	{r7, lr}
   2b072:	b086      	sub	sp, #24
   2b074:	af00      	add	r7, sp, #0
   2b076:	60f8      	str	r0, [r7, #12]
   2b078:	60b9      	str	r1, [r7, #8]
   2b07a:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   2b07c:	2300      	movs	r3, #0
   2b07e:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   2b080:	68fb      	ldr	r3, [r7, #12]
   2b082:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2b084:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   2b086:	68fb      	ldr	r3, [r7, #12]
   2b088:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b08a:	2b00      	cmp	r3, #0
   2b08c:	d043      	beq.n	2b116 <prvCopyDataToQueue+0xa6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   2b08e:	687b      	ldr	r3, [r7, #4]
   2b090:	2b00      	cmp	r3, #0
   2b092:	d119      	bne.n	2b0c8 <prvCopyDataToQueue+0x58>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   2b094:	68fb      	ldr	r3, [r7, #12]
   2b096:	6858      	ldr	r0, [r3, #4]
   2b098:	68fb      	ldr	r3, [r7, #12]
   2b09a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b09c:	461a      	mov	r2, r3
   2b09e:	68b9      	ldr	r1, [r7, #8]
   2b0a0:	f7ed f8d8 	bl	18254 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   2b0a4:	68fb      	ldr	r3, [r7, #12]
   2b0a6:	685a      	ldr	r2, [r3, #4]
   2b0a8:	68fb      	ldr	r3, [r7, #12]
   2b0aa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b0ac:	441a      	add	r2, r3
   2b0ae:	68fb      	ldr	r3, [r7, #12]
   2b0b0:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   2b0b2:	68fb      	ldr	r3, [r7, #12]
   2b0b4:	685a      	ldr	r2, [r3, #4]
   2b0b6:	68fb      	ldr	r3, [r7, #12]
   2b0b8:	689b      	ldr	r3, [r3, #8]
   2b0ba:	429a      	cmp	r2, r3
   2b0bc:	d32b      	bcc.n	2b116 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   2b0be:	68fb      	ldr	r3, [r7, #12]
   2b0c0:	681a      	ldr	r2, [r3, #0]
   2b0c2:	68fb      	ldr	r3, [r7, #12]
   2b0c4:	605a      	str	r2, [r3, #4]
   2b0c6:	e026      	b.n	2b116 <prvCopyDataToQueue+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
   2b0c8:	68fb      	ldr	r3, [r7, #12]
   2b0ca:	68d8      	ldr	r0, [r3, #12]
   2b0cc:	68fb      	ldr	r3, [r7, #12]
   2b0ce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b0d0:	461a      	mov	r2, r3
   2b0d2:	68b9      	ldr	r1, [r7, #8]
   2b0d4:	f7ed f8be 	bl	18254 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
   2b0d8:	68fb      	ldr	r3, [r7, #12]
   2b0da:	68da      	ldr	r2, [r3, #12]
   2b0dc:	68fb      	ldr	r3, [r7, #12]
   2b0de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b0e0:	425b      	negs	r3, r3
   2b0e2:	441a      	add	r2, r3
   2b0e4:	68fb      	ldr	r3, [r7, #12]
   2b0e6:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   2b0e8:	68fb      	ldr	r3, [r7, #12]
   2b0ea:	68da      	ldr	r2, [r3, #12]
   2b0ec:	68fb      	ldr	r3, [r7, #12]
   2b0ee:	681b      	ldr	r3, [r3, #0]
   2b0f0:	429a      	cmp	r2, r3
   2b0f2:	d207      	bcs.n	2b104 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
   2b0f4:	68fb      	ldr	r3, [r7, #12]
   2b0f6:	689a      	ldr	r2, [r3, #8]
   2b0f8:	68fb      	ldr	r3, [r7, #12]
   2b0fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b0fc:	425b      	negs	r3, r3
   2b0fe:	441a      	add	r2, r3
   2b100:	68fb      	ldr	r3, [r7, #12]
   2b102:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   2b104:	687b      	ldr	r3, [r7, #4]
   2b106:	2b02      	cmp	r3, #2
   2b108:	d105      	bne.n	2b116 <prvCopyDataToQueue+0xa6>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   2b10a:	697b      	ldr	r3, [r7, #20]
   2b10c:	2b00      	cmp	r3, #0
   2b10e:	d002      	beq.n	2b116 <prvCopyDataToQueue+0xa6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
   2b110:	697b      	ldr	r3, [r7, #20]
   2b112:	3b01      	subs	r3, #1
   2b114:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   2b116:	697b      	ldr	r3, [r7, #20]
   2b118:	1c5a      	adds	r2, r3, #1
   2b11a:	68fb      	ldr	r3, [r7, #12]
   2b11c:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   2b11e:	693b      	ldr	r3, [r7, #16]
}
   2b120:	4618      	mov	r0, r3
   2b122:	3718      	adds	r7, #24
   2b124:	46bd      	mov	sp, r7
   2b126:	bd80      	pop	{r7, pc}

0002b128 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   2b128:	b580      	push	{r7, lr}
   2b12a:	b082      	sub	sp, #8
   2b12c:	af00      	add	r7, sp, #0
   2b12e:	6078      	str	r0, [r7, #4]
   2b130:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   2b132:	687b      	ldr	r3, [r7, #4]
   2b134:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b136:	2b00      	cmp	r3, #0
   2b138:	d018      	beq.n	2b16c <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
   2b13a:	687b      	ldr	r3, [r7, #4]
   2b13c:	68da      	ldr	r2, [r3, #12]
   2b13e:	687b      	ldr	r3, [r7, #4]
   2b140:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b142:	441a      	add	r2, r3
   2b144:	687b      	ldr	r3, [r7, #4]
   2b146:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   2b148:	687b      	ldr	r3, [r7, #4]
   2b14a:	68da      	ldr	r2, [r3, #12]
   2b14c:	687b      	ldr	r3, [r7, #4]
   2b14e:	689b      	ldr	r3, [r3, #8]
   2b150:	429a      	cmp	r2, r3
   2b152:	d303      	bcc.n	2b15c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
   2b154:	687b      	ldr	r3, [r7, #4]
   2b156:	681a      	ldr	r2, [r3, #0]
   2b158:	687b      	ldr	r3, [r7, #4]
   2b15a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
   2b15c:	687b      	ldr	r3, [r7, #4]
   2b15e:	68d9      	ldr	r1, [r3, #12]
   2b160:	687b      	ldr	r3, [r7, #4]
   2b162:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   2b164:	461a      	mov	r2, r3
   2b166:	6838      	ldr	r0, [r7, #0]
   2b168:	f7ed f874 	bl	18254 <memcpy>
	}
}
   2b16c:	bf00      	nop
   2b16e:	3708      	adds	r7, #8
   2b170:	46bd      	mov	sp, r7
   2b172:	bd80      	pop	{r7, pc}

0002b174 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   2b174:	b580      	push	{r7, lr}
   2b176:	b084      	sub	sp, #16
   2b178:	af00      	add	r7, sp, #0
   2b17a:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   2b17c:	f7ff fb22 	bl	2a7c4 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
   2b180:	687b      	ldr	r3, [r7, #4]
   2b182:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   2b186:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
   2b188:	e011      	b.n	2b1ae <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2b18a:	687b      	ldr	r3, [r7, #4]
   2b18c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2b18e:	2b00      	cmp	r3, #0
   2b190:	d012      	beq.n	2b1b8 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2b192:	687b      	ldr	r3, [r7, #4]
   2b194:	3324      	adds	r3, #36	; 0x24
   2b196:	4618      	mov	r0, r3
   2b198:	f000 ffde 	bl	2c158 <xTaskRemoveFromEventList>
   2b19c:	4603      	mov	r3, r0
   2b19e:	2b00      	cmp	r3, #0
   2b1a0:	d001      	beq.n	2b1a6 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
   2b1a2:	f001 f8d1 	bl	2c348 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
   2b1a6:	7bfb      	ldrb	r3, [r7, #15]
   2b1a8:	3b01      	subs	r3, #1
   2b1aa:	b2db      	uxtb	r3, r3
   2b1ac:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
   2b1ae:	f997 300f 	ldrsb.w	r3, [r7, #15]
   2b1b2:	2b00      	cmp	r3, #0
   2b1b4:	dce9      	bgt.n	2b18a <prvUnlockQueue+0x16>
   2b1b6:	e000      	b.n	2b1ba <prvUnlockQueue+0x46>
					break;
   2b1b8:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
   2b1ba:	687b      	ldr	r3, [r7, #4]
   2b1bc:	22ff      	movs	r2, #255	; 0xff
   2b1be:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
   2b1c2:	f7ff fb19 	bl	2a7f8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   2b1c6:	f7ff fafd 	bl	2a7c4 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
   2b1ca:	687b      	ldr	r3, [r7, #4]
   2b1cc:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   2b1d0:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
   2b1d2:	e011      	b.n	2b1f8 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2b1d4:	687b      	ldr	r3, [r7, #4]
   2b1d6:	691b      	ldr	r3, [r3, #16]
   2b1d8:	2b00      	cmp	r3, #0
   2b1da:	d012      	beq.n	2b202 <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2b1dc:	687b      	ldr	r3, [r7, #4]
   2b1de:	3310      	adds	r3, #16
   2b1e0:	4618      	mov	r0, r3
   2b1e2:	f000 ffb9 	bl	2c158 <xTaskRemoveFromEventList>
   2b1e6:	4603      	mov	r3, r0
   2b1e8:	2b00      	cmp	r3, #0
   2b1ea:	d001      	beq.n	2b1f0 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
   2b1ec:	f001 f8ac 	bl	2c348 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
   2b1f0:	7bbb      	ldrb	r3, [r7, #14]
   2b1f2:	3b01      	subs	r3, #1
   2b1f4:	b2db      	uxtb	r3, r3
   2b1f6:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
   2b1f8:	f997 300e 	ldrsb.w	r3, [r7, #14]
   2b1fc:	2b00      	cmp	r3, #0
   2b1fe:	dce9      	bgt.n	2b1d4 <prvUnlockQueue+0x60>
   2b200:	e000      	b.n	2b204 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
   2b202:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
   2b204:	687b      	ldr	r3, [r7, #4]
   2b206:	22ff      	movs	r2, #255	; 0xff
   2b208:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   2b20c:	f7ff faf4 	bl	2a7f8 <vPortExitCritical>
}
   2b210:	bf00      	nop
   2b212:	3710      	adds	r7, #16
   2b214:	46bd      	mov	sp, r7
   2b216:	bd80      	pop	{r7, pc}

0002b218 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   2b218:	b580      	push	{r7, lr}
   2b21a:	b084      	sub	sp, #16
   2b21c:	af00      	add	r7, sp, #0
   2b21e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   2b220:	f7ff fad0 	bl	2a7c4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   2b224:	687b      	ldr	r3, [r7, #4]
   2b226:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2b228:	2b00      	cmp	r3, #0
   2b22a:	d102      	bne.n	2b232 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
   2b22c:	2301      	movs	r3, #1
   2b22e:	60fb      	str	r3, [r7, #12]
   2b230:	e001      	b.n	2b236 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
   2b232:	2300      	movs	r3, #0
   2b234:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   2b236:	f7ff fadf 	bl	2a7f8 <vPortExitCritical>

	return xReturn;
   2b23a:	68fb      	ldr	r3, [r7, #12]
}
   2b23c:	4618      	mov	r0, r3
   2b23e:	3710      	adds	r7, #16
   2b240:	46bd      	mov	sp, r7
   2b242:	bd80      	pop	{r7, pc}

0002b244 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   2b244:	b580      	push	{r7, lr}
   2b246:	b084      	sub	sp, #16
   2b248:	af00      	add	r7, sp, #0
   2b24a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   2b24c:	f7ff faba 	bl	2a7c4 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   2b250:	687b      	ldr	r3, [r7, #4]
   2b252:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   2b254:	687b      	ldr	r3, [r7, #4]
   2b256:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   2b258:	429a      	cmp	r2, r3
   2b25a:	d102      	bne.n	2b262 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
   2b25c:	2301      	movs	r3, #1
   2b25e:	60fb      	str	r3, [r7, #12]
   2b260:	e001      	b.n	2b266 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   2b262:	2300      	movs	r3, #0
   2b264:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   2b266:	f7ff fac7 	bl	2a7f8 <vPortExitCritical>

	return xReturn;
   2b26a:	68fb      	ldr	r3, [r7, #12]
}
   2b26c:	4618      	mov	r0, r3
   2b26e:	3710      	adds	r7, #16
   2b270:	46bd      	mov	sp, r7
   2b272:	bd80      	pop	{r7, pc}

0002b274 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   2b274:	b580      	push	{r7, lr}
   2b276:	b086      	sub	sp, #24
   2b278:	af00      	add	r7, sp, #0
   2b27a:	60f8      	str	r0, [r7, #12]
   2b27c:	60b9      	str	r1, [r7, #8]
   2b27e:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
   2b280:	68fb      	ldr	r3, [r7, #12]
   2b282:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   2b284:	f7ff fa9e 	bl	2a7c4 <vPortEnterCritical>
   2b288:	697b      	ldr	r3, [r7, #20]
   2b28a:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
   2b28e:	b25b      	sxtb	r3, r3
   2b290:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2b294:	d103      	bne.n	2b29e <vQueueWaitForMessageRestricted+0x2a>
   2b296:	697b      	ldr	r3, [r7, #20]
   2b298:	2200      	movs	r2, #0
   2b29a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
   2b29e:	697b      	ldr	r3, [r7, #20]
   2b2a0:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
   2b2a4:	b25b      	sxtb	r3, r3
   2b2a6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2b2aa:	d103      	bne.n	2b2b4 <vQueueWaitForMessageRestricted+0x40>
   2b2ac:	697b      	ldr	r3, [r7, #20]
   2b2ae:	2200      	movs	r2, #0
   2b2b0:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
   2b2b4:	f7ff faa0 	bl	2a7f8 <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   2b2b8:	697b      	ldr	r3, [r7, #20]
   2b2ba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2b2bc:	2b00      	cmp	r3, #0
   2b2be:	d106      	bne.n	2b2ce <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   2b2c0:	697b      	ldr	r3, [r7, #20]
   2b2c2:	3324      	adds	r3, #36	; 0x24
   2b2c4:	687a      	ldr	r2, [r7, #4]
   2b2c6:	68b9      	ldr	r1, [r7, #8]
   2b2c8:	4618      	mov	r0, r3
   2b2ca:	f000 ff27 	bl	2c11c <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   2b2ce:	6978      	ldr	r0, [r7, #20]
   2b2d0:	f7ff ff50 	bl	2b174 <prvUnlockQueue>
	}
   2b2d4:	bf00      	nop
   2b2d6:	3718      	adds	r7, #24
   2b2d8:	46bd      	mov	sp, r7
   2b2da:	bd80      	pop	{r7, pc}

0002b2dc <SecAesHciCback>:
 *
 *  \return none.
 */
/*************************************************************************************************/
void SecAesHciCback(secQueueBuf_t *pBuf, hciEvt_t *pEvent, wsfHandlerId_t handlerId)
{
   2b2dc:	b580      	push	{r7, lr}
   2b2de:	b086      	sub	sp, #24
   2b2e0:	af00      	add	r7, sp, #0
   2b2e2:	60f8      	str	r0, [r7, #12]
   2b2e4:	60b9      	str	r1, [r7, #8]
   2b2e6:	4613      	mov	r3, r2
   2b2e8:	71fb      	strb	r3, [r7, #7]
  secAes_t *pAes = (secAes_t *) &pBuf->msg;
   2b2ea:	68fb      	ldr	r3, [r7, #12]
   2b2ec:	617b      	str	r3, [r7, #20]

  /* set encrypted data pointer and copy */
  pAes->pCiphertext = pBuf->ciphertext;
   2b2ee:	68fb      	ldr	r3, [r7, #12]
   2b2f0:	f103 0210 	add.w	r2, r3, #16
   2b2f4:	697b      	ldr	r3, [r7, #20]
   2b2f6:	605a      	str	r2, [r3, #4]
  Calc128Cpy(pAes->pCiphertext, pEvent->leEncryptCmdCmpl.data);
   2b2f8:	697b      	ldr	r3, [r7, #20]
   2b2fa:	685a      	ldr	r2, [r3, #4]
   2b2fc:	68bb      	ldr	r3, [r7, #8]
   2b2fe:	3305      	adds	r3, #5
   2b300:	4619      	mov	r1, r3
   2b302:	4610      	mov	r0, r2
   2b304:	f7f6 fc70 	bl	21be8 <Calc128Cpy>

  /* send message */
  WsfMsgSend(handlerId, pAes);
   2b308:	79fb      	ldrb	r3, [r7, #7]
   2b30a:	6979      	ldr	r1, [r7, #20]
   2b30c:	4618      	mov	r0, r3
   2b30e:	f001 fef2 	bl	2d0f6 <WsfMsgSend>
}
   2b312:	bf00      	nop
   2b314:	3718      	adds	r7, #24
   2b316:	46bd      	mov	sp, r7
   2b318:	bd80      	pop	{r7, pc}
	...

0002b31c <SecAesInit>:
 *
 *  \return none.
 */
/*************************************************************************************************/
void SecAesInit()
{
   2b31c:	b480      	push	{r7}
   2b31e:	af00      	add	r7, sp, #0
  secCb.hciCbackTbl[SEC_TYPE_AES] = SecAesHciCback;
   2b320:	4b03      	ldr	r3, [pc, #12]	; (2b330 <SecAesInit+0x14>)
   2b322:	4a04      	ldr	r2, [pc, #16]	; (2b334 <SecAesInit+0x18>)
   2b324:	63da      	str	r2, [r3, #60]	; 0x3c
}
   2b326:	bf00      	nop
   2b328:	46bd      	mov	sp, r7
   2b32a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2b32e:	4770      	bx	lr
   2b330:	10011730 	.word	0x10011730
   2b334:	0002b2dd 	.word	0x0002b2dd

0002b338 <secCmacProcessBlock>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void secCmacProcessBlock(secQueueBuf_t *pBuf)
{
   2b338:	b580      	push	{r7, lr}
   2b33a:	b08a      	sub	sp, #40	; 0x28
   2b33c:	af00      	add	r7, sp, #0
   2b33e:	6078      	str	r0, [r7, #4]
  secCmacSecCb_t *pCmac = (secCmacSecCb_t*) pBuf->pCb;
   2b340:	687b      	ldr	r3, [r7, #4]
   2b342:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b344:	627b      	str	r3, [r7, #36]	; 0x24
  uint8_t text[SEC_BLOCK_LEN];
  uint8_t *pMn = pCmac->pPlainText + pCmac->position;
   2b346:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b348:	681b      	ldr	r3, [r3, #0]
   2b34a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   2b34c:	8c92      	ldrh	r2, [r2, #36]	; 0x24
   2b34e:	4413      	add	r3, r2
   2b350:	623b      	str	r3, [r7, #32]
  int16_t remaining = (int16_t) pCmac->len - pCmac->position;
   2b352:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b354:	8cda      	ldrh	r2, [r3, #38]	; 0x26
   2b356:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b358:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
   2b35a:	1ad3      	subs	r3, r2, r3
   2b35c:	b29b      	uxth	r3, r3
   2b35e:	83fb      	strh	r3, [r7, #30]

  /* Check for Last Block */
  if (remaining <= SEC_BLOCK_LEN)
   2b360:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
   2b364:	2b10      	cmp	r3, #16
   2b366:	dc2e      	bgt.n	2b3c6 <secCmacProcessBlock+0x8e>
  {
    memcpy(text, pMn, remaining);
   2b368:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
   2b36c:	f107 030c 	add.w	r3, r7, #12
   2b370:	6a39      	ldr	r1, [r7, #32]
   2b372:	4618      	mov	r0, r3
   2b374:	f7ec ff6e 	bl	18254 <memcpy>

    /* Pad the message if necessary */
    if (remaining != SEC_BLOCK_LEN)
   2b378:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
   2b37c:	2b10      	cmp	r3, #16
   2b37e:	d014      	beq.n	2b3aa <secCmacProcessBlock+0x72>
    {
      memset(text + remaining, 0, SEC_BLOCK_LEN - remaining);
   2b380:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
   2b384:	f107 020c 	add.w	r2, r7, #12
   2b388:	18d0      	adds	r0, r2, r3
   2b38a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
   2b38e:	f1c3 0310 	rsb	r3, r3, #16
   2b392:	461a      	mov	r2, r3
   2b394:	2100      	movs	r1, #0
   2b396:	f004 feab 	bl	300f0 <memset>
      text[remaining] = 0x80;
   2b39a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
   2b39e:	f107 0228 	add.w	r2, r7, #40	; 0x28
   2b3a2:	4413      	add	r3, r2
   2b3a4:	2280      	movs	r2, #128	; 0x80
   2b3a6:	f803 2c1c 	strb.w	r2, [r3, #-28]
    }

    /* XOr the subkey */
    Calc128Xor(text, pCmac->subkey);
   2b3aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3ac:	f103 0214 	add.w	r2, r3, #20
   2b3b0:	f107 030c 	add.w	r3, r7, #12
   2b3b4:	4611      	mov	r1, r2
   2b3b6:	4618      	mov	r0, r3
   2b3b8:	f7f6 fc24 	bl	21c04 <Calc128Xor>
    pCmac->state = SEC_CMAC_STATE_COMPLETE;
   2b3bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3be:	2202      	movs	r2, #2
   2b3c0:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
   2b3c4:	e005      	b.n	2b3d2 <secCmacProcessBlock+0x9a>
  }
  else
  {
    /* Copy the block to the buffer */
    Calc128Cpy(text, pMn);
   2b3c6:	f107 030c 	add.w	r3, r7, #12
   2b3ca:	6a39      	ldr	r1, [r7, #32]
   2b3cc:	4618      	mov	r0, r3
   2b3ce:	f7f6 fc0b 	bl	21be8 <Calc128Cpy>
  }

  if (pCmac->position != 0)
   2b3d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3d4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
   2b3d6:	2b00      	cmp	r3, #0
   2b3d8:	d008      	beq.n	2b3ec <secCmacProcessBlock+0xb4>
  {
    /* Except for first block, XOr the previous AES calculation */
    Calc128Xor(text, pBuf->ciphertext);
   2b3da:	687b      	ldr	r3, [r7, #4]
   2b3dc:	f103 0210 	add.w	r2, r3, #16
   2b3e0:	f107 030c 	add.w	r3, r7, #12
   2b3e4:	4611      	mov	r1, r2
   2b3e6:	4618      	mov	r0, r3
   2b3e8:	f7f6 fc0c 	bl	21c04 <Calc128Xor>
  }

  pCmac->position += SEC_BLOCK_LEN;
   2b3ec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3ee:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
   2b3f0:	3310      	adds	r3, #16
   2b3f2:	b29a      	uxth	r2, r3
   2b3f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3f6:	849a      	strh	r2, [r3, #36]	; 0x24

  SecLeEncryptCmd(pCmac->key, text, pBuf, pCmac->handlerId);
   2b3f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3fa:	1d18      	adds	r0, r3, #4
   2b3fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2b3fe:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
   2b402:	f107 010c 	add.w	r1, r7, #12
   2b406:	687a      	ldr	r2, [r7, #4]
   2b408:	f000 faa6 	bl	2b958 <SecLeEncryptCmd>
}
   2b40c:	bf00      	nop
   2b40e:	3728      	adds	r7, #40	; 0x28
   2b410:	46bd      	mov	sp, r7
   2b412:	bd80      	pop	{r7, pc}

0002b414 <secCmacGenSubkey1>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void secCmacGenSubkey1(secQueueBuf_t *pBuf)
{
   2b414:	b580      	push	{r7, lr}
   2b416:	b088      	sub	sp, #32
   2b418:	af00      	add	r7, sp, #0
   2b41a:	6078      	str	r0, [r7, #4]
  secCmacSecCb_t *pCmac = (secCmacSecCb_t*) pBuf->pCb;
   2b41c:	687b      	ldr	r3, [r7, #4]
   2b41e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b420:	61fb      	str	r3, [r7, #28]
  uint8_t buf[SEC_BLOCK_LEN];

  /* Perform aes on the key with a constant zero */
  memset(buf, 0, SEC_BLOCK_LEN);
   2b422:	f107 030c 	add.w	r3, r7, #12
   2b426:	2210      	movs	r2, #16
   2b428:	2100      	movs	r1, #0
   2b42a:	4618      	mov	r0, r3
   2b42c:	f004 fe60 	bl	300f0 <memset>

  SecLeEncryptCmd(pCmac->key, buf, pBuf, pCmac->handlerId);
   2b430:	69fb      	ldr	r3, [r7, #28]
   2b432:	1d18      	adds	r0, r3, #4
   2b434:	69fb      	ldr	r3, [r7, #28]
   2b436:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
   2b43a:	f107 010c 	add.w	r1, r7, #12
   2b43e:	687a      	ldr	r2, [r7, #4]
   2b440:	f000 fa8a 	bl	2b958 <SecLeEncryptCmd>
}
   2b444:	bf00      	nop
   2b446:	3720      	adds	r7, #32
   2b448:	46bd      	mov	sp, r7
   2b44a:	bd80      	pop	{r7, pc}

0002b44c <secCmacKeyShift>:
 *
 *  \return The overflow of the operaiton.
 */
/*************************************************************************************************/
static uint8_t secCmacKeyShift(uint8_t *pBuf, uint8_t shift)
{
   2b44c:	b480      	push	{r7}
   2b44e:	b085      	sub	sp, #20
   2b450:	af00      	add	r7, sp, #0
   2b452:	6078      	str	r0, [r7, #4]
   2b454:	460b      	mov	r3, r1
   2b456:	70fb      	strb	r3, [r7, #3]
  uint8_t overflow, i;
  uint8_t finalOverflow = pBuf[0] >> (8 - shift);
   2b458:	687b      	ldr	r3, [r7, #4]
   2b45a:	781b      	ldrb	r3, [r3, #0]
   2b45c:	461a      	mov	r2, r3
   2b45e:	78fb      	ldrb	r3, [r7, #3]
   2b460:	f1c3 0308 	rsb	r3, r3, #8
   2b464:	fa42 f303 	asr.w	r3, r2, r3
   2b468:	737b      	strb	r3, [r7, #13]

  for (i = 0; i < SEC_CMAC_KEY_LEN; i++)
   2b46a:	2300      	movs	r3, #0
   2b46c:	73bb      	strb	r3, [r7, #14]
   2b46e:	e026      	b.n	2b4be <secCmacKeyShift+0x72>
  {
    /* store shifted bits for next byte */
    if (i < SEC_CMAC_KEY_LEN-1)
   2b470:	7bbb      	ldrb	r3, [r7, #14]
   2b472:	2b0e      	cmp	r3, #14
   2b474:	d80c      	bhi.n	2b490 <secCmacKeyShift+0x44>
    {
      overflow = pBuf[i+1] >> (8 - shift);
   2b476:	7bbb      	ldrb	r3, [r7, #14]
   2b478:	3301      	adds	r3, #1
   2b47a:	687a      	ldr	r2, [r7, #4]
   2b47c:	4413      	add	r3, r2
   2b47e:	781b      	ldrb	r3, [r3, #0]
   2b480:	461a      	mov	r2, r3
   2b482:	78fb      	ldrb	r3, [r7, #3]
   2b484:	f1c3 0308 	rsb	r3, r3, #8
   2b488:	fa42 f303 	asr.w	r3, r2, r3
   2b48c:	73fb      	strb	r3, [r7, #15]
   2b48e:	e001      	b.n	2b494 <secCmacKeyShift+0x48>
    }
    else
    {
      overflow = 0;
   2b490:	2300      	movs	r3, #0
   2b492:	73fb      	strb	r3, [r7, #15]
    }

    /* shift byte and OR in shifted bits from previous byte */
    pBuf[i] = (pBuf[i] << shift) | overflow;
   2b494:	7bbb      	ldrb	r3, [r7, #14]
   2b496:	687a      	ldr	r2, [r7, #4]
   2b498:	4413      	add	r3, r2
   2b49a:	781b      	ldrb	r3, [r3, #0]
   2b49c:	461a      	mov	r2, r3
   2b49e:	78fb      	ldrb	r3, [r7, #3]
   2b4a0:	fa02 f303 	lsl.w	r3, r2, r3
   2b4a4:	b25a      	sxtb	r2, r3
   2b4a6:	f997 300f 	ldrsb.w	r3, [r7, #15]
   2b4aa:	4313      	orrs	r3, r2
   2b4ac:	b259      	sxtb	r1, r3
   2b4ae:	7bbb      	ldrb	r3, [r7, #14]
   2b4b0:	687a      	ldr	r2, [r7, #4]
   2b4b2:	4413      	add	r3, r2
   2b4b4:	b2ca      	uxtb	r2, r1
   2b4b6:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < SEC_CMAC_KEY_LEN; i++)
   2b4b8:	7bbb      	ldrb	r3, [r7, #14]
   2b4ba:	3301      	adds	r3, #1
   2b4bc:	73bb      	strb	r3, [r7, #14]
   2b4be:	7bbb      	ldrb	r3, [r7, #14]
   2b4c0:	2b0f      	cmp	r3, #15
   2b4c2:	d9d5      	bls.n	2b470 <secCmacKeyShift+0x24>
  }

  return finalOverflow;
   2b4c4:	7b7b      	ldrb	r3, [r7, #13]
}
   2b4c6:	4618      	mov	r0, r3
   2b4c8:	3714      	adds	r7, #20
   2b4ca:	46bd      	mov	sp, r7
   2b4cc:	f85d 7b04 	ldr.w	r7, [sp], #4
   2b4d0:	4770      	bx	lr

0002b4d2 <secCmacGenSubkey2>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void secCmacGenSubkey2(secQueueBuf_t *pBuf)
{
   2b4d2:	b580      	push	{r7, lr}
   2b4d4:	b084      	sub	sp, #16
   2b4d6:	af00      	add	r7, sp, #0
   2b4d8:	6078      	str	r0, [r7, #4]
  secCmacSecCb_t *pCmac = (secCmacSecCb_t*) pBuf->pCb;
   2b4da:	687b      	ldr	r3, [r7, #4]
   2b4dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b4de:	60fb      	str	r3, [r7, #12]
  uint8_t overflow;

  /* Copy the result of the AES oepration */
  Calc128Cpy(pCmac->subkey, pBuf->ciphertext);
   2b4e0:	68fb      	ldr	r3, [r7, #12]
   2b4e2:	f103 0214 	add.w	r2, r3, #20
   2b4e6:	687b      	ldr	r3, [r7, #4]
   2b4e8:	3310      	adds	r3, #16
   2b4ea:	4619      	mov	r1, r3
   2b4ec:	4610      	mov	r0, r2
   2b4ee:	f7f6 fb7b 	bl	21be8 <Calc128Cpy>

  /* Calculate the K1 subkey */
  overflow = secCmacKeyShift(pCmac->subkey, 1);
   2b4f2:	68fb      	ldr	r3, [r7, #12]
   2b4f4:	3314      	adds	r3, #20
   2b4f6:	2101      	movs	r1, #1
   2b4f8:	4618      	mov	r0, r3
   2b4fa:	f7ff ffa7 	bl	2b44c <secCmacKeyShift>
   2b4fe:	4603      	mov	r3, r0
   2b500:	72fb      	strb	r3, [r7, #11]

  if (overflow)
   2b502:	7afb      	ldrb	r3, [r7, #11]
   2b504:	2b00      	cmp	r3, #0
   2b506:	d009      	beq.n	2b51c <secCmacGenSubkey2+0x4a>
  {
    pCmac->subkey[SEC_BLOCK_LEN-1] ^= SEC_CMAC_RB;
   2b508:	68fb      	ldr	r3, [r7, #12]
   2b50a:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
   2b50e:	f083 0378 	eor.w	r3, r3, #120	; 0x78
   2b512:	43db      	mvns	r3, r3
   2b514:	b2da      	uxtb	r2, r3
   2b516:	68fb      	ldr	r3, [r7, #12]
   2b518:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  }

  if (pCmac->len % SEC_BLOCK_LEN != 0)
   2b51c:	68fb      	ldr	r3, [r7, #12]
   2b51e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
   2b520:	f003 030f 	and.w	r3, r3, #15
   2b524:	b29b      	uxth	r3, r3
   2b526:	2b00      	cmp	r3, #0
   2b528:	d014      	beq.n	2b554 <secCmacGenSubkey2+0x82>
  {
    /* If the message len is not a multiple of SEC_BLOCK_LEN */
    /* Continue with generation of the K2 subkey based on the K1 key */
    overflow = secCmacKeyShift(pCmac->subkey, 1);
   2b52a:	68fb      	ldr	r3, [r7, #12]
   2b52c:	3314      	adds	r3, #20
   2b52e:	2101      	movs	r1, #1
   2b530:	4618      	mov	r0, r3
   2b532:	f7ff ff8b 	bl	2b44c <secCmacKeyShift>
   2b536:	4603      	mov	r3, r0
   2b538:	72fb      	strb	r3, [r7, #11]

    if (overflow)
   2b53a:	7afb      	ldrb	r3, [r7, #11]
   2b53c:	2b00      	cmp	r3, #0
   2b53e:	d009      	beq.n	2b554 <secCmacGenSubkey2+0x82>
    {
      pCmac->subkey[SEC_BLOCK_LEN-1] ^= SEC_CMAC_RB;
   2b540:	68fb      	ldr	r3, [r7, #12]
   2b542:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
   2b546:	f083 0378 	eor.w	r3, r3, #120	; 0x78
   2b54a:	43db      	mvns	r3, r3
   2b54c:	b2da      	uxtb	r2, r3
   2b54e:	68fb      	ldr	r3, [r7, #12]
   2b550:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
    }
  }

  /* Begin CMAC calculation */
  pCmac->state = SEC_CMAC_STATE_BLOCK;
   2b554:	68fb      	ldr	r3, [r7, #12]
   2b556:	2201      	movs	r2, #1
   2b558:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  secCmacProcessBlock(pBuf);
   2b55c:	6878      	ldr	r0, [r7, #4]
   2b55e:	f7ff feeb 	bl	2b338 <secCmacProcessBlock>
}
   2b562:	bf00      	nop
   2b564:	3710      	adds	r7, #16
   2b566:	46bd      	mov	sp, r7
   2b568:	bd80      	pop	{r7, pc}

0002b56a <secCmacComplete>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void secCmacComplete(secQueueBuf_t *pBuf)
{
   2b56a:	b580      	push	{r7, lr}
   2b56c:	b084      	sub	sp, #16
   2b56e:	af00      	add	r7, sp, #0
   2b570:	6078      	str	r0, [r7, #4]
  /* CMAC is complete, copy and send result to handler */
  secCmacMsg_t *pMsg = (secCmacMsg_t *) &pBuf->msg;
   2b572:	687b      	ldr	r3, [r7, #4]
   2b574:	60fb      	str	r3, [r7, #12]
  secCmacSecCb_t *pCmac = (secCmacSecCb_t *) pBuf->pCb;
   2b576:	687b      	ldr	r3, [r7, #4]
   2b578:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b57a:	60bb      	str	r3, [r7, #8]

  pMsg->pCiphertext = pBuf->ciphertext;
   2b57c:	687b      	ldr	r3, [r7, #4]
   2b57e:	f103 0210 	add.w	r2, r3, #16
   2b582:	68fb      	ldr	r3, [r7, #12]
   2b584:	605a      	str	r2, [r3, #4]
  pMsg->pPlainText = pCmac->pPlainText;
   2b586:	68bb      	ldr	r3, [r7, #8]
   2b588:	681a      	ldr	r2, [r3, #0]
   2b58a:	68fb      	ldr	r3, [r7, #12]
   2b58c:	609a      	str	r2, [r3, #8]

  WsfMsgSend(pCmac->handlerId, pMsg);
   2b58e:	68bb      	ldr	r3, [r7, #8]
   2b590:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
   2b594:	68f9      	ldr	r1, [r7, #12]
   2b596:	4618      	mov	r0, r3
   2b598:	f001 fdad 	bl	2d0f6 <WsfMsgSend>
}
   2b59c:	bf00      	nop
   2b59e:	3710      	adds	r7, #16
   2b5a0:	46bd      	mov	sp, r7
   2b5a2:	bd80      	pop	{r7, pc}

0002b5a4 <SecCmacHciCback>:
 *
 *  \return none.
 */
/*************************************************************************************************/
void SecCmacHciCback(secQueueBuf_t *pBuf, hciEvt_t *pEvent, wsfHandlerId_t handlerId)
{
   2b5a4:	b580      	push	{r7, lr}
   2b5a6:	b086      	sub	sp, #24
   2b5a8:	af00      	add	r7, sp, #0
   2b5aa:	60f8      	str	r0, [r7, #12]
   2b5ac:	60b9      	str	r1, [r7, #8]
   2b5ae:	4613      	mov	r3, r2
   2b5b0:	71fb      	strb	r3, [r7, #7]
  secCmacSecCb_t *pCmac = (secCmacSecCb_t *) pBuf->pCb;
   2b5b2:	68fb      	ldr	r3, [r7, #12]
   2b5b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   2b5b6:	617b      	str	r3, [r7, #20]

  if (pCmac)
   2b5b8:	697b      	ldr	r3, [r7, #20]
   2b5ba:	2b00      	cmp	r3, #0
   2b5bc:	d020      	beq.n	2b600 <SecCmacHciCback+0x5c>
  {
    Calc128Cpy(pBuf->ciphertext, pEvent->leEncryptCmdCmpl.data);
   2b5be:	68fb      	ldr	r3, [r7, #12]
   2b5c0:	f103 0210 	add.w	r2, r3, #16
   2b5c4:	68bb      	ldr	r3, [r7, #8]
   2b5c6:	3305      	adds	r3, #5
   2b5c8:	4619      	mov	r1, r3
   2b5ca:	4610      	mov	r0, r2
   2b5cc:	f7f6 fb0c 	bl	21be8 <Calc128Cpy>

    switch (pCmac->state)
   2b5d0:	697b      	ldr	r3, [r7, #20]
   2b5d2:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
   2b5d6:	2b02      	cmp	r3, #2
   2b5d8:	d00e      	beq.n	2b5f8 <SecCmacHciCback+0x54>
   2b5da:	2b02      	cmp	r3, #2
   2b5dc:	dc11      	bgt.n	2b602 <SecCmacHciCback+0x5e>
   2b5de:	2b00      	cmp	r3, #0
   2b5e0:	d002      	beq.n	2b5e8 <SecCmacHciCback+0x44>
   2b5e2:	2b01      	cmp	r3, #1
   2b5e4:	d004      	beq.n	2b5f0 <SecCmacHciCback+0x4c>
    case SEC_CMAC_STATE_COMPLETE:
      secCmacComplete(pBuf);
      break;
    }
  }
}
   2b5e6:	e00c      	b.n	2b602 <SecCmacHciCback+0x5e>
      secCmacGenSubkey2(pBuf);
   2b5e8:	68f8      	ldr	r0, [r7, #12]
   2b5ea:	f7ff ff72 	bl	2b4d2 <secCmacGenSubkey2>
      break;
   2b5ee:	e008      	b.n	2b602 <SecCmacHciCback+0x5e>
      secCmacProcessBlock(pBuf);
   2b5f0:	68f8      	ldr	r0, [r7, #12]
   2b5f2:	f7ff fea1 	bl	2b338 <secCmacProcessBlock>
      break;
   2b5f6:	e004      	b.n	2b602 <SecCmacHciCback+0x5e>
      secCmacComplete(pBuf);
   2b5f8:	68f8      	ldr	r0, [r7, #12]
   2b5fa:	f7ff ffb6 	bl	2b56a <secCmacComplete>
      break;
   2b5fe:	e000      	b.n	2b602 <SecCmacHciCback+0x5e>
  }
   2b600:	bf00      	nop
}
   2b602:	bf00      	nop
   2b604:	3718      	adds	r7, #24
   2b606:	46bd      	mov	sp, r7
   2b608:	bd80      	pop	{r7, pc}
	...

0002b60c <SecCmac>:
 *  \return TRUE if successful, else FALSE.
 */
/*************************************************************************************************/
bool_t SecCmac(const uint8_t *pKey, uint8_t *pPlainText, uint16_t textLen, wsfHandlerId_t handlerId,
               uint16_t param, uint8_t event)
{
   2b60c:	b580      	push	{r7, lr}
   2b60e:	b088      	sub	sp, #32
   2b610:	af00      	add	r7, sp, #0
   2b612:	60f8      	str	r0, [r7, #12]
   2b614:	60b9      	str	r1, [r7, #8]
   2b616:	4611      	mov	r1, r2
   2b618:	461a      	mov	r2, r3
   2b61a:	460b      	mov	r3, r1
   2b61c:	80fb      	strh	r3, [r7, #6]
   2b61e:	4613      	mov	r3, r2
   2b620:	717b      	strb	r3, [r7, #5]
  secQueueBuf_t *pBuf;
  uint16_t bufSize = sizeof(secQueueBuf_t) + sizeof(secCmacSecCb_t);
   2b622:	2364      	movs	r3, #100	; 0x64
   2b624:	83fb      	strh	r3, [r7, #30]

  if ((pBuf = WsfMsgAlloc(bufSize)) != NULL)
   2b626:	8bfb      	ldrh	r3, [r7, #30]
   2b628:	4618      	mov	r0, r3
   2b62a:	f001 fd40 	bl	2d0ae <WsfMsgAlloc>
   2b62e:	61b8      	str	r0, [r7, #24]
   2b630:	69bb      	ldr	r3, [r7, #24]
   2b632:	2b00      	cmp	r3, #0
   2b634:	d036      	beq.n	2b6a4 <SecCmac+0x98>
  {
    secCmacSecCb_t *pCmacCb = (secCmacSecCb_t *) (pBuf + 1);
   2b636:	69bb      	ldr	r3, [r7, #24]
   2b638:	3338      	adds	r3, #56	; 0x38
   2b63a:	617b      	str	r3, [r7, #20]

    /* Setup queue buffer */
    pBuf->pCb = pCmacCb;
   2b63c:	69bb      	ldr	r3, [r7, #24]
   2b63e:	697a      	ldr	r2, [r7, #20]
   2b640:	631a      	str	r2, [r3, #48]	; 0x30
    pBuf->type = SEC_TYPE_CMAC;
   2b642:	69bb      	ldr	r3, [r7, #24]
   2b644:	2201      	movs	r2, #1
   2b646:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    pBuf->msg.hdr.status = secCb.token++;
   2b64a:	4b19      	ldr	r3, [pc, #100]	; (2b6b0 <SecCmac+0xa4>)
   2b64c:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   2b650:	1c5a      	adds	r2, r3, #1
   2b652:	b2d1      	uxtb	r1, r2
   2b654:	4a16      	ldr	r2, [pc, #88]	; (2b6b0 <SecCmac+0xa4>)
   2b656:	f882 1038 	strb.w	r1, [r2, #56]	; 0x38
   2b65a:	69ba      	ldr	r2, [r7, #24]
   2b65c:	70d3      	strb	r3, [r2, #3]
    pBuf->msg.hdr.param = param;
   2b65e:	69bb      	ldr	r3, [r7, #24]
   2b660:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
   2b662:	801a      	strh	r2, [r3, #0]
    pBuf->msg.hdr.event = event;
   2b664:	69bb      	ldr	r3, [r7, #24]
   2b666:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
   2b66a:	709a      	strb	r2, [r3, #2]

    pCmacCb->pPlainText = pPlainText;
   2b66c:	697b      	ldr	r3, [r7, #20]
   2b66e:	68ba      	ldr	r2, [r7, #8]
   2b670:	601a      	str	r2, [r3, #0]

    pCmacCb->len = textLen;
   2b672:	697b      	ldr	r3, [r7, #20]
   2b674:	88fa      	ldrh	r2, [r7, #6]
   2b676:	84da      	strh	r2, [r3, #38]	; 0x26
    pCmacCb->position = 0;
   2b678:	697b      	ldr	r3, [r7, #20]
   2b67a:	2200      	movs	r2, #0
   2b67c:	849a      	strh	r2, [r3, #36]	; 0x24
    pCmacCb->handlerId = handlerId;
   2b67e:	697b      	ldr	r3, [r7, #20]
   2b680:	797a      	ldrb	r2, [r7, #5]
   2b682:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
    pCmacCb->state = SEC_CMAC_STATE_SUBKEY;
   2b686:	697b      	ldr	r3, [r7, #20]
   2b688:	2200      	movs	r2, #0
   2b68a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

    /* Copy key */
    Calc128Cpy(pCmacCb->key, (uint8_t *) pKey);
   2b68e:	697b      	ldr	r3, [r7, #20]
   2b690:	3304      	adds	r3, #4
   2b692:	68f9      	ldr	r1, [r7, #12]
   2b694:	4618      	mov	r0, r3
   2b696:	f7f6 faa7 	bl	21be8 <Calc128Cpy>

    /* Start the CMAC process by calculating the subkey */
    secCmacGenSubkey1(pBuf);
   2b69a:	69b8      	ldr	r0, [r7, #24]
   2b69c:	f7ff feba 	bl	2b414 <secCmacGenSubkey1>

    return TRUE;
   2b6a0:	2301      	movs	r3, #1
   2b6a2:	e000      	b.n	2b6a6 <SecCmac+0x9a>
  }

  return FALSE;
   2b6a4:	2300      	movs	r3, #0
}
   2b6a6:	4618      	mov	r0, r3
   2b6a8:	3720      	adds	r7, #32
   2b6aa:	46bd      	mov	sp, r7
   2b6ac:	bd80      	pop	{r7, pc}
   2b6ae:	bf00      	nop
   2b6b0:	10011730 	.word	0x10011730

0002b6b4 <SecCmacInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void SecCmacInit()
{
   2b6b4:	b480      	push	{r7}
   2b6b6:	af00      	add	r7, sp, #0
  secCb.hciCbackTbl[SEC_TYPE_CMAC] = SecCmacHciCback;
   2b6b8:	4b03      	ldr	r3, [pc, #12]	; (2b6c8 <SecCmacInit+0x14>)
   2b6ba:	4a04      	ldr	r2, [pc, #16]	; (2b6cc <SecCmacInit+0x18>)
   2b6bc:	641a      	str	r2, [r3, #64]	; 0x40
}
   2b6be:	bf00      	nop
   2b6c0:	46bd      	mov	sp, r7
   2b6c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   2b6c6:	4770      	bx	lr
   2b6c8:	10011730 	.word	0x10011730
   2b6cc:	0002b5a5 	.word	0x0002b5a5

0002b6d0 <SecEccHciCback>:
 *
 *  \return none.
 */
/*************************************************************************************************/
void SecEccHciCback(secQueueBuf_t *pBuf, hciEvt_t *pEvent, wsfHandlerId_t handlerId)
{
   2b6d0:	b580      	push	{r7, lr}
   2b6d2:	b086      	sub	sp, #24
   2b6d4:	af00      	add	r7, sp, #0
   2b6d6:	60f8      	str	r0, [r7, #12]
   2b6d8:	60b9      	str	r1, [r7, #8]
   2b6da:	4613      	mov	r3, r2
   2b6dc:	71fb      	strb	r3, [r7, #7]
  secEccMsg_t *pMsg = (secEccMsg_t *) &pBuf->msg;
   2b6de:	68fb      	ldr	r3, [r7, #12]
   2b6e0:	617b      	str	r3, [r7, #20]

  if (pEvent->hdr.event == HCI_LE_READ_LOCAL_P256_PUB_KEY_CMPL_CBACK_EVT)
   2b6e2:	68bb      	ldr	r3, [r7, #8]
   2b6e4:	789b      	ldrb	r3, [r3, #2]
   2b6e6:	2b25      	cmp	r3, #37	; 0x25
   2b6e8:	d11b      	bne.n	2b722 <SecEccHciCback+0x52>
  {
    /* Reverse copy the public key (to big endian) */
    WStrReverseCpy(pMsg->data.key.pubKey_x, pEvent->leP256.key, SEC_ECC_KEY_LEN);
   2b6ea:	697b      	ldr	r3, [r7, #20]
   2b6ec:	1d18      	adds	r0, r3, #4
   2b6ee:	68bb      	ldr	r3, [r7, #8]
   2b6f0:	3305      	adds	r3, #5
   2b6f2:	2220      	movs	r2, #32
   2b6f4:	4619      	mov	r1, r3
   2b6f6:	f002 f979 	bl	2d9ec <WStrReverseCpy>
    WStrReverseCpy(pMsg->data.key.pubKey_y, pEvent->leP256.key + SEC_ECC_KEY_LEN, SEC_ECC_KEY_LEN);
   2b6fa:	697b      	ldr	r3, [r7, #20]
   2b6fc:	f103 0024 	add.w	r0, r3, #36	; 0x24
   2b700:	68bb      	ldr	r3, [r7, #8]
   2b702:	3305      	adds	r3, #5
   2b704:	3320      	adds	r3, #32
   2b706:	2220      	movs	r2, #32
   2b708:	4619      	mov	r1, r3
   2b70a:	f002 f96f 	bl	2d9ec <WStrReverseCpy>

    /* Send shared secret to handler */
    pMsg->hdr.status = pEvent->leP256.status;
   2b70e:	68bb      	ldr	r3, [r7, #8]
   2b710:	791a      	ldrb	r2, [r3, #4]
   2b712:	697b      	ldr	r3, [r7, #20]
   2b714:	70da      	strb	r2, [r3, #3]
    WsfMsgSend(handlerId, pMsg);
   2b716:	79fb      	ldrb	r3, [r7, #7]
   2b718:	6979      	ldr	r1, [r7, #20]
   2b71a:	4618      	mov	r0, r3
   2b71c:	f001 fceb 	bl	2d0f6 <WsfMsgSend>
        /* Send shared secret to handler */
        pMsg->hdr.status = pEvent->leGenDHKey.status;
    }
    WsfMsgSend(handlerId, pMsg);
  }
}
   2b720:	e01c      	b.n	2b75c <SecEccHciCback+0x8c>
  else if (pEvent->hdr.event == HCI_LE_GENERATE_DHKEY_CMPL_CBACK_EVT)
   2b722:	68bb      	ldr	r3, [r7, #8]
   2b724:	789b      	ldrb	r3, [r3, #2]
   2b726:	2b26      	cmp	r3, #38	; 0x26
   2b728:	d118      	bne.n	2b75c <SecEccHciCback+0x8c>
    if(pEvent->hdr.status == HCI_ERR_INVALID_PARAM)
   2b72a:	68bb      	ldr	r3, [r7, #8]
   2b72c:	78db      	ldrb	r3, [r3, #3]
   2b72e:	2b12      	cmp	r3, #18
   2b730:	d103      	bne.n	2b73a <SecEccHciCback+0x6a>
        pMsg->hdr.status = HCI_ERR_INVALID_PARAM;
   2b732:	697b      	ldr	r3, [r7, #20]
   2b734:	2212      	movs	r2, #18
   2b736:	70da      	strb	r2, [r3, #3]
   2b738:	e00b      	b.n	2b752 <SecEccHciCback+0x82>
        WStrReverseCpy(pMsg->data.sharedSecret.secret, pEvent->leGenDHKey.key, SEC_ECC_KEY_LEN);
   2b73a:	697b      	ldr	r3, [r7, #20]
   2b73c:	1d18      	adds	r0, r3, #4
   2b73e:	68bb      	ldr	r3, [r7, #8]
   2b740:	3305      	adds	r3, #5
   2b742:	2220      	movs	r2, #32
   2b744:	4619      	mov	r1, r3
   2b746:	f002 f951 	bl	2d9ec <WStrReverseCpy>
        pMsg->hdr.status = pEvent->leGenDHKey.status;
   2b74a:	68bb      	ldr	r3, [r7, #8]
   2b74c:	791a      	ldrb	r2, [r3, #4]
   2b74e:	697b      	ldr	r3, [r7, #20]
   2b750:	70da      	strb	r2, [r3, #3]
    WsfMsgSend(handlerId, pMsg);
   2b752:	79fb      	ldrb	r3, [r7, #7]
   2b754:	6979      	ldr	r1, [r7, #20]
   2b756:	4618      	mov	r0, r3
   2b758:	f001 fccd 	bl	2d0f6 <WsfMsgSend>
}
   2b75c:	bf00      	nop
   2b75e:	3718      	adds	r7, #24
   2b760:	46bd      	mov	sp, r7
   2b762:	bd80      	pop	{r7, pc}

0002b764 <SecEccInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void SecEccInit()
{
   2b764:	b480      	push	{r7}
   2b766:	af00      	add	r7, sp, #0
  secCb.hciCbackTbl[SEC_TYPE_DH] = SecEccHciCback;
   2b768:	4b03      	ldr	r3, [pc, #12]	; (2b778 <SecEccInit+0x14>)
   2b76a:	4a04      	ldr	r2, [pc, #16]	; (2b77c <SecEccInit+0x18>)
   2b76c:	645a      	str	r2, [r3, #68]	; 0x44
}
   2b76e:	bf00      	nop
   2b770:	46bd      	mov	sp, r7
   2b772:	f85d 7b04 	ldr.w	r7, [sp], #4
   2b776:	4770      	bx	lr
   2b778:	10011730 	.word	0x10011730
   2b77c:	0002b6d1 	.word	0x0002b6d1

0002b780 <secHciCback>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void secHciCback(hciEvt_t *pEvent)
{
   2b780:	b580      	push	{r7, lr}
   2b782:	b084      	sub	sp, #16
   2b784:	af00      	add	r7, sp, #0
   2b786:	6078      	str	r0, [r7, #4]
  secQueueBuf_t *pBuf = NULL;
   2b788:	2300      	movs	r3, #0
   2b78a:	60fb      	str	r3, [r7, #12]
  wsfHandlerId_t handlerId = 0;
   2b78c:	2300      	movs	r3, #0
   2b78e:	72fb      	strb	r3, [r7, #11]

  /* Handle random number event. */
  switch (pEvent->hdr.event)
   2b790:	687b      	ldr	r3, [r7, #4]
   2b792:	789b      	ldrb	r3, [r3, #2]
   2b794:	3b14      	subs	r3, #20
   2b796:	2b12      	cmp	r3, #18
   2b798:	f200 809d 	bhi.w	2b8d6 <secHciCback+0x156>
   2b79c:	a201      	add	r2, pc, #4	; (adr r2, 2b7a4 <secHciCback+0x24>)
   2b79e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2b7a2:	bf00      	nop
   2b7a4:	0002b889 	.word	0x0002b889
   2b7a8:	0002b8d7 	.word	0x0002b8d7
   2b7ac:	0002b8d7 	.word	0x0002b8d7
   2b7b0:	0002b8d7 	.word	0x0002b8d7
   2b7b4:	0002b8d7 	.word	0x0002b8d7
   2b7b8:	0002b8d7 	.word	0x0002b8d7
   2b7bc:	0002b8d7 	.word	0x0002b8d7
   2b7c0:	0002b829 	.word	0x0002b829
   2b7c4:	0002b7f1 	.word	0x0002b7f1
   2b7c8:	0002b8d7 	.word	0x0002b8d7
   2b7cc:	0002b8d7 	.word	0x0002b8d7
   2b7d0:	0002b8d7 	.word	0x0002b8d7
   2b7d4:	0002b8d7 	.word	0x0002b8d7
   2b7d8:	0002b8d7 	.word	0x0002b8d7
   2b7dc:	0002b8d7 	.word	0x0002b8d7
   2b7e0:	0002b8d7 	.word	0x0002b8d7
   2b7e4:	0002b8d7 	.word	0x0002b8d7
   2b7e8:	0002b863 	.word	0x0002b863
   2b7ec:	0002b873 	.word	0x0002b873
  {
  case HCI_LE_RAND_CMD_CMPL_CBACK_EVT:

    /* Copy new data to circular buffer of random data. */
    memcpy(&secCb.rand[HCI_RAND_LEN * secCb.randTop], pEvent->leRandCmdCmpl.randNum, HCI_RAND_LEN);
   2b7f0:	4b44      	ldr	r3, [pc, #272]	; (2b904 <secHciCback+0x184>)
   2b7f2:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
   2b7f6:	00db      	lsls	r3, r3, #3
   2b7f8:	4a42      	ldr	r2, [pc, #264]	; (2b904 <secHciCback+0x184>)
   2b7fa:	1898      	adds	r0, r3, r2
   2b7fc:	687b      	ldr	r3, [r7, #4]
   2b7fe:	3305      	adds	r3, #5
   2b800:	2208      	movs	r2, #8
   2b802:	4619      	mov	r1, r3
   2b804:	f7ec fd26 	bl	18254 <memcpy>
    secCb.randTop = (secCb.randTop >= SEC_HCI_RAND_MULT - 1) ? 0 : secCb.randTop + 1;
   2b808:	4b3e      	ldr	r3, [pc, #248]	; (2b904 <secHciCback+0x184>)
   2b80a:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
   2b80e:	2b02      	cmp	r3, #2
   2b810:	d805      	bhi.n	2b81e <secHciCback+0x9e>
   2b812:	4b3c      	ldr	r3, [pc, #240]	; (2b904 <secHciCback+0x184>)
   2b814:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
   2b818:	3301      	adds	r3, #1
   2b81a:	b2db      	uxtb	r3, r3
   2b81c:	e000      	b.n	2b820 <secHciCback+0xa0>
   2b81e:	2300      	movs	r3, #0
   2b820:	4a38      	ldr	r2, [pc, #224]	; (2b904 <secHciCback+0x184>)
   2b822:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39
    break;
   2b826:	e059      	b.n	2b8dc <secHciCback+0x15c>

  case HCI_LE_ENCRYPT_CMD_CMPL_CBACK_EVT:
    pBuf = WsfMsgDeq(&secCb.aesEncQueue, &handlerId);
   2b828:	f107 030b 	add.w	r3, r7, #11
   2b82c:	4619      	mov	r1, r3
   2b82e:	4836      	ldr	r0, [pc, #216]	; (2b908 <secHciCback+0x188>)
   2b830:	f001 fc8e 	bl	2d150 <WsfMsgDeq>
   2b834:	60f8      	str	r0, [r7, #12]

    WSF_ASSERT(pBuf != NULL);

    /* note: pBuf should never be NULL and is checked by assert above. */
    /* coverity[dereference] */
    if (pBuf->type == SEC_TYPE_CCM || pBuf->type == SEC_TYPE_CMAC || pBuf->type == SEC_TYPE_AES_REV)
   2b836:	68fb      	ldr	r3, [r7, #12]
   2b838:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   2b83c:	2b03      	cmp	r3, #3
   2b83e:	d009      	beq.n	2b854 <secHciCback+0xd4>
   2b840:	68fb      	ldr	r3, [r7, #12]
   2b842:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   2b846:	2b01      	cmp	r3, #1
   2b848:	d004      	beq.n	2b854 <secHciCback+0xd4>
   2b84a:	68fb      	ldr	r3, [r7, #12]
   2b84c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   2b850:	2b04      	cmp	r3, #4
   2b852:	d142      	bne.n	2b8da <secHciCback+0x15a>
    {
      WStrReverse(pEvent->leEncryptCmdCmpl.data, HCI_ENCRYPT_DATA_LEN);
   2b854:	687b      	ldr	r3, [r7, #4]
   2b856:	3305      	adds	r3, #5
   2b858:	2110      	movs	r1, #16
   2b85a:	4618      	mov	r0, r3
   2b85c:	f002 f8f0 	bl	2da40 <WStrReverse>
    }
    break;
   2b860:	e03b      	b.n	2b8da <secHciCback+0x15a>

  case HCI_LE_READ_LOCAL_P256_PUB_KEY_CMPL_CBACK_EVT:
    pBuf = WsfMsgDeq(&secCb.pubKeyQueue, &handlerId);
   2b862:	f107 030b 	add.w	r3, r7, #11
   2b866:	4619      	mov	r1, r3
   2b868:	4828      	ldr	r0, [pc, #160]	; (2b90c <secHciCback+0x18c>)
   2b86a:	f001 fc71 	bl	2d150 <WsfMsgDeq>
   2b86e:	60f8      	str	r0, [r7, #12]
    break;
   2b870:	e034      	b.n	2b8dc <secHciCback+0x15c>

  case HCI_LE_GENERATE_DHKEY_CMPL_CBACK_EVT:
    pBuf = WsfMsgDeq(&secCb.dhKeyQueue, &handlerId);
   2b872:	f107 030b 	add.w	r3, r7, #11
   2b876:	4619      	mov	r1, r3
   2b878:	4825      	ldr	r0, [pc, #148]	; (2b910 <secHciCback+0x190>)
   2b87a:	f001 fc69 	bl	2d150 <WsfMsgDeq>
   2b87e:	60f8      	str	r0, [r7, #12]
    break;
   2b880:	e02c      	b.n	2b8dc <secHciCback+0x15c>

  case HCI_HW_ERROR_CBACK_EVT:
    while ((pBuf = WsfMsgDeq(&secCb.pubKeyQueue, &handlerId)) != NULL)
    {
      WsfMsgFree(pBuf);
   2b882:	68f8      	ldr	r0, [r7, #12]
   2b884:	f001 fc2a 	bl	2d0dc <WsfMsgFree>
    while ((pBuf = WsfMsgDeq(&secCb.pubKeyQueue, &handlerId)) != NULL)
   2b888:	f107 030b 	add.w	r3, r7, #11
   2b88c:	4619      	mov	r1, r3
   2b88e:	481f      	ldr	r0, [pc, #124]	; (2b90c <secHciCback+0x18c>)
   2b890:	f001 fc5e 	bl	2d150 <WsfMsgDeq>
   2b894:	60f8      	str	r0, [r7, #12]
   2b896:	68fb      	ldr	r3, [r7, #12]
   2b898:	2b00      	cmp	r3, #0
   2b89a:	d1f2      	bne.n	2b882 <secHciCback+0x102>
    }

    while ((pBuf = WsfMsgDeq(&secCb.dhKeyQueue, &handlerId)) != NULL)
   2b89c:	e002      	b.n	2b8a4 <secHciCback+0x124>
    {
      WsfMsgFree(pBuf);
   2b89e:	68f8      	ldr	r0, [r7, #12]
   2b8a0:	f001 fc1c 	bl	2d0dc <WsfMsgFree>
    while ((pBuf = WsfMsgDeq(&secCb.dhKeyQueue, &handlerId)) != NULL)
   2b8a4:	f107 030b 	add.w	r3, r7, #11
   2b8a8:	4619      	mov	r1, r3
   2b8aa:	4819      	ldr	r0, [pc, #100]	; (2b910 <secHciCback+0x190>)
   2b8ac:	f001 fc50 	bl	2d150 <WsfMsgDeq>
   2b8b0:	60f8      	str	r0, [r7, #12]
   2b8b2:	68fb      	ldr	r3, [r7, #12]
   2b8b4:	2b00      	cmp	r3, #0
   2b8b6:	d1f2      	bne.n	2b89e <secHciCback+0x11e>
    }

    while ((pBuf = WsfMsgDeq(&secCb.aesEncQueue, &handlerId)) != NULL)
   2b8b8:	e002      	b.n	2b8c0 <secHciCback+0x140>
    {
      WsfMsgFree(pBuf);
   2b8ba:	68f8      	ldr	r0, [r7, #12]
   2b8bc:	f001 fc0e 	bl	2d0dc <WsfMsgFree>
    while ((pBuf = WsfMsgDeq(&secCb.aesEncQueue, &handlerId)) != NULL)
   2b8c0:	f107 030b 	add.w	r3, r7, #11
   2b8c4:	4619      	mov	r1, r3
   2b8c6:	4810      	ldr	r0, [pc, #64]	; (2b908 <secHciCback+0x188>)
   2b8c8:	f001 fc42 	bl	2d150 <WsfMsgDeq>
   2b8cc:	60f8      	str	r0, [r7, #12]
   2b8ce:	68fb      	ldr	r3, [r7, #12]
   2b8d0:	2b00      	cmp	r3, #0
   2b8d2:	d1f2      	bne.n	2b8ba <secHciCback+0x13a>
    }
    break;
   2b8d4:	e002      	b.n	2b8dc <secHciCback+0x15c>

  default:
    break;
   2b8d6:	bf00      	nop
   2b8d8:	e000      	b.n	2b8dc <secHciCback+0x15c>
    break;
   2b8da:	bf00      	nop
  }

  if (pBuf)
   2b8dc:	68fb      	ldr	r3, [r7, #12]
   2b8de:	2b00      	cmp	r3, #0
   2b8e0:	d00b      	beq.n	2b8fa <secHciCback+0x17a>
  {
    WSF_ASSERT(secCb.hciCbackTbl[pBuf->type]);
    secCb.hciCbackTbl[pBuf->type](pBuf, pEvent, handlerId);
   2b8e2:	68fb      	ldr	r3, [r7, #12]
   2b8e4:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
   2b8e8:	4a06      	ldr	r2, [pc, #24]	; (2b904 <secHciCback+0x184>)
   2b8ea:	330e      	adds	r3, #14
   2b8ec:	009b      	lsls	r3, r3, #2
   2b8ee:	4413      	add	r3, r2
   2b8f0:	685b      	ldr	r3, [r3, #4]
   2b8f2:	7afa      	ldrb	r2, [r7, #11]
   2b8f4:	6879      	ldr	r1, [r7, #4]
   2b8f6:	68f8      	ldr	r0, [r7, #12]
   2b8f8:	4798      	blx	r3
  }
}
   2b8fa:	bf00      	nop
   2b8fc:	3710      	adds	r7, #16
   2b8fe:	46bd      	mov	sp, r7
   2b900:	bd80      	pop	{r7, pc}
   2b902:	bf00      	nop
   2b904:	10011730 	.word	0x10011730
   2b908:	10011750 	.word	0x10011750
   2b90c:	10011758 	.word	0x10011758
   2b910:	10011760 	.word	0x10011760

0002b914 <SecInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void SecInit(void)
{
   2b914:	b580      	push	{r7, lr}
   2b916:	af00      	add	r7, sp, #0
  WSF_QUEUE_INIT(&secCb.aesEncQueue);
   2b918:	4b0d      	ldr	r3, [pc, #52]	; (2b950 <SecInit+0x3c>)
   2b91a:	2200      	movs	r2, #0
   2b91c:	621a      	str	r2, [r3, #32]
   2b91e:	4b0c      	ldr	r3, [pc, #48]	; (2b950 <SecInit+0x3c>)
   2b920:	2200      	movs	r2, #0
   2b922:	625a      	str	r2, [r3, #36]	; 0x24
  WSF_QUEUE_INIT(&secCb.pubKeyQueue);
   2b924:	4b0a      	ldr	r3, [pc, #40]	; (2b950 <SecInit+0x3c>)
   2b926:	2200      	movs	r2, #0
   2b928:	629a      	str	r2, [r3, #40]	; 0x28
   2b92a:	4b09      	ldr	r3, [pc, #36]	; (2b950 <SecInit+0x3c>)
   2b92c:	2200      	movs	r2, #0
   2b92e:	62da      	str	r2, [r3, #44]	; 0x2c
  WSF_QUEUE_INIT(&secCb.dhKeyQueue);
   2b930:	4b07      	ldr	r3, [pc, #28]	; (2b950 <SecInit+0x3c>)
   2b932:	2200      	movs	r2, #0
   2b934:	631a      	str	r2, [r3, #48]	; 0x30
   2b936:	4b06      	ldr	r3, [pc, #24]	; (2b950 <SecInit+0x3c>)
   2b938:	2200      	movs	r2, #0
   2b93a:	635a      	str	r2, [r3, #52]	; 0x34

  secCb.token = 0;
   2b93c:	4b04      	ldr	r3, [pc, #16]	; (2b950 <SecInit+0x3c>)
   2b93e:	2200      	movs	r2, #0
   2b940:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Register callback with HCI */
  HciSecRegister(secHciCback);
   2b944:	4803      	ldr	r0, [pc, #12]	; (2b954 <SecInit+0x40>)
   2b946:	f7fd fb77 	bl	29038 <HciSecRegister>
}
   2b94a:	bf00      	nop
   2b94c:	bd80      	pop	{r7, pc}
   2b94e:	bf00      	nop
   2b950:	10011730 	.word	0x10011730
   2b954:	0002b781 	.word	0x0002b781

0002b958 <SecLeEncryptCmd>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void SecLeEncryptCmd(uint8_t *pKey, uint8_t *pText, void *pBuf, wsfHandlerId_t handlerId)
{
   2b958:	b580      	push	{r7, lr}
   2b95a:	b08c      	sub	sp, #48	; 0x30
   2b95c:	af00      	add	r7, sp, #0
   2b95e:	60f8      	str	r0, [r7, #12]
   2b960:	60b9      	str	r1, [r7, #8]
   2b962:	607a      	str	r2, [r7, #4]
   2b964:	70fb      	strb	r3, [r7, #3]
  uint8_t revKey[HCI_KEY_LEN];
  uint8_t revText[HCI_ENCRYPT_DATA_LEN];

  WStrReverseCpy(revKey, pKey, HCI_KEY_LEN);
   2b966:	f107 0320 	add.w	r3, r7, #32
   2b96a:	2210      	movs	r2, #16
   2b96c:	68f9      	ldr	r1, [r7, #12]
   2b96e:	4618      	mov	r0, r3
   2b970:	f002 f83c 	bl	2d9ec <WStrReverseCpy>
  WStrReverseCpy(revText, pText, HCI_ENCRYPT_DATA_LEN);
   2b974:	f107 0310 	add.w	r3, r7, #16
   2b978:	2210      	movs	r2, #16
   2b97a:	68b9      	ldr	r1, [r7, #8]
   2b97c:	4618      	mov	r0, r3
   2b97e:	f002 f835 	bl	2d9ec <WStrReverseCpy>

  WsfMsgEnq(&secCb.aesEncQueue, handlerId, pBuf);
   2b982:	78fb      	ldrb	r3, [r7, #3]
   2b984:	687a      	ldr	r2, [r7, #4]
   2b986:	4619      	mov	r1, r3
   2b988:	4807      	ldr	r0, [pc, #28]	; (2b9a8 <SecLeEncryptCmd+0x50>)
   2b98a:	f001 fbcc 	bl	2d126 <WsfMsgEnq>
  HciLeEncryptCmd(revKey, revText);
   2b98e:	f107 0210 	add.w	r2, r7, #16
   2b992:	f107 0320 	add.w	r3, r7, #32
   2b996:	4611      	mov	r1, r2
   2b998:	4618      	mov	r0, r3
   2b99a:	f7f9 fcf9 	bl	25390 <HciLeEncryptCmd>
}
   2b99e:	bf00      	nop
   2b9a0:	3730      	adds	r7, #48	; 0x30
   2b9a2:	46bd      	mov	sp, r7
   2b9a4:	bd80      	pop	{r7, pc}
   2b9a6:	bf00      	nop
   2b9a8:	10011750 	.word	0x10011750

0002b9ac <SmpDmMsgSend>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void SmpDmMsgSend(smpDmMsg_t *pMsg)
{
   2b9ac:	b580      	push	{r7, lr}
   2b9ae:	b082      	sub	sp, #8
   2b9b0:	af00      	add	r7, sp, #0
   2b9b2:	6078      	str	r0, [r7, #4]
  WsfMsgSend(smpCb.handlerId, pMsg);
   2b9b4:	4b05      	ldr	r3, [pc, #20]	; (2b9cc <SmpDmMsgSend+0x20>)
   2b9b6:	f893 30e0 	ldrb.w	r3, [r3, #224]	; 0xe0
   2b9ba:	6879      	ldr	r1, [r7, #4]
   2b9bc:	4618      	mov	r0, r3
   2b9be:	f001 fb9a 	bl	2d0f6 <WsfMsgSend>
}
   2b9c2:	bf00      	nop
   2b9c4:	3708      	adds	r7, #8
   2b9c6:	46bd      	mov	sp, r7
   2b9c8:	bd80      	pop	{r7, pc}
   2b9ca:	bf00      	nop
   2b9cc:	10011780 	.word	0x10011780

0002b9d0 <Reset_Handler>:
Reset_Handler(void)
{
    //
    // Set the vector table pointer.
    //
    __asm("    ldr    r0, =0xE000ED08\n"
   2b9d0:	4811      	ldr	r0, [pc, #68]	; (2ba18 <zero_loop+0x12>)
   2b9d2:	4912      	ldr	r1, [pc, #72]	; (2ba1c <zero_loop+0x16>)
   2b9d4:	6001      	str	r1, [r0, #0]
          "    str    r1, [r0]");

    //
    // Set the stack pointer.
    //
    __asm("    ldr    sp, [r1]");
   2b9d6:	f8d1 d000 	ldr.w	sp, [r1]
#ifndef NOFPU
    //
    // Enable the FPU.
    //
    __asm("ldr  r0, =0xE000ED88\n"
   2b9da:	4811      	ldr	r0, [pc, #68]	; (2ba20 <zero_loop+0x1a>)
   2b9dc:	6801      	ldr	r1, [r0, #0]
   2b9de:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   2b9e2:	6001      	str	r1, [r0, #0]
   2b9e4:	f3bf 8f4f 	dsb	sy
   2b9e8:	f3bf 8f6f 	isb	sy
          "isb\n");
#endif
    //
    // Copy the data segment initializers from flash to SRAM.
    //
    __asm("    ldr     r0, =_init_data\n"
   2b9ec:	480d      	ldr	r0, [pc, #52]	; (2ba24 <zero_loop+0x1e>)
   2b9ee:	490e      	ldr	r1, [pc, #56]	; (2ba28 <zero_loop+0x22>)
   2b9f0:	4a0e      	ldr	r2, [pc, #56]	; (2ba2c <zero_loop+0x26>)

0002b9f2 <copy_loop>:
   2b9f2:	f850 3b04 	ldr.w	r3, [r0], #4
   2b9f6:	f841 3b04 	str.w	r3, [r1], #4
   2b9fa:	4291      	cmp	r1, r2
   2b9fc:	dbf9      	blt.n	2b9f2 <copy_loop>
          "        cmp     r1, r2\n"
          "        blt     copy_loop\n");
    //
    // Zero fill the bss segment.
    //
    __asm("    ldr     r0, =_sbss\n"
   2b9fe:	480c      	ldr	r0, [pc, #48]	; (2ba30 <zero_loop+0x2a>)
   2ba00:	490c      	ldr	r1, [pc, #48]	; (2ba34 <zero_loop+0x2e>)
   2ba02:	f04f 0200 	mov.w	r2, #0

0002ba06 <zero_loop>:
   2ba06:	4288      	cmp	r0, r1
   2ba08:	bfb8      	it	lt
   2ba0a:	f840 2b04 	strlt.w	r2, [r0], #4
   2ba0e:	dbfa      	blt.n	2ba06 <zero_loop>
          "        blt     zero_loop");

    //
    // Call the application's entry point.
    //
    main();
   2ba10:	f004 f9ae 	bl	2fd70 <main>

    //
    // If main returns then execute a break point instruction
    //
    __asm("    bkpt     ");
   2ba14:	be00      	bkpt	0x0000
}
   2ba16:	bf00      	nop
   2ba18:	e000ed08 	.word	0xe000ed08
   2ba1c:	00018000 	.word	0x00018000
   2ba20:	e000ed88 	.word	0xe000ed88
   2ba24:	00047094 	.word	0x00047094
   2ba28:	10002b00 	.word	0x10002b00
   2ba2c:	10003868 	.word	0x10003868
   2ba30:	10003868 	.word	0x10003868
   2ba34:	100118e4 	.word	0x100118e4

0002ba38 <NMI_Handler>:
// by a debugger.
//
//*****************************************************************************
void
NMI_Handler(void)
{
   2ba38:	b480      	push	{r7}
   2ba3a:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
   2ba3c:	e7fe      	b.n	2ba3c <NMI_Handler+0x4>

0002ba3e <BusFault_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
HardFault_Handler(void)
{
   2ba3e:	b480      	push	{r7}
   2ba40:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
   2ba42:	e7fe      	b.n	2ba42 <BusFault_Handler+0x4>

0002ba44 <DebugMon_Handler>:
// for examination by a debugger.
//
//*****************************************************************************
void
am_default_isr(void)
{
   2ba44:	b480      	push	{r7}
   2ba46:	af00      	add	r7, sp, #0
    //
    // Go into an infinite loop.
    //
    while(1)
   2ba48:	e7fe      	b.n	2ba48 <DebugMon_Handler+0x4>

0002ba4a <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
   2ba4a:	b580      	push	{r7, lr}
   2ba4c:	b08c      	sub	sp, #48	; 0x30
   2ba4e:	af04      	add	r7, sp, #16
   2ba50:	60f8      	str	r0, [r7, #12]
   2ba52:	60b9      	str	r1, [r7, #8]
   2ba54:	603b      	str	r3, [r7, #0]
   2ba56:	4613      	mov	r3, r2
   2ba58:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
   2ba5a:	88fb      	ldrh	r3, [r7, #6]
   2ba5c:	009b      	lsls	r3, r3, #2
   2ba5e:	4618      	mov	r0, r3
   2ba60:	f7fd feee 	bl	29840 <pvPortMalloc>
   2ba64:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
   2ba66:	697b      	ldr	r3, [r7, #20]
   2ba68:	2b00      	cmp	r3, #0
   2ba6a:	d00e      	beq.n	2ba8a <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
   2ba6c:	204c      	movs	r0, #76	; 0x4c
   2ba6e:	f7fd fee7 	bl	29840 <pvPortMalloc>
   2ba72:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
   2ba74:	69fb      	ldr	r3, [r7, #28]
   2ba76:	2b00      	cmp	r3, #0
   2ba78:	d003      	beq.n	2ba82 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
   2ba7a:	69fb      	ldr	r3, [r7, #28]
   2ba7c:	697a      	ldr	r2, [r7, #20]
   2ba7e:	631a      	str	r2, [r3, #48]	; 0x30
   2ba80:	e005      	b.n	2ba8e <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
   2ba82:	6978      	ldr	r0, [r7, #20]
   2ba84:	f7fd ff70 	bl	29968 <vPortFree>
   2ba88:	e001      	b.n	2ba8e <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
   2ba8a:	2300      	movs	r3, #0
   2ba8c:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
   2ba8e:	69fb      	ldr	r3, [r7, #28]
   2ba90:	2b00      	cmp	r3, #0
   2ba92:	d013      	beq.n	2babc <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
   2ba94:	88fa      	ldrh	r2, [r7, #6]
   2ba96:	2300      	movs	r3, #0
   2ba98:	9303      	str	r3, [sp, #12]
   2ba9a:	69fb      	ldr	r3, [r7, #28]
   2ba9c:	9302      	str	r3, [sp, #8]
   2ba9e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   2baa0:	9301      	str	r3, [sp, #4]
   2baa2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2baa4:	9300      	str	r3, [sp, #0]
   2baa6:	683b      	ldr	r3, [r7, #0]
   2baa8:	68b9      	ldr	r1, [r7, #8]
   2baaa:	68f8      	ldr	r0, [r7, #12]
   2baac:	f000 f80e 	bl	2bacc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
   2bab0:	69f8      	ldr	r0, [r7, #28]
   2bab2:	f000 f875 	bl	2bba0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
   2bab6:	2301      	movs	r3, #1
   2bab8:	61bb      	str	r3, [r7, #24]
   2baba:	e002      	b.n	2bac2 <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   2babc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2bac0:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
   2bac2:	69bb      	ldr	r3, [r7, #24]
	}
   2bac4:	4618      	mov	r0, r3
   2bac6:	3720      	adds	r7, #32
   2bac8:	46bd      	mov	sp, r7
   2baca:	bd80      	pop	{r7, pc}

0002bacc <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
   2bacc:	b580      	push	{r7, lr}
   2bace:	b086      	sub	sp, #24
   2bad0:	af00      	add	r7, sp, #0
   2bad2:	60f8      	str	r0, [r7, #12]
   2bad4:	60b9      	str	r1, [r7, #8]
   2bad6:	607a      	str	r2, [r7, #4]
   2bad8:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
   2bada:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2badc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   2bade:	687b      	ldr	r3, [r7, #4]
   2bae0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   2bae4:	3b01      	subs	r3, #1
   2bae6:	009b      	lsls	r3, r3, #2
   2bae8:	4413      	add	r3, r2
   2baea:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
   2baec:	693b      	ldr	r3, [r7, #16]
   2baee:	f023 0307 	bic.w	r3, r3, #7
   2baf2:	613b      	str	r3, [r7, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2baf4:	2300      	movs	r3, #0
   2baf6:	617b      	str	r3, [r7, #20]
   2baf8:	e012      	b.n	2bb20 <prvInitialiseNewTask+0x54>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   2bafa:	68ba      	ldr	r2, [r7, #8]
   2bafc:	697b      	ldr	r3, [r7, #20]
   2bafe:	4413      	add	r3, r2
   2bb00:	7819      	ldrb	r1, [r3, #0]
   2bb02:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2bb04:	697b      	ldr	r3, [r7, #20]
   2bb06:	4413      	add	r3, r2
   2bb08:	3334      	adds	r3, #52	; 0x34
   2bb0a:	460a      	mov	r2, r1
   2bb0c:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == ( char ) 0x00 )
   2bb0e:	68ba      	ldr	r2, [r7, #8]
   2bb10:	697b      	ldr	r3, [r7, #20]
   2bb12:	4413      	add	r3, r2
   2bb14:	781b      	ldrb	r3, [r3, #0]
   2bb16:	2b00      	cmp	r3, #0
   2bb18:	d006      	beq.n	2bb28 <prvInitialiseNewTask+0x5c>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2bb1a:	697b      	ldr	r3, [r7, #20]
   2bb1c:	3301      	adds	r3, #1
   2bb1e:	617b      	str	r3, [r7, #20]
   2bb20:	697b      	ldr	r3, [r7, #20]
   2bb22:	2b0f      	cmp	r3, #15
   2bb24:	d9e9      	bls.n	2bafa <prvInitialiseNewTask+0x2e>
   2bb26:	e000      	b.n	2bb2a <prvInitialiseNewTask+0x5e>
		{
			break;
   2bb28:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2bb2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb2c:	2200      	movs	r2, #0
   2bb2e:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2bb32:	6a3b      	ldr	r3, [r7, #32]
   2bb34:	2b05      	cmp	r3, #5
   2bb36:	d901      	bls.n	2bb3c <prvInitialiseNewTask+0x70>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2bb38:	2305      	movs	r3, #5
   2bb3a:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
   2bb3c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb3e:	6a3a      	ldr	r2, [r7, #32]
   2bb40:	62da      	str	r2, [r3, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   2bb42:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb44:	3304      	adds	r3, #4
   2bb46:	4618      	mov	r0, r3
   2bb48:	f7fe fcbe 	bl	2a4c8 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   2bb4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb4e:	3318      	adds	r3, #24
   2bb50:	4618      	mov	r0, r3
   2bb52:	f7fe fcb9 	bl	2a4c8 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   2bb56:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb58:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2bb5a:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2bb5c:	6a3b      	ldr	r3, [r7, #32]
   2bb5e:	f1c3 0206 	rsb	r2, r3, #6
   2bb62:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb64:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   2bb66:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb68:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2bb6a:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
   2bb6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb6e:	2200      	movs	r2, #0
   2bb70:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   2bb72:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb74:	2200      	movs	r2, #0
   2bb76:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   2bb7a:	683a      	ldr	r2, [r7, #0]
   2bb7c:	68f9      	ldr	r1, [r7, #12]
   2bb7e:	6938      	ldr	r0, [r7, #16]
   2bb80:	f7fe fd7e 	bl	2a680 <pxPortInitialiseStack>
   2bb84:	4602      	mov	r2, r0
   2bb86:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2bb88:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
   2bb8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2bb8c:	2b00      	cmp	r3, #0
   2bb8e:	d002      	beq.n	2bb96 <prvInitialiseNewTask+0xca>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   2bb90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2bb92:	6aba      	ldr	r2, [r7, #40]	; 0x28
   2bb94:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   2bb96:	bf00      	nop
   2bb98:	3718      	adds	r7, #24
   2bb9a:	46bd      	mov	sp, r7
   2bb9c:	bd80      	pop	{r7, pc}
	...

0002bba0 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
   2bba0:	b580      	push	{r7, lr}
   2bba2:	b082      	sub	sp, #8
   2bba4:	af00      	add	r7, sp, #0
   2bba6:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
   2bba8:	f7fe fe0c 	bl	2a7c4 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
   2bbac:	4b2b      	ldr	r3, [pc, #172]	; (2bc5c <prvAddNewTaskToReadyList+0xbc>)
   2bbae:	681b      	ldr	r3, [r3, #0]
   2bbb0:	3301      	adds	r3, #1
   2bbb2:	4a2a      	ldr	r2, [pc, #168]	; (2bc5c <prvAddNewTaskToReadyList+0xbc>)
   2bbb4:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   2bbb6:	4b2a      	ldr	r3, [pc, #168]	; (2bc60 <prvAddNewTaskToReadyList+0xc0>)
   2bbb8:	681b      	ldr	r3, [r3, #0]
   2bbba:	2b00      	cmp	r3, #0
   2bbbc:	d109      	bne.n	2bbd2 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
   2bbbe:	4a28      	ldr	r2, [pc, #160]	; (2bc60 <prvAddNewTaskToReadyList+0xc0>)
   2bbc0:	687b      	ldr	r3, [r7, #4]
   2bbc2:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   2bbc4:	4b25      	ldr	r3, [pc, #148]	; (2bc5c <prvAddNewTaskToReadyList+0xbc>)
   2bbc6:	681b      	ldr	r3, [r3, #0]
   2bbc8:	2b01      	cmp	r3, #1
   2bbca:	d110      	bne.n	2bbee <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
   2bbcc:	f000 fc20 	bl	2c410 <prvInitialiseTaskLists>
   2bbd0:	e00d      	b.n	2bbee <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
   2bbd2:	4b24      	ldr	r3, [pc, #144]	; (2bc64 <prvAddNewTaskToReadyList+0xc4>)
   2bbd4:	681b      	ldr	r3, [r3, #0]
   2bbd6:	2b00      	cmp	r3, #0
   2bbd8:	d109      	bne.n	2bbee <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   2bbda:	4b21      	ldr	r3, [pc, #132]	; (2bc60 <prvAddNewTaskToReadyList+0xc0>)
   2bbdc:	681b      	ldr	r3, [r3, #0]
   2bbde:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bbe0:	687b      	ldr	r3, [r7, #4]
   2bbe2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bbe4:	429a      	cmp	r2, r3
   2bbe6:	d802      	bhi.n	2bbee <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
   2bbe8:	4a1d      	ldr	r2, [pc, #116]	; (2bc60 <prvAddNewTaskToReadyList+0xc0>)
   2bbea:	687b      	ldr	r3, [r7, #4]
   2bbec:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
   2bbee:	4b1e      	ldr	r3, [pc, #120]	; (2bc68 <prvAddNewTaskToReadyList+0xc8>)
   2bbf0:	681b      	ldr	r3, [r3, #0]
   2bbf2:	3301      	adds	r3, #1
   2bbf4:	4a1c      	ldr	r2, [pc, #112]	; (2bc68 <prvAddNewTaskToReadyList+0xc8>)
   2bbf6:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
   2bbf8:	687b      	ldr	r3, [r7, #4]
   2bbfa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bbfc:	4b1b      	ldr	r3, [pc, #108]	; (2bc6c <prvAddNewTaskToReadyList+0xcc>)
   2bbfe:	681b      	ldr	r3, [r3, #0]
   2bc00:	429a      	cmp	r2, r3
   2bc02:	d903      	bls.n	2bc0c <prvAddNewTaskToReadyList+0x6c>
   2bc04:	687b      	ldr	r3, [r7, #4]
   2bc06:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bc08:	4a18      	ldr	r2, [pc, #96]	; (2bc6c <prvAddNewTaskToReadyList+0xcc>)
   2bc0a:	6013      	str	r3, [r2, #0]
   2bc0c:	687b      	ldr	r3, [r7, #4]
   2bc0e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bc10:	4613      	mov	r3, r2
   2bc12:	009b      	lsls	r3, r3, #2
   2bc14:	4413      	add	r3, r2
   2bc16:	009b      	lsls	r3, r3, #2
   2bc18:	4a15      	ldr	r2, [pc, #84]	; (2bc70 <prvAddNewTaskToReadyList+0xd0>)
   2bc1a:	441a      	add	r2, r3
   2bc1c:	687b      	ldr	r3, [r7, #4]
   2bc1e:	3304      	adds	r3, #4
   2bc20:	4619      	mov	r1, r3
   2bc22:	4610      	mov	r0, r2
   2bc24:	f7fe fc5d 	bl	2a4e2 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
   2bc28:	f7fe fde6 	bl	2a7f8 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
   2bc2c:	4b0d      	ldr	r3, [pc, #52]	; (2bc64 <prvAddNewTaskToReadyList+0xc4>)
   2bc2e:	681b      	ldr	r3, [r3, #0]
   2bc30:	2b00      	cmp	r3, #0
   2bc32:	d00e      	beq.n	2bc52 <prvAddNewTaskToReadyList+0xb2>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   2bc34:	4b0a      	ldr	r3, [pc, #40]	; (2bc60 <prvAddNewTaskToReadyList+0xc0>)
   2bc36:	681b      	ldr	r3, [r3, #0]
   2bc38:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bc3a:	687b      	ldr	r3, [r7, #4]
   2bc3c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bc3e:	429a      	cmp	r2, r3
   2bc40:	d207      	bcs.n	2bc52 <prvAddNewTaskToReadyList+0xb2>
		{
			taskYIELD_IF_USING_PREEMPTION();
   2bc42:	4b0c      	ldr	r3, [pc, #48]	; (2bc74 <prvAddNewTaskToReadyList+0xd4>)
   2bc44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2bc48:	601a      	str	r2, [r3, #0]
   2bc4a:	f3bf 8f4f 	dsb	sy
   2bc4e:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   2bc52:	bf00      	nop
   2bc54:	3708      	adds	r7, #8
   2bc56:	46bd      	mov	sp, r7
   2bc58:	bd80      	pop	{r7, pc}
   2bc5a:	bf00      	nop
   2bc5c:	100080c4 	.word	0x100080c4
   2bc60:	10007ff0 	.word	0x10007ff0
   2bc64:	100080d0 	.word	0x100080d0
   2bc68:	100080e0 	.word	0x100080e0
   2bc6c:	100080cc 	.word	0x100080cc
   2bc70:	10007ff4 	.word	0x10007ff4
   2bc74:	e000ed04 	.word	0xe000ed04

0002bc78 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   2bc78:	b580      	push	{r7, lr}
   2bc7a:	b084      	sub	sp, #16
   2bc7c:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
   2bc7e:	4b17      	ldr	r3, [pc, #92]	; (2bcdc <vTaskStartScheduler+0x64>)
   2bc80:	9301      	str	r3, [sp, #4]
   2bc82:	2300      	movs	r3, #0
   2bc84:	9300      	str	r3, [sp, #0]
   2bc86:	2300      	movs	r3, #0
   2bc88:	f44f 7280 	mov.w	r2, #256	; 0x100
   2bc8c:	4914      	ldr	r1, [pc, #80]	; (2bce0 <vTaskStartScheduler+0x68>)
   2bc8e:	4815      	ldr	r0, [pc, #84]	; (2bce4 <vTaskStartScheduler+0x6c>)
   2bc90:	f7ff fedb 	bl	2ba4a <xTaskCreate>
   2bc94:	6078      	str	r0, [r7, #4]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   2bc96:	687b      	ldr	r3, [r7, #4]
   2bc98:	2b01      	cmp	r3, #1
   2bc9a:	d102      	bne.n	2bca2 <vTaskStartScheduler+0x2a>
		{
			xReturn = xTimerCreateTimerTask();
   2bc9c:	f000 fdd8 	bl	2c850 <xTimerCreateTimerTask>
   2bca0:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   2bca2:	687b      	ldr	r3, [r7, #4]
   2bca4:	2b01      	cmp	r3, #1
   2bca6:	d115      	bne.n	2bcd4 <vTaskStartScheduler+0x5c>
	__asm volatile
   2bca8:	f04f 0360 	mov.w	r3, #96	; 0x60
   2bcac:	f383 8811 	msr	BASEPRI, r3
   2bcb0:	f3bf 8f6f 	isb	sy
   2bcb4:	f3bf 8f4f 	dsb	sy
   2bcb8:	603b      	str	r3, [r7, #0]
}
   2bcba:	bf00      	nop
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
   2bcbc:	4b0a      	ldr	r3, [pc, #40]	; (2bce8 <vTaskStartScheduler+0x70>)
   2bcbe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2bcc2:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   2bcc4:	4b09      	ldr	r3, [pc, #36]	; (2bcec <vTaskStartScheduler+0x74>)
   2bcc6:	2201      	movs	r2, #1
   2bcc8:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
   2bcca:	4b09      	ldr	r3, [pc, #36]	; (2bcf0 <vTaskStartScheduler+0x78>)
   2bccc:	2200      	movs	r2, #0
   2bcce:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   2bcd0:	f7fe fd4e 	bl	2a770 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
   2bcd4:	bf00      	nop
   2bcd6:	3708      	adds	r7, #8
   2bcd8:	46bd      	mov	sp, r7
   2bcda:	bd80      	pop	{r7, pc}
   2bcdc:	100080e8 	.word	0x100080e8
   2bce0:	000451a0 	.word	0x000451a0
   2bce4:	0002c361 	.word	0x0002c361
   2bce8:	100080e4 	.word	0x100080e4
   2bcec:	100080d0 	.word	0x100080d0
   2bcf0:	100080c8 	.word	0x100080c8

0002bcf4 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   2bcf4:	b480      	push	{r7}
   2bcf6:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   2bcf8:	4b04      	ldr	r3, [pc, #16]	; (2bd0c <vTaskSuspendAll+0x18>)
   2bcfa:	681b      	ldr	r3, [r3, #0]
   2bcfc:	3301      	adds	r3, #1
   2bcfe:	4a03      	ldr	r2, [pc, #12]	; (2bd0c <vTaskSuspendAll+0x18>)
   2bd00:	6013      	str	r3, [r2, #0]
}
   2bd02:	bf00      	nop
   2bd04:	46bd      	mov	sp, r7
   2bd06:	f85d 7b04 	ldr.w	r7, [sp], #4
   2bd0a:	4770      	bx	lr
   2bd0c:	100080ec 	.word	0x100080ec

0002bd10 <prvGetExpectedIdleTime>:
/*----------------------------------------------------------*/

#if ( configUSE_TICKLESS_IDLE != 0 )

	static TickType_t prvGetExpectedIdleTime( void )
	{
   2bd10:	b480      	push	{r7}
   2bd12:	b083      	sub	sp, #12
   2bd14:	af00      	add	r7, sp, #0
	TickType_t xReturn;
	UBaseType_t uxHigherPriorityReadyTasks = pdFALSE;
   2bd16:	2300      	movs	r3, #0
   2bd18:	603b      	str	r3, [r7, #0]
		configUSE_PREEMPTION is 0, so there may be tasks above the idle priority
		task that are in the Ready state, even though the idle task is
		running. */
		#if( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
		{
			if( uxTopReadyPriority > tskIDLE_PRIORITY )
   2bd1a:	4b14      	ldr	r3, [pc, #80]	; (2bd6c <prvGetExpectedIdleTime+0x5c>)
   2bd1c:	681b      	ldr	r3, [r3, #0]
   2bd1e:	2b00      	cmp	r3, #0
   2bd20:	d001      	beq.n	2bd26 <prvGetExpectedIdleTime+0x16>
			{
				uxHigherPriorityReadyTasks = pdTRUE;
   2bd22:	2301      	movs	r3, #1
   2bd24:	603b      	str	r3, [r7, #0]
				uxHigherPriorityReadyTasks = pdTRUE;
			}
		}
		#endif

		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   2bd26:	4b12      	ldr	r3, [pc, #72]	; (2bd70 <prvGetExpectedIdleTime+0x60>)
   2bd28:	681b      	ldr	r3, [r3, #0]
   2bd2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bd2c:	2b00      	cmp	r3, #0
   2bd2e:	d002      	beq.n	2bd36 <prvGetExpectedIdleTime+0x26>
		{
			xReturn = 0;
   2bd30:	2300      	movs	r3, #0
   2bd32:	607b      	str	r3, [r7, #4]
   2bd34:	e012      	b.n	2bd5c <prvGetExpectedIdleTime+0x4c>
		}
		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   2bd36:	4b0f      	ldr	r3, [pc, #60]	; (2bd74 <prvGetExpectedIdleTime+0x64>)
   2bd38:	681b      	ldr	r3, [r3, #0]
   2bd3a:	2b01      	cmp	r3, #1
   2bd3c:	d902      	bls.n	2bd44 <prvGetExpectedIdleTime+0x34>
		{
			/* There are other idle priority tasks in the ready state.  If
			time slicing is used then the very next tick interrupt must be
			processed. */
			xReturn = 0;
   2bd3e:	2300      	movs	r3, #0
   2bd40:	607b      	str	r3, [r7, #4]
   2bd42:	e00b      	b.n	2bd5c <prvGetExpectedIdleTime+0x4c>
		}
		else if( uxHigherPriorityReadyTasks != pdFALSE )
   2bd44:	683b      	ldr	r3, [r7, #0]
   2bd46:	2b00      	cmp	r3, #0
   2bd48:	d002      	beq.n	2bd50 <prvGetExpectedIdleTime+0x40>
		{
			/* There are tasks in the Ready state that have a priority above the
			idle priority.  This path can only be reached if
			configUSE_PREEMPTION is 0. */
			xReturn = 0;
   2bd4a:	2300      	movs	r3, #0
   2bd4c:	607b      	str	r3, [r7, #4]
   2bd4e:	e005      	b.n	2bd5c <prvGetExpectedIdleTime+0x4c>
		}
		else
		{
			xReturn = xNextTaskUnblockTime - xTickCount;
   2bd50:	4b09      	ldr	r3, [pc, #36]	; (2bd78 <prvGetExpectedIdleTime+0x68>)
   2bd52:	681a      	ldr	r2, [r3, #0]
   2bd54:	4b09      	ldr	r3, [pc, #36]	; (2bd7c <prvGetExpectedIdleTime+0x6c>)
   2bd56:	681b      	ldr	r3, [r3, #0]
   2bd58:	1ad3      	subs	r3, r2, r3
   2bd5a:	607b      	str	r3, [r7, #4]
		}

		return xReturn;
   2bd5c:	687b      	ldr	r3, [r7, #4]
	}
   2bd5e:	4618      	mov	r0, r3
   2bd60:	370c      	adds	r7, #12
   2bd62:	46bd      	mov	sp, r7
   2bd64:	f85d 7b04 	ldr.w	r7, [sp], #4
   2bd68:	4770      	bx	lr
   2bd6a:	bf00      	nop
   2bd6c:	100080cc 	.word	0x100080cc
   2bd70:	10007ff0 	.word	0x10007ff0
   2bd74:	10007ff4 	.word	0x10007ff4
   2bd78:	100080e4 	.word	0x100080e4
   2bd7c:	100080c8 	.word	0x100080c8

0002bd80 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   2bd80:	b580      	push	{r7, lr}
   2bd82:	b084      	sub	sp, #16
   2bd84:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
   2bd86:	2300      	movs	r3, #0
   2bd88:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
   2bd8a:	2300      	movs	r3, #0
   2bd8c:	60bb      	str	r3, [r7, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   2bd8e:	f7fe fd19 	bl	2a7c4 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
   2bd92:	4b39      	ldr	r3, [pc, #228]	; (2be78 <xTaskResumeAll+0xf8>)
   2bd94:	681b      	ldr	r3, [r3, #0]
   2bd96:	3b01      	subs	r3, #1
   2bd98:	4a37      	ldr	r2, [pc, #220]	; (2be78 <xTaskResumeAll+0xf8>)
   2bd9a:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2bd9c:	4b36      	ldr	r3, [pc, #216]	; (2be78 <xTaskResumeAll+0xf8>)
   2bd9e:	681b      	ldr	r3, [r3, #0]
   2bda0:	2b00      	cmp	r3, #0
   2bda2:	d162      	bne.n	2be6a <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   2bda4:	4b35      	ldr	r3, [pc, #212]	; (2be7c <xTaskResumeAll+0xfc>)
   2bda6:	681b      	ldr	r3, [r3, #0]
   2bda8:	2b00      	cmp	r3, #0
   2bdaa:	d05e      	beq.n	2be6a <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2bdac:	e02f      	b.n	2be0e <xTaskResumeAll+0x8e>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2bdae:	4b34      	ldr	r3, [pc, #208]	; (2be80 <xTaskResumeAll+0x100>)
   2bdb0:	68db      	ldr	r3, [r3, #12]
   2bdb2:	68db      	ldr	r3, [r3, #12]
   2bdb4:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2bdb6:	68fb      	ldr	r3, [r7, #12]
   2bdb8:	3318      	adds	r3, #24
   2bdba:	4618      	mov	r0, r3
   2bdbc:	f7fe fbee 	bl	2a59c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2bdc0:	68fb      	ldr	r3, [r7, #12]
   2bdc2:	3304      	adds	r3, #4
   2bdc4:	4618      	mov	r0, r3
   2bdc6:	f7fe fbe9 	bl	2a59c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   2bdca:	68fb      	ldr	r3, [r7, #12]
   2bdcc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bdce:	4b2d      	ldr	r3, [pc, #180]	; (2be84 <xTaskResumeAll+0x104>)
   2bdd0:	681b      	ldr	r3, [r3, #0]
   2bdd2:	429a      	cmp	r2, r3
   2bdd4:	d903      	bls.n	2bdde <xTaskResumeAll+0x5e>
   2bdd6:	68fb      	ldr	r3, [r7, #12]
   2bdd8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bdda:	4a2a      	ldr	r2, [pc, #168]	; (2be84 <xTaskResumeAll+0x104>)
   2bddc:	6013      	str	r3, [r2, #0]
   2bdde:	68fb      	ldr	r3, [r7, #12]
   2bde0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bde2:	4613      	mov	r3, r2
   2bde4:	009b      	lsls	r3, r3, #2
   2bde6:	4413      	add	r3, r2
   2bde8:	009b      	lsls	r3, r3, #2
   2bdea:	4a27      	ldr	r2, [pc, #156]	; (2be88 <xTaskResumeAll+0x108>)
   2bdec:	441a      	add	r2, r3
   2bdee:	68fb      	ldr	r3, [r7, #12]
   2bdf0:	3304      	adds	r3, #4
   2bdf2:	4619      	mov	r1, r3
   2bdf4:	4610      	mov	r0, r2
   2bdf6:	f7fe fb74 	bl	2a4e2 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2bdfa:	68fb      	ldr	r3, [r7, #12]
   2bdfc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bdfe:	4b23      	ldr	r3, [pc, #140]	; (2be8c <xTaskResumeAll+0x10c>)
   2be00:	681b      	ldr	r3, [r3, #0]
   2be02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2be04:	429a      	cmp	r2, r3
   2be06:	d302      	bcc.n	2be0e <xTaskResumeAll+0x8e>
					{
						xYieldPending = pdTRUE;
   2be08:	4b21      	ldr	r3, [pc, #132]	; (2be90 <xTaskResumeAll+0x110>)
   2be0a:	2201      	movs	r2, #1
   2be0c:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   2be0e:	4b1c      	ldr	r3, [pc, #112]	; (2be80 <xTaskResumeAll+0x100>)
   2be10:	681b      	ldr	r3, [r3, #0]
   2be12:	2b00      	cmp	r3, #0
   2be14:	d1cb      	bne.n	2bdae <xTaskResumeAll+0x2e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
   2be16:	68fb      	ldr	r3, [r7, #12]
   2be18:	2b00      	cmp	r3, #0
   2be1a:	d001      	beq.n	2be20 <xTaskResumeAll+0xa0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
   2be1c:	f000 fb3a 	bl	2c494 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   2be20:	4b1c      	ldr	r3, [pc, #112]	; (2be94 <xTaskResumeAll+0x114>)
   2be22:	681b      	ldr	r3, [r3, #0]
   2be24:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
   2be26:	687b      	ldr	r3, [r7, #4]
   2be28:	2b00      	cmp	r3, #0
   2be2a:	d010      	beq.n	2be4e <xTaskResumeAll+0xce>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
   2be2c:	f000 f858 	bl	2bee0 <xTaskIncrementTick>
   2be30:	4603      	mov	r3, r0
   2be32:	2b00      	cmp	r3, #0
   2be34:	d002      	beq.n	2be3c <xTaskResumeAll+0xbc>
							{
								xYieldPending = pdTRUE;
   2be36:	4b16      	ldr	r3, [pc, #88]	; (2be90 <xTaskResumeAll+0x110>)
   2be38:	2201      	movs	r2, #1
   2be3a:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
   2be3c:	687b      	ldr	r3, [r7, #4]
   2be3e:	3b01      	subs	r3, #1
   2be40:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   2be42:	687b      	ldr	r3, [r7, #4]
   2be44:	2b00      	cmp	r3, #0
   2be46:	d1f1      	bne.n	2be2c <xTaskResumeAll+0xac>

						uxPendedTicks = 0;
   2be48:	4b12      	ldr	r3, [pc, #72]	; (2be94 <xTaskResumeAll+0x114>)
   2be4a:	2200      	movs	r2, #0
   2be4c:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
   2be4e:	4b10      	ldr	r3, [pc, #64]	; (2be90 <xTaskResumeAll+0x110>)
   2be50:	681b      	ldr	r3, [r3, #0]
   2be52:	2b00      	cmp	r3, #0
   2be54:	d009      	beq.n	2be6a <xTaskResumeAll+0xea>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   2be56:	2301      	movs	r3, #1
   2be58:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   2be5a:	4b0f      	ldr	r3, [pc, #60]	; (2be98 <xTaskResumeAll+0x118>)
   2be5c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2be60:	601a      	str	r2, [r3, #0]
   2be62:	f3bf 8f4f 	dsb	sy
   2be66:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   2be6a:	f7fe fcc5 	bl	2a7f8 <vPortExitCritical>

	return xAlreadyYielded;
   2be6e:	68bb      	ldr	r3, [r7, #8]
}
   2be70:	4618      	mov	r0, r3
   2be72:	3710      	adds	r7, #16
   2be74:	46bd      	mov	sp, r7
   2be76:	bd80      	pop	{r7, pc}
   2be78:	100080ec 	.word	0x100080ec
   2be7c:	100080c4 	.word	0x100080c4
   2be80:	1000809c 	.word	0x1000809c
   2be84:	100080cc 	.word	0x100080cc
   2be88:	10007ff4 	.word	0x10007ff4
   2be8c:	10007ff0 	.word	0x10007ff0
   2be90:	100080d8 	.word	0x100080d8
   2be94:	100080d4 	.word	0x100080d4
   2be98:	e000ed04 	.word	0xe000ed04

0002be9c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   2be9c:	b480      	push	{r7}
   2be9e:	b083      	sub	sp, #12
   2bea0:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
   2bea2:	4b05      	ldr	r3, [pc, #20]	; (2beb8 <xTaskGetTickCount+0x1c>)
   2bea4:	681b      	ldr	r3, [r3, #0]
   2bea6:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
   2bea8:	687b      	ldr	r3, [r7, #4]
}
   2beaa:	4618      	mov	r0, r3
   2beac:	370c      	adds	r7, #12
   2beae:	46bd      	mov	sp, r7
   2beb0:	f85d 7b04 	ldr.w	r7, [sp], #4
   2beb4:	4770      	bx	lr
   2beb6:	bf00      	nop
   2beb8:	100080c8 	.word	0x100080c8

0002bebc <vTaskStepTick>:
implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1. */
#if ( configUSE_TICKLESS_IDLE != 0 )

	void vTaskStepTick( const TickType_t xTicksToJump )
	{
   2bebc:	b480      	push	{r7}
   2bebe:	b083      	sub	sp, #12
   2bec0:	af00      	add	r7, sp, #0
   2bec2:	6078      	str	r0, [r7, #4]
		/* Correct the tick count value after a period during which the tick
		was suppressed.  Note this does *not* call the tick hook function for
		each stepped tick. */
		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
		xTickCount += xTicksToJump;
   2bec4:	4b05      	ldr	r3, [pc, #20]	; (2bedc <vTaskStepTick+0x20>)
   2bec6:	681a      	ldr	r2, [r3, #0]
   2bec8:	687b      	ldr	r3, [r7, #4]
   2beca:	4413      	add	r3, r2
   2becc:	4a03      	ldr	r2, [pc, #12]	; (2bedc <vTaskStepTick+0x20>)
   2bece:	6013      	str	r3, [r2, #0]
		traceINCREASE_TICK_COUNT( xTicksToJump );
	}
   2bed0:	bf00      	nop
   2bed2:	370c      	adds	r7, #12
   2bed4:	46bd      	mov	sp, r7
   2bed6:	f85d 7b04 	ldr.w	r7, [sp], #4
   2beda:	4770      	bx	lr
   2bedc:	100080c8 	.word	0x100080c8

0002bee0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   2bee0:	b580      	push	{r7, lr}
   2bee2:	b086      	sub	sp, #24
   2bee4:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   2bee6:	2300      	movs	r3, #0
   2bee8:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2beea:	4b3f      	ldr	r3, [pc, #252]	; (2bfe8 <xTaskIncrementTick+0x108>)
   2beec:	681b      	ldr	r3, [r3, #0]
   2beee:	2b00      	cmp	r3, #0
   2bef0:	d169      	bne.n	2bfc6 <xTaskIncrementTick+0xe6>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   2bef2:	4b3e      	ldr	r3, [pc, #248]	; (2bfec <xTaskIncrementTick+0x10c>)
   2bef4:	681b      	ldr	r3, [r3, #0]
   2bef6:	3301      	adds	r3, #1
   2bef8:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
   2befa:	4a3c      	ldr	r2, [pc, #240]	; (2bfec <xTaskIncrementTick+0x10c>)
   2befc:	693b      	ldr	r3, [r7, #16]
   2befe:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   2bf00:	693b      	ldr	r3, [r7, #16]
   2bf02:	2b00      	cmp	r3, #0
   2bf04:	d110      	bne.n	2bf28 <xTaskIncrementTick+0x48>
		{
			taskSWITCH_DELAYED_LISTS();
   2bf06:	4b3a      	ldr	r3, [pc, #232]	; (2bff0 <xTaskIncrementTick+0x110>)
   2bf08:	681b      	ldr	r3, [r3, #0]
   2bf0a:	60fb      	str	r3, [r7, #12]
   2bf0c:	4b39      	ldr	r3, [pc, #228]	; (2bff4 <xTaskIncrementTick+0x114>)
   2bf0e:	681b      	ldr	r3, [r3, #0]
   2bf10:	4a37      	ldr	r2, [pc, #220]	; (2bff0 <xTaskIncrementTick+0x110>)
   2bf12:	6013      	str	r3, [r2, #0]
   2bf14:	4a37      	ldr	r2, [pc, #220]	; (2bff4 <xTaskIncrementTick+0x114>)
   2bf16:	68fb      	ldr	r3, [r7, #12]
   2bf18:	6013      	str	r3, [r2, #0]
   2bf1a:	4b37      	ldr	r3, [pc, #220]	; (2bff8 <xTaskIncrementTick+0x118>)
   2bf1c:	681b      	ldr	r3, [r3, #0]
   2bf1e:	3301      	adds	r3, #1
   2bf20:	4a35      	ldr	r2, [pc, #212]	; (2bff8 <xTaskIncrementTick+0x118>)
   2bf22:	6013      	str	r3, [r2, #0]
   2bf24:	f000 fab6 	bl	2c494 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
   2bf28:	4b34      	ldr	r3, [pc, #208]	; (2bffc <xTaskIncrementTick+0x11c>)
   2bf2a:	681b      	ldr	r3, [r3, #0]
   2bf2c:	693a      	ldr	r2, [r7, #16]
   2bf2e:	429a      	cmp	r2, r3
   2bf30:	d34e      	bcc.n	2bfd0 <xTaskIncrementTick+0xf0>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2bf32:	4b2f      	ldr	r3, [pc, #188]	; (2bff0 <xTaskIncrementTick+0x110>)
   2bf34:	681b      	ldr	r3, [r3, #0]
   2bf36:	681b      	ldr	r3, [r3, #0]
   2bf38:	2b00      	cmp	r3, #0
   2bf3a:	d104      	bne.n	2bf46 <xTaskIncrementTick+0x66>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2bf3c:	4b2f      	ldr	r3, [pc, #188]	; (2bffc <xTaskIncrementTick+0x11c>)
   2bf3e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2bf42:	601a      	str	r2, [r3, #0]
					break;
   2bf44:	e044      	b.n	2bfd0 <xTaskIncrementTick+0xf0>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2bf46:	4b2a      	ldr	r3, [pc, #168]	; (2bff0 <xTaskIncrementTick+0x110>)
   2bf48:	681b      	ldr	r3, [r3, #0]
   2bf4a:	68db      	ldr	r3, [r3, #12]
   2bf4c:	68db      	ldr	r3, [r3, #12]
   2bf4e:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   2bf50:	68bb      	ldr	r3, [r7, #8]
   2bf52:	685b      	ldr	r3, [r3, #4]
   2bf54:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
   2bf56:	693a      	ldr	r2, [r7, #16]
   2bf58:	687b      	ldr	r3, [r7, #4]
   2bf5a:	429a      	cmp	r2, r3
   2bf5c:	d203      	bcs.n	2bf66 <xTaskIncrementTick+0x86>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
   2bf5e:	4a27      	ldr	r2, [pc, #156]	; (2bffc <xTaskIncrementTick+0x11c>)
   2bf60:	687b      	ldr	r3, [r7, #4]
   2bf62:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
   2bf64:	e034      	b.n	2bfd0 <xTaskIncrementTick+0xf0>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2bf66:	68bb      	ldr	r3, [r7, #8]
   2bf68:	3304      	adds	r3, #4
   2bf6a:	4618      	mov	r0, r3
   2bf6c:	f7fe fb16 	bl	2a59c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   2bf70:	68bb      	ldr	r3, [r7, #8]
   2bf72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   2bf74:	2b00      	cmp	r3, #0
   2bf76:	d004      	beq.n	2bf82 <xTaskIncrementTick+0xa2>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   2bf78:	68bb      	ldr	r3, [r7, #8]
   2bf7a:	3318      	adds	r3, #24
   2bf7c:	4618      	mov	r0, r3
   2bf7e:	f7fe fb0d 	bl	2a59c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
   2bf82:	68bb      	ldr	r3, [r7, #8]
   2bf84:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bf86:	4b1e      	ldr	r3, [pc, #120]	; (2c000 <xTaskIncrementTick+0x120>)
   2bf88:	681b      	ldr	r3, [r3, #0]
   2bf8a:	429a      	cmp	r2, r3
   2bf8c:	d903      	bls.n	2bf96 <xTaskIncrementTick+0xb6>
   2bf8e:	68bb      	ldr	r3, [r7, #8]
   2bf90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bf92:	4a1b      	ldr	r2, [pc, #108]	; (2c000 <xTaskIncrementTick+0x120>)
   2bf94:	6013      	str	r3, [r2, #0]
   2bf96:	68bb      	ldr	r3, [r7, #8]
   2bf98:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bf9a:	4613      	mov	r3, r2
   2bf9c:	009b      	lsls	r3, r3, #2
   2bf9e:	4413      	add	r3, r2
   2bfa0:	009b      	lsls	r3, r3, #2
   2bfa2:	4a18      	ldr	r2, [pc, #96]	; (2c004 <xTaskIncrementTick+0x124>)
   2bfa4:	441a      	add	r2, r3
   2bfa6:	68bb      	ldr	r3, [r7, #8]
   2bfa8:	3304      	adds	r3, #4
   2bfaa:	4619      	mov	r1, r3
   2bfac:	4610      	mov	r0, r2
   2bfae:	f7fe fa98 	bl	2a4e2 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   2bfb2:	68bb      	ldr	r3, [r7, #8]
   2bfb4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2bfb6:	4b14      	ldr	r3, [pc, #80]	; (2c008 <xTaskIncrementTick+0x128>)
   2bfb8:	681b      	ldr	r3, [r3, #0]
   2bfba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2bfbc:	429a      	cmp	r2, r3
   2bfbe:	d3b8      	bcc.n	2bf32 <xTaskIncrementTick+0x52>
						{
							xSwitchRequired = pdTRUE;
   2bfc0:	2301      	movs	r3, #1
   2bfc2:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2bfc4:	e7b5      	b.n	2bf32 <xTaskIncrementTick+0x52>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   2bfc6:	4b11      	ldr	r3, [pc, #68]	; (2c00c <xTaskIncrementTick+0x12c>)
   2bfc8:	681b      	ldr	r3, [r3, #0]
   2bfca:	3301      	adds	r3, #1
   2bfcc:	4a0f      	ldr	r2, [pc, #60]	; (2c00c <xTaskIncrementTick+0x12c>)
   2bfce:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   2bfd0:	4b0f      	ldr	r3, [pc, #60]	; (2c010 <xTaskIncrementTick+0x130>)
   2bfd2:	681b      	ldr	r3, [r3, #0]
   2bfd4:	2b00      	cmp	r3, #0
   2bfd6:	d001      	beq.n	2bfdc <xTaskIncrementTick+0xfc>
		{
			xSwitchRequired = pdTRUE;
   2bfd8:	2301      	movs	r3, #1
   2bfda:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   2bfdc:	697b      	ldr	r3, [r7, #20]
}
   2bfde:	4618      	mov	r0, r3
   2bfe0:	3718      	adds	r7, #24
   2bfe2:	46bd      	mov	sp, r7
   2bfe4:	bd80      	pop	{r7, pc}
   2bfe6:	bf00      	nop
   2bfe8:	100080ec 	.word	0x100080ec
   2bfec:	100080c8 	.word	0x100080c8
   2bff0:	10008094 	.word	0x10008094
   2bff4:	10008098 	.word	0x10008098
   2bff8:	100080dc 	.word	0x100080dc
   2bffc:	100080e4 	.word	0x100080e4
   2c000:	100080cc 	.word	0x100080cc
   2c004:	10007ff4 	.word	0x10007ff4
   2c008:	10007ff0 	.word	0x10007ff0
   2c00c:	100080d4 	.word	0x100080d4
   2c010:	100080d8 	.word	0x100080d8

0002c014 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   2c014:	b480      	push	{r7}
   2c016:	b083      	sub	sp, #12
   2c018:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   2c01a:	4b21      	ldr	r3, [pc, #132]	; (2c0a0 <vTaskSwitchContext+0x8c>)
   2c01c:	681b      	ldr	r3, [r3, #0]
   2c01e:	2b00      	cmp	r3, #0
   2c020:	d003      	beq.n	2c02a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   2c022:	4b20      	ldr	r3, [pc, #128]	; (2c0a4 <vTaskSwitchContext+0x90>)
   2c024:	2201      	movs	r2, #1
   2c026:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   2c028:	e033      	b.n	2c092 <vTaskSwitchContext+0x7e>
		xYieldPending = pdFALSE;
   2c02a:	4b1e      	ldr	r3, [pc, #120]	; (2c0a4 <vTaskSwitchContext+0x90>)
   2c02c:	2200      	movs	r2, #0
   2c02e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2c030:	4b1d      	ldr	r3, [pc, #116]	; (2c0a8 <vTaskSwitchContext+0x94>)
   2c032:	681b      	ldr	r3, [r3, #0]
   2c034:	607b      	str	r3, [r7, #4]
   2c036:	e002      	b.n	2c03e <vTaskSwitchContext+0x2a>
   2c038:	687b      	ldr	r3, [r7, #4]
   2c03a:	3b01      	subs	r3, #1
   2c03c:	607b      	str	r3, [r7, #4]
   2c03e:	491b      	ldr	r1, [pc, #108]	; (2c0ac <vTaskSwitchContext+0x98>)
   2c040:	687a      	ldr	r2, [r7, #4]
   2c042:	4613      	mov	r3, r2
   2c044:	009b      	lsls	r3, r3, #2
   2c046:	4413      	add	r3, r2
   2c048:	009b      	lsls	r3, r3, #2
   2c04a:	440b      	add	r3, r1
   2c04c:	681b      	ldr	r3, [r3, #0]
   2c04e:	2b00      	cmp	r3, #0
   2c050:	d0f2      	beq.n	2c038 <vTaskSwitchContext+0x24>
   2c052:	687a      	ldr	r2, [r7, #4]
   2c054:	4613      	mov	r3, r2
   2c056:	009b      	lsls	r3, r3, #2
   2c058:	4413      	add	r3, r2
   2c05a:	009b      	lsls	r3, r3, #2
   2c05c:	4a13      	ldr	r2, [pc, #76]	; (2c0ac <vTaskSwitchContext+0x98>)
   2c05e:	4413      	add	r3, r2
   2c060:	603b      	str	r3, [r7, #0]
   2c062:	683b      	ldr	r3, [r7, #0]
   2c064:	685b      	ldr	r3, [r3, #4]
   2c066:	685a      	ldr	r2, [r3, #4]
   2c068:	683b      	ldr	r3, [r7, #0]
   2c06a:	605a      	str	r2, [r3, #4]
   2c06c:	683b      	ldr	r3, [r7, #0]
   2c06e:	685a      	ldr	r2, [r3, #4]
   2c070:	683b      	ldr	r3, [r7, #0]
   2c072:	3308      	adds	r3, #8
   2c074:	429a      	cmp	r2, r3
   2c076:	d104      	bne.n	2c082 <vTaskSwitchContext+0x6e>
   2c078:	683b      	ldr	r3, [r7, #0]
   2c07a:	685b      	ldr	r3, [r3, #4]
   2c07c:	685a      	ldr	r2, [r3, #4]
   2c07e:	683b      	ldr	r3, [r7, #0]
   2c080:	605a      	str	r2, [r3, #4]
   2c082:	683b      	ldr	r3, [r7, #0]
   2c084:	685b      	ldr	r3, [r3, #4]
   2c086:	68db      	ldr	r3, [r3, #12]
   2c088:	4a09      	ldr	r2, [pc, #36]	; (2c0b0 <vTaskSwitchContext+0x9c>)
   2c08a:	6013      	str	r3, [r2, #0]
   2c08c:	4a06      	ldr	r2, [pc, #24]	; (2c0a8 <vTaskSwitchContext+0x94>)
   2c08e:	687b      	ldr	r3, [r7, #4]
   2c090:	6013      	str	r3, [r2, #0]
}
   2c092:	bf00      	nop
   2c094:	370c      	adds	r7, #12
   2c096:	46bd      	mov	sp, r7
   2c098:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c09c:	4770      	bx	lr
   2c09e:	bf00      	nop
   2c0a0:	100080ec 	.word	0x100080ec
   2c0a4:	100080d8 	.word	0x100080d8
   2c0a8:	100080cc 	.word	0x100080cc
   2c0ac:	10007ff4 	.word	0x10007ff4
   2c0b0:	10007ff0 	.word	0x10007ff0

0002c0b4 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   2c0b4:	b580      	push	{r7, lr}
   2c0b6:	b082      	sub	sp, #8
   2c0b8:	af00      	add	r7, sp, #0
   2c0ba:	6078      	str	r0, [r7, #4]
   2c0bc:	6039      	str	r1, [r7, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2c0be:	4b07      	ldr	r3, [pc, #28]	; (2c0dc <vTaskPlaceOnEventList+0x28>)
   2c0c0:	681b      	ldr	r3, [r3, #0]
   2c0c2:	3318      	adds	r3, #24
   2c0c4:	4619      	mov	r1, r3
   2c0c6:	6878      	ldr	r0, [r7, #4]
   2c0c8:	f7fe fa2f 	bl	2a52a <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2c0cc:	2101      	movs	r1, #1
   2c0ce:	6838      	ldr	r0, [r7, #0]
   2c0d0:	f000 fb6a 	bl	2c7a8 <prvAddCurrentTaskToDelayedList>
}
   2c0d4:	bf00      	nop
   2c0d6:	3708      	adds	r7, #8
   2c0d8:	46bd      	mov	sp, r7
   2c0da:	bd80      	pop	{r7, pc}
   2c0dc:	10007ff0 	.word	0x10007ff0

0002c0e0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
   2c0e0:	b580      	push	{r7, lr}
   2c0e2:	b084      	sub	sp, #16
   2c0e4:	af00      	add	r7, sp, #0
   2c0e6:	60f8      	str	r0, [r7, #12]
   2c0e8:	60b9      	str	r1, [r7, #8]
   2c0ea:	607a      	str	r2, [r7, #4]
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2c0ec:	4b0a      	ldr	r3, [pc, #40]	; (2c118 <vTaskPlaceOnUnorderedEventList+0x38>)
   2c0ee:	681b      	ldr	r3, [r3, #0]
   2c0f0:	68ba      	ldr	r2, [r7, #8]
   2c0f2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   2c0f6:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2c0f8:	4b07      	ldr	r3, [pc, #28]	; (2c118 <vTaskPlaceOnUnorderedEventList+0x38>)
   2c0fa:	681b      	ldr	r3, [r3, #0]
   2c0fc:	3318      	adds	r3, #24
   2c0fe:	4619      	mov	r1, r3
   2c100:	68f8      	ldr	r0, [r7, #12]
   2c102:	f7fe f9ee 	bl	2a4e2 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   2c106:	2101      	movs	r1, #1
   2c108:	6878      	ldr	r0, [r7, #4]
   2c10a:	f000 fb4d 	bl	2c7a8 <prvAddCurrentTaskToDelayedList>
}
   2c10e:	bf00      	nop
   2c110:	3710      	adds	r7, #16
   2c112:	46bd      	mov	sp, r7
   2c114:	bd80      	pop	{r7, pc}
   2c116:	bf00      	nop
   2c118:	10007ff0 	.word	0x10007ff0

0002c11c <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   2c11c:	b580      	push	{r7, lr}
   2c11e:	b084      	sub	sp, #16
   2c120:	af00      	add	r7, sp, #0
   2c122:	60f8      	str	r0, [r7, #12]
   2c124:	60b9      	str	r1, [r7, #8]
   2c126:	607a      	str	r2, [r7, #4]

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   2c128:	4b0a      	ldr	r3, [pc, #40]	; (2c154 <vTaskPlaceOnEventListRestricted+0x38>)
   2c12a:	681b      	ldr	r3, [r3, #0]
   2c12c:	3318      	adds	r3, #24
   2c12e:	4619      	mov	r1, r3
   2c130:	68f8      	ldr	r0, [r7, #12]
   2c132:	f7fe f9d6 	bl	2a4e2 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
   2c136:	687b      	ldr	r3, [r7, #4]
   2c138:	2b00      	cmp	r3, #0
   2c13a:	d002      	beq.n	2c142 <vTaskPlaceOnEventListRestricted+0x26>
		{
			xTicksToWait = portMAX_DELAY;
   2c13c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2c140:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   2c142:	6879      	ldr	r1, [r7, #4]
   2c144:	68b8      	ldr	r0, [r7, #8]
   2c146:	f000 fb2f 	bl	2c7a8 <prvAddCurrentTaskToDelayedList>
	}
   2c14a:	bf00      	nop
   2c14c:	3710      	adds	r7, #16
   2c14e:	46bd      	mov	sp, r7
   2c150:	bd80      	pop	{r7, pc}
   2c152:	bf00      	nop
   2c154:	10007ff0 	.word	0x10007ff0

0002c158 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   2c158:	b580      	push	{r7, lr}
   2c15a:	b084      	sub	sp, #16
   2c15c:	af00      	add	r7, sp, #0
   2c15e:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2c160:	687b      	ldr	r3, [r7, #4]
   2c162:	68db      	ldr	r3, [r3, #12]
   2c164:	68db      	ldr	r3, [r3, #12]
   2c166:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   2c168:	68bb      	ldr	r3, [r7, #8]
   2c16a:	3318      	adds	r3, #24
   2c16c:	4618      	mov	r0, r3
   2c16e:	f7fe fa15 	bl	2a59c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2c172:	4b1f      	ldr	r3, [pc, #124]	; (2c1f0 <xTaskRemoveFromEventList+0x98>)
   2c174:	681b      	ldr	r3, [r3, #0]
   2c176:	2b00      	cmp	r3, #0
   2c178:	d11d      	bne.n	2c1b6 <xTaskRemoveFromEventList+0x5e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   2c17a:	68bb      	ldr	r3, [r7, #8]
   2c17c:	3304      	adds	r3, #4
   2c17e:	4618      	mov	r0, r3
   2c180:	f7fe fa0c 	bl	2a59c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
   2c184:	68bb      	ldr	r3, [r7, #8]
   2c186:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c188:	4b1a      	ldr	r3, [pc, #104]	; (2c1f4 <xTaskRemoveFromEventList+0x9c>)
   2c18a:	681b      	ldr	r3, [r3, #0]
   2c18c:	429a      	cmp	r2, r3
   2c18e:	d903      	bls.n	2c198 <xTaskRemoveFromEventList+0x40>
   2c190:	68bb      	ldr	r3, [r7, #8]
   2c192:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c194:	4a17      	ldr	r2, [pc, #92]	; (2c1f4 <xTaskRemoveFromEventList+0x9c>)
   2c196:	6013      	str	r3, [r2, #0]
   2c198:	68bb      	ldr	r3, [r7, #8]
   2c19a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c19c:	4613      	mov	r3, r2
   2c19e:	009b      	lsls	r3, r3, #2
   2c1a0:	4413      	add	r3, r2
   2c1a2:	009b      	lsls	r3, r3, #2
   2c1a4:	4a14      	ldr	r2, [pc, #80]	; (2c1f8 <xTaskRemoveFromEventList+0xa0>)
   2c1a6:	441a      	add	r2, r3
   2c1a8:	68bb      	ldr	r3, [r7, #8]
   2c1aa:	3304      	adds	r3, #4
   2c1ac:	4619      	mov	r1, r3
   2c1ae:	4610      	mov	r0, r2
   2c1b0:	f7fe f997 	bl	2a4e2 <vListInsertEnd>
   2c1b4:	e005      	b.n	2c1c2 <xTaskRemoveFromEventList+0x6a>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   2c1b6:	68bb      	ldr	r3, [r7, #8]
   2c1b8:	3318      	adds	r3, #24
   2c1ba:	4619      	mov	r1, r3
   2c1bc:	480f      	ldr	r0, [pc, #60]	; (2c1fc <xTaskRemoveFromEventList+0xa4>)
   2c1be:	f7fe f990 	bl	2a4e2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2c1c2:	68bb      	ldr	r3, [r7, #8]
   2c1c4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c1c6:	4b0e      	ldr	r3, [pc, #56]	; (2c200 <xTaskRemoveFromEventList+0xa8>)
   2c1c8:	681b      	ldr	r3, [r3, #0]
   2c1ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c1cc:	429a      	cmp	r2, r3
   2c1ce:	d905      	bls.n	2c1dc <xTaskRemoveFromEventList+0x84>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   2c1d0:	2301      	movs	r3, #1
   2c1d2:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   2c1d4:	4b0b      	ldr	r3, [pc, #44]	; (2c204 <xTaskRemoveFromEventList+0xac>)
   2c1d6:	2201      	movs	r2, #1
   2c1d8:	601a      	str	r2, [r3, #0]
   2c1da:	e001      	b.n	2c1e0 <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		xReturn = pdFALSE;
   2c1dc:	2300      	movs	r3, #0
   2c1de:	60fb      	str	r3, [r7, #12]
		normally left unchanged, because it is automatically reset to a new
		value when the tick count equals xNextTaskUnblockTime.  However if
		tickless idling is used it might be more important to enter sleep mode
		at the earliest possible time - so reset xNextTaskUnblockTime here to
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
   2c1e0:	f000 f958 	bl	2c494 <prvResetNextTaskUnblockTime>
	}
	#endif

	return xReturn;
   2c1e4:	68fb      	ldr	r3, [r7, #12]
}
   2c1e6:	4618      	mov	r0, r3
   2c1e8:	3710      	adds	r7, #16
   2c1ea:	46bd      	mov	sp, r7
   2c1ec:	bd80      	pop	{r7, pc}
   2c1ee:	bf00      	nop
   2c1f0:	100080ec 	.word	0x100080ec
   2c1f4:	100080cc 	.word	0x100080cc
   2c1f8:	10007ff4 	.word	0x10007ff4
   2c1fc:	1000809c 	.word	0x1000809c
   2c200:	10007ff0 	.word	0x10007ff0
   2c204:	100080d8 	.word	0x100080d8

0002c208 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
   2c208:	b580      	push	{r7, lr}
   2c20a:	b084      	sub	sp, #16
   2c20c:	af00      	add	r7, sp, #0
   2c20e:	6078      	str	r0, [r7, #4]
   2c210:	6039      	str	r1, [r7, #0]
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   2c212:	683b      	ldr	r3, [r7, #0]
   2c214:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
   2c218:	687b      	ldr	r3, [r7, #4]
   2c21a:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2c21c:	687b      	ldr	r3, [r7, #4]
   2c21e:	68db      	ldr	r3, [r3, #12]
   2c220:	60fb      	str	r3, [r7, #12]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
   2c222:	6878      	ldr	r0, [r7, #4]
   2c224:	f7fe f9ba 	bl	2a59c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   2c228:	68fb      	ldr	r3, [r7, #12]
   2c22a:	3304      	adds	r3, #4
   2c22c:	4618      	mov	r0, r3
   2c22e:	f7fe f9b5 	bl	2a59c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
   2c232:	68fb      	ldr	r3, [r7, #12]
   2c234:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c236:	4b12      	ldr	r3, [pc, #72]	; (2c280 <vTaskRemoveFromUnorderedEventList+0x78>)
   2c238:	681b      	ldr	r3, [r3, #0]
   2c23a:	429a      	cmp	r2, r3
   2c23c:	d903      	bls.n	2c246 <vTaskRemoveFromUnorderedEventList+0x3e>
   2c23e:	68fb      	ldr	r3, [r7, #12]
   2c240:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c242:	4a0f      	ldr	r2, [pc, #60]	; (2c280 <vTaskRemoveFromUnorderedEventList+0x78>)
   2c244:	6013      	str	r3, [r2, #0]
   2c246:	68fb      	ldr	r3, [r7, #12]
   2c248:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c24a:	4613      	mov	r3, r2
   2c24c:	009b      	lsls	r3, r3, #2
   2c24e:	4413      	add	r3, r2
   2c250:	009b      	lsls	r3, r3, #2
   2c252:	4a0c      	ldr	r2, [pc, #48]	; (2c284 <vTaskRemoveFromUnorderedEventList+0x7c>)
   2c254:	441a      	add	r2, r3
   2c256:	68fb      	ldr	r3, [r7, #12]
   2c258:	3304      	adds	r3, #4
   2c25a:	4619      	mov	r1, r3
   2c25c:	4610      	mov	r0, r2
   2c25e:	f7fe f940 	bl	2a4e2 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   2c262:	68fb      	ldr	r3, [r7, #12]
   2c264:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c266:	4b08      	ldr	r3, [pc, #32]	; (2c288 <vTaskRemoveFromUnorderedEventList+0x80>)
   2c268:	681b      	ldr	r3, [r3, #0]
   2c26a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c26c:	429a      	cmp	r2, r3
   2c26e:	d902      	bls.n	2c276 <vTaskRemoveFromUnorderedEventList+0x6e>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
   2c270:	4b06      	ldr	r3, [pc, #24]	; (2c28c <vTaskRemoveFromUnorderedEventList+0x84>)
   2c272:	2201      	movs	r2, #1
   2c274:	601a      	str	r2, [r3, #0]
	}
}
   2c276:	bf00      	nop
   2c278:	3710      	adds	r7, #16
   2c27a:	46bd      	mov	sp, r7
   2c27c:	bd80      	pop	{r7, pc}
   2c27e:	bf00      	nop
   2c280:	100080cc 	.word	0x100080cc
   2c284:	10007ff4 	.word	0x10007ff4
   2c288:	10007ff0 	.word	0x10007ff0
   2c28c:	100080d8 	.word	0x100080d8

0002c290 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   2c290:	b480      	push	{r7}
   2c292:	b083      	sub	sp, #12
   2c294:	af00      	add	r7, sp, #0
   2c296:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   2c298:	4b06      	ldr	r3, [pc, #24]	; (2c2b4 <vTaskInternalSetTimeOutState+0x24>)
   2c29a:	681a      	ldr	r2, [r3, #0]
   2c29c:	687b      	ldr	r3, [r7, #4]
   2c29e:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   2c2a0:	4b05      	ldr	r3, [pc, #20]	; (2c2b8 <vTaskInternalSetTimeOutState+0x28>)
   2c2a2:	681a      	ldr	r2, [r3, #0]
   2c2a4:	687b      	ldr	r3, [r7, #4]
   2c2a6:	605a      	str	r2, [r3, #4]
}
   2c2a8:	bf00      	nop
   2c2aa:	370c      	adds	r7, #12
   2c2ac:	46bd      	mov	sp, r7
   2c2ae:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c2b2:	4770      	bx	lr
   2c2b4:	100080dc 	.word	0x100080dc
   2c2b8:	100080c8 	.word	0x100080c8

0002c2bc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   2c2bc:	b580      	push	{r7, lr}
   2c2be:	b086      	sub	sp, #24
   2c2c0:	af00      	add	r7, sp, #0
   2c2c2:	6078      	str	r0, [r7, #4]
   2c2c4:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
   2c2c6:	f7fe fa7d 	bl	2a7c4 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   2c2ca:	4b1d      	ldr	r3, [pc, #116]	; (2c340 <xTaskCheckForTimeOut+0x84>)
   2c2cc:	681b      	ldr	r3, [r3, #0]
   2c2ce:	613b      	str	r3, [r7, #16]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   2c2d0:	687b      	ldr	r3, [r7, #4]
   2c2d2:	685b      	ldr	r3, [r3, #4]
   2c2d4:	693a      	ldr	r2, [r7, #16]
   2c2d6:	1ad3      	subs	r3, r2, r3
   2c2d8:	60fb      	str	r3, [r7, #12]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
   2c2da:	683b      	ldr	r3, [r7, #0]
   2c2dc:	681b      	ldr	r3, [r3, #0]
   2c2de:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2c2e2:	d102      	bne.n	2c2ea <xTaskCheckForTimeOut+0x2e>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
   2c2e4:	2300      	movs	r3, #0
   2c2e6:	617b      	str	r3, [r7, #20]
   2c2e8:	e023      	b.n	2c332 <xTaskCheckForTimeOut+0x76>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   2c2ea:	687b      	ldr	r3, [r7, #4]
   2c2ec:	681a      	ldr	r2, [r3, #0]
   2c2ee:	4b15      	ldr	r3, [pc, #84]	; (2c344 <xTaskCheckForTimeOut+0x88>)
   2c2f0:	681b      	ldr	r3, [r3, #0]
   2c2f2:	429a      	cmp	r2, r3
   2c2f4:	d007      	beq.n	2c306 <xTaskCheckForTimeOut+0x4a>
   2c2f6:	687b      	ldr	r3, [r7, #4]
   2c2f8:	685b      	ldr	r3, [r3, #4]
   2c2fa:	693a      	ldr	r2, [r7, #16]
   2c2fc:	429a      	cmp	r2, r3
   2c2fe:	d302      	bcc.n	2c306 <xTaskCheckForTimeOut+0x4a>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
   2c300:	2301      	movs	r3, #1
   2c302:	617b      	str	r3, [r7, #20]
   2c304:	e015      	b.n	2c332 <xTaskCheckForTimeOut+0x76>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   2c306:	683b      	ldr	r3, [r7, #0]
   2c308:	681b      	ldr	r3, [r3, #0]
   2c30a:	68fa      	ldr	r2, [r7, #12]
   2c30c:	429a      	cmp	r2, r3
   2c30e:	d20b      	bcs.n	2c328 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
   2c310:	683b      	ldr	r3, [r7, #0]
   2c312:	681a      	ldr	r2, [r3, #0]
   2c314:	68fb      	ldr	r3, [r7, #12]
   2c316:	1ad2      	subs	r2, r2, r3
   2c318:	683b      	ldr	r3, [r7, #0]
   2c31a:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   2c31c:	6878      	ldr	r0, [r7, #4]
   2c31e:	f7ff ffb7 	bl	2c290 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
   2c322:	2300      	movs	r3, #0
   2c324:	617b      	str	r3, [r7, #20]
   2c326:	e004      	b.n	2c332 <xTaskCheckForTimeOut+0x76>
		}
		else
		{
			*pxTicksToWait = 0;
   2c328:	683b      	ldr	r3, [r7, #0]
   2c32a:	2200      	movs	r2, #0
   2c32c:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
   2c32e:	2301      	movs	r3, #1
   2c330:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
   2c332:	f7fe fa61 	bl	2a7f8 <vPortExitCritical>

	return xReturn;
   2c336:	697b      	ldr	r3, [r7, #20]
}
   2c338:	4618      	mov	r0, r3
   2c33a:	3718      	adds	r7, #24
   2c33c:	46bd      	mov	sp, r7
   2c33e:	bd80      	pop	{r7, pc}
   2c340:	100080c8 	.word	0x100080c8
   2c344:	100080dc 	.word	0x100080dc

0002c348 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   2c348:	b480      	push	{r7}
   2c34a:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   2c34c:	4b03      	ldr	r3, [pc, #12]	; (2c35c <vTaskMissedYield+0x14>)
   2c34e:	2201      	movs	r2, #1
   2c350:	601a      	str	r2, [r3, #0]
}
   2c352:	bf00      	nop
   2c354:	46bd      	mov	sp, r7
   2c356:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c35a:	4770      	bx	lr
   2c35c:	100080d8 	.word	0x100080d8

0002c360 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   2c360:	b580      	push	{r7, lr}
   2c362:	b084      	sub	sp, #16
   2c364:	af00      	add	r7, sp, #0
   2c366:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
   2c368:	f000 f88c 	bl	2c484 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   2c36c:	4b0f      	ldr	r3, [pc, #60]	; (2c3ac <prvIdleTask+0x4c>)
   2c36e:	681b      	ldr	r3, [r3, #0]
   2c370:	2b01      	cmp	r3, #1
   2c372:	d907      	bls.n	2c384 <prvIdleTask+0x24>
			{
				taskYIELD();
   2c374:	4b0e      	ldr	r3, [pc, #56]	; (2c3b0 <prvIdleTask+0x50>)
   2c376:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2c37a:	601a      	str	r2, [r3, #0]
   2c37c:	f3bf 8f4f 	dsb	sy
   2c380:	f3bf 8f6f 	isb	sy
			/* It is not desirable to suspend then resume the scheduler on
			each iteration of the idle task.  Therefore, a preliminary
			test of the expected idle time is performed without the
			scheduler suspended.  The result here is not necessarily
			valid. */
			xExpectedIdleTime = prvGetExpectedIdleTime();
   2c384:	f7ff fcc4 	bl	2bd10 <prvGetExpectedIdleTime>
   2c388:	60f8      	str	r0, [r7, #12]

			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2c38a:	68fb      	ldr	r3, [r7, #12]
   2c38c:	2b01      	cmp	r3, #1
   2c38e:	d9eb      	bls.n	2c368 <prvIdleTask+0x8>
			{
				vTaskSuspendAll();
   2c390:	f7ff fcb0 	bl	2bcf4 <vTaskSuspendAll>
				{
					/* Now the scheduler is suspended, the expected idle
					time can be sampled again, and this time its value can
					be used. */
					configASSERT( xNextTaskUnblockTime >= xTickCount );
					xExpectedIdleTime = prvGetExpectedIdleTime();
   2c394:	f7ff fcbc 	bl	2bd10 <prvGetExpectedIdleTime>
   2c398:	60f8      	str	r0, [r7, #12]
					/* Define the following macro to set xExpectedIdleTime to 0
					if the application does not want
					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );

					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2c39a:	68fb      	ldr	r3, [r7, #12]
   2c39c:	2b01      	cmp	r3, #1
   2c39e:	d902      	bls.n	2c3a6 <prvIdleTask+0x46>
					{
						traceLOW_POWER_IDLE_BEGIN();
						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2c3a0:	68f8      	ldr	r0, [r7, #12]
   2c3a2:	f7fe faa5 	bl	2a8f0 <vPortSuppressTicksAndSleep>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}
				( void ) xTaskResumeAll();
   2c3a6:	f7ff fceb 	bl	2bd80 <xTaskResumeAll>
		prvCheckTasksWaitingTermination();
   2c3aa:	e7dd      	b.n	2c368 <prvIdleTask+0x8>
   2c3ac:	10007ff4 	.word	0x10007ff4
   2c3b0:	e000ed04 	.word	0xe000ed04

0002c3b4 <eTaskConfirmSleepModeStatus>:
/*-----------------------------------------------------------*/

#if( configUSE_TICKLESS_IDLE != 0 )

	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
	{
   2c3b4:	b480      	push	{r7}
   2c3b6:	b083      	sub	sp, #12
   2c3b8:	af00      	add	r7, sp, #0
	/* The idle task exists in addition to the application tasks. */
	const UBaseType_t uxNonApplicationTasks = 1;
   2c3ba:	2301      	movs	r3, #1
   2c3bc:	603b      	str	r3, [r7, #0]
	eSleepModeStatus eReturn = eStandardSleep;
   2c3be:	2301      	movs	r3, #1
   2c3c0:	71fb      	strb	r3, [r7, #7]

		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2c3c2:	4b0f      	ldr	r3, [pc, #60]	; (2c400 <eTaskConfirmSleepModeStatus+0x4c>)
   2c3c4:	681b      	ldr	r3, [r3, #0]
   2c3c6:	2b00      	cmp	r3, #0
   2c3c8:	d002      	beq.n	2c3d0 <eTaskConfirmSleepModeStatus+0x1c>
		{
			/* A task was made ready while the scheduler was suspended. */
			eReturn = eAbortSleep;
   2c3ca:	2300      	movs	r3, #0
   2c3cc:	71fb      	strb	r3, [r7, #7]
   2c3ce:	e010      	b.n	2c3f2 <eTaskConfirmSleepModeStatus+0x3e>
		}
		else if( xYieldPending != pdFALSE )
   2c3d0:	4b0c      	ldr	r3, [pc, #48]	; (2c404 <eTaskConfirmSleepModeStatus+0x50>)
   2c3d2:	681b      	ldr	r3, [r3, #0]
   2c3d4:	2b00      	cmp	r3, #0
   2c3d6:	d002      	beq.n	2c3de <eTaskConfirmSleepModeStatus+0x2a>
		{
			/* A yield was pended while the scheduler was suspended. */
			eReturn = eAbortSleep;
   2c3d8:	2300      	movs	r3, #0
   2c3da:	71fb      	strb	r3, [r7, #7]
   2c3dc:	e009      	b.n	2c3f2 <eTaskConfirmSleepModeStatus+0x3e>
		{
			/* If all the tasks are in the suspended list (which might mean they
			have an infinite block time rather than actually being suspended)
			then it is safe to turn all clocks off and just wait for external
			interrupts. */
			if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2c3de:	4b0a      	ldr	r3, [pc, #40]	; (2c408 <eTaskConfirmSleepModeStatus+0x54>)
   2c3e0:	681a      	ldr	r2, [r3, #0]
   2c3e2:	4b0a      	ldr	r3, [pc, #40]	; (2c40c <eTaskConfirmSleepModeStatus+0x58>)
   2c3e4:	6819      	ldr	r1, [r3, #0]
   2c3e6:	683b      	ldr	r3, [r7, #0]
   2c3e8:	1acb      	subs	r3, r1, r3
   2c3ea:	429a      	cmp	r2, r3
   2c3ec:	d101      	bne.n	2c3f2 <eTaskConfirmSleepModeStatus+0x3e>
			{
				eReturn = eNoTasksWaitingTimeout;
   2c3ee:	2302      	movs	r3, #2
   2c3f0:	71fb      	strb	r3, [r7, #7]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return eReturn;
   2c3f2:	79fb      	ldrb	r3, [r7, #7]
	}
   2c3f4:	4618      	mov	r0, r3
   2c3f6:	370c      	adds	r7, #12
   2c3f8:	46bd      	mov	sp, r7
   2c3fa:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c3fe:	4770      	bx	lr
   2c400:	1000809c 	.word	0x1000809c
   2c404:	100080d8 	.word	0x100080d8
   2c408:	100080b0 	.word	0x100080b0
   2c40c:	100080c4 	.word	0x100080c4

0002c410 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   2c410:	b580      	push	{r7, lr}
   2c412:	b082      	sub	sp, #8
   2c414:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2c416:	2300      	movs	r3, #0
   2c418:	607b      	str	r3, [r7, #4]
   2c41a:	e00c      	b.n	2c436 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   2c41c:	687a      	ldr	r2, [r7, #4]
   2c41e:	4613      	mov	r3, r2
   2c420:	009b      	lsls	r3, r3, #2
   2c422:	4413      	add	r3, r2
   2c424:	009b      	lsls	r3, r3, #2
   2c426:	4a10      	ldr	r2, [pc, #64]	; (2c468 <prvInitialiseTaskLists+0x58>)
   2c428:	4413      	add	r3, r2
   2c42a:	4618      	mov	r0, r3
   2c42c:	f7fe f82c 	bl	2a488 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2c430:	687b      	ldr	r3, [r7, #4]
   2c432:	3301      	adds	r3, #1
   2c434:	607b      	str	r3, [r7, #4]
   2c436:	687b      	ldr	r3, [r7, #4]
   2c438:	2b05      	cmp	r3, #5
   2c43a:	d9ef      	bls.n	2c41c <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
   2c43c:	480b      	ldr	r0, [pc, #44]	; (2c46c <prvInitialiseTaskLists+0x5c>)
   2c43e:	f7fe f823 	bl	2a488 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
   2c442:	480b      	ldr	r0, [pc, #44]	; (2c470 <prvInitialiseTaskLists+0x60>)
   2c444:	f7fe f820 	bl	2a488 <vListInitialise>
	vListInitialise( &xPendingReadyList );
   2c448:	480a      	ldr	r0, [pc, #40]	; (2c474 <prvInitialiseTaskLists+0x64>)
   2c44a:	f7fe f81d 	bl	2a488 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   2c44e:	480a      	ldr	r0, [pc, #40]	; (2c478 <prvInitialiseTaskLists+0x68>)
   2c450:	f7fe f81a 	bl	2a488 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   2c454:	4b09      	ldr	r3, [pc, #36]	; (2c47c <prvInitialiseTaskLists+0x6c>)
   2c456:	4a05      	ldr	r2, [pc, #20]	; (2c46c <prvInitialiseTaskLists+0x5c>)
   2c458:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2c45a:	4b09      	ldr	r3, [pc, #36]	; (2c480 <prvInitialiseTaskLists+0x70>)
   2c45c:	4a04      	ldr	r2, [pc, #16]	; (2c470 <prvInitialiseTaskLists+0x60>)
   2c45e:	601a      	str	r2, [r3, #0]
}
   2c460:	bf00      	nop
   2c462:	3708      	adds	r7, #8
   2c464:	46bd      	mov	sp, r7
   2c466:	bd80      	pop	{r7, pc}
   2c468:	10007ff4 	.word	0x10007ff4
   2c46c:	1000806c 	.word	0x1000806c
   2c470:	10008080 	.word	0x10008080
   2c474:	1000809c 	.word	0x1000809c
   2c478:	100080b0 	.word	0x100080b0
   2c47c:	10008094 	.word	0x10008094
   2c480:	10008098 	.word	0x10008098

0002c484 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   2c484:	b480      	push	{r7}
   2c486:	af00      	add	r7, sp, #0

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
   2c488:	bf00      	nop
   2c48a:	46bd      	mov	sp, r7
   2c48c:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c490:	4770      	bx	lr
	...

0002c494 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   2c494:	b480      	push	{r7}
   2c496:	b083      	sub	sp, #12
   2c498:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   2c49a:	4b0c      	ldr	r3, [pc, #48]	; (2c4cc <prvResetNextTaskUnblockTime+0x38>)
   2c49c:	681b      	ldr	r3, [r3, #0]
   2c49e:	681b      	ldr	r3, [r3, #0]
   2c4a0:	2b00      	cmp	r3, #0
   2c4a2:	d104      	bne.n	2c4ae <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   2c4a4:	4b0a      	ldr	r3, [pc, #40]	; (2c4d0 <prvResetNextTaskUnblockTime+0x3c>)
   2c4a6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   2c4aa:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
   2c4ac:	e008      	b.n	2c4c0 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2c4ae:	4b07      	ldr	r3, [pc, #28]	; (2c4cc <prvResetNextTaskUnblockTime+0x38>)
   2c4b0:	681b      	ldr	r3, [r3, #0]
   2c4b2:	68db      	ldr	r3, [r3, #12]
   2c4b4:	68db      	ldr	r3, [r3, #12]
   2c4b6:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   2c4b8:	687b      	ldr	r3, [r7, #4]
   2c4ba:	685b      	ldr	r3, [r3, #4]
   2c4bc:	4a04      	ldr	r2, [pc, #16]	; (2c4d0 <prvResetNextTaskUnblockTime+0x3c>)
   2c4be:	6013      	str	r3, [r2, #0]
}
   2c4c0:	bf00      	nop
   2c4c2:	370c      	adds	r7, #12
   2c4c4:	46bd      	mov	sp, r7
   2c4c6:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c4ca:	4770      	bx	lr
   2c4cc:	10008094 	.word	0x10008094
   2c4d0:	100080e4 	.word	0x100080e4

0002c4d4 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
   2c4d4:	b480      	push	{r7}
   2c4d6:	b083      	sub	sp, #12
   2c4d8:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
   2c4da:	4b0b      	ldr	r3, [pc, #44]	; (2c508 <xTaskGetSchedulerState+0x34>)
   2c4dc:	681b      	ldr	r3, [r3, #0]
   2c4de:	2b00      	cmp	r3, #0
   2c4e0:	d102      	bne.n	2c4e8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   2c4e2:	2301      	movs	r3, #1
   2c4e4:	607b      	str	r3, [r7, #4]
   2c4e6:	e008      	b.n	2c4fa <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2c4e8:	4b08      	ldr	r3, [pc, #32]	; (2c50c <xTaskGetSchedulerState+0x38>)
   2c4ea:	681b      	ldr	r3, [r3, #0]
   2c4ec:	2b00      	cmp	r3, #0
   2c4ee:	d102      	bne.n	2c4f6 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
   2c4f0:	2302      	movs	r3, #2
   2c4f2:	607b      	str	r3, [r7, #4]
   2c4f4:	e001      	b.n	2c4fa <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   2c4f6:	2300      	movs	r3, #0
   2c4f8:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
   2c4fa:	687b      	ldr	r3, [r7, #4]
	}
   2c4fc:	4618      	mov	r0, r3
   2c4fe:	370c      	adds	r7, #12
   2c500:	46bd      	mov	sp, r7
   2c502:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c506:	4770      	bx	lr
   2c508:	100080d0 	.word	0x100080d0
   2c50c:	100080ec 	.word	0x100080ec

0002c510 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
   2c510:	b480      	push	{r7}
   2c512:	b083      	sub	sp, #12
   2c514:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   2c516:	4b09      	ldr	r3, [pc, #36]	; (2c53c <uxTaskResetEventItemValue+0x2c>)
   2c518:	681b      	ldr	r3, [r3, #0]
   2c51a:	699b      	ldr	r3, [r3, #24]
   2c51c:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2c51e:	4b07      	ldr	r3, [pc, #28]	; (2c53c <uxTaskResetEventItemValue+0x2c>)
   2c520:	681b      	ldr	r3, [r3, #0]
   2c522:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c524:	4b05      	ldr	r3, [pc, #20]	; (2c53c <uxTaskResetEventItemValue+0x2c>)
   2c526:	681b      	ldr	r3, [r3, #0]
   2c528:	f1c2 0206 	rsb	r2, r2, #6
   2c52c:	619a      	str	r2, [r3, #24]

	return uxReturn;
   2c52e:	687b      	ldr	r3, [r7, #4]
}
   2c530:	4618      	mov	r0, r3
   2c532:	370c      	adds	r7, #12
   2c534:	46bd      	mov	sp, r7
   2c536:	f85d 7b04 	ldr.w	r7, [sp], #4
   2c53a:	4770      	bx	lr
   2c53c:	10007ff0 	.word	0x10007ff0

0002c540 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
   2c540:	b580      	push	{r7, lr}
   2c542:	b088      	sub	sp, #32
   2c544:	af00      	add	r7, sp, #0
   2c546:	60f8      	str	r0, [r7, #12]
   2c548:	60b9      	str	r1, [r7, #8]
   2c54a:	603b      	str	r3, [r7, #0]
   2c54c:	4613      	mov	r3, r2
   2c54e:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
   2c550:	2301      	movs	r3, #1
   2c552:	61fb      	str	r3, [r7, #28]
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
   2c554:	68fb      	ldr	r3, [r7, #12]
   2c556:	61bb      	str	r3, [r7, #24]

		taskENTER_CRITICAL();
   2c558:	f7fe f934 	bl	2a7c4 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
   2c55c:	683b      	ldr	r3, [r7, #0]
   2c55e:	2b00      	cmp	r3, #0
   2c560:	d003      	beq.n	2c56a <xTaskGenericNotify+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   2c562:	69bb      	ldr	r3, [r7, #24]
   2c564:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   2c566:	683b      	ldr	r3, [r7, #0]
   2c568:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   2c56a:	69bb      	ldr	r3, [r7, #24]
   2c56c:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
   2c570:	75fb      	strb	r3, [r7, #23]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   2c572:	69bb      	ldr	r3, [r7, #24]
   2c574:	2202      	movs	r2, #2
   2c576:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

			switch( eAction )
   2c57a:	79fb      	ldrb	r3, [r7, #7]
   2c57c:	2b04      	cmp	r3, #4
   2c57e:	d828      	bhi.n	2c5d2 <xTaskGenericNotify+0x92>
   2c580:	a201      	add	r2, pc, #4	; (adr r2, 2c588 <xTaskGenericNotify+0x48>)
   2c582:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2c586:	bf00      	nop
   2c588:	0002c5d3 	.word	0x0002c5d3
   2c58c:	0002c59d 	.word	0x0002c59d
   2c590:	0002c5ab 	.word	0x0002c5ab
   2c594:	0002c5b7 	.word	0x0002c5b7
   2c598:	0002c5bf 	.word	0x0002c5bf
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   2c59c:	69bb      	ldr	r3, [r7, #24]
   2c59e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   2c5a0:	68bb      	ldr	r3, [r7, #8]
   2c5a2:	431a      	orrs	r2, r3
   2c5a4:	69bb      	ldr	r3, [r7, #24]
   2c5a6:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c5a8:	e014      	b.n	2c5d4 <xTaskGenericNotify+0x94>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   2c5aa:	69bb      	ldr	r3, [r7, #24]
   2c5ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   2c5ae:	1c5a      	adds	r2, r3, #1
   2c5b0:	69bb      	ldr	r3, [r7, #24]
   2c5b2:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c5b4:	e00e      	b.n	2c5d4 <xTaskGenericNotify+0x94>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   2c5b6:	69bb      	ldr	r3, [r7, #24]
   2c5b8:	68ba      	ldr	r2, [r7, #8]
   2c5ba:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c5bc:	e00a      	b.n	2c5d4 <xTaskGenericNotify+0x94>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   2c5be:	7dfb      	ldrb	r3, [r7, #23]
   2c5c0:	2b02      	cmp	r3, #2
   2c5c2:	d003      	beq.n	2c5cc <xTaskGenericNotify+0x8c>
					{
						pxTCB->ulNotifiedValue = ulValue;
   2c5c4:	69bb      	ldr	r3, [r7, #24]
   2c5c6:	68ba      	ldr	r2, [r7, #8]
   2c5c8:	645a      	str	r2, [r3, #68]	; 0x44
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   2c5ca:	e003      	b.n	2c5d4 <xTaskGenericNotify+0x94>
						xReturn = pdFAIL;
   2c5cc:	2300      	movs	r3, #0
   2c5ce:	61fb      	str	r3, [r7, #28]
					break;
   2c5d0:	e000      	b.n	2c5d4 <xTaskGenericNotify+0x94>
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );

					break;
   2c5d2:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   2c5d4:	7dfb      	ldrb	r3, [r7, #23]
   2c5d6:	2b01      	cmp	r3, #1
   2c5d8:	d12d      	bne.n	2c636 <xTaskGenericNotify+0xf6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2c5da:	69bb      	ldr	r3, [r7, #24]
   2c5dc:	3304      	adds	r3, #4
   2c5de:	4618      	mov	r0, r3
   2c5e0:	f7fd ffdc 	bl	2a59c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
   2c5e4:	69bb      	ldr	r3, [r7, #24]
   2c5e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c5e8:	4b16      	ldr	r3, [pc, #88]	; (2c644 <xTaskGenericNotify+0x104>)
   2c5ea:	681b      	ldr	r3, [r3, #0]
   2c5ec:	429a      	cmp	r2, r3
   2c5ee:	d903      	bls.n	2c5f8 <xTaskGenericNotify+0xb8>
   2c5f0:	69bb      	ldr	r3, [r7, #24]
   2c5f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c5f4:	4a13      	ldr	r2, [pc, #76]	; (2c644 <xTaskGenericNotify+0x104>)
   2c5f6:	6013      	str	r3, [r2, #0]
   2c5f8:	69bb      	ldr	r3, [r7, #24]
   2c5fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c5fc:	4613      	mov	r3, r2
   2c5fe:	009b      	lsls	r3, r3, #2
   2c600:	4413      	add	r3, r2
   2c602:	009b      	lsls	r3, r3, #2
   2c604:	4a10      	ldr	r2, [pc, #64]	; (2c648 <xTaskGenericNotify+0x108>)
   2c606:	441a      	add	r2, r3
   2c608:	69bb      	ldr	r3, [r7, #24]
   2c60a:	3304      	adds	r3, #4
   2c60c:	4619      	mov	r1, r3
   2c60e:	4610      	mov	r0, r2
   2c610:	f7fd ff67 	bl	2a4e2 <vListInsertEnd>
					the tick count equals xNextTaskUnblockTime.  However if
					tickless idling is used it might be more important to enter
					sleep mode at the earliest possible time - so reset
					xNextTaskUnblockTime here to ensure it is updated at the
					earliest possible time. */
					prvResetNextTaskUnblockTime();
   2c614:	f7ff ff3e 	bl	2c494 <prvResetNextTaskUnblockTime>
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2c618:	69bb      	ldr	r3, [r7, #24]
   2c61a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c61c:	4b0b      	ldr	r3, [pc, #44]	; (2c64c <xTaskGenericNotify+0x10c>)
   2c61e:	681b      	ldr	r3, [r3, #0]
   2c620:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c622:	429a      	cmp	r2, r3
   2c624:	d907      	bls.n	2c636 <xTaskGenericNotify+0xf6>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
   2c626:	4b0a      	ldr	r3, [pc, #40]	; (2c650 <xTaskGenericNotify+0x110>)
   2c628:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2c62c:	601a      	str	r2, [r3, #0]
   2c62e:	f3bf 8f4f 	dsb	sy
   2c632:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
   2c636:	f7fe f8df 	bl	2a7f8 <vPortExitCritical>

		return xReturn;
   2c63a:	69fb      	ldr	r3, [r7, #28]
	}
   2c63c:	4618      	mov	r0, r3
   2c63e:	3720      	adds	r7, #32
   2c640:	46bd      	mov	sp, r7
   2c642:	bd80      	pop	{r7, pc}
   2c644:	100080cc 	.word	0x100080cc
   2c648:	10007ff4 	.word	0x10007ff4
   2c64c:	10007ff0 	.word	0x10007ff0
   2c650:	e000ed04 	.word	0xe000ed04

0002c654 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
   2c654:	b580      	push	{r7, lr}
   2c656:	b08c      	sub	sp, #48	; 0x30
   2c658:	af00      	add	r7, sp, #0
   2c65a:	60f8      	str	r0, [r7, #12]
   2c65c:	60b9      	str	r1, [r7, #8]
   2c65e:	603b      	str	r3, [r7, #0]
   2c660:	4613      	mov	r3, r2
   2c662:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
   2c664:	2301      	movs	r3, #1
   2c666:	62fb      	str	r3, [r7, #44]	; 0x2c
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
   2c668:	68fb      	ldr	r3, [r7, #12]
   2c66a:	62bb      	str	r3, [r7, #40]	; 0x28
	__asm volatile
   2c66c:	f3ef 8211 	mrs	r2, BASEPRI
   2c670:	f04f 0360 	mov.w	r3, #96	; 0x60
   2c674:	f383 8811 	msr	BASEPRI, r3
   2c678:	f3bf 8f6f 	isb	sy
   2c67c:	f3bf 8f4f 	dsb	sy
   2c680:	61fa      	str	r2, [r7, #28]
   2c682:	61bb      	str	r3, [r7, #24]
	return ulOriginalBASEPRI;
   2c684:	69fb      	ldr	r3, [r7, #28]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   2c686:	627b      	str	r3, [r7, #36]	; 0x24
		{
			if( pulPreviousNotificationValue != NULL )
   2c688:	683b      	ldr	r3, [r7, #0]
   2c68a:	2b00      	cmp	r3, #0
   2c68c:	d003      	beq.n	2c696 <xTaskGenericNotifyFromISR+0x42>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   2c68e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c690:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   2c692:	683b      	ldr	r3, [r7, #0]
   2c694:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
   2c696:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c698:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
   2c69c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
   2c6a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6a2:	2202      	movs	r2, #2
   2c6a4:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

			switch( eAction )
   2c6a8:	79fb      	ldrb	r3, [r7, #7]
   2c6aa:	2b04      	cmp	r3, #4
   2c6ac:	d828      	bhi.n	2c700 <xTaskGenericNotifyFromISR+0xac>
   2c6ae:	a201      	add	r2, pc, #4	; (adr r2, 2c6b4 <xTaskGenericNotifyFromISR+0x60>)
   2c6b0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2c6b4:	0002c701 	.word	0x0002c701
   2c6b8:	0002c6c9 	.word	0x0002c6c9
   2c6bc:	0002c6d7 	.word	0x0002c6d7
   2c6c0:	0002c6e3 	.word	0x0002c6e3
   2c6c4:	0002c6eb 	.word	0x0002c6eb
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
   2c6c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6ca:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   2c6cc:	68bb      	ldr	r3, [r7, #8]
   2c6ce:	431a      	orrs	r2, r3
   2c6d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6d2:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c6d4:	e015      	b.n	2c702 <xTaskGenericNotifyFromISR+0xae>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
   2c6d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6d8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   2c6da:	1c5a      	adds	r2, r3, #1
   2c6dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6de:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c6e0:	e00f      	b.n	2c702 <xTaskGenericNotifyFromISR+0xae>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
   2c6e2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6e4:	68ba      	ldr	r2, [r7, #8]
   2c6e6:	645a      	str	r2, [r3, #68]	; 0x44
					break;
   2c6e8:	e00b      	b.n	2c702 <xTaskGenericNotifyFromISR+0xae>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
   2c6ea:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   2c6ee:	2b02      	cmp	r3, #2
   2c6f0:	d003      	beq.n	2c6fa <xTaskGenericNotifyFromISR+0xa6>
					{
						pxTCB->ulNotifiedValue = ulValue;
   2c6f2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c6f4:	68ba      	ldr	r2, [r7, #8]
   2c6f6:	645a      	str	r2, [r3, #68]	; 0x44
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
   2c6f8:	e003      	b.n	2c702 <xTaskGenericNotifyFromISR+0xae>
						xReturn = pdFAIL;
   2c6fa:	2300      	movs	r3, #0
   2c6fc:	62fb      	str	r3, [r7, #44]	; 0x2c
					break;
   2c6fe:	e000      	b.n	2c702 <xTaskGenericNotifyFromISR+0xae>
				default:
					/* Should not get here if all enums are handled.
					Artificially force an assert by testing a value the
					compiler can't assume is const. */
					configASSERT( pxTCB->ulNotifiedValue == ~0UL );
					break;
   2c700:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
   2c702:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
   2c706:	2b01      	cmp	r3, #1
   2c708:	d137      	bne.n	2c77a <xTaskGenericNotifyFromISR+0x126>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   2c70a:	4b21      	ldr	r3, [pc, #132]	; (2c790 <xTaskGenericNotifyFromISR+0x13c>)
   2c70c:	681b      	ldr	r3, [r3, #0]
   2c70e:	2b00      	cmp	r3, #0
   2c710:	d11d      	bne.n	2c74e <xTaskGenericNotifyFromISR+0xfa>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   2c712:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c714:	3304      	adds	r3, #4
   2c716:	4618      	mov	r0, r3
   2c718:	f7fd ff40 	bl	2a59c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
   2c71c:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c71e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c720:	4b1c      	ldr	r3, [pc, #112]	; (2c794 <xTaskGenericNotifyFromISR+0x140>)
   2c722:	681b      	ldr	r3, [r3, #0]
   2c724:	429a      	cmp	r2, r3
   2c726:	d903      	bls.n	2c730 <xTaskGenericNotifyFromISR+0xdc>
   2c728:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c72a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c72c:	4a19      	ldr	r2, [pc, #100]	; (2c794 <xTaskGenericNotifyFromISR+0x140>)
   2c72e:	6013      	str	r3, [r2, #0]
   2c730:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c732:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c734:	4613      	mov	r3, r2
   2c736:	009b      	lsls	r3, r3, #2
   2c738:	4413      	add	r3, r2
   2c73a:	009b      	lsls	r3, r3, #2
   2c73c:	4a16      	ldr	r2, [pc, #88]	; (2c798 <xTaskGenericNotifyFromISR+0x144>)
   2c73e:	441a      	add	r2, r3
   2c740:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c742:	3304      	adds	r3, #4
   2c744:	4619      	mov	r1, r3
   2c746:	4610      	mov	r0, r2
   2c748:	f7fd fecb 	bl	2a4e2 <vListInsertEnd>
   2c74c:	e005      	b.n	2c75a <xTaskGenericNotifyFromISR+0x106>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   2c74e:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c750:	3318      	adds	r3, #24
   2c752:	4619      	mov	r1, r3
   2c754:	4811      	ldr	r0, [pc, #68]	; (2c79c <xTaskGenericNotifyFromISR+0x148>)
   2c756:	f7fd fec4 	bl	2a4e2 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   2c75a:	6abb      	ldr	r3, [r7, #40]	; 0x28
   2c75c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   2c75e:	4b10      	ldr	r3, [pc, #64]	; (2c7a0 <xTaskGenericNotifyFromISR+0x14c>)
   2c760:	681b      	ldr	r3, [r3, #0]
   2c762:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   2c764:	429a      	cmp	r2, r3
   2c766:	d908      	bls.n	2c77a <xTaskGenericNotifyFromISR+0x126>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
   2c768:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2c76a:	2b00      	cmp	r3, #0
   2c76c:	d002      	beq.n	2c774 <xTaskGenericNotifyFromISR+0x120>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
   2c76e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
   2c770:	2201      	movs	r2, #1
   2c772:	601a      	str	r2, [r3, #0]
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
   2c774:	4b0b      	ldr	r3, [pc, #44]	; (2c7a4 <xTaskGenericNotifyFromISR+0x150>)
   2c776:	2201      	movs	r2, #1
   2c778:	601a      	str	r2, [r3, #0]
   2c77a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2c77c:	617b      	str	r3, [r7, #20]
	__asm volatile
   2c77e:	697b      	ldr	r3, [r7, #20]
   2c780:	f383 8811 	msr	BASEPRI, r3
}
   2c784:	bf00      	nop
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
   2c786:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
   2c788:	4618      	mov	r0, r3
   2c78a:	3730      	adds	r7, #48	; 0x30
   2c78c:	46bd      	mov	sp, r7
   2c78e:	bd80      	pop	{r7, pc}
   2c790:	100080ec 	.word	0x100080ec
   2c794:	100080cc 	.word	0x100080cc
   2c798:	10007ff4 	.word	0x10007ff4
   2c79c:	1000809c 	.word	0x1000809c
   2c7a0:	10007ff0 	.word	0x10007ff0
   2c7a4:	100080d8 	.word	0x100080d8

0002c7a8 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   2c7a8:	b580      	push	{r7, lr}
   2c7aa:	b084      	sub	sp, #16
   2c7ac:	af00      	add	r7, sp, #0
   2c7ae:	6078      	str	r0, [r7, #4]
   2c7b0:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   2c7b2:	4b21      	ldr	r3, [pc, #132]	; (2c838 <prvAddCurrentTaskToDelayedList+0x90>)
   2c7b4:	681b      	ldr	r3, [r3, #0]
   2c7b6:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   2c7b8:	4b20      	ldr	r3, [pc, #128]	; (2c83c <prvAddCurrentTaskToDelayedList+0x94>)
   2c7ba:	681b      	ldr	r3, [r3, #0]
   2c7bc:	3304      	adds	r3, #4
   2c7be:	4618      	mov	r0, r3
   2c7c0:	f7fd feec 	bl	2a59c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   2c7c4:	687b      	ldr	r3, [r7, #4]
   2c7c6:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2c7ca:	d10a      	bne.n	2c7e2 <prvAddCurrentTaskToDelayedList+0x3a>
   2c7cc:	683b      	ldr	r3, [r7, #0]
   2c7ce:	2b00      	cmp	r3, #0
   2c7d0:	d007      	beq.n	2c7e2 <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   2c7d2:	4b1a      	ldr	r3, [pc, #104]	; (2c83c <prvAddCurrentTaskToDelayedList+0x94>)
   2c7d4:	681b      	ldr	r3, [r3, #0]
   2c7d6:	3304      	adds	r3, #4
   2c7d8:	4619      	mov	r1, r3
   2c7da:	4819      	ldr	r0, [pc, #100]	; (2c840 <prvAddCurrentTaskToDelayedList+0x98>)
   2c7dc:	f7fd fe81 	bl	2a4e2 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   2c7e0:	e026      	b.n	2c830 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
   2c7e2:	68fa      	ldr	r2, [r7, #12]
   2c7e4:	687b      	ldr	r3, [r7, #4]
   2c7e6:	4413      	add	r3, r2
   2c7e8:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   2c7ea:	4b14      	ldr	r3, [pc, #80]	; (2c83c <prvAddCurrentTaskToDelayedList+0x94>)
   2c7ec:	681b      	ldr	r3, [r3, #0]
   2c7ee:	68ba      	ldr	r2, [r7, #8]
   2c7f0:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
   2c7f2:	68ba      	ldr	r2, [r7, #8]
   2c7f4:	68fb      	ldr	r3, [r7, #12]
   2c7f6:	429a      	cmp	r2, r3
   2c7f8:	d209      	bcs.n	2c80e <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   2c7fa:	4b12      	ldr	r3, [pc, #72]	; (2c844 <prvAddCurrentTaskToDelayedList+0x9c>)
   2c7fc:	681a      	ldr	r2, [r3, #0]
   2c7fe:	4b0f      	ldr	r3, [pc, #60]	; (2c83c <prvAddCurrentTaskToDelayedList+0x94>)
   2c800:	681b      	ldr	r3, [r3, #0]
   2c802:	3304      	adds	r3, #4
   2c804:	4619      	mov	r1, r3
   2c806:	4610      	mov	r0, r2
   2c808:	f7fd fe8f 	bl	2a52a <vListInsert>
}
   2c80c:	e010      	b.n	2c830 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   2c80e:	4b0e      	ldr	r3, [pc, #56]	; (2c848 <prvAddCurrentTaskToDelayedList+0xa0>)
   2c810:	681a      	ldr	r2, [r3, #0]
   2c812:	4b0a      	ldr	r3, [pc, #40]	; (2c83c <prvAddCurrentTaskToDelayedList+0x94>)
   2c814:	681b      	ldr	r3, [r3, #0]
   2c816:	3304      	adds	r3, #4
   2c818:	4619      	mov	r1, r3
   2c81a:	4610      	mov	r0, r2
   2c81c:	f7fd fe85 	bl	2a52a <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
   2c820:	4b0a      	ldr	r3, [pc, #40]	; (2c84c <prvAddCurrentTaskToDelayedList+0xa4>)
   2c822:	681b      	ldr	r3, [r3, #0]
   2c824:	68ba      	ldr	r2, [r7, #8]
   2c826:	429a      	cmp	r2, r3
   2c828:	d202      	bcs.n	2c830 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
   2c82a:	4a08      	ldr	r2, [pc, #32]	; (2c84c <prvAddCurrentTaskToDelayedList+0xa4>)
   2c82c:	68bb      	ldr	r3, [r7, #8]
   2c82e:	6013      	str	r3, [r2, #0]
}
   2c830:	bf00      	nop
   2c832:	3710      	adds	r7, #16
   2c834:	46bd      	mov	sp, r7
   2c836:	bd80      	pop	{r7, pc}
   2c838:	100080c8 	.word	0x100080c8
   2c83c:	10007ff0 	.word	0x10007ff0
   2c840:	100080b0 	.word	0x100080b0
   2c844:	10008098 	.word	0x10008098
   2c848:	10008094 	.word	0x10008094
   2c84c:	100080e4 	.word	0x100080e4

0002c850 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   2c850:	b580      	push	{r7, lr}
   2c852:	b084      	sub	sp, #16
   2c854:	af02      	add	r7, sp, #8
BaseType_t xReturn = pdFAIL;
   2c856:	2300      	movs	r3, #0
   2c858:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   2c85a:	f000 fa91 	bl	2cd80 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
   2c85e:	4b0a      	ldr	r3, [pc, #40]	; (2c888 <xTimerCreateTimerTask+0x38>)
   2c860:	681b      	ldr	r3, [r3, #0]
   2c862:	2b00      	cmp	r3, #0
   2c864:	d00b      	beq.n	2c87e <xTimerCreateTimerTask+0x2e>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
   2c866:	4b09      	ldr	r3, [pc, #36]	; (2c88c <xTimerCreateTimerTask+0x3c>)
   2c868:	9301      	str	r3, [sp, #4]
   2c86a:	2303      	movs	r3, #3
   2c86c:	9300      	str	r3, [sp, #0]
   2c86e:	2300      	movs	r3, #0
   2c870:	f44f 7280 	mov.w	r2, #256	; 0x100
   2c874:	4906      	ldr	r1, [pc, #24]	; (2c890 <xTimerCreateTimerTask+0x40>)
   2c876:	4807      	ldr	r0, [pc, #28]	; (2c894 <xTimerCreateTimerTask+0x44>)
   2c878:	f7ff f8e7 	bl	2ba4a <xTaskCreate>
   2c87c:	6078      	str	r0, [r7, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
   2c87e:	687b      	ldr	r3, [r7, #4]
}
   2c880:	4618      	mov	r0, r3
   2c882:	3708      	adds	r7, #8
   2c884:	46bd      	mov	sp, r7
   2c886:	bd80      	pop	{r7, pc}
   2c888:	10008120 	.word	0x10008120
   2c88c:	10008124 	.word	0x10008124
   2c890:	000451a8 	.word	0x000451a8
   2c894:	0002ca01 	.word	0x0002ca01

0002c898 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
   2c898:	b580      	push	{r7, lr}
   2c89a:	b088      	sub	sp, #32
   2c89c:	af02      	add	r7, sp, #8
   2c89e:	60f8      	str	r0, [r7, #12]
   2c8a0:	60b9      	str	r1, [r7, #8]
   2c8a2:	607a      	str	r2, [r7, #4]
   2c8a4:	603b      	str	r3, [r7, #0]
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
   2c8a6:	2028      	movs	r0, #40	; 0x28
   2c8a8:	f7fc ffca 	bl	29840 <pvPortMalloc>
   2c8ac:	6178      	str	r0, [r7, #20]

		if( pxNewTimer != NULL )
   2c8ae:	697b      	ldr	r3, [r7, #20]
   2c8b0:	2b00      	cmp	r3, #0
   2c8b2:	d009      	beq.n	2c8c8 <xTimerCreate+0x30>
		{
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
   2c8b4:	697b      	ldr	r3, [r7, #20]
   2c8b6:	9301      	str	r3, [sp, #4]
   2c8b8:	6a3b      	ldr	r3, [r7, #32]
   2c8ba:	9300      	str	r3, [sp, #0]
   2c8bc:	683b      	ldr	r3, [r7, #0]
   2c8be:	687a      	ldr	r2, [r7, #4]
   2c8c0:	68b9      	ldr	r1, [r7, #8]
   2c8c2:	68f8      	ldr	r0, [r7, #12]
   2c8c4:	f000 f805 	bl	2c8d2 <prvInitialiseNewTimer>
				pxNewTimer->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
   2c8c8:	697b      	ldr	r3, [r7, #20]
	}
   2c8ca:	4618      	mov	r0, r3
   2c8cc:	3718      	adds	r7, #24
   2c8ce:	46bd      	mov	sp, r7
   2c8d0:	bd80      	pop	{r7, pc}

0002c8d2 <prvInitialiseNewTimer>:
									const TickType_t xTimerPeriodInTicks,
									const UBaseType_t uxAutoReload,
									void * const pvTimerID,
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer )
{
   2c8d2:	b580      	push	{r7, lr}
   2c8d4:	b084      	sub	sp, #16
   2c8d6:	af00      	add	r7, sp, #0
   2c8d8:	60f8      	str	r0, [r7, #12]
   2c8da:	60b9      	str	r1, [r7, #8]
   2c8dc:	607a      	str	r2, [r7, #4]
   2c8de:	603b      	str	r3, [r7, #0]
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
   2c8e0:	69fb      	ldr	r3, [r7, #28]
   2c8e2:	2b00      	cmp	r3, #0
   2c8e4:	d015      	beq.n	2c912 <prvInitialiseNewTimer+0x40>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
   2c8e6:	f000 fa4b 	bl	2cd80 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
   2c8ea:	69fb      	ldr	r3, [r7, #28]
   2c8ec:	68fa      	ldr	r2, [r7, #12]
   2c8ee:	601a      	str	r2, [r3, #0]
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
   2c8f0:	69fb      	ldr	r3, [r7, #28]
   2c8f2:	68ba      	ldr	r2, [r7, #8]
   2c8f4:	619a      	str	r2, [r3, #24]
		pxNewTimer->uxAutoReload = uxAutoReload;
   2c8f6:	69fb      	ldr	r3, [r7, #28]
   2c8f8:	687a      	ldr	r2, [r7, #4]
   2c8fa:	61da      	str	r2, [r3, #28]
		pxNewTimer->pvTimerID = pvTimerID;
   2c8fc:	69fb      	ldr	r3, [r7, #28]
   2c8fe:	683a      	ldr	r2, [r7, #0]
   2c900:	621a      	str	r2, [r3, #32]
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
   2c902:	69fb      	ldr	r3, [r7, #28]
   2c904:	69ba      	ldr	r2, [r7, #24]
   2c906:	625a      	str	r2, [r3, #36]	; 0x24
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
   2c908:	69fb      	ldr	r3, [r7, #28]
   2c90a:	3304      	adds	r3, #4
   2c90c:	4618      	mov	r0, r3
   2c90e:	f7fd fddb 	bl	2a4c8 <vListInitialiseItem>
		traceTIMER_CREATE( pxNewTimer );
	}
}
   2c912:	bf00      	nop
   2c914:	3710      	adds	r7, #16
   2c916:	46bd      	mov	sp, r7
   2c918:	bd80      	pop	{r7, pc}
	...

0002c91c <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   2c91c:	b580      	push	{r7, lr}
   2c91e:	b08a      	sub	sp, #40	; 0x28
   2c920:	af00      	add	r7, sp, #0
   2c922:	60f8      	str	r0, [r7, #12]
   2c924:	60b9      	str	r1, [r7, #8]
   2c926:	607a      	str	r2, [r7, #4]
   2c928:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   2c92a:	2300      	movs	r3, #0
   2c92c:	627b      	str	r3, [r7, #36]	; 0x24

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   2c92e:	4b1a      	ldr	r3, [pc, #104]	; (2c998 <xTimerGenericCommand+0x7c>)
   2c930:	681b      	ldr	r3, [r3, #0]
   2c932:	2b00      	cmp	r3, #0
   2c934:	d02a      	beq.n	2c98c <xTimerGenericCommand+0x70>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   2c936:	68bb      	ldr	r3, [r7, #8]
   2c938:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   2c93a:	687b      	ldr	r3, [r7, #4]
   2c93c:	61bb      	str	r3, [r7, #24]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
   2c93e:	68fb      	ldr	r3, [r7, #12]
   2c940:	61fb      	str	r3, [r7, #28]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   2c942:	68bb      	ldr	r3, [r7, #8]
   2c944:	2b05      	cmp	r3, #5
   2c946:	dc18      	bgt.n	2c97a <xTimerGenericCommand+0x5e>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   2c948:	f7ff fdc4 	bl	2c4d4 <xTaskGetSchedulerState>
   2c94c:	4603      	mov	r3, r0
   2c94e:	2b02      	cmp	r3, #2
   2c950:	d109      	bne.n	2c966 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   2c952:	4b11      	ldr	r3, [pc, #68]	; (2c998 <xTimerGenericCommand+0x7c>)
   2c954:	6818      	ldr	r0, [r3, #0]
   2c956:	f107 0114 	add.w	r1, r7, #20
   2c95a:	2300      	movs	r3, #0
   2c95c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   2c95e:	f7fe f9e1 	bl	2ad24 <xQueueGenericSend>
   2c962:	6278      	str	r0, [r7, #36]	; 0x24
   2c964:	e012      	b.n	2c98c <xTimerGenericCommand+0x70>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   2c966:	4b0c      	ldr	r3, [pc, #48]	; (2c998 <xTimerGenericCommand+0x7c>)
   2c968:	6818      	ldr	r0, [r3, #0]
   2c96a:	f107 0114 	add.w	r1, r7, #20
   2c96e:	2300      	movs	r3, #0
   2c970:	2200      	movs	r2, #0
   2c972:	f7fe f9d7 	bl	2ad24 <xQueueGenericSend>
   2c976:	6278      	str	r0, [r7, #36]	; 0x24
   2c978:	e008      	b.n	2c98c <xTimerGenericCommand+0x70>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   2c97a:	4b07      	ldr	r3, [pc, #28]	; (2c998 <xTimerGenericCommand+0x7c>)
   2c97c:	6818      	ldr	r0, [r3, #0]
   2c97e:	f107 0114 	add.w	r1, r7, #20
   2c982:	2300      	movs	r3, #0
   2c984:	683a      	ldr	r2, [r7, #0]
   2c986:	f7fe fa77 	bl	2ae78 <xQueueGenericSendFromISR>
   2c98a:	6278      	str	r0, [r7, #36]	; 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   2c98c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
   2c98e:	4618      	mov	r0, r3
   2c990:	3728      	adds	r7, #40	; 0x28
   2c992:	46bd      	mov	sp, r7
   2c994:	bd80      	pop	{r7, pc}
   2c996:	bf00      	nop
   2c998:	10008120 	.word	0x10008120

0002c99c <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   2c99c:	b580      	push	{r7, lr}
   2c99e:	b086      	sub	sp, #24
   2c9a0:	af02      	add	r7, sp, #8
   2c9a2:	6078      	str	r0, [r7, #4]
   2c9a4:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2c9a6:	4b15      	ldr	r3, [pc, #84]	; (2c9fc <prvProcessExpiredTimer+0x60>)
   2c9a8:	681b      	ldr	r3, [r3, #0]
   2c9aa:	68db      	ldr	r3, [r3, #12]
   2c9ac:	68db      	ldr	r3, [r3, #12]
   2c9ae:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   2c9b0:	68fb      	ldr	r3, [r7, #12]
   2c9b2:	3304      	adds	r3, #4
   2c9b4:	4618      	mov	r0, r3
   2c9b6:	f7fd fdf1 	bl	2a59c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   2c9ba:	68fb      	ldr	r3, [r7, #12]
   2c9bc:	69db      	ldr	r3, [r3, #28]
   2c9be:	2b01      	cmp	r3, #1
   2c9c0:	d114      	bne.n	2c9ec <prvProcessExpiredTimer+0x50>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   2c9c2:	68fb      	ldr	r3, [r7, #12]
   2c9c4:	699a      	ldr	r2, [r3, #24]
   2c9c6:	687b      	ldr	r3, [r7, #4]
   2c9c8:	18d1      	adds	r1, r2, r3
   2c9ca:	687b      	ldr	r3, [r7, #4]
   2c9cc:	683a      	ldr	r2, [r7, #0]
   2c9ce:	68f8      	ldr	r0, [r7, #12]
   2c9d0:	f000 f8ba 	bl	2cb48 <prvInsertTimerInActiveList>
   2c9d4:	4603      	mov	r3, r0
   2c9d6:	2b00      	cmp	r3, #0
   2c9d8:	d008      	beq.n	2c9ec <prvProcessExpiredTimer+0x50>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   2c9da:	2300      	movs	r3, #0
   2c9dc:	9300      	str	r3, [sp, #0]
   2c9de:	2300      	movs	r3, #0
   2c9e0:	687a      	ldr	r2, [r7, #4]
   2c9e2:	2100      	movs	r1, #0
   2c9e4:	68f8      	ldr	r0, [r7, #12]
   2c9e6:	f7ff ff99 	bl	2c91c <xTimerGenericCommand>
   2c9ea:	60b8      	str	r0, [r7, #8]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   2c9ec:	68fb      	ldr	r3, [r7, #12]
   2c9ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2c9f0:	68f8      	ldr	r0, [r7, #12]
   2c9f2:	4798      	blx	r3
}
   2c9f4:	bf00      	nop
   2c9f6:	3710      	adds	r7, #16
   2c9f8:	46bd      	mov	sp, r7
   2c9fa:	bd80      	pop	{r7, pc}
   2c9fc:	10008118 	.word	0x10008118

0002ca00 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   2ca00:	b580      	push	{r7, lr}
   2ca02:	b084      	sub	sp, #16
   2ca04:	af00      	add	r7, sp, #0
   2ca06:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   2ca08:	f107 0308 	add.w	r3, r7, #8
   2ca0c:	4618      	mov	r0, r3
   2ca0e:	f000 f857 	bl	2cac0 <prvGetNextExpireTime>
   2ca12:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   2ca14:	68bb      	ldr	r3, [r7, #8]
   2ca16:	4619      	mov	r1, r3
   2ca18:	68f8      	ldr	r0, [r7, #12]
   2ca1a:	f000 f803 	bl	2ca24 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   2ca1e:	f000 f8d5 	bl	2cbcc <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   2ca22:	e7f1      	b.n	2ca08 <prvTimerTask+0x8>

0002ca24 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
   2ca24:	b580      	push	{r7, lr}
   2ca26:	b084      	sub	sp, #16
   2ca28:	af00      	add	r7, sp, #0
   2ca2a:	6078      	str	r0, [r7, #4]
   2ca2c:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   2ca2e:	f7ff f961 	bl	2bcf4 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   2ca32:	f107 0308 	add.w	r3, r7, #8
   2ca36:	4618      	mov	r0, r3
   2ca38:	f000 f866 	bl	2cb08 <prvSampleTimeNow>
   2ca3c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   2ca3e:	68bb      	ldr	r3, [r7, #8]
   2ca40:	2b00      	cmp	r3, #0
   2ca42:	d130      	bne.n	2caa6 <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   2ca44:	683b      	ldr	r3, [r7, #0]
   2ca46:	2b00      	cmp	r3, #0
   2ca48:	d10a      	bne.n	2ca60 <prvProcessTimerOrBlockTask+0x3c>
   2ca4a:	687a      	ldr	r2, [r7, #4]
   2ca4c:	68fb      	ldr	r3, [r7, #12]
   2ca4e:	429a      	cmp	r2, r3
   2ca50:	d806      	bhi.n	2ca60 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
   2ca52:	f7ff f995 	bl	2bd80 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   2ca56:	68f9      	ldr	r1, [r7, #12]
   2ca58:	6878      	ldr	r0, [r7, #4]
   2ca5a:	f7ff ff9f 	bl	2c99c <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
   2ca5e:	e024      	b.n	2caaa <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
   2ca60:	683b      	ldr	r3, [r7, #0]
   2ca62:	2b00      	cmp	r3, #0
   2ca64:	d008      	beq.n	2ca78 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   2ca66:	4b13      	ldr	r3, [pc, #76]	; (2cab4 <prvProcessTimerOrBlockTask+0x90>)
   2ca68:	681b      	ldr	r3, [r3, #0]
   2ca6a:	681b      	ldr	r3, [r3, #0]
   2ca6c:	2b00      	cmp	r3, #0
   2ca6e:	d101      	bne.n	2ca74 <prvProcessTimerOrBlockTask+0x50>
   2ca70:	2301      	movs	r3, #1
   2ca72:	e000      	b.n	2ca76 <prvProcessTimerOrBlockTask+0x52>
   2ca74:	2300      	movs	r3, #0
   2ca76:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   2ca78:	4b0f      	ldr	r3, [pc, #60]	; (2cab8 <prvProcessTimerOrBlockTask+0x94>)
   2ca7a:	6818      	ldr	r0, [r3, #0]
   2ca7c:	687a      	ldr	r2, [r7, #4]
   2ca7e:	68fb      	ldr	r3, [r7, #12]
   2ca80:	1ad3      	subs	r3, r2, r3
   2ca82:	683a      	ldr	r2, [r7, #0]
   2ca84:	4619      	mov	r1, r3
   2ca86:	f7fe fbf5 	bl	2b274 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
   2ca8a:	f7ff f979 	bl	2bd80 <xTaskResumeAll>
   2ca8e:	4603      	mov	r3, r0
   2ca90:	2b00      	cmp	r3, #0
   2ca92:	d10a      	bne.n	2caaa <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
   2ca94:	4b09      	ldr	r3, [pc, #36]	; (2cabc <prvProcessTimerOrBlockTask+0x98>)
   2ca96:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2ca9a:	601a      	str	r2, [r3, #0]
   2ca9c:	f3bf 8f4f 	dsb	sy
   2caa0:	f3bf 8f6f 	isb	sy
}
   2caa4:	e001      	b.n	2caaa <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
   2caa6:	f7ff f96b 	bl	2bd80 <xTaskResumeAll>
}
   2caaa:	bf00      	nop
   2caac:	3710      	adds	r7, #16
   2caae:	46bd      	mov	sp, r7
   2cab0:	bd80      	pop	{r7, pc}
   2cab2:	bf00      	nop
   2cab4:	1000811c 	.word	0x1000811c
   2cab8:	10008120 	.word	0x10008120
   2cabc:	e000ed04 	.word	0xe000ed04

0002cac0 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   2cac0:	b480      	push	{r7}
   2cac2:	b085      	sub	sp, #20
   2cac4:	af00      	add	r7, sp, #0
   2cac6:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   2cac8:	4b0e      	ldr	r3, [pc, #56]	; (2cb04 <prvGetNextExpireTime+0x44>)
   2caca:	681b      	ldr	r3, [r3, #0]
   2cacc:	681b      	ldr	r3, [r3, #0]
   2cace:	2b00      	cmp	r3, #0
   2cad0:	d101      	bne.n	2cad6 <prvGetNextExpireTime+0x16>
   2cad2:	2201      	movs	r2, #1
   2cad4:	e000      	b.n	2cad8 <prvGetNextExpireTime+0x18>
   2cad6:	2200      	movs	r2, #0
   2cad8:	687b      	ldr	r3, [r7, #4]
   2cada:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
   2cadc:	687b      	ldr	r3, [r7, #4]
   2cade:	681b      	ldr	r3, [r3, #0]
   2cae0:	2b00      	cmp	r3, #0
   2cae2:	d105      	bne.n	2caf0 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   2cae4:	4b07      	ldr	r3, [pc, #28]	; (2cb04 <prvGetNextExpireTime+0x44>)
   2cae6:	681b      	ldr	r3, [r3, #0]
   2cae8:	68db      	ldr	r3, [r3, #12]
   2caea:	681b      	ldr	r3, [r3, #0]
   2caec:	60fb      	str	r3, [r7, #12]
   2caee:	e001      	b.n	2caf4 <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   2caf0:	2300      	movs	r3, #0
   2caf2:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   2caf4:	68fb      	ldr	r3, [r7, #12]
}
   2caf6:	4618      	mov	r0, r3
   2caf8:	3714      	adds	r7, #20
   2cafa:	46bd      	mov	sp, r7
   2cafc:	f85d 7b04 	ldr.w	r7, [sp], #4
   2cb00:	4770      	bx	lr
   2cb02:	bf00      	nop
   2cb04:	10008118 	.word	0x10008118

0002cb08 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   2cb08:	b580      	push	{r7, lr}
   2cb0a:	b084      	sub	sp, #16
   2cb0c:	af00      	add	r7, sp, #0
   2cb0e:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   2cb10:	f7ff f9c4 	bl	2be9c <xTaskGetTickCount>
   2cb14:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
   2cb16:	4b0b      	ldr	r3, [pc, #44]	; (2cb44 <prvSampleTimeNow+0x3c>)
   2cb18:	681b      	ldr	r3, [r3, #0]
   2cb1a:	68fa      	ldr	r2, [r7, #12]
   2cb1c:	429a      	cmp	r2, r3
   2cb1e:	d205      	bcs.n	2cb2c <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
   2cb20:	f000 f8da 	bl	2ccd8 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
   2cb24:	687b      	ldr	r3, [r7, #4]
   2cb26:	2201      	movs	r2, #1
   2cb28:	601a      	str	r2, [r3, #0]
   2cb2a:	e002      	b.n	2cb32 <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   2cb2c:	687b      	ldr	r3, [r7, #4]
   2cb2e:	2200      	movs	r2, #0
   2cb30:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   2cb32:	4a04      	ldr	r2, [pc, #16]	; (2cb44 <prvSampleTimeNow+0x3c>)
   2cb34:	68fb      	ldr	r3, [r7, #12]
   2cb36:	6013      	str	r3, [r2, #0]

	return xTimeNow;
   2cb38:	68fb      	ldr	r3, [r7, #12]
}
   2cb3a:	4618      	mov	r0, r3
   2cb3c:	3710      	adds	r7, #16
   2cb3e:	46bd      	mov	sp, r7
   2cb40:	bd80      	pop	{r7, pc}
   2cb42:	bf00      	nop
   2cb44:	10008128 	.word	0x10008128

0002cb48 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   2cb48:	b580      	push	{r7, lr}
   2cb4a:	b086      	sub	sp, #24
   2cb4c:	af00      	add	r7, sp, #0
   2cb4e:	60f8      	str	r0, [r7, #12]
   2cb50:	60b9      	str	r1, [r7, #8]
   2cb52:	607a      	str	r2, [r7, #4]
   2cb54:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   2cb56:	2300      	movs	r3, #0
   2cb58:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   2cb5a:	68fb      	ldr	r3, [r7, #12]
   2cb5c:	68ba      	ldr	r2, [r7, #8]
   2cb5e:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   2cb60:	68fb      	ldr	r3, [r7, #12]
   2cb62:	68fa      	ldr	r2, [r7, #12]
   2cb64:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   2cb66:	68ba      	ldr	r2, [r7, #8]
   2cb68:	687b      	ldr	r3, [r7, #4]
   2cb6a:	429a      	cmp	r2, r3
   2cb6c:	d812      	bhi.n	2cb94 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2cb6e:	687a      	ldr	r2, [r7, #4]
   2cb70:	683b      	ldr	r3, [r7, #0]
   2cb72:	1ad2      	subs	r2, r2, r3
   2cb74:	68fb      	ldr	r3, [r7, #12]
   2cb76:	699b      	ldr	r3, [r3, #24]
   2cb78:	429a      	cmp	r2, r3
   2cb7a:	d302      	bcc.n	2cb82 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   2cb7c:	2301      	movs	r3, #1
   2cb7e:	617b      	str	r3, [r7, #20]
   2cb80:	e01b      	b.n	2cbba <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   2cb82:	4b10      	ldr	r3, [pc, #64]	; (2cbc4 <prvInsertTimerInActiveList+0x7c>)
   2cb84:	681a      	ldr	r2, [r3, #0]
   2cb86:	68fb      	ldr	r3, [r7, #12]
   2cb88:	3304      	adds	r3, #4
   2cb8a:	4619      	mov	r1, r3
   2cb8c:	4610      	mov	r0, r2
   2cb8e:	f7fd fccc 	bl	2a52a <vListInsert>
   2cb92:	e012      	b.n	2cbba <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   2cb94:	687a      	ldr	r2, [r7, #4]
   2cb96:	683b      	ldr	r3, [r7, #0]
   2cb98:	429a      	cmp	r2, r3
   2cb9a:	d206      	bcs.n	2cbaa <prvInsertTimerInActiveList+0x62>
   2cb9c:	68ba      	ldr	r2, [r7, #8]
   2cb9e:	683b      	ldr	r3, [r7, #0]
   2cba0:	429a      	cmp	r2, r3
   2cba2:	d302      	bcc.n	2cbaa <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   2cba4:	2301      	movs	r3, #1
   2cba6:	617b      	str	r3, [r7, #20]
   2cba8:	e007      	b.n	2cbba <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   2cbaa:	4b07      	ldr	r3, [pc, #28]	; (2cbc8 <prvInsertTimerInActiveList+0x80>)
   2cbac:	681a      	ldr	r2, [r3, #0]
   2cbae:	68fb      	ldr	r3, [r7, #12]
   2cbb0:	3304      	adds	r3, #4
   2cbb2:	4619      	mov	r1, r3
   2cbb4:	4610      	mov	r0, r2
   2cbb6:	f7fd fcb8 	bl	2a52a <vListInsert>
		}
	}

	return xProcessTimerNow;
   2cbba:	697b      	ldr	r3, [r7, #20]
}
   2cbbc:	4618      	mov	r0, r3
   2cbbe:	3718      	adds	r7, #24
   2cbc0:	46bd      	mov	sp, r7
   2cbc2:	bd80      	pop	{r7, pc}
   2cbc4:	1000811c 	.word	0x1000811c
   2cbc8:	10008118 	.word	0x10008118

0002cbcc <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   2cbcc:	b580      	push	{r7, lr}
   2cbce:	b08c      	sub	sp, #48	; 0x30
   2cbd0:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   2cbd2:	e06e      	b.n	2ccb2 <prvProcessReceivedCommands+0xe6>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
   2cbd4:	68bb      	ldr	r3, [r7, #8]
   2cbd6:	2b00      	cmp	r3, #0
   2cbd8:	da0b      	bge.n	2cbf2 <prvProcessReceivedCommands+0x26>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
   2cbda:	f107 0308 	add.w	r3, r7, #8
   2cbde:	3304      	adds	r3, #4
   2cbe0:	627b      	str	r3, [r7, #36]	; 0x24
				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
   2cbe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   2cbe4:	681b      	ldr	r3, [r3, #0]
   2cbe6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   2cbe8:	6850      	ldr	r0, [r2, #4]
   2cbea:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   2cbec:	6892      	ldr	r2, [r2, #8]
   2cbee:	4611      	mov	r1, r2
   2cbf0:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   2cbf2:	68bb      	ldr	r3, [r7, #8]
   2cbf4:	2b00      	cmp	r3, #0
   2cbf6:	db5b      	blt.n	2ccb0 <prvProcessReceivedCommands+0xe4>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   2cbf8:	693b      	ldr	r3, [r7, #16]
   2cbfa:	623b      	str	r3, [r7, #32]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   2cbfc:	6a3b      	ldr	r3, [r7, #32]
   2cbfe:	695b      	ldr	r3, [r3, #20]
   2cc00:	2b00      	cmp	r3, #0
   2cc02:	d004      	beq.n	2cc0e <prvProcessReceivedCommands+0x42>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   2cc04:	6a3b      	ldr	r3, [r7, #32]
   2cc06:	3304      	adds	r3, #4
   2cc08:	4618      	mov	r0, r3
   2cc0a:	f7fd fcc7 	bl	2a59c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   2cc0e:	1d3b      	adds	r3, r7, #4
   2cc10:	4618      	mov	r0, r3
   2cc12:	f7ff ff79 	bl	2cb08 <prvSampleTimeNow>
   2cc16:	61f8      	str	r0, [r7, #28]

			switch( xMessage.xMessageID )
   2cc18:	68bb      	ldr	r3, [r7, #8]
   2cc1a:	2b09      	cmp	r3, #9
   2cc1c:	d849      	bhi.n	2ccb2 <prvProcessReceivedCommands+0xe6>
   2cc1e:	a201      	add	r2, pc, #4	; (adr r2, 2cc24 <prvProcessReceivedCommands+0x58>)
   2cc20:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2cc24:	0002cc4d 	.word	0x0002cc4d
   2cc28:	0002cc4d 	.word	0x0002cc4d
   2cc2c:	0002cc4d 	.word	0x0002cc4d
   2cc30:	0002ccb3 	.word	0x0002ccb3
   2cc34:	0002cc8f 	.word	0x0002cc8f
   2cc38:	0002cca9 	.word	0x0002cca9
   2cc3c:	0002cc4d 	.word	0x0002cc4d
   2cc40:	0002cc4d 	.word	0x0002cc4d
   2cc44:	0002ccb3 	.word	0x0002ccb3
   2cc48:	0002cc8f 	.word	0x0002cc8f
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   2cc4c:	68fa      	ldr	r2, [r7, #12]
   2cc4e:	6a3b      	ldr	r3, [r7, #32]
   2cc50:	699b      	ldr	r3, [r3, #24]
   2cc52:	18d1      	adds	r1, r2, r3
   2cc54:	68fb      	ldr	r3, [r7, #12]
   2cc56:	69fa      	ldr	r2, [r7, #28]
   2cc58:	6a38      	ldr	r0, [r7, #32]
   2cc5a:	f7ff ff75 	bl	2cb48 <prvInsertTimerInActiveList>
   2cc5e:	4603      	mov	r3, r0
   2cc60:	2b00      	cmp	r3, #0
   2cc62:	d026      	beq.n	2ccb2 <prvProcessReceivedCommands+0xe6>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   2cc64:	6a3b      	ldr	r3, [r7, #32]
   2cc66:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2cc68:	6a38      	ldr	r0, [r7, #32]
   2cc6a:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   2cc6c:	6a3b      	ldr	r3, [r7, #32]
   2cc6e:	69db      	ldr	r3, [r3, #28]
   2cc70:	2b01      	cmp	r3, #1
   2cc72:	d11e      	bne.n	2ccb2 <prvProcessReceivedCommands+0xe6>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   2cc74:	68fa      	ldr	r2, [r7, #12]
   2cc76:	6a3b      	ldr	r3, [r7, #32]
   2cc78:	699b      	ldr	r3, [r3, #24]
   2cc7a:	441a      	add	r2, r3
   2cc7c:	2300      	movs	r3, #0
   2cc7e:	9300      	str	r3, [sp, #0]
   2cc80:	2300      	movs	r3, #0
   2cc82:	2100      	movs	r1, #0
   2cc84:	6a38      	ldr	r0, [r7, #32]
   2cc86:	f7ff fe49 	bl	2c91c <xTimerGenericCommand>
   2cc8a:	61b8      	str	r0, [r7, #24]
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   2cc8c:	e011      	b.n	2ccb2 <prvProcessReceivedCommands+0xe6>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   2cc8e:	68fa      	ldr	r2, [r7, #12]
   2cc90:	6a3b      	ldr	r3, [r7, #32]
   2cc92:	619a      	str	r2, [r3, #24]
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   2cc94:	6a3b      	ldr	r3, [r7, #32]
   2cc96:	699a      	ldr	r2, [r3, #24]
   2cc98:	69fb      	ldr	r3, [r7, #28]
   2cc9a:	18d1      	adds	r1, r2, r3
   2cc9c:	69fb      	ldr	r3, [r7, #28]
   2cc9e:	69fa      	ldr	r2, [r7, #28]
   2cca0:	6a38      	ldr	r0, [r7, #32]
   2cca2:	f7ff ff51 	bl	2cb48 <prvInsertTimerInActiveList>
					break;
   2cca6:	e004      	b.n	2ccb2 <prvProcessReceivedCommands+0xe6>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
   2cca8:	6a38      	ldr	r0, [r7, #32]
   2ccaa:	f7fc fe5d 	bl	29968 <vPortFree>
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
   2ccae:	e000      	b.n	2ccb2 <prvProcessReceivedCommands+0xe6>

				default	:
					/* Don't expect to get here. */
					break;
			}
		}
   2ccb0:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   2ccb2:	4b08      	ldr	r3, [pc, #32]	; (2ccd4 <prvProcessReceivedCommands+0x108>)
   2ccb4:	681b      	ldr	r3, [r3, #0]
   2ccb6:	f107 0108 	add.w	r1, r7, #8
   2ccba:	2200      	movs	r2, #0
   2ccbc:	4618      	mov	r0, r3
   2ccbe:	f7fe f935 	bl	2af2c <xQueueReceive>
   2ccc2:	4603      	mov	r3, r0
   2ccc4:	2b00      	cmp	r3, #0
   2ccc6:	d185      	bne.n	2cbd4 <prvProcessReceivedCommands+0x8>
	}
}
   2ccc8:	bf00      	nop
   2ccca:	bf00      	nop
   2cccc:	3728      	adds	r7, #40	; 0x28
   2ccce:	46bd      	mov	sp, r7
   2ccd0:	bd80      	pop	{r7, pc}
   2ccd2:	bf00      	nop
   2ccd4:	10008120 	.word	0x10008120

0002ccd8 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   2ccd8:	b580      	push	{r7, lr}
   2ccda:	b088      	sub	sp, #32
   2ccdc:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   2ccde:	e037      	b.n	2cd50 <prvSwitchTimerLists+0x78>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   2cce0:	4b25      	ldr	r3, [pc, #148]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2cce2:	681b      	ldr	r3, [r3, #0]
   2cce4:	68db      	ldr	r3, [r3, #12]
   2cce6:	681b      	ldr	r3, [r3, #0]
   2cce8:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
   2ccea:	4b23      	ldr	r3, [pc, #140]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2ccec:	681b      	ldr	r3, [r3, #0]
   2ccee:	68db      	ldr	r3, [r3, #12]
   2ccf0:	68db      	ldr	r3, [r3, #12]
   2ccf2:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   2ccf4:	68fb      	ldr	r3, [r7, #12]
   2ccf6:	3304      	adds	r3, #4
   2ccf8:	4618      	mov	r0, r3
   2ccfa:	f7fd fc4f 	bl	2a59c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   2ccfe:	68fb      	ldr	r3, [r7, #12]
   2cd00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   2cd02:	68f8      	ldr	r0, [r7, #12]
   2cd04:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   2cd06:	68fb      	ldr	r3, [r7, #12]
   2cd08:	69db      	ldr	r3, [r3, #28]
   2cd0a:	2b01      	cmp	r3, #1
   2cd0c:	d120      	bne.n	2cd50 <prvSwitchTimerLists+0x78>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   2cd0e:	68fb      	ldr	r3, [r7, #12]
   2cd10:	699b      	ldr	r3, [r3, #24]
   2cd12:	693a      	ldr	r2, [r7, #16]
   2cd14:	4413      	add	r3, r2
   2cd16:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
   2cd18:	68ba      	ldr	r2, [r7, #8]
   2cd1a:	693b      	ldr	r3, [r7, #16]
   2cd1c:	429a      	cmp	r2, r3
   2cd1e:	d90e      	bls.n	2cd3e <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   2cd20:	68fb      	ldr	r3, [r7, #12]
   2cd22:	68ba      	ldr	r2, [r7, #8]
   2cd24:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   2cd26:	68fb      	ldr	r3, [r7, #12]
   2cd28:	68fa      	ldr	r2, [r7, #12]
   2cd2a:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   2cd2c:	4b12      	ldr	r3, [pc, #72]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2cd2e:	681a      	ldr	r2, [r3, #0]
   2cd30:	68fb      	ldr	r3, [r7, #12]
   2cd32:	3304      	adds	r3, #4
   2cd34:	4619      	mov	r1, r3
   2cd36:	4610      	mov	r0, r2
   2cd38:	f7fd fbf7 	bl	2a52a <vListInsert>
   2cd3c:	e008      	b.n	2cd50 <prvSwitchTimerLists+0x78>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   2cd3e:	2300      	movs	r3, #0
   2cd40:	9300      	str	r3, [sp, #0]
   2cd42:	2300      	movs	r3, #0
   2cd44:	693a      	ldr	r2, [r7, #16]
   2cd46:	2100      	movs	r1, #0
   2cd48:	68f8      	ldr	r0, [r7, #12]
   2cd4a:	f7ff fde7 	bl	2c91c <xTimerGenericCommand>
   2cd4e:	6078      	str	r0, [r7, #4]
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   2cd50:	4b09      	ldr	r3, [pc, #36]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2cd52:	681b      	ldr	r3, [r3, #0]
   2cd54:	681b      	ldr	r3, [r3, #0]
   2cd56:	2b00      	cmp	r3, #0
   2cd58:	d1c2      	bne.n	2cce0 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   2cd5a:	4b07      	ldr	r3, [pc, #28]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2cd5c:	681b      	ldr	r3, [r3, #0]
   2cd5e:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
   2cd60:	4b06      	ldr	r3, [pc, #24]	; (2cd7c <prvSwitchTimerLists+0xa4>)
   2cd62:	681b      	ldr	r3, [r3, #0]
   2cd64:	4a04      	ldr	r2, [pc, #16]	; (2cd78 <prvSwitchTimerLists+0xa0>)
   2cd66:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
   2cd68:	4a04      	ldr	r2, [pc, #16]	; (2cd7c <prvSwitchTimerLists+0xa4>)
   2cd6a:	697b      	ldr	r3, [r7, #20]
   2cd6c:	6013      	str	r3, [r2, #0]
}
   2cd6e:	bf00      	nop
   2cd70:	3718      	adds	r7, #24
   2cd72:	46bd      	mov	sp, r7
   2cd74:	bd80      	pop	{r7, pc}
   2cd76:	bf00      	nop
   2cd78:	10008118 	.word	0x10008118
   2cd7c:	1000811c 	.word	0x1000811c

0002cd80 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   2cd80:	b580      	push	{r7, lr}
   2cd82:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   2cd84:	f7fd fd1e 	bl	2a7c4 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
   2cd88:	4b0d      	ldr	r3, [pc, #52]	; (2cdc0 <prvCheckForValidListAndQueue+0x40>)
   2cd8a:	681b      	ldr	r3, [r3, #0]
   2cd8c:	2b00      	cmp	r3, #0
   2cd8e:	d113      	bne.n	2cdb8 <prvCheckForValidListAndQueue+0x38>
		{
			vListInitialise( &xActiveTimerList1 );
   2cd90:	480c      	ldr	r0, [pc, #48]	; (2cdc4 <prvCheckForValidListAndQueue+0x44>)
   2cd92:	f7fd fb79 	bl	2a488 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
   2cd96:	480c      	ldr	r0, [pc, #48]	; (2cdc8 <prvCheckForValidListAndQueue+0x48>)
   2cd98:	f7fd fb76 	bl	2a488 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
   2cd9c:	4b0b      	ldr	r3, [pc, #44]	; (2cdcc <prvCheckForValidListAndQueue+0x4c>)
   2cd9e:	4a09      	ldr	r2, [pc, #36]	; (2cdc4 <prvCheckForValidListAndQueue+0x44>)
   2cda0:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   2cda2:	4b0b      	ldr	r3, [pc, #44]	; (2cdd0 <prvCheckForValidListAndQueue+0x50>)
   2cda4:	4a08      	ldr	r2, [pc, #32]	; (2cdc8 <prvCheckForValidListAndQueue+0x48>)
   2cda6:	601a      	str	r2, [r3, #0]

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   2cda8:	2200      	movs	r2, #0
   2cdaa:	2110      	movs	r1, #16
   2cdac:	2005      	movs	r0, #5
   2cdae:	f7fd ff6b 	bl	2ac88 <xQueueGenericCreate>
   2cdb2:	4603      	mov	r3, r0
   2cdb4:	4a02      	ldr	r2, [pc, #8]	; (2cdc0 <prvCheckForValidListAndQueue+0x40>)
   2cdb6:	6013      	str	r3, [r2, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   2cdb8:	f7fd fd1e 	bl	2a7f8 <vPortExitCritical>
}
   2cdbc:	bf00      	nop
   2cdbe:	bd80      	pop	{r7, pc}
   2cdc0:	10008120 	.word	0x10008120
   2cdc4:	100080f0 	.word	0x100080f0
   2cdc8:	10008104 	.word	0x10008104
   2cdcc:	10008118 	.word	0x10008118
   2cdd0:	1000811c 	.word	0x1000811c

0002cdd4 <xTimerPendFunctionCallFromISR>:
/*-----------------------------------------------------------*/

#if( INCLUDE_xTimerPendFunctionCall == 1 )

	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
	{
   2cdd4:	b580      	push	{r7, lr}
   2cdd6:	b08a      	sub	sp, #40	; 0x28
   2cdd8:	af00      	add	r7, sp, #0
   2cdda:	60f8      	str	r0, [r7, #12]
   2cddc:	60b9      	str	r1, [r7, #8]
   2cdde:	607a      	str	r2, [r7, #4]
   2cde0:	603b      	str	r3, [r7, #0]
	DaemonTaskMessage_t xMessage;
	BaseType_t xReturn;

		/* Complete the message with the function parameters and post it to the
		daemon task. */
		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
   2cde2:	f06f 0301 	mvn.w	r3, #1
   2cde6:	617b      	str	r3, [r7, #20]
		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   2cde8:	68fb      	ldr	r3, [r7, #12]
   2cdea:	61bb      	str	r3, [r7, #24]
		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   2cdec:	68bb      	ldr	r3, [r7, #8]
   2cdee:	61fb      	str	r3, [r7, #28]
		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   2cdf0:	687b      	ldr	r3, [r7, #4]
   2cdf2:	623b      	str	r3, [r7, #32]

		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   2cdf4:	4b06      	ldr	r3, [pc, #24]	; (2ce10 <xTimerPendFunctionCallFromISR+0x3c>)
   2cdf6:	6818      	ldr	r0, [r3, #0]
   2cdf8:	f107 0114 	add.w	r1, r7, #20
   2cdfc:	2300      	movs	r3, #0
   2cdfe:	683a      	ldr	r2, [r7, #0]
   2ce00:	f7fe f83a 	bl	2ae78 <xQueueGenericSendFromISR>
   2ce04:	6278      	str	r0, [r7, #36]	; 0x24

		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );

		return xReturn;
   2ce06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
   2ce08:	4618      	mov	r0, r3
   2ce0a:	3728      	adds	r7, #40	; 0x28
   2ce0c:	46bd      	mov	sp, r7
   2ce0e:	bd80      	pop	{r7, pc}
   2ce10:	10008120 	.word	0x10008120

0002ce14 <WsfAssert>:
 *  \param  pFile   Name of file originating assert.
 *  \param  line    Line number of assert statement.
 */
/*************************************************************************************************/
void WsfAssert(const char *pFile, uint16_t line)
{
   2ce14:	b480      	push	{r7}
   2ce16:	b085      	sub	sp, #20
   2ce18:	af00      	add	r7, sp, #0
   2ce1a:	6078      	str	r0, [r7, #4]
   2ce1c:	460b      	mov	r3, r1
   2ce1e:	807b      	strh	r3, [r7, #2]
  volatile uint8_t escape=0;
   2ce20:	2300      	movs	r3, #0
   2ce22:	73fb      	strb	r3, [r7, #15]
  {
    /*
     *  However, you can exit with a debugger by setting variable 'escape'.
     *  Handy to see where the assert happened if you cannot view the call stack.
    */
    if (escape)
   2ce24:	7bfb      	ldrb	r3, [r7, #15]
   2ce26:	b2db      	uxtb	r3, r3
   2ce28:	2b00      	cmp	r3, #0
   2ce2a:	d100      	bne.n	2ce2e <WsfAssert+0x1a>
   2ce2c:	e7fa      	b.n	2ce24 <WsfAssert+0x10>
    {
      break;
   2ce2e:	bf00      	nop
    }
  }
}
   2ce30:	bf00      	nop
   2ce32:	3714      	adds	r7, #20
   2ce34:	46bd      	mov	sp, r7
   2ce36:	f85d 7b04 	ldr.w	r7, [sp], #4
   2ce3a:	4770      	bx	lr

0002ce3c <WsfBufInit>:
 *
 *  \return Amount of pBufMem used or 0 for failures.
 */
/*************************************************************************************************/
uint16_t WsfBufInit(uint16_t bufMemLen, uint8_t *pBufMem, uint8_t numPools, wsfBufPoolDesc_t *pDesc)
{
   2ce3c:	b480      	push	{r7}
   2ce3e:	b089      	sub	sp, #36	; 0x24
   2ce40:	af00      	add	r7, sp, #0
   2ce42:	60b9      	str	r1, [r7, #8]
   2ce44:	607b      	str	r3, [r7, #4]
   2ce46:	4603      	mov	r3, r0
   2ce48:	81fb      	strh	r3, [r7, #14]
   2ce4a:	4613      	mov	r3, r2
   2ce4c:	737b      	strb	r3, [r7, #13]
  wsfBufPool_t  *pPool;
  wsfBufMem_t   *pStart;
  uint16_t      len;
  uint8_t       i;

  wsfBufMem = (wsfBufMem_t *) pBufMem;
   2ce4e:	4a4d      	ldr	r2, [pc, #308]	; (2cf84 <WsfBufInit+0x148>)
   2ce50:	68bb      	ldr	r3, [r7, #8]
   2ce52:	6013      	str	r3, [r2, #0]
  pPool = (wsfBufPool_t *) wsfBufMem;
   2ce54:	4b4b      	ldr	r3, [pc, #300]	; (2cf84 <WsfBufInit+0x148>)
   2ce56:	681b      	ldr	r3, [r3, #0]
   2ce58:	61fb      	str	r3, [r7, #28]

  /* buffer storage starts after the pool structs */
  pStart = (wsfBufMem_t *) (pPool + numPools);
   2ce5a:	7b7a      	ldrb	r2, [r7, #13]
   2ce5c:	4613      	mov	r3, r2
   2ce5e:	005b      	lsls	r3, r3, #1
   2ce60:	4413      	add	r3, r2
   2ce62:	009b      	lsls	r3, r3, #2
   2ce64:	461a      	mov	r2, r3
   2ce66:	69fb      	ldr	r3, [r7, #28]
   2ce68:	4413      	add	r3, r2
   2ce6a:	61bb      	str	r3, [r7, #24]

  wsfBufNumPools = numPools;
   2ce6c:	4a46      	ldr	r2, [pc, #280]	; (2cf88 <WsfBufInit+0x14c>)
   2ce6e:	7b7b      	ldrb	r3, [r7, #13]
   2ce70:	7013      	strb	r3, [r2, #0]

  /* create each pool; see loop exit condition below */
  while (TRUE)
  {
    /* verify we didn't overrun memory; if we did, abort */
    if (pStart > &wsfBufMem[bufMemLen / sizeof(wsfBufMem_t)])
   2ce72:	4b44      	ldr	r3, [pc, #272]	; (2cf84 <WsfBufInit+0x148>)
   2ce74:	681a      	ldr	r2, [r3, #0]
   2ce76:	89fb      	ldrh	r3, [r7, #14]
   2ce78:	08db      	lsrs	r3, r3, #3
   2ce7a:	b29b      	uxth	r3, r3
   2ce7c:	00db      	lsls	r3, r3, #3
   2ce7e:	4413      	add	r3, r2
   2ce80:	69ba      	ldr	r2, [r7, #24]
   2ce82:	429a      	cmp	r2, r3
   2ce84:	d901      	bls.n	2ce8a <WsfBufInit+0x4e>
    {
      WSF_ASSERT(FALSE);
      return 0;
   2ce86:	2300      	movs	r3, #0
   2ce88:	e075      	b.n	2cf76 <WsfBufInit+0x13a>
    }

    /* exit loop after verification check */
    if (numPools-- == 0)
   2ce8a:	7b7b      	ldrb	r3, [r7, #13]
   2ce8c:	1e5a      	subs	r2, r3, #1
   2ce8e:	737a      	strb	r2, [r7, #13]
   2ce90:	2b00      	cmp	r3, #0
   2ce92:	d066      	beq.n	2cf62 <WsfBufInit+0x126>
    {
      break;
    }

    /* adjust pool lengths for minimum size and alignment */
    if (pDesc->len < sizeof(wsfBufMem_t))
   2ce94:	687b      	ldr	r3, [r7, #4]
   2ce96:	881b      	ldrh	r3, [r3, #0]
   2ce98:	2b07      	cmp	r3, #7
   2ce9a:	d803      	bhi.n	2cea4 <WsfBufInit+0x68>
    {
      pPool->desc.len = sizeof(wsfBufMem_t);
   2ce9c:	69fb      	ldr	r3, [r7, #28]
   2ce9e:	2208      	movs	r2, #8
   2cea0:	801a      	strh	r2, [r3, #0]
   2cea2:	e014      	b.n	2cece <WsfBufInit+0x92>
    }
    else if ((pDesc->len % sizeof(wsfBufMem_t)) != 0)
   2cea4:	687b      	ldr	r3, [r7, #4]
   2cea6:	881b      	ldrh	r3, [r3, #0]
   2cea8:	f003 0307 	and.w	r3, r3, #7
   2ceac:	b29b      	uxth	r3, r3
   2ceae:	2b00      	cmp	r3, #0
   2ceb0:	d009      	beq.n	2cec6 <WsfBufInit+0x8a>
    {
      pPool->desc.len = pDesc->len + sizeof(wsfBufMem_t) - (pDesc->len % sizeof(wsfBufMem_t));
   2ceb2:	687b      	ldr	r3, [r7, #4]
   2ceb4:	881b      	ldrh	r3, [r3, #0]
   2ceb6:	f023 0307 	bic.w	r3, r3, #7
   2ceba:	b29b      	uxth	r3, r3
   2cebc:	3308      	adds	r3, #8
   2cebe:	b29a      	uxth	r2, r3
   2cec0:	69fb      	ldr	r3, [r7, #28]
   2cec2:	801a      	strh	r2, [r3, #0]
   2cec4:	e003      	b.n	2cece <WsfBufInit+0x92>
    }
    else
    {
      pPool->desc.len = pDesc->len;
   2cec6:	687b      	ldr	r3, [r7, #4]
   2cec8:	881a      	ldrh	r2, [r3, #0]
   2ceca:	69fb      	ldr	r3, [r7, #28]
   2cecc:	801a      	strh	r2, [r3, #0]
    }

    pPool->desc.num = pDesc->num;
   2cece:	687b      	ldr	r3, [r7, #4]
   2ced0:	789a      	ldrb	r2, [r3, #2]
   2ced2:	69fb      	ldr	r3, [r7, #28]
   2ced4:	709a      	strb	r2, [r3, #2]
    pDesc++;
   2ced6:	687b      	ldr	r3, [r7, #4]
   2ced8:	3304      	adds	r3, #4
   2ceda:	607b      	str	r3, [r7, #4]

    pPool->pStart = pStart;
   2cedc:	69fb      	ldr	r3, [r7, #28]
   2cede:	69ba      	ldr	r2, [r7, #24]
   2cee0:	605a      	str	r2, [r3, #4]
    pPool->pFree = pStart;
   2cee2:	69fb      	ldr	r3, [r7, #28]
   2cee4:	69ba      	ldr	r2, [r7, #24]
   2cee6:	609a      	str	r2, [r3, #8]

    WSF_TRACE_INFO2("Creating pool len=%u num=%u", pPool->desc.len, pPool->desc.num);
    WSF_TRACE_INFO1("              pStart=0x%x", (uint32_t)pPool->pStart);

    /* initialize free list */
    len = pPool->desc.len / sizeof(wsfBufMem_t);
   2cee8:	69fb      	ldr	r3, [r7, #28]
   2ceea:	881b      	ldrh	r3, [r3, #0]
   2ceec:	08db      	lsrs	r3, r3, #3
   2ceee:	82bb      	strh	r3, [r7, #20]
    for (i = pPool->desc.num; i > 1; i--)
   2cef0:	69fb      	ldr	r3, [r7, #28]
   2cef2:	789b      	ldrb	r3, [r3, #2]
   2cef4:	75fb      	strb	r3, [r7, #23]
   2cef6:	e019      	b.n	2cf2c <WsfBufInit+0xf0>
    {
      /* verify we didn't overrun memory; if we did, abort */
      if (pStart > &wsfBufMem[bufMemLen / sizeof(wsfBufMem_t)])
   2cef8:	4b22      	ldr	r3, [pc, #136]	; (2cf84 <WsfBufInit+0x148>)
   2cefa:	681a      	ldr	r2, [r3, #0]
   2cefc:	89fb      	ldrh	r3, [r7, #14]
   2cefe:	08db      	lsrs	r3, r3, #3
   2cf00:	b29b      	uxth	r3, r3
   2cf02:	00db      	lsls	r3, r3, #3
   2cf04:	4413      	add	r3, r2
   2cf06:	69ba      	ldr	r2, [r7, #24]
   2cf08:	429a      	cmp	r2, r3
   2cf0a:	d901      	bls.n	2cf10 <WsfBufInit+0xd4>
      {
        WSF_ASSERT(FALSE);
        return 0;
   2cf0c:	2300      	movs	r3, #0
   2cf0e:	e032      	b.n	2cf76 <WsfBufInit+0x13a>
      }
      /* pointer to the next free buffer is stored in the buffer itself */
      pStart->pNext = pStart + len;
   2cf10:	8abb      	ldrh	r3, [r7, #20]
   2cf12:	00db      	lsls	r3, r3, #3
   2cf14:	69ba      	ldr	r2, [r7, #24]
   2cf16:	441a      	add	r2, r3
   2cf18:	69bb      	ldr	r3, [r7, #24]
   2cf1a:	601a      	str	r2, [r3, #0]
      pStart += len;
   2cf1c:	8abb      	ldrh	r3, [r7, #20]
   2cf1e:	00db      	lsls	r3, r3, #3
   2cf20:	69ba      	ldr	r2, [r7, #24]
   2cf22:	4413      	add	r3, r2
   2cf24:	61bb      	str	r3, [r7, #24]
    for (i = pPool->desc.num; i > 1; i--)
   2cf26:	7dfb      	ldrb	r3, [r7, #23]
   2cf28:	3b01      	subs	r3, #1
   2cf2a:	75fb      	strb	r3, [r7, #23]
   2cf2c:	7dfb      	ldrb	r3, [r7, #23]
   2cf2e:	2b01      	cmp	r3, #1
   2cf30:	d8e2      	bhi.n	2cef8 <WsfBufInit+0xbc>
    }

    /* verify we didn't overrun memory; if we did, abort */
    if (pStart > &wsfBufMem[bufMemLen / sizeof(wsfBufMem_t)])
   2cf32:	4b14      	ldr	r3, [pc, #80]	; (2cf84 <WsfBufInit+0x148>)
   2cf34:	681a      	ldr	r2, [r3, #0]
   2cf36:	89fb      	ldrh	r3, [r7, #14]
   2cf38:	08db      	lsrs	r3, r3, #3
   2cf3a:	b29b      	uxth	r3, r3
   2cf3c:	00db      	lsls	r3, r3, #3
   2cf3e:	4413      	add	r3, r2
   2cf40:	69ba      	ldr	r2, [r7, #24]
   2cf42:	429a      	cmp	r2, r3
   2cf44:	d901      	bls.n	2cf4a <WsfBufInit+0x10e>
    {
      WSF_ASSERT(FALSE);
      return 0;
   2cf46:	2300      	movs	r3, #0
   2cf48:	e015      	b.n	2cf76 <WsfBufInit+0x13a>
    }
    /* last one in list points to NULL */
    pStart->pNext = NULL;
   2cf4a:	69bb      	ldr	r3, [r7, #24]
   2cf4c:	2200      	movs	r2, #0
   2cf4e:	601a      	str	r2, [r3, #0]
    pStart += len;
   2cf50:	8abb      	ldrh	r3, [r7, #20]
   2cf52:	00db      	lsls	r3, r3, #3
   2cf54:	69ba      	ldr	r2, [r7, #24]
   2cf56:	4413      	add	r3, r2
   2cf58:	61bb      	str	r3, [r7, #24]

    /* next pool */
    pPool++;
   2cf5a:	69fb      	ldr	r3, [r7, #28]
   2cf5c:	330c      	adds	r3, #12
   2cf5e:	61fb      	str	r3, [r7, #28]
    if (pStart > &wsfBufMem[bufMemLen / sizeof(wsfBufMem_t)])
   2cf60:	e787      	b.n	2ce72 <WsfBufInit+0x36>
      break;
   2cf62:	bf00      	nop
  }

  wsfBufMemLen = (uint8_t *) pStart - (uint8_t *) wsfBufMem;
   2cf64:	4b07      	ldr	r3, [pc, #28]	; (2cf84 <WsfBufInit+0x148>)
   2cf66:	681b      	ldr	r3, [r3, #0]
   2cf68:	69ba      	ldr	r2, [r7, #24]
   2cf6a:	1ad3      	subs	r3, r2, r3
   2cf6c:	b29a      	uxth	r2, r3
   2cf6e:	4b07      	ldr	r3, [pc, #28]	; (2cf8c <WsfBufInit+0x150>)
   2cf70:	801a      	strh	r2, [r3, #0]
  WSF_TRACE_INFO1("Created buffer pools; using %u bytes", wsfBufMemLen);

  return wsfBufMemLen;
   2cf72:	4b06      	ldr	r3, [pc, #24]	; (2cf8c <WsfBufInit+0x150>)
   2cf74:	881b      	ldrh	r3, [r3, #0]
}
   2cf76:	4618      	mov	r0, r3
   2cf78:	3724      	adds	r7, #36	; 0x24
   2cf7a:	46bd      	mov	sp, r7
   2cf7c:	f85d 7b04 	ldr.w	r7, [sp], #4
   2cf80:	4770      	bx	lr
   2cf82:	bf00      	nop
   2cf84:	1000812c 	.word	0x1000812c
   2cf88:	10011872 	.word	0x10011872
   2cf8c:	10011870 	.word	0x10011870

0002cf90 <WsfBufAlloc>:
 *
 *  \return Pointer to allocated buffer or NULL if allocation fails.
 */
/*************************************************************************************************/
void *WsfBufAlloc(uint16_t len)
{
   2cf90:	b580      	push	{r7, lr}
   2cf92:	b086      	sub	sp, #24
   2cf94:	af00      	add	r7, sp, #0
   2cf96:	4603      	mov	r3, r0
   2cf98:	80fb      	strh	r3, [r7, #6]

  WSF_CS_INIT(cs);

  WSF_ASSERT(len > 0);

  pPool = (wsfBufPool_t *) wsfBufMem;
   2cf9a:	4b1a      	ldr	r3, [pc, #104]	; (2d004 <WsfBufAlloc+0x74>)
   2cf9c:	681b      	ldr	r3, [r3, #0]
   2cf9e:	617b      	str	r3, [r7, #20]

  for (i = wsfBufNumPools; i > 0; i--, pPool++)
   2cfa0:	4b19      	ldr	r3, [pc, #100]	; (2d008 <WsfBufAlloc+0x78>)
   2cfa2:	781b      	ldrb	r3, [r3, #0]
   2cfa4:	74fb      	strb	r3, [r7, #19]
   2cfa6:	e020      	b.n	2cfea <WsfBufAlloc+0x5a>
  {
    /* if buffer is big enough */
    if (len <= pPool->desc.len)
   2cfa8:	697b      	ldr	r3, [r7, #20]
   2cfaa:	881b      	ldrh	r3, [r3, #0]
   2cfac:	88fa      	ldrh	r2, [r7, #6]
   2cfae:	429a      	cmp	r2, r3
   2cfb0:	d815      	bhi.n	2cfde <WsfBufAlloc+0x4e>
    {
      /* enter critical section */
      WSF_CS_ENTER(cs);
   2cfb2:	f000 f8ff 	bl	2d1b4 <WsfCsEnter>

      /* if buffers available */
      if (pPool->pFree != NULL)
   2cfb6:	697b      	ldr	r3, [r7, #20]
   2cfb8:	689b      	ldr	r3, [r3, #8]
   2cfba:	2b00      	cmp	r3, #0
   2cfbc:	d00d      	beq.n	2cfda <WsfBufAlloc+0x4a>
      {
        /* allocation succeeded */
        pBuf = pPool->pFree;
   2cfbe:	697b      	ldr	r3, [r7, #20]
   2cfc0:	689b      	ldr	r3, [r3, #8]
   2cfc2:	60fb      	str	r3, [r7, #12]

        /* next free buffer is stored inside current free buffer */
        pPool->pFree = pBuf->pNext;
   2cfc4:	68fb      	ldr	r3, [r7, #12]
   2cfc6:	681a      	ldr	r2, [r3, #0]
   2cfc8:	697b      	ldr	r3, [r7, #20]
   2cfca:	609a      	str	r2, [r3, #8]

#if WSF_BUF_FREE_CHECK == TRUE
        pBuf->free = 0;
   2cfcc:	68fb      	ldr	r3, [r7, #12]
   2cfce:	2200      	movs	r2, #0
   2cfd0:	605a      	str	r2, [r3, #4]
          pPool->maxAlloc = pPool->numAlloc;
        }
        pPool->maxReqLen = WSF_MAX(pPool->maxReqLen, len);
#endif
        /* exit critical section */
        WSF_CS_EXIT(cs);
   2cfd2:	f000 f903 	bl	2d1dc <WsfCsExit>

        WSF_TRACE_ALLOC2("WsfBufAlloc len:%u pBuf:%08x", pPool->desc.len, pBuf);

        return pBuf;
   2cfd6:	68fb      	ldr	r3, [r7, #12]
   2cfd8:	e010      	b.n	2cffc <WsfBufAlloc+0x6c>
      }

      /* exit critical section */
      WSF_CS_EXIT(cs);
   2cfda:	f000 f8ff 	bl	2d1dc <WsfCsExit>
  for (i = wsfBufNumPools; i > 0; i--, pPool++)
   2cfde:	7cfb      	ldrb	r3, [r7, #19]
   2cfe0:	3b01      	subs	r3, #1
   2cfe2:	74fb      	strb	r3, [r7, #19]
   2cfe4:	697b      	ldr	r3, [r7, #20]
   2cfe6:	330c      	adds	r3, #12
   2cfe8:	617b      	str	r3, [r7, #20]
   2cfea:	7cfb      	ldrb	r3, [r7, #19]
   2cfec:	2b00      	cmp	r3, #0
   2cfee:	d1db      	bne.n	2cfa8 <WsfBufAlloc+0x18>
  else
  {
    WSF_TRACE_WARN2("WsfBufAlloc failed len:%u - task:%u", len, WSF_OS_GET_ACTIVE_HANDLER_ID());
  }
#else
  WSF_TRACE_WARN1("WsfBufAlloc failed len:%u", len);
   2cff0:	88fb      	ldrh	r3, [r7, #6]
   2cff2:	4619      	mov	r1, r3
   2cff4:	4805      	ldr	r0, [pc, #20]	; (2d00c <WsfBufAlloc+0x7c>)
   2cff6:	f000 fccb 	bl	2d990 <WsfTrace>

#if WSF_BUF_ALLOC_FAIL_ASSERT == TRUE
  WSF_ASSERT(FALSE);
#endif

  return NULL;
   2cffa:	2300      	movs	r3, #0
}
   2cffc:	4618      	mov	r0, r3
   2cffe:	3718      	adds	r7, #24
   2d000:	46bd      	mov	sp, r7
   2d002:	bd80      	pop	{r7, pc}
   2d004:	1000812c 	.word	0x1000812c
   2d008:	10011872 	.word	0x10011872
   2d00c:	000451b0 	.word	0x000451b0

0002d010 <WsfBufFree>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfBufFree(void *pBuf)
{
   2d010:	b580      	push	{r7, lr}
   2d012:	b084      	sub	sp, #16
   2d014:	af00      	add	r7, sp, #0
   2d016:	6078      	str	r0, [r7, #4]
  wsfBufPool_t  *pPool;
  wsfBufMem_t   *p = pBuf;
   2d018:	687b      	ldr	r3, [r7, #4]
   2d01a:	60bb      	str	r3, [r7, #8]
  WSF_ASSERT(p >= ((wsfBufPool_t *) wsfBufMem)->pStart);
  WSF_ASSERT(p < (wsfBufMem_t *)(((uint8_t *) wsfBufMem) + wsfBufMemLen));
#endif

  /* iterate over pools starting from last pool */
  pPool = (wsfBufPool_t *) wsfBufMem + (wsfBufNumPools - 1);
   2d01c:	4b16      	ldr	r3, [pc, #88]	; (2d078 <WsfBufFree+0x68>)
   2d01e:	681a      	ldr	r2, [r3, #0]
   2d020:	4b16      	ldr	r3, [pc, #88]	; (2d07c <WsfBufFree+0x6c>)
   2d022:	781b      	ldrb	r3, [r3, #0]
   2d024:	4619      	mov	r1, r3
   2d026:	460b      	mov	r3, r1
   2d028:	005b      	lsls	r3, r3, #1
   2d02a:	440b      	add	r3, r1
   2d02c:	009b      	lsls	r3, r3, #2
   2d02e:	3b0c      	subs	r3, #12
   2d030:	4413      	add	r3, r2
   2d032:	60fb      	str	r3, [r7, #12]
  while (pPool >= (wsfBufPool_t *) wsfBufMem)
   2d034:	e016      	b.n	2d064 <WsfBufFree+0x54>
  {
    /* if the buffer memory is located inside this pool */
    if (p >= pPool->pStart)
   2d036:	68fb      	ldr	r3, [r7, #12]
   2d038:	685b      	ldr	r3, [r3, #4]
   2d03a:	68ba      	ldr	r2, [r7, #8]
   2d03c:	429a      	cmp	r2, r3
   2d03e:	d30e      	bcc.n	2d05e <WsfBufFree+0x4e>
    {
      /* enter critical section */
      WSF_CS_ENTER(cs);
   2d040:	f000 f8b8 	bl	2d1b4 <WsfCsEnter>

#if WSF_BUF_FREE_CHECK == TRUE
      WSF_ASSERT(p->free != WSF_BUF_FREE_NUM);
      p->free = WSF_BUF_FREE_NUM;
   2d044:	68bb      	ldr	r3, [r7, #8]
   2d046:	4a0e      	ldr	r2, [pc, #56]	; (2d080 <WsfBufFree+0x70>)
   2d048:	605a      	str	r2, [r3, #4]
#if WSF_BUF_STATS == TRUE
      pPool->numAlloc--;
#endif

      /* pool found; put buffer back in free list */
      p->pNext = pPool->pFree;
   2d04a:	68fb      	ldr	r3, [r7, #12]
   2d04c:	689a      	ldr	r2, [r3, #8]
   2d04e:	68bb      	ldr	r3, [r7, #8]
   2d050:	601a      	str	r2, [r3, #0]
      pPool->pFree = p;
   2d052:	68fb      	ldr	r3, [r7, #12]
   2d054:	68ba      	ldr	r2, [r7, #8]
   2d056:	609a      	str	r2, [r3, #8]

      /* exit critical section */
      WSF_CS_EXIT(cs);
   2d058:	f000 f8c0 	bl	2d1dc <WsfCsExit>

      WSF_TRACE_FREE2("WsfBufFree len:%u pBuf:%08x", pPool->desc.len, pBuf);

      return;
   2d05c:	e008      	b.n	2d070 <WsfBufFree+0x60>
    }

    /* next pool */
    pPool--;
   2d05e:	68fb      	ldr	r3, [r7, #12]
   2d060:	3b0c      	subs	r3, #12
   2d062:	60fb      	str	r3, [r7, #12]
  while (pPool >= (wsfBufPool_t *) wsfBufMem)
   2d064:	4b04      	ldr	r3, [pc, #16]	; (2d078 <WsfBufFree+0x68>)
   2d066:	681b      	ldr	r3, [r3, #0]
   2d068:	68fa      	ldr	r2, [r7, #12]
   2d06a:	429a      	cmp	r2, r3
   2d06c:	d2e3      	bcs.n	2d036 <WsfBufFree+0x26>
  }

  /* should never get here */
  WSF_ASSERT(FALSE);

  return;
   2d06e:	bf00      	nop
}
   2d070:	3710      	adds	r7, #16
   2d072:	46bd      	mov	sp, r7
   2d074:	bd80      	pop	{r7, pc}
   2d076:	bf00      	nop
   2d078:	1000812c 	.word	0x1000812c
   2d07c:	10011872 	.word	0x10011872
   2d080:	faabd00d 	.word	0xfaabd00d

0002d084 <WsfMsgDataAlloc>:
 *
 *  \return Pointer to data message buffer or NULL if allocation failed.
 */
/*************************************************************************************************/
void *WsfMsgDataAlloc(uint16_t len, uint8_t tailroom)
{
   2d084:	b580      	push	{r7, lr}
   2d086:	b082      	sub	sp, #8
   2d088:	af00      	add	r7, sp, #0
   2d08a:	4603      	mov	r3, r0
   2d08c:	460a      	mov	r2, r1
   2d08e:	80fb      	strh	r3, [r7, #6]
   2d090:	4613      	mov	r3, r2
   2d092:	717b      	strb	r3, [r7, #5]
  return WsfMsgAlloc(len + tailroom);
   2d094:	797b      	ldrb	r3, [r7, #5]
   2d096:	b29a      	uxth	r2, r3
   2d098:	88fb      	ldrh	r3, [r7, #6]
   2d09a:	4413      	add	r3, r2
   2d09c:	b29b      	uxth	r3, r3
   2d09e:	4618      	mov	r0, r3
   2d0a0:	f000 f805 	bl	2d0ae <WsfMsgAlloc>
   2d0a4:	4603      	mov	r3, r0
}
   2d0a6:	4618      	mov	r0, r3
   2d0a8:	3708      	adds	r7, #8
   2d0aa:	46bd      	mov	sp, r7
   2d0ac:	bd80      	pop	{r7, pc}

0002d0ae <WsfMsgAlloc>:
 *
 *  \return Pointer to message buffer or NULL if allocation failed.
 */
/*************************************************************************************************/
void *WsfMsgAlloc(uint16_t len)
{
   2d0ae:	b580      	push	{r7, lr}
   2d0b0:	b084      	sub	sp, #16
   2d0b2:	af00      	add	r7, sp, #0
   2d0b4:	4603      	mov	r3, r0
   2d0b6:	80fb      	strh	r3, [r7, #6]
  wsfMsg_t  *pMsg;

  pMsg = WsfBufAlloc(len + sizeof(wsfMsg_t));
   2d0b8:	88fb      	ldrh	r3, [r7, #6]
   2d0ba:	3308      	adds	r3, #8
   2d0bc:	b29b      	uxth	r3, r3
   2d0be:	4618      	mov	r0, r3
   2d0c0:	f7ff ff66 	bl	2cf90 <WsfBufAlloc>
   2d0c4:	60f8      	str	r0, [r7, #12]

  /* hide header */
  if (pMsg != NULL)
   2d0c6:	68fb      	ldr	r3, [r7, #12]
   2d0c8:	2b00      	cmp	r3, #0
   2d0ca:	d002      	beq.n	2d0d2 <WsfMsgAlloc+0x24>
  {
    pMsg++;
   2d0cc:	68fb      	ldr	r3, [r7, #12]
   2d0ce:	3308      	adds	r3, #8
   2d0d0:	60fb      	str	r3, [r7, #12]
  }

  return pMsg;
   2d0d2:	68fb      	ldr	r3, [r7, #12]
}
   2d0d4:	4618      	mov	r0, r3
   2d0d6:	3710      	adds	r7, #16
   2d0d8:	46bd      	mov	sp, r7
   2d0da:	bd80      	pop	{r7, pc}

0002d0dc <WsfMsgFree>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfMsgFree(void *pMsg)
{
   2d0dc:	b580      	push	{r7, lr}
   2d0de:	b082      	sub	sp, #8
   2d0e0:	af00      	add	r7, sp, #0
   2d0e2:	6078      	str	r0, [r7, #4]
  WsfBufFree(((wsfMsg_t *) pMsg) - 1);
   2d0e4:	687b      	ldr	r3, [r7, #4]
   2d0e6:	3b08      	subs	r3, #8
   2d0e8:	4618      	mov	r0, r3
   2d0ea:	f7ff ff91 	bl	2d010 <WsfBufFree>
}
   2d0ee:	bf00      	nop
   2d0f0:	3708      	adds	r7, #8
   2d0f2:	46bd      	mov	sp, r7
   2d0f4:	bd80      	pop	{r7, pc}

0002d0f6 <WsfMsgSend>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfMsgSend(wsfHandlerId_t handlerId, void *pMsg)
{
   2d0f6:	b580      	push	{r7, lr}
   2d0f8:	b082      	sub	sp, #8
   2d0fa:	af00      	add	r7, sp, #0
   2d0fc:	4603      	mov	r3, r0
   2d0fe:	6039      	str	r1, [r7, #0]
   2d100:	71fb      	strb	r3, [r7, #7]
  WSF_TRACE_MSG1("WsfMsgSend handlerId:%u", handlerId);

  /* get queue for this handler and enqueue message */
  WsfMsgEnq(WsfTaskMsgQueue(handlerId), handlerId, pMsg);
   2d102:	79fb      	ldrb	r3, [r7, #7]
   2d104:	4618      	mov	r0, r3
   2d106:	f000 f923 	bl	2d350 <WsfTaskMsgQueue>
   2d10a:	79fb      	ldrb	r3, [r7, #7]
   2d10c:	683a      	ldr	r2, [r7, #0]
   2d10e:	4619      	mov	r1, r3
   2d110:	f000 f809 	bl	2d126 <WsfMsgEnq>

  /* set task for this handler as ready to run */
  WsfTaskSetReady(handlerId, WSF_MSG_QUEUE_EVENT);
   2d114:	79fb      	ldrb	r3, [r7, #7]
   2d116:	2101      	movs	r1, #1
   2d118:	4618      	mov	r0, r3
   2d11a:	f000 f8fb 	bl	2d314 <WsfTaskSetReady>
}
   2d11e:	bf00      	nop
   2d120:	3708      	adds	r7, #8
   2d122:	46bd      	mov	sp, r7
   2d124:	bd80      	pop	{r7, pc}

0002d126 <WsfMsgEnq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfMsgEnq(wsfQueue_t *pQueue, wsfHandlerId_t handlerId, void *pMsg)
{
   2d126:	b580      	push	{r7, lr}
   2d128:	b086      	sub	sp, #24
   2d12a:	af00      	add	r7, sp, #0
   2d12c:	60f8      	str	r0, [r7, #12]
   2d12e:	460b      	mov	r3, r1
   2d130:	607a      	str	r2, [r7, #4]
   2d132:	72fb      	strb	r3, [r7, #11]
  wsfMsg_t    *p;

  WSF_ASSERT(pMsg != NULL);

  /* get message header */
  p = ((wsfMsg_t *) pMsg) - 1;
   2d134:	687b      	ldr	r3, [r7, #4]
   2d136:	3b08      	subs	r3, #8
   2d138:	617b      	str	r3, [r7, #20]

  /* set handler ID */
  p->handlerId = handlerId;
   2d13a:	697b      	ldr	r3, [r7, #20]
   2d13c:	7afa      	ldrb	r2, [r7, #11]
   2d13e:	711a      	strb	r2, [r3, #4]

  WsfQueueEnq(pQueue, p);
   2d140:	6979      	ldr	r1, [r7, #20]
   2d142:	68f8      	ldr	r0, [r7, #12]
   2d144:	f000 f9f0 	bl	2d528 <WsfQueueEnq>
}
   2d148:	bf00      	nop
   2d14a:	3718      	adds	r7, #24
   2d14c:	46bd      	mov	sp, r7
   2d14e:	bd80      	pop	{r7, pc}

0002d150 <WsfMsgDeq>:
 *
 *  \return Pointer to message that has been dequeued or NULL if queue is empty.
 */
/*************************************************************************************************/
void *WsfMsgDeq(wsfQueue_t *pQueue, wsfHandlerId_t *pHandlerId)
{
   2d150:	b580      	push	{r7, lr}
   2d152:	b084      	sub	sp, #16
   2d154:	af00      	add	r7, sp, #0
   2d156:	6078      	str	r0, [r7, #4]
   2d158:	6039      	str	r1, [r7, #0]
  wsfMsg_t *pMsg;

  if ((pMsg = WsfQueueDeq(pQueue)) != NULL)
   2d15a:	6878      	ldr	r0, [r7, #4]
   2d15c:	f000 fa06 	bl	2d56c <WsfQueueDeq>
   2d160:	60f8      	str	r0, [r7, #12]
   2d162:	68fb      	ldr	r3, [r7, #12]
   2d164:	2b00      	cmp	r3, #0
   2d166:	d006      	beq.n	2d176 <WsfMsgDeq+0x26>
  {
    *pHandlerId = pMsg->handlerId;
   2d168:	68fb      	ldr	r3, [r7, #12]
   2d16a:	791a      	ldrb	r2, [r3, #4]
   2d16c:	683b      	ldr	r3, [r7, #0]
   2d16e:	701a      	strb	r2, [r3, #0]

    /* hide header */
    pMsg++;
   2d170:	68fb      	ldr	r3, [r7, #12]
   2d172:	3308      	adds	r3, #8
   2d174:	60fb      	str	r3, [r7, #12]
  }

  return pMsg;
   2d176:	68fb      	ldr	r3, [r7, #12]
}
   2d178:	4618      	mov	r0, r3
   2d17a:	3710      	adds	r7, #16
   2d17c:	46bd      	mov	sp, r7
   2d17e:	bd80      	pop	{r7, pc}

0002d180 <WsfMsgPeek>:
 *
 *  \return Pointer to the next message on the queue or NULL if queue is empty.
 */
/*************************************************************************************************/
void *WsfMsgPeek(wsfQueue_t *pQueue, wsfHandlerId_t *pHandlerId)
{
   2d180:	b480      	push	{r7}
   2d182:	b085      	sub	sp, #20
   2d184:	af00      	add	r7, sp, #0
   2d186:	6078      	str	r0, [r7, #4]
   2d188:	6039      	str	r1, [r7, #0]
  wsfMsg_t *pMsg = pQueue->pHead;
   2d18a:	687b      	ldr	r3, [r7, #4]
   2d18c:	681b      	ldr	r3, [r3, #0]
   2d18e:	60fb      	str	r3, [r7, #12]

  if (pMsg != NULL)
   2d190:	68fb      	ldr	r3, [r7, #12]
   2d192:	2b00      	cmp	r3, #0
   2d194:	d006      	beq.n	2d1a4 <WsfMsgPeek+0x24>
  {
    *pHandlerId = pMsg->handlerId;
   2d196:	68fb      	ldr	r3, [r7, #12]
   2d198:	791a      	ldrb	r2, [r3, #4]
   2d19a:	683b      	ldr	r3, [r7, #0]
   2d19c:	701a      	strb	r2, [r3, #0]

    /* hide header */
    pMsg++;
   2d19e:	68fb      	ldr	r3, [r7, #12]
   2d1a0:	3308      	adds	r3, #8
   2d1a2:	60fb      	str	r3, [r7, #12]
  }

  return pMsg;
   2d1a4:	68fb      	ldr	r3, [r7, #12]
}
   2d1a6:	4618      	mov	r0, r3
   2d1a8:	3714      	adds	r7, #20
   2d1aa:	46bd      	mov	sp, r7
   2d1ac:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d1b0:	4770      	bx	lr
	...

0002d1b4 <WsfCsEnter>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfCsEnter(void)
{
   2d1b4:	b480      	push	{r7}
   2d1b6:	af00      	add	r7, sp, #0
  if (csNesting == 0)
   2d1b8:	4b07      	ldr	r3, [pc, #28]	; (2d1d8 <WsfCsEnter+0x24>)
   2d1ba:	781b      	ldrb	r3, [r3, #0]
   2d1bc:	2b00      	cmp	r3, #0
   2d1be:	d100      	bne.n	2d1c2 <WsfCsEnter+0xe>
  {
#ifdef __IAR_SYSTEMS_ICC__
    __disable_interrupt();
#endif
#ifdef __GNUC__
    __asm volatile ("cpsid i");
   2d1c0:	b672      	cpsid	i
#ifdef __CC_ARM
  __disable_irq();
#endif

  }
  csNesting++;
   2d1c2:	4b05      	ldr	r3, [pc, #20]	; (2d1d8 <WsfCsEnter+0x24>)
   2d1c4:	781b      	ldrb	r3, [r3, #0]
   2d1c6:	3301      	adds	r3, #1
   2d1c8:	b2da      	uxtb	r2, r3
   2d1ca:	4b03      	ldr	r3, [pc, #12]	; (2d1d8 <WsfCsEnter+0x24>)
   2d1cc:	701a      	strb	r2, [r3, #0]
}
   2d1ce:	bf00      	nop
   2d1d0:	46bd      	mov	sp, r7
   2d1d2:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d1d6:	4770      	bx	lr
   2d1d8:	10008130 	.word	0x10008130

0002d1dc <WsfCsExit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfCsExit(void)
{
   2d1dc:	b480      	push	{r7}
   2d1de:	af00      	add	r7, sp, #0
  WSF_ASSERT(csNesting != 0);

  csNesting--;
   2d1e0:	4b07      	ldr	r3, [pc, #28]	; (2d200 <WsfCsExit+0x24>)
   2d1e2:	781b      	ldrb	r3, [r3, #0]
   2d1e4:	3b01      	subs	r3, #1
   2d1e6:	b2da      	uxtb	r2, r3
   2d1e8:	4b05      	ldr	r3, [pc, #20]	; (2d200 <WsfCsExit+0x24>)
   2d1ea:	701a      	strb	r2, [r3, #0]
  if (csNesting == 0)
   2d1ec:	4b04      	ldr	r3, [pc, #16]	; (2d200 <WsfCsExit+0x24>)
   2d1ee:	781b      	ldrb	r3, [r3, #0]
   2d1f0:	2b00      	cmp	r3, #0
   2d1f2:	d100      	bne.n	2d1f6 <WsfCsExit+0x1a>
  {
#ifdef __IAR_SYSTEMS_ICC__
    __enable_interrupt();
#endif
#ifdef __GNUC__
    __asm volatile ("cpsie i");
   2d1f4:	b662      	cpsie	i
#ifdef __CC_ARM
      __enable_irq();
#endif

  }
}
   2d1f6:	bf00      	nop
   2d1f8:	46bd      	mov	sp, r7
   2d1fa:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d1fe:	4770      	bx	lr
   2d200:	10008130 	.word	0x10008130

0002d204 <WsfTaskLock>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTaskLock(void)
{
   2d204:	b580      	push	{r7, lr}
   2d206:	af00      	add	r7, sp, #0
  WsfCsEnter();
   2d208:	f7ff ffd4 	bl	2d1b4 <WsfCsEnter>
}
   2d20c:	bf00      	nop
   2d20e:	bd80      	pop	{r7, pc}

0002d210 <WsfTaskUnlock>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTaskUnlock(void)
{
   2d210:	b580      	push	{r7, lr}
   2d212:	af00      	add	r7, sp, #0
  WsfCsExit();
   2d214:	f7ff ffe2 	bl	2d1dc <WsfCsExit>
}
   2d218:	bf00      	nop
   2d21a:	bd80      	pop	{r7, pc}

0002d21c <WsfSetOsSpecificEvent>:

void WsfSetOsSpecificEvent(void)
{
   2d21c:	b580      	push	{r7, lr}
   2d21e:	b084      	sub	sp, #16
   2d220:	af00      	add	r7, sp, #0
  if(xRadioTaskEventObject != NULL) 
   2d222:	4b21      	ldr	r3, [pc, #132]	; (2d2a8 <WsfSetOsSpecificEvent+0x8c>)
   2d224:	681b      	ldr	r3, [r3, #0]
   2d226:	2b00      	cmp	r3, #0
   2d228:	d039      	beq.n	2d29e <WsfSetOsSpecificEvent+0x82>
	__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
   2d22a:	f3ef 8305 	mrs	r3, IPSR
   2d22e:	60bb      	str	r3, [r7, #8]
	if( ulCurrentInterrupt == 0 )
   2d230:	68bb      	ldr	r3, [r7, #8]
   2d232:	2b00      	cmp	r3, #0
   2d234:	d102      	bne.n	2d23c <WsfSetOsSpecificEvent+0x20>
		xReturn = pdFALSE;
   2d236:	2300      	movs	r3, #0
   2d238:	607b      	str	r3, [r7, #4]
   2d23a:	e001      	b.n	2d240 <WsfSetOsSpecificEvent+0x24>
		xReturn = pdTRUE;
   2d23c:	2301      	movs	r3, #1
   2d23e:	607b      	str	r3, [r7, #4]
	return xReturn;
   2d240:	687b      	ldr	r3, [r7, #4]
  {

      BaseType_t xHigherPriorityTaskWoken, xResult;

      if(xPortIsInsideInterrupt() == pdTRUE) {
   2d242:	2b01      	cmp	r3, #1
   2d244:	d118      	bne.n	2d278 <WsfSetOsSpecificEvent+0x5c>

          //
          // Send an event to the main radio task
          //
          xHigherPriorityTaskWoken = pdFALSE;
   2d246:	2300      	movs	r3, #0
   2d248:	603b      	str	r3, [r7, #0]

          xResult = xEventGroupSetBitsFromISR(xRadioTaskEventObject, 1,
   2d24a:	4b17      	ldr	r3, [pc, #92]	; (2d2a8 <WsfSetOsSpecificEvent+0x8c>)
   2d24c:	6819      	ldr	r1, [r3, #0]
   2d24e:	463b      	mov	r3, r7
   2d250:	2201      	movs	r2, #1
   2d252:	4816      	ldr	r0, [pc, #88]	; (2d2ac <WsfSetOsSpecificEvent+0x90>)
   2d254:	f7ff fdbe 	bl	2cdd4 <xTimerPendFunctionCallFromISR>
   2d258:	60f8      	str	r0, [r7, #12]

          //
          // If the radio task is higher-priority than the context we're currently
          // running from, we should yield now and run the radio task.
          //
          if ( xResult != pdFAIL )
   2d25a:	68fb      	ldr	r3, [r7, #12]
   2d25c:	2b00      	cmp	r3, #0
   2d25e:	d01e      	beq.n	2d29e <WsfSetOsSpecificEvent+0x82>
          {
              portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2d260:	683b      	ldr	r3, [r7, #0]
   2d262:	2b00      	cmp	r3, #0
   2d264:	d01b      	beq.n	2d29e <WsfSetOsSpecificEvent+0x82>
   2d266:	4b12      	ldr	r3, [pc, #72]	; (2d2b0 <WsfSetOsSpecificEvent+0x94>)
   2d268:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2d26c:	601a      	str	r2, [r3, #0]
   2d26e:	f3bf 8f4f 	dsb	sy
   2d272:	f3bf 8f6f 	isb	sy
              portYIELD();
          }
      }

  }    
}
   2d276:	e012      	b.n	2d29e <WsfSetOsSpecificEvent+0x82>
          xResult = xEventGroupSetBits(xRadioTaskEventObject, 1);
   2d278:	4b0b      	ldr	r3, [pc, #44]	; (2d2a8 <WsfSetOsSpecificEvent+0x8c>)
   2d27a:	681b      	ldr	r3, [r3, #0]
   2d27c:	2101      	movs	r1, #1
   2d27e:	4618      	mov	r0, r3
   2d280:	f7f7 fc14 	bl	24aac <xEventGroupSetBits>
   2d284:	4603      	mov	r3, r0
   2d286:	60fb      	str	r3, [r7, #12]
          if ( xResult != pdFAIL )
   2d288:	68fb      	ldr	r3, [r7, #12]
   2d28a:	2b00      	cmp	r3, #0
   2d28c:	d007      	beq.n	2d29e <WsfSetOsSpecificEvent+0x82>
              portYIELD();
   2d28e:	4b08      	ldr	r3, [pc, #32]	; (2d2b0 <WsfSetOsSpecificEvent+0x94>)
   2d290:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2d294:	601a      	str	r2, [r3, #0]
   2d296:	f3bf 8f4f 	dsb	sy
   2d29a:	f3bf 8f6f 	isb	sy
}
   2d29e:	bf00      	nop
   2d2a0:	3710      	adds	r7, #16
   2d2a2:	46bd      	mov	sp, r7
   2d2a4:	bd80      	pop	{r7, pc}
   2d2a6:	bf00      	nop
   2d2a8:	10008134 	.word	0x10008134
   2d2ac:	00024b87 	.word	0x00024b87
   2d2b0:	e000ed04 	.word	0xe000ed04

0002d2b4 <WsfSetEvent>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfSetEvent(wsfHandlerId_t handlerId, wsfEventMask_t event)
{
   2d2b4:	b580      	push	{r7, lr}
   2d2b6:	b082      	sub	sp, #8
   2d2b8:	af00      	add	r7, sp, #0
   2d2ba:	4603      	mov	r3, r0
   2d2bc:	460a      	mov	r2, r1
   2d2be:	71fb      	strb	r3, [r7, #7]
   2d2c0:	4613      	mov	r3, r2
   2d2c2:	71bb      	strb	r3, [r7, #6]

  WSF_ASSERT(WSF_HANDLER_FROM_ID(handlerId) < WSF_MAX_HANDLERS);

  WSF_TRACE_INFO2("WsfSetEvent handlerId:%u event:%u", handlerId, event);

  WSF_CS_ENTER(cs);
   2d2c4:	f7ff ff76 	bl	2d1b4 <WsfCsEnter>
  wsfOs.task.handlerEventMask[WSF_HANDLER_FROM_ID(handlerId)] |= event;
   2d2c8:	79fb      	ldrb	r3, [r7, #7]
   2d2ca:	f003 030f 	and.w	r3, r3, #15
   2d2ce:	4a10      	ldr	r2, [pc, #64]	; (2d310 <WsfSetEvent+0x5c>)
   2d2d0:	4413      	add	r3, r2
   2d2d2:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
   2d2d6:	79fb      	ldrb	r3, [r7, #7]
   2d2d8:	f003 030f 	and.w	r3, r3, #15
   2d2dc:	79ba      	ldrb	r2, [r7, #6]
   2d2de:	430a      	orrs	r2, r1
   2d2e0:	b2d1      	uxtb	r1, r2
   2d2e2:	4a0b      	ldr	r2, [pc, #44]	; (2d310 <WsfSetEvent+0x5c>)
   2d2e4:	4413      	add	r3, r2
   2d2e6:	460a      	mov	r2, r1
   2d2e8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  wsfOs.task.taskEventMask |= WSF_HANDLER_EVENT;
   2d2ec:	4b08      	ldr	r3, [pc, #32]	; (2d310 <WsfSetEvent+0x5c>)
   2d2ee:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   2d2f2:	f043 0304 	orr.w	r3, r3, #4
   2d2f6:	b2da      	uxtb	r2, r3
   2d2f8:	4b05      	ldr	r3, [pc, #20]	; (2d310 <WsfSetEvent+0x5c>)
   2d2fa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  WSF_CS_EXIT(cs);
   2d2fe:	f7ff ff6d 	bl	2d1dc <WsfCsExit>

  /* set event in OS */

  WsfSetOsSpecificEvent();
   2d302:	f7ff ff8b 	bl	2d21c <WsfSetOsSpecificEvent>
}
   2d306:	bf00      	nop
   2d308:	3708      	adds	r7, #8
   2d30a:	46bd      	mov	sp, r7
   2d30c:	bd80      	pop	{r7, pc}
   2d30e:	bf00      	nop
   2d310:	10011874 	.word	0x10011874

0002d314 <WsfTaskSetReady>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTaskSetReady(wsfHandlerId_t handlerId, wsfTaskEvent_t event)
{
   2d314:	b580      	push	{r7, lr}
   2d316:	b082      	sub	sp, #8
   2d318:	af00      	add	r7, sp, #0
   2d31a:	4603      	mov	r3, r0
   2d31c:	460a      	mov	r2, r1
   2d31e:	71fb      	strb	r3, [r7, #7]
   2d320:	4613      	mov	r3, r2
   2d322:	71bb      	strb	r3, [r7, #6]
  /* Unused parameter */
  (void)handlerId;

  WSF_CS_INIT(cs);

  WSF_CS_ENTER(cs);
   2d324:	f7ff ff46 	bl	2d1b4 <WsfCsEnter>
  wsfOs.task.taskEventMask |= event;
   2d328:	4b08      	ldr	r3, [pc, #32]	; (2d34c <WsfTaskSetReady+0x38>)
   2d32a:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
   2d32e:	79bb      	ldrb	r3, [r7, #6]
   2d330:	4313      	orrs	r3, r2
   2d332:	b2da      	uxtb	r2, r3
   2d334:	4b05      	ldr	r3, [pc, #20]	; (2d34c <WsfTaskSetReady+0x38>)
   2d336:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
  WSF_CS_EXIT(cs);
   2d33a:	f7ff ff4f 	bl	2d1dc <WsfCsExit>

  /* set event in OS */

  WsfSetOsSpecificEvent();
   2d33e:	f7ff ff6d 	bl	2d21c <WsfSetOsSpecificEvent>
}
   2d342:	bf00      	nop
   2d344:	3708      	adds	r7, #8
   2d346:	46bd      	mov	sp, r7
   2d348:	bd80      	pop	{r7, pc}
   2d34a:	bf00      	nop
   2d34c:	10011874 	.word	0x10011874

0002d350 <WsfTaskMsgQueue>:
 *
 *  \return Task message queue.
 */
/*************************************************************************************************/
wsfQueue_t *WsfTaskMsgQueue(wsfHandlerId_t handlerId)
{
   2d350:	b480      	push	{r7}
   2d352:	b083      	sub	sp, #12
   2d354:	af00      	add	r7, sp, #0
   2d356:	4603      	mov	r3, r0
   2d358:	71fb      	strb	r3, [r7, #7]
  /* Unused parameter */
  (void)handlerId;

  return &(wsfOs.task.msgQueue);
   2d35a:	4b03      	ldr	r3, [pc, #12]	; (2d368 <WsfTaskMsgQueue+0x18>)
}
   2d35c:	4618      	mov	r0, r3
   2d35e:	370c      	adds	r7, #12
   2d360:	46bd      	mov	sp, r7
   2d362:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d366:	4770      	bx	lr
   2d368:	100118a4 	.word	0x100118a4

0002d36c <WsfOsSetNextHandler>:
 *
 *  \return WSF handler ID for this handler.
 */
/*************************************************************************************************/
wsfHandlerId_t WsfOsSetNextHandler(wsfEventHandler_t handler)
{
   2d36c:	b480      	push	{r7}
   2d36e:	b085      	sub	sp, #20
   2d370:	af00      	add	r7, sp, #0
   2d372:	6078      	str	r0, [r7, #4]
  wsfHandlerId_t handlerId = wsfOs.task.numHandler++;
   2d374:	4b0a      	ldr	r3, [pc, #40]	; (2d3a0 <WsfOsSetNextHandler+0x34>)
   2d376:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
   2d37a:	1c5a      	adds	r2, r3, #1
   2d37c:	b2d1      	uxtb	r1, r2
   2d37e:	4a08      	ldr	r2, [pc, #32]	; (2d3a0 <WsfOsSetNextHandler+0x34>)
   2d380:	f882 1039 	strb.w	r1, [r2, #57]	; 0x39
   2d384:	73fb      	strb	r3, [r7, #15]

  WSF_ASSERT(handlerId < WSF_MAX_HANDLERS);

  wsfOs.task.handler[handlerId] = handler;
   2d386:	7bfb      	ldrb	r3, [r7, #15]
   2d388:	4905      	ldr	r1, [pc, #20]	; (2d3a0 <WsfOsSetNextHandler+0x34>)
   2d38a:	687a      	ldr	r2, [r7, #4]
   2d38c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

  return handlerId;
   2d390:	7bfb      	ldrb	r3, [r7, #15]
}
   2d392:	4618      	mov	r0, r3
   2d394:	3714      	adds	r7, #20
   2d396:	46bd      	mov	sp, r7
   2d398:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d39c:	4770      	bx	lr
   2d39e:	bf00      	nop
   2d3a0:	10011874 	.word	0x10011874

0002d3a4 <wsfOsReadyToSleep>:
 *
 *  \return Return TRUE if there are no pending WSF task events set, FALSE otherwise.
 */
/*************************************************************************************************/
bool_t wsfOsReadyToSleep(void)
{
   2d3a4:	b480      	push	{r7}
   2d3a6:	af00      	add	r7, sp, #0
  return (wsfOs.task.taskEventMask == 0);
   2d3a8:	4b06      	ldr	r3, [pc, #24]	; (2d3c4 <wsfOsReadyToSleep+0x20>)
   2d3aa:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   2d3ae:	2b00      	cmp	r3, #0
   2d3b0:	bf0c      	ite	eq
   2d3b2:	2301      	moveq	r3, #1
   2d3b4:	2300      	movne	r3, #0
   2d3b6:	b2db      	uxtb	r3, r3
}
   2d3b8:	4618      	mov	r0, r3
   2d3ba:	46bd      	mov	sp, r7
   2d3bc:	f85d 7b04 	ldr.w	r7, [sp], #4
   2d3c0:	4770      	bx	lr
   2d3c2:	bf00      	nop
   2d3c4:	10011874 	.word	0x10011874

0002d3c8 <WsfOsInit>:
*
*  \return None.
*/
/*************************************************************************************************/
void WsfOsInit(void)
{
   2d3c8:	b580      	push	{r7, lr}
   2d3ca:	af00      	add	r7, sp, #0
  memset(&wsfOs, 0, sizeof(wsfOs));
   2d3cc:	223c      	movs	r2, #60	; 0x3c
   2d3ce:	2100      	movs	r1, #0
   2d3d0:	4806      	ldr	r0, [pc, #24]	; (2d3ec <WsfOsInit+0x24>)
   2d3d2:	f002 fe8d 	bl	300f0 <memset>

  if( xRadioTaskEventObject == NULL)
   2d3d6:	4b06      	ldr	r3, [pc, #24]	; (2d3f0 <WsfOsInit+0x28>)
   2d3d8:	681b      	ldr	r3, [r3, #0]
   2d3da:	2b00      	cmp	r3, #0
   2d3dc:	d104      	bne.n	2d3e8 <WsfOsInit+0x20>
  {
    xRadioTaskEventObject = xEventGroupCreate();
   2d3de:	f7f7 fac3 	bl	24968 <xEventGroupCreate>
   2d3e2:	4603      	mov	r3, r0
   2d3e4:	4a02      	ldr	r2, [pc, #8]	; (2d3f0 <WsfOsInit+0x28>)
   2d3e6:	6013      	str	r3, [r2, #0]

    WSF_ASSERT(xRadioTaskEventObject != NULL);
  }
}
   2d3e8:	bf00      	nop
   2d3ea:	bd80      	pop	{r7, pc}
   2d3ec:	10011874 	.word	0x10011874
   2d3f0:	10008134 	.word	0x10008134

0002d3f4 <wsfOsDispatcher>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void wsfOsDispatcher(void)
{
   2d3f4:	b580      	push	{r7, lr}
   2d3f6:	b088      	sub	sp, #32
   2d3f8:	af02      	add	r7, sp, #8
  wsfHandlerId_t    handlerId;
  uint8_t           i;

  WSF_CS_INIT(cs);

  pTask = &wsfOs.task;
   2d3fa:	4b49      	ldr	r3, [pc, #292]	; (2d520 <wsfOsDispatcher+0x12c>)
   2d3fc:	613b      	str	r3, [r7, #16]

  WsfTimerUpdateTicks();
   2d3fe:	f000 faa1 	bl	2d944 <WsfTimerUpdateTicks>

  while (pTask->taskEventMask)
   2d402:	e072      	b.n	2d4ea <wsfOsDispatcher+0xf6>
  {
    /* get and then clear task event mask */
    WSF_CS_ENTER(cs);
   2d404:	f7ff fed6 	bl	2d1b4 <WsfCsEnter>
    taskEventMask = pTask->taskEventMask;
   2d408:	693b      	ldr	r3, [r7, #16]
   2d40a:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   2d40e:	73fb      	strb	r3, [r7, #15]
    pTask->taskEventMask = 0;
   2d410:	693b      	ldr	r3, [r7, #16]
   2d412:	2200      	movs	r2, #0
   2d414:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    WSF_CS_EXIT(cs);
   2d418:	f7ff fee0 	bl	2d1dc <WsfCsExit>

    if (taskEventMask & WSF_MSG_QUEUE_EVENT)
   2d41c:	7bfb      	ldrb	r3, [r7, #15]
   2d41e:	f003 0301 	and.w	r3, r3, #1
   2d422:	2b00      	cmp	r3, #0
   2d424:	d016      	beq.n	2d454 <wsfOsDispatcher+0x60>
    {
      /* handle msg queue */
      while ((pMsg = WsfMsgDeq(&pTask->msgQueue, &handlerId)) != NULL)
   2d426:	e00a      	b.n	2d43e <wsfOsDispatcher+0x4a>
      {
        WSF_ASSERT(handlerId < WSF_MAX_HANDLERS);
        (*pTask->handler[handlerId])(0, pMsg);
   2d428:	78bb      	ldrb	r3, [r7, #2]
   2d42a:	461a      	mov	r2, r3
   2d42c:	693b      	ldr	r3, [r7, #16]
   2d42e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   2d432:	68b9      	ldr	r1, [r7, #8]
   2d434:	2000      	movs	r0, #0
   2d436:	4798      	blx	r3
        WsfMsgFree(pMsg);
   2d438:	68b8      	ldr	r0, [r7, #8]
   2d43a:	f7ff fe4f 	bl	2d0dc <WsfMsgFree>
      while ((pMsg = WsfMsgDeq(&pTask->msgQueue, &handlerId)) != NULL)
   2d43e:	693b      	ldr	r3, [r7, #16]
   2d440:	3330      	adds	r3, #48	; 0x30
   2d442:	1cba      	adds	r2, r7, #2
   2d444:	4611      	mov	r1, r2
   2d446:	4618      	mov	r0, r3
   2d448:	f7ff fe82 	bl	2d150 <WsfMsgDeq>
   2d44c:	60b8      	str	r0, [r7, #8]
   2d44e:	68bb      	ldr	r3, [r7, #8]
   2d450:	2b00      	cmp	r3, #0
   2d452:	d1e9      	bne.n	2d428 <wsfOsDispatcher+0x34>
      }
    }

    if (taskEventMask & WSF_TIMER_EVENT)
   2d454:	7bfb      	ldrb	r3, [r7, #15]
   2d456:	f003 0302 	and.w	r3, r3, #2
   2d45a:	2b00      	cmp	r3, #0
   2d45c:	d012      	beq.n	2d484 <wsfOsDispatcher+0x90>
    {
      /* service timers */
      while ((pTimer = WsfTimerServiceExpired(0)) != NULL)
   2d45e:	e00a      	b.n	2d476 <wsfOsDispatcher+0x82>
      {
        WSF_ASSERT(pTimer->handlerId < WSF_MAX_HANDLERS);
        (*pTask->handler[pTimer->handlerId])(0, &pTimer->msg);
   2d460:	687b      	ldr	r3, [r7, #4]
   2d462:	7b1b      	ldrb	r3, [r3, #12]
   2d464:	461a      	mov	r2, r3
   2d466:	693b      	ldr	r3, [r7, #16]
   2d468:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   2d46c:	687a      	ldr	r2, [r7, #4]
   2d46e:	3208      	adds	r2, #8
   2d470:	4611      	mov	r1, r2
   2d472:	2000      	movs	r0, #0
   2d474:	4798      	blx	r3
      while ((pTimer = WsfTimerServiceExpired(0)) != NULL)
   2d476:	2000      	movs	r0, #0
   2d478:	f000 fa3c 	bl	2d8f4 <WsfTimerServiceExpired>
   2d47c:	6078      	str	r0, [r7, #4]
   2d47e:	687b      	ldr	r3, [r7, #4]
   2d480:	2b00      	cmp	r3, #0
   2d482:	d1ed      	bne.n	2d460 <wsfOsDispatcher+0x6c>
      }
    }

    if (taskEventMask & WSF_HANDLER_EVENT)
   2d484:	7bfb      	ldrb	r3, [r7, #15]
   2d486:	f003 0304 	and.w	r3, r3, #4
   2d48a:	2b00      	cmp	r3, #0
   2d48c:	d02d      	beq.n	2d4ea <wsfOsDispatcher+0xf6>
    {
      /* service handlers */
      for (i = 0; i < WSF_MAX_HANDLERS; i++)
   2d48e:	2300      	movs	r3, #0
   2d490:	75fb      	strb	r3, [r7, #23]
   2d492:	e027      	b.n	2d4e4 <wsfOsDispatcher+0xf0>
      {
        if ((pTask->handlerEventMask[i] != 0) && (pTask->handler[i] != NULL))
   2d494:	7dfb      	ldrb	r3, [r7, #23]
   2d496:	693a      	ldr	r2, [r7, #16]
   2d498:	4413      	add	r3, r2
   2d49a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   2d49e:	2b00      	cmp	r3, #0
   2d4a0:	d01d      	beq.n	2d4de <wsfOsDispatcher+0xea>
   2d4a2:	7dfa      	ldrb	r2, [r7, #23]
   2d4a4:	693b      	ldr	r3, [r7, #16]
   2d4a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   2d4aa:	2b00      	cmp	r3, #0
   2d4ac:	d017      	beq.n	2d4de <wsfOsDispatcher+0xea>
        {
          WSF_CS_ENTER(cs);
   2d4ae:	f7ff fe81 	bl	2d1b4 <WsfCsEnter>
          eventMask = pTask->handlerEventMask[i];
   2d4b2:	7dfb      	ldrb	r3, [r7, #23]
   2d4b4:	693a      	ldr	r2, [r7, #16]
   2d4b6:	4413      	add	r3, r2
   2d4b8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
   2d4bc:	70fb      	strb	r3, [r7, #3]
          pTask->handlerEventMask[i] = 0;
   2d4be:	7dfb      	ldrb	r3, [r7, #23]
   2d4c0:	693a      	ldr	r2, [r7, #16]
   2d4c2:	4413      	add	r3, r2
   2d4c4:	2200      	movs	r2, #0
   2d4c6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
          WSF_CS_EXIT(cs);
   2d4ca:	f7ff fe87 	bl	2d1dc <WsfCsExit>

          (*pTask->handler[i])(eventMask, NULL);
   2d4ce:	7dfa      	ldrb	r2, [r7, #23]
   2d4d0:	693b      	ldr	r3, [r7, #16]
   2d4d2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   2d4d6:	78fa      	ldrb	r2, [r7, #3]
   2d4d8:	2100      	movs	r1, #0
   2d4da:	4610      	mov	r0, r2
   2d4dc:	4798      	blx	r3
      for (i = 0; i < WSF_MAX_HANDLERS; i++)
   2d4de:	7dfb      	ldrb	r3, [r7, #23]
   2d4e0:	3301      	adds	r3, #1
   2d4e2:	75fb      	strb	r3, [r7, #23]
   2d4e4:	7dfb      	ldrb	r3, [r7, #23]
   2d4e6:	2b08      	cmp	r3, #8
   2d4e8:	d9d4      	bls.n	2d494 <wsfOsDispatcher+0xa0>
  while (pTask->taskEventMask)
   2d4ea:	693b      	ldr	r3, [r7, #16]
   2d4ec:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
   2d4f0:	2b00      	cmp	r3, #0
   2d4f2:	d187      	bne.n	2d404 <wsfOsDispatcher+0x10>
        }
      }
    }
  }

  WsfTimerUpdateTicks();
   2d4f4:	f000 fa26 	bl	2d944 <WsfTimerUpdateTicks>

  if (wsfOsReadyToSleep())
   2d4f8:	f7ff ff54 	bl	2d3a4 <wsfOsReadyToSleep>
   2d4fc:	4603      	mov	r3, r0
   2d4fe:	2b00      	cmp	r3, #0
   2d500:	d009      	beq.n	2d516 <wsfOsDispatcher+0x122>
  {
    xEventGroupWaitBits(xRadioTaskEventObject, 1, pdTRUE,
   2d502:	4b08      	ldr	r3, [pc, #32]	; (2d524 <wsfOsDispatcher+0x130>)
   2d504:	6818      	ldr	r0, [r3, #0]
   2d506:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2d50a:	9300      	str	r3, [sp, #0]
   2d50c:	2300      	movs	r3, #0
   2d50e:	2201      	movs	r2, #1
   2d510:	2101      	movs	r1, #1
   2d512:	f7f7 fa41 	bl	24998 <xEventGroupWaitBits>
                      pdFALSE, portMAX_DELAY);
  }

}
   2d516:	bf00      	nop
   2d518:	3718      	adds	r7, #24
   2d51a:	46bd      	mov	sp, r7
   2d51c:	bd80      	pop	{r7, pc}
   2d51e:	bf00      	nop
   2d520:	10011874 	.word	0x10011874
   2d524:	10008134 	.word	0x10008134

0002d528 <WsfQueueEnq>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfQueueEnq(wsfQueue_t *pQueue, void *pElem)
{
   2d528:	b580      	push	{r7, lr}
   2d52a:	b082      	sub	sp, #8
   2d52c:	af00      	add	r7, sp, #0
   2d52e:	6078      	str	r0, [r7, #4]
   2d530:	6039      	str	r1, [r7, #0]

  WSF_ASSERT(pQueue != NULL);
  WSF_ASSERT(pElem != NULL);

  /* initialize next pointer */
  WSF_QUEUE_NEXT(pElem) = NULL;
   2d532:	683b      	ldr	r3, [r7, #0]
   2d534:	2200      	movs	r2, #0
   2d536:	601a      	str	r2, [r3, #0]

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d538:	f7ff fe3c 	bl	2d1b4 <WsfCsEnter>

  /* if queue empty */
  if (pQueue->pHead == NULL)
   2d53c:	687b      	ldr	r3, [r7, #4]
   2d53e:	681b      	ldr	r3, [r3, #0]
   2d540:	2b00      	cmp	r3, #0
   2d542:	d106      	bne.n	2d552 <WsfQueueEnq+0x2a>
  {
    pQueue->pHead = pElem;
   2d544:	687b      	ldr	r3, [r7, #4]
   2d546:	683a      	ldr	r2, [r7, #0]
   2d548:	601a      	str	r2, [r3, #0]
    pQueue->pTail = pElem;
   2d54a:	687b      	ldr	r3, [r7, #4]
   2d54c:	683a      	ldr	r2, [r7, #0]
   2d54e:	605a      	str	r2, [r3, #4]
   2d550:	e006      	b.n	2d560 <WsfQueueEnq+0x38>
  }
  /* else enqueue element to the tail of queue */
  else
  {
    WSF_QUEUE_NEXT(pQueue->pTail) = pElem;
   2d552:	687b      	ldr	r3, [r7, #4]
   2d554:	685b      	ldr	r3, [r3, #4]
   2d556:	683a      	ldr	r2, [r7, #0]
   2d558:	601a      	str	r2, [r3, #0]
    pQueue->pTail = pElem;
   2d55a:	687b      	ldr	r3, [r7, #4]
   2d55c:	683a      	ldr	r2, [r7, #0]
   2d55e:	605a      	str	r2, [r3, #4]
  }

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d560:	f7ff fe3c 	bl	2d1dc <WsfCsExit>
}
   2d564:	bf00      	nop
   2d566:	3708      	adds	r7, #8
   2d568:	46bd      	mov	sp, r7
   2d56a:	bd80      	pop	{r7, pc}

0002d56c <WsfQueueDeq>:
 *
 *  \return Pointer to element that has been dequeued or NULL if queue is empty.
 */
/*************************************************************************************************/
void *WsfQueueDeq(wsfQueue_t *pQueue)
{
   2d56c:	b580      	push	{r7, lr}
   2d56e:	b084      	sub	sp, #16
   2d570:	af00      	add	r7, sp, #0
   2d572:	6078      	str	r0, [r7, #4]
  WSF_CS_INIT(cs);

  WSF_ASSERT(pQueue != NULL);

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d574:	f7ff fe1e 	bl	2d1b4 <WsfCsEnter>

  pElem = pQueue->pHead;
   2d578:	687b      	ldr	r3, [r7, #4]
   2d57a:	681b      	ldr	r3, [r3, #0]
   2d57c:	60fb      	str	r3, [r7, #12]

  /* if queue is not empty */
  if (pElem != NULL)
   2d57e:	68fb      	ldr	r3, [r7, #12]
   2d580:	2b00      	cmp	r3, #0
   2d582:	d00a      	beq.n	2d59a <WsfQueueDeq+0x2e>
  {
    /* set head to next element in queue */
    pQueue->pHead = WSF_QUEUE_NEXT(pElem);
   2d584:	68fb      	ldr	r3, [r7, #12]
   2d586:	681a      	ldr	r2, [r3, #0]
   2d588:	687b      	ldr	r3, [r7, #4]
   2d58a:	601a      	str	r2, [r3, #0]

    /* check for empty queue */
    if (pQueue->pHead == NULL)
   2d58c:	687b      	ldr	r3, [r7, #4]
   2d58e:	681b      	ldr	r3, [r3, #0]
   2d590:	2b00      	cmp	r3, #0
   2d592:	d102      	bne.n	2d59a <WsfQueueDeq+0x2e>
    {
      pQueue->pTail = NULL;
   2d594:	687b      	ldr	r3, [r7, #4]
   2d596:	2200      	movs	r2, #0
   2d598:	605a      	str	r2, [r3, #4]
    }
  }

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d59a:	f7ff fe1f 	bl	2d1dc <WsfCsExit>

  return pElem;
   2d59e:	68fb      	ldr	r3, [r7, #12]
}
   2d5a0:	4618      	mov	r0, r3
   2d5a2:	3710      	adds	r7, #16
   2d5a4:	46bd      	mov	sp, r7
   2d5a6:	bd80      	pop	{r7, pc}

0002d5a8 <WsfQueuePush>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfQueuePush(wsfQueue_t *pQueue, void *pElem)
{
   2d5a8:	b580      	push	{r7, lr}
   2d5aa:	b082      	sub	sp, #8
   2d5ac:	af00      	add	r7, sp, #0
   2d5ae:	6078      	str	r0, [r7, #4]
   2d5b0:	6039      	str	r1, [r7, #0]

  WSF_ASSERT(pQueue != NULL);
  WSF_ASSERT(pElem != NULL);

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d5b2:	f7ff fdff 	bl	2d1b4 <WsfCsEnter>

  /* else push element to head of queue */
  WSF_QUEUE_NEXT(pElem) = pQueue->pHead;
   2d5b6:	687b      	ldr	r3, [r7, #4]
   2d5b8:	681a      	ldr	r2, [r3, #0]
   2d5ba:	683b      	ldr	r3, [r7, #0]
   2d5bc:	601a      	str	r2, [r3, #0]

  /* if queue was empty set tail */
  if (pQueue->pHead == NULL)
   2d5be:	687b      	ldr	r3, [r7, #4]
   2d5c0:	681b      	ldr	r3, [r3, #0]
   2d5c2:	2b00      	cmp	r3, #0
   2d5c4:	d102      	bne.n	2d5cc <WsfQueuePush+0x24>
  {
    pQueue->pTail = pElem;
   2d5c6:	687b      	ldr	r3, [r7, #4]
   2d5c8:	683a      	ldr	r2, [r7, #0]
   2d5ca:	605a      	str	r2, [r3, #4]
  }

  /* set head */
  pQueue->pHead = pElem;
   2d5cc:	687b      	ldr	r3, [r7, #4]
   2d5ce:	683a      	ldr	r2, [r7, #0]
   2d5d0:	601a      	str	r2, [r3, #0]

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d5d2:	f7ff fe03 	bl	2d1dc <WsfCsExit>
}
   2d5d6:	bf00      	nop
   2d5d8:	3708      	adds	r7, #8
   2d5da:	46bd      	mov	sp, r7
   2d5dc:	bd80      	pop	{r7, pc}

0002d5de <WsfQueueInsert>:
 *                    Note:  set pPrev to NULL if pElem is first element in queue.
 *  \return None.
 */
/*************************************************************************************************/
void WsfQueueInsert(wsfQueue_t *pQueue, void *pElem, void *pPrev)
{
   2d5de:	b580      	push	{r7, lr}
   2d5e0:	b084      	sub	sp, #16
   2d5e2:	af00      	add	r7, sp, #0
   2d5e4:	60f8      	str	r0, [r7, #12]
   2d5e6:	60b9      	str	r1, [r7, #8]
   2d5e8:	607a      	str	r2, [r7, #4]

  WSF_ASSERT(pQueue != NULL);
  WSF_ASSERT(pElem != NULL);

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d5ea:	f7ff fde3 	bl	2d1b4 <WsfCsEnter>

  /* if queue empty or inserting at tail */
  if (pQueue->pHead == NULL || pPrev == pQueue->pTail)
   2d5ee:	68fb      	ldr	r3, [r7, #12]
   2d5f0:	681b      	ldr	r3, [r3, #0]
   2d5f2:	2b00      	cmp	r3, #0
   2d5f4:	d004      	beq.n	2d600 <WsfQueueInsert+0x22>
   2d5f6:	68fb      	ldr	r3, [r7, #12]
   2d5f8:	685b      	ldr	r3, [r3, #4]
   2d5fa:	687a      	ldr	r2, [r7, #4]
   2d5fc:	429a      	cmp	r2, r3
   2d5fe:	d104      	bne.n	2d60a <WsfQueueInsert+0x2c>
  {
    /* queue as normal */
    WsfQueueEnq(pQueue, pElem);
   2d600:	68b9      	ldr	r1, [r7, #8]
   2d602:	68f8      	ldr	r0, [r7, #12]
   2d604:	f7ff ff90 	bl	2d528 <WsfQueueEnq>
   2d608:	e00e      	b.n	2d628 <WsfQueueInsert+0x4a>
  }
  /* else if inserting at head */
  else if (pPrev == NULL)
   2d60a:	687b      	ldr	r3, [r7, #4]
   2d60c:	2b00      	cmp	r3, #0
   2d60e:	d104      	bne.n	2d61a <WsfQueueInsert+0x3c>
  {
    /* push to head */
    WsfQueuePush(pQueue, pElem);
   2d610:	68b9      	ldr	r1, [r7, #8]
   2d612:	68f8      	ldr	r0, [r7, #12]
   2d614:	f7ff ffc8 	bl	2d5a8 <WsfQueuePush>
   2d618:	e006      	b.n	2d628 <WsfQueueInsert+0x4a>
  }
  else
  {
    /* insert in middle of queue */
    WSF_QUEUE_NEXT(pElem) = WSF_QUEUE_NEXT(pPrev);
   2d61a:	687b      	ldr	r3, [r7, #4]
   2d61c:	681a      	ldr	r2, [r3, #0]
   2d61e:	68bb      	ldr	r3, [r7, #8]
   2d620:	601a      	str	r2, [r3, #0]
    WSF_QUEUE_NEXT(pPrev) = pElem;
   2d622:	687b      	ldr	r3, [r7, #4]
   2d624:	68ba      	ldr	r2, [r7, #8]
   2d626:	601a      	str	r2, [r3, #0]
  }

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d628:	f7ff fdd8 	bl	2d1dc <WsfCsExit>
}
   2d62c:	bf00      	nop
   2d62e:	3710      	adds	r7, #16
   2d630:	46bd      	mov	sp, r7
   2d632:	bd80      	pop	{r7, pc}

0002d634 <WsfQueueRemove>:
 *                    Note:  set pPrev to NULL if pElem is first element in queue.
 *  \return None.
 */
/*************************************************************************************************/
void WsfQueueRemove(wsfQueue_t *pQueue, void *pElem, void *pPrev)
{
   2d634:	b580      	push	{r7, lr}
   2d636:	b084      	sub	sp, #16
   2d638:	af00      	add	r7, sp, #0
   2d63a:	60f8      	str	r0, [r7, #12]
   2d63c:	60b9      	str	r1, [r7, #8]
   2d63e:	607a      	str	r2, [r7, #4]
  WSF_ASSERT(pQueue != NULL);
  WSF_ASSERT(pQueue->pHead != NULL);
  WSF_ASSERT(pElem != NULL);

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d640:	f7ff fdb8 	bl	2d1b4 <WsfCsEnter>

  /* if first element */
  if (pElem == pQueue->pHead)
   2d644:	68fb      	ldr	r3, [r7, #12]
   2d646:	681b      	ldr	r3, [r3, #0]
   2d648:	68ba      	ldr	r2, [r7, #8]
   2d64a:	429a      	cmp	r2, r3
   2d64c:	d104      	bne.n	2d658 <WsfQueueRemove+0x24>
  {
    /* remove from head of queue */
    pQueue->pHead = WSF_QUEUE_NEXT(pElem);
   2d64e:	68bb      	ldr	r3, [r7, #8]
   2d650:	681a      	ldr	r2, [r3, #0]
   2d652:	68fb      	ldr	r3, [r7, #12]
   2d654:	601a      	str	r2, [r3, #0]
   2d656:	e006      	b.n	2d666 <WsfQueueRemove+0x32>
  }
  else if (pPrev)
   2d658:	687b      	ldr	r3, [r7, #4]
   2d65a:	2b00      	cmp	r3, #0
   2d65c:	d003      	beq.n	2d666 <WsfQueueRemove+0x32>
  {
    /* remove from middle of queue, pPrev will never be null */
    WSF_QUEUE_NEXT(pPrev) = WSF_QUEUE_NEXT(pElem);
   2d65e:	68bb      	ldr	r3, [r7, #8]
   2d660:	681a      	ldr	r2, [r3, #0]
   2d662:	687b      	ldr	r3, [r7, #4]
   2d664:	601a      	str	r2, [r3, #0]
  }

  /* if last element */
  if (pElem == pQueue->pTail)
   2d666:	68fb      	ldr	r3, [r7, #12]
   2d668:	685b      	ldr	r3, [r3, #4]
   2d66a:	68ba      	ldr	r2, [r7, #8]
   2d66c:	429a      	cmp	r2, r3
   2d66e:	d102      	bne.n	2d676 <WsfQueueRemove+0x42>
  {
    /* update tail */
    pQueue->pTail = pPrev;
   2d670:	68fb      	ldr	r3, [r7, #12]
   2d672:	687a      	ldr	r2, [r7, #4]
   2d674:	605a      	str	r2, [r3, #4]
  }

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d676:	f7ff fdb1 	bl	2d1dc <WsfCsExit>
}
   2d67a:	bf00      	nop
   2d67c:	3710      	adds	r7, #16
   2d67e:	46bd      	mov	sp, r7
   2d680:	bd80      	pop	{r7, pc}

0002d682 <WsfQueueCount>:
 *
 *  \return Number of elements in queue.
 */
/*************************************************************************************************/
uint16_t WsfQueueCount(wsfQueue_t *pQueue)
{
   2d682:	b580      	push	{r7, lr}
   2d684:	b084      	sub	sp, #16
   2d686:	af00      	add	r7, sp, #0
   2d688:	6078      	str	r0, [r7, #4]
  wsfQueueElem_t  *pElem;
  uint16_t        count = 0;
   2d68a:	2300      	movs	r3, #0
   2d68c:	817b      	strh	r3, [r7, #10]
  WSF_CS_INIT(cs);

  WSF_ASSERT(pQueue != NULL);

  /* enter critical section */
  WSF_CS_ENTER(cs);
   2d68e:	f7ff fd91 	bl	2d1b4 <WsfCsEnter>

  pElem = pQueue->pHead;
   2d692:	687b      	ldr	r3, [r7, #4]
   2d694:	681b      	ldr	r3, [r3, #0]
   2d696:	60fb      	str	r3, [r7, #12]

  /* iterate over queue */
  while (pElem != NULL)
   2d698:	e005      	b.n	2d6a6 <WsfQueueCount+0x24>
  {
    count++;
   2d69a:	897b      	ldrh	r3, [r7, #10]
   2d69c:	3301      	adds	r3, #1
   2d69e:	817b      	strh	r3, [r7, #10]
    pElem = pElem->pNext;
   2d6a0:	68fb      	ldr	r3, [r7, #12]
   2d6a2:	681b      	ldr	r3, [r3, #0]
   2d6a4:	60fb      	str	r3, [r7, #12]
  while (pElem != NULL)
   2d6a6:	68fb      	ldr	r3, [r7, #12]
   2d6a8:	2b00      	cmp	r3, #0
   2d6aa:	d1f6      	bne.n	2d69a <WsfQueueCount+0x18>
  }

  /* exit critical section */
  WSF_CS_EXIT(cs);
   2d6ac:	f7ff fd96 	bl	2d1dc <WsfCsExit>

  return count;
   2d6b0:	897b      	ldrh	r3, [r7, #10]
}
   2d6b2:	4618      	mov	r0, r3
   2d6b4:	3710      	adds	r7, #16
   2d6b6:	46bd      	mov	sp, r7
   2d6b8:	bd80      	pop	{r7, pc}
	...

0002d6bc <wsfTimerRemove>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void wsfTimerRemove(wsfTimer_t *pTimer)
{
   2d6bc:	b580      	push	{r7, lr}
   2d6be:	b084      	sub	sp, #16
   2d6c0:	af00      	add	r7, sp, #0
   2d6c2:	6078      	str	r0, [r7, #4]
  wsfTimer_t  *pElem;
  wsfTimer_t  *pPrev = NULL;
   2d6c4:	2300      	movs	r3, #0
   2d6c6:	60bb      	str	r3, [r7, #8]

  pElem = (wsfTimer_t *) wsfTimerTimerQueue.pHead;
   2d6c8:	4b10      	ldr	r3, [pc, #64]	; (2d70c <wsfTimerRemove+0x50>)
   2d6ca:	681b      	ldr	r3, [r3, #0]
   2d6cc:	60fb      	str	r3, [r7, #12]

  /* find timer in queue */
  while (pElem != NULL)
   2d6ce:	e008      	b.n	2d6e2 <wsfTimerRemove+0x26>
  {
    if (pElem == pTimer)
   2d6d0:	68fa      	ldr	r2, [r7, #12]
   2d6d2:	687b      	ldr	r3, [r7, #4]
   2d6d4:	429a      	cmp	r2, r3
   2d6d6:	d008      	beq.n	2d6ea <wsfTimerRemove+0x2e>
    {
      break;
    }
    pPrev = pElem;
   2d6d8:	68fb      	ldr	r3, [r7, #12]
   2d6da:	60bb      	str	r3, [r7, #8]
    pElem = pElem->pNext;
   2d6dc:	68fb      	ldr	r3, [r7, #12]
   2d6de:	681b      	ldr	r3, [r3, #0]
   2d6e0:	60fb      	str	r3, [r7, #12]
  while (pElem != NULL)
   2d6e2:	68fb      	ldr	r3, [r7, #12]
   2d6e4:	2b00      	cmp	r3, #0
   2d6e6:	d1f3      	bne.n	2d6d0 <wsfTimerRemove+0x14>
   2d6e8:	e000      	b.n	2d6ec <wsfTimerRemove+0x30>
      break;
   2d6ea:	bf00      	nop
  }

  /* if timer found remove from queue */
  if (pElem != NULL)
   2d6ec:	68fb      	ldr	r3, [r7, #12]
   2d6ee:	2b00      	cmp	r3, #0
   2d6f0:	d007      	beq.n	2d702 <wsfTimerRemove+0x46>
  {
    WsfQueueRemove(&wsfTimerTimerQueue, pTimer, pPrev);
   2d6f2:	68ba      	ldr	r2, [r7, #8]
   2d6f4:	6879      	ldr	r1, [r7, #4]
   2d6f6:	4805      	ldr	r0, [pc, #20]	; (2d70c <wsfTimerRemove+0x50>)
   2d6f8:	f7ff ff9c 	bl	2d634 <WsfQueueRemove>

    pTimer->isStarted = FALSE;
   2d6fc:	687b      	ldr	r3, [r7, #4]
   2d6fe:	2200      	movs	r2, #0
   2d700:	735a      	strb	r2, [r3, #13]
  }
}
   2d702:	bf00      	nop
   2d704:	3710      	adds	r7, #16
   2d706:	46bd      	mov	sp, r7
   2d708:	bd80      	pop	{r7, pc}
   2d70a:	bf00      	nop
   2d70c:	100118b0 	.word	0x100118b0

0002d710 <wsfTimerInsert>:
 *
 *  \return None.
 */
/*************************************************************************************************/
static void wsfTimerInsert(wsfTimer_t *pTimer, wsfTimerTicks_t ticks)
{
   2d710:	b580      	push	{r7, lr}
   2d712:	b084      	sub	sp, #16
   2d714:	af00      	add	r7, sp, #0
   2d716:	6078      	str	r0, [r7, #4]
   2d718:	6039      	str	r1, [r7, #0]
  wsfTimer_t  *pElem;
  wsfTimer_t  *pPrev = NULL;
   2d71a:	2300      	movs	r3, #0
   2d71c:	60bb      	str	r3, [r7, #8]

  /* task schedule lock */
  WsfTaskLock();
   2d71e:	f7ff fd71 	bl	2d204 <WsfTaskLock>

  /* if timer is already running stop it first */
  if (pTimer->isStarted)
   2d722:	687b      	ldr	r3, [r7, #4]
   2d724:	7b5b      	ldrb	r3, [r3, #13]
   2d726:	2b00      	cmp	r3, #0
   2d728:	d002      	beq.n	2d730 <wsfTimerInsert+0x20>
  {
    wsfTimerRemove(pTimer);
   2d72a:	6878      	ldr	r0, [r7, #4]
   2d72c:	f7ff ffc6 	bl	2d6bc <wsfTimerRemove>
  }

  pTimer->isStarted = TRUE;
   2d730:	687b      	ldr	r3, [r7, #4]
   2d732:	2201      	movs	r2, #1
   2d734:	735a      	strb	r2, [r3, #13]
  pTimer->ticks = ticks;
   2d736:	687b      	ldr	r3, [r7, #4]
   2d738:	683a      	ldr	r2, [r7, #0]
   2d73a:	605a      	str	r2, [r3, #4]

  pElem = (wsfTimer_t *) wsfTimerTimerQueue.pHead;
   2d73c:	4b0f      	ldr	r3, [pc, #60]	; (2d77c <wsfTimerInsert+0x6c>)
   2d73e:	681b      	ldr	r3, [r3, #0]
   2d740:	60fb      	str	r3, [r7, #12]

  /* find insertion point in queue */
  while (pElem != NULL)
   2d742:	e00a      	b.n	2d75a <wsfTimerInsert+0x4a>
  {
    if (pTimer->ticks < pElem->ticks)
   2d744:	687b      	ldr	r3, [r7, #4]
   2d746:	685a      	ldr	r2, [r3, #4]
   2d748:	68fb      	ldr	r3, [r7, #12]
   2d74a:	685b      	ldr	r3, [r3, #4]
   2d74c:	429a      	cmp	r2, r3
   2d74e:	d308      	bcc.n	2d762 <wsfTimerInsert+0x52>
    {
      break;
    }
    pPrev = pElem;
   2d750:	68fb      	ldr	r3, [r7, #12]
   2d752:	60bb      	str	r3, [r7, #8]
    pElem = pElem->pNext;
   2d754:	68fb      	ldr	r3, [r7, #12]
   2d756:	681b      	ldr	r3, [r3, #0]
   2d758:	60fb      	str	r3, [r7, #12]
  while (pElem != NULL)
   2d75a:	68fb      	ldr	r3, [r7, #12]
   2d75c:	2b00      	cmp	r3, #0
   2d75e:	d1f1      	bne.n	2d744 <wsfTimerInsert+0x34>
   2d760:	e000      	b.n	2d764 <wsfTimerInsert+0x54>
      break;
   2d762:	bf00      	nop
  }

  /* insert timer into queue */
  WsfQueueInsert(&wsfTimerTimerQueue, pTimer, pPrev);
   2d764:	68ba      	ldr	r2, [r7, #8]
   2d766:	6879      	ldr	r1, [r7, #4]
   2d768:	4804      	ldr	r0, [pc, #16]	; (2d77c <wsfTimerInsert+0x6c>)
   2d76a:	f7ff ff38 	bl	2d5de <WsfQueueInsert>

  /* task schedule unlock */
  WsfTaskUnlock();
   2d76e:	f7ff fd4f 	bl	2d210 <WsfTaskUnlock>
}
   2d772:	bf00      	nop
   2d774:	3710      	adds	r7, #16
   2d776:	46bd      	mov	sp, r7
   2d778:	bd80      	pop	{r7, pc}
   2d77a:	bf00      	nop
   2d77c:	100118b0 	.word	0x100118b0

0002d780 <WsfTimer_handler>:

static void WsfTimer_handler(TimerHandle_t xTimer)
{
   2d780:	b580      	push	{r7, lr}
   2d782:	b082      	sub	sp, #8
   2d784:	af00      	add	r7, sp, #0
   2d786:	6078      	str	r0, [r7, #4]
  WsfTaskSetReady(0, WSF_TIMER_EVENT);
   2d788:	2102      	movs	r1, #2
   2d78a:	2000      	movs	r0, #0
   2d78c:	f7ff fdc2 	bl	2d314 <WsfTaskSetReady>
}
   2d790:	bf00      	nop
   2d792:	3708      	adds	r7, #8
   2d794:	46bd      	mov	sp, r7
   2d796:	bd80      	pop	{r7, pc}

0002d798 <WsfTimerInit>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTimerInit(void)
{
   2d798:	b580      	push	{r7, lr}
   2d79a:	b082      	sub	sp, #8
   2d79c:	af02      	add	r7, sp, #8
  WSF_QUEUE_INIT(&wsfTimerTimerQueue);
   2d79e:	4b0e      	ldr	r3, [pc, #56]	; (2d7d8 <WsfTimerInit+0x40>)
   2d7a0:	2200      	movs	r2, #0
   2d7a2:	601a      	str	r2, [r3, #0]
   2d7a4:	4b0c      	ldr	r3, [pc, #48]	; (2d7d8 <WsfTimerInit+0x40>)
   2d7a6:	2200      	movs	r2, #0
   2d7a8:	605a      	str	r2, [r3, #4]

  if(xWsfTimer == NULL)
   2d7aa:	4b0c      	ldr	r3, [pc, #48]	; (2d7dc <WsfTimerInit+0x44>)
   2d7ac:	681b      	ldr	r3, [r3, #0]
   2d7ae:	2b00      	cmp	r3, #0
   2d7b0:	d10f      	bne.n	2d7d2 <WsfTimerInit+0x3a>
  {
    xWsfTimer = xTimerCreate("WSF Timer", pdMS_TO_TICKS(WSF_MS_PER_TICK),
   2d7b2:	4b0b      	ldr	r3, [pc, #44]	; (2d7e0 <WsfTimerInit+0x48>)
   2d7b4:	9300      	str	r3, [sp, #0]
   2d7b6:	2300      	movs	r3, #0
   2d7b8:	2200      	movs	r2, #0
   2d7ba:	210a      	movs	r1, #10
   2d7bc:	4809      	ldr	r0, [pc, #36]	; (2d7e4 <WsfTimerInit+0x4c>)
   2d7be:	f7ff f86b 	bl	2c898 <xTimerCreate>
   2d7c2:	4603      	mov	r3, r0
   2d7c4:	4a05      	ldr	r2, [pc, #20]	; (2d7dc <WsfTimerInit+0x44>)
   2d7c6:	6013      	str	r3, [r2, #0]
          pdFALSE, NULL, WsfTimer_handler);
    configASSERT(xWsfTimer);
    g_ui32LastTime = xTaskGetTickCount();
   2d7c8:	f7fe fb68 	bl	2be9c <xTaskGetTickCount>
   2d7cc:	4603      	mov	r3, r0
   2d7ce:	4a06      	ldr	r2, [pc, #24]	; (2d7e8 <WsfTimerInit+0x50>)
   2d7d0:	6013      	str	r3, [r2, #0]
  }
}
   2d7d2:	bf00      	nop
   2d7d4:	46bd      	mov	sp, r7
   2d7d6:	bd80      	pop	{r7, pc}
   2d7d8:	100118b0 	.word	0x100118b0
   2d7dc:	100118b8 	.word	0x100118b8
   2d7e0:	0002d781 	.word	0x0002d781
   2d7e4:	000451cc 	.word	0x000451cc
   2d7e8:	10008138 	.word	0x10008138

0002d7ec <WsfTimerStartSec>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTimerStartSec(wsfTimer_t *pTimer, wsfTimerTicks_t sec)
{
   2d7ec:	b580      	push	{r7, lr}
   2d7ee:	b082      	sub	sp, #8
   2d7f0:	af00      	add	r7, sp, #0
   2d7f2:	6078      	str	r0, [r7, #4]
   2d7f4:	6039      	str	r1, [r7, #0]
  WSF_TRACE_INFO2("WsfTimerStartSec pTimer:0x%x ticks:%u", (uint32_t)pTimer, WSF_TIMER_SEC_TO_TICKS(sec));

  /* insert timer into queue */
  wsfTimerInsert(pTimer, WSF_TIMER_SEC_TO_TICKS(sec));
   2d7f6:	683b      	ldr	r3, [r7, #0]
   2d7f8:	2264      	movs	r2, #100	; 0x64
   2d7fa:	fb02 f303 	mul.w	r3, r2, r3
   2d7fe:	4619      	mov	r1, r3
   2d800:	6878      	ldr	r0, [r7, #4]
   2d802:	f7ff ff85 	bl	2d710 <wsfTimerInsert>
}
   2d806:	bf00      	nop
   2d808:	3708      	adds	r7, #8
   2d80a:	46bd      	mov	sp, r7
   2d80c:	bd80      	pop	{r7, pc}
	...

0002d810 <WsfTimerStartMs>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTimerStartMs(wsfTimer_t *pTimer, wsfTimerTicks_t ms)
{
   2d810:	b580      	push	{r7, lr}
   2d812:	b082      	sub	sp, #8
   2d814:	af00      	add	r7, sp, #0
   2d816:	6078      	str	r0, [r7, #4]
   2d818:	6039      	str	r1, [r7, #0]
  WSF_TRACE_INFO2("WsfTimerStartMs pTimer:0x%x ticks:%u", (uint32_t)pTimer, WSF_TIMER_MS_TO_TICKS(ms));

  /* insert timer into queue */
  wsfTimerInsert(pTimer, WSF_TIMER_MS_TO_TICKS(ms));
   2d81a:	683b      	ldr	r3, [r7, #0]
   2d81c:	4a05      	ldr	r2, [pc, #20]	; (2d834 <WsfTimerStartMs+0x24>)
   2d81e:	fba2 2303 	umull	r2, r3, r2, r3
   2d822:	08db      	lsrs	r3, r3, #3
   2d824:	4619      	mov	r1, r3
   2d826:	6878      	ldr	r0, [r7, #4]
   2d828:	f7ff ff72 	bl	2d710 <wsfTimerInsert>
}
   2d82c:	bf00      	nop
   2d82e:	3708      	adds	r7, #8
   2d830:	46bd      	mov	sp, r7
   2d832:	bd80      	pop	{r7, pc}
   2d834:	cccccccd 	.word	0xcccccccd

0002d838 <WsfTimerStop>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTimerStop(wsfTimer_t *pTimer)
{
   2d838:	b580      	push	{r7, lr}
   2d83a:	b082      	sub	sp, #8
   2d83c:	af00      	add	r7, sp, #0
   2d83e:	6078      	str	r0, [r7, #4]
  WSF_TRACE_INFO1("WsfTimerStop pTimer:0x%x", pTimer);

  /* task schedule lock */
  WsfTaskLock();
   2d840:	f7ff fce0 	bl	2d204 <WsfTaskLock>

  wsfTimerRemove(pTimer);
   2d844:	6878      	ldr	r0, [r7, #4]
   2d846:	f7ff ff39 	bl	2d6bc <wsfTimerRemove>

  /* task schedule unlock */
  WsfTaskUnlock();
   2d84a:	f7ff fce1 	bl	2d210 <WsfTaskUnlock>
}
   2d84e:	bf00      	nop
   2d850:	3708      	adds	r7, #8
   2d852:	46bd      	mov	sp, r7
   2d854:	bd80      	pop	{r7, pc}
	...

0002d858 <WsfTimerUpdate>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTimerUpdate(wsfTimerTicks_t ticks)
{
   2d858:	b580      	push	{r7, lr}
   2d85a:	b084      	sub	sp, #16
   2d85c:	af00      	add	r7, sp, #0
   2d85e:	6078      	str	r0, [r7, #4]
  wsfTimer_t  *pElem;

  /* task schedule lock */
  WsfTaskLock();
   2d860:	f7ff fcd0 	bl	2d204 <WsfTaskLock>

  pElem = (wsfTimer_t *) wsfTimerTimerQueue.pHead;
   2d864:	4b12      	ldr	r3, [pc, #72]	; (2d8b0 <WsfTimerUpdate+0x58>)
   2d866:	681b      	ldr	r3, [r3, #0]
   2d868:	60fb      	str	r3, [r7, #12]

  /* iterate over timer queue */
  while (pElem != NULL)
   2d86a:	e017      	b.n	2d89c <WsfTimerUpdate+0x44>
  {
    /* decrement ticks while preventing underflow */
    if (pElem->ticks > ticks)
   2d86c:	68fb      	ldr	r3, [r7, #12]
   2d86e:	685b      	ldr	r3, [r3, #4]
   2d870:	687a      	ldr	r2, [r7, #4]
   2d872:	429a      	cmp	r2, r3
   2d874:	d206      	bcs.n	2d884 <WsfTimerUpdate+0x2c>
    {
      pElem->ticks -= ticks;
   2d876:	68fb      	ldr	r3, [r7, #12]
   2d878:	685a      	ldr	r2, [r3, #4]
   2d87a:	687b      	ldr	r3, [r7, #4]
   2d87c:	1ad2      	subs	r2, r2, r3
   2d87e:	68fb      	ldr	r3, [r7, #12]
   2d880:	605a      	str	r2, [r3, #4]
   2d882:	e008      	b.n	2d896 <WsfTimerUpdate+0x3e>
    }
    else
    {
      pElem->ticks = 0;
   2d884:	68fb      	ldr	r3, [r7, #12]
   2d886:	2200      	movs	r2, #0
   2d888:	605a      	str	r2, [r3, #4]

      /* timer expired; set task for this timer as ready */
      WsfTaskSetReady(pElem->handlerId, WSF_TIMER_EVENT);
   2d88a:	68fb      	ldr	r3, [r7, #12]
   2d88c:	7b1b      	ldrb	r3, [r3, #12]
   2d88e:	2102      	movs	r1, #2
   2d890:	4618      	mov	r0, r3
   2d892:	f7ff fd3f 	bl	2d314 <WsfTaskSetReady>
    }

    pElem = pElem->pNext;
   2d896:	68fb      	ldr	r3, [r7, #12]
   2d898:	681b      	ldr	r3, [r3, #0]
   2d89a:	60fb      	str	r3, [r7, #12]
  while (pElem != NULL)
   2d89c:	68fb      	ldr	r3, [r7, #12]
   2d89e:	2b00      	cmp	r3, #0
   2d8a0:	d1e4      	bne.n	2d86c <WsfTimerUpdate+0x14>
  }

  /* task schedule unlock */
  WsfTaskUnlock();
   2d8a2:	f7ff fcb5 	bl	2d210 <WsfTaskUnlock>
}
   2d8a6:	bf00      	nop
   2d8a8:	3710      	adds	r7, #16
   2d8aa:	46bd      	mov	sp, r7
   2d8ac:	bd80      	pop	{r7, pc}
   2d8ae:	bf00      	nop
   2d8b0:	100118b0 	.word	0x100118b0

0002d8b4 <WsfTimerNextExpiration>:
 *
 *  \return The number of ticks until the next timer expiration.
 */
/*************************************************************************************************/
wsfTimerTicks_t WsfTimerNextExpiration(bool_t *pTimerRunning)
{
   2d8b4:	b580      	push	{r7, lr}
   2d8b6:	b084      	sub	sp, #16
   2d8b8:	af00      	add	r7, sp, #0
   2d8ba:	6078      	str	r0, [r7, #4]
  wsfTimerTicks_t ticks;

  /* task schedule lock */
  WsfTaskLock();
   2d8bc:	f7ff fca2 	bl	2d204 <WsfTaskLock>

  if (wsfTimerTimerQueue.pHead == NULL)
   2d8c0:	4b0b      	ldr	r3, [pc, #44]	; (2d8f0 <WsfTimerNextExpiration+0x3c>)
   2d8c2:	681b      	ldr	r3, [r3, #0]
   2d8c4:	2b00      	cmp	r3, #0
   2d8c6:	d105      	bne.n	2d8d4 <WsfTimerNextExpiration+0x20>
  {
    *pTimerRunning = FALSE;
   2d8c8:	687b      	ldr	r3, [r7, #4]
   2d8ca:	2200      	movs	r2, #0
   2d8cc:	701a      	strb	r2, [r3, #0]
    ticks = 0;
   2d8ce:	2300      	movs	r3, #0
   2d8d0:	60fb      	str	r3, [r7, #12]
   2d8d2:	e006      	b.n	2d8e2 <WsfTimerNextExpiration+0x2e>
  }
  else
  {
    *pTimerRunning = TRUE;
   2d8d4:	687b      	ldr	r3, [r7, #4]
   2d8d6:	2201      	movs	r2, #1
   2d8d8:	701a      	strb	r2, [r3, #0]
    ticks = ((wsfTimer_t *) wsfTimerTimerQueue.pHead)->ticks;
   2d8da:	4b05      	ldr	r3, [pc, #20]	; (2d8f0 <WsfTimerNextExpiration+0x3c>)
   2d8dc:	681b      	ldr	r3, [r3, #0]
   2d8de:	685b      	ldr	r3, [r3, #4]
   2d8e0:	60fb      	str	r3, [r7, #12]
  }

  /* task schedule unlock */
  WsfTaskUnlock();
   2d8e2:	f7ff fc95 	bl	2d210 <WsfTaskUnlock>

  return ticks;
   2d8e6:	68fb      	ldr	r3, [r7, #12]
}
   2d8e8:	4618      	mov	r0, r3
   2d8ea:	3710      	adds	r7, #16
   2d8ec:	46bd      	mov	sp, r7
   2d8ee:	bd80      	pop	{r7, pc}
   2d8f0:	100118b0 	.word	0x100118b0

0002d8f4 <WsfTimerServiceExpired>:
 *
 *  \return Pointer to timer or NULL.
 */
/*************************************************************************************************/
wsfTimer_t *WsfTimerServiceExpired(wsfTaskId_t taskId)
{
   2d8f4:	b580      	push	{r7, lr}
   2d8f6:	b084      	sub	sp, #16
   2d8f8:	af00      	add	r7, sp, #0
   2d8fa:	4603      	mov	r3, r0
   2d8fc:	71fb      	strb	r3, [r7, #7]
  wsfTimer_t  *pElem;
  wsfTimer_t  *pPrev = NULL;
   2d8fe:	2300      	movs	r3, #0
   2d900:	60fb      	str	r3, [r7, #12]

  /* Unused parameters */
  (void)taskId;

  /* task schedule lock */
  WsfTaskLock();
   2d902:	f7ff fc7f 	bl	2d204 <WsfTaskLock>

  /* find expired timers in queue */
  if (((pElem = (wsfTimer_t *) wsfTimerTimerQueue.pHead) != NULL) &&
   2d906:	4b0e      	ldr	r3, [pc, #56]	; (2d940 <WsfTimerServiceExpired+0x4c>)
   2d908:	681b      	ldr	r3, [r3, #0]
   2d90a:	60bb      	str	r3, [r7, #8]
   2d90c:	68bb      	ldr	r3, [r7, #8]
   2d90e:	2b00      	cmp	r3, #0
   2d910:	d00f      	beq.n	2d932 <WsfTimerServiceExpired+0x3e>
      (pElem->ticks == 0))
   2d912:	68bb      	ldr	r3, [r7, #8]
   2d914:	685b      	ldr	r3, [r3, #4]
  if (((pElem = (wsfTimer_t *) wsfTimerTimerQueue.pHead) != NULL) &&
   2d916:	2b00      	cmp	r3, #0
   2d918:	d10b      	bne.n	2d932 <WsfTimerServiceExpired+0x3e>
  {
    /* remove timer from queue */
    WsfQueueRemove(&wsfTimerTimerQueue, pElem, pPrev);
   2d91a:	68fa      	ldr	r2, [r7, #12]
   2d91c:	68b9      	ldr	r1, [r7, #8]
   2d91e:	4808      	ldr	r0, [pc, #32]	; (2d940 <WsfTimerServiceExpired+0x4c>)
   2d920:	f7ff fe88 	bl	2d634 <WsfQueueRemove>

    pElem->isStarted = FALSE;
   2d924:	68bb      	ldr	r3, [r7, #8]
   2d926:	2200      	movs	r2, #0
   2d928:	735a      	strb	r2, [r3, #13]

    /* task schedule unlock */
    WsfTaskUnlock();
   2d92a:	f7ff fc71 	bl	2d210 <WsfTaskUnlock>

    WSF_TRACE_INFO1("Timer expired pTimer:0x%x", pElem);

    /* return timer */
    return pElem;
   2d92e:	68bb      	ldr	r3, [r7, #8]
   2d930:	e002      	b.n	2d938 <WsfTimerServiceExpired+0x44>
  }

  /* task schedule unlock */
  WsfTaskUnlock();
   2d932:	f7ff fc6d 	bl	2d210 <WsfTaskUnlock>

  return NULL;
   2d936:	2300      	movs	r3, #0
}
   2d938:	4618      	mov	r0, r3
   2d93a:	3710      	adds	r7, #16
   2d93c:	46bd      	mov	sp, r7
   2d93e:	bd80      	pop	{r7, pc}
   2d940:	100118b0 	.word	0x100118b0

0002d944 <WsfTimerUpdateTicks>:
//
// Calculate the elapsed time, and update the WSF software timers.
//
//*****************************************************************************
void WsfTimerUpdateTicks(void)
{
   2d944:	b580      	push	{r7, lr}
   2d946:	b084      	sub	sp, #16
   2d948:	af00      	add	r7, sp, #0
    wsfTimerTicks_t xNextExpiration;

    //
    // Read the continuous timer.
    //
    ui32CurrentTime = xTaskGetTickCount();
   2d94a:	f7fe faa7 	bl	2be9c <xTaskGetTickCount>
   2d94e:	60f8      	str	r0, [r7, #12]
    //
    // Figure out how long it has been since the last time we've read the
    // continuous timer. We should be reading often enough that we'll never
    // have more than one overflow.
    //
    ui32ElapsedTime = ui32CurrentTime - g_ui32LastTime;
   2d950:	4b0d      	ldr	r3, [pc, #52]	; (2d988 <WsfTimerUpdateTicks+0x44>)
   2d952:	681b      	ldr	r3, [r3, #0]
   2d954:	68fa      	ldr	r2, [r7, #12]
   2d956:	1ad3      	subs	r3, r2, r3
   2d958:	60bb      	str	r3, [r7, #8]

    //
    // Check to see if any WSF ticks need to happen.
    //
    if ( (ui32ElapsedTime / CLK_TICKS_PER_WSF_TICKS) > 0 )
   2d95a:	68bb      	ldr	r3, [r7, #8]
   2d95c:	2b09      	cmp	r3, #9
   2d95e:	d90a      	bls.n	2d976 <WsfTimerUpdateTicks+0x32>
    {
        //
        // Update the WSF timers and save the current time as our "last
        // update".
        //
        WsfTimerUpdate(ui32ElapsedTime / CLK_TICKS_PER_WSF_TICKS);
   2d960:	68bb      	ldr	r3, [r7, #8]
   2d962:	4a0a      	ldr	r2, [pc, #40]	; (2d98c <WsfTimerUpdateTicks+0x48>)
   2d964:	fba2 2303 	umull	r2, r3, r2, r3
   2d968:	08db      	lsrs	r3, r3, #3
   2d96a:	4618      	mov	r0, r3
   2d96c:	f7ff ff74 	bl	2d858 <WsfTimerUpdate>

        g_ui32LastTime = ui32CurrentTime;
   2d970:	4a05      	ldr	r2, [pc, #20]	; (2d988 <WsfTimerUpdateTicks+0x44>)
   2d972:	68fb      	ldr	r3, [r7, #12]
   2d974:	6013      	str	r3, [r2, #0]
    }

    //
    // Check to see when the next timer expiration should happen.
    //
    xNextExpiration = WsfTimerNextExpiration(&bTimerRunning);
   2d976:	1cfb      	adds	r3, r7, #3
   2d978:	4618      	mov	r0, r3
   2d97a:	f7ff ff9b 	bl	2d8b4 <WsfTimerNextExpiration>
   2d97e:	6078      	str	r0, [r7, #4]
    if ( xNextExpiration )
    {
        configASSERT(pdPASS == xTimerChangePeriod( xWsfTimer,
                pdMS_TO_TICKS(xNextExpiration*CLK_TICKS_PER_WSF_TICKS), 100)) ;
    }
}
   2d980:	bf00      	nop
   2d982:	3710      	adds	r7, #16
   2d984:	46bd      	mov	sp, r7
   2d986:	bd80      	pop	{r7, pc}
   2d988:	10008138 	.word	0x10008138
   2d98c:	cccccccd 	.word	0xcccccccd

0002d990 <WsfTrace>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WsfTrace(const char *pStr, ...)
{
   2d990:	b40f      	push	{r0, r1, r2, r3}
   2d992:	b580      	push	{r7, lr}
   2d994:	f5ad 6d81 	sub.w	sp, sp, #1032	; 0x408
   2d998:	af00      	add	r7, sp, #0
  char pTraceMsg[AM_PRINTF_BUFSIZE];
  uint32_t ui32NumChars;
  va_list           args;

  va_start(args, pStr);
   2d99a:	f207 4214 	addw	r2, r7, #1044	; 0x414
   2d99e:	463b      	mov	r3, r7
   2d9a0:	601a      	str	r2, [r3, #0]
  am_util_stdio_vsprintf(pTraceMsg, pStr, args);
   2d9a2:	463b      	mov	r3, r7
   2d9a4:	1d38      	adds	r0, r7, #4
   2d9a6:	681a      	ldr	r2, [r3, #0]
   2d9a8:	f8d7 1410 	ldr.w	r1, [r7, #1040]	; 0x410
   2d9ac:	f7ec fdec 	bl	1a588 <am_util_stdio_vsprintf>
  //vprintf(pStr, args);
  va_end(args);
  ui32NumChars = am_util_debug_printf(pTraceMsg);
   2d9b0:	1d3b      	adds	r3, r7, #4
   2d9b2:	4618      	mov	r0, r3
   2d9b4:	f7ed f8f4 	bl	1aba0 <am_util_stdio_printf>
   2d9b8:	f8c7 0404 	str.w	r0, [r7, #1028]	; 0x404
  if (!(ui32NumChars < AM_PRINTF_BUFSIZE))
   2d9bc:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
   2d9c0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
   2d9c4:	d303      	bcc.n	2d9ce <WsfTrace+0x3e>
    WsfAssert(__FILE__, (uint16_t) __LINE__);
   2d9c6:	2183      	movs	r1, #131	; 0x83
   2d9c8:	4806      	ldr	r0, [pc, #24]	; (2d9e4 <WsfTrace+0x54>)
   2d9ca:	f7ff fa23 	bl	2ce14 <WsfAssert>
  am_util_debug_printf("\n");
   2d9ce:	4806      	ldr	r0, [pc, #24]	; (2d9e8 <WsfTrace+0x58>)
   2d9d0:	f7ed f8e6 	bl	1aba0 <am_util_stdio_printf>
}
   2d9d4:	bf00      	nop
   2d9d6:	f507 6781 	add.w	r7, r7, #1032	; 0x408
   2d9da:	46bd      	mov	sp, r7
   2d9dc:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
   2d9e0:	b004      	add	sp, #16
   2d9e2:	4770      	bx	lr
   2d9e4:	000451e8 	.word	0x000451e8
   2d9e8:	000451e0 	.word	0x000451e0

0002d9ec <WStrReverseCpy>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WStrReverseCpy(uint8_t *pBuf1, const uint8_t *pBuf2, uint16_t len)
{
   2d9ec:	b480      	push	{r7}
   2d9ee:	b087      	sub	sp, #28
   2d9f0:	af00      	add	r7, sp, #0
   2d9f2:	60f8      	str	r0, [r7, #12]
   2d9f4:	60b9      	str	r1, [r7, #8]
   2d9f6:	4613      	mov	r3, r2
   2d9f8:	80fb      	strh	r3, [r7, #6]
  int16_t i;

  for (i=0; i<len; i++)
   2d9fa:	2300      	movs	r3, #0
   2d9fc:	82fb      	strh	r3, [r7, #22]
   2d9fe:	e013      	b.n	2da28 <WStrReverseCpy+0x3c>
  {
    pBuf1[len-1-i] = pBuf2[i];
   2da00:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
   2da04:	68ba      	ldr	r2, [r7, #8]
   2da06:	441a      	add	r2, r3
   2da08:	88fb      	ldrh	r3, [r7, #6]
   2da0a:	1e59      	subs	r1, r3, #1
   2da0c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
   2da10:	1acb      	subs	r3, r1, r3
   2da12:	4619      	mov	r1, r3
   2da14:	68fb      	ldr	r3, [r7, #12]
   2da16:	440b      	add	r3, r1
   2da18:	7812      	ldrb	r2, [r2, #0]
   2da1a:	701a      	strb	r2, [r3, #0]
  for (i=0; i<len; i++)
   2da1c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
   2da20:	b29b      	uxth	r3, r3
   2da22:	3301      	adds	r3, #1
   2da24:	b29b      	uxth	r3, r3
   2da26:	82fb      	strh	r3, [r7, #22]
   2da28:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
   2da2c:	88fb      	ldrh	r3, [r7, #6]
   2da2e:	429a      	cmp	r2, r3
   2da30:	dbe6      	blt.n	2da00 <WStrReverseCpy+0x14>
  }
}
   2da32:	bf00      	nop
   2da34:	bf00      	nop
   2da36:	371c      	adds	r7, #28
   2da38:	46bd      	mov	sp, r7
   2da3a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2da3e:	4770      	bx	lr

0002da40 <WStrReverse>:
 *
 *  \return None.
 */
/*************************************************************************************************/
void WStrReverse(uint8_t *pBuf, uint8_t len)
{
   2da40:	b480      	push	{r7}
   2da42:	b085      	sub	sp, #20
   2da44:	af00      	add	r7, sp, #0
   2da46:	6078      	str	r0, [r7, #4]
   2da48:	460b      	mov	r3, r1
   2da4a:	70fb      	strb	r3, [r7, #3]
  uint8_t i, temp;

  for (i=0; i<len/2; i++)
   2da4c:	2300      	movs	r3, #0
   2da4e:	73fb      	strb	r3, [r7, #15]
   2da50:	e01a      	b.n	2da88 <WStrReverse+0x48>
  {
    temp = pBuf[len-i-1];
   2da52:	78fa      	ldrb	r2, [r7, #3]
   2da54:	7bfb      	ldrb	r3, [r7, #15]
   2da56:	1ad3      	subs	r3, r2, r3
   2da58:	3b01      	subs	r3, #1
   2da5a:	687a      	ldr	r2, [r7, #4]
   2da5c:	4413      	add	r3, r2
   2da5e:	781b      	ldrb	r3, [r3, #0]
   2da60:	73bb      	strb	r3, [r7, #14]
    pBuf[len-i-1] = pBuf[i];
   2da62:	7bfb      	ldrb	r3, [r7, #15]
   2da64:	687a      	ldr	r2, [r7, #4]
   2da66:	441a      	add	r2, r3
   2da68:	78f9      	ldrb	r1, [r7, #3]
   2da6a:	7bfb      	ldrb	r3, [r7, #15]
   2da6c:	1acb      	subs	r3, r1, r3
   2da6e:	3b01      	subs	r3, #1
   2da70:	6879      	ldr	r1, [r7, #4]
   2da72:	440b      	add	r3, r1
   2da74:	7812      	ldrb	r2, [r2, #0]
   2da76:	701a      	strb	r2, [r3, #0]
    pBuf[i] = temp;
   2da78:	7bfb      	ldrb	r3, [r7, #15]
   2da7a:	687a      	ldr	r2, [r7, #4]
   2da7c:	4413      	add	r3, r2
   2da7e:	7bba      	ldrb	r2, [r7, #14]
   2da80:	701a      	strb	r2, [r3, #0]
  for (i=0; i<len/2; i++)
   2da82:	7bfb      	ldrb	r3, [r7, #15]
   2da84:	3301      	adds	r3, #1
   2da86:	73fb      	strb	r3, [r7, #15]
   2da88:	78fb      	ldrb	r3, [r7, #3]
   2da8a:	085b      	lsrs	r3, r3, #1
   2da8c:	b2db      	uxtb	r3, r3
   2da8e:	7bfa      	ldrb	r2, [r7, #15]
   2da90:	429a      	cmp	r2, r3
   2da92:	d3de      	bcc.n	2da52 <WStrReverse+0x12>
  }
}
   2da94:	bf00      	nop
   2da96:	bf00      	nop
   2da98:	3714      	adds	r7, #20
   2da9a:	46bd      	mov	sp, r7
   2da9c:	f85d 7b04 	ldr.w	r7, [sp], #4
   2daa0:	4770      	bx	lr
	...

0002daa4 <__NVIC_EnableIRQ>:
{
   2daa4:	b480      	push	{r7}
   2daa6:	b083      	sub	sp, #12
   2daa8:	af00      	add	r7, sp, #0
   2daaa:	4603      	mov	r3, r0
   2daac:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2daae:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2dab2:	2b00      	cmp	r3, #0
   2dab4:	db0b      	blt.n	2dace <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2dab6:	79fb      	ldrb	r3, [r7, #7]
   2dab8:	f003 021f 	and.w	r2, r3, #31
   2dabc:	4907      	ldr	r1, [pc, #28]	; (2dadc <__NVIC_EnableIRQ+0x38>)
   2dabe:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2dac2:	095b      	lsrs	r3, r3, #5
   2dac4:	2001      	movs	r0, #1
   2dac6:	fa00 f202 	lsl.w	r2, r0, r2
   2daca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   2dace:	bf00      	nop
   2dad0:	370c      	adds	r7, #12
   2dad2:	46bd      	mov	sp, r7
   2dad4:	f85d 7b04 	ldr.w	r7, [sp], #4
   2dad8:	4770      	bx	lr
   2dada:	bf00      	nop
   2dadc:	e000e100 	.word	0xe000e100

0002dae0 <__NVIC_DisableIRQ>:
{
   2dae0:	b480      	push	{r7}
   2dae2:	b083      	sub	sp, #12
   2dae4:	af00      	add	r7, sp, #0
   2dae6:	4603      	mov	r3, r0
   2dae8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2daea:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2daee:	2b00      	cmp	r3, #0
   2daf0:	db12      	blt.n	2db18 <__NVIC_DisableIRQ+0x38>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   2daf2:	79fb      	ldrb	r3, [r7, #7]
   2daf4:	f003 021f 	and.w	r2, r3, #31
   2daf8:	490a      	ldr	r1, [pc, #40]	; (2db24 <__NVIC_DisableIRQ+0x44>)
   2dafa:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2dafe:	095b      	lsrs	r3, r3, #5
   2db00:	2001      	movs	r0, #1
   2db02:	fa00 f202 	lsl.w	r2, r0, r2
   2db06:	3320      	adds	r3, #32
   2db08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
   2db0c:	f3bf 8f4f 	dsb	sy
}
   2db10:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
   2db12:	f3bf 8f6f 	isb	sy
}
   2db16:	bf00      	nop
}
   2db18:	bf00      	nop
   2db1a:	370c      	adds	r7, #12
   2db1c:	46bd      	mov	sp, r7
   2db1e:	f85d 7b04 	ldr.w	r7, [sp], #4
   2db22:	4770      	bx	lr
   2db24:	e000e100 	.word	0xe000e100

0002db28 <__NVIC_SetPriority>:
{
   2db28:	b480      	push	{r7}
   2db2a:	b083      	sub	sp, #12
   2db2c:	af00      	add	r7, sp, #0
   2db2e:	4603      	mov	r3, r0
   2db30:	6039      	str	r1, [r7, #0]
   2db32:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2db34:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2db38:	2b00      	cmp	r3, #0
   2db3a:	db0a      	blt.n	2db52 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2db3c:	683b      	ldr	r3, [r7, #0]
   2db3e:	b2da      	uxtb	r2, r3
   2db40:	490c      	ldr	r1, [pc, #48]	; (2db74 <__NVIC_SetPriority+0x4c>)
   2db42:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2db46:	0152      	lsls	r2, r2, #5
   2db48:	b2d2      	uxtb	r2, r2
   2db4a:	440b      	add	r3, r1
   2db4c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   2db50:	e00a      	b.n	2db68 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2db52:	683b      	ldr	r3, [r7, #0]
   2db54:	b2da      	uxtb	r2, r3
   2db56:	4908      	ldr	r1, [pc, #32]	; (2db78 <__NVIC_SetPriority+0x50>)
   2db58:	79fb      	ldrb	r3, [r7, #7]
   2db5a:	f003 030f 	and.w	r3, r3, #15
   2db5e:	3b04      	subs	r3, #4
   2db60:	0152      	lsls	r2, r2, #5
   2db62:	b2d2      	uxtb	r2, r2
   2db64:	440b      	add	r3, r1
   2db66:	761a      	strb	r2, [r3, #24]
}
   2db68:	bf00      	nop
   2db6a:	370c      	adds	r7, #12
   2db6c:	46bd      	mov	sp, r7
   2db6e:	f85d 7b04 	ldr.w	r7, [sp], #4
   2db72:	4770      	bx	lr
   2db74:	e000e100 	.word	0xe000e100
   2db78:	e000ed00 	.word	0xe000ed00

0002db7c <am_adc_isr>:
   if (event_callback)
      event_callback(is_charging ? BATTERY_CHARGING : BATTERY_NOT_CHARGING);
}

void am_adc_isr(void)
{
   2db7c:	b580      	push	{r7, lr}
   2db7e:	b084      	sub	sp, #16
   2db80:	af02      	add	r7, sp, #8
   // Clear the ADC interrupt
   static uint32_t status;
   am_hal_adc_interrupt_status(adc_handle, &status, true);
   2db82:	4b1b      	ldr	r3, [pc, #108]	; (2dbf0 <am_adc_isr+0x74>)
   2db84:	681b      	ldr	r3, [r3, #0]
   2db86:	2201      	movs	r2, #1
   2db88:	491a      	ldr	r1, [pc, #104]	; (2dbf4 <am_adc_isr+0x78>)
   2db8a:	4618      	mov	r0, r3
   2db8c:	f007 fcb8 	bl	35500 <am_hal_adc_interrupt_status>
   am_hal_adc_interrupt_clear(adc_handle, status);
   2db90:	4b17      	ldr	r3, [pc, #92]	; (2dbf0 <am_adc_isr+0x74>)
   2db92:	681b      	ldr	r3, [r3, #0]
   2db94:	4a17      	ldr	r2, [pc, #92]	; (2dbf4 <am_adc_isr+0x78>)
   2db96:	6812      	ldr	r2, [r2, #0]
   2db98:	4611      	mov	r1, r2
   2db9a:	4618      	mov	r0, r3
   2db9c:	f007 fcd4 	bl	35548 <am_hal_adc_interrupt_clear>

   // Read all values from the ADC FIFO
   static am_hal_adc_sample_t sample;
   while (AM_HAL_ADC_FIFO_COUNT(ADC->FIFO))
   2dba0:	e019      	b.n	2dbd6 <am_adc_isr+0x5a>
   {
      uint32_t samples_to_read = 1;
   2dba2:	2301      	movs	r3, #1
   2dba4:	607b      	str	r3, [r7, #4]
      am_hal_daxi_control(AM_HAL_DAXI_CONTROL_INVALIDATE, NULL);
   2dba6:	2100      	movs	r1, #0
   2dba8:	2000      	movs	r0, #0
   2dbaa:	f006 f8ab 	bl	33d04 <am_hal_daxi_control>
      am_hal_adc_samples_read(adc_handle, true, NULL, &samples_to_read, &sample);
   2dbae:	4b10      	ldr	r3, [pc, #64]	; (2dbf0 <am_adc_isr+0x74>)
   2dbb0:	6818      	ldr	r0, [r3, #0]
   2dbb2:	1d3b      	adds	r3, r7, #4
   2dbb4:	4a10      	ldr	r2, [pc, #64]	; (2dbf8 <am_adc_isr+0x7c>)
   2dbb6:	9200      	str	r2, [sp, #0]
   2dbb8:	2200      	movs	r2, #0
   2dbba:	2101      	movs	r1, #1
   2dbbc:	f007 fcd4 	bl	35568 <am_hal_adc_samples_read>
      if (sample.ui32Slot == BATTERY_ADC_SLOT)
   2dbc0:	4b0d      	ldr	r3, [pc, #52]	; (2dbf8 <am_adc_isr+0x7c>)
   2dbc2:	685b      	ldr	r3, [r3, #4]
   2dbc4:	2b00      	cmp	r3, #0
   2dbc6:	d106      	bne.n	2dbd6 <am_adc_isr+0x5a>
         battery_voltage_code = AM_HAL_ADC_FIFO_SAMPLE(sample.ui32Sample);
   2dbc8:	4b0b      	ldr	r3, [pc, #44]	; (2dbf8 <am_adc_isr+0x7c>)
   2dbca:	681b      	ldr	r3, [r3, #0]
   2dbcc:	099b      	lsrs	r3, r3, #6
   2dbce:	f3c3 030d 	ubfx	r3, r3, #0, #14
   2dbd2:	4a0a      	ldr	r2, [pc, #40]	; (2dbfc <am_adc_isr+0x80>)
   2dbd4:	6013      	str	r3, [r2, #0]
   while (AM_HAL_ADC_FIFO_COUNT(ADC->FIFO))
   2dbd6:	4b0a      	ldr	r3, [pc, #40]	; (2dc00 <am_adc_isr+0x84>)
   2dbd8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   2dbda:	0d1b      	lsrs	r3, r3, #20
   2dbdc:	b2db      	uxtb	r3, r3
   2dbde:	2b00      	cmp	r3, #0
   2dbe0:	d1df      	bne.n	2dba2 <am_adc_isr+0x26>
   }

   // Set the conversion complete flag
   conversion_complete = true;
   2dbe2:	4b08      	ldr	r3, [pc, #32]	; (2dc04 <am_adc_isr+0x88>)
   2dbe4:	2201      	movs	r2, #1
   2dbe6:	701a      	strb	r2, [r3, #0]
}
   2dbe8:	bf00      	nop
   2dbea:	3708      	adds	r7, #8
   2dbec:	46bd      	mov	sp, r7
   2dbee:	bd80      	pop	{r7, pc}
   2dbf0:	10008144 	.word	0x10008144
   2dbf4:	10008148 	.word	0x10008148
   2dbf8:	1000814c 	.word	0x1000814c
   2dbfc:	1000813c 	.word	0x1000813c
   2dc00:	40038000 	.word	0x40038000
   2dc04:	10008140 	.word	0x10008140

0002dc08 <battery_monitor_get_level_mV>:
{
   event_callback = callback;
}

uint32_t battery_monitor_get_level_mV(void)
{
   2dc08:	b580      	push	{r7, lr}
   2dc0a:	af00      	add	r7, sp, #0
   // Wake up the ADC
   conversion_complete = false;
   2dc0c:	4b34      	ldr	r3, [pc, #208]	; (2dce0 <battery_monitor_get_level_mV+0xd8>)
   2dc0e:	2200      	movs	r2, #0
   2dc10:	701a      	strb	r2, [r3, #0]
   if (am_hal_adc_power_control(adc_handle, AM_HAL_SYSCTRL_WAKE, true) != AM_HAL_STATUS_SUCCESS)
   2dc12:	4b34      	ldr	r3, [pc, #208]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc14:	681b      	ldr	r3, [r3, #0]
   2dc16:	2201      	movs	r2, #1
   2dc18:	2100      	movs	r1, #0
   2dc1a:	4618      	mov	r0, r3
   2dc1c:	f007 fe68 	bl	358f0 <am_hal_adc_power_control>
   2dc20:	4603      	mov	r3, r0
   2dc22:	2b00      	cmp	r3, #0
   2dc24:	d001      	beq.n	2dc2a <battery_monitor_get_level_mV+0x22>
      return 0;
   2dc26:	2300      	movs	r3, #0
   2dc28:	e057      	b.n	2dcda <battery_monitor_get_level_mV+0xd2>

   // Enable interrupts upon completion of an ADC conversion
   am_hal_adc_interrupt_enable(adc_handle, AM_HAL_ADC_INT_CNVCMP);
   2dc2a:	4b2e      	ldr	r3, [pc, #184]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc2c:	681b      	ldr	r3, [r3, #0]
   2dc2e:	2101      	movs	r1, #1
   2dc30:	4618      	mov	r0, r3
   2dc32:	f007 fc3b 	bl	354ac <am_hal_adc_interrupt_enable>
   NVIC_SetPriority(ADC_IRQn, AM_IRQ_PRIORITY_DEFAULT);
   2dc36:	2104      	movs	r1, #4
   2dc38:	2013      	movs	r0, #19
   2dc3a:	f7ff ff75 	bl	2db28 <__NVIC_SetPriority>
   NVIC_EnableIRQ(ADC_IRQn);
   2dc3e:	2013      	movs	r0, #19
   2dc40:	f7ff ff30 	bl	2daa4 <__NVIC_EnableIRQ>

   // Enable the ADC
   if ((am_hal_adc_enable(adc_handle) != AM_HAL_STATUS_SUCCESS) || am_hal_adc_sw_trigger(adc_handle))
   2dc44:	4b27      	ldr	r3, [pc, #156]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc46:	681b      	ldr	r3, [r3, #0]
   2dc48:	4618      	mov	r0, r3
   2dc4a:	f007 fc01 	bl	35450 <am_hal_adc_enable>
   2dc4e:	4603      	mov	r3, r0
   2dc50:	2b00      	cmp	r3, #0
   2dc52:	d107      	bne.n	2dc64 <battery_monitor_get_level_mV+0x5c>
   2dc54:	4b23      	ldr	r3, [pc, #140]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc56:	681b      	ldr	r3, [r3, #0]
   2dc58:	4618      	mov	r0, r3
   2dc5a:	f007 fe37 	bl	358cc <am_hal_adc_sw_trigger>
   2dc5e:	4603      	mov	r3, r0
   2dc60:	2b00      	cmp	r3, #0
   2dc62:	d014      	beq.n	2dc8e <battery_monitor_get_level_mV+0x86>
   {
      am_hal_adc_interrupt_disable(adc_handle, AM_HAL_ADC_INT_CNVCMP);
   2dc64:	4b1f      	ldr	r3, [pc, #124]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc66:	681b      	ldr	r3, [r3, #0]
   2dc68:	2101      	movs	r1, #1
   2dc6a:	4618      	mov	r0, r3
   2dc6c:	f007 fc32 	bl	354d4 <am_hal_adc_interrupt_disable>
      am_hal_adc_power_control(adc_handle, AM_HAL_SYSCTRL_DEEPSLEEP, true);
   2dc70:	4b1c      	ldr	r3, [pc, #112]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dc72:	681b      	ldr	r3, [r3, #0]
   2dc74:	2201      	movs	r2, #1
   2dc76:	2102      	movs	r1, #2
   2dc78:	4618      	mov	r0, r3
   2dc7a:	f007 fe39 	bl	358f0 <am_hal_adc_power_control>
      NVIC_DisableIRQ(ADC_IRQn);
   2dc7e:	2013      	movs	r0, #19
   2dc80:	f7ff ff2e 	bl	2dae0 <__NVIC_DisableIRQ>
      return 0;
   2dc84:	2300      	movs	r3, #0
   2dc86:	e028      	b.n	2dcda <battery_monitor_get_level_mV+0xd2>
   }

   // Wait until the conversion has completed
   while (!conversion_complete)
      am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_NORMAL);
   2dc88:	2000      	movs	r0, #0
   2dc8a:	f007 fa47 	bl	3511c <am_hal_sysctrl_sleep>
   while (!conversion_complete)
   2dc8e:	4b14      	ldr	r3, [pc, #80]	; (2dce0 <battery_monitor_get_level_mV+0xd8>)
   2dc90:	781b      	ldrb	r3, [r3, #0]
   2dc92:	b2db      	uxtb	r3, r3
   2dc94:	f083 0301 	eor.w	r3, r3, #1
   2dc98:	b2db      	uxtb	r3, r3
   2dc9a:	2b00      	cmp	r3, #0
   2dc9c:	d1f4      	bne.n	2dc88 <battery_monitor_get_level_mV+0x80>

   // Disable the ADC
   am_hal_adc_interrupt_disable(adc_handle, AM_HAL_ADC_INT_CNVCMP);
   2dc9e:	4b11      	ldr	r3, [pc, #68]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dca0:	681b      	ldr	r3, [r3, #0]
   2dca2:	2101      	movs	r1, #1
   2dca4:	4618      	mov	r0, r3
   2dca6:	f007 fc15 	bl	354d4 <am_hal_adc_interrupt_disable>
   am_hal_adc_power_control(adc_handle, AM_HAL_SYSCTRL_DEEPSLEEP, true);
   2dcaa:	4b0e      	ldr	r3, [pc, #56]	; (2dce4 <battery_monitor_get_level_mV+0xdc>)
   2dcac:	681b      	ldr	r3, [r3, #0]
   2dcae:	2201      	movs	r2, #1
   2dcb0:	2102      	movs	r1, #2
   2dcb2:	4618      	mov	r0, r3
   2dcb4:	f007 fe1c 	bl	358f0 <am_hal_adc_power_control>
   NVIC_DisableIRQ(ADC_IRQn);
   2dcb8:	2013      	movs	r0, #19
   2dcba:	f7ff ff11 	bl	2dae0 <__NVIC_DisableIRQ>

   // Calculate and return the battery voltage
   return (battery_voltage_code * AM_HAL_ADC_VREFMV / 4096) * (VOLTAGE_DIVIDER_UPPER + VOLTAGE_DIVIDER_LOWER) / VOLTAGE_DIVIDER_LOWER;
   2dcbe:	4b0a      	ldr	r3, [pc, #40]	; (2dce8 <battery_monitor_get_level_mV+0xe0>)
   2dcc0:	681b      	ldr	r3, [r3, #0]
   2dcc2:	f240 42a6 	movw	r2, #1190	; 0x4a6
   2dcc6:	fb02 f303 	mul.w	r3, r2, r3
   2dcca:	0b1b      	lsrs	r3, r3, #12
   2dccc:	2254      	movs	r2, #84	; 0x54
   2dcce:	fb02 f303 	mul.w	r3, r2, r3
   2dcd2:	4a06      	ldr	r2, [pc, #24]	; (2dcec <battery_monitor_get_level_mV+0xe4>)
   2dcd4:	fba2 2303 	umull	r2, r3, r2, r3
   2dcd8:	08db      	lsrs	r3, r3, #3
}
   2dcda:	4618      	mov	r0, r3
   2dcdc:	bd80      	pop	{r7, pc}
   2dcde:	bf00      	nop
   2dce0:	10008140 	.word	0x10008140
   2dce4:	10008144 	.word	0x10008144
   2dce8:	1000813c 	.word	0x1000813c
   2dcec:	3e0f83e1 	.word	0x3e0f83e1

0002dcf0 <__NVIC_SetPriority>:
{
   2dcf0:	b480      	push	{r7}
   2dcf2:	b083      	sub	sp, #12
   2dcf4:	af00      	add	r7, sp, #0
   2dcf6:	4603      	mov	r3, r0
   2dcf8:	6039      	str	r1, [r7, #0]
   2dcfa:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
   2dcfc:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2dd00:	2b00      	cmp	r3, #0
   2dd02:	db0a      	blt.n	2dd1a <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2dd04:	683b      	ldr	r3, [r7, #0]
   2dd06:	b2da      	uxtb	r2, r3
   2dd08:	490c      	ldr	r1, [pc, #48]	; (2dd3c <__NVIC_SetPriority+0x4c>)
   2dd0a:	f997 3007 	ldrsb.w	r3, [r7, #7]
   2dd0e:	0152      	lsls	r2, r2, #5
   2dd10:	b2d2      	uxtb	r2, r2
   2dd12:	440b      	add	r3, r1
   2dd14:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   2dd18:	e00a      	b.n	2dd30 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   2dd1a:	683b      	ldr	r3, [r7, #0]
   2dd1c:	b2da      	uxtb	r2, r3
   2dd1e:	4908      	ldr	r1, [pc, #32]	; (2dd40 <__NVIC_SetPriority+0x50>)
   2dd20:	79fb      	ldrb	r3, [r7, #7]
   2dd22:	f003 030f 	and.w	r3, r3, #15
   2dd26:	3b04      	subs	r3, #4
   2dd28:	0152      	lsls	r2, r2, #5
   2dd2a:	b2d2      	uxtb	r2, r2
   2dd2c:	440b      	add	r3, r1
   2dd2e:	761a      	strb	r2, [r3, #24]
}
   2dd30:	bf00      	nop
   2dd32:	370c      	adds	r7, #12
   2dd34:	46bd      	mov	sp, r7
   2dd36:	f85d 7b04 	ldr.w	r7, [sp], #4
   2dd3a:	4770      	bx	lr
   2dd3c:	e000e100 	.word	0xe000e100
   2dd40:	e000ed00 	.word	0xe000ed00

0002dd44 <advertising_setup>:


// Bluetooth LE Advertising Setup Functions ----------------------------------------------------------------------------

static void advertising_setup(dmEvt_t *pMsg)
{
   2dd44:	b580      	push	{r7, lr}
   2dd46:	b086      	sub	sp, #24
   2dd48:	af00      	add	r7, sp, #0
   2dd4a:	6078      	str	r0, [r7, #4]
   // Set the BLE address as the System ID, formatted for GATT 0x2A23
   uint8_t *bdaddr = HciGetBdAddr(), sys_id[8];
   2dd4c:	f7f8 fb68 	bl	26420 <HciGetBdAddr>
   2dd50:	6178      	str	r0, [r7, #20]
   sys_id[0] = bdaddr[0]; sys_id[1] = bdaddr[1]; sys_id[2] = bdaddr[2];
   2dd52:	697b      	ldr	r3, [r7, #20]
   2dd54:	781b      	ldrb	r3, [r3, #0]
   2dd56:	733b      	strb	r3, [r7, #12]
   2dd58:	697b      	ldr	r3, [r7, #20]
   2dd5a:	785b      	ldrb	r3, [r3, #1]
   2dd5c:	737b      	strb	r3, [r7, #13]
   2dd5e:	697b      	ldr	r3, [r7, #20]
   2dd60:	789b      	ldrb	r3, [r3, #2]
   2dd62:	73bb      	strb	r3, [r7, #14]
   sys_id[3] = 0xFE; sys_id[4] = 0xFF;
   2dd64:	23fe      	movs	r3, #254	; 0xfe
   2dd66:	73fb      	strb	r3, [r7, #15]
   2dd68:	23ff      	movs	r3, #255	; 0xff
   2dd6a:	743b      	strb	r3, [r7, #16]
   sys_id[5] = bdaddr[3]; sys_id[6] = bdaddr[4]; sys_id[7] = bdaddr[5];
   2dd6c:	697b      	ldr	r3, [r7, #20]
   2dd6e:	78db      	ldrb	r3, [r3, #3]
   2dd70:	747b      	strb	r3, [r7, #17]
   2dd72:	697b      	ldr	r3, [r7, #20]
   2dd74:	791b      	ldrb	r3, [r3, #4]
   2dd76:	74bb      	strb	r3, [r7, #18]
   2dd78:	697b      	ldr	r3, [r7, #20]
   2dd7a:	795b      	ldrb	r3, [r3, #5]
   2dd7c:	74fb      	strb	r3, [r7, #19]
   AttsSetAttr(DEVICE_INFO_SYSID_HANDLE, sizeof(sys_id), sys_id);
   2dd7e:	f107 030c 	add.w	r3, r7, #12
   2dd82:	461a      	mov	r2, r3
   2dd84:	2108      	movs	r1, #8
   2dd86:	2034      	movs	r0, #52	; 0x34
   2dd88:	f7f2 fa08 	bl	2019c <AttsSetAttr>

   // Set the advertising data
   memset(adv_data_conn, 0, sizeof(adv_data_conn));
   2dd8c:	221f      	movs	r2, #31
   2dd8e:	2100      	movs	r1, #0
   2dd90:	4816      	ldr	r0, [pc, #88]	; (2ddec <advertising_setup+0xa8>)
   2dd92:	f002 f9ad 	bl	300f0 <memset>
   AppAdvSetData(APP_ADV_DATA_CONNECTABLE, 0, (uint8_t*)adv_data_conn);
   2dd96:	4a15      	ldr	r2, [pc, #84]	; (2ddec <advertising_setup+0xa8>)
   2dd98:	2100      	movs	r1, #0
   2dd9a:	2000      	movs	r0, #0
   2dd9c:	f7ef fbfe 	bl	1d59c <AppAdvSetData>
   AppAdvSetAdValue(APP_ADV_DATA_CONNECTABLE, DM_ADV_TYPE_FLAGS, sizeof(adv_data_flags), (uint8_t*)adv_data_flags);
   2dda0:	4b13      	ldr	r3, [pc, #76]	; (2ddf0 <advertising_setup+0xac>)
   2dda2:	2201      	movs	r2, #1
   2dda4:	2101      	movs	r1, #1
   2dda6:	2000      	movs	r0, #0
   2dda8:	f7ef fc5b 	bl	1d662 <AppAdvSetAdValue>
   AppAdvSetAdValue(APP_ADV_DATA_CONNECTABLE, DM_ADV_TYPE_LOCAL_NAME, sizeof(adv_local_name), (uint8_t*)adv_local_name);
   2ddac:	4b11      	ldr	r3, [pc, #68]	; (2ddf4 <advertising_setup+0xb0>)
   2ddae:	2206      	movs	r2, #6
   2ddb0:	2109      	movs	r1, #9
   2ddb2:	2000      	movs	r0, #0
   2ddb4:	f7ef fc55 	bl	1d662 <AppAdvSetAdValue>
   AppAdvSetAdValue(APP_ADV_DATA_CONNECTABLE, DM_ADV_TYPE_MANUFACTURER, sizeof(current_ranging_role), (uint8_t*)current_ranging_role);
   2ddb8:	4b0f      	ldr	r3, [pc, #60]	; (2ddf8 <advertising_setup+0xb4>)
   2ddba:	2203      	movs	r2, #3
   2ddbc:	21ff      	movs	r1, #255	; 0xff
   2ddbe:	2000      	movs	r0, #0
   2ddc0:	f7ef fc4f 	bl	1d662 <AppAdvSetAdValue>

   // Set the scan response data
   memset(scan_data_conn, 0, sizeof(scan_data_conn));
   2ddc4:	221f      	movs	r2, #31
   2ddc6:	2100      	movs	r1, #0
   2ddc8:	480c      	ldr	r0, [pc, #48]	; (2ddfc <advertising_setup+0xb8>)
   2ddca:	f002 f991 	bl	300f0 <memset>
   AppAdvSetData(APP_SCAN_DATA_CONNECTABLE, 0, (uint8_t*)scan_data_conn);
   2ddce:	4a0b      	ldr	r2, [pc, #44]	; (2ddfc <advertising_setup+0xb8>)
   2ddd0:	2100      	movs	r1, #0
   2ddd2:	2001      	movs	r0, #1
   2ddd4:	f7ef fbe2 	bl	1d59c <AppAdvSetData>

   // Setup the advertising mode
   AppSetBondable(FALSE);
   2ddd8:	2000      	movs	r0, #0
   2ddda:	f7ef fad7 	bl	1d38c <AppSetBondable>
   AppSetAdvType(DM_ADV_CONN_UNDIRECT);
   2ddde:	2000      	movs	r0, #0
   2dde0:	f7ef fc5e 	bl	1d6a0 <AppSetAdvType>
}
   2dde4:	bf00      	nop
   2dde6:	3718      	adds	r7, #24
   2dde8:	46bd      	mov	sp, r7
   2ddea:	bd80      	pop	{r7, pc}
   2ddec:	10008160 	.word	0x10008160
   2ddf0:	00045edc 	.word	0x00045edc
   2ddf4:	00045ed4 	.word	0x00045ed4
   2ddf8:	10002cec 	.word	0x10002cec
   2ddfc:	10008180 	.word	0x10008180

0002de00 <AppExtScanStop>:
// TotTag BLE Event Callbacks ------------------------------------------------------------------------------------------

#ifndef AM_DEBUG_PRINTF
void hci_process_trace_data(uint8_t *dbg_data, uint32_t len) {}
#endif
void AppExtScanStop(void) {}
   2de00:	b480      	push	{r7}
   2de02:	af00      	add	r7, sp, #0
   2de04:	bf00      	nop
   2de06:	46bd      	mov	sp, r7
   2de08:	f85d 7b04 	ldr.w	r7, [sp], #4
   2de0c:	4770      	bx	lr

0002de0e <AppExtConnOpen>:
dmConnId_t AppExtConnOpen(uint8_t initPhys, uint8_t addrType, uint8_t *pAddr, appDbHdl_t dbHdl) { return DM_CONN_ID_NONE; }
   2de0e:	b480      	push	{r7}
   2de10:	b085      	sub	sp, #20
   2de12:	af00      	add	r7, sp, #0
   2de14:	60ba      	str	r2, [r7, #8]
   2de16:	607b      	str	r3, [r7, #4]
   2de18:	4603      	mov	r3, r0
   2de1a:	73fb      	strb	r3, [r7, #15]
   2de1c:	460b      	mov	r3, r1
   2de1e:	73bb      	strb	r3, [r7, #14]
   2de20:	2300      	movs	r3, #0
   2de22:	4618      	mov	r0, r3
   2de24:	3714      	adds	r7, #20
   2de26:	46bd      	mov	sp, r7
   2de28:	f85d 7b04 	ldr.w	r7, [sp], #4
   2de2c:	4770      	bx	lr

0002de2e <AppUiBtnPressed>:
void AppUiBtnPressed(void) {}
   2de2e:	b480      	push	{r7}
   2de30:	af00      	add	r7, sp, #0
   2de32:	bf00      	nop
   2de34:	46bd      	mov	sp, r7
   2de36:	f85d 7b04 	ldr.w	r7, [sp], #4
   2de3a:	4770      	bx	lr

0002de3c <appUiTimerExpired>:
void appUiTimerExpired(wsfMsgHdr_t *pMsg) {}
   2de3c:	b480      	push	{r7}
   2de3e:	b083      	sub	sp, #12
   2de40:	af00      	add	r7, sp, #0
   2de42:	6078      	str	r0, [r7, #4]
   2de44:	bf00      	nop
   2de46:	370c      	adds	r7, #12
   2de48:	46bd      	mov	sp, r7
   2de4a:	f85d 7b04 	ldr.w	r7, [sp], #4
   2de4e:	4770      	bx	lr

0002de50 <appUiBtnPoll>:
void appUiBtnPoll(void) {}
   2de50:	b480      	push	{r7}
   2de52:	af00      	add	r7, sp, #0
   2de54:	bf00      	nop
   2de56:	46bd      	mov	sp, r7
   2de58:	f85d 7b04 	ldr.w	r7, [sp], #4
   2de5c:	4770      	bx	lr
	...

0002de60 <deviceManagerCallback>:

static void deviceManagerCallback(dmEvt_t *pDmEvt)
{
   2de60:	b5f0      	push	{r4, r5, r6, r7, lr}
   2de62:	b08b      	sub	sp, #44	; 0x2c
   2de64:	af04      	add	r7, sp, #16
   2de66:	6078      	str	r0, [r7, #4]
   // Give the BLE protocol stack a first chance to handle the event
   dmConnId_t conn_id = (dmConnId_t)pDmEvt->hdr.param;
   2de68:	687b      	ldr	r3, [r7, #4]
   2de6a:	881b      	ldrh	r3, [r3, #0]
   2de6c:	75fb      	strb	r3, [r7, #23]
   if ((conn_id == DM_CONN_ID_NONE) || (DmConnRole(conn_id) == DM_ROLE_MASTER))
   2de6e:	7dfb      	ldrb	r3, [r7, #23]
   2de70:	2b00      	cmp	r3, #0
   2de72:	d006      	beq.n	2de82 <deviceManagerCallback+0x22>
   2de74:	7dfb      	ldrb	r3, [r7, #23]
   2de76:	4618      	mov	r0, r3
   2de78:	f7f5 fc04 	bl	23684 <DmConnRole>
   2de7c:	4603      	mov	r3, r0
   2de7e:	2b00      	cmp	r3, #0
   2de80:	d105      	bne.n	2de8e <deviceManagerCallback+0x2e>
   {
      AppMasterProcDmMsg(pDmEvt);
   2de82:	6878      	ldr	r0, [r7, #4]
   2de84:	f7ed fdc8 	bl	1ba18 <AppMasterProcDmMsg>
      AppMasterSecProcDmMsg(pDmEvt);
   2de88:	6878      	ldr	r0, [r7, #4]
   2de8a:	f7ed fe73 	bl	1bb74 <AppMasterSecProcDmMsg>
   }
   if ((conn_id == DM_CONN_ID_NONE) || (DmConnRole(conn_id) == DM_ROLE_SLAVE))
   2de8e:	7dfb      	ldrb	r3, [r7, #23]
   2de90:	2b00      	cmp	r3, #0
   2de92:	d006      	beq.n	2dea2 <deviceManagerCallback+0x42>
   2de94:	7dfb      	ldrb	r3, [r7, #23]
   2de96:	4618      	mov	r0, r3
   2de98:	f7f5 fbf4 	bl	23684 <DmConnRole>
   2de9c:	4603      	mov	r3, r0
   2de9e:	2b01      	cmp	r3, #1
   2dea0:	d105      	bne.n	2deae <deviceManagerCallback+0x4e>
   {
      AppSlaveProcDmMsg(pDmEvt);
   2dea2:	6878      	ldr	r0, [r7, #4]
   2dea4:	f7ee fe6e 	bl	1cb84 <AppSlaveProcDmMsg>
      AppSlaveSecProcDmMsg(pDmEvt);
   2dea8:	6878      	ldr	r0, [r7, #4]
   2deaa:	f7ef f9e9 	bl	1d280 <AppSlaveSecProcDmMsg>
   }

   // Handle the Device Manager message based on its type
   switch (pDmEvt->hdr.event)
   2deae:	687b      	ldr	r3, [r7, #4]
   2deb0:	789b      	ldrb	r3, [r3, #2]
   2deb2:	3b20      	subs	r3, #32
   2deb4:	2b26      	cmp	r3, #38	; 0x26
   2deb6:	f200 815b 	bhi.w	2e170 <deviceManagerCallback+0x310>
   2deba:	a201      	add	r2, pc, #4	; (adr r2, 2dec0 <deviceManagerCallback+0x60>)
   2debc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   2dec0:	0002df5d 	.word	0x0002df5d
   2dec4:	0002e015 	.word	0x0002e015
   2dec8:	0002e023 	.word	0x0002e023
   2decc:	0002e171 	.word	0x0002e171
   2ded0:	0002e041 	.word	0x0002e041
   2ded4:	0002e069 	.word	0x0002e069
   2ded8:	0002e08d 	.word	0x0002e08d
   2dedc:	0002df9d 	.word	0x0002df9d
   2dee0:	0002dfe9 	.word	0x0002dfe9
   2dee4:	0002e171 	.word	0x0002e171
   2dee8:	0002e171 	.word	0x0002e171
   2deec:	0002e171 	.word	0x0002e171
   2def0:	0002e171 	.word	0x0002e171
   2def4:	0002e171 	.word	0x0002e171
   2def8:	0002e171 	.word	0x0002e171
   2defc:	0002e171 	.word	0x0002e171
   2df00:	0002e171 	.word	0x0002e171
   2df04:	0002e171 	.word	0x0002e171
   2df08:	0002e171 	.word	0x0002e171
   2df0c:	0002e171 	.word	0x0002e171
   2df10:	0002e171 	.word	0x0002e171
   2df14:	0002e171 	.word	0x0002e171
   2df18:	0002e171 	.word	0x0002e171
   2df1c:	0002e171 	.word	0x0002e171
   2df20:	0002e171 	.word	0x0002e171
   2df24:	0002e171 	.word	0x0002e171
   2df28:	0002e171 	.word	0x0002e171
   2df2c:	0002e171 	.word	0x0002e171
   2df30:	0002e171 	.word	0x0002e171
   2df34:	0002e171 	.word	0x0002e171
   2df38:	0002e171 	.word	0x0002e171
   2df3c:	0002e171 	.word	0x0002e171
   2df40:	0002e171 	.word	0x0002e171
   2df44:	0002e171 	.word	0x0002e171
   2df48:	0002e171 	.word	0x0002e171
   2df4c:	0002e171 	.word	0x0002e171
   2df50:	0002e171 	.word	0x0002e171
   2df54:	0002e171 	.word	0x0002e171
   2df58:	0002e15d 	.word	0x0002e15d
   {
      case DM_RESET_CMPL_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_RESET_CMPL_IND\n");
   2df5c:	488d      	ldr	r0, [pc, #564]	; (2e194 <deviceManagerCallback+0x334>)
   2df5e:	f7ec fe1f 	bl	1aba0 <am_util_stdio_printf>
         AttsCalculateDbHash();
   2df62:	f7f2 f827 	bl	1ffb4 <AttsCalculateDbHash>
         advertising_setup(pDmEvt);
   2df66:	6878      	ldr	r0, [r7, #4]
   2df68:	f7ff feec 	bl	2dd44 <advertising_setup>
         is_initialized = true;
   2df6c:	4b8a      	ldr	r3, [pc, #552]	; (2e198 <deviceManagerCallback+0x338>)
   2df6e:	2201      	movs	r2, #1
   2df70:	701a      	strb	r2, [r3, #0]
         if (expected_advertising)
   2df72:	4b8a      	ldr	r3, [pc, #552]	; (2e19c <deviceManagerCallback+0x33c>)
   2df74:	781b      	ldrb	r3, [r3, #0]
   2df76:	b2db      	uxtb	r3, r3
   2df78:	2b00      	cmp	r3, #0
   2df7a:	d002      	beq.n	2df82 <deviceManagerCallback+0x122>
            bluetooth_start_advertising();
   2df7c:	f000 faa6 	bl	2e4cc <bluetooth_start_advertising>
   2df80:	e001      	b.n	2df86 <deviceManagerCallback+0x126>
         else
            bluetooth_stop_advertising();
   2df82:	f000 fab9 	bl	2e4f8 <bluetooth_stop_advertising>
         if (expected_scanning)
   2df86:	4b86      	ldr	r3, [pc, #536]	; (2e1a0 <deviceManagerCallback+0x340>)
   2df88:	781b      	ldrb	r3, [r3, #0]
   2df8a:	b2db      	uxtb	r3, r3
   2df8c:	2b00      	cmp	r3, #0
   2df8e:	d002      	beq.n	2df96 <deviceManagerCallback+0x136>
            bluetooth_start_scanning();
   2df90:	f000 fac4 	bl	2e51c <bluetooth_start_scanning>
         else
            bluetooth_stop_scanning();
         break;
   2df94:	e0fa      	b.n	2e18c <deviceManagerCallback+0x32c>
            bluetooth_stop_scanning();
   2df96:	f000 fad9 	bl	2e54c <bluetooth_stop_scanning>
         break;
   2df9a:	e0f7      	b.n	2e18c <deviceManagerCallback+0x32c>
      case DM_CONN_OPEN_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_CONN_OPEN_IND\n");
   2df9c:	4881      	ldr	r0, [pc, #516]	; (2e1a4 <deviceManagerCallback+0x344>)
   2df9e:	f7ec fdff 	bl	1aba0 <am_util_stdio_printf>
         is_connected = true;
   2dfa2:	4b81      	ldr	r3, [pc, #516]	; (2e1a8 <deviceManagerCallback+0x348>)
   2dfa4:	2201      	movs	r2, #1
   2dfa6:	701a      	strb	r2, [r3, #0]
         connection_mtu = AttGetMtu(pDmEvt->hdr.param);
   2dfa8:	687b      	ldr	r3, [r7, #4]
   2dfaa:	881b      	ldrh	r3, [r3, #0]
   2dfac:	b2db      	uxtb	r3, r3
   2dfae:	4618      	mov	r0, r3
   2dfb0:	f7ef fd8e 	bl	1dad0 <AttGetMtu>
   2dfb4:	4603      	mov	r3, r0
   2dfb6:	461a      	mov	r2, r3
   2dfb8:	4b7c      	ldr	r3, [pc, #496]	; (2e1ac <deviceManagerCallback+0x34c>)
   2dfba:	801a      	strh	r2, [r3, #0]
         AttsCccInitTable(pDmEvt->hdr.param, NULL);
   2dfbc:	687b      	ldr	r3, [r7, #4]
   2dfbe:	881b      	ldrh	r3, [r3, #0]
   2dfc0:	b2db      	uxtb	r3, r3
   2dfc2:	2100      	movs	r1, #0
   2dfc4:	4618      	mov	r0, r3
   2dfc6:	f7f1 f81b 	bl	1f000 <AttsCccInitTable>
         if (DmConnRole(conn_id) == DM_ROLE_MASTER)
   2dfca:	7dfb      	ldrb	r3, [r7, #23]
   2dfcc:	4618      	mov	r0, r3
   2dfce:	f7f5 fb59 	bl	23684 <DmConnRole>
   2dfd2:	4603      	mov	r3, r0
   2dfd4:	2b00      	cmp	r3, #0
   2dfd6:	f040 80d2 	bne.w	2e17e <deviceManagerCallback+0x31e>
            AttcWriteReq(conn_id, REQUEST_HANDLE, sizeof(requesting_id), requesting_id);
   2dfda:	7df8      	ldrb	r0, [r7, #23]
   2dfdc:	4b74      	ldr	r3, [pc, #464]	; (2e1b0 <deviceManagerCallback+0x350>)
   2dfde:	2206      	movs	r2, #6
   2dfe0:	2162      	movs	r1, #98	; 0x62
   2dfe2:	f7f0 fd1d 	bl	1ea20 <AttcWriteReq>
         break;
   2dfe6:	e0ca      	b.n	2e17e <deviceManagerCallback+0x31e>
      case DM_CONN_CLOSE_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_CONN_CLOSE_IND\n");
   2dfe8:	4872      	ldr	r0, [pc, #456]	; (2e1b4 <deviceManagerCallback+0x354>)
   2dfea:	f7ec fdd9 	bl	1aba0 <am_util_stdio_printf>
         is_connected = ranges_requested = data_requested = quick_scanning = false;
   2dfee:	2200      	movs	r2, #0
   2dff0:	4b71      	ldr	r3, [pc, #452]	; (2e1b8 <deviceManagerCallback+0x358>)
   2dff2:	4611      	mov	r1, r2
   2dff4:	7019      	strb	r1, [r3, #0]
   2dff6:	4b71      	ldr	r3, [pc, #452]	; (2e1bc <deviceManagerCallback+0x35c>)
   2dff8:	4611      	mov	r1, r2
   2dffa:	7019      	strb	r1, [r3, #0]
   2dffc:	4b70      	ldr	r3, [pc, #448]	; (2e1c0 <deviceManagerCallback+0x360>)
   2dffe:	4611      	mov	r1, r2
   2e000:	7019      	strb	r1, [r3, #0]
   2e002:	4b69      	ldr	r3, [pc, #420]	; (2e1a8 <deviceManagerCallback+0x348>)
   2e004:	701a      	strb	r2, [r3, #0]
         AttsCccClearTable(pDmEvt->hdr.param);
   2e006:	687b      	ldr	r3, [r7, #4]
   2e008:	881b      	ldrh	r3, [r3, #0]
   2e00a:	b2db      	uxtb	r3, r3
   2e00c:	4618      	mov	r0, r3
   2e00e:	f7f1 f83f 	bl	1f090 <AttsCccClearTable>
         break;
   2e012:	e0bb      	b.n	2e18c <deviceManagerCallback+0x32c>
      case DM_ADV_START_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_ADV_START_IND\n");
   2e014:	486b      	ldr	r0, [pc, #428]	; (2e1c4 <deviceManagerCallback+0x364>)
   2e016:	f7ec fdc3 	bl	1aba0 <am_util_stdio_printf>
         is_advertising = true;
   2e01a:	4b6b      	ldr	r3, [pc, #428]	; (2e1c8 <deviceManagerCallback+0x368>)
   2e01c:	2201      	movs	r2, #1
   2e01e:	701a      	strb	r2, [r3, #0]
         break;
   2e020:	e0b4      	b.n	2e18c <deviceManagerCallback+0x32c>
      case DM_ADV_STOP_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_ADV_STOP_IND\n");
   2e022:	486a      	ldr	r0, [pc, #424]	; (2e1cc <deviceManagerCallback+0x36c>)
   2e024:	f7ec fdbc 	bl	1aba0 <am_util_stdio_printf>
         is_advertising = false;
   2e028:	4b67      	ldr	r3, [pc, #412]	; (2e1c8 <deviceManagerCallback+0x368>)
   2e02a:	2200      	movs	r2, #0
   2e02c:	701a      	strb	r2, [r3, #0]
         if (expected_advertising)
   2e02e:	4b5b      	ldr	r3, [pc, #364]	; (2e19c <deviceManagerCallback+0x33c>)
   2e030:	781b      	ldrb	r3, [r3, #0]
   2e032:	b2db      	uxtb	r3, r3
   2e034:	2b00      	cmp	r3, #0
   2e036:	f000 80a4 	beq.w	2e182 <deviceManagerCallback+0x322>
            bluetooth_start_advertising();
   2e03a:	f000 fa47 	bl	2e4cc <bluetooth_start_advertising>
         break;
   2e03e:	e0a0      	b.n	2e182 <deviceManagerCallback+0x322>
      case DM_SCAN_START_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_SCAN_START_IND\n");
   2e040:	4863      	ldr	r0, [pc, #396]	; (2e1d0 <deviceManagerCallback+0x370>)
   2e042:	f7ec fdad 	bl	1aba0 <am_util_stdio_printf>
         is_scanning = !quick_scanning;
   2e046:	4b5c      	ldr	r3, [pc, #368]	; (2e1b8 <deviceManagerCallback+0x358>)
   2e048:	781b      	ldrb	r3, [r3, #0]
   2e04a:	b2db      	uxtb	r3, r3
   2e04c:	2b00      	cmp	r3, #0
   2e04e:	bf14      	ite	ne
   2e050:	2301      	movne	r3, #1
   2e052:	2300      	moveq	r3, #0
   2e054:	b2db      	uxtb	r3, r3
   2e056:	f083 0301 	eor.w	r3, r3, #1
   2e05a:	b2db      	uxtb	r3, r3
   2e05c:	f003 0301 	and.w	r3, r3, #1
   2e060:	b2da      	uxtb	r2, r3
   2e062:	4b5c      	ldr	r3, [pc, #368]	; (2e1d4 <deviceManagerCallback+0x374>)
   2e064:	701a      	strb	r2, [r3, #0]
         break;
   2e066:	e091      	b.n	2e18c <deviceManagerCallback+0x32c>
      case DM_SCAN_STOP_IND:
         print("TotTag BLE: deviceManagerCallback: Received DM_SCAN_STOP_IND\n");
   2e068:	485b      	ldr	r0, [pc, #364]	; (2e1d8 <deviceManagerCallback+0x378>)
   2e06a:	f7ec fd99 	bl	1aba0 <am_util_stdio_printf>
         is_scanning = quick_scanning = false;
   2e06e:	2100      	movs	r1, #0
   2e070:	4b51      	ldr	r3, [pc, #324]	; (2e1b8 <deviceManagerCallback+0x358>)
   2e072:	460a      	mov	r2, r1
   2e074:	701a      	strb	r2, [r3, #0]
   2e076:	4b57      	ldr	r3, [pc, #348]	; (2e1d4 <deviceManagerCallback+0x374>)
   2e078:	460a      	mov	r2, r1
   2e07a:	701a      	strb	r2, [r3, #0]
         if (expected_scanning)
   2e07c:	4b48      	ldr	r3, [pc, #288]	; (2e1a0 <deviceManagerCallback+0x340>)
   2e07e:	781b      	ldrb	r3, [r3, #0]
   2e080:	b2db      	uxtb	r3, r3
   2e082:	2b00      	cmp	r3, #0
   2e084:	d07f      	beq.n	2e186 <deviceManagerCallback+0x326>
            bluetooth_start_scanning();
   2e086:	f000 fa49 	bl	2e51c <bluetooth_start_scanning>
         break;
   2e08a:	e07c      	b.n	2e186 <deviceManagerCallback+0x326>
      case DM_SCAN_REPORT_IND:
      {
         uint8_t *nameLengthData = DmFindAdType(DM_ADV_TYPE_LOCAL_NAME, pDmEvt->scanReport.len, pDmEvt->scanReport.pData);
   2e08c:	687b      	ldr	r3, [r7, #4]
   2e08e:	7a1b      	ldrb	r3, [r3, #8]
   2e090:	b299      	uxth	r1, r3
   2e092:	687b      	ldr	r3, [r7, #4]
   2e094:	685b      	ldr	r3, [r3, #4]
   2e096:	461a      	mov	r2, r3
   2e098:	2009      	movs	r0, #9
   2e09a:	f7f5 fea9 	bl	23df0 <DmFindAdType>
   2e09e:	6138      	str	r0, [r7, #16]
         uint8_t *rangingRoleData = DmFindAdType(DM_ADV_TYPE_MANUFACTURER, pDmEvt->scanReport.len, pDmEvt->scanReport.pData);
   2e0a0:	687b      	ldr	r3, [r7, #4]
   2e0a2:	7a1b      	ldrb	r3, [r3, #8]
   2e0a4:	b299      	uxth	r1, r3
   2e0a6:	687b      	ldr	r3, [r7, #4]
   2e0a8:	685b      	ldr	r3, [r3, #4]
   2e0aa:	461a      	mov	r2, r3
   2e0ac:	20ff      	movs	r0, #255	; 0xff
   2e0ae:	f7f5 fe9f 	bl	23df0 <DmFindAdType>
   2e0b2:	60f8      	str	r0, [r7, #12]
         if (nameLengthData && rangingRoleData && (*nameLengthData == (1 + sizeof(adv_local_name))) && (*rangingRoleData == (1 + sizeof(current_ranging_role))) &&
   2e0b4:	693b      	ldr	r3, [r7, #16]
   2e0b6:	2b00      	cmp	r3, #0
   2e0b8:	d067      	beq.n	2e18a <deviceManagerCallback+0x32a>
   2e0ba:	68fb      	ldr	r3, [r7, #12]
   2e0bc:	2b00      	cmp	r3, #0
   2e0be:	d064      	beq.n	2e18a <deviceManagerCallback+0x32a>
   2e0c0:	693b      	ldr	r3, [r7, #16]
   2e0c2:	781b      	ldrb	r3, [r3, #0]
   2e0c4:	2b07      	cmp	r3, #7
   2e0c6:	d160      	bne.n	2e18a <deviceManagerCallback+0x32a>
   2e0c8:	68fb      	ldr	r3, [r7, #12]
   2e0ca:	781b      	ldrb	r3, [r3, #0]
   2e0cc:	2b04      	cmp	r3, #4
   2e0ce:	d15c      	bne.n	2e18a <deviceManagerCallback+0x32a>
               (memcmp(adv_local_name, nameLengthData + 2, sizeof(adv_local_name)) == 0) && (current_ranging_role[0] == rangingRoleData[2]) && (current_ranging_role[1] == rangingRoleData[3]))
   2e0d0:	693b      	ldr	r3, [r7, #16]
   2e0d2:	3302      	adds	r3, #2
   2e0d4:	2206      	movs	r2, #6
   2e0d6:	4619      	mov	r1, r3
   2e0d8:	4840      	ldr	r0, [pc, #256]	; (2e1dc <deviceManagerCallback+0x37c>)
   2e0da:	f001 ff6d 	bl	2ffb8 <memcmp>
   2e0de:	4603      	mov	r3, r0
         if (nameLengthData && rangingRoleData && (*nameLengthData == (1 + sizeof(adv_local_name))) && (*rangingRoleData == (1 + sizeof(current_ranging_role))) &&
   2e0e0:	2b00      	cmp	r3, #0
   2e0e2:	d152      	bne.n	2e18a <deviceManagerCallback+0x32a>
               (memcmp(adv_local_name, nameLengthData + 2, sizeof(adv_local_name)) == 0) && (current_ranging_role[0] == rangingRoleData[2]) && (current_ranging_role[1] == rangingRoleData[3]))
   2e0e4:	4b3e      	ldr	r3, [pc, #248]	; (2e1e0 <deviceManagerCallback+0x380>)
   2e0e6:	781a      	ldrb	r2, [r3, #0]
   2e0e8:	68fb      	ldr	r3, [r7, #12]
   2e0ea:	3302      	adds	r3, #2
   2e0ec:	781b      	ldrb	r3, [r3, #0]
   2e0ee:	429a      	cmp	r2, r3
   2e0f0:	d14b      	bne.n	2e18a <deviceManagerCallback+0x32a>
   2e0f2:	4b3b      	ldr	r3, [pc, #236]	; (2e1e0 <deviceManagerCallback+0x380>)
   2e0f4:	785a      	ldrb	r2, [r3, #1]
   2e0f6:	68fb      	ldr	r3, [r7, #12]
   2e0f8:	3303      	adds	r3, #3
   2e0fa:	781b      	ldrb	r3, [r3, #0]
   2e0fc:	429a      	cmp	r2, r3
   2e0fe:	d144      	bne.n	2e18a <deviceManagerCallback+0x32a>
         {
            print("TotTag BLE: Found TotTag: %02x:%02x:%02x:%02x:%02x:%02x rssi: %d\n",
   2e100:	687b      	ldr	r3, [r7, #4]
   2e102:	7c5b      	ldrb	r3, [r3, #17]
   2e104:	461c      	mov	r4, r3
   2e106:	687b      	ldr	r3, [r7, #4]
   2e108:	7c1b      	ldrb	r3, [r3, #16]
   2e10a:	461d      	mov	r5, r3
   2e10c:	687b      	ldr	r3, [r7, #4]
   2e10e:	7bdb      	ldrb	r3, [r3, #15]
   2e110:	461e      	mov	r6, r3
   2e112:	687b      	ldr	r3, [r7, #4]
   2e114:	7b9b      	ldrb	r3, [r3, #14]
   2e116:	461a      	mov	r2, r3
   2e118:	687b      	ldr	r3, [r7, #4]
   2e11a:	7b5b      	ldrb	r3, [r3, #13]
   2e11c:	4619      	mov	r1, r3
   2e11e:	687b      	ldr	r3, [r7, #4]
   2e120:	7b1b      	ldrb	r3, [r3, #12]
   2e122:	4618      	mov	r0, r3
   2e124:	687b      	ldr	r3, [r7, #4]
   2e126:	f993 3009 	ldrsb.w	r3, [r3, #9]
   2e12a:	9303      	str	r3, [sp, #12]
   2e12c:	9002      	str	r0, [sp, #8]
   2e12e:	9101      	str	r1, [sp, #4]
   2e130:	9200      	str	r2, [sp, #0]
   2e132:	4633      	mov	r3, r6
   2e134:	462a      	mov	r2, r5
   2e136:	4621      	mov	r1, r4
   2e138:	482a      	ldr	r0, [pc, #168]	; (2e1e4 <deviceManagerCallback+0x384>)
   2e13a:	f7ec fd31 	bl	1aba0 <am_util_stdio_printf>
                  pDmEvt->scanReport.addr[5], pDmEvt->scanReport.addr[4], pDmEvt->scanReport.addr[3],
                  pDmEvt->scanReport.addr[2], pDmEvt->scanReport.addr[1], pDmEvt->scanReport.addr[0], pDmEvt->scanReport.rssi);
            if (discovery_callback)
   2e13e:	4b2a      	ldr	r3, [pc, #168]	; (2e1e8 <deviceManagerCallback+0x388>)
   2e140:	681b      	ldr	r3, [r3, #0]
   2e142:	2b00      	cmp	r3, #0
   2e144:	d021      	beq.n	2e18a <deviceManagerCallback+0x32a>
               discovery_callback(pDmEvt->scanReport.addr, rangingRoleData[4]);
   2e146:	4b28      	ldr	r3, [pc, #160]	; (2e1e8 <deviceManagerCallback+0x388>)
   2e148:	681b      	ldr	r3, [r3, #0]
   2e14a:	687a      	ldr	r2, [r7, #4]
   2e14c:	f102 000c 	add.w	r0, r2, #12
   2e150:	68fa      	ldr	r2, [r7, #12]
   2e152:	3204      	adds	r2, #4
   2e154:	7812      	ldrb	r2, [r2, #0]
   2e156:	4611      	mov	r1, r2
   2e158:	4798      	blx	r3
         }
         break;
   2e15a:	e016      	b.n	2e18a <deviceManagerCallback+0x32a>
      }
      case DM_PHY_UPDATE_IND:
         print("TotTag BLE: deviceManagerCallback: Negotiated PHY: RX = %d, TX = %d\n", pDmEvt->phyUpdate.rxPhy, pDmEvt->phyUpdate.txPhy);
   2e15c:	687b      	ldr	r3, [r7, #4]
   2e15e:	7a5b      	ldrb	r3, [r3, #9]
   2e160:	4619      	mov	r1, r3
   2e162:	687b      	ldr	r3, [r7, #4]
   2e164:	7a1b      	ldrb	r3, [r3, #8]
   2e166:	461a      	mov	r2, r3
   2e168:	4820      	ldr	r0, [pc, #128]	; (2e1ec <deviceManagerCallback+0x38c>)
   2e16a:	f7ec fd19 	bl	1aba0 <am_util_stdio_printf>
         break;
   2e16e:	e00d      	b.n	2e18c <deviceManagerCallback+0x32c>
      default:
         print("TotTag BLE: deviceManagerCallback: Received Event ID %d\n", pDmEvt->hdr.event);
   2e170:	687b      	ldr	r3, [r7, #4]
   2e172:	789b      	ldrb	r3, [r3, #2]
   2e174:	4619      	mov	r1, r3
   2e176:	481e      	ldr	r0, [pc, #120]	; (2e1f0 <deviceManagerCallback+0x390>)
   2e178:	f7ec fd12 	bl	1aba0 <am_util_stdio_printf>
         break;
   2e17c:	e006      	b.n	2e18c <deviceManagerCallback+0x32c>
         break;
   2e17e:	bf00      	nop
   2e180:	e004      	b.n	2e18c <deviceManagerCallback+0x32c>
         break;
   2e182:	bf00      	nop
   2e184:	e002      	b.n	2e18c <deviceManagerCallback+0x32c>
         break;
   2e186:	bf00      	nop
   2e188:	e000      	b.n	2e18c <deviceManagerCallback+0x32c>
         break;
   2e18a:	bf00      	nop
   }
}
   2e18c:	bf00      	nop
   2e18e:	371c      	adds	r7, #28
   2e190:	46bd      	mov	sp, r7
   2e192:	bdf0      	pop	{r4, r5, r6, r7, pc}
   2e194:	00045224 	.word	0x00045224
   2e198:	1000815e 	.word	0x1000815e
   2e19c:	1000815d 	.word	0x1000815d
   2e1a0:	1000815c 	.word	0x1000815c
   2e1a4:	00045264 	.word	0x00045264
   2e1a8:	10008158 	.word	0x10008158
   2e1ac:	10008154 	.word	0x10008154
   2e1b0:	100081a8 	.word	0x100081a8
   2e1b4:	000452a4 	.word	0x000452a4
   2e1b8:	1000815a 	.word	0x1000815a
   2e1bc:	1000815b 	.word	0x1000815b
   2e1c0:	10008159 	.word	0x10008159
   2e1c4:	000452e4 	.word	0x000452e4
   2e1c8:	10008157 	.word	0x10008157
   2e1cc:	00045324 	.word	0x00045324
   2e1d0:	00045364 	.word	0x00045364
   2e1d4:	10008156 	.word	0x10008156
   2e1d8:	000453a4 	.word	0x000453a4
   2e1dc:	00045ed4 	.word	0x00045ed4
   2e1e0:	10002cec 	.word	0x10002cec
   2e1e4:	000453e4 	.word	0x000453e4
   2e1e8:	100081b0 	.word	0x100081b0
   2e1ec:	00045428 	.word	0x00045428
   2e1f0:	00045470 	.word	0x00045470

0002e1f4 <attProtocolCallback>:

static void attProtocolCallback(attEvt_t *pEvt)
{
   2e1f4:	b580      	push	{r7, lr}
   2e1f6:	b082      	sub	sp, #8
   2e1f8:	af00      	add	r7, sp, #0
   2e1fa:	6078      	str	r0, [r7, #4]
   // Handle the ATT Protocol message based on its type
   switch (pEvt->hdr.event)
   2e1fc:	687b      	ldr	r3, [r7, #4]
   2e1fe:	789b      	ldrb	r3, [r3, #2]
   2e200:	2b12      	cmp	r3, #18
   2e202:	d006      	beq.n	2e212 <attProtocolCallback+0x1e>
   2e204:	2b12      	cmp	r3, #18
   2e206:	dc40      	bgt.n	2e28a <attProtocolCallback+0x96>
   2e208:	2b09      	cmp	r3, #9
   2e20a:	d00d      	beq.n	2e228 <attProtocolCallback+0x34>
   2e20c:	2b0f      	cmp	r3, #15
   2e20e:	d01c      	beq.n	2e24a <attProtocolCallback+0x56>
   2e210:	e03b      	b.n	2e28a <attProtocolCallback+0x96>
   {
      case ATT_MTU_UPDATE_IND:
         print("TotTag BLE: attProtocolCallback: Negotiated MTU = %u\n", (uint32_t)pEvt->mtu);
   2e212:	687b      	ldr	r3, [r7, #4]
   2e214:	89db      	ldrh	r3, [r3, #14]
   2e216:	4619      	mov	r1, r3
   2e218:	4823      	ldr	r0, [pc, #140]	; (2e2a8 <attProtocolCallback+0xb4>)
   2e21a:	f7ec fcc1 	bl	1aba0 <am_util_stdio_printf>
         connection_mtu = pEvt->mtu;
   2e21e:	687b      	ldr	r3, [r7, #4]
   2e220:	89da      	ldrh	r2, [r3, #14]
   2e222:	4b22      	ldr	r3, [pc, #136]	; (2e2ac <attProtocolCallback+0xb8>)
   2e224:	801a      	strh	r2, [r3, #0]
         break;
   2e226:	e03a      	b.n	2e29e <attProtocolCallback+0xaa>
      case ATTC_WRITE_RSP:
         print("TotTag BLE: attProtocolCallback: Data Write Completed = %u\n", (uint32_t)pEvt->hdr.status);
   2e228:	687b      	ldr	r3, [r7, #4]
   2e22a:	78db      	ldrb	r3, [r3, #3]
   2e22c:	4619      	mov	r1, r3
   2e22e:	4820      	ldr	r0, [pc, #128]	; (2e2b0 <attProtocolCallback+0xbc>)
   2e230:	f7ec fcb6 	bl	1aba0 <am_util_stdio_printf>
         if (pEvt->handle == REQUEST_HANDLE)
   2e234:	687b      	ldr	r3, [r7, #4]
   2e236:	895b      	ldrh	r3, [r3, #10]
   2e238:	2b62      	cmp	r3, #98	; 0x62
   2e23a:	d12d      	bne.n	2e298 <attProtocolCallback+0xa4>
            AppConnClose((dmConnId_t)pEvt->hdr.param);
   2e23c:	687b      	ldr	r3, [r7, #4]
   2e23e:	881b      	ldrh	r3, [r3, #0]
   2e240:	b2db      	uxtb	r3, r3
   2e242:	4618      	mov	r0, r3
   2e244:	f7ec ffd6 	bl	1b1f4 <AppConnClose>
         break;
   2e248:	e026      	b.n	2e298 <attProtocolCallback+0xa4>
      case ATTS_HANDLE_VALUE_CNF:
         print("TotTag BLE: attProtocolCallback: Data Notify Completed = %u\n", (uint32_t)pEvt->hdr.status);
   2e24a:	687b      	ldr	r3, [r7, #4]
   2e24c:	78db      	ldrb	r3, [r3, #3]
   2e24e:	4619      	mov	r1, r3
   2e250:	4818      	ldr	r0, [pc, #96]	; (2e2b4 <attProtocolCallback+0xc0>)
   2e252:	f7ec fca5 	bl	1aba0 <am_util_stdio_printf>
         if ((pEvt->hdr.status == ATT_SUCCESS) && (pEvt->handle == MAINTENANCE_RESULT_HANDLE) && data_requested)
   2e256:	687b      	ldr	r3, [r7, #4]
   2e258:	78db      	ldrb	r3, [r3, #3]
   2e25a:	2b00      	cmp	r3, #0
   2e25c:	d11e      	bne.n	2e29c <attProtocolCallback+0xa8>
   2e25e:	687b      	ldr	r3, [r7, #4]
   2e260:	895b      	ldrh	r3, [r3, #10]
   2e262:	2b78      	cmp	r3, #120	; 0x78
   2e264:	d11a      	bne.n	2e29c <attProtocolCallback+0xa8>
   2e266:	4b14      	ldr	r3, [pc, #80]	; (2e2b8 <attProtocolCallback+0xc4>)
   2e268:	781b      	ldrb	r3, [r3, #0]
   2e26a:	b2db      	uxtb	r3, r3
   2e26c:	2b00      	cmp	r3, #0
   2e26e:	d015      	beq.n	2e29c <attProtocolCallback+0xa8>
            continueSendingLogData((dmConnId_t)pEvt->hdr.param, connection_mtu - 3);
   2e270:	687b      	ldr	r3, [r7, #4]
   2e272:	881b      	ldrh	r3, [r3, #0]
   2e274:	b2da      	uxtb	r2, r3
   2e276:	4b0d      	ldr	r3, [pc, #52]	; (2e2ac <attProtocolCallback+0xb8>)
   2e278:	881b      	ldrh	r3, [r3, #0]
   2e27a:	b29b      	uxth	r3, r3
   2e27c:	3b03      	subs	r3, #3
   2e27e:	b29b      	uxth	r3, r3
   2e280:	4619      	mov	r1, r3
   2e282:	4610      	mov	r0, r2
   2e284:	f001 fb40 	bl	2f908 <continueSendingLogData>
         break;
   2e288:	e008      	b.n	2e29c <attProtocolCallback+0xa8>
      default:
         print("TotTag BLE: attProtocolCallback: Received Event ID %d\n", pEvt->hdr.event);
   2e28a:	687b      	ldr	r3, [r7, #4]
   2e28c:	789b      	ldrb	r3, [r3, #2]
   2e28e:	4619      	mov	r1, r3
   2e290:	480a      	ldr	r0, [pc, #40]	; (2e2bc <attProtocolCallback+0xc8>)
   2e292:	f7ec fc85 	bl	1aba0 <am_util_stdio_printf>
         break;
   2e296:	e002      	b.n	2e29e <attProtocolCallback+0xaa>
         break;
   2e298:	bf00      	nop
   2e29a:	e000      	b.n	2e29e <attProtocolCallback+0xaa>
         break;
   2e29c:	bf00      	nop
   }
}
   2e29e:	bf00      	nop
   2e2a0:	3708      	adds	r7, #8
   2e2a2:	46bd      	mov	sp, r7
   2e2a4:	bd80      	pop	{r7, pc}
   2e2a6:	bf00      	nop
   2e2a8:	000454ac 	.word	0x000454ac
   2e2ac:	10008154 	.word	0x10008154
   2e2b0:	000454e4 	.word	0x000454e4
   2e2b4:	00045520 	.word	0x00045520
   2e2b8:	1000815b 	.word	0x1000815b
   2e2bc:	00045560 	.word	0x00045560

0002e2c0 <cccCallback>:

static void cccCallback(attsCccEvt_t *pEvt)
{
   2e2c0:	b580      	push	{r7, lr}
   2e2c2:	b082      	sub	sp, #8
   2e2c4:	af00      	add	r7, sp, #0
   2e2c6:	6078      	str	r0, [r7, #4]
   // Handle various BLE notification requests
   print("TotTag BLE: cccCallback: index = %d, handle = %d, value = %d\n", pEvt->idx, pEvt->handle, pEvt->value);
   2e2c8:	687b      	ldr	r3, [r7, #4]
   2e2ca:	7a1b      	ldrb	r3, [r3, #8]
   2e2cc:	4619      	mov	r1, r3
   2e2ce:	687b      	ldr	r3, [r7, #4]
   2e2d0:	889b      	ldrh	r3, [r3, #4]
   2e2d2:	461a      	mov	r2, r3
   2e2d4:	687b      	ldr	r3, [r7, #4]
   2e2d6:	88db      	ldrh	r3, [r3, #6]
   2e2d8:	4810      	ldr	r0, [pc, #64]	; (2e31c <cccCallback+0x5c>)
   2e2da:	f7ec fc61 	bl	1aba0 <am_util_stdio_printf>
   if (pEvt->idx == TOTTAG_RANGING_CCC_IDX)
   2e2de:	687b      	ldr	r3, [r7, #4]
   2e2e0:	7a1b      	ldrb	r3, [r3, #8]
   2e2e2:	2b01      	cmp	r3, #1
   2e2e4:	d109      	bne.n	2e2fa <cccCallback+0x3a>
      ranges_requested = (pEvt->value == ATT_CLIENT_CFG_NOTIFY);
   2e2e6:	687b      	ldr	r3, [r7, #4]
   2e2e8:	88db      	ldrh	r3, [r3, #6]
   2e2ea:	2b01      	cmp	r3, #1
   2e2ec:	bf0c      	ite	eq
   2e2ee:	2301      	moveq	r3, #1
   2e2f0:	2300      	movne	r3, #0
   2e2f2:	b2da      	uxtb	r2, r3
   2e2f4:	4b0a      	ldr	r3, [pc, #40]	; (2e320 <cccCallback+0x60>)
   2e2f6:	701a      	strb	r2, [r3, #0]
   else if (pEvt->idx == TOTTAG_MAINTENANCE_RESULT_CCC_IDX)
      data_requested = (pEvt->value == ATT_CLIENT_CFG_NOTIFY);
}
   2e2f8:	e00c      	b.n	2e314 <cccCallback+0x54>
   else if (pEvt->idx == TOTTAG_MAINTENANCE_RESULT_CCC_IDX)
   2e2fa:	687b      	ldr	r3, [r7, #4]
   2e2fc:	7a1b      	ldrb	r3, [r3, #8]
   2e2fe:	2b02      	cmp	r3, #2
   2e300:	d108      	bne.n	2e314 <cccCallback+0x54>
      data_requested = (pEvt->value == ATT_CLIENT_CFG_NOTIFY);
   2e302:	687b      	ldr	r3, [r7, #4]
   2e304:	88db      	ldrh	r3, [r3, #6]
   2e306:	2b01      	cmp	r3, #1
   2e308:	bf0c      	ite	eq
   2e30a:	2301      	moveq	r3, #1
   2e30c:	2300      	movne	r3, #0
   2e30e:	b2da      	uxtb	r2, r3
   2e310:	4b04      	ldr	r3, [pc, #16]	; (2e324 <cccCallback+0x64>)
   2e312:	701a      	strb	r2, [r3, #0]
}
   2e314:	bf00      	nop
   2e316:	3708      	adds	r7, #8
   2e318:	46bd      	mov	sp, r7
   2e31a:	bd80      	pop	{r7, pc}
   2e31c:	00045598 	.word	0x00045598
   2e320:	10008159 	.word	0x10008159
   2e324:	1000815b 	.word	0x1000815b

0002e328 <bluetooth_init>:


// Public API Functions ------------------------------------------------------------------------------------------------

void bluetooth_init(uint8_t* uid)
{
   2e328:	b580      	push	{r7, lr}
   2e32a:	b082      	sub	sp, #8
   2e32c:	af00      	add	r7, sp, #0
   2e32e:	6078      	str	r0, [r7, #4]
   // Initialize static variables
   data_requested = expected_scanning = expected_advertising = is_initialized = false;
   2e330:	2200      	movs	r2, #0
   2e332:	4b27      	ldr	r3, [pc, #156]	; (2e3d0 <bluetooth_init+0xa8>)
   2e334:	4611      	mov	r1, r2
   2e336:	7019      	strb	r1, [r3, #0]
   2e338:	4b26      	ldr	r3, [pc, #152]	; (2e3d4 <bluetooth_init+0xac>)
   2e33a:	4611      	mov	r1, r2
   2e33c:	7019      	strb	r1, [r3, #0]
   2e33e:	4b26      	ldr	r3, [pc, #152]	; (2e3d8 <bluetooth_init+0xb0>)
   2e340:	4611      	mov	r1, r2
   2e342:	7019      	strb	r1, [r3, #0]
   2e344:	4b25      	ldr	r3, [pc, #148]	; (2e3dc <bluetooth_init+0xb4>)
   2e346:	701a      	strb	r2, [r3, #0]
   is_scanning = is_advertising = is_connected = ranges_requested = quick_scanning = false;
   2e348:	2200      	movs	r2, #0
   2e34a:	4b25      	ldr	r3, [pc, #148]	; (2e3e0 <bluetooth_init+0xb8>)
   2e34c:	4611      	mov	r1, r2
   2e34e:	7019      	strb	r1, [r3, #0]
   2e350:	4b24      	ldr	r3, [pc, #144]	; (2e3e4 <bluetooth_init+0xbc>)
   2e352:	4611      	mov	r1, r2
   2e354:	7019      	strb	r1, [r3, #0]
   2e356:	4b24      	ldr	r3, [pc, #144]	; (2e3e8 <bluetooth_init+0xc0>)
   2e358:	4611      	mov	r1, r2
   2e35a:	7019      	strb	r1, [r3, #0]
   2e35c:	4b23      	ldr	r3, [pc, #140]	; (2e3ec <bluetooth_init+0xc4>)
   2e35e:	4611      	mov	r1, r2
   2e360:	7019      	strb	r1, [r3, #0]
   2e362:	4b23      	ldr	r3, [pc, #140]	; (2e3f0 <bluetooth_init+0xc8>)
   2e364:	701a      	strb	r2, [r3, #0]
   memcpy(device_id, uid, EUI_LEN);
   2e366:	4b23      	ldr	r3, [pc, #140]	; (2e3f4 <bluetooth_init+0xcc>)
   2e368:	687a      	ldr	r2, [r7, #4]
   2e36a:	6810      	ldr	r0, [r2, #0]
   2e36c:	6018      	str	r0, [r3, #0]
   2e36e:	8892      	ldrh	r2, [r2, #4]
   2e370:	809a      	strh	r2, [r3, #4]
   discovery_callback = NULL;
   2e372:	4b21      	ldr	r3, [pc, #132]	; (2e3f8 <bluetooth_init+0xd0>)
   2e374:	2200      	movs	r2, #0
   2e376:	601a      	str	r2, [r3, #0]

   // Set the Bluetooth address and boot the BLE radio
   HciVscSetCustom_BDAddr(uid);
   2e378:	6878      	ldr	r0, [r7, #4]
   2e37a:	f7f8 fce7 	bl	26d4c <HciVscSetCustom_BDAddr>
   configASSERT0(HciDrvRadioBoot(false));
   2e37e:	2000      	movs	r0, #0
   2e380:	f7f8 faf2 	bl	26968 <HciDrvRadioBoot>
   2e384:	4603      	mov	r3, r0
   2e386:	2b00      	cmp	r3, #0
   2e388:	d003      	beq.n	2e392 <bluetooth_init+0x6a>
   2e38a:	21fd      	movs	r1, #253	; 0xfd
   2e38c:	481b      	ldr	r0, [pc, #108]	; (2e3fc <bluetooth_init+0xd4>)
   2e38e:	f000 ff8f 	bl	2f2b0 <vAssertCalled>

   // Setup BLE interrupt priorities
   NVIC_SetPriority(COOPER_IOM_IRQn, NVIC_configMAX_SYSCALL_INTERRUPT_PRIORITY + 1);
   2e392:	2104      	movs	r1, #4
   2e394:	200a      	movs	r0, #10
   2e396:	f7ff fcab 	bl	2dcf0 <__NVIC_SetPriority>
   NVIC_SetPriority(AM_COOPER_IRQn, NVIC_configMAX_SYSCALL_INTERRUPT_PRIORITY + 1);
   2e39a:	2104      	movs	r1, #4
   2e39c:	2039      	movs	r0, #57	; 0x39
   2e39e:	f7ff fca7 	bl	2dcf0 <__NVIC_SetPriority>

   // Store all BLE configuration pointers
   pAppAdvCfg = (appAdvCfg_t*)&ble_adv_cfg;
   2e3a2:	4b17      	ldr	r3, [pc, #92]	; (2e400 <bluetooth_init+0xd8>)
   2e3a4:	4a17      	ldr	r2, [pc, #92]	; (2e404 <bluetooth_init+0xdc>)
   2e3a6:	601a      	str	r2, [r3, #0]
   pAppMasterCfg = (appMasterCfg_t*)&ble_master_cfg;
   2e3a8:	4b17      	ldr	r3, [pc, #92]	; (2e408 <bluetooth_init+0xe0>)
   2e3aa:	4a18      	ldr	r2, [pc, #96]	; (2e40c <bluetooth_init+0xe4>)
   2e3ac:	601a      	str	r2, [r3, #0]
   pAppSlaveCfg = (appSlaveCfg_t*)&ble_slave_cfg;
   2e3ae:	4b18      	ldr	r3, [pc, #96]	; (2e410 <bluetooth_init+0xe8>)
   2e3b0:	4a18      	ldr	r2, [pc, #96]	; (2e414 <bluetooth_init+0xec>)
   2e3b2:	601a      	str	r2, [r3, #0]
   pAppSecCfg = (appSecCfg_t*)&ble_sec_cfg;
   2e3b4:	4b18      	ldr	r3, [pc, #96]	; (2e418 <bluetooth_init+0xf0>)
   2e3b6:	4a19      	ldr	r2, [pc, #100]	; (2e41c <bluetooth_init+0xf4>)
   2e3b8:	601a      	str	r2, [r3, #0]
   pAppUpdateCfg = (appUpdateCfg_t*)&ble_update_cfg;
   2e3ba:	4b19      	ldr	r3, [pc, #100]	; (2e420 <bluetooth_init+0xf8>)
   2e3bc:	4a19      	ldr	r2, [pc, #100]	; (2e424 <bluetooth_init+0xfc>)
   2e3be:	601a      	str	r2, [r3, #0]
   pAttCfg = (attCfg_t*)&ble_att_cfg;
   2e3c0:	4b19      	ldr	r3, [pc, #100]	; (2e428 <bluetooth_init+0x100>)
   2e3c2:	4a1a      	ldr	r2, [pc, #104]	; (2e42c <bluetooth_init+0x104>)
   2e3c4:	601a      	str	r2, [r3, #0]
}
   2e3c6:	bf00      	nop
   2e3c8:	3708      	adds	r7, #8
   2e3ca:	46bd      	mov	sp, r7
   2e3cc:	bd80      	pop	{r7, pc}
   2e3ce:	bf00      	nop
   2e3d0:	1000815e 	.word	0x1000815e
   2e3d4:	1000815d 	.word	0x1000815d
   2e3d8:	1000815c 	.word	0x1000815c
   2e3dc:	1000815b 	.word	0x1000815b
   2e3e0:	1000815a 	.word	0x1000815a
   2e3e4:	10008159 	.word	0x10008159
   2e3e8:	10008158 	.word	0x10008158
   2e3ec:	10008157 	.word	0x10008157
   2e3f0:	10008156 	.word	0x10008156
   2e3f4:	100081a0 	.word	0x100081a0
   2e3f8:	100081b0 	.word	0x100081b0
   2e3fc:	000455d8 	.word	0x000455d8
   2e400:	10010ecc 	.word	0x10010ecc
   2e404:	00045ee0 	.word	0x00045ee0
   2e408:	10010e94 	.word	0x10010e94
   2e40c:	00045f10 	.word	0x00045f10
   2e410:	10010e9c 	.word	0x10010e9c
   2e414:	00045eec 	.word	0x00045eec
   2e418:	10010ec0 	.word	0x10010ec0
   2e41c:	00045ef0 	.word	0x00045ef0
   2e420:	10010e98 	.word	0x10010e98
   2e424:	00045ef8 	.word	0x00045ef8
   2e428:	10002b8c 	.word	0x10002b8c
   2e42c:	00045f08 	.word	0x00045f08

0002e430 <bluetooth_start>:
   am_hal_gpio_state_write(AM_DEVICES_BLECTRLR_RESET_PIN, AM_HAL_GPIO_OUTPUT_SET);
   am_hal_gpio_state_write(AM_DEVICES_BLECTRLR_RESET_PIN, AM_HAL_GPIO_OUTPUT_CLEAR);
}

void bluetooth_start(void)
{
   2e430:	b580      	push	{r7, lr}
   2e432:	af00      	add	r7, sp, #0
   // Register all BLE protocol stack callback functions
   AppMasterInit();
   2e434:	f7ed fad8 	bl	1b9e8 <AppMasterInit>
   AppSlaveInit();
   2e438:	f7ee fb5c 	bl	1caf4 <AppSlaveInit>
   DmRegister(deviceManagerCallback);
   2e43c:	4817      	ldr	r0, [pc, #92]	; (2e49c <bluetooth_start+0x6c>)
   2e43e:	f7f5 fcaf 	bl	23da0 <DmRegister>
   DmConnRegister(DM_CLIENT_ID_APP, deviceManagerCallback);
   2e442:	4916      	ldr	r1, [pc, #88]	; (2e49c <bluetooth_start+0x6c>)
   2e444:	2003      	movs	r0, #3
   2e446:	f7f4 fed5 	bl	231f4 <DmConnRegister>
   AttRegister(attProtocolCallback);
   2e44a:	4815      	ldr	r0, [pc, #84]	; (2e4a0 <bluetooth_start+0x70>)
   2e44c:	f7ef fb20 	bl	1da90 <AttRegister>
   AttsCccRegister(TOTTAG_NUM_CCC_CHARACTERISTICS, (attsCccSet_t*)characteristicSet, cccCallback);
   2e450:	4a14      	ldr	r2, [pc, #80]	; (2e4a4 <bluetooth_start+0x74>)
   2e452:	4915      	ldr	r1, [pc, #84]	; (2e4a8 <bluetooth_start+0x78>)
   2e454:	2003      	movs	r0, #3
   2e456:	f7f0 fdb3 	bl	1efc0 <AttsCccRegister>

   // Initialize all TotTag BLE services
   gapGattRegisterCallbacks(GattReadCback, GattWriteCback);
   2e45a:	4914      	ldr	r1, [pc, #80]	; (2e4ac <bluetooth_start+0x7c>)
   2e45c:	4814      	ldr	r0, [pc, #80]	; (2e4b0 <bluetooth_start+0x80>)
   2e45e:	f001 f951 	bl	2f704 <gapGattRegisterCallbacks>
   gapGattAddGroup();
   2e462:	f001 f941 	bl	2f6e8 <gapGattAddGroup>
   deviceInfoAddGroup();
   2e466:	f001 f925 	bl	2f6b4 <deviceInfoAddGroup>
   liveStatsRegisterCallbacks(handleLiveStatsRead, handleLiveStatsWrite);
   2e46a:	4912      	ldr	r1, [pc, #72]	; (2e4b4 <bluetooth_start+0x84>)
   2e46c:	4812      	ldr	r0, [pc, #72]	; (2e4b8 <bluetooth_start+0x88>)
   2e46e:	f001 f9c5 	bl	2f7fc <liveStatsRegisterCallbacks>
   liveStatsAddGroup();
   2e472:	f001 f9b9 	bl	2f7e8 <liveStatsAddGroup>
   deviceMaintenanceRegisterCallbacks(handleDeviceMaintenanceRead, handleDeviceMaintenanceWrite);
   2e476:	4911      	ldr	r1, [pc, #68]	; (2e4bc <bluetooth_start+0x8c>)
   2e478:	4811      	ldr	r0, [pc, #68]	; (2e4c0 <bluetooth_start+0x90>)
   2e47a:	f001 fb07 	bl	2fa8c <deviceMaintenanceRegisterCallbacks>
   deviceMaintenanceAddGroup();
   2e47e:	f001 fafb 	bl	2fa78 <deviceMaintenanceAddGroup>
   schedulingRegisterCallbacks(handleSchedulingRead, handleSchedulingWrite);
   2e482:	4910      	ldr	r1, [pc, #64]	; (2e4c4 <bluetooth_start+0x94>)
   2e484:	4810      	ldr	r0, [pc, #64]	; (2e4c8 <bluetooth_start+0x98>)
   2e486:	f001 fba5 	bl	2fbd4 <schedulingRegisterCallbacks>
   schedulingAddGroup();
   2e48a:	f001 fb99 	bl	2fbc0 <schedulingAddGroup>

   // Set the GATT Service Changed CCCD index
   GattSetSvcChangedIdx(TOTTAG_GATT_SERVICE_CHANGED_CCC_IDX);
   2e48e:	2000      	movs	r0, #0
   2e490:	f7f6 fba8 	bl	24be4 <GattSetSvcChangedIdx>

   // Reset the BLE device
   DmDevReset();
   2e494:	f7f5 fc12 	bl	23cbc <DmDevReset>
}
   2e498:	bf00      	nop
   2e49a:	bd80      	pop	{r7, pc}
   2e49c:	0002de61 	.word	0x0002de61
   2e4a0:	0002e1f5 	.word	0x0002e1f5
   2e4a4:	0002e2c1 	.word	0x0002e2c1
   2e4a8:	00045f18 	.word	0x00045f18
   2e4ac:	00024c55 	.word	0x00024c55
   2e4b0:	00024c0d 	.word	0x00024c0d
   2e4b4:	0002f78d 	.word	0x0002f78d
   2e4b8:	0002f72d 	.word	0x0002f72d
   2e4bc:	0002f86d 	.word	0x0002f86d
   2e4c0:	0002f825 	.word	0x0002f825
   2e4c4:	0002fb79 	.word	0x0002fb79
   2e4c8:	0002fb41 	.word	0x0002fb41

0002e4cc <bluetooth_start_advertising>:
   if (ranges_requested)
      updateRangeResults(AppConnIsOpen(), results, results_length);
}

void bluetooth_start_advertising(void)
{
   2e4cc:	b580      	push	{r7, lr}
   2e4ce:	af00      	add	r7, sp, #0
   // Attempt to begin advertising
   expected_advertising = true;
   2e4d0:	4b07      	ldr	r3, [pc, #28]	; (2e4f0 <bluetooth_start_advertising+0x24>)
   2e4d2:	2201      	movs	r2, #1
   2e4d4:	701a      	strb	r2, [r3, #0]
   if (is_initialized)
   2e4d6:	4b07      	ldr	r3, [pc, #28]	; (2e4f4 <bluetooth_start_advertising+0x28>)
   2e4d8:	781b      	ldrb	r3, [r3, #0]
   2e4da:	b2db      	uxtb	r3, r3
   2e4dc:	2b00      	cmp	r3, #0
   2e4de:	d005      	beq.n	2e4ec <bluetooth_start_advertising+0x20>
   {
      HciVscSetRfPowerLevelEx(TX_POWER_LEVEL_0P0_dBm);
   2e4e0:	2004      	movs	r0, #4
   2e4e2:	f7f8 fc0b 	bl	26cfc <HciVscSetRfPowerLevelEx>
      AppAdvStart(APP_MODE_CONNECTABLE);
   2e4e6:	2000      	movs	r0, #0
   2e4e8:	f7ef f87a 	bl	1d5e0 <AppAdvStart>
   }
}
   2e4ec:	bf00      	nop
   2e4ee:	bd80      	pop	{r7, pc}
   2e4f0:	1000815d 	.word	0x1000815d
   2e4f4:	1000815e 	.word	0x1000815e

0002e4f8 <bluetooth_stop_advertising>:

void bluetooth_stop_advertising(void)
{
   2e4f8:	b580      	push	{r7, lr}
   2e4fa:	af00      	add	r7, sp, #0
   // Attempt to stop advertising
   expected_advertising = false;
   2e4fc:	4b05      	ldr	r3, [pc, #20]	; (2e514 <bluetooth_stop_advertising+0x1c>)
   2e4fe:	2200      	movs	r2, #0
   2e500:	701a      	strb	r2, [r3, #0]
   if (is_initialized)
   2e502:	4b05      	ldr	r3, [pc, #20]	; (2e518 <bluetooth_stop_advertising+0x20>)
   2e504:	781b      	ldrb	r3, [r3, #0]
   2e506:	b2db      	uxtb	r3, r3
   2e508:	2b00      	cmp	r3, #0
   2e50a:	d001      	beq.n	2e510 <bluetooth_stop_advertising+0x18>
      AppAdvStop();
   2e50c:	f7ef f896 	bl	1d63c <AppAdvStop>
}
   2e510:	bf00      	nop
   2e512:	bd80      	pop	{r7, pc}
   2e514:	1000815d 	.word	0x1000815d
   2e518:	1000815e 	.word	0x1000815e

0002e51c <bluetooth_start_scanning>:
   // Return whether advertising is currently enabled
   return is_advertising;
}

void bluetooth_start_scanning(void)
{
   2e51c:	b580      	push	{r7, lr}
   2e51e:	af00      	add	r7, sp, #0
   // Attempt to start scanning
   expected_scanning = true;
   2e520:	4b08      	ldr	r3, [pc, #32]	; (2e544 <bluetooth_start_scanning+0x28>)
   2e522:	2201      	movs	r2, #1
   2e524:	701a      	strb	r2, [r3, #0]
   if (is_initialized)
   2e526:	4b08      	ldr	r3, [pc, #32]	; (2e548 <bluetooth_start_scanning+0x2c>)
   2e528:	781b      	ldrb	r3, [r3, #0]
   2e52a:	b2db      	uxtb	r3, r3
   2e52c:	2b00      	cmp	r3, #0
   2e52e:	d006      	beq.n	2e53e <bluetooth_start_scanning+0x22>
      AppScanStart(ble_master_cfg.discMode, ble_master_cfg.scanType, ble_master_cfg.scanDuration);
   2e530:	2300      	movs	r3, #0
   2e532:	2100      	movs	r1, #0
   2e534:	f242 7210 	movw	r2, #10000	; 0x2710
   2e538:	4618      	mov	r0, r3
   2e53a:	f7ed fc5f 	bl	1bdfc <AppScanStart>
}
   2e53e:	bf00      	nop
   2e540:	bd80      	pop	{r7, pc}
   2e542:	bf00      	nop
   2e544:	1000815c 	.word	0x1000815c
   2e548:	1000815e 	.word	0x1000815e

0002e54c <bluetooth_stop_scanning>:

void bluetooth_stop_scanning(void)
{
   2e54c:	b580      	push	{r7, lr}
   2e54e:	af00      	add	r7, sp, #0
   // Attempt to stop scanning
   expected_scanning = false;
   2e550:	4b05      	ldr	r3, [pc, #20]	; (2e568 <bluetooth_stop_scanning+0x1c>)
   2e552:	2200      	movs	r2, #0
   2e554:	701a      	strb	r2, [r3, #0]
   if (is_initialized)
   2e556:	4b05      	ldr	r3, [pc, #20]	; (2e56c <bluetooth_stop_scanning+0x20>)
   2e558:	781b      	ldrb	r3, [r3, #0]
   2e55a:	b2db      	uxtb	r3, r3
   2e55c:	2b00      	cmp	r3, #0
   2e55e:	d001      	beq.n	2e564 <bluetooth_stop_scanning+0x18>
      AppScanStop();
   2e560:	f7ed fc74 	bl	1be4c <AppScanStop>
}
   2e564:	bf00      	nop
   2e566:	bd80      	pop	{r7, pc}
   2e568:	1000815c 	.word	0x1000815c
   2e56c:	1000815e 	.word	0x1000815e

0002e570 <continue_current_sequence>:
}

#endif  // #if REVISION_ID == REVISION_I

static void continue_current_sequence(void)
{
   2e570:	b580      	push	{r7, lr}
   2e572:	af00      	add	r7, sp, #0
   // Check whether the end of the sequence has been reached
   if (*current_frequency > 0)
   2e574:	4b34      	ldr	r3, [pc, #208]	; (2e648 <continue_current_sequence+0xd8>)
   2e576:	681b      	ldr	r3, [r3, #0]
   2e578:	881b      	ldrh	r3, [r3, #0]
   2e57a:	b29b      	uxth	r3, r3
   2e57c:	2b00      	cmp	r3, #0
   2e57e:	d050      	beq.n	2e622 <continue_current_sequence+0xb2>
   {
      // Check whether the current sequence value should be silence
      if (*current_frequency == 1)
   2e580:	4b31      	ldr	r3, [pc, #196]	; (2e648 <continue_current_sequence+0xd8>)
   2e582:	681b      	ldr	r3, [r3, #0]
   2e584:	881b      	ldrh	r3, [r3, #0]
   2e586:	b29b      	uxth	r3, r3
   2e588:	2b01      	cmp	r3, #1
   2e58a:	d113      	bne.n	2e5b4 <continue_current_sequence+0x44>
      {
         timer_config.ui32Compare0 = (*current_duration * buzzer_clock_hz) / 1000;
   2e58c:	4b2f      	ldr	r3, [pc, #188]	; (2e64c <continue_current_sequence+0xdc>)
   2e58e:	681b      	ldr	r3, [r3, #0]
   2e590:	881b      	ldrh	r3, [r3, #0]
   2e592:	b29b      	uxth	r3, r3
   2e594:	461a      	mov	r2, r3
   2e596:	4b2e      	ldr	r3, [pc, #184]	; (2e650 <continue_current_sequence+0xe0>)
   2e598:	fb03 f302 	mul.w	r3, r3, r2
   2e59c:	4a2d      	ldr	r2, [pc, #180]	; (2e654 <continue_current_sequence+0xe4>)
   2e59e:	fba2 2303 	umull	r2, r3, r2, r3
   2e5a2:	099b      	lsrs	r3, r3, #6
   2e5a4:	4a2c      	ldr	r2, [pc, #176]	; (2e658 <continue_current_sequence+0xe8>)
   2e5a6:	60d3      	str	r3, [r2, #12]
         timer_config.ui32Compare1 = timer_config.ui32Compare0 + 1;
   2e5a8:	4b2b      	ldr	r3, [pc, #172]	; (2e658 <continue_current_sequence+0xe8>)
   2e5aa:	68db      	ldr	r3, [r3, #12]
   2e5ac:	3301      	adds	r3, #1
   2e5ae:	4a2a      	ldr	r2, [pc, #168]	; (2e658 <continue_current_sequence+0xe8>)
   2e5b0:	6113      	str	r3, [r2, #16]
   2e5b2:	e00d      	b.n	2e5d0 <continue_current_sequence+0x60>
      }
      else
      {
         timer_config.ui32Compare0 = buzzer_clock_hz / *current_frequency;
   2e5b4:	4a26      	ldr	r2, [pc, #152]	; (2e650 <continue_current_sequence+0xe0>)
   2e5b6:	4b24      	ldr	r3, [pc, #144]	; (2e648 <continue_current_sequence+0xd8>)
   2e5b8:	681b      	ldr	r3, [r3, #0]
   2e5ba:	881b      	ldrh	r3, [r3, #0]
   2e5bc:	b29b      	uxth	r3, r3
   2e5be:	fbb2 f3f3 	udiv	r3, r2, r3
   2e5c2:	4a25      	ldr	r2, [pc, #148]	; (2e658 <continue_current_sequence+0xe8>)
   2e5c4:	60d3      	str	r3, [r2, #12]
         timer_config.ui32Compare1 = timer_config.ui32Compare0 / 2;
   2e5c6:	4b24      	ldr	r3, [pc, #144]	; (2e658 <continue_current_sequence+0xe8>)
   2e5c8:	68db      	ldr	r3, [r3, #12]
   2e5ca:	085b      	lsrs	r3, r3, #1
   2e5cc:	4a22      	ldr	r2, [pc, #136]	; (2e658 <continue_current_sequence+0xe8>)
   2e5ce:	6113      	str	r3, [r2, #16]
      }

      // Set the duration and expected number of interrupt services
      interrupt_counter_index = 0;
   2e5d0:	4b22      	ldr	r3, [pc, #136]	; (2e65c <continue_current_sequence+0xec>)
   2e5d2:	2200      	movs	r2, #0
   2e5d4:	601a      	str	r2, [r3, #0]
      interrupt_counter_max = (*current_duration * *current_frequency) / 1000;
   2e5d6:	4b1d      	ldr	r3, [pc, #116]	; (2e64c <continue_current_sequence+0xdc>)
   2e5d8:	681b      	ldr	r3, [r3, #0]
   2e5da:	881b      	ldrh	r3, [r3, #0]
   2e5dc:	b29b      	uxth	r3, r3
   2e5de:	461a      	mov	r2, r3
   2e5e0:	4b19      	ldr	r3, [pc, #100]	; (2e648 <continue_current_sequence+0xd8>)
   2e5e2:	681b      	ldr	r3, [r3, #0]
   2e5e4:	881b      	ldrh	r3, [r3, #0]
   2e5e6:	b29b      	uxth	r3, r3
   2e5e8:	fb03 f302 	mul.w	r3, r3, r2
   2e5ec:	4a19      	ldr	r2, [pc, #100]	; (2e654 <continue_current_sequence+0xe4>)
   2e5ee:	fb82 1203 	smull	r1, r2, r2, r3
   2e5f2:	1192      	asrs	r2, r2, #6
   2e5f4:	17db      	asrs	r3, r3, #31
   2e5f6:	1ad3      	subs	r3, r2, r3
   2e5f8:	461a      	mov	r2, r3
   2e5fa:	4b19      	ldr	r3, [pc, #100]	; (2e660 <continue_current_sequence+0xf0>)
   2e5fc:	601a      	str	r2, [r3, #0]
      am_hal_timer_config(BUZZER_TIMER_NUMBER, &timer_config);
   2e5fe:	4916      	ldr	r1, [pc, #88]	; (2e658 <continue_current_sequence+0xe8>)
   2e600:	2000      	movs	r0, #0
   2e602:	f008 fab7 	bl	36b74 <am_hal_timer_config>

      // Move on to the next value in the sequence
      ++current_frequency;
   2e606:	4b10      	ldr	r3, [pc, #64]	; (2e648 <continue_current_sequence+0xd8>)
   2e608:	681b      	ldr	r3, [r3, #0]
   2e60a:	3302      	adds	r3, #2
   2e60c:	4a0e      	ldr	r2, [pc, #56]	; (2e648 <continue_current_sequence+0xd8>)
   2e60e:	6013      	str	r3, [r2, #0]
      ++current_duration;
   2e610:	4b0e      	ldr	r3, [pc, #56]	; (2e64c <continue_current_sequence+0xdc>)
   2e612:	681b      	ldr	r3, [r3, #0]
   2e614:	3302      	adds	r3, #2
   2e616:	4a0d      	ldr	r2, [pc, #52]	; (2e64c <continue_current_sequence+0xdc>)
   2e618:	6013      	str	r3, [r2, #0]
      am_hal_timer_clear(BUZZER_TIMER_NUMBER);
   2e61a:	2000      	movs	r0, #0
   2e61c:	f008 fb12 	bl	36c44 <am_hal_timer_clear>
      am_hal_timer_stop(BUZZER_TIMER_NUMBER);
      am_hal_timer_disable(BUZZER_TIMER_NUMBER);
      am_hal_gpio_output_clear(PIN_BUZZER_DRIVER);
      current_frequency = current_duration = NULL;
   }
}
   2e620:	e010      	b.n	2e644 <continue_current_sequence+0xd4>
      am_hal_timer_stop(BUZZER_TIMER_NUMBER);
   2e622:	2000      	movs	r0, #0
   2e624:	f008 faf6 	bl	36c14 <am_hal_timer_disable>
      am_hal_timer_disable(BUZZER_TIMER_NUMBER);
   2e628:	2000      	movs	r0, #0
   2e62a:	f008 faf3 	bl	36c14 <am_hal_timer_disable>
      am_hal_gpio_output_clear(PIN_BUZZER_DRIVER);
   2e62e:	4b0d      	ldr	r3, [pc, #52]	; (2e664 <continue_current_sequence+0xf4>)
   2e630:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2e634:	601a      	str	r2, [r3, #0]
      current_frequency = current_duration = NULL;
   2e636:	4b05      	ldr	r3, [pc, #20]	; (2e64c <continue_current_sequence+0xdc>)
   2e638:	2200      	movs	r2, #0
   2e63a:	601a      	str	r2, [r3, #0]
   2e63c:	4b03      	ldr	r3, [pc, #12]	; (2e64c <continue_current_sequence+0xdc>)
   2e63e:	681b      	ldr	r3, [r3, #0]
   2e640:	4a01      	ldr	r2, [pc, #4]	; (2e648 <continue_current_sequence+0xd8>)
   2e642:	6013      	str	r3, [r2, #0]
}
   2e644:	bf00      	nop
   2e646:	bd80      	pop	{r7, pc}
   2e648:	100081c8 	.word	0x100081c8
   2e64c:	100081cc 	.word	0x100081cc
   2e650:	0005b8d8 	.word	0x0005b8d8
   2e654:	10624dd3 	.word	0x10624dd3
   2e658:	100081b4 	.word	0x100081b4
   2e65c:	100081d0 	.word	0x100081d0
   2e660:	100081d4 	.word	0x100081d4
   2e664:	40010234 	.word	0x40010234

0002e668 <am_timer00_isr>:

void am_timer00_isr(void)
{
   2e668:	b580      	push	{r7, lr}
   2e66a:	af00      	add	r7, sp, #0
   // Clear the timer interrupt and check if it is time to move to the next value in the PWM sequence
   am_hal_timer_interrupt_clear(AM_HAL_TIMER_MASK(BUZZER_TIMER_NUMBER, AM_HAL_TIMER_COMPARE0));
   2e66c:	2001      	movs	r0, #1
   2e66e:	f008 fb13 	bl	36c98 <am_hal_timer_interrupt_clear>
   if (++interrupt_counter_index >= interrupt_counter_max)
   2e672:	4b06      	ldr	r3, [pc, #24]	; (2e68c <am_timer00_isr+0x24>)
   2e674:	681b      	ldr	r3, [r3, #0]
   2e676:	3301      	adds	r3, #1
   2e678:	4a04      	ldr	r2, [pc, #16]	; (2e68c <am_timer00_isr+0x24>)
   2e67a:	6013      	str	r3, [r2, #0]
   2e67c:	4a04      	ldr	r2, [pc, #16]	; (2e690 <am_timer00_isr+0x28>)
   2e67e:	6812      	ldr	r2, [r2, #0]
   2e680:	4293      	cmp	r3, r2
   2e682:	d301      	bcc.n	2e688 <am_timer00_isr+0x20>
      continue_current_sequence();
   2e684:	f7ff ff74 	bl	2e570 <continue_current_sequence>
}
   2e688:	bf00      	nop
   2e68a:	bd80      	pop	{r7, pc}
   2e68c:	100081d0 	.word	0x100081d0
   2e690:	100081d4 	.word	0x100081d4

0002e694 <logging_init>:


// Public API Functions ------------------------------------------------------------------------------------------------

void logging_init(void)
{
   2e694:	b580      	push	{r7, lr}
   2e696:	af00      	add	r7, sp, #0
#if defined(ENABLE_LOGGING) && ((7-ENABLE_LOGGING-7 == 14) || (7-ENABLE_LOGGING-7 != 0))

#if (REVISION_ID == REVISION_I) //|| (REVISION_ID == REVISION_APOLLO4_EVB)
   SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#else
   am_bsp_itm_printf_enable();
   2e698:	f004 ffd4 	bl	33644 <am_bsp_itm_printf_enable>
   //#elif (REVISION_ID != REVISION_I) //&& (REVISION_ID != REVISION_APOLLO4_EVB)

   //am_bsp_itm_printf_disable();

#endif
}
   2e69c:	bf00      	nop
   2e69e:	bd80      	pop	{r7, pc}

0002e6a0 <print_reset_reason>:
}

#if defined(ENABLE_LOGGING) && ((7-ENABLE_LOGGING-7 == 14) || (7-ENABLE_LOGGING-7 != 0))

void print_reset_reason(const am_hal_reset_status_t* reason)
{
   2e6a0:	b580      	push	{r7, lr}
   2e6a2:	b082      	sub	sp, #8
   2e6a4:	af00      	add	r7, sp, #0
   2e6a6:	6078      	str	r0, [r7, #4]
   print("\n----------------------------------------\n");
   2e6a8:	4830      	ldr	r0, [pc, #192]	; (2e76c <print_reset_reason+0xcc>)
   2e6aa:	f7ec fa79 	bl	1aba0 <am_util_stdio_printf>
   print("Reset Reasons: ");
   2e6ae:	4830      	ldr	r0, [pc, #192]	; (2e770 <print_reset_reason+0xd0>)
   2e6b0:	f7ec fa76 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bEXTStat)
   2e6b4:	687b      	ldr	r3, [r7, #4]
   2e6b6:	789b      	ldrb	r3, [r3, #2]
   2e6b8:	2b00      	cmp	r3, #0
   2e6ba:	d002      	beq.n	2e6c2 <print_reset_reason+0x22>
      print("External Reset, ");
   2e6bc:	482d      	ldr	r0, [pc, #180]	; (2e774 <print_reset_reason+0xd4>)
   2e6be:	f7ec fa6f 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bPORStat)
   2e6c2:	687b      	ldr	r3, [r7, #4]
   2e6c4:	78db      	ldrb	r3, [r3, #3]
   2e6c6:	2b00      	cmp	r3, #0
   2e6c8:	d002      	beq.n	2e6d0 <print_reset_reason+0x30>
      print("HW Power-On Reset, ");
   2e6ca:	482b      	ldr	r0, [pc, #172]	; (2e778 <print_reset_reason+0xd8>)
   2e6cc:	f7ec fa68 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBODStat)
   2e6d0:	687b      	ldr	r3, [r7, #4]
   2e6d2:	791b      	ldrb	r3, [r3, #4]
   2e6d4:	2b00      	cmp	r3, #0
   2e6d6:	d002      	beq.n	2e6de <print_reset_reason+0x3e>
      print("Brown-Out Reset, ");
   2e6d8:	4828      	ldr	r0, [pc, #160]	; (2e77c <print_reset_reason+0xdc>)
   2e6da:	f7ec fa61 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bSWPORStat)
   2e6de:	687b      	ldr	r3, [r7, #4]
   2e6e0:	795b      	ldrb	r3, [r3, #5]
   2e6e2:	2b00      	cmp	r3, #0
   2e6e4:	d002      	beq.n	2e6ec <print_reset_reason+0x4c>
      print("SW Power-On Reset, ");
   2e6e6:	4826      	ldr	r0, [pc, #152]	; (2e780 <print_reset_reason+0xe0>)
   2e6e8:	f7ec fa5a 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bSWPOIStat)
   2e6ec:	687b      	ldr	r3, [r7, #4]
   2e6ee:	799b      	ldrb	r3, [r3, #6]
   2e6f0:	2b00      	cmp	r3, #0
   2e6f2:	d002      	beq.n	2e6fa <print_reset_reason+0x5a>
      print("SW Power-On Initialization, ");
   2e6f4:	4823      	ldr	r0, [pc, #140]	; (2e784 <print_reset_reason+0xe4>)
   2e6f6:	f7ec fa53 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bDBGRStat)
   2e6fa:	687b      	ldr	r3, [r7, #4]
   2e6fc:	79db      	ldrb	r3, [r3, #7]
   2e6fe:	2b00      	cmp	r3, #0
   2e700:	d002      	beq.n	2e708 <print_reset_reason+0x68>
      print("Debugger Reset, ");
   2e702:	4821      	ldr	r0, [pc, #132]	; (2e788 <print_reset_reason+0xe8>)
   2e704:	f7ec fa4c 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bWDTStat)
   2e708:	687b      	ldr	r3, [r7, #4]
   2e70a:	7a1b      	ldrb	r3, [r3, #8]
   2e70c:	2b00      	cmp	r3, #0
   2e70e:	d002      	beq.n	2e716 <print_reset_reason+0x76>
      print("Watch Dog Timer Reset, ");
   2e710:	481e      	ldr	r0, [pc, #120]	; (2e78c <print_reset_reason+0xec>)
   2e712:	f7ec fa45 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBOUnregStat)
   2e716:	687b      	ldr	r3, [r7, #4]
   2e718:	7a5b      	ldrb	r3, [r3, #9]
   2e71a:	2b00      	cmp	r3, #0
   2e71c:	d002      	beq.n	2e724 <print_reset_reason+0x84>
      print("Unregulated Supply Brownout, ");
   2e71e:	481c      	ldr	r0, [pc, #112]	; (2e790 <print_reset_reason+0xf0>)
   2e720:	f7ec fa3e 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBOCOREStat)
   2e724:	687b      	ldr	r3, [r7, #4]
   2e726:	7a9b      	ldrb	r3, [r3, #10]
   2e728:	2b00      	cmp	r3, #0
   2e72a:	d002      	beq.n	2e732 <print_reset_reason+0x92>
      print("Core Regulator Brownout, ");
   2e72c:	4819      	ldr	r0, [pc, #100]	; (2e794 <print_reset_reason+0xf4>)
   2e72e:	f7ec fa37 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBOMEMStat)
   2e732:	687b      	ldr	r3, [r7, #4]
   2e734:	7adb      	ldrb	r3, [r3, #11]
   2e736:	2b00      	cmp	r3, #0
   2e738:	d002      	beq.n	2e740 <print_reset_reason+0xa0>
      print("Memory Regulator Brownout, ");
   2e73a:	4817      	ldr	r0, [pc, #92]	; (2e798 <print_reset_reason+0xf8>)
   2e73c:	f7ec fa30 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBOHPMEMStat)
   2e740:	687b      	ldr	r3, [r7, #4]
   2e742:	7b1b      	ldrb	r3, [r3, #12]
   2e744:	2b00      	cmp	r3, #0
   2e746:	d002      	beq.n	2e74e <print_reset_reason+0xae>
      print("High-Power Memory Regulator Brownout, ");
   2e748:	4814      	ldr	r0, [pc, #80]	; (2e79c <print_reset_reason+0xfc>)
   2e74a:	f7ec fa29 	bl	1aba0 <am_util_stdio_printf>
   if (reason->bBOLPCOREStat)
   2e74e:	687b      	ldr	r3, [r7, #4]
   2e750:	7b5b      	ldrb	r3, [r3, #13]
   2e752:	2b00      	cmp	r3, #0
   2e754:	d002      	beq.n	2e75c <print_reset_reason+0xbc>
      print("Low-Power Core Regulator Brownout, ");
   2e756:	4812      	ldr	r0, [pc, #72]	; (2e7a0 <print_reset_reason+0x100>)
   2e758:	f7ec fa22 	bl	1aba0 <am_util_stdio_printf>
   print("\n");
   2e75c:	4811      	ldr	r0, [pc, #68]	; (2e7a4 <print_reset_reason+0x104>)
   2e75e:	f7ec fa1f 	bl	1aba0 <am_util_stdio_printf>
}
   2e762:	bf00      	nop
   2e764:	3708      	adds	r7, #8
   2e766:	46bd      	mov	sp, r7
   2e768:	bd80      	pop	{r7, pc}
   2e76a:	bf00      	nop
   2e76c:	000455fc 	.word	0x000455fc
   2e770:	00045628 	.word	0x00045628
   2e774:	00045638 	.word	0x00045638
   2e778:	0004564c 	.word	0x0004564c
   2e77c:	00045660 	.word	0x00045660
   2e780:	00045674 	.word	0x00045674
   2e784:	00045688 	.word	0x00045688
   2e788:	000456a8 	.word	0x000456a8
   2e78c:	000456bc 	.word	0x000456bc
   2e790:	000456d4 	.word	0x000456d4
   2e794:	000456f4 	.word	0x000456f4
   2e798:	00045710 	.word	0x00045710
   2e79c:	0004572c 	.word	0x0004572c
   2e7a0:	00045754 	.word	0x00045754
   2e7a4:	00045778 	.word	0x00045778

0002e7a8 <decamutexon>:

static const struct dwt_spi_s spi_functions = { .readfromspi = readfromspi, .writetospi = writetospi,
   .writetospiwithcrc = NULL, .setslowrate = ranging_radio_spi_slow, .setfastrate = ranging_radio_spi_fast };
static const struct dwt_probe_s driver_interface = { .dw = NULL, .spi = (void*)&spi_functions, .wakeup_device_with_io = NULL };

decaIrqStatus_t decamutexon(void) { return (decaIrqStatus_t)am_hal_interrupt_master_disable(); }
   2e7a8:	b580      	push	{r7, lr}
   2e7aa:	af00      	add	r7, sp, #0
   2e7ac:	f005 fb26 	bl	33dfc <am_hal_interrupt_master_disable>
   2e7b0:	4603      	mov	r3, r0
   2e7b2:	4618      	mov	r0, r3
   2e7b4:	bd80      	pop	{r7, pc}

0002e7b6 <decamutexoff>:
void decamutexoff(decaIrqStatus_t status) { am_hal_interrupt_master_set((uint32_t)status); }
   2e7b6:	b580      	push	{r7, lr}
   2e7b8:	b082      	sub	sp, #8
   2e7ba:	af00      	add	r7, sp, #0
   2e7bc:	6078      	str	r0, [r7, #4]
   2e7be:	687b      	ldr	r3, [r7, #4]
   2e7c0:	4618      	mov	r0, r3
   2e7c2:	f005 fb1f 	bl	33e04 <am_hal_interrupt_master_set>
   2e7c6:	bf00      	nop
   2e7c8:	3708      	adds	r7, #8
   2e7ca:	46bd      	mov	sp, r7
   2e7cc:	bd80      	pop	{r7, pc}

0002e7ce <deca_sleep>:
void deca_sleep(unsigned int time_ms) { am_hal_delay_us(time_ms * 1000); }
   2e7ce:	b580      	push	{r7, lr}
   2e7d0:	b082      	sub	sp, #8
   2e7d2:	af00      	add	r7, sp, #0
   2e7d4:	6078      	str	r0, [r7, #4]
   2e7d6:	687b      	ldr	r3, [r7, #4]
   2e7d8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   2e7dc:	fb02 f303 	mul.w	r3, r2, r3
   2e7e0:	4618      	mov	r0, r3
   2e7e2:	f006 fd71 	bl	352c8 <am_hal_delay_us>
   2e7e6:	bf00      	nop
   2e7e8:	3708      	adds	r7, #8
   2e7ea:	46bd      	mov	sp, r7
   2e7ec:	bd80      	pop	{r7, pc}

0002e7ee <deca_usleep>:
void deca_usleep(unsigned long time_us) { am_hal_delay_us(time_us); }
   2e7ee:	b580      	push	{r7, lr}
   2e7f0:	b082      	sub	sp, #8
   2e7f2:	af00      	add	r7, sp, #0
   2e7f4:	6078      	str	r0, [r7, #4]
   2e7f6:	6878      	ldr	r0, [r7, #4]
   2e7f8:	f006 fd66 	bl	352c8 <am_hal_delay_us>
   2e7fc:	bf00      	nop
   2e7fe:	3708      	adds	r7, #8
   2e800:	46bd      	mov	sp, r7
   2e802:	bd80      	pop	{r7, pc}

0002e804 <to_unix_timestamp>:
         return i;
   return 7;
}

static uint32_t to_unix_timestamp(const am_hal_rtc_time_t *time)
{
   2e804:	b580      	push	{r7, lr}
   2e806:	b08e      	sub	sp, #56	; 0x38
   2e808:	af00      	add	r7, sp, #0
   2e80a:	6078      	str	r0, [r7, #4]
   struct tm time_struct = {
      .tm_sec = time->ui32Second,
   2e80c:	687b      	ldr	r3, [r7, #4]
   2e80e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   struct tm time_struct = {
   2e810:	60fb      	str	r3, [r7, #12]
      .tm_min = time->ui32Minute,
   2e812:	687b      	ldr	r3, [r7, #4]
   2e814:	6a1b      	ldr	r3, [r3, #32]
   struct tm time_struct = {
   2e816:	613b      	str	r3, [r7, #16]
      .tm_hour = time->ui32Hour,
   2e818:	687b      	ldr	r3, [r7, #4]
   2e81a:	69db      	ldr	r3, [r3, #28]
   struct tm time_struct = {
   2e81c:	617b      	str	r3, [r7, #20]
      .tm_mday = time->ui32DayOfMonth,
   2e81e:	687b      	ldr	r3, [r7, #4]
   2e820:	699b      	ldr	r3, [r3, #24]
   struct tm time_struct = {
   2e822:	61bb      	str	r3, [r7, #24]
      .tm_mon = time->ui32Month - 1,
   2e824:	687b      	ldr	r3, [r7, #4]
   2e826:	695b      	ldr	r3, [r3, #20]
   2e828:	3b01      	subs	r3, #1
   struct tm time_struct = {
   2e82a:	61fb      	str	r3, [r7, #28]
      .tm_year = time->ui32Year + 100,
   2e82c:	687b      	ldr	r3, [r7, #4]
   2e82e:	691b      	ldr	r3, [r3, #16]
   2e830:	3364      	adds	r3, #100	; 0x64
   struct tm time_struct = {
   2e832:	623b      	str	r3, [r7, #32]
      .tm_wday = time->ui32Weekday,
   2e834:	687b      	ldr	r3, [r7, #4]
   2e836:	689b      	ldr	r3, [r3, #8]
   struct tm time_struct = {
   2e838:	627b      	str	r3, [r7, #36]	; 0x24
   2e83a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2e83e:	62bb      	str	r3, [r7, #40]	; 0x28
   2e840:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   2e844:	62fb      	str	r3, [r7, #44]	; 0x2c
      .tm_yday = -1,
      .tm_isdst = -1
   };
   time_t timestamp = mktime(&time_struct);
   2e846:	f107 030c 	add.w	r3, r7, #12
   2e84a:	4618      	mov	r0, r3
   2e84c:	f001 fd9e 	bl	3038c <mktime>
   2e850:	e9c7 010c 	strd	r0, r1, [r7, #48]	; 0x30
   return (timestamp == (time_t)(-1)) ? 0 : (uint32_t)timestamp;
   2e854:	e9d7 230c 	ldrd	r2, r3, [r7, #48]	; 0x30
   2e858:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
   2e85c:	bf08      	it	eq
   2e85e:	f1b2 3fff 	cmpeq.w	r2, #4294967295	; 0xffffffff
   2e862:	d001      	beq.n	2e868 <to_unix_timestamp+0x64>
   2e864:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   2e866:	e000      	b.n	2e86a <to_unix_timestamp+0x66>
   2e868:	2300      	movs	r3, #0
}
   2e86a:	4618      	mov	r0, r3
   2e86c:	3738      	adds	r7, #56	; 0x38
   2e86e:	46bd      	mov	sp, r7
   2e870:	bd80      	pop	{r7, pc}

0002e872 <to_rtc_time>:

static am_hal_rtc_time_t to_rtc_time(uint32_t unix_timestamp)
{
   2e872:	b5b0      	push	{r4, r5, r7, lr}
   2e874:	b092      	sub	sp, #72	; 0x48
   2e876:	af00      	add	r7, sp, #0
   2e878:	6078      	str	r0, [r7, #4]
   2e87a:	6039      	str	r1, [r7, #0]
   time_t timestamp = (time_t)unix_timestamp;
   2e87c:	683b      	ldr	r3, [r7, #0]
   2e87e:	461a      	mov	r2, r3
   2e880:	f04f 0300 	mov.w	r3, #0
   2e884:	e9c7 230e 	strd	r2, r3, [r7, #56]	; 0x38
   struct tm *unix_time = gmtime(&timestamp);
   2e888:	f107 0338 	add.w	r3, r7, #56	; 0x38
   2e88c:	4618      	mov	r0, r3
   2e88e:	f001 faa5 	bl	2fddc <gmtime>
   2e892:	6478      	str	r0, [r7, #68]	; 0x44
   am_hal_rtc_time_t new_rtc_time = {
   2e894:	2300      	movs	r3, #0
   2e896:	60fb      	str	r3, [r7, #12]
   2e898:	2300      	movs	r3, #0
   2e89a:	613b      	str	r3, [r7, #16]
      .ui32Century = 0,
      .ui32Hour = unix_time->tm_hour,
      .ui32Minute = unix_time->tm_min,
      .ui32Second = unix_time->tm_sec,
      .ui32Hundredths = 0,
      .ui32Weekday = unix_time->tm_wday,
   2e89c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e89e:	699b      	ldr	r3, [r3, #24]
   am_hal_rtc_time_t new_rtc_time = {
   2e8a0:	617b      	str	r3, [r7, #20]
   2e8a2:	2300      	movs	r3, #0
   2e8a4:	61bb      	str	r3, [r7, #24]
      .ui32DayOfMonth = unix_time->tm_mday,
      .ui32Month = unix_time->tm_mon + 1,
      .ui32Year = unix_time->tm_year - 100
   2e8a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8a8:	695b      	ldr	r3, [r3, #20]
   2e8aa:	3b64      	subs	r3, #100	; 0x64
   am_hal_rtc_time_t new_rtc_time = {
   2e8ac:	61fb      	str	r3, [r7, #28]
      .ui32Month = unix_time->tm_mon + 1,
   2e8ae:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8b0:	691b      	ldr	r3, [r3, #16]
   2e8b2:	3301      	adds	r3, #1
   am_hal_rtc_time_t new_rtc_time = {
   2e8b4:	623b      	str	r3, [r7, #32]
      .ui32DayOfMonth = unix_time->tm_mday,
   2e8b6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8b8:	68db      	ldr	r3, [r3, #12]
   am_hal_rtc_time_t new_rtc_time = {
   2e8ba:	627b      	str	r3, [r7, #36]	; 0x24
      .ui32Hour = unix_time->tm_hour,
   2e8bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8be:	689b      	ldr	r3, [r3, #8]
   am_hal_rtc_time_t new_rtc_time = {
   2e8c0:	62bb      	str	r3, [r7, #40]	; 0x28
      .ui32Minute = unix_time->tm_min,
   2e8c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8c4:	685b      	ldr	r3, [r3, #4]
   am_hal_rtc_time_t new_rtc_time = {
   2e8c6:	62fb      	str	r3, [r7, #44]	; 0x2c
      .ui32Second = unix_time->tm_sec,
   2e8c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
   2e8ca:	681b      	ldr	r3, [r3, #0]
   am_hal_rtc_time_t new_rtc_time = {
   2e8cc:	633b      	str	r3, [r7, #48]	; 0x30
   2e8ce:	2300      	movs	r3, #0
   2e8d0:	637b      	str	r3, [r7, #52]	; 0x34
   };
   return new_rtc_time;
   2e8d2:	687b      	ldr	r3, [r7, #4]
   2e8d4:	461d      	mov	r5, r3
   2e8d6:	f107 040c 	add.w	r4, r7, #12
   2e8da:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   2e8dc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2e8de:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   2e8e0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   2e8e2:	e894 0007 	ldmia.w	r4, {r0, r1, r2}
   2e8e6:	e885 0007 	stmia.w	r5, {r0, r1, r2}
}
   2e8ea:	6878      	ldr	r0, [r7, #4]
   2e8ec:	3748      	adds	r7, #72	; 0x48
   2e8ee:	46bd      	mov	sp, r7
   2e8f0:	bdb0      	pop	{r4, r5, r7, pc}

0002e8f2 <rtc_set_time_from_timestamp>:
   };
   configASSERT0(am_hal_rtc_time_set(&new_rtc_time));
}

bool rtc_set_time_from_timestamp(uint32_t timestamp)
{
   2e8f2:	b580      	push	{r7, lr}
   2e8f4:	b08e      	sub	sp, #56	; 0x38
   2e8f6:	af00      	add	r7, sp, #0
   2e8f8:	6078      	str	r0, [r7, #4]
   am_hal_rtc_time_t new_rtc_time = to_rtc_time(timestamp);
   2e8fa:	f107 030c 	add.w	r3, r7, #12
   2e8fe:	6879      	ldr	r1, [r7, #4]
   2e900:	4618      	mov	r0, r3
   2e902:	f7ff ffb6 	bl	2e872 <to_rtc_time>
   return (am_hal_rtc_time_set(&new_rtc_time) == AM_HAL_STATUS_SUCCESS);
   2e906:	f107 030c 	add.w	r3, r7, #12
   2e90a:	4618      	mov	r0, r3
   2e90c:	f006 fa74 	bl	34df8 <am_hal_rtc_time_set>
   2e910:	4603      	mov	r3, r0
   2e912:	2b00      	cmp	r3, #0
   2e914:	bf0c      	ite	eq
   2e916:	2301      	moveq	r3, #1
   2e918:	2300      	movne	r3, #0
   2e91a:	b2db      	uxtb	r3, r3
}
   2e91c:	4618      	mov	r0, r3
   2e91e:	3738      	adds	r7, #56	; 0x38
   2e920:	46bd      	mov	sp, r7
   2e922:	bd80      	pop	{r7, pc}

0002e924 <rtc_get_timestamp>:
   NVIC_SetPriority(RTC_IRQn, AM_IRQ_PRIORITY_DEFAULT);
   NVIC_EnableIRQ(RTC_IRQn);
}

uint32_t rtc_get_timestamp(void)
{
   2e924:	b580      	push	{r7, lr}
   2e926:	af00      	add	r7, sp, #0
   static am_hal_rtc_time_t rtc_time;
   return (am_hal_rtc_time_get(&rtc_time) == AM_HAL_STATUS_SUCCESS) ? to_unix_timestamp(&rtc_time) : 0;
   2e928:	4806      	ldr	r0, [pc, #24]	; (2e944 <rtc_get_timestamp+0x20>)
   2e92a:	f006 fb21 	bl	34f70 <am_hal_rtc_time_get>
   2e92e:	4603      	mov	r3, r0
   2e930:	2b00      	cmp	r3, #0
   2e932:	d104      	bne.n	2e93e <rtc_get_timestamp+0x1a>
   2e934:	4803      	ldr	r0, [pc, #12]	; (2e944 <rtc_get_timestamp+0x20>)
   2e936:	f7ff ff65 	bl	2e804 <to_unix_timestamp>
   2e93a:	4603      	mov	r3, r0
   2e93c:	e000      	b.n	2e940 <rtc_get_timestamp+0x1c>
   2e93e:	2300      	movs	r3, #0
}
   2e940:	4618      	mov	r0, r3
   2e942:	bd80      	pop	{r7, pc}
   2e944:	100081d8 	.word	0x100081d8

0002e948 <spi_read>:


// Private Helper Functions --------------------------------------------------------------------------------------------

static void spi_read(uint8_t command, const void *address, uint32_t address_length, void *read_buffer, uint32_t read_length)
{
   2e948:	b580      	push	{r7, lr}
   2e94a:	b092      	sub	sp, #72	; 0x48
   2e94c:	af00      	add	r7, sp, #0
   2e94e:	60b9      	str	r1, [r7, #8]
   2e950:	607a      	str	r2, [r7, #4]
   2e952:	603b      	str	r3, [r7, #0]
   2e954:	4603      	mov	r3, r0
   2e956:	73fb      	strb	r3, [r7, #15]
   // Create the SPI transaction structure
   uint32_t instruction = command;
   2e958:	7bfb      	ldrb	r3, [r7, #15]
   2e95a:	647b      	str	r3, [r7, #68]	; 0x44
   memcpy(((uint8_t*)&instruction) + 1, address, address_length);
   2e95c:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2e960:	3301      	adds	r3, #1
   2e962:	687a      	ldr	r2, [r7, #4]
   2e964:	68b9      	ldr	r1, [r7, #8]
   2e966:	4618      	mov	r0, r3
   2e968:	f7e9 fc74 	bl	18254 <memcpy>
   am_hal_iom_transfer_t spi_transaction = {
   2e96c:	2300      	movs	r3, #0
   2e96e:	613b      	str	r3, [r7, #16]
   2e970:	2300      	movs	r3, #0
   2e972:	617b      	str	r3, [r7, #20]
   2e974:	f04f 0200 	mov.w	r2, #0
   2e978:	f04f 0300 	mov.w	r3, #0
   2e97c:	e9c7 2306 	strd	r2, r3, [r7, #24]
      .uPeerInfo.ui32SpiChipSelect  = 0,
      .ui32InstrLen                 = 0,
      .ui64Instr                    = 0,
      .eDirection                   = AM_HAL_IOM_TX,
      .ui32NumBytes                 = 1 + address_length,
   2e980:	687b      	ldr	r3, [r7, #4]
   2e982:	3301      	adds	r3, #1
   am_hal_iom_transfer_t spi_transaction = {
   2e984:	623b      	str	r3, [r7, #32]
   2e986:	2300      	movs	r3, #0
   2e988:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
   2e98c:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2e990:	62bb      	str	r3, [r7, #40]	; 0x28
   2e992:	2300      	movs	r3, #0
   2e994:	62fb      	str	r3, [r7, #44]	; 0x2c
   2e996:	2301      	movs	r3, #1
   2e998:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
   2e99c:	2300      	movs	r3, #0
   2e99e:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
   2e9a2:	2301      	movs	r3, #1
   2e9a4:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
   2e9a8:	2300      	movs	r3, #0
   2e9aa:	637b      	str	r3, [r7, #52]	; 0x34
   2e9ac:	2300      	movs	r3, #0
   2e9ae:	63bb      	str	r3, [r7, #56]	; 0x38
      .ui32PauseCondition           = 0,
      .ui32StatusSetClr             = 0
   };

   // Repeat the transfer until it succeeds
   while (am_hal_iom_blocking_transfer(spi_handle, &spi_transaction) != AM_HAL_STATUS_SUCCESS);
   2e9b0:	bf00      	nop
   2e9b2:	4b14      	ldr	r3, [pc, #80]	; (2ea04 <spi_read+0xbc>)
   2e9b4:	681b      	ldr	r3, [r3, #0]
   2e9b6:	f107 0210 	add.w	r2, r7, #16
   2e9ba:	4611      	mov	r1, r2
   2e9bc:	4618      	mov	r0, r3
   2e9be:	f005 fe15 	bl	345ec <am_hal_iom_blocking_transfer>
   2e9c2:	4603      	mov	r3, r0
   2e9c4:	2b00      	cmp	r3, #0
   2e9c6:	d1f4      	bne.n	2e9b2 <spi_read+0x6a>

   // Update the SPI transaction structure
   spi_transaction.eDirection = AM_HAL_IOM_RX;
   2e9c8:	2301      	movs	r3, #1
   2e9ca:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
   spi_transaction.ui32NumBytes = read_length;
   2e9ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2e9d0:	623b      	str	r3, [r7, #32]
   spi_transaction.pui32TxBuffer = NULL,
   2e9d2:	2300      	movs	r3, #0
   2e9d4:	62bb      	str	r3, [r7, #40]	; 0x28
   spi_transaction.pui32RxBuffer = read_buffer;
   2e9d6:	683b      	ldr	r3, [r7, #0]
   2e9d8:	62fb      	str	r3, [r7, #44]	; 0x2c
   spi_transaction.bContinue = false;
   2e9da:	2300      	movs	r3, #0
   2e9dc:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30

   // Repeat the transfer until it succeeds
   while (am_hal_iom_blocking_transfer(spi_handle, &spi_transaction) != AM_HAL_STATUS_SUCCESS);
   2e9e0:	bf00      	nop
   2e9e2:	4b08      	ldr	r3, [pc, #32]	; (2ea04 <spi_read+0xbc>)
   2e9e4:	681b      	ldr	r3, [r3, #0]
   2e9e6:	f107 0210 	add.w	r2, r7, #16
   2e9ea:	4611      	mov	r1, r2
   2e9ec:	4618      	mov	r0, r3
   2e9ee:	f005 fdfd 	bl	345ec <am_hal_iom_blocking_transfer>
   2e9f2:	4603      	mov	r3, r0
   2e9f4:	2b00      	cmp	r3, #0
   2e9f6:	d1f4      	bne.n	2e9e2 <spi_read+0x9a>
}
   2e9f8:	bf00      	nop
   2e9fa:	bf00      	nop
   2e9fc:	3748      	adds	r7, #72	; 0x48
   2e9fe:	46bd      	mov	sp, r7
   2ea00:	bd80      	pop	{r7, pc}
   2ea02:	bf00      	nop
   2ea04:	10008204 	.word	0x10008204

0002ea08 <spi_write>:

static void spi_write(uint8_t command, const void *address, uint32_t address_length, const void *write_buffer, uint32_t write_length)
{
   2ea08:	b580      	push	{r7, lr}
   2ea0a:	b092      	sub	sp, #72	; 0x48
   2ea0c:	af00      	add	r7, sp, #0
   2ea0e:	60b9      	str	r1, [r7, #8]
   2ea10:	607a      	str	r2, [r7, #4]
   2ea12:	603b      	str	r3, [r7, #0]
   2ea14:	4603      	mov	r3, r0
   2ea16:	73fb      	strb	r3, [r7, #15]
   // Create the SPI transaction structure
   uint32_t instruction = command;
   2ea18:	7bfb      	ldrb	r3, [r7, #15]
   2ea1a:	647b      	str	r3, [r7, #68]	; 0x44
   memcpy(((uint8_t*)&instruction) + 1, address, address_length);
   2ea1c:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2ea20:	3301      	adds	r3, #1
   2ea22:	687a      	ldr	r2, [r7, #4]
   2ea24:	68b9      	ldr	r1, [r7, #8]
   2ea26:	4618      	mov	r0, r3
   2ea28:	f7e9 fc14 	bl	18254 <memcpy>
   am_hal_iom_transfer_t spi_transaction = {
   2ea2c:	2300      	movs	r3, #0
   2ea2e:	613b      	str	r3, [r7, #16]
   2ea30:	2300      	movs	r3, #0
   2ea32:	617b      	str	r3, [r7, #20]
   2ea34:	f04f 0200 	mov.w	r2, #0
   2ea38:	f04f 0300 	mov.w	r3, #0
   2ea3c:	e9c7 2306 	strd	r2, r3, [r7, #24]
      .uPeerInfo.ui32SpiChipSelect  = 0,
      .ui32InstrLen                 = 0,
      .ui64Instr                    = 0,
      .eDirection                   = AM_HAL_IOM_TX,
      .ui32NumBytes                 = 1 + address_length,
   2ea40:	687b      	ldr	r3, [r7, #4]
   2ea42:	3301      	adds	r3, #1
   am_hal_iom_transfer_t spi_transaction = {
   2ea44:	623b      	str	r3, [r7, #32]
   2ea46:	2300      	movs	r3, #0
   2ea48:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
   2ea4c:	f107 0344 	add.w	r3, r7, #68	; 0x44
   2ea50:	62bb      	str	r3, [r7, #40]	; 0x28
   2ea52:	2300      	movs	r3, #0
   2ea54:	62fb      	str	r3, [r7, #44]	; 0x2c
   2ea56:	2301      	movs	r3, #1
   2ea58:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
   2ea5c:	2300      	movs	r3, #0
   2ea5e:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
   2ea62:	2301      	movs	r3, #1
   2ea64:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
   2ea68:	2300      	movs	r3, #0
   2ea6a:	637b      	str	r3, [r7, #52]	; 0x34
   2ea6c:	2300      	movs	r3, #0
   2ea6e:	63bb      	str	r3, [r7, #56]	; 0x38
      .ui32PauseCondition           = 0,
      .ui32StatusSetClr             = 0
   };

   // Repeat the transfer until it succeeds
   while (am_hal_iom_blocking_transfer(spi_handle, &spi_transaction) != AM_HAL_STATUS_SUCCESS);
   2ea70:	bf00      	nop
   2ea72:	4b11      	ldr	r3, [pc, #68]	; (2eab8 <spi_write+0xb0>)
   2ea74:	681b      	ldr	r3, [r3, #0]
   2ea76:	f107 0210 	add.w	r2, r7, #16
   2ea7a:	4611      	mov	r1, r2
   2ea7c:	4618      	mov	r0, r3
   2ea7e:	f005 fdb5 	bl	345ec <am_hal_iom_blocking_transfer>
   2ea82:	4603      	mov	r3, r0
   2ea84:	2b00      	cmp	r3, #0
   2ea86:	d1f4      	bne.n	2ea72 <spi_write+0x6a>

   // Update the SPI transaction structure
   spi_transaction.ui32NumBytes = write_length;
   2ea88:	6d3b      	ldr	r3, [r7, #80]	; 0x50
   2ea8a:	623b      	str	r3, [r7, #32]
   spi_transaction.pui32TxBuffer = (uint32_t*)write_buffer,
   2ea8c:	683b      	ldr	r3, [r7, #0]
   2ea8e:	62bb      	str	r3, [r7, #40]	; 0x28
   spi_transaction.bContinue = false;
   2ea90:	2300      	movs	r3, #0
   2ea92:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30

   // Repeat the transfer until it succeeds
   while (am_hal_iom_blocking_transfer(spi_handle, &spi_transaction) != AM_HAL_STATUS_SUCCESS);
   2ea96:	bf00      	nop
   2ea98:	4b07      	ldr	r3, [pc, #28]	; (2eab8 <spi_write+0xb0>)
   2ea9a:	681b      	ldr	r3, [r3, #0]
   2ea9c:	f107 0210 	add.w	r2, r7, #16
   2eaa0:	4611      	mov	r1, r2
   2eaa2:	4618      	mov	r0, r3
   2eaa4:	f005 fda2 	bl	345ec <am_hal_iom_blocking_transfer>
   2eaa8:	4603      	mov	r3, r0
   2eaaa:	2b00      	cmp	r3, #0
   2eaac:	d1f4      	bne.n	2ea98 <spi_write+0x90>
}
   2eaae:	bf00      	nop
   2eab0:	bf00      	nop
   2eab2:	3748      	adds	r7, #72	; 0x48
   2eab4:	46bd      	mov	sp, r7
   2eab6:	bd80      	pop	{r7, pc}
   2eab8:	10008204 	.word	0x10008204

0002eabc <read_register>:

static uint8_t read_register(uint8_t register_number)
{
   2eabc:	b580      	push	{r7, lr}
   2eabe:	b084      	sub	sp, #16
   2eac0:	af02      	add	r7, sp, #8
   2eac2:	4603      	mov	r3, r0
   2eac4:	71fb      	strb	r3, [r7, #7]
   static uint8_t register_value;
   spi_read(COMMAND_READ_STATUS_REGISTER, &register_number, 1, &register_value, 1);
   2eac6:	1df9      	adds	r1, r7, #7
   2eac8:	2301      	movs	r3, #1
   2eaca:	9300      	str	r3, [sp, #0]
   2eacc:	4b05      	ldr	r3, [pc, #20]	; (2eae4 <read_register+0x28>)
   2eace:	2201      	movs	r2, #1
   2ead0:	200f      	movs	r0, #15
   2ead2:	f7ff ff39 	bl	2e948 <spi_read>
   return register_value;
   2ead6:	4b03      	ldr	r3, [pc, #12]	; (2eae4 <read_register+0x28>)
   2ead8:	781b      	ldrb	r3, [r3, #0]
}
   2eada:	4618      	mov	r0, r3
   2eadc:	3708      	adds	r7, #8
   2eade:	46bd      	mov	sp, r7
   2eae0:	bd80      	pop	{r7, pc}
   2eae2:	bf00      	nop
   2eae4:	10008a65 	.word	0x10008a65

0002eae8 <write_register>:

static void write_register(uint8_t register_number, uint8_t value)
{
   2eae8:	b580      	push	{r7, lr}
   2eaea:	b084      	sub	sp, #16
   2eaec:	af02      	add	r7, sp, #8
   2eaee:	4603      	mov	r3, r0
   2eaf0:	460a      	mov	r2, r1
   2eaf2:	71fb      	strb	r3, [r7, #7]
   2eaf4:	4613      	mov	r3, r2
   2eaf6:	71bb      	strb	r3, [r7, #6]
   spi_write(COMMAND_WRITE_STATUS_REGISTER, &register_number, 1, &value, 1);
   2eaf8:	1dbb      	adds	r3, r7, #6
   2eafa:	1df9      	adds	r1, r7, #7
   2eafc:	2201      	movs	r2, #1
   2eafe:	9200      	str	r2, [sp, #0]
   2eb00:	2201      	movs	r2, #1
   2eb02:	201f      	movs	r0, #31
   2eb04:	f7ff ff80 	bl	2ea08 <spi_write>
}
   2eb08:	bf00      	nop
   2eb0a:	3708      	adds	r7, #8
   2eb0c:	46bd      	mov	sp, r7
   2eb0e:	bd80      	pop	{r7, pc}

0002eb10 <wait_until_not_busy>:
   spi_read(COMMAND_READ_DEVICE_ID, NULL, 0, device_id_read, sizeof(device_id_read));
   return (memcmp(device_id_read + 1, device_id_known, sizeof(device_id_known)) == 0);
}

static void wait_until_not_busy(void)
{
   2eb10:	b580      	push	{r7, lr}
   2eb12:	af00      	add	r7, sp, #0
   while ((read_register(STATUS_REGISTER_3) & STATUS_BUSY) == STATUS_BUSY)
   2eb14:	e002      	b.n	2eb1c <wait_until_not_busy+0xc>
      am_hal_delay_us(1);
   2eb16:	2001      	movs	r0, #1
   2eb18:	f006 fbd6 	bl	352c8 <am_hal_delay_us>
   while ((read_register(STATUS_REGISTER_3) & STATUS_BUSY) == STATUS_BUSY)
   2eb1c:	20c0      	movs	r0, #192	; 0xc0
   2eb1e:	f7ff ffcd 	bl	2eabc <read_register>
   2eb22:	4603      	mov	r3, r0
   2eb24:	f003 0301 	and.w	r3, r3, #1
   2eb28:	2b01      	cmp	r3, #1
   2eb2a:	d0f4      	beq.n	2eb16 <wait_until_not_busy+0x6>
}
   2eb2c:	bf00      	nop
   2eb2e:	bf00      	nop
   2eb30:	bd80      	pop	{r7, pc}
	...

0002eb34 <write_page_raw>:

static bool write_page_raw(const uint8_t *data, uint32_t page_number)
{
   2eb34:	b580      	push	{r7, lr}
   2eb36:	b086      	sub	sp, #24
   2eb38:	af02      	add	r7, sp, #8
   2eb3a:	6078      	str	r0, [r7, #4]
   2eb3c:	6039      	str	r1, [r7, #0]
   static const uint16_t byte_offset = 0;
   const uint16_t page_number_reordered = (uint16_t)(((page_number & 0x0000FF00) >> 8) | ((page_number & 0x000000FF) << 8));
   2eb3e:	683b      	ldr	r3, [r7, #0]
   2eb40:	0a1b      	lsrs	r3, r3, #8
   2eb42:	b29b      	uxth	r3, r3
   2eb44:	b2db      	uxtb	r3, r3
   2eb46:	b29a      	uxth	r2, r3
   2eb48:	683b      	ldr	r3, [r7, #0]
   2eb4a:	b29b      	uxth	r3, r3
   2eb4c:	021b      	lsls	r3, r3, #8
   2eb4e:	b29b      	uxth	r3, r3
   2eb50:	4313      	orrs	r3, r2
   2eb52:	b29b      	uxth	r3, r3
   2eb54:	81bb      	strh	r3, [r7, #12]
   for (uint8_t retry_index = 0; retry_index < MEMORY_NUM_BLOCK_ERRORS_BEFORE_REMOVAL; ++retry_index)
   2eb56:	2300      	movs	r3, #0
   2eb58:	73fb      	strb	r3, [r7, #15]
   2eb5a:	e02c      	b.n	2ebb6 <write_page_raw+0x82>
   {
      wait_until_not_busy();
   2eb5c:	f7ff ffd8 	bl	2eb10 <wait_until_not_busy>
      spi_write(COMMAND_WRITE_ENABLE, NULL, 0, NULL, 0);
   2eb60:	2300      	movs	r3, #0
   2eb62:	9300      	str	r3, [sp, #0]
   2eb64:	2300      	movs	r3, #0
   2eb66:	2200      	movs	r2, #0
   2eb68:	2100      	movs	r1, #0
   2eb6a:	2006      	movs	r0, #6
   2eb6c:	f7ff ff4c 	bl	2ea08 <spi_write>
      spi_write(COMMAND_PROGRAM_DATA_LOAD, &byte_offset, 2, data, MEMORY_PAGE_SIZE_BYTES);
   2eb70:	f44f 6300 	mov.w	r3, #2048	; 0x800
   2eb74:	9300      	str	r3, [sp, #0]
   2eb76:	687b      	ldr	r3, [r7, #4]
   2eb78:	2202      	movs	r2, #2
   2eb7a:	4913      	ldr	r1, [pc, #76]	; (2ebc8 <write_page_raw+0x94>)
   2eb7c:	2002      	movs	r0, #2
   2eb7e:	f7ff ff43 	bl	2ea08 <spi_write>
      wait_until_not_busy();
   2eb82:	f7ff ffc5 	bl	2eb10 <wait_until_not_busy>
      spi_write(COMMAND_PROGRAM_EXECUTE, &byte_offset, 1, &page_number_reordered, 2);
   2eb86:	f107 030c 	add.w	r3, r7, #12
   2eb8a:	2202      	movs	r2, #2
   2eb8c:	9200      	str	r2, [sp, #0]
   2eb8e:	2201      	movs	r2, #1
   2eb90:	490d      	ldr	r1, [pc, #52]	; (2ebc8 <write_page_raw+0x94>)
   2eb92:	2010      	movs	r0, #16
   2eb94:	f7ff ff38 	bl	2ea08 <spi_write>
      wait_until_not_busy();
   2eb98:	f7ff ffba 	bl	2eb10 <wait_until_not_busy>
      if ((read_register(STATUS_REGISTER_3) & STATUS_WRITE_FAILURE) != STATUS_WRITE_FAILURE)
   2eb9c:	20c0      	movs	r0, #192	; 0xc0
   2eb9e:	f7ff ff8d 	bl	2eabc <read_register>
   2eba2:	4603      	mov	r3, r0
   2eba4:	f003 0308 	and.w	r3, r3, #8
   2eba8:	2b08      	cmp	r3, #8
   2ebaa:	d001      	beq.n	2ebb0 <write_page_raw+0x7c>
         return true;
   2ebac:	2301      	movs	r3, #1
   2ebae:	e006      	b.n	2ebbe <write_page_raw+0x8a>
   for (uint8_t retry_index = 0; retry_index < MEMORY_NUM_BLOCK_ERRORS_BEFORE_REMOVAL; ++retry_index)
   2ebb0:	7bfb      	ldrb	r3, [r7, #15]
   2ebb2:	3301      	adds	r3, #1
   2ebb4:	73fb      	strb	r3, [r7, #15]
   2ebb6:	7bfb      	ldrb	r3, [r7, #15]
   2ebb8:	2b02      	cmp	r3, #2
   2ebba:	d9cf      	bls.n	2eb5c <write_page_raw+0x28>
   }
   return false;
   2ebbc:	2300      	movs	r3, #0
}
   2ebbe:	4618      	mov	r0, r3
   2ebc0:	3710      	adds	r7, #16
   2ebc2:	46bd      	mov	sp, r7
   2ebc4:	bd80      	pop	{r7, pc}
   2ebc6:	bf00      	nop
   2ebc8:	00045f2a 	.word	0x00045f2a

0002ebcc <read_page>:

static bool read_page(uint8_t *buffer, uint32_t page_number)
{
   2ebcc:	b580      	push	{r7, lr}
   2ebce:	b086      	sub	sp, #24
   2ebd0:	af02      	add	r7, sp, #8
   2ebd2:	6078      	str	r0, [r7, #4]
   2ebd4:	6039      	str	r1, [r7, #0]
   static const uint32_t byte_offset = 0;
   const uint16_t page_number_reordered = (uint16_t)(((page_number & 0x0000FF00) >> 8) | ((page_number & 0x000000FF) << 8));
   2ebd6:	683b      	ldr	r3, [r7, #0]
   2ebd8:	0a1b      	lsrs	r3, r3, #8
   2ebda:	b29b      	uxth	r3, r3
   2ebdc:	b2db      	uxtb	r3, r3
   2ebde:	b29a      	uxth	r2, r3
   2ebe0:	683b      	ldr	r3, [r7, #0]
   2ebe2:	b29b      	uxth	r3, r3
   2ebe4:	021b      	lsls	r3, r3, #8
   2ebe6:	b29b      	uxth	r3, r3
   2ebe8:	4313      	orrs	r3, r2
   2ebea:	b29b      	uxth	r3, r3
   2ebec:	81fb      	strh	r3, [r7, #14]
   wait_until_not_busy();
   2ebee:	f7ff ff8f 	bl	2eb10 <wait_until_not_busy>
   spi_write(COMMAND_PAGE_DATA_READ, &byte_offset, 1, &page_number_reordered, 2);
   2ebf2:	f107 030e 	add.w	r3, r7, #14
   2ebf6:	2202      	movs	r2, #2
   2ebf8:	9200      	str	r2, [sp, #0]
   2ebfa:	2201      	movs	r2, #1
   2ebfc:	490f      	ldr	r1, [pc, #60]	; (2ec3c <read_page+0x70>)
   2ebfe:	2013      	movs	r0, #19
   2ec00:	f7ff ff02 	bl	2ea08 <spi_write>
   wait_until_not_busy();
   2ec04:	f7ff ff84 	bl	2eb10 <wait_until_not_busy>
   spi_read(COMMAND_READ, &byte_offset, 3, buffer, MEMORY_PAGE_SIZE_BYTES);
   2ec08:	f44f 6300 	mov.w	r3, #2048	; 0x800
   2ec0c:	9300      	str	r3, [sp, #0]
   2ec0e:	687b      	ldr	r3, [r7, #4]
   2ec10:	2203      	movs	r2, #3
   2ec12:	490a      	ldr	r1, [pc, #40]	; (2ec3c <read_page+0x70>)
   2ec14:	2003      	movs	r0, #3
   2ec16:	f7ff fe97 	bl	2e948 <spi_read>
   wait_until_not_busy();
   2ec1a:	f7ff ff79 	bl	2eb10 <wait_until_not_busy>
   return (read_register(STATUS_REGISTER_3) & STATUS_PAGE_FATAL_ERROR) != STATUS_PAGE_FATAL_ERROR;
   2ec1e:	20c0      	movs	r0, #192	; 0xc0
   2ec20:	f7ff ff4c 	bl	2eabc <read_register>
   2ec24:	4603      	mov	r3, r0
   2ec26:	f003 0320 	and.w	r3, r3, #32
   2ec2a:	2b20      	cmp	r3, #32
   2ec2c:	bf14      	ite	ne
   2ec2e:	2301      	movne	r3, #1
   2ec30:	2300      	moveq	r3, #0
   2ec32:	b2db      	uxtb	r3, r3
}
   2ec34:	4618      	mov	r0, r3
   2ec36:	3710      	adds	r7, #16
   2ec38:	46bd      	mov	sp, r7
   2ec3a:	bd80      	pop	{r7, pc}
   2ec3c:	00045f2c 	.word	0x00045f2c

0002ec40 <add_bad_block>:
   }
   return true;
}

static void add_bad_block(uint16_t block_address)
{
   2ec40:	b580      	push	{r7, lr}
   2ec42:	b08a      	sub	sp, #40	; 0x28
   2ec44:	af02      	add	r7, sp, #8
   2ec46:	4603      	mov	r3, r0
   2ec48:	80fb      	strh	r3, [r7, #6]
   // Find first available workaround block
   uint16_t workaround_block = 0;
   2ec4a:	2300      	movs	r3, #0
   2ec4c:	83fb      	strh	r3, [r7, #30]
   for (uint32_t page = BBM_LUT_BASE_ADDRESS; !workaround_block && (page < MEMORY_PAGE_COUNT); page += MEMORY_PAGES_PER_BLOCK)
   2ec4e:	f44f 4376 	mov.w	r3, #62976	; 0xf600
   2ec52:	61bb      	str	r3, [r7, #24]
   2ec54:	e027      	b.n	2eca6 <add_bad_block+0x66>
      if (read_page(transfer_buffer, page) && (transfer_buffer[0] == 0xFF))
   2ec56:	69b9      	ldr	r1, [r7, #24]
   2ec58:	4841      	ldr	r0, [pc, #260]	; (2ed60 <add_bad_block+0x120>)
   2ec5a:	f7ff ffb7 	bl	2ebcc <read_page>
   2ec5e:	4603      	mov	r3, r0
   2ec60:	2b00      	cmp	r3, #0
   2ec62:	d01d      	beq.n	2eca0 <add_bad_block+0x60>
   2ec64:	4b3e      	ldr	r3, [pc, #248]	; (2ed60 <add_bad_block+0x120>)
   2ec66:	781b      	ldrb	r3, [r3, #0]
   2ec68:	2bff      	cmp	r3, #255	; 0xff
   2ec6a:	d119      	bne.n	2eca0 <add_bad_block+0x60>
      {
         // Ensure that the candidate block is not already in use
         workaround_block = (uint16_t)((page & 0x0000FFC0) >> 6);
   2ec6c:	69bb      	ldr	r3, [r7, #24]
   2ec6e:	099b      	lsrs	r3, r3, #6
   2ec70:	b29b      	uxth	r3, r3
   2ec72:	f3c3 0309 	ubfx	r3, r3, #0, #10
   2ec76:	83fb      	strh	r3, [r7, #30]
         for (uint32_t i = 0; i < BBM_INTERNAL_LUT_NUM_ENTRIES; ++i)
   2ec78:	2300      	movs	r3, #0
   2ec7a:	617b      	str	r3, [r7, #20]
   2ec7c:	e00d      	b.n	2ec9a <add_bad_block+0x5a>
            if (bad_block_lookup_table_internal[i].pba == workaround_block)
   2ec7e:	4a39      	ldr	r2, [pc, #228]	; (2ed64 <add_bad_block+0x124>)
   2ec80:	697b      	ldr	r3, [r7, #20]
   2ec82:	009b      	lsls	r3, r3, #2
   2ec84:	4413      	add	r3, r2
   2ec86:	885b      	ldrh	r3, [r3, #2]
   2ec88:	8bfa      	ldrh	r2, [r7, #30]
   2ec8a:	429a      	cmp	r2, r3
   2ec8c:	d102      	bne.n	2ec94 <add_bad_block+0x54>
            {
               workaround_block = 0;
   2ec8e:	2300      	movs	r3, #0
   2ec90:	83fb      	strh	r3, [r7, #30]
               break;
   2ec92:	e005      	b.n	2eca0 <add_bad_block+0x60>
         for (uint32_t i = 0; i < BBM_INTERNAL_LUT_NUM_ENTRIES; ++i)
   2ec94:	697b      	ldr	r3, [r7, #20]
   2ec96:	3301      	adds	r3, #1
   2ec98:	617b      	str	r3, [r7, #20]
   2ec9a:	697b      	ldr	r3, [r7, #20]
   2ec9c:	2b13      	cmp	r3, #19
   2ec9e:	d9ee      	bls.n	2ec7e <add_bad_block+0x3e>
   for (uint32_t page = BBM_LUT_BASE_ADDRESS; !workaround_block && (page < MEMORY_PAGE_COUNT); page += MEMORY_PAGES_PER_BLOCK)
   2eca0:	69bb      	ldr	r3, [r7, #24]
   2eca2:	3340      	adds	r3, #64	; 0x40
   2eca4:	61bb      	str	r3, [r7, #24]
   2eca6:	8bfb      	ldrh	r3, [r7, #30]
   2eca8:	2b00      	cmp	r3, #0
   2ecaa:	d103      	bne.n	2ecb4 <add_bad_block+0x74>
   2ecac:	69bb      	ldr	r3, [r7, #24]
   2ecae:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   2ecb2:	d3d0      	bcc.n	2ec56 <add_bad_block+0x16>
            }
      }

   // Update LUT with the workaround block
   if (workaround_block)
   2ecb4:	8bfb      	ldrh	r3, [r7, #30]
   2ecb6:	2b00      	cmp	r3, #0
   2ecb8:	d04e      	beq.n	2ed58 <add_bad_block+0x118>
   {
      block_address = (uint16_t)(((uint32_t)block_address & 0x0000FFC0) >> 6);
   2ecba:	88fb      	ldrh	r3, [r7, #6]
   2ecbc:	099b      	lsrs	r3, r3, #6
   2ecbe:	80fb      	strh	r3, [r7, #6]
      bbm_lut_t destination_address = {
         .lba = ((block_address << 8) & 0xFF00) | ((block_address >> 8) & 0x00FF),
   2ecc0:	88fb      	ldrh	r3, [r7, #6]
   2ecc2:	021b      	lsls	r3, r3, #8
   2ecc4:	b21a      	sxth	r2, r3
   2ecc6:	88fb      	ldrh	r3, [r7, #6]
   2ecc8:	0a1b      	lsrs	r3, r3, #8
   2ecca:	b29b      	uxth	r3, r3
   2eccc:	b21b      	sxth	r3, r3
   2ecce:	4313      	orrs	r3, r2
   2ecd0:	b21b      	sxth	r3, r3
   2ecd2:	b29b      	uxth	r3, r3
      bbm_lut_t destination_address = {
   2ecd4:	81bb      	strh	r3, [r7, #12]
         .pba = ((workaround_block << 8) & 0xFF00) | ((workaround_block >> 8) & 0x00FF)
   2ecd6:	8bfb      	ldrh	r3, [r7, #30]
   2ecd8:	021b      	lsls	r3, r3, #8
   2ecda:	b21a      	sxth	r2, r3
   2ecdc:	8bfb      	ldrh	r3, [r7, #30]
   2ecde:	0a1b      	lsrs	r3, r3, #8
   2ece0:	b29b      	uxth	r3, r3
   2ece2:	b21b      	sxth	r3, r3
   2ece4:	4313      	orrs	r3, r2
   2ece6:	b21b      	sxth	r3, r3
   2ece8:	b29b      	uxth	r3, r3
      bbm_lut_t destination_address = {
   2ecea:	81fb      	strh	r3, [r7, #14]
      };
      spi_write(COMMAND_WRITE_ENABLE, NULL, 0, NULL, 0);
   2ecec:	2300      	movs	r3, #0
   2ecee:	9300      	str	r3, [sp, #0]
   2ecf0:	2300      	movs	r3, #0
   2ecf2:	2200      	movs	r2, #0
   2ecf4:	2100      	movs	r1, #0
   2ecf6:	2006      	movs	r0, #6
   2ecf8:	f7ff fe86 	bl	2ea08 <spi_write>
      spi_write(COMMAND_WRITE_BBM_LUT, NULL, 0, &destination_address, sizeof(destination_address));
   2ecfc:	f107 030c 	add.w	r3, r7, #12
   2ed00:	2204      	movs	r2, #4
   2ed02:	9200      	str	r2, [sp, #0]
   2ed04:	2200      	movs	r2, #0
   2ed06:	2100      	movs	r1, #0
   2ed08:	20a1      	movs	r0, #161	; 0xa1
   2ed0a:	f7ff fe7d 	bl	2ea08 <spi_write>
      wait_until_not_busy();
   2ed0e:	f7ff feff 	bl	2eb10 <wait_until_not_busy>

      // Update the bad block lookup table
      for (uint32_t i = 0; i < BBM_INTERNAL_LUT_NUM_ENTRIES; ++i)
   2ed12:	2300      	movs	r3, #0
   2ed14:	613b      	str	r3, [r7, #16]
   2ed16:	e01c      	b.n	2ed52 <add_bad_block+0x112>
         if ((bad_block_lookup_table_internal[i].pba == 0) && (bad_block_lookup_table_internal[i].lba == 0))
   2ed18:	4a12      	ldr	r2, [pc, #72]	; (2ed64 <add_bad_block+0x124>)
   2ed1a:	693b      	ldr	r3, [r7, #16]
   2ed1c:	009b      	lsls	r3, r3, #2
   2ed1e:	4413      	add	r3, r2
   2ed20:	885b      	ldrh	r3, [r3, #2]
   2ed22:	2b00      	cmp	r3, #0
   2ed24:	d112      	bne.n	2ed4c <add_bad_block+0x10c>
   2ed26:	4a0f      	ldr	r2, [pc, #60]	; (2ed64 <add_bad_block+0x124>)
   2ed28:	693b      	ldr	r3, [r7, #16]
   2ed2a:	f832 3023 	ldrh.w	r3, [r2, r3, lsl #2]
   2ed2e:	2b00      	cmp	r3, #0
   2ed30:	d10c      	bne.n	2ed4c <add_bad_block+0x10c>
         {
            bad_block_lookup_table_internal[i].lba = block_address;
   2ed32:	490c      	ldr	r1, [pc, #48]	; (2ed64 <add_bad_block+0x124>)
   2ed34:	693b      	ldr	r3, [r7, #16]
   2ed36:	88fa      	ldrh	r2, [r7, #6]
   2ed38:	f821 2023 	strh.w	r2, [r1, r3, lsl #2]
            bad_block_lookup_table_internal[i].pba = workaround_block;
   2ed3c:	4a09      	ldr	r2, [pc, #36]	; (2ed64 <add_bad_block+0x124>)
   2ed3e:	693b      	ldr	r3, [r7, #16]
   2ed40:	009b      	lsls	r3, r3, #2
   2ed42:	4413      	add	r3, r2
   2ed44:	8bfa      	ldrh	r2, [r7, #30]
   2ed46:	805a      	strh	r2, [r3, #2]
            break;
   2ed48:	bf00      	nop
         }
   }
}
   2ed4a:	e005      	b.n	2ed58 <add_bad_block+0x118>
      for (uint32_t i = 0; i < BBM_INTERNAL_LUT_NUM_ENTRIES; ++i)
   2ed4c:	693b      	ldr	r3, [r7, #16]
   2ed4e:	3301      	adds	r3, #1
   2ed50:	613b      	str	r3, [r7, #16]
   2ed52:	693b      	ldr	r3, [r7, #16]
   2ed54:	2b13      	cmp	r3, #19
   2ed56:	d9df      	bls.n	2ed18 <add_bad_block+0xd8>
}
   2ed58:	bf00      	nop
   2ed5a:	3720      	adds	r7, #32
   2ed5c:	46bd      	mov	sp, r7
   2ed5e:	bd80      	pop	{r7, pc}
   2ed60:	10008258 	.word	0x10008258
   2ed64:	10008208 	.word	0x10008208

0002ed68 <erase_block>:
   if (!in_maintenance_mode)
      am_hal_iom_power_ctrl(spi_handle, AM_HAL_SYSCTRL_DEEPSLEEP, true);
}

static void erase_block(uint32_t starting_page, uint32_t ending_page)
{
   2ed68:	b580      	push	{r7, lr}
   2ed6a:	b088      	sub	sp, #32
   2ed6c:	af02      	add	r7, sp, #8
   2ed6e:	6078      	str	r0, [r7, #4]
   2ed70:	6039      	str	r1, [r7, #0]
   // Disable memory page write protection
   am_hal_gpio_output_set(PIN_STORAGE_WRITE_PROTECT);
   2ed72:	4b3b      	ldr	r3, [pc, #236]	; (2ee60 <erase_block+0xf8>)
   2ed74:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2ed78:	601a      	str	r2, [r3, #0]
   write_register(STATUS_REGISTER_1, 0b00000010);
   2ed7a:	2102      	movs	r1, #2
   2ed7c:	20a0      	movs	r0, #160	; 0xa0
   2ed7e:	f7ff feb3 	bl	2eae8 <write_register>

   // Iterate through all blocks to be erased
   ending_page &= 0x0000FFC0;
   2ed82:	683a      	ldr	r2, [r7, #0]
   2ed84:	f64f 73c0 	movw	r3, #65472	; 0xffc0
   2ed88:	4013      	ands	r3, r2
   2ed8a:	603b      	str	r3, [r7, #0]
   starting_page &= 0x0000FFC0;
   2ed8c:	687a      	ldr	r2, [r7, #4]
   2ed8e:	f64f 73c0 	movw	r3, #65472	; 0xffc0
   2ed92:	4013      	ands	r3, r2
   2ed94:	607b      	str	r3, [r7, #4]
   const uint8_t num_iterations = (starting_page <= ending_page) ? 1 : 2;
   2ed96:	687a      	ldr	r2, [r7, #4]
   2ed98:	683b      	ldr	r3, [r7, #0]
   2ed9a:	429a      	cmp	r2, r3
   2ed9c:	d801      	bhi.n	2eda2 <erase_block+0x3a>
   2ed9e:	2301      	movs	r3, #1
   2eda0:	e000      	b.n	2eda4 <erase_block+0x3c>
   2eda2:	2302      	movs	r3, #2
   2eda4:	74bb      	strb	r3, [r7, #18]
   uint32_t end = (starting_page <= ending_page) ? ending_page : (BBM_LUT_BASE_ADDRESS - 1);
   2eda6:	687a      	ldr	r2, [r7, #4]
   2eda8:	683b      	ldr	r3, [r7, #0]
   2edaa:	429a      	cmp	r2, r3
   2edac:	d801      	bhi.n	2edb2 <erase_block+0x4a>
   2edae:	683b      	ldr	r3, [r7, #0]
   2edb0:	e001      	b.n	2edb6 <erase_block+0x4e>
   2edb2:	f24f 53ff 	movw	r3, #62975	; 0xf5ff
   2edb6:	617b      	str	r3, [r7, #20]
   for (uint8_t i = 0; i < num_iterations; ++i)
   2edb8:	2300      	movs	r3, #0
   2edba:	74fb      	strb	r3, [r7, #19]
   2edbc:	e03f      	b.n	2ee3e <erase_block+0xd6>
   {
      for (uint32_t page = starting_page; page <= end; page += MEMORY_PAGES_PER_BLOCK)
   2edbe:	687b      	ldr	r3, [r7, #4]
   2edc0:	60fb      	str	r3, [r7, #12]
   2edc2:	e031      	b.n	2ee28 <erase_block+0xc0>
      {
         // Erase the current page and ensure that the command was successful
         const uint16_t page_number_reordered = (uint16_t)(((page & 0x0000FF00) >> 8) | ((page & 0x000000FF) << 8));
   2edc4:	68fb      	ldr	r3, [r7, #12]
   2edc6:	0a1b      	lsrs	r3, r3, #8
   2edc8:	b29b      	uxth	r3, r3
   2edca:	b2db      	uxtb	r3, r3
   2edcc:	b29a      	uxth	r2, r3
   2edce:	68fb      	ldr	r3, [r7, #12]
   2edd0:	b29b      	uxth	r3, r3
   2edd2:	021b      	lsls	r3, r3, #8
   2edd4:	b29b      	uxth	r3, r3
   2edd6:	4313      	orrs	r3, r2
   2edd8:	b29b      	uxth	r3, r3
   2edda:	817b      	strh	r3, [r7, #10]
         wait_until_not_busy();
   2eddc:	f7ff fe98 	bl	2eb10 <wait_until_not_busy>
         spi_write(COMMAND_WRITE_ENABLE, NULL, 0, NULL, 0);
   2ede0:	2300      	movs	r3, #0
   2ede2:	9300      	str	r3, [sp, #0]
   2ede4:	2300      	movs	r3, #0
   2ede6:	2200      	movs	r2, #0
   2ede8:	2100      	movs	r1, #0
   2edea:	2006      	movs	r0, #6
   2edec:	f7ff fe0c 	bl	2ea08 <spi_write>
         spi_write(COMMAND_BLOCK_ERASE, &page, 1, &page_number_reordered, 2);
   2edf0:	f107 030a 	add.w	r3, r7, #10
   2edf4:	f107 010c 	add.w	r1, r7, #12
   2edf8:	2202      	movs	r2, #2
   2edfa:	9200      	str	r2, [sp, #0]
   2edfc:	2201      	movs	r2, #1
   2edfe:	20d8      	movs	r0, #216	; 0xd8
   2ee00:	f7ff fe02 	bl	2ea08 <spi_write>
         wait_until_not_busy();
   2ee04:	f7ff fe84 	bl	2eb10 <wait_until_not_busy>
         if ((read_register(STATUS_REGISTER_3) & STATUS_ERASE_FAILURE) == STATUS_ERASE_FAILURE)
   2ee08:	20c0      	movs	r0, #192	; 0xc0
   2ee0a:	f7ff fe57 	bl	2eabc <read_register>
   2ee0e:	4603      	mov	r3, r0
   2ee10:	f003 0304 	and.w	r3, r3, #4
   2ee14:	2b04      	cmp	r3, #4
   2ee16:	d104      	bne.n	2ee22 <erase_block+0xba>
            add_bad_block(page);
   2ee18:	68fb      	ldr	r3, [r7, #12]
   2ee1a:	b29b      	uxth	r3, r3
   2ee1c:	4618      	mov	r0, r3
   2ee1e:	f7ff ff0f 	bl	2ec40 <add_bad_block>
      for (uint32_t page = starting_page; page <= end; page += MEMORY_PAGES_PER_BLOCK)
   2ee22:	68fb      	ldr	r3, [r7, #12]
   2ee24:	3340      	adds	r3, #64	; 0x40
   2ee26:	60fb      	str	r3, [r7, #12]
   2ee28:	68fb      	ldr	r3, [r7, #12]
   2ee2a:	697a      	ldr	r2, [r7, #20]
   2ee2c:	429a      	cmp	r2, r3
   2ee2e:	d2c9      	bcs.n	2edc4 <erase_block+0x5c>
      }
      starting_page = 0;
   2ee30:	2300      	movs	r3, #0
   2ee32:	607b      	str	r3, [r7, #4]
      end = ending_page;
   2ee34:	683b      	ldr	r3, [r7, #0]
   2ee36:	617b      	str	r3, [r7, #20]
   for (uint8_t i = 0; i < num_iterations; ++i)
   2ee38:	7cfb      	ldrb	r3, [r7, #19]
   2ee3a:	3301      	adds	r3, #1
   2ee3c:	74fb      	strb	r3, [r7, #19]
   2ee3e:	7cfa      	ldrb	r2, [r7, #19]
   2ee40:	7cbb      	ldrb	r3, [r7, #18]
   2ee42:	429a      	cmp	r2, r3
   2ee44:	d3bb      	bcc.n	2edbe <erase_block+0x56>
   }

   // Re-enable memory page write protection
   write_register(STATUS_REGISTER_1, 0b01111110);
   2ee46:	217e      	movs	r1, #126	; 0x7e
   2ee48:	20a0      	movs	r0, #160	; 0xa0
   2ee4a:	f7ff fe4d 	bl	2eae8 <write_register>
   am_hal_gpio_output_clear(PIN_STORAGE_WRITE_PROTECT);
   2ee4e:	4b05      	ldr	r3, [pc, #20]	; (2ee64 <erase_block+0xfc>)
   2ee50:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2ee54:	601a      	str	r2, [r3, #0]
}
   2ee56:	bf00      	nop
   2ee58:	3718      	adds	r7, #24
   2ee5a:	46bd      	mov	sp, r7
   2ee5c:	bd80      	pop	{r7, pc}
   2ee5e:	bf00      	nop
   2ee60:	40010224 	.word	0x40010224
   2ee64:	40010234 	.word	0x40010234

0002ee68 <ensure_empty_memory>:

static void ensure_empty_memory(void)
{
   2ee68:	b580      	push	{r7, lr}
   2ee6a:	b084      	sub	sp, #16
   2ee6c:	af00      	add	r7, sp, #0
   // Ensure that all memory blocks have been successfully erased
   bool current_block_erased = false;
   2ee6e:	2300      	movs	r3, #0
   2ee70:	73fb      	strb	r3, [r7, #15]
   const uint32_t current_block = current_page & 0x0000FFC0;
   2ee72:	4b22      	ldr	r3, [pc, #136]	; (2eefc <ensure_empty_memory+0x94>)
   2ee74:	681a      	ldr	r2, [r3, #0]
   2ee76:	f64f 73c0 	movw	r3, #65472	; 0xffc0
   2ee7a:	4013      	ands	r3, r2
   2ee7c:	607b      	str	r3, [r7, #4]
   for (uint32_t block = 0; block < (MEMORY_BLOCK_COUNT - BBM_NUM_RESERVED_BLOCKS); ++block)
   2ee7e:	2300      	movs	r3, #0
   2ee80:	60bb      	str	r3, [r7, #8]
   2ee82:	e024      	b.n	2eece <ensure_empty_memory+0x66>
      if (!read_page(transfer_buffer, block * MEMORY_PAGES_PER_BLOCK) || (transfer_buffer[0] != 0xFF) || (transfer_buffer[1] != 0xFF))
   2ee84:	68bb      	ldr	r3, [r7, #8]
   2ee86:	019b      	lsls	r3, r3, #6
   2ee88:	4619      	mov	r1, r3
   2ee8a:	481d      	ldr	r0, [pc, #116]	; (2ef00 <ensure_empty_memory+0x98>)
   2ee8c:	f7ff fe9e 	bl	2ebcc <read_page>
   2ee90:	4603      	mov	r3, r0
   2ee92:	f083 0301 	eor.w	r3, r3, #1
   2ee96:	b2db      	uxtb	r3, r3
   2ee98:	2b00      	cmp	r3, #0
   2ee9a:	d107      	bne.n	2eeac <ensure_empty_memory+0x44>
   2ee9c:	4b18      	ldr	r3, [pc, #96]	; (2ef00 <ensure_empty_memory+0x98>)
   2ee9e:	781b      	ldrb	r3, [r3, #0]
   2eea0:	2bff      	cmp	r3, #255	; 0xff
   2eea2:	d103      	bne.n	2eeac <ensure_empty_memory+0x44>
   2eea4:	4b16      	ldr	r3, [pc, #88]	; (2ef00 <ensure_empty_memory+0x98>)
   2eea6:	785b      	ldrb	r3, [r3, #1]
   2eea8:	2bff      	cmp	r3, #255	; 0xff
   2eeaa:	d00d      	beq.n	2eec8 <ensure_empty_memory+0x60>
      {
         erase_block(block * MEMORY_PAGES_PER_BLOCK, block * MEMORY_PAGES_PER_BLOCK);
   2eeac:	68bb      	ldr	r3, [r7, #8]
   2eeae:	019a      	lsls	r2, r3, #6
   2eeb0:	68bb      	ldr	r3, [r7, #8]
   2eeb2:	019b      	lsls	r3, r3, #6
   2eeb4:	4619      	mov	r1, r3
   2eeb6:	4610      	mov	r0, r2
   2eeb8:	f7ff ff56 	bl	2ed68 <erase_block>
         if (block == current_block)
   2eebc:	68ba      	ldr	r2, [r7, #8]
   2eebe:	687b      	ldr	r3, [r7, #4]
   2eec0:	429a      	cmp	r2, r3
   2eec2:	d101      	bne.n	2eec8 <ensure_empty_memory+0x60>
            current_block_erased = true;
   2eec4:	2301      	movs	r3, #1
   2eec6:	73fb      	strb	r3, [r7, #15]
   for (uint32_t block = 0; block < (MEMORY_BLOCK_COUNT - BBM_NUM_RESERVED_BLOCKS); ++block)
   2eec8:	68bb      	ldr	r3, [r7, #8]
   2eeca:	3301      	adds	r3, #1
   2eecc:	60bb      	str	r3, [r7, #8]
   2eece:	68bb      	ldr	r3, [r7, #8]
   2eed0:	f5b3 7f76 	cmp.w	r3, #984	; 0x3d8
   2eed4:	d3d6      	bcc.n	2ee84 <ensure_empty_memory+0x1c>
      }
   if (!current_block_erased)
   2eed6:	7bfb      	ldrb	r3, [r7, #15]
   2eed8:	f083 0301 	eor.w	r3, r3, #1
   2eedc:	b2db      	uxtb	r3, r3
   2eede:	2b00      	cmp	r3, #0
   2eee0:	d007      	beq.n	2eef2 <ensure_empty_memory+0x8a>
      erase_block(current_page, current_page);
   2eee2:	4b06      	ldr	r3, [pc, #24]	; (2eefc <ensure_empty_memory+0x94>)
   2eee4:	681b      	ldr	r3, [r3, #0]
   2eee6:	4a05      	ldr	r2, [pc, #20]	; (2eefc <ensure_empty_memory+0x94>)
   2eee8:	6812      	ldr	r2, [r2, #0]
   2eeea:	4611      	mov	r1, r2
   2eeec:	4618      	mov	r0, r3
   2eeee:	f7ff ff3b 	bl	2ed68 <erase_block>
}
   2eef2:	bf00      	nop
   2eef4:	3710      	adds	r7, #16
   2eef6:	46bd      	mov	sp, r7
   2eef8:	bd80      	pop	{r7, pc}
   2eefa:	bf00      	nop
   2eefc:	10008a5c 	.word	0x10008a5c
   2ef00:	10008258 	.word	0x10008258

0002ef04 <storage_store_experiment_details>:
   // Set the storage disabled flag
   disabled = disable;
}

void storage_store_experiment_details(const experiment_details_t *details)
{
   2ef04:	b580      	push	{r7, lr}
   2ef06:	b084      	sub	sp, #16
   2ef08:	af00      	add	r7, sp, #0
   2ef0a:	6078      	str	r0, [r7, #4]
   // Only store new details in maintenance mode
   if (in_maintenance_mode)
   2ef0c:	4b4c      	ldr	r3, [pc, #304]	; (2f040 <storage_store_experiment_details+0x13c>)
   2ef0e:	781b      	ldrb	r3, [r3, #0]
   2ef10:	2b00      	cmp	r3, #0
   2ef12:	f000 8090 	beq.w	2f036 <storage_store_experiment_details+0x132>
   {
      // Erase all existing used pages and update storage metadata
      ensure_empty_memory();
   2ef16:	f7ff ffa7 	bl	2ee68 <ensure_empty_memory>
      starting_page = (current_page + MEMORY_PAGES_PER_BLOCK) & 0x0000FFC0;
   2ef1a:	4b4a      	ldr	r3, [pc, #296]	; (2f044 <storage_store_experiment_details+0x140>)
   2ef1c:	681b      	ldr	r3, [r3, #0]
   2ef1e:	f103 0240 	add.w	r2, r3, #64	; 0x40
   2ef22:	f64f 73c0 	movw	r3, #65472	; 0xffc0
   2ef26:	4013      	ands	r3, r2
   2ef28:	4a47      	ldr	r2, [pc, #284]	; (2f048 <storage_store_experiment_details+0x144>)
   2ef2a:	6013      	str	r3, [r2, #0]
      current_page = (current_page + 1) % BBM_LUT_BASE_ADDRESS;
   2ef2c:	4b45      	ldr	r3, [pc, #276]	; (2f044 <storage_store_experiment_details+0x140>)
   2ef2e:	681b      	ldr	r3, [r3, #0]
   2ef30:	3301      	adds	r3, #1
   2ef32:	0a5a      	lsrs	r2, r3, #9
   2ef34:	4945      	ldr	r1, [pc, #276]	; (2f04c <storage_store_experiment_details+0x148>)
   2ef36:	fba1 1202 	umull	r1, r2, r1, r2
   2ef3a:	f44f 4176 	mov.w	r1, #62976	; 0xf600
   2ef3e:	fb01 f202 	mul.w	r2, r1, r2
   2ef42:	1a9b      	subs	r3, r3, r2
   2ef44:	4a3f      	ldr	r2, [pc, #252]	; (2f044 <storage_store_experiment_details+0x140>)
   2ef46:	6013      	str	r3, [r2, #0]
      cache_index = 0;
   2ef48:	4b41      	ldr	r3, [pc, #260]	; (2f050 <storage_store_experiment_details+0x14c>)
   2ef4a:	2200      	movs	r2, #0
   2ef4c:	601a      	str	r2, [r3, #0]

      // Write experiment details to storage
      bool success = false;
   2ef4e:	2300      	movs	r3, #0
   2ef50:	73fb      	strb	r3, [r7, #15]
      while (!success)
   2ef52:	e06a      	b.n	2f02a <storage_store_experiment_details+0x126>
      {
         // Disable memory page write protection
         am_hal_gpio_output_set(PIN_STORAGE_WRITE_PROTECT);
   2ef54:	4b3f      	ldr	r3, [pc, #252]	; (2f054 <storage_store_experiment_details+0x150>)
   2ef56:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2ef5a:	601a      	str	r2, [r3, #0]
         write_register(STATUS_REGISTER_1, 0b00000010);
   2ef5c:	2102      	movs	r1, #2
   2ef5e:	20a0      	movs	r0, #160	; 0xa0
   2ef60:	f7ff fdc2 	bl	2eae8 <write_register>

         // Perform the write
         memset(transfer_buffer, 0, sizeof(transfer_buffer));
   2ef64:	f44f 6200 	mov.w	r2, #2048	; 0x800
   2ef68:	2100      	movs	r1, #0
   2ef6a:	483b      	ldr	r0, [pc, #236]	; (2f058 <storage_store_experiment_details+0x154>)
   2ef6c:	f001 f8c0 	bl	300f0 <memset>
         memcpy(transfer_buffer, "META", 4);
   2ef70:	2204      	movs	r2, #4
   2ef72:	493a      	ldr	r1, [pc, #232]	; (2f05c <storage_store_experiment_details+0x158>)
   2ef74:	4838      	ldr	r0, [pc, #224]	; (2f058 <storage_store_experiment_details+0x154>)
   2ef76:	f7e9 f96d 	bl	18254 <memcpy>
         memcpy(transfer_buffer + 4, details, sizeof(*details));
   2ef7a:	4b39      	ldr	r3, [pc, #228]	; (2f060 <storage_store_experiment_details+0x15c>)
   2ef7c:	22ed      	movs	r2, #237	; 0xed
   2ef7e:	6879      	ldr	r1, [r7, #4]
   2ef80:	4618      	mov	r0, r3
   2ef82:	f7e9 f967 	bl	18254 <memcpy>
         success = write_page_raw(transfer_buffer, starting_page) && read_page(transfer_buffer, starting_page);
   2ef86:	4b30      	ldr	r3, [pc, #192]	; (2f048 <storage_store_experiment_details+0x144>)
   2ef88:	681b      	ldr	r3, [r3, #0]
   2ef8a:	4619      	mov	r1, r3
   2ef8c:	4832      	ldr	r0, [pc, #200]	; (2f058 <storage_store_experiment_details+0x154>)
   2ef8e:	f7ff fdd1 	bl	2eb34 <write_page_raw>
   2ef92:	4603      	mov	r3, r0
   2ef94:	2b00      	cmp	r3, #0
   2ef96:	d00a      	beq.n	2efae <storage_store_experiment_details+0xaa>
   2ef98:	4b2b      	ldr	r3, [pc, #172]	; (2f048 <storage_store_experiment_details+0x144>)
   2ef9a:	681b      	ldr	r3, [r3, #0]
   2ef9c:	4619      	mov	r1, r3
   2ef9e:	482e      	ldr	r0, [pc, #184]	; (2f058 <storage_store_experiment_details+0x154>)
   2efa0:	f7ff fe14 	bl	2ebcc <read_page>
   2efa4:	4603      	mov	r3, r0
   2efa6:	2b00      	cmp	r3, #0
   2efa8:	d001      	beq.n	2efae <storage_store_experiment_details+0xaa>
   2efaa:	2301      	movs	r3, #1
   2efac:	e000      	b.n	2efb0 <storage_store_experiment_details+0xac>
   2efae:	2300      	movs	r3, #0
   2efb0:	73fb      	strb	r3, [r7, #15]
   2efb2:	7bfb      	ldrb	r3, [r7, #15]
   2efb4:	f003 0301 	and.w	r3, r3, #1
   2efb8:	73fb      	strb	r3, [r7, #15]

         // Re-enable memory page write protection
         write_register(STATUS_REGISTER_1, 0b01111110);
   2efba:	217e      	movs	r1, #126	; 0x7e
   2efbc:	20a0      	movs	r0, #160	; 0xa0
   2efbe:	f7ff fd93 	bl	2eae8 <write_register>
         am_hal_gpio_output_clear(PIN_STORAGE_WRITE_PROTECT);
   2efc2:	4b28      	ldr	r3, [pc, #160]	; (2f064 <storage_store_experiment_details+0x160>)
   2efc4:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   2efc8:	601a      	str	r2, [r3, #0]

         // Update bad block metadata if unable to write
         if (!success)
   2efca:	7bfb      	ldrb	r3, [r7, #15]
   2efcc:	f083 0301 	eor.w	r3, r3, #1
   2efd0:	b2db      	uxtb	r3, r3
   2efd2:	2b00      	cmp	r3, #0
   2efd4:	d029      	beq.n	2f02a <storage_store_experiment_details+0x126>
         {
            erase_block(starting_page, starting_page);
   2efd6:	4b1c      	ldr	r3, [pc, #112]	; (2f048 <storage_store_experiment_details+0x144>)
   2efd8:	681b      	ldr	r3, [r3, #0]
   2efda:	4a1b      	ldr	r2, [pc, #108]	; (2f048 <storage_store_experiment_details+0x144>)
   2efdc:	6812      	ldr	r2, [r2, #0]
   2efde:	4611      	mov	r1, r2
   2efe0:	4618      	mov	r0, r3
   2efe2:	f7ff fec1 	bl	2ed68 <erase_block>
            add_bad_block(starting_page);
   2efe6:	4b18      	ldr	r3, [pc, #96]	; (2f048 <storage_store_experiment_details+0x144>)
   2efe8:	681b      	ldr	r3, [r3, #0]
   2efea:	b29b      	uxth	r3, r3
   2efec:	4618      	mov	r0, r3
   2efee:	f7ff fe27 	bl	2ec40 <add_bad_block>
            starting_page = (starting_page + MEMORY_PAGES_PER_BLOCK) % BBM_LUT_BASE_ADDRESS;
   2eff2:	4b15      	ldr	r3, [pc, #84]	; (2f048 <storage_store_experiment_details+0x144>)
   2eff4:	681b      	ldr	r3, [r3, #0]
   2eff6:	3340      	adds	r3, #64	; 0x40
   2eff8:	0a5a      	lsrs	r2, r3, #9
   2effa:	4914      	ldr	r1, [pc, #80]	; (2f04c <storage_store_experiment_details+0x148>)
   2effc:	fba1 1202 	umull	r1, r2, r1, r2
   2f000:	f44f 4176 	mov.w	r1, #62976	; 0xf600
   2f004:	fb01 f202 	mul.w	r2, r1, r2
   2f008:	1a9b      	subs	r3, r3, r2
   2f00a:	4a0f      	ldr	r2, [pc, #60]	; (2f048 <storage_store_experiment_details+0x144>)
   2f00c:	6013      	str	r3, [r2, #0]
            current_page = (starting_page + 1) % BBM_LUT_BASE_ADDRESS;
   2f00e:	4b0e      	ldr	r3, [pc, #56]	; (2f048 <storage_store_experiment_details+0x144>)
   2f010:	681b      	ldr	r3, [r3, #0]
   2f012:	3301      	adds	r3, #1
   2f014:	0a5a      	lsrs	r2, r3, #9
   2f016:	490d      	ldr	r1, [pc, #52]	; (2f04c <storage_store_experiment_details+0x148>)
   2f018:	fba1 1202 	umull	r1, r2, r1, r2
   2f01c:	f44f 4176 	mov.w	r1, #62976	; 0xf600
   2f020:	fb01 f202 	mul.w	r2, r1, r2
   2f024:	1a9b      	subs	r3, r3, r2
   2f026:	4a07      	ldr	r2, [pc, #28]	; (2f044 <storage_store_experiment_details+0x140>)
   2f028:	6013      	str	r3, [r2, #0]
      while (!success)
   2f02a:	7bfb      	ldrb	r3, [r7, #15]
   2f02c:	f083 0301 	eor.w	r3, r3, #1
   2f030:	b2db      	uxtb	r3, r3
   2f032:	2b00      	cmp	r3, #0
   2f034:	d18e      	bne.n	2ef54 <storage_store_experiment_details+0x50>
         }
      }
   }
}
   2f036:	bf00      	nop
   2f038:	3710      	adds	r7, #16
   2f03a:	46bd      	mov	sp, r7
   2f03c:	bd80      	pop	{r7, pc}
   2f03e:	bf00      	nop
   2f040:	10008a64 	.word	0x10008a64
   2f044:	10008a5c 	.word	0x10008a5c
   2f048:	10008a58 	.word	0x10008a58
   2f04c:	0214d025 	.word	0x0214d025
   2f050:	10008a60 	.word	0x10008a60
   2f054:	40010224 	.word	0x40010224
   2f058:	10008258 	.word	0x10008258
   2f05c:	000457d8 	.word	0x000457d8
   2f060:	1000825c 	.word	0x1000825c
   2f064:	40010234 	.word	0x40010234

0002f068 <storage_retrieve_experiment_details>:

void storage_retrieve_experiment_details(experiment_details_t *details)
{
   2f068:	b580      	push	{r7, lr}
   2f06a:	b082      	sub	sp, #8
   2f06c:	af00      	add	r7, sp, #0
   2f06e:	6078      	str	r0, [r7, #4]
   // Retrieve experiment details
   if (!in_maintenance_mode)
   2f070:	4b1a      	ldr	r3, [pc, #104]	; (2f0dc <storage_retrieve_experiment_details+0x74>)
   2f072:	781b      	ldrb	r3, [r3, #0]
   2f074:	f083 0301 	eor.w	r3, r3, #1
   2f078:	b2db      	uxtb	r3, r3
   2f07a:	2b00      	cmp	r3, #0
   2f07c:	d006      	beq.n	2f08c <storage_retrieve_experiment_details+0x24>
      am_hal_iom_power_ctrl(spi_handle, AM_HAL_SYSCTRL_WAKE, true);
   2f07e:	4b18      	ldr	r3, [pc, #96]	; (2f0e0 <storage_retrieve_experiment_details+0x78>)
   2f080:	681b      	ldr	r3, [r3, #0]
   2f082:	2201      	movs	r2, #1
   2f084:	2100      	movs	r1, #0
   2f086:	4618      	mov	r0, r3
   2f088:	f005 f854 	bl	34134 <am_hal_iom_power_ctrl>
   if (read_page(transfer_buffer, starting_page))
   2f08c:	4b15      	ldr	r3, [pc, #84]	; (2f0e4 <storage_retrieve_experiment_details+0x7c>)
   2f08e:	681b      	ldr	r3, [r3, #0]
   2f090:	4619      	mov	r1, r3
   2f092:	4815      	ldr	r0, [pc, #84]	; (2f0e8 <storage_retrieve_experiment_details+0x80>)
   2f094:	f7ff fd9a 	bl	2ebcc <read_page>
   2f098:	4603      	mov	r3, r0
   2f09a:	2b00      	cmp	r3, #0
   2f09c:	d006      	beq.n	2f0ac <storage_retrieve_experiment_details+0x44>
      memcpy(details, transfer_buffer + 4, sizeof(*details));
   2f09e:	4b13      	ldr	r3, [pc, #76]	; (2f0ec <storage_retrieve_experiment_details+0x84>)
   2f0a0:	22ed      	movs	r2, #237	; 0xed
   2f0a2:	4619      	mov	r1, r3
   2f0a4:	6878      	ldr	r0, [r7, #4]
   2f0a6:	f7e9 f8d5 	bl	18254 <memcpy>
   2f0aa:	e004      	b.n	2f0b6 <storage_retrieve_experiment_details+0x4e>
   else
      memset(details, 0, sizeof(*details));
   2f0ac:	22ed      	movs	r2, #237	; 0xed
   2f0ae:	2100      	movs	r1, #0
   2f0b0:	6878      	ldr	r0, [r7, #4]
   2f0b2:	f001 f81d 	bl	300f0 <memset>
   if (!in_maintenance_mode)
   2f0b6:	4b09      	ldr	r3, [pc, #36]	; (2f0dc <storage_retrieve_experiment_details+0x74>)
   2f0b8:	781b      	ldrb	r3, [r3, #0]
   2f0ba:	f083 0301 	eor.w	r3, r3, #1
   2f0be:	b2db      	uxtb	r3, r3
   2f0c0:	2b00      	cmp	r3, #0
   2f0c2:	d006      	beq.n	2f0d2 <storage_retrieve_experiment_details+0x6a>
      am_hal_iom_power_ctrl(spi_handle, AM_HAL_SYSCTRL_DEEPSLEEP, true);
   2f0c4:	4b06      	ldr	r3, [pc, #24]	; (2f0e0 <storage_retrieve_experiment_details+0x78>)
   2f0c6:	681b      	ldr	r3, [r3, #0]
   2f0c8:	2201      	movs	r2, #1
   2f0ca:	2102      	movs	r1, #2
   2f0cc:	4618      	mov	r0, r3
   2f0ce:	f005 f831 	bl	34134 <am_hal_iom_power_ctrl>
}
   2f0d2:	bf00      	nop
   2f0d4:	3708      	adds	r7, #8
   2f0d6:	46bd      	mov	sp, r7
   2f0d8:	bd80      	pop	{r7, pc}
   2f0da:	bf00      	nop
   2f0dc:	10008a64 	.word	0x10008a64
   2f0e0:	10008204 	.word	0x10008204
   2f0e4:	10008a58 	.word	0x10008a58
   2f0e8:	10008258 	.word	0x10008258
   2f0ec:	1000825c 	.word	0x1000825c

0002f0f0 <am_gpio0_001f_isr>:
void _getpid(void) {}
void _isatty(void) {}
void _kill(void) {}

void am_gpio0_001f_isr(void)
{
   2f0f0:	b580      	push	{r7, lr}
   2f0f2:	b082      	sub	sp, #8
   2f0f4:	af00      	add	r7, sp, #0
   static uint32_t status;
   AM_CRITICAL_BEGIN
   2f0f6:	f004 fe81 	bl	33dfc <am_hal_interrupt_master_disable>
   2f0fa:	4603      	mov	r3, r0
   2f0fc:	607b      	str	r3, [r7, #4]
   am_hal_gpio_interrupt_irq_status_get(GPIO0_001F_IRQn, false, &status);
   2f0fe:	4a0c      	ldr	r2, [pc, #48]	; (2f130 <am_gpio0_001f_isr+0x40>)
   2f100:	2100      	movs	r1, #0
   2f102:	2038      	movs	r0, #56	; 0x38
   2f104:	f006 fe10 	bl	35d28 <am_hal_gpio_interrupt_irq_status_get>
   am_hal_gpio_interrupt_irq_clear(GPIO0_001F_IRQn, status);
   2f108:	4b09      	ldr	r3, [pc, #36]	; (2f130 <am_gpio0_001f_isr+0x40>)
   2f10a:	681b      	ldr	r3, [r3, #0]
   2f10c:	4619      	mov	r1, r3
   2f10e:	2038      	movs	r0, #56	; 0x38
   2f110:	f006 fe44 	bl	35d9c <am_hal_gpio_interrupt_irq_clear>
   AM_CRITICAL_END
   2f114:	687b      	ldr	r3, [r7, #4]
   2f116:	4618      	mov	r0, r3
   2f118:	f004 fe74 	bl	33e04 <am_hal_interrupt_master_set>
   am_hal_gpio_interrupt_service(GPIO0_001F_IRQn, status);
   2f11c:	4b04      	ldr	r3, [pc, #16]	; (2f130 <am_gpio0_001f_isr+0x40>)
   2f11e:	681b      	ldr	r3, [r3, #0]
   2f120:	4619      	mov	r1, r3
   2f122:	2038      	movs	r0, #56	; 0x38
   2f124:	f006 fe88 	bl	35e38 <am_hal_gpio_interrupt_service>
}
   2f128:	bf00      	nop
   2f12a:	3708      	adds	r7, #8
   2f12c:	46bd      	mov	sp, r7
   2f12e:	bd80      	pop	{r7, pc}
   2f130:	10008a68 	.word	0x10008a68

0002f134 <am_gpio0_203f_isr>:

void am_gpio0_203f_isr(void)
{
   2f134:	b580      	push	{r7, lr}
   2f136:	b082      	sub	sp, #8
   2f138:	af00      	add	r7, sp, #0
   static uint32_t status;
   AM_CRITICAL_BEGIN
   2f13a:	f004 fe5f 	bl	33dfc <am_hal_interrupt_master_disable>
   2f13e:	4603      	mov	r3, r0
   2f140:	607b      	str	r3, [r7, #4]
   am_hal_gpio_interrupt_irq_status_get(GPIO0_203F_IRQn, false, &status);
   2f142:	4a0c      	ldr	r2, [pc, #48]	; (2f174 <am_gpio0_203f_isr+0x40>)
   2f144:	2100      	movs	r1, #0
   2f146:	2039      	movs	r0, #57	; 0x39
   2f148:	f006 fdee 	bl	35d28 <am_hal_gpio_interrupt_irq_status_get>
   am_hal_gpio_interrupt_irq_clear(GPIO0_203F_IRQn, status);
   2f14c:	4b09      	ldr	r3, [pc, #36]	; (2f174 <am_gpio0_203f_isr+0x40>)
   2f14e:	681b      	ldr	r3, [r3, #0]
   2f150:	4619      	mov	r1, r3
   2f152:	2039      	movs	r0, #57	; 0x39
   2f154:	f006 fe22 	bl	35d9c <am_hal_gpio_interrupt_irq_clear>
   AM_CRITICAL_END
   2f158:	687b      	ldr	r3, [r7, #4]
   2f15a:	4618      	mov	r0, r3
   2f15c:	f004 fe52 	bl	33e04 <am_hal_interrupt_master_set>
   am_hal_gpio_interrupt_service(GPIO0_203F_IRQn, status);
   2f160:	4b04      	ldr	r3, [pc, #16]	; (2f174 <am_gpio0_203f_isr+0x40>)
   2f162:	681b      	ldr	r3, [r3, #0]
   2f164:	4619      	mov	r1, r3
   2f166:	2039      	movs	r0, #57	; 0x39
   2f168:	f006 fe66 	bl	35e38 <am_hal_gpio_interrupt_service>
}
   2f16c:	bf00      	nop
   2f16e:	3708      	adds	r7, #8
   2f170:	46bd      	mov	sp, r7
   2f172:	bd80      	pop	{r7, pc}
   2f174:	10008a6c 	.word	0x10008a6c

0002f178 <am_gpio0_405f_isr>:

void am_gpio0_405f_isr(void)
{
   2f178:	b580      	push	{r7, lr}
   2f17a:	b082      	sub	sp, #8
   2f17c:	af00      	add	r7, sp, #0
   static uint32_t status;
   AM_CRITICAL_BEGIN
   2f17e:	f004 fe3d 	bl	33dfc <am_hal_interrupt_master_disable>
   2f182:	4603      	mov	r3, r0
   2f184:	607b      	str	r3, [r7, #4]
   am_hal_gpio_interrupt_irq_status_get(GPIO0_405F_IRQn, false, &status);
   2f186:	4a0c      	ldr	r2, [pc, #48]	; (2f1b8 <am_gpio0_405f_isr+0x40>)
   2f188:	2100      	movs	r1, #0
   2f18a:	203a      	movs	r0, #58	; 0x3a
   2f18c:	f006 fdcc 	bl	35d28 <am_hal_gpio_interrupt_irq_status_get>
   am_hal_gpio_interrupt_irq_clear(GPIO0_405F_IRQn, status);
   2f190:	4b09      	ldr	r3, [pc, #36]	; (2f1b8 <am_gpio0_405f_isr+0x40>)
   2f192:	681b      	ldr	r3, [r3, #0]
   2f194:	4619      	mov	r1, r3
   2f196:	203a      	movs	r0, #58	; 0x3a
   2f198:	f006 fe00 	bl	35d9c <am_hal_gpio_interrupt_irq_clear>
   AM_CRITICAL_END
   2f19c:	687b      	ldr	r3, [r7, #4]
   2f19e:	4618      	mov	r0, r3
   2f1a0:	f004 fe30 	bl	33e04 <am_hal_interrupt_master_set>
   am_hal_gpio_interrupt_service(GPIO0_405F_IRQn, status);
   2f1a4:	4b04      	ldr	r3, [pc, #16]	; (2f1b8 <am_gpio0_405f_isr+0x40>)
   2f1a6:	681b      	ldr	r3, [r3, #0]
   2f1a8:	4619      	mov	r1, r3
   2f1aa:	203a      	movs	r0, #58	; 0x3a
   2f1ac:	f006 fe44 	bl	35e38 <am_hal_gpio_interrupt_service>
}
   2f1b0:	bf00      	nop
   2f1b2:	3708      	adds	r7, #8
   2f1b4:	46bd      	mov	sp, r7
   2f1b6:	bd80      	pop	{r7, pc}
   2f1b8:	10008a70 	.word	0x10008a70

0002f1bc <am_gpio0_607f_isr>:

void am_gpio0_607f_isr(void)
{
   2f1bc:	b580      	push	{r7, lr}
   2f1be:	b082      	sub	sp, #8
   2f1c0:	af00      	add	r7, sp, #0
   static uint32_t status;
   AM_CRITICAL_BEGIN
   2f1c2:	f004 fe1b 	bl	33dfc <am_hal_interrupt_master_disable>
   2f1c6:	4603      	mov	r3, r0
   2f1c8:	607b      	str	r3, [r7, #4]
   am_hal_gpio_interrupt_irq_status_get(GPIO0_607F_IRQn, false, &status);
   2f1ca:	4a0c      	ldr	r2, [pc, #48]	; (2f1fc <am_gpio0_607f_isr+0x40>)
   2f1cc:	2100      	movs	r1, #0
   2f1ce:	203b      	movs	r0, #59	; 0x3b
   2f1d0:	f006 fdaa 	bl	35d28 <am_hal_gpio_interrupt_irq_status_get>
   am_hal_gpio_interrupt_irq_clear(GPIO0_607F_IRQn, status);
   2f1d4:	4b09      	ldr	r3, [pc, #36]	; (2f1fc <am_gpio0_607f_isr+0x40>)
   2f1d6:	681b      	ldr	r3, [r3, #0]
   2f1d8:	4619      	mov	r1, r3
   2f1da:	203b      	movs	r0, #59	; 0x3b
   2f1dc:	f006 fdde 	bl	35d9c <am_hal_gpio_interrupt_irq_clear>
   AM_CRITICAL_END
   2f1e0:	687b      	ldr	r3, [r7, #4]
   2f1e2:	4618      	mov	r0, r3
   2f1e4:	f004 fe0e 	bl	33e04 <am_hal_interrupt_master_set>
   am_hal_gpio_interrupt_service(GPIO0_607F_IRQn, status);
   2f1e8:	4b04      	ldr	r3, [pc, #16]	; (2f1fc <am_gpio0_607f_isr+0x40>)
   2f1ea:	681b      	ldr	r3, [r3, #0]
   2f1ec:	4619      	mov	r1, r3
   2f1ee:	203b      	movs	r0, #59	; 0x3b
   2f1f0:	f006 fe22 	bl	35e38 <am_hal_gpio_interrupt_service>
}
   2f1f4:	bf00      	nop
   2f1f6:	3708      	adds	r7, #8
   2f1f8:	46bd      	mov	sp, r7
   2f1fa:	bd80      	pop	{r7, pc}
   2f1fc:	10008a74 	.word	0x10008a74

0002f200 <am_rtc_isr>:

void am_rtc_isr(void)
{
   2f200:	b580      	push	{r7, lr}
   2f202:	b082      	sub	sp, #8
   2f204:	af00      	add	r7, sp, #0
   static am_hal_rtc_alarm_repeat_e repeat_interval;
   AM_CRITICAL_BEGIN
   2f206:	f004 fdf9 	bl	33dfc <am_hal_interrupt_master_disable>
   2f20a:	4603      	mov	r3, r0
   2f20c:	607b      	str	r3, [r7, #4]
   am_hal_rtc_alarm_get(NULL, &repeat_interval);
   2f20e:	490a      	ldr	r1, [pc, #40]	; (2f238 <am_rtc_isr+0x38>)
   2f210:	2000      	movs	r0, #0
   2f212:	f005 ff07 	bl	35024 <am_hal_rtc_alarm_get>
   am_hal_rtc_interrupt_clear(AM_HAL_RTC_INT_ALM);
   2f216:	2001      	movs	r0, #1
   2f218:	f005 ff78 	bl	3510c <am_hal_rtc_interrupt_clear>
   AM_CRITICAL_END
   2f21c:	687b      	ldr	r3, [r7, #4]
   2f21e:	4618      	mov	r0, r3
   2f220:	f004 fdf0 	bl	33e04 <am_hal_interrupt_master_set>
   if (repeat_interval == AM_HAL_RTC_ALM_RPT_SEC)
   2f224:	4b04      	ldr	r3, [pc, #16]	; (2f238 <am_rtc_isr+0x38>)
   2f226:	781b      	ldrb	r3, [r3, #0]
   2f228:	2b07      	cmp	r3, #7
   2f22a:	d101      	bne.n	2f230 <am_rtc_isr+0x30>
      scheduler_rtc_isr();
   2f22c:	f000 fc66 	bl	2fafc <scheduler_rtc_isr>
}
   2f230:	bf00      	nop
   2f232:	3708      	adds	r7, #8
   2f234:	46bd      	mov	sp, r7
   2f236:	bd80      	pop	{r7, pc}
   2f238:	10008a78 	.word	0x10008a78

0002f23c <am_freertos_sleep>:

uint32_t am_freertos_sleep(uint32_t idleTime)
{
   2f23c:	b580      	push	{r7, lr}
   2f23e:	b082      	sub	sp, #8
   2f240:	af00      	add	r7, sp, #0
   2f242:	6078      	str	r0, [r7, #4]
   am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
   2f244:	2001      	movs	r0, #1
   2f246:	f005 ff69 	bl	3511c <am_hal_sysctrl_sleep>
   return 0;
   2f24a:	2300      	movs	r3, #0
}
   2f24c:	4618      	mov	r0, r3
   2f24e:	3708      	adds	r7, #8
   2f250:	46bd      	mov	sp, r7
   2f252:	bd80      	pop	{r7, pc}

0002f254 <am_freertos_wakeup>:

void am_freertos_wakeup(uint32_t idleTime) { return; }
   2f254:	b480      	push	{r7}
   2f256:	b083      	sub	sp, #12
   2f258:	af00      	add	r7, sp, #0
   2f25a:	6078      	str	r0, [r7, #4]
   2f25c:	bf00      	nop
   2f25e:	370c      	adds	r7, #12
   2f260:	46bd      	mov	sp, r7
   2f262:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f266:	4770      	bx	lr

0002f268 <system_hard_fault_handler>:
      "mrsne r0, psp \n"                         \
      "b system_hard_fault_handler \n"           )

__attribute__((optimize("O0")))
void system_hard_fault_handler(sContextStateFrame *frame)
{
   2f268:	b480      	push	{r7}
   2f26a:	b083      	sub	sp, #12
   2f26c:	af00      	add	r7, sp, #0
   2f26e:	6078      	str	r0, [r7, #4]
#ifdef DEBUGGING
   do {
      if (CoreDebug->DHCSR & (1 << 0))
   2f270:	4b06      	ldr	r3, [pc, #24]	; (2f28c <system_hard_fault_handler+0x24>)
   2f272:	681b      	ldr	r3, [r3, #0]
   2f274:	f003 0301 	and.w	r3, r3, #1
   2f278:	2b00      	cmp	r3, #0
   2f27a:	d000      	beq.n	2f27e <system_hard_fault_handler+0x16>
         __asm("bkpt 1");
   2f27c:	be01      	bkpt	0x0001
   } while (0);
#else
   NVIC_SystemReset();
   while (true) {}
#endif
}
   2f27e:	bf00      	nop
   2f280:	370c      	adds	r7, #12
   2f282:	46bd      	mov	sp, r7
   2f284:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f288:	4770      	bx	lr
   2f28a:	bf00      	nop
   2f28c:	e000edf0 	.word	0xe000edf0

0002f290 <HardFault_Handler>:

void HardFault_Handler(void) { HARDFAULT_HANDLING_ASM(); }
   2f290:	b480      	push	{r7}
   2f292:	af00      	add	r7, sp, #0
   2f294:	f01e 0f04 	tst.w	lr, #4
   2f298:	bf0c      	ite	eq
   2f29a:	f3ef 8008 	mrseq	r0, MSP
   2f29e:	f3ef 8009 	mrsne	r0, PSP
   2f2a2:	f7ff bfe1 	b.w	2f268 <system_hard_fault_handler>
   2f2a6:	bf00      	nop
   2f2a8:	46bd      	mov	sp, r7
   2f2aa:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f2ae:	4770      	bx	lr

0002f2b0 <vAssertCalled>:
   while (1)
      __asm("BKPT #0\n");
}

void vAssertCalled(const char * const pcFileName, unsigned long ulLine)
{
   2f2b0:	b580      	push	{r7, lr}
   2f2b2:	b084      	sub	sp, #16
   2f2b4:	af00      	add	r7, sp, #0
   2f2b6:	6078      	str	r0, [r7, #4]
   2f2b8:	6039      	str	r1, [r7, #0]
   volatile uint32_t ulSetToNonZeroInDebuggerToContinue = 0;
   2f2ba:	2300      	movs	r3, #0
   2f2bc:	60fb      	str	r3, [r7, #12]
   taskENTER_CRITICAL();
   2f2be:	f7fb fa81 	bl	2a7c4 <vPortEnterCritical>
   {
      // You can step out of this function to debug the assertion by using
      // the debugger to set ulSetToNonZeroInDebuggerToContinue to a non-zero value.
      while (ulSetToNonZeroInDebuggerToContinue == 0)
   2f2c2:	bf00      	nop
   2f2c4:	68fb      	ldr	r3, [r7, #12]
   2f2c6:	2b00      	cmp	r3, #0
   2f2c8:	d0fc      	beq.n	2f2c4 <vAssertCalled+0x14>
         portNOP();
   }
   taskEXIT_CRITICAL();
   2f2ca:	f7fb fa95 	bl	2a7f8 <vPortExitCritical>
}
   2f2ce:	bf00      	nop
   2f2d0:	3710      	adds	r7, #16
   2f2d2:	46bd      	mov	sp, r7
   2f2d4:	bd80      	pop	{r7, pc}
	...

0002f2d8 <setup_hardware>:


// Public API Functions ------------------------------------------------------------------------------------------------

void setup_hardware(void)
{
   2f2d8:	b580      	push	{r7, lr}
   2f2da:	b08c      	sub	sp, #48	; 0x30
   2f2dc:	af00      	add	r7, sp, #0
   // Read the hardware reset reason
   am_hal_reset_status_t reset_reason;
   am_hal_reset_status_get(&reset_reason);
   2f2de:	f107 0320 	add.w	r3, r7, #32
   2f2e2:	4618      	mov	r0, r3
   2f2e4:	f005 fd46 	bl	34d74 <am_hal_reset_status_get>

   // Enable the floating point module
   am_hal_sysctrl_fpu_enable();
   2f2e8:	f005 ff96 	bl	35218 <am_hal_sysctrl_fpu_enable>
   am_hal_sysctrl_fpu_stacking_enable(true);
   2f2ec:	2001      	movs	r0, #1
   2f2ee:	f005 ff9b 	bl	35228 <am_hal_sysctrl_fpu_stacking_enable>

   // Configure the board to operate in low-power mode
   am_hal_pwrctrl_low_power_init();
   2f2f2:	f007 f957 	bl	365a4 <am_hal_pwrctrl_low_power_init>
   am_hal_pwrctrl_control(AM_HAL_PWRCTRL_CONTROL_SIMOBUCK_INIT, NULL);
   2f2f6:	2100      	movs	r1, #0
   2f2f8:	2000      	movs	r0, #0
   2f2fa:	f007 fa25 	bl	36748 <am_hal_pwrctrl_control>

   // Turn on all necessary memory
   am_hal_pwrctrl_dsp_memory_config_t dsp_mem_config =
   2f2fe:	f107 0318 	add.w	r3, r7, #24
   2f302:	2200      	movs	r2, #0
   2f304:	601a      	str	r2, [r3, #0]
   2f306:	711a      	strb	r2, [r3, #4]
      .bRetainCache = false,
      .bEnableRAM = false,
      .bActiveRAM = false,
      .bRetainRAM = false
   };
   am_hal_pwrctrl_mcu_memory_config_t mcu_mem_config =
   2f308:	4a2d      	ldr	r2, [pc, #180]	; (2f3c0 <setup_hardware+0xe8>)
   2f30a:	f107 0310 	add.w	r3, r7, #16
   2f30e:	e892 0003 	ldmia.w	r2, {r0, r1}
   2f312:	6018      	str	r0, [r3, #0]
   2f314:	3304      	adds	r3, #4
   2f316:	8019      	strh	r1, [r3, #0]
      .eDTCMCfg     = AM_HAL_PWRCTRL_DTCM_384K,
      .eRetainDTCM  = AM_HAL_PWRCTRL_DTCM_384K,
      .bEnableNVM0  = true,
      .bRetainNVM0  = false
   };
   am_hal_pwrctrl_sram_memcfg_t sram_mem_config =
   2f318:	f107 0308 	add.w	r3, r7, #8
   2f31c:	2200      	movs	r2, #0
   2f31e:	601a      	str	r2, [r3, #0]
   2f320:	809a      	strh	r2, [r3, #4]
      .eActiveWithGFX     = AM_HAL_PWRCTRL_SRAM_NONE,
      .eActiveWithDISP    = AM_HAL_PWRCTRL_SRAM_NONE,
      .eActiveWithDSP     = AM_HAL_PWRCTRL_SRAM_NONE,
      .eSRAMRetain        = AM_HAL_PWRCTRL_SRAM_NONE
   };
   am_hal_pwrctrl_dsp_memory_config(AM_HAL_DSP0, &dsp_mem_config);
   2f322:	f107 0318 	add.w	r3, r7, #24
   2f326:	4619      	mov	r1, r3
   2f328:	2000      	movs	r0, #0
   2f32a:	f006 fec3 	bl	360b4 <am_hal_pwrctrl_dsp_memory_config>
   am_hal_pwrctrl_dsp_memory_config(AM_HAL_DSP1, &dsp_mem_config);
   2f32e:	f107 0318 	add.w	r3, r7, #24
   2f332:	4619      	mov	r1, r3
   2f334:	2001      	movs	r0, #1
   2f336:	f006 febd 	bl	360b4 <am_hal_pwrctrl_dsp_memory_config>
   am_hal_pwrctrl_mcu_memory_config(&mcu_mem_config);
   2f33a:	f107 0310 	add.w	r3, r7, #16
   2f33e:	4618      	mov	r0, r3
   2f340:	f006 fdb2 	bl	35ea8 <am_hal_pwrctrl_mcu_memory_config>
   am_hal_pwrctrl_sram_config(&sram_mem_config);
   2f344:	f107 0308 	add.w	r3, r7, #8
   2f348:	4618      	mov	r0, r3
   2f34a:	f006 fe5b 	bl	36004 <am_hal_pwrctrl_sram_config>

   // Set up the cache configuration
   const am_hal_cachectrl_config_t cachectrl_config =
   2f34e:	4a1d      	ldr	r2, [pc, #116]	; (2f3c4 <setup_hardware+0xec>)
   2f350:	1d3b      	adds	r3, r7, #4
   2f352:	6812      	ldr	r2, [r2, #0]
   2f354:	4611      	mov	r1, r2
   2f356:	8019      	strh	r1, [r3, #0]
   2f358:	3302      	adds	r3, #2
   2f35a:	0c12      	lsrs	r2, r2, #16
   2f35c:	701a      	strb	r2, [r3, #0]
   {
      .bLRU                       = false,
      .eDescript                  = AM_HAL_CACHECTRL_DESCR_1WAY_128B_512E,
      .eMode                      = AM_HAL_CACHECTRL_CONFIG_MODE_INSTR,
   };
   am_hal_cachectrl_config(&cachectrl_config);
   2f35e:	1d3b      	adds	r3, r7, #4
   2f360:	4618      	mov	r0, r3
   2f362:	f004 fc57 	bl	33c14 <am_hal_cachectrl_config>
   am_hal_cachectrl_enable();
   2f366:	f004 fc77 	bl	33c58 <am_hal_cachectrl_enable>

   // Turn on the power rails to all external peripherals
   configASSERT0(am_hal_gpio_pinconfig(PIN_EXTERNAL_PERIPH_POWER_ENABLE, am_hal_gpio_pincfg_output));
   2f36a:	4b17      	ldr	r3, [pc, #92]	; (2f3c8 <setup_hardware+0xf0>)
   2f36c:	6819      	ldr	r1, [r3, #0]
   2f36e:	2055      	movs	r0, #85	; 0x55
   2f370:	f006 fbe2 	bl	35b38 <am_hal_gpio_pinconfig>
   2f374:	4603      	mov	r3, r0
   2f376:	2b00      	cmp	r3, #0
   2f378:	d003      	beq.n	2f382 <setup_hardware+0xaa>
   2f37a:	21d2      	movs	r1, #210	; 0xd2
   2f37c:	4813      	ldr	r0, [pc, #76]	; (2f3cc <setup_hardware+0xf4>)
   2f37e:	f7ff ff97 	bl	2f2b0 <vAssertCalled>
   configASSERT0(am_hal_gpio_pinconfig(PIN_BLE_PERIPH_POWER_ENABLE, am_hal_gpio_pincfg_output));
   2f382:	4b11      	ldr	r3, [pc, #68]	; (2f3c8 <setup_hardware+0xf0>)
   2f384:	6819      	ldr	r1, [r3, #0]
   2f386:	2055      	movs	r0, #85	; 0x55
   2f388:	f006 fbd6 	bl	35b38 <am_hal_gpio_pinconfig>
   2f38c:	4603      	mov	r3, r0
   2f38e:	2b00      	cmp	r3, #0
   2f390:	d003      	beq.n	2f39a <setup_hardware+0xc2>
   2f392:	21d3      	movs	r1, #211	; 0xd3
   2f394:	480d      	ldr	r0, [pc, #52]	; (2f3cc <setup_hardware+0xf4>)
   2f396:	f7ff ff8b 	bl	2f2b0 <vAssertCalled>
   am_hal_gpio_output_set(PIN_EXTERNAL_PERIPH_POWER_ENABLE);
   2f39a:	4b0d      	ldr	r3, [pc, #52]	; (2f3d0 <setup_hardware+0xf8>)
   2f39c:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   2f3a0:	601a      	str	r2, [r3, #0]
   am_hal_gpio_output_set(PIN_BLE_PERIPH_POWER_ENABLE);
   2f3a2:	4b0b      	ldr	r3, [pc, #44]	; (2f3d0 <setup_hardware+0xf8>)
   2f3a4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   2f3a8:	601a      	str	r2, [r3, #0]

   // Set up printing to the console
   logging_init();
   2f3aa:	f7ff f973 	bl	2e694 <logging_init>
   print_reset_reason(&reset_reason);
   2f3ae:	f107 0320 	add.w	r3, r7, #32
   2f3b2:	4618      	mov	r0, r3
   2f3b4:	f7ff f974 	bl	2e6a0 <print_reset_reason>
}
   2f3b8:	bf00      	nop
   2f3ba:	3730      	adds	r7, #48	; 0x30
   2f3bc:	46bd      	mov	sp, r7
   2f3be:	bd80      	pop	{r7, pc}
   2f3c0:	00045804 	.word	0x00045804
   2f3c4:	0004580c 	.word	0x0004580c
   2f3c8:	00046808 	.word	0x00046808
   2f3cc:	000457e4 	.word	0x000457e4
   2f3d0:	4001022c 	.word	0x4001022c

0002f3d4 <system_read_UID>:
   am_hal_interrupt_master_enable();
   am_hal_sysctrl_sleep(AM_HAL_SYSCTRL_SLEEP_DEEP);
}

void system_read_UID(uint8_t *uid, uint32_t uid_length)
{
   2f3d4:	b480      	push	{r7}
   2f3d6:	b085      	sub	sp, #20
   2f3d8:	af00      	add	r7, sp, #0
   2f3da:	6078      	str	r0, [r7, #4]
   2f3dc:	6039      	str	r1, [r7, #0]
   // Copy UID from flash memory location into the specified buffer
   uint8_t *_uid = &_uid_base_address;
   2f3de:	4b0d      	ldr	r3, [pc, #52]	; (2f414 <system_read_UID+0x40>)
   2f3e0:	60bb      	str	r3, [r7, #8]
   for (uint32_t i = 0; i < uid_length; ++i)
   2f3e2:	2300      	movs	r3, #0
   2f3e4:	60fb      	str	r3, [r7, #12]
   2f3e6:	e00a      	b.n	2f3fe <system_read_UID+0x2a>
      uid[i] = _uid[i];
   2f3e8:	68ba      	ldr	r2, [r7, #8]
   2f3ea:	68fb      	ldr	r3, [r7, #12]
   2f3ec:	441a      	add	r2, r3
   2f3ee:	6879      	ldr	r1, [r7, #4]
   2f3f0:	68fb      	ldr	r3, [r7, #12]
   2f3f2:	440b      	add	r3, r1
   2f3f4:	7812      	ldrb	r2, [r2, #0]
   2f3f6:	701a      	strb	r2, [r3, #0]
   for (uint32_t i = 0; i < uid_length; ++i)
   2f3f8:	68fb      	ldr	r3, [r7, #12]
   2f3fa:	3301      	adds	r3, #1
   2f3fc:	60fb      	str	r3, [r7, #12]
   2f3fe:	68fa      	ldr	r2, [r7, #12]
   2f400:	683b      	ldr	r3, [r7, #0]
   2f402:	429a      	cmp	r2, r3
   2f404:	d3f0      	bcc.n	2f3e8 <system_read_UID+0x14>
}
   2f406:	bf00      	nop
   2f408:	bf00      	nop
   2f40a:	3714      	adds	r7, #20
   2f40c:	46bd      	mov	sp, r7
   2f40e:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f412:	4770      	bx	lr
   2f414:	001ffff8 	.word	0x001ffff8

0002f418 <app_maintenance_activate_find_my_tottag>:


// Public API Functions ------------------------------------------------------------------------------------------------

void app_maintenance_activate_find_my_tottag(uint32_t seconds_to_activate)
{
   2f418:	b580      	push	{r7, lr}
   2f41a:	b086      	sub	sp, #24
   2f41c:	af02      	add	r7, sp, #8
   2f41e:	6078      	str	r0, [r7, #4]
   // Notify application of the request to active FindMyTottag
   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   2f420:	2300      	movs	r3, #0
   2f422:	60fb      	str	r3, [r7, #12]
   seconds_to_activate_buzzer = seconds_to_activate;
   2f424:	4a0d      	ldr	r2, [pc, #52]	; (2f45c <app_maintenance_activate_find_my_tottag+0x44>)
   2f426:	687b      	ldr	r3, [r7, #4]
   2f428:	6013      	str	r3, [r2, #0]
   xTaskNotifyFromISR(app_task_handle, APP_NOTIFY_FIND_MY_TOTTAG_ACTIVATED, eSetBits, &xHigherPriorityTaskWoken);
   2f42a:	4b0d      	ldr	r3, [pc, #52]	; (2f460 <app_maintenance_activate_find_my_tottag+0x48>)
   2f42c:	6818      	ldr	r0, [r3, #0]
   2f42e:	f107 030c 	add.w	r3, r7, #12
   2f432:	9300      	str	r3, [sp, #0]
   2f434:	2300      	movs	r3, #0
   2f436:	2201      	movs	r2, #1
   2f438:	2180      	movs	r1, #128	; 0x80
   2f43a:	f7fd f90b 	bl	2c654 <xTaskGenericNotifyFromISR>
   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2f43e:	68fb      	ldr	r3, [r7, #12]
   2f440:	2b00      	cmp	r3, #0
   2f442:	d007      	beq.n	2f454 <app_maintenance_activate_find_my_tottag+0x3c>
   2f444:	4b07      	ldr	r3, [pc, #28]	; (2f464 <app_maintenance_activate_find_my_tottag+0x4c>)
   2f446:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2f44a:	601a      	str	r2, [r3, #0]
   2f44c:	f3bf 8f4f 	dsb	sy
   2f450:	f3bf 8f6f 	isb	sy
}
   2f454:	bf00      	nop
   2f456:	3710      	adds	r7, #16
   2f458:	46bd      	mov	sp, r7
   2f45a:	bd80      	pop	{r7, pc}
   2f45c:	10008a80 	.word	0x10008a80
   2f460:	10008a7c 	.word	0x10008a7c
   2f464:	e000ed04 	.word	0xe000ed04

0002f468 <am_timer04_isr>:
      discovered_devices[num_discovered_devices++][EUI_LEN] = ranging_role;
   }
}

void am_timer04_isr(void)
{
   2f468:	b580      	push	{r7, lr}
   2f46a:	b084      	sub	sp, #16
   2f46c:	af02      	add	r7, sp, #8
   // Notify the main task to handle the interrupt
   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   2f46e:	2300      	movs	r3, #0
   2f470:	607b      	str	r3, [r7, #4]
   am_hal_timer_interrupt_clear(AM_HAL_TIMER_MASK(BLE_SCANNING_TIMER_NUMBER, AM_HAL_TIMER_COMPARE_BOTH));
   2f472:	f44f 7040 	mov.w	r0, #768	; 0x300
   2f476:	f007 fc0f 	bl	36c98 <am_hal_timer_interrupt_clear>
   xTaskNotifyFromISR(app_task_handle, APP_NOTIFY_NETWORK_FOUND, eSetBits, &xHigherPriorityTaskWoken);
   2f47a:	4b0c      	ldr	r3, [pc, #48]	; (2f4ac <am_timer04_isr+0x44>)
   2f47c:	6818      	ldr	r0, [r3, #0]
   2f47e:	1d3b      	adds	r3, r7, #4
   2f480:	9300      	str	r3, [sp, #0]
   2f482:	2300      	movs	r3, #0
   2f484:	2201      	movs	r2, #1
   2f486:	2104      	movs	r1, #4
   2f488:	f7fd f8e4 	bl	2c654 <xTaskGenericNotifyFromISR>
   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2f48c:	687b      	ldr	r3, [r7, #4]
   2f48e:	2b00      	cmp	r3, #0
   2f490:	d007      	beq.n	2f4a2 <am_timer04_isr+0x3a>
   2f492:	4b07      	ldr	r3, [pc, #28]	; (2f4b0 <am_timer04_isr+0x48>)
   2f494:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2f498:	601a      	str	r2, [r3, #0]
   2f49a:	f3bf 8f4f 	dsb	sy
   2f49e:	f3bf 8f6f 	isb	sy
}
   2f4a2:	bf00      	nop
   2f4a4:	3708      	adds	r7, #8
   2f4a6:	46bd      	mov	sp, r7
   2f4a8:	bd80      	pop	{r7, pc}
   2f4aa:	bf00      	nop
   2f4ac:	10008a84 	.word	0x10008a84
   2f4b0:	e000ed04 	.word	0xe000ed04

0002f4b4 <app_notify>:
// Public API Functions ------------------------------------------------------------------------------------------------

extern void app_maintenance_activate_find_my_tottag(uint32_t seconds_to_activate);

void app_notify(app_notification_t notification, bool from_isr)
{
   2f4b4:	b580      	push	{r7, lr}
   2f4b6:	b086      	sub	sp, #24
   2f4b8:	af02      	add	r7, sp, #8
   2f4ba:	4603      	mov	r3, r0
   2f4bc:	460a      	mov	r2, r1
   2f4be:	71fb      	strb	r3, [r7, #7]
   2f4c0:	4613      	mov	r3, r2
   2f4c2:	71bb      	strb	r3, [r7, #6]
   // Call the correct notification function based on the current ISR context
   if (app_task_handle)
   2f4c4:	4b14      	ldr	r3, [pc, #80]	; (2f518 <app_notify+0x64>)
   2f4c6:	681b      	ldr	r3, [r3, #0]
   2f4c8:	2b00      	cmp	r3, #0
   2f4ca:	d021      	beq.n	2f510 <app_notify+0x5c>
   {
      if (from_isr)
   2f4cc:	79bb      	ldrb	r3, [r7, #6]
   2f4ce:	2b00      	cmp	r3, #0
   2f4d0:	d017      	beq.n	2f502 <app_notify+0x4e>
      {
         BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   2f4d2:	2300      	movs	r3, #0
   2f4d4:	60fb      	str	r3, [r7, #12]
         xTaskNotifyFromISR(app_task_handle, notification, eSetBits, &xHigherPriorityTaskWoken);
   2f4d6:	4b10      	ldr	r3, [pc, #64]	; (2f518 <app_notify+0x64>)
   2f4d8:	6818      	ldr	r0, [r3, #0]
   2f4da:	79f9      	ldrb	r1, [r7, #7]
   2f4dc:	f107 030c 	add.w	r3, r7, #12
   2f4e0:	9300      	str	r3, [sp, #0]
   2f4e2:	2300      	movs	r3, #0
   2f4e4:	2201      	movs	r2, #1
   2f4e6:	f7fd f8b5 	bl	2c654 <xTaskGenericNotifyFromISR>
         portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2f4ea:	68fb      	ldr	r3, [r7, #12]
   2f4ec:	2b00      	cmp	r3, #0
   2f4ee:	d00f      	beq.n	2f510 <app_notify+0x5c>
   2f4f0:	4b0a      	ldr	r3, [pc, #40]	; (2f51c <app_notify+0x68>)
   2f4f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2f4f6:	601a      	str	r2, [r3, #0]
   2f4f8:	f3bf 8f4f 	dsb	sy
   2f4fc:	f3bf 8f6f 	isb	sy
      }
      else
         xTaskNotify(app_task_handle, notification, eSetBits);
   }
}
   2f500:	e006      	b.n	2f510 <app_notify+0x5c>
         xTaskNotify(app_task_handle, notification, eSetBits);
   2f502:	4b05      	ldr	r3, [pc, #20]	; (2f518 <app_notify+0x64>)
   2f504:	6818      	ldr	r0, [r3, #0]
   2f506:	79f9      	ldrb	r1, [r7, #7]
   2f508:	2300      	movs	r3, #0
   2f50a:	2201      	movs	r2, #1
   2f50c:	f7fd f818 	bl	2c540 <xTaskGenericNotify>
}
   2f510:	bf00      	nop
   2f512:	3710      	adds	r7, #16
   2f514:	46bd      	mov	sp, r7
   2f516:	bd80      	pop	{r7, pc}
   2f518:	10008a84 	.word	0x10008a84
   2f51c:	e000ed04 	.word	0xe000ed04

0002f520 <app_schedule_device>:

void app_schedule_device(const uint8_t *uid)
{
   2f520:	b580      	push	{r7, lr}
   2f522:	b082      	sub	sp, #8
   2f524:	af00      	add	r7, sp, #0
   2f526:	6078      	str	r0, [r7, #4]
   // Notify application of the device scheduling request
   memcpy(previous_device_id_to_schedule, device_id_to_schedule, EUI_LEN);
   2f528:	4b0a      	ldr	r3, [pc, #40]	; (2f554 <app_schedule_device+0x34>)
   2f52a:	4a0b      	ldr	r2, [pc, #44]	; (2f558 <app_schedule_device+0x38>)
   2f52c:	e892 0003 	ldmia.w	r2, {r0, r1}
   2f530:	6018      	str	r0, [r3, #0]
   2f532:	3304      	adds	r3, #4
   2f534:	8019      	strh	r1, [r3, #0]
   memcpy(device_id_to_schedule, uid, EUI_LEN);
   2f536:	4b08      	ldr	r3, [pc, #32]	; (2f558 <app_schedule_device+0x38>)
   2f538:	687a      	ldr	r2, [r7, #4]
   2f53a:	6810      	ldr	r0, [r2, #0]
   2f53c:	6018      	str	r0, [r3, #0]
   2f53e:	8892      	ldrh	r2, [r2, #4]
   2f540:	809a      	strh	r2, [r3, #4]
   app_notify(APP_NOTIFY_SCHEDULE_DEVICE, false);
   2f542:	2100      	movs	r1, #0
   2f544:	2040      	movs	r0, #64	; 0x40
   2f546:	f7ff ffb5 	bl	2f4b4 <app_notify>
}
   2f54a:	bf00      	nop
   2f54c:	3708      	adds	r7, #8
   2f54e:	46bd      	mov	sp, r7
   2f550:	bd80      	pop	{r7, pc}
   2f552:	bf00      	nop
   2f554:	10008a88 	.word	0x10008a88
   2f558:	10008a90 	.word	0x10008a90

0002f55c <app_activate_find_my_tottag>:

void app_activate_find_my_tottag(uint32_t seconds_to_activate)
{
   2f55c:	b580      	push	{r7, lr}
   2f55e:	b082      	sub	sp, #8
   2f560:	af00      	add	r7, sp, #0
   2f562:	6078      	str	r0, [r7, #4]
   // Notify application of the request to active FindMyTottag
   if (app_task_handle)
   2f564:	4b09      	ldr	r3, [pc, #36]	; (2f58c <app_activate_find_my_tottag+0x30>)
   2f566:	681b      	ldr	r3, [r3, #0]
   2f568:	2b00      	cmp	r3, #0
   2f56a:	d007      	beq.n	2f57c <app_activate_find_my_tottag+0x20>
   {
      seconds_to_activate_buzzer = seconds_to_activate;
   2f56c:	4a08      	ldr	r2, [pc, #32]	; (2f590 <app_activate_find_my_tottag+0x34>)
   2f56e:	687b      	ldr	r3, [r7, #4]
   2f570:	6013      	str	r3, [r2, #0]
      app_notify(APP_NOTIFY_FIND_MY_TOTTAG_ACTIVATED, false);
   2f572:	2100      	movs	r1, #0
   2f574:	2080      	movs	r0, #128	; 0x80
   2f576:	f7ff ff9d 	bl	2f4b4 <app_notify>
   }
   else
      app_maintenance_activate_find_my_tottag(seconds_to_activate);
}
   2f57a:	e002      	b.n	2f582 <app_activate_find_my_tottag+0x26>
      app_maintenance_activate_find_my_tottag(seconds_to_activate);
   2f57c:	6878      	ldr	r0, [r7, #4]
   2f57e:	f7ff ff4b 	bl	2f418 <app_maintenance_activate_find_my_tottag>
}
   2f582:	bf00      	nop
   2f584:	3708      	adds	r7, #8
   2f586:	46bd      	mov	sp, r7
   2f588:	bd80      	pop	{r7, pc}
   2f58a:	bf00      	nop
   2f58c:	10008a84 	.word	0x10008a84
   2f590:	10008a98 	.word	0x10008a98

0002f594 <ble_stack_init>:


// Private Helper Functions --------------------------------------------------------------------------------------------

static void ble_stack_init(void)
{
   2f594:	b580      	push	{r7, lr}
   2f596:	b082      	sub	sp, #8
   2f598:	af00      	add	r7, sp, #0
   // Set up timers for the WSF scheduler
   WsfOsInit();
   2f59a:	f7fd ff15 	bl	2d3c8 <WsfOsInit>
   WsfTimerInit();
   2f59e:	f7fe f8fb 	bl	2d798 <WsfTimerInit>

   // Initialize a buffer pool for WSF dynamic memory needs
   uint16_t wsfBufMemLen = WsfBufInit(sizeof(g_pui32BufMem), (uint8_t *)g_pui32BufMem, WSF_BUF_POOLS, g_psPoolDescriptors);
   2f5a2:	4b35      	ldr	r3, [pc, #212]	; (2f678 <ble_stack_init+0xe4>)
   2f5a4:	2205      	movs	r2, #5
   2f5a6:	4935      	ldr	r1, [pc, #212]	; (2f67c <ble_stack_init+0xe8>)
   2f5a8:	f241 1094 	movw	r0, #4500	; 0x1194
   2f5ac:	f7fd fc46 	bl	2ce3c <WsfBufInit>
   2f5b0:	4603      	mov	r3, r0
   2f5b2:	80fb      	strh	r3, [r7, #6]
   if (wsfBufMemLen > sizeof(g_pui32BufMem))
   2f5b4:	88fb      	ldrh	r3, [r7, #6]
   2f5b6:	f241 1294 	movw	r2, #4500	; 0x1194
   2f5ba:	4293      	cmp	r3, r2
   2f5bc:	d907      	bls.n	2f5ce <ble_stack_init+0x3a>
      print("ERROR: Memory pool is too small by %d\n", wsfBufMemLen - sizeof(g_pui32BufMem));
   2f5be:	88fb      	ldrh	r3, [r7, #6]
   2f5c0:	f5a3 538c 	sub.w	r3, r3, #4480	; 0x1180
   2f5c4:	3b14      	subs	r3, #20
   2f5c6:	4619      	mov	r1, r3
   2f5c8:	482d      	ldr	r0, [pc, #180]	; (2f680 <ble_stack_init+0xec>)
   2f5ca:	f7eb fae9 	bl	1aba0 <am_util_stdio_printf>

   // Initialize the WSF security service
   SecInit();
   2f5ce:	f7fc f9a1 	bl	2b914 <SecInit>
   SecAesInit();
   2f5d2:	f7fb fea3 	bl	2b31c <SecAesInit>
   SecCmacInit();
   2f5d6:	f7fc f86d 	bl	2b6b4 <SecCmacInit>
   SecEccInit();
   2f5da:	f7fc f8c3 	bl	2b764 <SecEccInit>

   // Set up callback functions for the various layers of the BLE stack
   HciHandlerInit(WsfOsSetNextHandler(HciHandler));
   2f5de:	4829      	ldr	r0, [pc, #164]	; (2f684 <ble_stack_init+0xf0>)
   2f5e0:	f7fd fec4 	bl	2d36c <WsfOsSetNextHandler>
   2f5e4:	4603      	mov	r3, r0
   2f5e6:	4618      	mov	r0, r3
   2f5e8:	f7f9 fd4a 	bl	29080 <HciHandlerInit>
   DmDevVsInit(0);
   2f5ec:	2000      	movs	r0, #0
   2f5ee:	f7f4 fb85 	bl	23cfc <DmDevVsInit>
   DmAdvInit();
   2f5f2:	f7f3 f839 	bl	22668 <DmAdvInit>
   DmScanInit();
   2f5f6:	f7f5 f875 	bl	246e4 <DmScanInit>
   DmPhyInit();
   2f5fa:	f7f4 fd7b 	bl	240f4 <DmPhyInit>
   DmConnInit();
   2f5fe:	f7f3 fddf 	bl	231c0 <DmConnInit>
   DmConnMasterInit();
   2f602:	f7f4 f927 	bl	23854 <DmConnMasterInit>
   DmConnSlaveInit();
   2f606:	f7f4 fa1d 	bl	23a44 <DmConnSlaveInit>
   DmHandlerInit(WsfOsSetNextHandler(DmHandler));
   2f60a:	481f      	ldr	r0, [pc, #124]	; (2f688 <ble_stack_init+0xf4>)
   2f60c:	f7fd feae 	bl	2d36c <WsfOsSetNextHandler>
   2f610:	4603      	mov	r3, r0
   2f612:	4618      	mov	r0, r3
   2f614:	f7f4 fc20 	bl	23e58 <DmHandlerInit>
   L2cSlaveHandlerInit(WsfOsSetNextHandler(L2cSlaveHandler));
   2f618:	481c      	ldr	r0, [pc, #112]	; (2f68c <ble_stack_init+0xf8>)
   2f61a:	f7fd fea7 	bl	2d36c <WsfOsSetNextHandler>
   2f61e:	4603      	mov	r3, r0
   2f620:	4618      	mov	r0, r3
   2f622:	f7fa ff07 	bl	2a434 <L2cSlaveHandlerInit>
   L2cInit();
   2f626:	f7fa fc0f 	bl	29e48 <L2cInit>
   L2cSlaveInit();
   2f62a:	f7fa fe49 	bl	2a2c0 <L2cSlaveInit>
   L2cMasterInit();
   2f62e:	f7fa fd5f 	bl	2a0f0 <L2cMasterInit>

   AttHandlerInit(WsfOsSetNextHandler(AttHandler));
   2f632:	4817      	ldr	r0, [pc, #92]	; (2f690 <ble_stack_init+0xfc>)
   2f634:	f7fd fe9a 	bl	2d36c <WsfOsSetNextHandler>
   2f638:	4603      	mov	r3, r0
   2f63a:	4618      	mov	r0, r3
   2f63c:	f7ee f9e4 	bl	1da08 <AttHandlerInit>
   AttsInit();
   2f640:	f7f0 fc7e 	bl	1ff40 <AttsInit>
   AttsIndInit();
   2f644:	f7f0 f966 	bl	1f914 <AttsIndInit>
   AttcInit();
   2f648:	f7ee fec6 	bl	1e3d8 <AttcInit>
   HciSetMaxRxAclLen(251);
   2f64c:	20fb      	movs	r0, #251	; 0xfb
   2f64e:	f7f6 fda1 	bl	26194 <HciSetMaxRxAclLen>

   AppHandlerInit(WsfOsSetNextHandler(AppHandler));
   2f652:	4810      	ldr	r0, [pc, #64]	; (2f694 <ble_stack_init+0x100>)
   2f654:	f7fd fe8a 	bl	2d36c <WsfOsSetNextHandler>
   2f658:	4603      	mov	r3, r0
   2f65a:	4618      	mov	r0, r3
   2f65c:	f7eb fd86 	bl	1b16c <AppHandlerInit>
   HciDrvHandlerInit(WsfOsSetNextHandler(HciDrvHandler));
   2f660:	480d      	ldr	r0, [pc, #52]	; (2f698 <ble_stack_init+0x104>)
   2f662:	f7fd fe83 	bl	2d36c <WsfOsSetNextHandler>
   2f666:	4603      	mov	r3, r0
   2f668:	4618      	mov	r0, r3
   2f66a:	f7f7 fa55 	bl	26b18 <HciDrvHandlerInit>
}
   2f66e:	bf00      	nop
   2f670:	3708      	adds	r7, #8
   2f672:	46bd      	mov	sp, r7
   2f674:	bd80      	pop	{r7, pc}
   2f676:	bf00      	nop
   2f678:	10002cf0 	.word	0x10002cf0
   2f67c:	10008a9c 	.word	0x10008a9c
   2f680:	0004582c 	.word	0x0004582c
   2f684:	000290ad 	.word	0x000290ad
   2f688:	00023e8d 	.word	0x00023e8d
   2f68c:	0002a461 	.word	0x0002a461
   2f690:	0001da55 	.word	0x0001da55
   2f694:	0001b18d 	.word	0x0001b18d
   2f698:	00026b39 	.word	0x00026b39

0002f69c <BLETask>:


// Public API Functions ------------------------------------------------------------------------------------------------

void BLETask(void *params)
{
   2f69c:	b580      	push	{r7, lr}
   2f69e:	b082      	sub	sp, #8
   2f6a0:	af00      	add	r7, sp, #0
   2f6a2:	6078      	str	r0, [r7, #4]
   // Initialize the BLE stack and start the BLE profile
   ble_stack_init();
   2f6a4:	f7ff ff76 	bl	2f594 <ble_stack_init>
   bluetooth_start();
   2f6a8:	f7fe fec2 	bl	2e430 <bluetooth_start>

   // Loop forever handling BLE events
   while (true)
      wsfOsDispatcher();
   2f6ac:	f7fd fea2 	bl	2d3f4 <wsfOsDispatcher>
   2f6b0:	e7fc      	b.n	2f6ac <BLETask+0x10>
	...

0002f6b4 <deviceInfoAddGroup>:


// Public API ----------------------------------------------------------------------------------------------------------

void deviceInfoAddGroup(void)
{
   2f6b4:	b580      	push	{r7, lr}
   2f6b6:	af00      	add	r7, sp, #0
   AttsAddGroup(&deviceInfoGroup);
   2f6b8:	4802      	ldr	r0, [pc, #8]	; (2f6c4 <deviceInfoAddGroup+0x10>)
   2f6ba:	f7f0 fd43 	bl	20144 <AttsAddGroup>
}
   2f6be:	bf00      	nop
   2f6c0:	bd80      	pop	{r7, pc}
   2f6c2:	bf00      	nop
   2f6c4:	10002d04 	.word	0x10002d04

0002f6c8 <SvcCoreGapCentAddrResUpdate>:
   }
};

static attsGroup_t gattGroup = { 0, (attsAttr_t*)gattList, 0, 0, GATT_SERVICE_HANDLE, GATT_MAX_HANDLE-1 };

void SvcCoreGapCentAddrResUpdate(bool_t value) { gapCentralAddrRes[0] = value; }
   2f6c8:	b480      	push	{r7}
   2f6ca:	b083      	sub	sp, #12
   2f6cc:	af00      	add	r7, sp, #0
   2f6ce:	4603      	mov	r3, r0
   2f6d0:	71fb      	strb	r3, [r7, #7]
   2f6d2:	4a04      	ldr	r2, [pc, #16]	; (2f6e4 <SvcCoreGapCentAddrResUpdate+0x1c>)
   2f6d4:	79fb      	ldrb	r3, [r7, #7]
   2f6d6:	7013      	strb	r3, [r2, #0]
   2f6d8:	bf00      	nop
   2f6da:	370c      	adds	r7, #12
   2f6dc:	46bd      	mov	sp, r7
   2f6de:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f6e2:	4770      	bx	lr
   2f6e4:	10009c38 	.word	0x10009c38

0002f6e8 <gapGattAddGroup>:


// Public API ----------------------------------------------------------------------------------------------------------

void gapGattAddGroup(void)
{
   2f6e8:	b580      	push	{r7, lr}
   2f6ea:	af00      	add	r7, sp, #0
   AttsAddGroup(&gapGroup);
   2f6ec:	4803      	ldr	r0, [pc, #12]	; (2f6fc <gapGattAddGroup+0x14>)
   2f6ee:	f7f0 fd29 	bl	20144 <AttsAddGroup>
   AttsAddGroup(&gattGroup);
   2f6f2:	4803      	ldr	r0, [pc, #12]	; (2f700 <gapGattAddGroup+0x18>)
   2f6f4:	f7f0 fd26 	bl	20144 <AttsAddGroup>
}
   2f6f8:	bf00      	nop
   2f6fa:	bd80      	pop	{r7, pc}
   2f6fc:	10002d18 	.word	0x10002d18
   2f700:	10002d2c 	.word	0x10002d2c

0002f704 <gapGattRegisterCallbacks>:

void gapGattRegisterCallbacks(attsReadCback_t readCallback, attsWriteCback_t writeCallback)
{
   2f704:	b480      	push	{r7}
   2f706:	b083      	sub	sp, #12
   2f708:	af00      	add	r7, sp, #0
   2f70a:	6078      	str	r0, [r7, #4]
   2f70c:	6039      	str	r1, [r7, #0]
   gattGroup.readCback = readCallback;
   2f70e:	4a06      	ldr	r2, [pc, #24]	; (2f728 <gapGattRegisterCallbacks+0x24>)
   2f710:	687b      	ldr	r3, [r7, #4]
   2f712:	6093      	str	r3, [r2, #8]
   gattGroup.writeCback = writeCallback;
   2f714:	4a04      	ldr	r2, [pc, #16]	; (2f728 <gapGattRegisterCallbacks+0x24>)
   2f716:	683b      	ldr	r3, [r7, #0]
   2f718:	60d3      	str	r3, [r2, #12]
}
   2f71a:	bf00      	nop
   2f71c:	370c      	adds	r7, #12
   2f71e:	46bd      	mov	sp, r7
   2f720:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f724:	4770      	bx	lr
   2f726:	bf00      	nop
   2f728:	10002d2c 	.word	0x10002d2c

0002f72c <handleLiveStatsRead>:


// Public API ----------------------------------------------------------------------------------------------------------

uint8_t handleLiveStatsRead(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, attsAttr_t *pAttr)
{
   2f72c:	b590      	push	{r4, r7, lr}
   2f72e:	b083      	sub	sp, #12
   2f730:	af00      	add	r7, sp, #0
   2f732:	4604      	mov	r4, r0
   2f734:	4608      	mov	r0, r1
   2f736:	4611      	mov	r1, r2
   2f738:	461a      	mov	r2, r3
   2f73a:	4623      	mov	r3, r4
   2f73c:	71fb      	strb	r3, [r7, #7]
   2f73e:	4603      	mov	r3, r0
   2f740:	80bb      	strh	r3, [r7, #4]
   2f742:	460b      	mov	r3, r1
   2f744:	71bb      	strb	r3, [r7, #6]
   2f746:	4613      	mov	r3, r2
   2f748:	807b      	strh	r3, [r7, #2]
   print("TotTag BLE: Live Stats Read: connID = %d, handle = %d, operation = %d\n", connId, handle, operation);
   2f74a:	79f9      	ldrb	r1, [r7, #7]
   2f74c:	88ba      	ldrh	r2, [r7, #4]
   2f74e:	79bb      	ldrb	r3, [r7, #6]
   2f750:	480d      	ldr	r0, [pc, #52]	; (2f788 <handleLiveStatsRead+0x5c>)
   2f752:	f7eb fa25 	bl	1aba0 <am_util_stdio_printf>
   if (handle == BATTERY_LEVEL_HANDLE)
   2f756:	88bb      	ldrh	r3, [r7, #4]
   2f758:	2b42      	cmp	r3, #66	; 0x42
   2f75a:	d107      	bne.n	2f76c <handleLiveStatsRead+0x40>
      *(uint16_t*)pAttr->pValue = (uint16_t)battery_monitor_get_level_mV();
   2f75c:	f7fe fa54 	bl	2dc08 <battery_monitor_get_level_mV>
   2f760:	4602      	mov	r2, r0
   2f762:	69bb      	ldr	r3, [r7, #24]
   2f764:	685b      	ldr	r3, [r3, #4]
   2f766:	b292      	uxth	r2, r2
   2f768:	801a      	strh	r2, [r3, #0]
   2f76a:	e008      	b.n	2f77e <handleLiveStatsRead+0x52>
   else if (handle == TIMESTAMP_HANDLE)
   2f76c:	88bb      	ldrh	r3, [r7, #4]
   2f76e:	2b45      	cmp	r3, #69	; 0x45
   2f770:	d105      	bne.n	2f77e <handleLiveStatsRead+0x52>
      *(uint32_t*)pAttr->pValue = rtc_get_timestamp();
   2f772:	69bb      	ldr	r3, [r7, #24]
   2f774:	685c      	ldr	r4, [r3, #4]
   2f776:	f7ff f8d5 	bl	2e924 <rtc_get_timestamp>
   2f77a:	4603      	mov	r3, r0
   2f77c:	6023      	str	r3, [r4, #0]
   return ATT_SUCCESS;
   2f77e:	2300      	movs	r3, #0
}
   2f780:	4618      	mov	r0, r3
   2f782:	370c      	adds	r7, #12
   2f784:	46bd      	mov	sp, r7
   2f786:	bd90      	pop	{r4, r7, pc}
   2f788:	00045854 	.word	0x00045854

0002f78c <handleLiveStatsWrite>:

uint8_t handleLiveStatsWrite(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, uint16_t len, uint8_t *pValue, attsAttr_t *pAttr)
{
   2f78c:	b590      	push	{r4, r7, lr}
   2f78e:	b083      	sub	sp, #12
   2f790:	af00      	add	r7, sp, #0
   2f792:	4604      	mov	r4, r0
   2f794:	4608      	mov	r0, r1
   2f796:	4611      	mov	r1, r2
   2f798:	461a      	mov	r2, r3
   2f79a:	4623      	mov	r3, r4
   2f79c:	71fb      	strb	r3, [r7, #7]
   2f79e:	4603      	mov	r3, r0
   2f7a0:	80bb      	strh	r3, [r7, #4]
   2f7a2:	460b      	mov	r3, r1
   2f7a4:	71bb      	strb	r3, [r7, #6]
   2f7a6:	4613      	mov	r3, r2
   2f7a8:	807b      	strh	r3, [r7, #2]
   print("TotTag BLE: Live Stats Write: connID = %d handle = %d, value = %d\n", connId, handle, *pValue);
   2f7aa:	79f9      	ldrb	r1, [r7, #7]
   2f7ac:	88ba      	ldrh	r2, [r7, #4]
   2f7ae:	69fb      	ldr	r3, [r7, #28]
   2f7b0:	781b      	ldrb	r3, [r3, #0]
   2f7b2:	480c      	ldr	r0, [pc, #48]	; (2f7e4 <handleLiveStatsWrite+0x58>)
   2f7b4:	f7eb f9f4 	bl	1aba0 <am_util_stdio_printf>
   if (handle == FIND_MY_TOTTAG_HANDLE)
   2f7b8:	88bb      	ldrh	r3, [r7, #4]
   2f7ba:	2b48      	cmp	r3, #72	; 0x48
   2f7bc:	d105      	bne.n	2f7ca <handleLiveStatsWrite+0x3e>
      app_activate_find_my_tottag(*(uint32_t*)pValue);
   2f7be:	69fb      	ldr	r3, [r7, #28]
   2f7c0:	681b      	ldr	r3, [r3, #0]
   2f7c2:	4618      	mov	r0, r3
   2f7c4:	f7ff feca 	bl	2f55c <app_activate_find_my_tottag>
   2f7c8:	e007      	b.n	2f7da <handleLiveStatsWrite+0x4e>
   else if (handle == TIMESTAMP_HANDLE)
   2f7ca:	88bb      	ldrh	r3, [r7, #4]
   2f7cc:	2b45      	cmp	r3, #69	; 0x45
   2f7ce:	d104      	bne.n	2f7da <handleLiveStatsWrite+0x4e>
      rtc_set_time_from_timestamp(*(uint32_t*)pValue);
   2f7d0:	69fb      	ldr	r3, [r7, #28]
   2f7d2:	681b      	ldr	r3, [r3, #0]
   2f7d4:	4618      	mov	r0, r3
   2f7d6:	f7ff f88c 	bl	2e8f2 <rtc_set_time_from_timestamp>
   return ATT_SUCCESS;
   2f7da:	2300      	movs	r3, #0
}
   2f7dc:	4618      	mov	r0, r3
   2f7de:	370c      	adds	r7, #12
   2f7e0:	46bd      	mov	sp, r7
   2f7e2:	bd90      	pop	{r4, r7, pc}
   2f7e4:	0004589c 	.word	0x0004589c

0002f7e8 <liveStatsAddGroup>:


// Public API ----------------------------------------------------------------------------------------------------------

void liveStatsAddGroup(void)
{
   2f7e8:	b580      	push	{r7, lr}
   2f7ea:	af00      	add	r7, sp, #0
   AttsAddGroup(&liveStatsGroup);
   2f7ec:	4802      	ldr	r0, [pc, #8]	; (2f7f8 <liveStatsAddGroup+0x10>)
   2f7ee:	f7f0 fca9 	bl	20144 <AttsAddGroup>
}
   2f7f2:	bf00      	nop
   2f7f4:	bd80      	pop	{r7, pc}
   2f7f6:	bf00      	nop
   2f7f8:	10002d40 	.word	0x10002d40

0002f7fc <liveStatsRegisterCallbacks>:

void liveStatsRegisterCallbacks(attsReadCback_t readCallback, attsWriteCback_t writeCallback)
{
   2f7fc:	b480      	push	{r7}
   2f7fe:	b083      	sub	sp, #12
   2f800:	af00      	add	r7, sp, #0
   2f802:	6078      	str	r0, [r7, #4]
   2f804:	6039      	str	r1, [r7, #0]
   liveStatsGroup.readCback = readCallback;
   2f806:	4a06      	ldr	r2, [pc, #24]	; (2f820 <liveStatsRegisterCallbacks+0x24>)
   2f808:	687b      	ldr	r3, [r7, #4]
   2f80a:	6093      	str	r3, [r2, #8]
   liveStatsGroup.writeCback = writeCallback;
   2f80c:	4a04      	ldr	r2, [pc, #16]	; (2f820 <liveStatsRegisterCallbacks+0x24>)
   2f80e:	683b      	ldr	r3, [r7, #0]
   2f810:	60d3      	str	r3, [r2, #12]
}
   2f812:	bf00      	nop
   2f814:	370c      	adds	r7, #12
   2f816:	46bd      	mov	sp, r7
   2f818:	f85d 7b04 	ldr.w	r7, [sp], #4
   2f81c:	4770      	bx	lr
   2f81e:	bf00      	nop
   2f820:	10002d40 	.word	0x10002d40

0002f824 <handleDeviceMaintenanceRead>:


// Public API ----------------------------------------------------------------------------------------------------------

uint8_t handleDeviceMaintenanceRead(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, attsAttr_t *pAttr)
{
   2f824:	b590      	push	{r4, r7, lr}
   2f826:	b083      	sub	sp, #12
   2f828:	af00      	add	r7, sp, #0
   2f82a:	4604      	mov	r4, r0
   2f82c:	4608      	mov	r0, r1
   2f82e:	4611      	mov	r1, r2
   2f830:	461a      	mov	r2, r3
   2f832:	4623      	mov	r3, r4
   2f834:	71fb      	strb	r3, [r7, #7]
   2f836:	4603      	mov	r3, r0
   2f838:	80bb      	strh	r3, [r7, #4]
   2f83a:	460b      	mov	r3, r1
   2f83c:	71bb      	strb	r3, [r7, #6]
   2f83e:	4613      	mov	r3, r2
   2f840:	807b      	strh	r3, [r7, #2]
   print("TotTag BLE: Device Maintenance Read: connID = %d, handle = %d, operation = %d\n", connId, handle, operation);
   2f842:	79f9      	ldrb	r1, [r7, #7]
   2f844:	88ba      	ldrh	r2, [r7, #4]
   2f846:	79bb      	ldrb	r3, [r7, #6]
   2f848:	4807      	ldr	r0, [pc, #28]	; (2f868 <handleDeviceMaintenanceRead+0x44>)
   2f84a:	f7eb f9a9 	bl	1aba0 <am_util_stdio_printf>
   if (handle == MAINTENANCE_EXPERIMENT_HANDLE)
   2f84e:	88bb      	ldrh	r3, [r7, #4]
   2f850:	2b72      	cmp	r3, #114	; 0x72
   2f852:	d104      	bne.n	2f85e <handleDeviceMaintenanceRead+0x3a>
      storage_retrieve_experiment_details((experiment_details_t*)pAttr->pValue);
   2f854:	69bb      	ldr	r3, [r7, #24]
   2f856:	685b      	ldr	r3, [r3, #4]
   2f858:	4618      	mov	r0, r3
   2f85a:	f7ff fc05 	bl	2f068 <storage_retrieve_experiment_details>
   return ATT_SUCCESS;
   2f85e:	2300      	movs	r3, #0
}
   2f860:	4618      	mov	r0, r3
   2f862:	370c      	adds	r7, #12
   2f864:	46bd      	mov	sp, r7
   2f866:	bd90      	pop	{r4, r7, pc}
   2f868:	000458e0 	.word	0x000458e0

0002f86c <handleDeviceMaintenanceWrite>:

uint8_t handleDeviceMaintenanceWrite(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, uint16_t len, uint8_t *pValue, attsAttr_t *pAttr)
{
   2f86c:	b590      	push	{r4, r7, lr}
   2f86e:	b0c1      	sub	sp, #260	; 0x104
   2f870:	af00      	add	r7, sp, #0
   2f872:	4604      	mov	r4, r0
   2f874:	4608      	mov	r0, r1
   2f876:	4611      	mov	r1, r2
   2f878:	461a      	mov	r2, r3
   2f87a:	4623      	mov	r3, r4
   2f87c:	71fb      	strb	r3, [r7, #7]
   2f87e:	4603      	mov	r3, r0
   2f880:	80bb      	strh	r3, [r7, #4]
   2f882:	460b      	mov	r3, r1
   2f884:	71bb      	strb	r3, [r7, #6]
   2f886:	4613      	mov	r3, r2
   2f888:	807b      	strh	r3, [r7, #2]
   // Handle the incoming BLE request
   print("TotTag BLE: Device Maintenance Write: connID = %d handle = %d, value = %d\n", connId, handle, *pValue);
   2f88a:	79f9      	ldrb	r1, [r7, #7]
   2f88c:	88ba      	ldrh	r2, [r7, #4]
   2f88e:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2f892:	781b      	ldrb	r3, [r3, #0]
   2f894:	481b      	ldr	r0, [pc, #108]	; (2f904 <handleDeviceMaintenanceWrite+0x98>)
   2f896:	f7eb f983 	bl	1aba0 <am_util_stdio_printf>
   if (handle == MAINTENANCE_COMMAND_HANDLE)
   2f89a:	88bb      	ldrh	r3, [r7, #4]
   2f89c:	2b75      	cmp	r3, #117	; 0x75
   2f89e:	d128      	bne.n	2f8f2 <handleDeviceMaintenanceWrite+0x86>
      switch (*pValue)
   2f8a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2f8a4:	781b      	ldrb	r3, [r3, #0]
   2f8a6:	2b03      	cmp	r3, #3
   2f8a8:	d01d      	beq.n	2f8e6 <handleDeviceMaintenanceWrite+0x7a>
   2f8aa:	2b03      	cmp	r3, #3
   2f8ac:	dc23      	bgt.n	2f8f6 <handleDeviceMaintenanceWrite+0x8a>
   2f8ae:	2b01      	cmp	r3, #1
   2f8b0:	d002      	beq.n	2f8b8 <handleDeviceMaintenanceWrite+0x4c>
   2f8b2:	2b02      	cmp	r3, #2
   2f8b4:	d00a      	beq.n	2f8cc <handleDeviceMaintenanceWrite+0x60>
         }
         case BLE_MAINTENANCE_DOWNLOAD_LOG:
            continueSendingLogData(connId, 0);
            break;
         default:
            break;
   2f8b6:	e01e      	b.n	2f8f6 <handleDeviceMaintenanceWrite+0x8a>
            const experiment_details_t* new_details = (const experiment_details_t*)(pValue + 1);
   2f8b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
   2f8bc:	3301      	adds	r3, #1
   2f8be:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
            storage_store_experiment_details(new_details);
   2f8c2:	f8d7 00fc 	ldr.w	r0, [r7, #252]	; 0xfc
   2f8c6:	f7ff fb1d 	bl	2ef04 <storage_store_experiment_details>
            break;
   2f8ca:	e015      	b.n	2f8f8 <handleDeviceMaintenanceWrite+0x8c>
            const experiment_details_t empty_details = { 0 };
   2f8cc:	f107 030c 	add.w	r3, r7, #12
   2f8d0:	22ed      	movs	r2, #237	; 0xed
   2f8d2:	2100      	movs	r1, #0
   2f8d4:	4618      	mov	r0, r3
   2f8d6:	f000 fc0b 	bl	300f0 <memset>
            storage_store_experiment_details(&empty_details);
   2f8da:	f107 030c 	add.w	r3, r7, #12
   2f8de:	4618      	mov	r0, r3
   2f8e0:	f7ff fb10 	bl	2ef04 <storage_store_experiment_details>
            break;
   2f8e4:	e008      	b.n	2f8f8 <handleDeviceMaintenanceWrite+0x8c>
            continueSendingLogData(connId, 0);
   2f8e6:	79fb      	ldrb	r3, [r7, #7]
   2f8e8:	2100      	movs	r1, #0
   2f8ea:	4618      	mov	r0, r3
   2f8ec:	f000 f80c 	bl	2f908 <continueSendingLogData>
            break;
   2f8f0:	e002      	b.n	2f8f8 <handleDeviceMaintenanceWrite+0x8c>
   }
   return ATT_SUCCESS;
   2f8f2:	bf00      	nop
   2f8f4:	e000      	b.n	2f8f8 <handleDeviceMaintenanceWrite+0x8c>
            break;
   2f8f6:	bf00      	nop
   return ATT_SUCCESS;
   2f8f8:	2300      	movs	r3, #0
}
   2f8fa:	4618      	mov	r0, r3
   2f8fc:	f507 7782 	add.w	r7, r7, #260	; 0x104
   2f900:	46bd      	mov	sp, r7
   2f902:	bd90      	pop	{r4, r7, pc}
   2f904:	00045930 	.word	0x00045930

0002f908 <continueSendingLogData>:

void continueSendingLogData(dmConnId_t connId, uint16_t max_length)
{
   2f908:	b580      	push	{r7, lr}
   2f90a:	b0be      	sub	sp, #248	; 0xf8
   2f90c:	af00      	add	r7, sp, #0
   2f90e:	4603      	mov	r3, r0
   2f910:	460a      	mov	r2, r1
   2f912:	71fb      	strb	r3, [r7, #7]
   2f914:	4613      	mov	r3, r2
   2f916:	80bb      	strh	r3, [r7, #4]
   static uint8_t transmit_buffer[2 * MEMORY_PAGE_SIZE_BYTES];
   static uint32_t transmit_index, total_data_length;
   static uint16_t buffer_index, buffer_length;

   // Determine whether this is a new transmission or a continuation
   if (max_length == 0)
   2f918:	88bb      	ldrh	r3, [r7, #4]
   2f91a:	2b00      	cmp	r3, #0
   2f91c:	d126      	bne.n	2f96c <continueSendingLogData+0x64>
   {
      // Reset all transmission variables and send total data length
      storage_begin_reading();
   2f91e:	f000 f989 	bl	2fc34 <storage_begin_reading>
      experiment_details_t details;
      transmit_index = buffer_index = 0;
   2f922:	4b50      	ldr	r3, [pc, #320]	; (2fa64 <continueSendingLogData+0x15c>)
   2f924:	2200      	movs	r2, #0
   2f926:	801a      	strh	r2, [r3, #0]
   2f928:	4b4f      	ldr	r3, [pc, #316]	; (2fa68 <continueSendingLogData+0x160>)
   2f92a:	2200      	movs	r2, #0
   2f92c:	601a      	str	r2, [r3, #0]
      storage_retrieve_experiment_details(&details);
   2f92e:	f107 0308 	add.w	r3, r7, #8
   2f932:	4618      	mov	r0, r3
   2f934:	f7ff fb98 	bl	2f068 <storage_retrieve_experiment_details>
      total_data_length = storage_retrieve_data_length();
   2f938:	f000 f9cc 	bl	2fcd4 <storage_retrieve_data_length>
   2f93c:	4603      	mov	r3, r0
   2f93e:	4a4b      	ldr	r2, [pc, #300]	; (2fa6c <continueSendingLogData+0x164>)
   2f940:	6013      	str	r3, [r2, #0]
      buffer_length = (uint16_t)storage_retrieve_next_data_chunk(transmit_buffer);
   2f942:	484b      	ldr	r0, [pc, #300]	; (2fa70 <continueSendingLogData+0x168>)
   2f944:	f000 f9d0 	bl	2fce8 <storage_retrieve_next_data_chunk>
   2f948:	4603      	mov	r3, r0
   2f94a:	b29a      	uxth	r2, r3
   2f94c:	4b49      	ldr	r3, [pc, #292]	; (2fa74 <continueSendingLogData+0x16c>)
   2f94e:	801a      	strh	r2, [r3, #0]
      AttsHandleValueNtf(connId, MAINTENANCE_RESULT_HANDLE, sizeof(total_data_length), (uint8_t*)&total_data_length);
   2f950:	79f8      	ldrb	r0, [r7, #7]
   2f952:	4b46      	ldr	r3, [pc, #280]	; (2fa6c <continueSendingLogData+0x164>)
   2f954:	2204      	movs	r2, #4
   2f956:	2178      	movs	r1, #120	; 0x78
   2f958:	f7f0 f812 	bl	1f980 <AttsHandleValueNtf>
      AttsHandleValueNtf(connId, MAINTENANCE_RESULT_HANDLE, sizeof(details), (uint8_t*)&details);
   2f95c:	f107 0308 	add.w	r3, r7, #8
   2f960:	79f8      	ldrb	r0, [r7, #7]
   2f962:	22ed      	movs	r2, #237	; 0xed
   2f964:	2178      	movs	r1, #120	; 0x78
   2f966:	f7f0 f80b 	bl	1f980 <AttsHandleValueNtf>
      storage_end_reading();
      uint8_t completion_packet = BLE_MAINTENANCE_PACKET_COMPLETE;
      AttsHandleValueNtf(connId, MAINTENANCE_RESULT_HANDLE, sizeof(completion_packet), &completion_packet);
      ++transmit_index;
   }
}
   2f96a:	e076      	b.n	2fa5a <continueSendingLogData+0x152>
   else if (transmit_index < total_data_length)
   2f96c:	4b3e      	ldr	r3, [pc, #248]	; (2fa68 <continueSendingLogData+0x160>)
   2f96e:	681a      	ldr	r2, [r3, #0]
   2f970:	4b3e      	ldr	r3, [pc, #248]	; (2fa6c <continueSendingLogData+0x164>)
   2f972:	681b      	ldr	r3, [r3, #0]
   2f974:	429a      	cmp	r2, r3
   2f976:	d259      	bcs.n	2fa2c <continueSendingLogData+0x124>
      const uint16_t transmit_length = MIN(max_length, buffer_length - buffer_index);
   2f978:	4b3e      	ldr	r3, [pc, #248]	; (2fa74 <continueSendingLogData+0x16c>)
   2f97a:	881b      	ldrh	r3, [r3, #0]
   2f97c:	461a      	mov	r2, r3
   2f97e:	4b39      	ldr	r3, [pc, #228]	; (2fa64 <continueSendingLogData+0x15c>)
   2f980:	881b      	ldrh	r3, [r3, #0]
   2f982:	1ad2      	subs	r2, r2, r3
   2f984:	88bb      	ldrh	r3, [r7, #4]
   2f986:	4293      	cmp	r3, r2
   2f988:	bfa8      	it	ge
   2f98a:	4613      	movge	r3, r2
   2f98c:	f8a7 30f6 	strh.w	r3, [r7, #246]	; 0xf6
      AttsHandleValueNtf(connId, MAINTENANCE_RESULT_HANDLE, transmit_length, transmit_buffer + buffer_index);
   2f990:	4b34      	ldr	r3, [pc, #208]	; (2fa64 <continueSendingLogData+0x15c>)
   2f992:	881b      	ldrh	r3, [r3, #0]
   2f994:	461a      	mov	r2, r3
   2f996:	4b36      	ldr	r3, [pc, #216]	; (2fa70 <continueSendingLogData+0x168>)
   2f998:	4413      	add	r3, r2
   2f99a:	f8b7 20f6 	ldrh.w	r2, [r7, #246]	; 0xf6
   2f99e:	79f8      	ldrb	r0, [r7, #7]
   2f9a0:	2178      	movs	r1, #120	; 0x78
   2f9a2:	f7ef ffed 	bl	1f980 <AttsHandleValueNtf>
      transmit_index += transmit_length;
   2f9a6:	f8b7 20f6 	ldrh.w	r2, [r7, #246]	; 0xf6
   2f9aa:	4b2f      	ldr	r3, [pc, #188]	; (2fa68 <continueSendingLogData+0x160>)
   2f9ac:	681b      	ldr	r3, [r3, #0]
   2f9ae:	4413      	add	r3, r2
   2f9b0:	4a2d      	ldr	r2, [pc, #180]	; (2fa68 <continueSendingLogData+0x160>)
   2f9b2:	6013      	str	r3, [r2, #0]
      buffer_index += transmit_length;
   2f9b4:	4b2b      	ldr	r3, [pc, #172]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9b6:	881a      	ldrh	r2, [r3, #0]
   2f9b8:	f8b7 30f6 	ldrh.w	r3, [r7, #246]	; 0xf6
   2f9bc:	4413      	add	r3, r2
   2f9be:	b29a      	uxth	r2, r3
   2f9c0:	4b28      	ldr	r3, [pc, #160]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9c2:	801a      	strh	r2, [r3, #0]
      if ((buffer_length - buffer_index) < max_length)
   2f9c4:	4b2b      	ldr	r3, [pc, #172]	; (2fa74 <continueSendingLogData+0x16c>)
   2f9c6:	881b      	ldrh	r3, [r3, #0]
   2f9c8:	461a      	mov	r2, r3
   2f9ca:	4b26      	ldr	r3, [pc, #152]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9cc:	881b      	ldrh	r3, [r3, #0]
   2f9ce:	1ad2      	subs	r2, r2, r3
   2f9d0:	88bb      	ldrh	r3, [r7, #4]
   2f9d2:	429a      	cmp	r2, r3
   2f9d4:	da41      	bge.n	2fa5a <continueSendingLogData+0x152>
         memmove(transmit_buffer, transmit_buffer + buffer_index, buffer_length - buffer_index);
   2f9d6:	4b23      	ldr	r3, [pc, #140]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9d8:	881b      	ldrh	r3, [r3, #0]
   2f9da:	461a      	mov	r2, r3
   2f9dc:	4b24      	ldr	r3, [pc, #144]	; (2fa70 <continueSendingLogData+0x168>)
   2f9de:	4413      	add	r3, r2
   2f9e0:	4a24      	ldr	r2, [pc, #144]	; (2fa74 <continueSendingLogData+0x16c>)
   2f9e2:	8812      	ldrh	r2, [r2, #0]
   2f9e4:	4611      	mov	r1, r2
   2f9e6:	4a1f      	ldr	r2, [pc, #124]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9e8:	8812      	ldrh	r2, [r2, #0]
   2f9ea:	1a8a      	subs	r2, r1, r2
   2f9ec:	4619      	mov	r1, r3
   2f9ee:	4820      	ldr	r0, [pc, #128]	; (2fa70 <continueSendingLogData+0x168>)
   2f9f0:	f000 fb12 	bl	30018 <memmove>
         buffer_length -= buffer_index;
   2f9f4:	4b1f      	ldr	r3, [pc, #124]	; (2fa74 <continueSendingLogData+0x16c>)
   2f9f6:	881a      	ldrh	r2, [r3, #0]
   2f9f8:	4b1a      	ldr	r3, [pc, #104]	; (2fa64 <continueSendingLogData+0x15c>)
   2f9fa:	881b      	ldrh	r3, [r3, #0]
   2f9fc:	1ad3      	subs	r3, r2, r3
   2f9fe:	b29a      	uxth	r2, r3
   2fa00:	4b1c      	ldr	r3, [pc, #112]	; (2fa74 <continueSendingLogData+0x16c>)
   2fa02:	801a      	strh	r2, [r3, #0]
         buffer_length += (uint16_t)storage_retrieve_next_data_chunk(transmit_buffer + buffer_length);
   2fa04:	4b1b      	ldr	r3, [pc, #108]	; (2fa74 <continueSendingLogData+0x16c>)
   2fa06:	881b      	ldrh	r3, [r3, #0]
   2fa08:	461a      	mov	r2, r3
   2fa0a:	4b19      	ldr	r3, [pc, #100]	; (2fa70 <continueSendingLogData+0x168>)
   2fa0c:	4413      	add	r3, r2
   2fa0e:	4618      	mov	r0, r3
   2fa10:	f000 f96a 	bl	2fce8 <storage_retrieve_next_data_chunk>
   2fa14:	4603      	mov	r3, r0
   2fa16:	b29a      	uxth	r2, r3
   2fa18:	4b16      	ldr	r3, [pc, #88]	; (2fa74 <continueSendingLogData+0x16c>)
   2fa1a:	881b      	ldrh	r3, [r3, #0]
   2fa1c:	4413      	add	r3, r2
   2fa1e:	b29a      	uxth	r2, r3
   2fa20:	4b14      	ldr	r3, [pc, #80]	; (2fa74 <continueSendingLogData+0x16c>)
   2fa22:	801a      	strh	r2, [r3, #0]
         buffer_index = 0;
   2fa24:	4b0f      	ldr	r3, [pc, #60]	; (2fa64 <continueSendingLogData+0x15c>)
   2fa26:	2200      	movs	r2, #0
   2fa28:	801a      	strh	r2, [r3, #0]
}
   2fa2a:	e016      	b.n	2fa5a <continueSendingLogData+0x152>
   else if (transmit_index == total_data_length)
   2fa2c:	4b0e      	ldr	r3, [pc, #56]	; (2fa68 <continueSendingLogData+0x160>)
   2fa2e:	681a      	ldr	r2, [r3, #0]
   2fa30:	4b0e      	ldr	r3, [pc, #56]	; (2fa6c <continueSendingLogData+0x164>)
   2fa32:	681b      	ldr	r3, [r3, #0]
   2fa34:	429a      	cmp	r2, r3
   2fa36:	d110      	bne.n	2fa5a <continueSendingLogData+0x152>
      storage_end_reading();
   2fa38:	f000 f940 	bl	2fcbc <storage_end_reading>
      uint8_t completion_packet = BLE_MAINTENANCE_PACKET_COMPLETE;
   2fa3c:	23ff      	movs	r3, #255	; 0xff
   2fa3e:	f887 30f5 	strb.w	r3, [r7, #245]	; 0xf5
      AttsHandleValueNtf(connId, MAINTENANCE_RESULT_HANDLE, sizeof(completion_packet), &completion_packet);
   2fa42:	f107 03f5 	add.w	r3, r7, #245	; 0xf5
   2fa46:	79f8      	ldrb	r0, [r7, #7]
   2fa48:	2201      	movs	r2, #1
   2fa4a:	2178      	movs	r1, #120	; 0x78
   2fa4c:	f7ef ff98 	bl	1f980 <AttsHandleValueNtf>
      ++transmit_index;
   2fa50:	4b05      	ldr	r3, [pc, #20]	; (2fa68 <continueSendingLogData+0x160>)
   2fa52:	681b      	ldr	r3, [r3, #0]
   2fa54:	3301      	adds	r3, #1
   2fa56:	4a04      	ldr	r2, [pc, #16]	; (2fa68 <continueSendingLogData+0x160>)
   2fa58:	6013      	str	r3, [r2, #0]
}
   2fa5a:	bf00      	nop
   2fa5c:	37f8      	adds	r7, #248	; 0xf8
   2fa5e:	46bd      	mov	sp, r7
   2fa60:	bd80      	pop	{r7, pc}
   2fa62:	bf00      	nop
   2fa64:	10009c66 	.word	0x10009c66
   2fa68:	10009c68 	.word	0x10009c68
   2fa6c:	10009c6c 	.word	0x10009c6c
   2fa70:	10009c70 	.word	0x10009c70
   2fa74:	1000ac70 	.word	0x1000ac70

0002fa78 <deviceMaintenanceAddGroup>:


// Public API ----------------------------------------------------------------------------------------------------------

void deviceMaintenanceAddGroup(void)
{
   2fa78:	b580      	push	{r7, lr}
   2fa7a:	af00      	add	r7, sp, #0
   AttsAddGroup(&maintenanceGroup);
   2fa7c:	4802      	ldr	r0, [pc, #8]	; (2fa88 <deviceMaintenanceAddGroup+0x10>)
   2fa7e:	f7f0 fb61 	bl	20144 <AttsAddGroup>
}
   2fa82:	bf00      	nop
   2fa84:	bd80      	pop	{r7, pc}
   2fa86:	bf00      	nop
   2fa88:	10002d54 	.word	0x10002d54

0002fa8c <deviceMaintenanceRegisterCallbacks>:

void deviceMaintenanceRegisterCallbacks(attsReadCback_t readCallback, attsWriteCback_t writeCallback)
{
   2fa8c:	b480      	push	{r7}
   2fa8e:	b083      	sub	sp, #12
   2fa90:	af00      	add	r7, sp, #0
   2fa92:	6078      	str	r0, [r7, #4]
   2fa94:	6039      	str	r1, [r7, #0]
   maintenanceGroup.readCback = readCallback;
   2fa96:	4a06      	ldr	r2, [pc, #24]	; (2fab0 <deviceMaintenanceRegisterCallbacks+0x24>)
   2fa98:	687b      	ldr	r3, [r7, #4]
   2fa9a:	6093      	str	r3, [r2, #8]
   maintenanceGroup.writeCback = writeCallback;
   2fa9c:	4a04      	ldr	r2, [pc, #16]	; (2fab0 <deviceMaintenanceRegisterCallbacks+0x24>)
   2fa9e:	683b      	ldr	r3, [r7, #0]
   2faa0:	60d3      	str	r3, [r2, #12]
}
   2faa2:	bf00      	nop
   2faa4:	370c      	adds	r7, #12
   2faa6:	46bd      	mov	sp, r7
   2faa8:	f85d 7b04 	ldr.w	r7, [sp], #4
   2faac:	4770      	bx	lr
   2faae:	bf00      	nop
   2fab0:	10002d54 	.word	0x10002d54

0002fab4 <am_timer02_isr>:


// Interrupt Service Routines and Callbacks ----------------------------------------------------------------------------

void am_timer02_isr(void)
{
   2fab4:	b580      	push	{r7, lr}
   2fab6:	b084      	sub	sp, #16
   2fab8:	af02      	add	r7, sp, #8
   // Notify the main task to handle the interrupt
   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   2faba:	2300      	movs	r3, #0
   2fabc:	607b      	str	r3, [r7, #4]
   am_hal_timer_interrupt_clear(AM_HAL_TIMER_MASK(RADIO_WAKEUP_TIMER_NUMBER, AM_HAL_TIMER_COMPARE_BOTH));
   2fabe:	2030      	movs	r0, #48	; 0x30
   2fac0:	f007 f8ea 	bl	36c98 <am_hal_timer_interrupt_clear>
   xTaskNotifyFromISR(notification_handle, RANGING_NEW_ROUND_START, eSetBits, &xHigherPriorityTaskWoken);
   2fac4:	4b0b      	ldr	r3, [pc, #44]	; (2faf4 <am_timer02_isr+0x40>)
   2fac6:	6818      	ldr	r0, [r3, #0]
   2fac8:	1d3b      	adds	r3, r7, #4
   2faca:	9300      	str	r3, [sp, #0]
   2facc:	2300      	movs	r3, #0
   2face:	2201      	movs	r2, #1
   2fad0:	2102      	movs	r1, #2
   2fad2:	f7fc fdbf 	bl	2c654 <xTaskGenericNotifyFromISR>
   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2fad6:	687b      	ldr	r3, [r7, #4]
   2fad8:	2b00      	cmp	r3, #0
   2fada:	d007      	beq.n	2faec <am_timer02_isr+0x38>
   2fadc:	4b06      	ldr	r3, [pc, #24]	; (2faf8 <am_timer02_isr+0x44>)
   2fade:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2fae2:	601a      	str	r2, [r3, #0]
   2fae4:	f3bf 8f4f 	dsb	sy
   2fae8:	f3bf 8f6f 	isb	sy
}
   2faec:	bf00      	nop
   2faee:	3708      	adds	r7, #8
   2faf0:	46bd      	mov	sp, r7
   2faf2:	bd80      	pop	{r7, pc}
   2faf4:	1000ae5c 	.word	0x1000ae5c
   2faf8:	e000ed04 	.word	0xe000ed04

0002fafc <scheduler_rtc_isr>:

void scheduler_rtc_isr(void)
{
   2fafc:	b580      	push	{r7, lr}
   2fafe:	b084      	sub	sp, #16
   2fb00:	af02      	add	r7, sp, #8
   // Notify the main task to handle the interrupt
   BaseType_t xHigherPriorityTaskWoken = pdFALSE;
   2fb02:	2300      	movs	r3, #0
   2fb04:	607b      	str	r3, [r7, #4]
   xTaskNotifyFromISR(notification_handle, RANGING_NEW_ROUND_START, eSetBits, &xHigherPriorityTaskWoken);
   2fb06:	4b0c      	ldr	r3, [pc, #48]	; (2fb38 <scheduler_rtc_isr+0x3c>)
   2fb08:	6818      	ldr	r0, [r3, #0]
   2fb0a:	1d3b      	adds	r3, r7, #4
   2fb0c:	9300      	str	r3, [sp, #0]
   2fb0e:	2300      	movs	r3, #0
   2fb10:	2201      	movs	r2, #1
   2fb12:	2102      	movs	r1, #2
   2fb14:	f7fc fd9e 	bl	2c654 <xTaskGenericNotifyFromISR>
   portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
   2fb18:	687b      	ldr	r3, [r7, #4]
   2fb1a:	2b00      	cmp	r3, #0
   2fb1c:	d007      	beq.n	2fb2e <scheduler_rtc_isr+0x32>
   2fb1e:	4b07      	ldr	r3, [pc, #28]	; (2fb3c <scheduler_rtc_isr+0x40>)
   2fb20:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   2fb24:	601a      	str	r2, [r3, #0]
   2fb26:	f3bf 8f4f 	dsb	sy
   2fb2a:	f3bf 8f6f 	isb	sy
}
   2fb2e:	bf00      	nop
   2fb30:	3708      	adds	r7, #8
   2fb32:	46bd      	mov	sp, r7
   2fb34:	bd80      	pop	{r7, pc}
   2fb36:	bf00      	nop
   2fb38:	1000ae5c 	.word	0x1000ae5c
   2fb3c:	e000ed04 	.word	0xe000ed04

0002fb40 <handleSchedulingRead>:


// Public API ----------------------------------------------------------------------------------------------------------

uint8_t handleSchedulingRead(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, attsAttr_t *pAttr)
{
   2fb40:	b590      	push	{r4, r7, lr}
   2fb42:	b083      	sub	sp, #12
   2fb44:	af00      	add	r7, sp, #0
   2fb46:	4604      	mov	r4, r0
   2fb48:	4608      	mov	r0, r1
   2fb4a:	4611      	mov	r1, r2
   2fb4c:	461a      	mov	r2, r3
   2fb4e:	4623      	mov	r3, r4
   2fb50:	71fb      	strb	r3, [r7, #7]
   2fb52:	4603      	mov	r3, r0
   2fb54:	80bb      	strh	r3, [r7, #4]
   2fb56:	460b      	mov	r3, r1
   2fb58:	71bb      	strb	r3, [r7, #6]
   2fb5a:	4613      	mov	r3, r2
   2fb5c:	807b      	strh	r3, [r7, #2]
   print("TotTag BLE: Scheduling Read: connID = %d, handle = %d, operation = %d\n", connId, handle, operation);
   2fb5e:	79f9      	ldrb	r1, [r7, #7]
   2fb60:	88ba      	ldrh	r2, [r7, #4]
   2fb62:	79bb      	ldrb	r3, [r7, #6]
   2fb64:	4803      	ldr	r0, [pc, #12]	; (2fb74 <handleSchedulingRead+0x34>)
   2fb66:	f7eb f81b 	bl	1aba0 <am_util_stdio_printf>
   return ATT_SUCCESS;
   2fb6a:	2300      	movs	r3, #0
}
   2fb6c:	4618      	mov	r0, r3
   2fb6e:	370c      	adds	r7, #12
   2fb70:	46bd      	mov	sp, r7
   2fb72:	bd90      	pop	{r4, r7, pc}
   2fb74:	0004597c 	.word	0x0004597c

0002fb78 <handleSchedulingWrite>:

uint8_t handleSchedulingWrite(dmConnId_t connId, uint16_t handle, uint8_t operation, uint16_t offset, uint16_t len, uint8_t *pValue, attsAttr_t *pAttr)
{
   2fb78:	b590      	push	{r4, r7, lr}
   2fb7a:	b083      	sub	sp, #12
   2fb7c:	af00      	add	r7, sp, #0
   2fb7e:	4604      	mov	r4, r0
   2fb80:	4608      	mov	r0, r1
   2fb82:	4611      	mov	r1, r2
   2fb84:	461a      	mov	r2, r3
   2fb86:	4623      	mov	r3, r4
   2fb88:	71fb      	strb	r3, [r7, #7]
   2fb8a:	4603      	mov	r3, r0
   2fb8c:	80bb      	strh	r3, [r7, #4]
   2fb8e:	460b      	mov	r3, r1
   2fb90:	71bb      	strb	r3, [r7, #6]
   2fb92:	4613      	mov	r3, r2
   2fb94:	807b      	strh	r3, [r7, #2]
   print("TotTag BLE: Scheduling Write: connID = %d handle = %d, value = %d\n", connId, handle, *pValue);
   2fb96:	79f9      	ldrb	r1, [r7, #7]
   2fb98:	88ba      	ldrh	r2, [r7, #4]
   2fb9a:	69fb      	ldr	r3, [r7, #28]
   2fb9c:	781b      	ldrb	r3, [r3, #0]
   2fb9e:	4807      	ldr	r0, [pc, #28]	; (2fbbc <handleSchedulingWrite+0x44>)
   2fba0:	f7ea fffe 	bl	1aba0 <am_util_stdio_printf>
   if (handle == REQUEST_HANDLE)
   2fba4:	88bb      	ldrh	r3, [r7, #4]
   2fba6:	2b62      	cmp	r3, #98	; 0x62
   2fba8:	d102      	bne.n	2fbb0 <handleSchedulingWrite+0x38>
      app_schedule_device(pValue);
   2fbaa:	69f8      	ldr	r0, [r7, #28]
   2fbac:	f7ff fcb8 	bl	2f520 <app_schedule_device>
   return ATT_SUCCESS;
   2fbb0:	2300      	movs	r3, #0
}
   2fbb2:	4618      	mov	r0, r3
   2fbb4:	370c      	adds	r7, #12
   2fbb6:	46bd      	mov	sp, r7
   2fbb8:	bd90      	pop	{r4, r7, pc}
   2fbba:	bf00      	nop
   2fbbc:	000459c4 	.word	0x000459c4

0002fbc0 <schedulingAddGroup>:


// Public API ----------------------------------------------------------------------------------------------------------

void schedulingAddGroup(void)
{
   2fbc0:	b580      	push	{r7, lr}
   2fbc2:	af00      	add	r7, sp, #0
   AttsAddGroup(&schedulingGroup);
   2fbc4:	4802      	ldr	r0, [pc, #8]	; (2fbd0 <schedulingAddGroup+0x10>)
   2fbc6:	f7f0 fabd 	bl	20144 <AttsAddGroup>
}
   2fbca:	bf00      	nop
   2fbcc:	bd80      	pop	{r7, pc}
   2fbce:	bf00      	nop
   2fbd0:	10002d68 	.word	0x10002d68

0002fbd4 <schedulingRegisterCallbacks>:

void schedulingRegisterCallbacks(attsReadCback_t readCallback, attsWriteCback_t writeCallback)
{
   2fbd4:	b480      	push	{r7}
   2fbd6:	b083      	sub	sp, #12
   2fbd8:	af00      	add	r7, sp, #0
   2fbda:	6078      	str	r0, [r7, #4]
   2fbdc:	6039      	str	r1, [r7, #0]
   schedulingGroup.readCback = readCallback;
   2fbde:	4a06      	ldr	r2, [pc, #24]	; (2fbf8 <schedulingRegisterCallbacks+0x24>)
   2fbe0:	687b      	ldr	r3, [r7, #4]
   2fbe2:	6093      	str	r3, [r2, #8]
   schedulingGroup.writeCback = writeCallback;
   2fbe4:	4a04      	ldr	r2, [pc, #16]	; (2fbf8 <schedulingRegisterCallbacks+0x24>)
   2fbe6:	683b      	ldr	r3, [r7, #0]
   2fbe8:	60d3      	str	r3, [r2, #12]
}
   2fbea:	bf00      	nop
   2fbec:	370c      	adds	r7, #12
   2fbee:	46bd      	mov	sp, r7
   2fbf0:	f85d 7b04 	ldr.w	r7, [sp], #4
   2fbf4:	4770      	bx	lr
   2fbf6:	bf00      	nop
   2fbf8:	10002d68 	.word	0x10002d68

0002fbfc <read_page>:
static uint8_t cache[2 * MEMORY_PAGE_SIZE_BYTES];
static const uint32_t total_size = 2097158;
static bool is_reading;

static void read_page(uint8_t *buffer)
{
   2fbfc:	b480      	push	{r7}
   2fbfe:	b085      	sub	sp, #20
   2fc00:	af00      	add	r7, sp, #0
   2fc02:	6078      	str	r0, [r7, #4]
   for (uint16_t i = 0; i < MEMORY_PAGE_SIZE_BYTES; ++i)
   2fc04:	2300      	movs	r3, #0
   2fc06:	81fb      	strh	r3, [r7, #14]
   2fc08:	e008      	b.n	2fc1c <read_page+0x20>
      buffer[i] = (uint8_t)((((uint32_t)reading_page * MEMORY_PAGE_SIZE_BYTES) + i) & 0xFF);
   2fc0a:	89fb      	ldrh	r3, [r7, #14]
   2fc0c:	687a      	ldr	r2, [r7, #4]
   2fc0e:	4413      	add	r3, r2
   2fc10:	89fa      	ldrh	r2, [r7, #14]
   2fc12:	b2d2      	uxtb	r2, r2
   2fc14:	701a      	strb	r2, [r3, #0]
   for (uint16_t i = 0; i < MEMORY_PAGE_SIZE_BYTES; ++i)
   2fc16:	89fb      	ldrh	r3, [r7, #14]
   2fc18:	3301      	adds	r3, #1
   2fc1a:	81fb      	strh	r3, [r7, #14]
   2fc1c:	89fb      	ldrh	r3, [r7, #14]
   2fc1e:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
   2fc22:	d3f2      	bcc.n	2fc0a <read_page+0xe>
}
   2fc24:	bf00      	nop
   2fc26:	bf00      	nop
   2fc28:	3714      	adds	r7, #20
   2fc2a:	46bd      	mov	sp, r7
   2fc2c:	f85d 7b04 	ldr.w	r7, [sp], #4
   2fc30:	4770      	bx	lr
	...

0002fc34 <storage_begin_reading>:
void storage_begin_reading(void)
{
   2fc34:	b480      	push	{r7}
   2fc36:	b083      	sub	sp, #12
   2fc38:	af00      	add	r7, sp, #0
   reading_page = 0;
   2fc3a:	4b1a      	ldr	r3, [pc, #104]	; (2fca4 <storage_begin_reading+0x70>)
   2fc3c:	2200      	movs	r2, #0
   2fc3e:	801a      	strh	r2, [r3, #0]
   is_reading = true;
   2fc40:	4b19      	ldr	r3, [pc, #100]	; (2fca8 <storage_begin_reading+0x74>)
   2fc42:	2201      	movs	r2, #1
   2fc44:	701a      	strb	r2, [r3, #0]
   cache_index = total_size % MEMORY_PAGE_SIZE_BYTES;
   2fc46:	4b19      	ldr	r3, [pc, #100]	; (2fcac <storage_begin_reading+0x78>)
   2fc48:	b29b      	uxth	r3, r3
   2fc4a:	f3c3 030a 	ubfx	r3, r3, #0, #11
   2fc4e:	b29a      	uxth	r2, r3
   2fc50:	4b17      	ldr	r3, [pc, #92]	; (2fcb0 <storage_begin_reading+0x7c>)
   2fc52:	801a      	strh	r2, [r3, #0]
   final_page = (total_size / MEMORY_PAGE_SIZE_BYTES) + (((total_size % MEMORY_PAGE_SIZE_BYTES) > 0) ? 1 : 0) - 1;
   2fc54:	4b15      	ldr	r3, [pc, #84]	; (2fcac <storage_begin_reading+0x78>)
   2fc56:	0adb      	lsrs	r3, r3, #11
   2fc58:	b29b      	uxth	r3, r3
   2fc5a:	4a14      	ldr	r2, [pc, #80]	; (2fcac <storage_begin_reading+0x78>)
   2fc5c:	f3c2 020a 	ubfx	r2, r2, #0, #11
   2fc60:	2a00      	cmp	r2, #0
   2fc62:	d001      	beq.n	2fc68 <storage_begin_reading+0x34>
   2fc64:	2201      	movs	r2, #1
   2fc66:	e000      	b.n	2fc6a <storage_begin_reading+0x36>
   2fc68:	2200      	movs	r2, #0
   2fc6a:	4413      	add	r3, r2
   2fc6c:	b29b      	uxth	r3, r3
   2fc6e:	3b01      	subs	r3, #1
   2fc70:	b29a      	uxth	r2, r3
   2fc72:	4b10      	ldr	r3, [pc, #64]	; (2fcb4 <storage_begin_reading+0x80>)
   2fc74:	801a      	strh	r2, [r3, #0]
   for (uint16_t i = 0; i < cache_index; ++i)
   2fc76:	2300      	movs	r3, #0
   2fc78:	80fb      	strh	r3, [r7, #6]
   2fc7a:	e007      	b.n	2fc8c <storage_begin_reading+0x58>
      cache[i] = (uint8_t)i;
   2fc7c:	88fb      	ldrh	r3, [r7, #6]
   2fc7e:	88fa      	ldrh	r2, [r7, #6]
   2fc80:	b2d1      	uxtb	r1, r2
   2fc82:	4a0d      	ldr	r2, [pc, #52]	; (2fcb8 <storage_begin_reading+0x84>)
   2fc84:	54d1      	strb	r1, [r2, r3]
   for (uint16_t i = 0; i < cache_index; ++i)
   2fc86:	88fb      	ldrh	r3, [r7, #6]
   2fc88:	3301      	adds	r3, #1
   2fc8a:	80fb      	strh	r3, [r7, #6]
   2fc8c:	4b08      	ldr	r3, [pc, #32]	; (2fcb0 <storage_begin_reading+0x7c>)
   2fc8e:	881b      	ldrh	r3, [r3, #0]
   2fc90:	88fa      	ldrh	r2, [r7, #6]
   2fc92:	429a      	cmp	r2, r3
   2fc94:	d3f2      	bcc.n	2fc7c <storage_begin_reading+0x48>
}
   2fc96:	bf00      	nop
   2fc98:	bf00      	nop
   2fc9a:	370c      	adds	r7, #12
   2fc9c:	46bd      	mov	sp, r7
   2fc9e:	f85d 7b04 	ldr.w	r7, [sp], #4
   2fca2:	4770      	bx	lr
   2fca4:	1000ae66 	.word	0x1000ae66
   2fca8:	1000be6c 	.word	0x1000be6c
   2fcac:	00200006 	.word	0x00200006
   2fcb0:	1000ae6a 	.word	0x1000ae6a
   2fcb4:	1000ae68 	.word	0x1000ae68
   2fcb8:	1000ae6c 	.word	0x1000ae6c

0002fcbc <storage_end_reading>:
void storage_end_reading(void) { is_reading = false; }
   2fcbc:	b480      	push	{r7}
   2fcbe:	af00      	add	r7, sp, #0
   2fcc0:	4b03      	ldr	r3, [pc, #12]	; (2fcd0 <storage_end_reading+0x14>)
   2fcc2:	2200      	movs	r2, #0
   2fcc4:	701a      	strb	r2, [r3, #0]
   2fcc6:	bf00      	nop
   2fcc8:	46bd      	mov	sp, r7
   2fcca:	f85d 7b04 	ldr.w	r7, [sp], #4
   2fcce:	4770      	bx	lr
   2fcd0:	1000be6c 	.word	0x1000be6c

0002fcd4 <storage_retrieve_data_length>:
uint32_t storage_retrieve_data_length(void) { return total_size; }
   2fcd4:	b480      	push	{r7}
   2fcd6:	af00      	add	r7, sp, #0
   2fcd8:	4b02      	ldr	r3, [pc, #8]	; (2fce4 <storage_retrieve_data_length+0x10>)
   2fcda:	4618      	mov	r0, r3
   2fcdc:	46bd      	mov	sp, r7
   2fcde:	f85d 7b04 	ldr.w	r7, [sp], #4
   2fce2:	4770      	bx	lr
   2fce4:	00200006 	.word	0x00200006

0002fce8 <storage_retrieve_next_data_chunk>:
uint32_t storage_retrieve_next_data_chunk(uint8_t *buffer)
{
   2fce8:	b580      	push	{r7, lr}
   2fcea:	b084      	sub	sp, #16
   2fcec:	af00      	add	r7, sp, #0
   2fcee:	6078      	str	r0, [r7, #4]
   // Ensure that we are in reading mode
   if (!is_reading)
   2fcf0:	4b1a      	ldr	r3, [pc, #104]	; (2fd5c <storage_retrieve_next_data_chunk+0x74>)
   2fcf2:	781b      	ldrb	r3, [r3, #0]
   2fcf4:	f083 0301 	eor.w	r3, r3, #1
   2fcf8:	b2db      	uxtb	r3, r3
   2fcfa:	2b00      	cmp	r3, #0
   2fcfc:	d001      	beq.n	2fd02 <storage_retrieve_next_data_chunk+0x1a>
      return 0;
   2fcfe:	2300      	movs	r3, #0
   2fd00:	e027      	b.n	2fd52 <storage_retrieve_next_data_chunk+0x6a>

   // Determine if a full page of memory is available to read
   uint32_t num_bytes_retrieved = MEMORY_PAGE_SIZE_BYTES;
   2fd02:	f44f 6300 	mov.w	r3, #2048	; 0x800
   2fd06:	60fb      	str	r3, [r7, #12]
   if (reading_page == final_page)
   2fd08:	4b15      	ldr	r3, [pc, #84]	; (2fd60 <storage_retrieve_next_data_chunk+0x78>)
   2fd0a:	881a      	ldrh	r2, [r3, #0]
   2fd0c:	4b15      	ldr	r3, [pc, #84]	; (2fd64 <storage_retrieve_next_data_chunk+0x7c>)
   2fd0e:	881b      	ldrh	r3, [r3, #0]
   2fd10:	429a      	cmp	r2, r3
   2fd12:	d10d      	bne.n	2fd30 <storage_retrieve_next_data_chunk+0x48>
   {
      // Return the valid available bytes
      memcpy(buffer, cache, cache_index);
   2fd14:	4b14      	ldr	r3, [pc, #80]	; (2fd68 <storage_retrieve_next_data_chunk+0x80>)
   2fd16:	881b      	ldrh	r3, [r3, #0]
   2fd18:	461a      	mov	r2, r3
   2fd1a:	4914      	ldr	r1, [pc, #80]	; (2fd6c <storage_retrieve_next_data_chunk+0x84>)
   2fd1c:	6878      	ldr	r0, [r7, #4]
   2fd1e:	f7e8 fa99 	bl	18254 <memcpy>
      num_bytes_retrieved = cache_index;
   2fd22:	4b11      	ldr	r3, [pc, #68]	; (2fd68 <storage_retrieve_next_data_chunk+0x80>)
   2fd24:	881b      	ldrh	r3, [r3, #0]
   2fd26:	60fb      	str	r3, [r7, #12]
      is_reading = false;
   2fd28:	4b0c      	ldr	r3, [pc, #48]	; (2fd5c <storage_retrieve_next_data_chunk+0x74>)
   2fd2a:	2200      	movs	r2, #0
   2fd2c:	701a      	strb	r2, [r3, #0]
   2fd2e:	e00f      	b.n	2fd50 <storage_retrieve_next_data_chunk+0x68>
   }
   else
   {
      // Read the next page of memory and update the reading metadata
      read_page(buffer);
   2fd30:	6878      	ldr	r0, [r7, #4]
   2fd32:	f7ff ff63 	bl	2fbfc <read_page>
      reading_page = (reading_page + 1) % MEMORY_PAGE_COUNT;
   2fd36:	4b0a      	ldr	r3, [pc, #40]	; (2fd60 <storage_retrieve_next_data_chunk+0x78>)
   2fd38:	881b      	ldrh	r3, [r3, #0]
   2fd3a:	3301      	adds	r3, #1
   2fd3c:	425a      	negs	r2, r3
   2fd3e:	f3c3 030e 	ubfx	r3, r3, #0, #15
   2fd42:	f3c2 020e 	ubfx	r2, r2, #0, #15
   2fd46:	bf58      	it	pl
   2fd48:	4253      	negpl	r3, r2
   2fd4a:	b29a      	uxth	r2, r3
   2fd4c:	4b04      	ldr	r3, [pc, #16]	; (2fd60 <storage_retrieve_next_data_chunk+0x78>)
   2fd4e:	801a      	strh	r2, [r3, #0]
   }
   return num_bytes_retrieved;
   2fd50:	68fb      	ldr	r3, [r7, #12]
}
   2fd52:	4618      	mov	r0, r3
   2fd54:	3710      	adds	r7, #16
   2fd56:	46bd      	mov	sp, r7
   2fd58:	bd80      	pop	{r7, pc}
   2fd5a:	bf00      	nop
   2fd5c:	1000be6c 	.word	0x1000be6c
   2fd60:	1000ae66 	.word	0x1000ae66
   2fd64:	1000ae68 	.word	0x1000ae68
   2fd68:	1000ae6a 	.word	0x1000ae6a
   2fd6c:	1000ae6c 	.word	0x1000ae6c

0002fd70 <main>:


int main(void)
{
   2fd70:	b580      	push	{r7, lr}
   2fd72:	b082      	sub	sp, #8
   2fd74:	af02      	add	r7, sp, #8
   // Set up system hardware
   setup_hardware();
   2fd76:	f7ff faaf 	bl	2f2d8 <setup_hardware>
   
   print("please print this!");
   2fd7a:	4812      	ldr	r0, [pc, #72]	; (2fdc4 <main+0x54>)
   2fd7c:	f7ea ff10 	bl	1aba0 <am_util_stdio_printf>
   // Fetch the device UID and initialize the Bluetooth hardware
   static uint8_t uid[EUI_LEN];
   system_read_UID(uid, sizeof(uid));
   2fd80:	2106      	movs	r1, #6
   2fd82:	4811      	ldr	r0, [pc, #68]	; (2fdc8 <main+0x58>)
   2fd84:	f7ff fb26 	bl	2f3d4 <system_read_UID>
   bluetooth_init(uid);
   2fd88:	480f      	ldr	r0, [pc, #60]	; (2fdc8 <main+0x58>)
   2fd8a:	f7fe facd 	bl	2e328 <bluetooth_init>
   //am_hal_delay_us(5000000);

   // Create the BLE task and start the task scheduler
   static TaskHandle_t ble_task_handle;
   configASSERT1(xTaskCreate(BLETask, "BLETask", 512, NULL, 3, &ble_task_handle));
   2fd8e:	4b0f      	ldr	r3, [pc, #60]	; (2fdcc <main+0x5c>)
   2fd90:	9301      	str	r3, [sp, #4]
   2fd92:	2303      	movs	r3, #3
   2fd94:	9300      	str	r3, [sp, #0]
   2fd96:	2300      	movs	r3, #0
   2fd98:	f44f 7200 	mov.w	r2, #512	; 0x200
   2fd9c:	490c      	ldr	r1, [pc, #48]	; (2fdd0 <main+0x60>)
   2fd9e:	480d      	ldr	r0, [pc, #52]	; (2fdd4 <main+0x64>)
   2fda0:	f7fb fe53 	bl	2ba4a <xTaskCreate>
   2fda4:	4603      	mov	r3, r0
   2fda6:	2b01      	cmp	r3, #1
   2fda8:	d003      	beq.n	2fdb2 <main+0x42>
   2fdaa:	2148      	movs	r1, #72	; 0x48
   2fdac:	480a      	ldr	r0, [pc, #40]	; (2fdd8 <main+0x68>)
   2fdae:	f7ff fa7f 	bl	2f2b0 <vAssertCalled>
   bluetooth_start_advertising();
   2fdb2:	f7fe fb8b 	bl	2e4cc <bluetooth_start_advertising>
   vTaskStartScheduler();
   2fdb6:	f7fb ff5f 	bl	2bc78 <vTaskStartScheduler>

   // Should never reach this point
   return 0;
   2fdba:	2300      	movs	r3, #0
}
   2fdbc:	4618      	mov	r0, r3
   2fdbe:	46bd      	mov	sp, r7
   2fdc0:	bd80      	pop	{r7, pc}
   2fdc2:	bf00      	nop
   2fdc4:	00045a08 	.word	0x00045a08
   2fdc8:	1000be70 	.word	0x1000be70
   2fdcc:	1000be78 	.word	0x1000be78
   2fdd0:	00045a1c 	.word	0x00045a1c
   2fdd4:	0002f69d 	.word	0x0002f69d
   2fdd8:	00045a24 	.word	0x00045a24

0002fddc <gmtime>:
   2fddc:	4b02      	ldr	r3, [pc, #8]	; (2fde8 <gmtime+0xc>)
   2fdde:	6819      	ldr	r1, [r3, #0]
   2fde0:	317c      	adds	r1, #124	; 0x7c
   2fde2:	f000 b803 	b.w	2fdec <gmtime_r>
   2fde6:	bf00      	nop
   2fde8:	10002d7c 	.word	0x10002d7c

0002fdec <gmtime_r>:
   2fdec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   2fdee:	e9d0 6700 	ldrd	r6, r7, [r0]
   2fdf2:	4a61      	ldr	r2, [pc, #388]	; (2ff78 <gmtime_r+0x18c>)
   2fdf4:	2300      	movs	r3, #0
   2fdf6:	460c      	mov	r4, r1
   2fdf8:	4630      	mov	r0, r6
   2fdfa:	4639      	mov	r1, r7
   2fdfc:	f7e8 fd0e 	bl	1881c <__aeabi_ldivmod>
   2fe00:	4a5d      	ldr	r2, [pc, #372]	; (2ff78 <gmtime_r+0x18c>)
   2fe02:	4605      	mov	r5, r0
   2fe04:	2300      	movs	r3, #0
   2fe06:	4630      	mov	r0, r6
   2fe08:	4639      	mov	r1, r7
   2fe0a:	f7e8 fd07 	bl	1881c <__aeabi_ldivmod>
   2fe0e:	2a00      	cmp	r2, #0
   2fe10:	f2c0 80a8 	blt.w	2ff64 <gmtime_r+0x178>
   2fe14:	f505 202f 	add.w	r0, r5, #716800	; 0xaf000
   2fe18:	f600 206c 	addw	r0, r0, #2668	; 0xa6c
   2fe1c:	4d57      	ldr	r5, [pc, #348]	; (2ff7c <gmtime_r+0x190>)
   2fe1e:	4958      	ldr	r1, [pc, #352]	; (2ff80 <gmtime_r+0x194>)
   2fe20:	fba5 3502 	umull	r3, r5, r5, r2
   2fe24:	0aed      	lsrs	r5, r5, #11
   2fe26:	f44f 6361 	mov.w	r3, #3600	; 0xe10
   2fe2a:	fb03 2215 	mls	r2, r3, r5, r2
   2fe2e:	4b55      	ldr	r3, [pc, #340]	; (2ff84 <gmtime_r+0x198>)
   2fe30:	60a5      	str	r5, [r4, #8]
   2fe32:	1cc6      	adds	r6, r0, #3
   2fe34:	fb83 5306 	smull	r5, r3, r3, r6
   2fe38:	fba1 5102 	umull	r5, r1, r1, r2
   2fe3c:	199d      	adds	r5, r3, r6
   2fe3e:	17f3      	asrs	r3, r6, #31
   2fe40:	ebc3 03a5 	rsb	r3, r3, r5, asr #2
   2fe44:	0949      	lsrs	r1, r1, #5
   2fe46:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   2fe4a:	1af3      	subs	r3, r6, r3
   2fe4c:	ebc1 1501 	rsb	r5, r1, r1, lsl #4
   2fe50:	bf48      	it	mi
   2fe52:	3307      	addmi	r3, #7
   2fe54:	eba2 0285 	sub.w	r2, r2, r5, lsl #2
   2fe58:	2800      	cmp	r0, #0
   2fe5a:	e9c4 2100 	strd	r2, r1, [r4]
   2fe5e:	61a3      	str	r3, [r4, #24]
   2fe60:	db75      	blt.n	2ff4e <gmtime_r+0x162>
   2fe62:	4b49      	ldr	r3, [pc, #292]	; (2ff88 <gmtime_r+0x19c>)
   2fe64:	17c2      	asrs	r2, r0, #31
   2fe66:	fb83 1300 	smull	r1, r3, r3, r0
   2fe6a:	ebc2 32e3 	rsb	r2, r2, r3, asr #15
   2fe6e:	4d47      	ldr	r5, [pc, #284]	; (2ff8c <gmtime_r+0x1a0>)
   2fe70:	4b47      	ldr	r3, [pc, #284]	; (2ff90 <gmtime_r+0x1a4>)
   2fe72:	4e48      	ldr	r6, [pc, #288]	; (2ff94 <gmtime_r+0x1a8>)
   2fe74:	4f48      	ldr	r7, [pc, #288]	; (2ff98 <gmtime_r+0x1ac>)
   2fe76:	4949      	ldr	r1, [pc, #292]	; (2ff9c <gmtime_r+0x1b0>)
   2fe78:	fb05 0502 	mla	r5, r5, r2, r0
   2fe7c:	08a8      	lsrs	r0, r5, #2
   2fe7e:	fba3 c300 	umull	ip, r3, r3, r0
   2fe82:	eb05 23d3 	add.w	r3, r5, r3, lsr #11
   2fe86:	fba6 c000 	umull	ip, r0, r6, r0
   2fe8a:	eba3 13d0 	sub.w	r3, r3, r0, lsr #7
   2fe8e:	0928      	lsrs	r0, r5, #4
   2fe90:	fba7 7000 	umull	r7, r0, r7, r0
   2fe94:	eba3 1310 	sub.w	r3, r3, r0, lsr #4
   2fe98:	fba1 0103 	umull	r0, r1, r1, r3
   2fe9c:	1a5f      	subs	r7, r3, r1
   2fe9e:	0898      	lsrs	r0, r3, #2
   2fea0:	eb01 0357 	add.w	r3, r1, r7, lsr #1
   2fea4:	4f3e      	ldr	r7, [pc, #248]	; (2ffa0 <gmtime_r+0x1b4>)
   2fea6:	493f      	ldr	r1, [pc, #252]	; (2ffa4 <gmtime_r+0x1b8>)
   2fea8:	0a1b      	lsrs	r3, r3, #8
   2feaa:	fba6 6000 	umull	r6, r0, r6, r0
   2feae:	09c0      	lsrs	r0, r0, #7
   2feb0:	fba7 7603 	umull	r7, r6, r7, r3
   2feb4:	ebc0 1056 	rsb	r0, r0, r6, lsr #5
   2feb8:	4428      	add	r0, r5
   2feba:	f240 156d 	movw	r5, #365	; 0x16d
   2febe:	fb05 0013 	mls	r0, r5, r3, r0
   2fec2:	eb00 0580 	add.w	r5, r0, r0, lsl #2
   2fec6:	3502      	adds	r5, #2
   2fec8:	fba1 6105 	umull	r6, r1, r1, r5
   2fecc:	09ce      	lsrs	r6, r1, #7
   2fece:	f240 51f9 	movw	r1, #1529	; 0x5f9
   2fed2:	428d      	cmp	r5, r1
   2fed4:	f44f 77c8 	mov.w	r7, #400	; 0x190
   2fed8:	eb06 01c6 	add.w	r1, r6, r6, lsl #3
   2fedc:	fb07 3202 	mla	r2, r7, r2, r3
   2fee0:	4d31      	ldr	r5, [pc, #196]	; (2ffa8 <gmtime_r+0x1bc>)
   2fee2:	bf94      	ite	ls
   2fee4:	2702      	movls	r7, #2
   2fee6:	f06f 0709 	mvnhi.w	r7, #9
   2feea:	eb01 1101 	add.w	r1, r1, r1, lsl #4
   2feee:	3102      	adds	r1, #2
   2fef0:	443e      	add	r6, r7
   2fef2:	fba5 5101 	umull	r5, r1, r5, r1
   2fef6:	2e01      	cmp	r6, #1
   2fef8:	bf98      	it	ls
   2fefa:	3201      	addls	r2, #1
   2fefc:	1c45      	adds	r5, r0, #1
   2fefe:	f5b0 7f99 	cmp.w	r0, #306	; 0x132
   2ff02:	eba5 0191 	sub.w	r1, r5, r1, lsr #2
   2ff06:	d30b      	bcc.n	2ff20 <gmtime_r+0x134>
   2ff08:	f5a0 7099 	sub.w	r0, r0, #306	; 0x132
   2ff0c:	f2a2 726c 	subw	r2, r2, #1900	; 0x76c
   2ff10:	2300      	movs	r3, #0
   2ff12:	61e0      	str	r0, [r4, #28]
   2ff14:	e9c4 1603 	strd	r1, r6, [r4, #12]
   2ff18:	6162      	str	r2, [r4, #20]
   2ff1a:	6223      	str	r3, [r4, #32]
   2ff1c:	4620      	mov	r0, r4
   2ff1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   2ff20:	079d      	lsls	r5, r3, #30
   2ff22:	d00b      	beq.n	2ff3c <gmtime_r+0x150>
   2ff24:	4d21      	ldr	r5, [pc, #132]	; (2ffac <gmtime_r+0x1c0>)
   2ff26:	4f22      	ldr	r7, [pc, #136]	; (2ffb0 <gmtime_r+0x1c4>)
   2ff28:	fb05 f303 	mul.w	r3, r5, r3
   2ff2c:	ebb7 1f33 	cmp.w	r7, r3, ror #4
   2ff30:	bf2c      	ite	cs
   2ff32:	2301      	movcs	r3, #1
   2ff34:	2300      	movcc	r3, #0
   2ff36:	303b      	adds	r0, #59	; 0x3b
   2ff38:	4418      	add	r0, r3
   2ff3a:	e7e7      	b.n	2ff0c <gmtime_r+0x120>
   2ff3c:	4d1b      	ldr	r5, [pc, #108]	; (2ffac <gmtime_r+0x1c0>)
   2ff3e:	4f1d      	ldr	r7, [pc, #116]	; (2ffb4 <gmtime_r+0x1c8>)
   2ff40:	fb05 f503 	mul.w	r5, r5, r3
   2ff44:	ebb7 0fb5 	cmp.w	r7, r5, ror #2
   2ff48:	d2ec      	bcs.n	2ff24 <gmtime_r+0x138>
   2ff4a:	2301      	movs	r3, #1
   2ff4c:	e7f3      	b.n	2ff36 <gmtime_r+0x14a>
   2ff4e:	4a0e      	ldr	r2, [pc, #56]	; (2ff88 <gmtime_r+0x19c>)
   2ff50:	f5a0 330e 	sub.w	r3, r0, #145408	; 0x23800
   2ff54:	f5a3 732c 	sub.w	r3, r3, #688	; 0x2b0
   2ff58:	fb82 1203 	smull	r1, r2, r2, r3
   2ff5c:	17db      	asrs	r3, r3, #31
   2ff5e:	ebc3 32e2 	rsb	r2, r3, r2, asr #15
   2ff62:	e784      	b.n	2fe6e <gmtime_r+0x82>
   2ff64:	f502 32a8 	add.w	r2, r2, #86016	; 0x15000
   2ff68:	f505 202f 	add.w	r0, r5, #716800	; 0xaf000
   2ff6c:	f502 72c0 	add.w	r2, r2, #384	; 0x180
   2ff70:	f600 206b 	addw	r0, r0, #2667	; 0xa6b
   2ff74:	e752      	b.n	2fe1c <gmtime_r+0x30>
   2ff76:	bf00      	nop
   2ff78:	00015180 	.word	0x00015180
   2ff7c:	91a2b3c5 	.word	0x91a2b3c5
   2ff80:	88888889 	.word	0x88888889
   2ff84:	92492493 	.word	0x92492493
   2ff88:	396b06bd 	.word	0x396b06bd
   2ff8c:	fffdc54f 	.word	0xfffdc54f
   2ff90:	396b207f 	.word	0x396b207f
   2ff94:	59c67cd9 	.word	0x59c67cd9
   2ff98:	0072d641 	.word	0x0072d641
   2ff9c:	6719f361 	.word	0x6719f361
   2ffa0:	51eb851f 	.word	0x51eb851f
   2ffa4:	d62b80d7 	.word	0xd62b80d7
   2ffa8:	cccccccd 	.word	0xcccccccd
   2ffac:	c28f5c29 	.word	0xc28f5c29
   2ffb0:	00a3d70a 	.word	0x00a3d70a
   2ffb4:	028f5c28 	.word	0x028f5c28

0002ffb8 <memcmp>:
   2ffb8:	2a03      	cmp	r2, #3
   2ffba:	b470      	push	{r4, r5, r6}
   2ffbc:	d912      	bls.n	2ffe4 <memcmp+0x2c>
   2ffbe:	ea40 0501 	orr.w	r5, r0, r1
   2ffc2:	07ad      	lsls	r5, r5, #30
   2ffc4:	4604      	mov	r4, r0
   2ffc6:	460b      	mov	r3, r1
   2ffc8:	d11e      	bne.n	30008 <memcmp+0x50>
   2ffca:	4619      	mov	r1, r3
   2ffcc:	4620      	mov	r0, r4
   2ffce:	f853 5b04 	ldr.w	r5, [r3], #4
   2ffd2:	f854 6b04 	ldr.w	r6, [r4], #4
   2ffd6:	42ae      	cmp	r6, r5
   2ffd8:	d116      	bne.n	30008 <memcmp+0x50>
   2ffda:	3a04      	subs	r2, #4
   2ffdc:	2a03      	cmp	r2, #3
   2ffde:	4620      	mov	r0, r4
   2ffe0:	4619      	mov	r1, r3
   2ffe2:	d8f2      	bhi.n	2ffca <memcmp+0x12>
   2ffe4:	1e56      	subs	r6, r2, #1
   2ffe6:	b1a2      	cbz	r2, 30012 <memcmp+0x5a>
   2ffe8:	3901      	subs	r1, #1
   2ffea:	1e44      	subs	r4, r0, #1
   2ffec:	e001      	b.n	2fff2 <memcmp+0x3a>
   2ffee:	18c3      	adds	r3, r0, r3
   2fff0:	d00c      	beq.n	3000c <memcmp+0x54>
   2fff2:	f814 5f01 	ldrb.w	r5, [r4, #1]!
   2fff6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
   2fffa:	4295      	cmp	r5, r2
   2fffc:	eba6 0304 	sub.w	r3, r6, r4
   30000:	d0f5      	beq.n	2ffee <memcmp+0x36>
   30002:	1aa8      	subs	r0, r5, r2
   30004:	bc70      	pop	{r4, r5, r6}
   30006:	4770      	bx	lr
   30008:	1e56      	subs	r6, r2, #1
   3000a:	e7ed      	b.n	2ffe8 <memcmp+0x30>
   3000c:	4618      	mov	r0, r3
   3000e:	bc70      	pop	{r4, r5, r6}
   30010:	4770      	bx	lr
   30012:	4610      	mov	r0, r2
   30014:	e7f6      	b.n	30004 <memcmp+0x4c>
   30016:	bf00      	nop

00030018 <memmove>:
   30018:	4288      	cmp	r0, r1
   3001a:	b4f0      	push	{r4, r5, r6, r7}
   3001c:	d90d      	bls.n	3003a <memmove+0x22>
   3001e:	188b      	adds	r3, r1, r2
   30020:	4283      	cmp	r3, r0
   30022:	d90a      	bls.n	3003a <memmove+0x22>
   30024:	1884      	adds	r4, r0, r2
   30026:	b132      	cbz	r2, 30036 <memmove+0x1e>
   30028:	4622      	mov	r2, r4
   3002a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   3002e:	f802 4d01 	strb.w	r4, [r2, #-1]!
   30032:	4299      	cmp	r1, r3
   30034:	d1f9      	bne.n	3002a <memmove+0x12>
   30036:	bcf0      	pop	{r4, r5, r6, r7}
   30038:	4770      	bx	lr
   3003a:	2a0f      	cmp	r2, #15
   3003c:	d80e      	bhi.n	3005c <memmove+0x44>
   3003e:	4603      	mov	r3, r0
   30040:	1e54      	subs	r4, r2, #1
   30042:	2a00      	cmp	r2, #0
   30044:	d0f7      	beq.n	30036 <memmove+0x1e>
   30046:	3401      	adds	r4, #1
   30048:	440c      	add	r4, r1
   3004a:	3b01      	subs	r3, #1
   3004c:	f811 2b01 	ldrb.w	r2, [r1], #1
   30050:	f803 2f01 	strb.w	r2, [r3, #1]!
   30054:	42a1      	cmp	r1, r4
   30056:	d1f9      	bne.n	3004c <memmove+0x34>
   30058:	bcf0      	pop	{r4, r5, r6, r7}
   3005a:	4770      	bx	lr
   3005c:	ea40 0301 	orr.w	r3, r0, r1
   30060:	079b      	lsls	r3, r3, #30
   30062:	d13f      	bne.n	300e4 <memmove+0xcc>
   30064:	f1a2 0310 	sub.w	r3, r2, #16
   30068:	f023 040f 	bic.w	r4, r3, #15
   3006c:	f101 0720 	add.w	r7, r1, #32
   30070:	4427      	add	r7, r4
   30072:	091b      	lsrs	r3, r3, #4
   30074:	f101 0410 	add.w	r4, r1, #16
   30078:	f100 0510 	add.w	r5, r0, #16
   3007c:	f854 6c10 	ldr.w	r6, [r4, #-16]
   30080:	f845 6c10 	str.w	r6, [r5, #-16]
   30084:	f854 6c0c 	ldr.w	r6, [r4, #-12]
   30088:	f845 6c0c 	str.w	r6, [r5, #-12]
   3008c:	f854 6c08 	ldr.w	r6, [r4, #-8]
   30090:	f845 6c08 	str.w	r6, [r5, #-8]
   30094:	f854 6c04 	ldr.w	r6, [r4, #-4]
   30098:	f845 6c04 	str.w	r6, [r5, #-4]
   3009c:	3410      	adds	r4, #16
   3009e:	42bc      	cmp	r4, r7
   300a0:	f105 0510 	add.w	r5, r5, #16
   300a4:	d1ea      	bne.n	3007c <memmove+0x64>
   300a6:	3301      	adds	r3, #1
   300a8:	f012 0f0c 	tst.w	r2, #12
   300ac:	eb01 1103 	add.w	r1, r1, r3, lsl #4
   300b0:	f002 040f 	and.w	r4, r2, #15
   300b4:	eb00 1303 	add.w	r3, r0, r3, lsl #4
   300b8:	d017      	beq.n	300ea <memmove+0xd2>
   300ba:	3c04      	subs	r4, #4
   300bc:	f024 0c03 	bic.w	ip, r4, #3
   300c0:	08a5      	lsrs	r5, r4, #2
   300c2:	449c      	add	ip, r3
   300c4:	1f1c      	subs	r4, r3, #4
   300c6:	460e      	mov	r6, r1
   300c8:	f856 7b04 	ldr.w	r7, [r6], #4
   300cc:	f844 7f04 	str.w	r7, [r4, #4]!
   300d0:	4564      	cmp	r4, ip
   300d2:	d1f9      	bne.n	300c8 <memmove+0xb0>
   300d4:	1c6c      	adds	r4, r5, #1
   300d6:	eb03 0384 	add.w	r3, r3, r4, lsl #2
   300da:	eb01 0184 	add.w	r1, r1, r4, lsl #2
   300de:	f002 0203 	and.w	r2, r2, #3
   300e2:	e7ad      	b.n	30040 <memmove+0x28>
   300e4:	1e54      	subs	r4, r2, #1
   300e6:	4603      	mov	r3, r0
   300e8:	e7ad      	b.n	30046 <memmove+0x2e>
   300ea:	4622      	mov	r2, r4
   300ec:	e7a8      	b.n	30040 <memmove+0x28>
   300ee:	bf00      	nop

000300f0 <memset>:
   300f0:	b4f0      	push	{r4, r5, r6, r7}
   300f2:	0786      	lsls	r6, r0, #30
   300f4:	d046      	beq.n	30184 <memset+0x94>
   300f6:	1e54      	subs	r4, r2, #1
   300f8:	2a00      	cmp	r2, #0
   300fa:	d03c      	beq.n	30176 <memset+0x86>
   300fc:	b2ca      	uxtb	r2, r1
   300fe:	4603      	mov	r3, r0
   30100:	e001      	b.n	30106 <memset+0x16>
   30102:	3c01      	subs	r4, #1
   30104:	d337      	bcc.n	30176 <memset+0x86>
   30106:	f803 2b01 	strb.w	r2, [r3], #1
   3010a:	079d      	lsls	r5, r3, #30
   3010c:	d1f9      	bne.n	30102 <memset+0x12>
   3010e:	2c03      	cmp	r4, #3
   30110:	d92a      	bls.n	30168 <memset+0x78>
   30112:	b2cd      	uxtb	r5, r1
   30114:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   30118:	2c0f      	cmp	r4, #15
   3011a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   3011e:	d934      	bls.n	3018a <memset+0x9a>
   30120:	f1a4 0210 	sub.w	r2, r4, #16
   30124:	f022 0c0f 	bic.w	ip, r2, #15
   30128:	f103 0720 	add.w	r7, r3, #32
   3012c:	0916      	lsrs	r6, r2, #4
   3012e:	4467      	add	r7, ip
   30130:	f103 0210 	add.w	r2, r3, #16
   30134:	e942 5504 	strd	r5, r5, [r2, #-16]
   30138:	e942 5502 	strd	r5, r5, [r2, #-8]
   3013c:	3210      	adds	r2, #16
   3013e:	42ba      	cmp	r2, r7
   30140:	d1f8      	bne.n	30134 <memset+0x44>
   30142:	1c72      	adds	r2, r6, #1
   30144:	f014 0f0c 	tst.w	r4, #12
   30148:	eb03 1202 	add.w	r2, r3, r2, lsl #4
   3014c:	f004 060f 	and.w	r6, r4, #15
   30150:	d013      	beq.n	3017a <memset+0x8a>
   30152:	1f33      	subs	r3, r6, #4
   30154:	f023 0303 	bic.w	r3, r3, #3
   30158:	3304      	adds	r3, #4
   3015a:	4413      	add	r3, r2
   3015c:	f842 5b04 	str.w	r5, [r2], #4
   30160:	4293      	cmp	r3, r2
   30162:	d1fb      	bne.n	3015c <memset+0x6c>
   30164:	f006 0403 	and.w	r4, r6, #3
   30168:	b12c      	cbz	r4, 30176 <memset+0x86>
   3016a:	b2ca      	uxtb	r2, r1
   3016c:	441c      	add	r4, r3
   3016e:	f803 2b01 	strb.w	r2, [r3], #1
   30172:	429c      	cmp	r4, r3
   30174:	d1fb      	bne.n	3016e <memset+0x7e>
   30176:	bcf0      	pop	{r4, r5, r6, r7}
   30178:	4770      	bx	lr
   3017a:	4634      	mov	r4, r6
   3017c:	4613      	mov	r3, r2
   3017e:	2c00      	cmp	r4, #0
   30180:	d1f3      	bne.n	3016a <memset+0x7a>
   30182:	e7f8      	b.n	30176 <memset+0x86>
   30184:	4614      	mov	r4, r2
   30186:	4603      	mov	r3, r0
   30188:	e7c1      	b.n	3010e <memset+0x1e>
   3018a:	461a      	mov	r2, r3
   3018c:	4626      	mov	r6, r4
   3018e:	e7e0      	b.n	30152 <memset+0x62>

00030190 <validate_structure>:
   30190:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   30194:	6801      	ldr	r1, [r0, #0]
   30196:	293b      	cmp	r1, #59	; 0x3b
   30198:	b083      	sub	sp, #12
   3019a:	4604      	mov	r4, r0
   3019c:	f200 80cd 	bhi.w	3033a <validate_structure+0x1aa>
   301a0:	6841      	ldr	r1, [r0, #4]
   301a2:	293b      	cmp	r1, #59	; 0x3b
   301a4:	f200 80b7 	bhi.w	30316 <validate_structure+0x186>
   301a8:	68a1      	ldr	r1, [r4, #8]
   301aa:	2917      	cmp	r1, #23
   301ac:	f200 80a1 	bhi.w	302f2 <validate_structure+0x162>
   301b0:	6921      	ldr	r1, [r4, #16]
   301b2:	290b      	cmp	r1, #11
   301b4:	f200 808b 	bhi.w	302ce <validate_structure+0x13e>
   301b8:	6963      	ldr	r3, [r4, #20]
   301ba:	079a      	lsls	r2, r3, #30
   301bc:	d13e      	bne.n	3023c <validate_structure+0xac>
   301be:	486e      	ldr	r0, [pc, #440]	; (30378 <validate_structure+0x1e8>)
   301c0:	4a6e      	ldr	r2, [pc, #440]	; (3037c <validate_structure+0x1ec>)
   301c2:	4d6f      	ldr	r5, [pc, #444]	; (30380 <validate_structure+0x1f0>)
   301c4:	fb00 2603 	mla	r6, r0, r3, r2
   301c8:	ebb5 0fb6 	cmp.w	r5, r6, ror #2
   301cc:	d272      	bcs.n	302b4 <validate_structure+0x124>
   301ce:	68e3      	ldr	r3, [r4, #12]
   301d0:	2b00      	cmp	r3, #0
   301d2:	f04f 001d 	mov.w	r0, #29
   301d6:	dc35      	bgt.n	30244 <validate_structure+0xb4>
   301d8:	4d6a      	ldr	r5, [pc, #424]	; (30384 <validate_structure+0x1f4>)
   301da:	4f67      	ldr	r7, [pc, #412]	; (30378 <validate_structure+0x1e8>)
   301dc:	4e67      	ldr	r6, [pc, #412]	; (3037c <validate_structure+0x1ec>)
   301de:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 30380 <validate_structure+0x1f0>
   301e2:	f8df e1a4 	ldr.w	lr, [pc, #420]	; 30388 <validate_structure+0x1f8>
   301e6:	e007      	b.n	301f8 <validate_structure+0x68>
   301e8:	2901      	cmp	r1, #1
   301ea:	bf14      	ite	ne
   301ec:	f855 2021 	ldrne.w	r2, [r5, r1, lsl #2]
   301f0:	4602      	moveq	r2, r0
   301f2:	4413      	add	r3, r2
   301f4:	2b00      	cmp	r3, #0
   301f6:	dc1c      	bgt.n	30232 <validate_structure+0xa2>
   301f8:	3901      	subs	r1, #1
   301fa:	d2f5      	bcs.n	301e8 <validate_structure+0x58>
   301fc:	6961      	ldr	r1, [r4, #20]
   301fe:	1e4a      	subs	r2, r1, #1
   30200:	f012 0f03 	tst.w	r2, #3
   30204:	6162      	str	r2, [r4, #20]
   30206:	d160      	bne.n	302ca <validate_structure+0x13a>
   30208:	fb07 6202 	mla	r2, r7, r2, r6
   3020c:	ebbc 0fb2 	cmp.w	ip, r2, ror #2
   30210:	f0c0 80a5 	bcc.w	3035e <validate_structure+0x1ce>
   30214:	f201 716b 	addw	r1, r1, #1899	; 0x76b
   30218:	fb07 6101 	mla	r1, r7, r1, r6
   3021c:	ebbe 1f31 	cmp.w	lr, r1, ror #4
   30220:	bf34      	ite	cc
   30222:	201c      	movcc	r0, #28
   30224:	201d      	movcs	r0, #29
   30226:	221f      	movs	r2, #31
   30228:	4413      	add	r3, r2
   3022a:	2b00      	cmp	r3, #0
   3022c:	f04f 010b 	mov.w	r1, #11
   30230:	dde2      	ble.n	301f8 <validate_structure+0x68>
   30232:	e9c4 3103 	strd	r3, r1, [r4, #12]
   30236:	b003      	add	sp, #12
   30238:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3023c:	201c      	movs	r0, #28
   3023e:	68e3      	ldr	r3, [r4, #12]
   30240:	2b00      	cmp	r3, #0
   30242:	ddc9      	ble.n	301d8 <validate_structure+0x48>
   30244:	4d4f      	ldr	r5, [pc, #316]	; (30384 <validate_structure+0x1f4>)
   30246:	f8df e130 	ldr.w	lr, [pc, #304]	; 30378 <validate_structure+0x1e8>
   3024a:	f8df c130 	ldr.w	ip, [pc, #304]	; 3037c <validate_structure+0x1ec>
   3024e:	f8df 8130 	ldr.w	r8, [pc, #304]	; 30380 <validate_structure+0x1f0>
   30252:	f8df 9134 	ldr.w	r9, [pc, #308]	; 30388 <validate_structure+0x1f8>
   30256:	2602      	movs	r6, #2
   30258:	2700      	movs	r7, #0
   3025a:	2901      	cmp	r1, #1
   3025c:	f101 0201 	add.w	r2, r1, #1
   30260:	d00e      	beq.n	30280 <validate_structure+0xf0>
   30262:	f855 1021 	ldr.w	r1, [r5, r1, lsl #2]
   30266:	4299      	cmp	r1, r3
   30268:	eba3 0301 	sub.w	r3, r3, r1
   3026c:	dae3      	bge.n	30236 <validate_structure+0xa6>
   3026e:	2a0c      	cmp	r2, #12
   30270:	e9c4 3203 	strd	r3, r2, [r4, #12]
   30274:	d00d      	beq.n	30292 <validate_structure+0x102>
   30276:	4611      	mov	r1, r2
   30278:	2901      	cmp	r1, #1
   3027a:	f101 0201 	add.w	r2, r1, #1
   3027e:	d1f0      	bne.n	30262 <validate_structure+0xd2>
   30280:	4298      	cmp	r0, r3
   30282:	eba3 0300 	sub.w	r3, r3, r0
   30286:	dad6      	bge.n	30236 <validate_structure+0xa6>
   30288:	2202      	movs	r2, #2
   3028a:	e9c4 3603 	strd	r3, r6, [r4, #12]
   3028e:	4611      	mov	r1, r2
   30290:	e7f2      	b.n	30278 <validate_structure+0xe8>
   30292:	6961      	ldr	r1, [r4, #20]
   30294:	6127      	str	r7, [r4, #16]
   30296:	1c4a      	adds	r2, r1, #1
   30298:	f012 0f03 	tst.w	r2, #3
   3029c:	6162      	str	r2, [r4, #20]
   3029e:	d002      	beq.n	302a6 <validate_structure+0x116>
   302a0:	201c      	movs	r0, #28
   302a2:	2100      	movs	r1, #0
   302a4:	e7d9      	b.n	3025a <validate_structure+0xca>
   302a6:	fb0e c202 	mla	r2, lr, r2, ip
   302aa:	ebb8 0fb2 	cmp.w	r8, r2, ror #2
   302ae:	d258      	bcs.n	30362 <validate_structure+0x1d2>
   302b0:	201d      	movs	r0, #29
   302b2:	e7f6      	b.n	302a2 <validate_structure+0x112>
   302b4:	4d34      	ldr	r5, [pc, #208]	; (30388 <validate_structure+0x1f8>)
   302b6:	f203 736c 	addw	r3, r3, #1900	; 0x76c
   302ba:	fb00 2303 	mla	r3, r0, r3, r2
   302be:	ebb5 1f33 	cmp.w	r5, r3, ror #4
   302c2:	bf34      	ite	cc
   302c4:	201c      	movcc	r0, #28
   302c6:	201d      	movcs	r0, #29
   302c8:	e7b9      	b.n	3023e <validate_structure+0xae>
   302ca:	201c      	movs	r0, #28
   302cc:	e7ab      	b.n	30226 <validate_structure+0x96>
   302ce:	220c      	movs	r2, #12
   302d0:	4668      	mov	r0, sp
   302d2:	f000 fcb5 	bl	30c40 <div>
   302d6:	e9dd 2100 	ldrd	r2, r1, [sp]
   302da:	6963      	ldr	r3, [r4, #20]
   302dc:	2900      	cmp	r1, #0
   302de:	4413      	add	r3, r2
   302e0:	6163      	str	r3, [r4, #20]
   302e2:	bfbd      	ittte	lt
   302e4:	310c      	addlt	r1, #12
   302e6:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
   302ea:	e9c4 1304 	strdlt	r1, r3, [r4, #16]
   302ee:	6121      	strge	r1, [r4, #16]
   302f0:	e763      	b.n	301ba <validate_structure+0x2a>
   302f2:	2218      	movs	r2, #24
   302f4:	4668      	mov	r0, sp
   302f6:	f000 fca3 	bl	30c40 <div>
   302fa:	e9dd 1200 	ldrd	r1, r2, [sp]
   302fe:	68e3      	ldr	r3, [r4, #12]
   30300:	2a00      	cmp	r2, #0
   30302:	440b      	add	r3, r1
   30304:	60e3      	str	r3, [r4, #12]
   30306:	bfbd      	ittte	lt
   30308:	3218      	addlt	r2, #24
   3030a:	f103 33ff 	addlt.w	r3, r3, #4294967295	; 0xffffffff
   3030e:	e9c4 2302 	strdlt	r2, r3, [r4, #8]
   30312:	60a2      	strge	r2, [r4, #8]
   30314:	e74c      	b.n	301b0 <validate_structure+0x20>
   30316:	223c      	movs	r2, #60	; 0x3c
   30318:	4668      	mov	r0, sp
   3031a:	f000 fc91 	bl	30c40 <div>
   3031e:	e9dd 2300 	ldrd	r2, r3, [sp]
   30322:	68a1      	ldr	r1, [r4, #8]
   30324:	2b00      	cmp	r3, #0
   30326:	4411      	add	r1, r2
   30328:	60a1      	str	r1, [r4, #8]
   3032a:	bfbd      	ittte	lt
   3032c:	333c      	addlt	r3, #60	; 0x3c
   3032e:	f101 31ff 	addlt.w	r1, r1, #4294967295	; 0xffffffff
   30332:	e9c4 3101 	strdlt	r3, r1, [r4, #4]
   30336:	6063      	strge	r3, [r4, #4]
   30338:	e737      	b.n	301aa <validate_structure+0x1a>
   3033a:	223c      	movs	r2, #60	; 0x3c
   3033c:	4668      	mov	r0, sp
   3033e:	f000 fc7f 	bl	30c40 <div>
   30342:	e9dd 2300 	ldrd	r2, r3, [sp]
   30346:	6861      	ldr	r1, [r4, #4]
   30348:	2b00      	cmp	r3, #0
   3034a:	4411      	add	r1, r2
   3034c:	6061      	str	r1, [r4, #4]
   3034e:	bfbd      	ittte	lt
   30350:	333c      	addlt	r3, #60	; 0x3c
   30352:	f101 31ff 	addlt.w	r1, r1, #4294967295	; 0xffffffff
   30356:	e9c4 3100 	strdlt	r3, r1, [r4]
   3035a:	6023      	strge	r3, [r4, #0]
   3035c:	e721      	b.n	301a2 <validate_structure+0x12>
   3035e:	201d      	movs	r0, #29
   30360:	e761      	b.n	30226 <validate_structure+0x96>
   30362:	f201 726d 	addw	r2, r1, #1901	; 0x76d
   30366:	fb0e c202 	mla	r2, lr, r2, ip
   3036a:	ebb9 1f32 	cmp.w	r9, r2, ror #4
   3036e:	bf34      	ite	cc
   30370:	201c      	movcc	r0, #28
   30372:	201d      	movcs	r0, #29
   30374:	e795      	b.n	302a2 <validate_structure+0x112>
   30376:	bf00      	nop
   30378:	c28f5c29 	.word	0xc28f5c29
   3037c:	051eb850 	.word	0x051eb850
   30380:	028f5c28 	.word	0x028f5c28
   30384:	00046590 	.word	0x00046590
   30388:	00a3d70a 	.word	0x00a3d70a

0003038c <mktime>:
   3038c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   30390:	b08d      	sub	sp, #52	; 0x34
   30392:	4605      	mov	r5, r0
   30394:	f000 fcbc 	bl	30d10 <__gettzinfo>
   30398:	4607      	mov	r7, r0
   3039a:	4628      	mov	r0, r5
   3039c:	f7ff fef8 	bl	30190 <validate_structure>
   303a0:	692e      	ldr	r6, [r5, #16]
   303a2:	4bcc      	ldr	r3, [pc, #816]	; (306d4 <mktime+0x348>)
   303a4:	6868      	ldr	r0, [r5, #4]
   303a6:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
   303aa:	682a      	ldr	r2, [r5, #0]
   303ac:	68eb      	ldr	r3, [r5, #12]
   303ae:	68a9      	ldr	r1, [r5, #8]
   303b0:	ebc0 1000 	rsb	r0, r0, r0, lsl #4
   303b4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
   303b8:	f44f 6a61 	mov.w	sl, #3600	; 0xe10
   303bc:	3b01      	subs	r3, #1
   303be:	2e01      	cmp	r6, #1
   303c0:	fb0a 0a01 	mla	sl, sl, r1, r0
   303c4:	696e      	ldr	r6, [r5, #20]
   303c6:	441c      	add	r4, r3
   303c8:	dd02      	ble.n	303d0 <mktime+0x44>
   303ca:	07b1      	lsls	r1, r6, #30
   303cc:	f000 80ce 	beq.w	3056c <mktime+0x1e0>
   303d0:	f506 531c 	add.w	r3, r6, #9984	; 0x2700
   303d4:	3310      	adds	r3, #16
   303d6:	f644 6220 	movw	r2, #20000	; 0x4e20
   303da:	4293      	cmp	r3, r2
   303dc:	61ec      	str	r4, [r5, #28]
   303de:	f200 81a6 	bhi.w	3072e <mktime+0x3a2>
   303e2:	2e46      	cmp	r6, #70	; 0x46
   303e4:	f300 80a2 	bgt.w	3052c <mktime+0x1a0>
   303e8:	d043      	beq.n	30472 <mktime+0xe6>
   303ea:	2e45      	cmp	r6, #69	; 0x45
   303ec:	f000 815b 	beq.w	306a6 <mktime+0x31a>
   303f0:	48b9      	ldr	r0, [pc, #740]	; (306d8 <mktime+0x34c>)
   303f2:	49ba      	ldr	r1, [pc, #744]	; (306dc <mktime+0x350>)
   303f4:	f8df e2e8 	ldr.w	lr, [pc, #744]	; 306e0 <mktime+0x354>
   303f8:	f8df 92e8 	ldr.w	r9, [pc, #744]	; 306e4 <mktime+0x358>
   303fc:	2345      	movs	r3, #69	; 0x45
   303fe:	f240 186d 	movw	r8, #365	; 0x16d
   30402:	e012      	b.n	3042a <mktime+0x9e>
   30404:	f203 726c 	addw	r2, r3, #1900	; 0x76c
   30408:	ebbe 0fbc 	cmp.w	lr, ip, ror #2
   3040c:	fb00 1202 	mla	r2, r0, r2, r1
   30410:	f0c0 80f7 	bcc.w	30602 <mktime+0x276>
   30414:	ebb9 1f32 	cmp.w	r9, r2, ror #4
   30418:	bf34      	ite	cc
   3041a:	4642      	movcc	r2, r8
   3041c:	f44f 72b7 	movcs.w	r2, #366	; 0x16e
   30420:	3b01      	subs	r3, #1
   30422:	42b3      	cmp	r3, r6
   30424:	eba4 0402 	sub.w	r4, r4, r2
   30428:	d00a      	beq.n	30440 <mktime+0xb4>
   3042a:	079a      	lsls	r2, r3, #30
   3042c:	fb00 1c03 	mla	ip, r0, r3, r1
   30430:	d0e8      	beq.n	30404 <mktime+0x78>
   30432:	3b01      	subs	r3, #1
   30434:	f240 126d 	movw	r2, #365	; 0x16d
   30438:	42b3      	cmp	r3, r6
   3043a:	eba4 0402 	sub.w	r4, r4, r2
   3043e:	d1f4      	bne.n	3042a <mktime+0x9e>
   30440:	07b0      	lsls	r0, r6, #30
   30442:	f040 8130 	bne.w	306a6 <mktime+0x31a>
   30446:	48a4      	ldr	r0, [pc, #656]	; (306d8 <mktime+0x34c>)
   30448:	4aa4      	ldr	r2, [pc, #656]	; (306dc <mktime+0x350>)
   3044a:	4ba5      	ldr	r3, [pc, #660]	; (306e0 <mktime+0x354>)
   3044c:	fb00 2106 	mla	r1, r0, r6, r2
   30450:	ebb3 0fb1 	cmp.w	r3, r1, ror #2
   30454:	f0c0 813a 	bcc.w	306cc <mktime+0x340>
   30458:	49a2      	ldr	r1, [pc, #648]	; (306e4 <mktime+0x358>)
   3045a:	f206 736c 	addw	r3, r6, #1900	; 0x76c
   3045e:	fb00 2303 	mla	r3, r0, r3, r2
   30462:	ebb1 1f33 	cmp.w	r1, r3, ror #4
   30466:	f240 136d 	movw	r3, #365	; 0x16d
   3046a:	bf28      	it	cs
   3046c:	f44f 73b7 	movcs.w	r3, #366	; 0x16e
   30470:	1ae4      	subs	r4, r4, r3
   30472:	4b9d      	ldr	r3, [pc, #628]	; (306e8 <mktime+0x35c>)
   30474:	ea4f 7bea 	mov.w	fp, sl, asr #31
   30478:	fbc3 ab04 	smlal	sl, fp, r3, r4
   3047c:	f000 fa3a 	bl	308f4 <__tz_lock>
   30480:	f000 fa44 	bl	3090c <_tzset_unlocked>
   30484:	4b99      	ldr	r3, [pc, #612]	; (306ec <mktime+0x360>)
   30486:	f8d3 8000 	ldr.w	r8, [r3]
   3048a:	f1b8 0f00 	cmp.w	r8, #0
   3048e:	f000 8094 	beq.w	305ba <mktime+0x22e>
   30492:	f8d5 9020 	ldr.w	r9, [r5, #32]
   30496:	6968      	ldr	r0, [r5, #20]
   30498:	687b      	ldr	r3, [r7, #4]
   3049a:	f1b9 0f01 	cmp.w	r9, #1
   3049e:	f200 706c 	addw	r0, r0, #1900	; 0x76c
   304a2:	46c8      	mov	r8, r9
   304a4:	bfa8      	it	ge
   304a6:	f04f 0801 	movge.w	r8, #1
   304aa:	4283      	cmp	r3, r0
   304ac:	d002      	beq.n	304b4 <mktime+0x128>
   304ae:	f000 f957 	bl	30760 <__tzcalc_limits>
   304b2:	b350      	cbz	r0, 3050a <mktime+0x17e>
   304b4:	e9d7 2312 	ldrd	r2, r3, [r7, #72]	; 0x48
   304b8:	f8d7 c028 	ldr.w	ip, [r7, #40]	; 0x28
   304bc:	f8d7 e050 	ldr.w	lr, [r7, #80]	; 0x50
   304c0:	4660      	mov	r0, ip
   304c2:	17c1      	asrs	r1, r0, #31
   304c4:	e9cd 2306 	strd	r2, r3, [sp, #24]
   304c8:	ebb2 020c 	subs.w	r2, r2, ip
   304cc:	eb63 73ec 	sbc.w	r3, r3, ip, asr #31
   304d0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   304d4:	4592      	cmp	sl, r2
   304d6:	4670      	mov	r0, lr
   304d8:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
   304dc:	ea4f 71e0 	mov.w	r1, r0, asr #31
   304e0:	eb7b 0303 	sbcs.w	r3, fp, r3
   304e4:	e9cd 0100 	strd	r0, r1, [sp]
   304e8:	db4d      	blt.n	30586 <mktime+0x1fa>
   304ea:	e9dd 1200 	ldrd	r1, r2, [sp]
   304ee:	9806      	ldr	r0, [sp, #24]
   304f0:	1a43      	subs	r3, r0, r1
   304f2:	9308      	str	r3, [sp, #32]
   304f4:	4613      	mov	r3, r2
   304f6:	9a07      	ldr	r2, [sp, #28]
   304f8:	eb62 0303 	sbc.w	r3, r2, r3
   304fc:	9309      	str	r3, [sp, #36]	; 0x24
   304fe:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
   30502:	4592      	cmp	sl, r2
   30504:	eb7b 0303 	sbcs.w	r3, fp, r3
   30508:	da3d      	bge.n	30586 <mktime+0x1fa>
   3050a:	f1b8 0f01 	cmp.w	r8, #1
   3050e:	d154      	bne.n	305ba <mktime+0x22e>
   30510:	6d3a      	ldr	r2, [r7, #80]	; 0x50
   30512:	4610      	mov	r0, r2
   30514:	17d1      	asrs	r1, r2, #31
   30516:	e9cd 0100 	strd	r0, r1, [sp]
   3051a:	e9dd 1200 	ldrd	r1, r2, [sp]
   3051e:	eb1a 0001 	adds.w	r0, sl, r1
   30522:	eb4b 0102 	adc.w	r1, fp, r2
   30526:	f04f 0801 	mov.w	r8, #1
   3052a:	e051      	b.n	305d0 <mktime+0x244>
   3052c:	496a      	ldr	r1, [pc, #424]	; (306d8 <mktime+0x34c>)
   3052e:	486c      	ldr	r0, [pc, #432]	; (306e0 <mktime+0x354>)
   30530:	f8df e1b0 	ldr.w	lr, [pc, #432]	; 306e4 <mktime+0x358>
   30534:	2346      	movs	r3, #70	; 0x46
   30536:	f240 1c6d 	movw	ip, #365	; 0x16d
   3053a:	e010      	b.n	3055e <mktime+0x1d2>
   3053c:	f203 726c 	addw	r2, r3, #1900	; 0x76c
   30540:	ebb0 0fb8 	cmp.w	r0, r8, ror #2
   30544:	fb01 f202 	mul.w	r2, r1, r2
   30548:	d31a      	bcc.n	30580 <mktime+0x1f4>
   3054a:	ebbe 1f32 	cmp.w	lr, r2, ror #4
   3054e:	bf34      	ite	cc
   30550:	4662      	movcc	r2, ip
   30552:	f44f 72b7 	movcs.w	r2, #366	; 0x16e
   30556:	3301      	adds	r3, #1
   30558:	42b3      	cmp	r3, r6
   3055a:	4414      	add	r4, r2
   3055c:	d089      	beq.n	30472 <mktime+0xe6>
   3055e:	079a      	lsls	r2, r3, #30
   30560:	fb01 f803 	mul.w	r8, r1, r3
   30564:	d0ea      	beq.n	3053c <mktime+0x1b0>
   30566:	f240 126d 	movw	r2, #365	; 0x16d
   3056a:	e7f4      	b.n	30556 <mktime+0x1ca>
   3056c:	485a      	ldr	r0, [pc, #360]	; (306d8 <mktime+0x34c>)
   3056e:	4a5b      	ldr	r2, [pc, #364]	; (306dc <mktime+0x350>)
   30570:	4b5b      	ldr	r3, [pc, #364]	; (306e0 <mktime+0x354>)
   30572:	fb00 2106 	mla	r1, r0, r6, r2
   30576:	ebb3 0fb1 	cmp.w	r3, r1, ror #2
   3057a:	d245      	bcs.n	30608 <mktime+0x27c>
   3057c:	3401      	adds	r4, #1
   3057e:	e727      	b.n	303d0 <mktime+0x44>
   30580:	f44f 72b7 	mov.w	r2, #366	; 0x16e
   30584:	e7e7      	b.n	30556 <mktime+0x1ca>
   30586:	e9d7 1008 	ldrd	r1, r0, [r7, #32]
   3058a:	9b00      	ldr	r3, [sp, #0]
   3058c:	f8d7 8000 	ldr.w	r8, [r7]
   30590:	1ac9      	subs	r1, r1, r3
   30592:	9b01      	ldr	r3, [sp, #4]
   30594:	9104      	str	r1, [sp, #16]
   30596:	eb60 0303 	sbc.w	r3, r0, r3
   3059a:	9305      	str	r3, [sp, #20]
   3059c:	e9dd 2304 	ldrd	r2, r3, [sp, #16]
   305a0:	f1b8 0f00 	cmp.w	r8, #0
   305a4:	d03a      	beq.n	3061c <mktime+0x290>
   305a6:	4592      	cmp	sl, r2
   305a8:	eb7b 0303 	sbcs.w	r3, fp, r3
   305ac:	da7e      	bge.n	306ac <mktime+0x320>
   305ae:	f1b9 0f00 	cmp.w	r9, #0
   305b2:	dc40      	bgt.n	30636 <mktime+0x2aa>
   305b4:	f04f 0800 	mov.w	r8, #0
   305b8:	e004      	b.n	305c4 <mktime+0x238>
   305ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
   305bc:	4610      	mov	r0, r2
   305be:	17d1      	asrs	r1, r2, #31
   305c0:	e9cd 0102 	strd	r0, r1, [sp, #8]
   305c4:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
   305c8:	eb1a 0001 	adds.w	r0, sl, r1
   305cc:	eb4b 0102 	adc.w	r1, fp, r2
   305d0:	9102      	str	r1, [sp, #8]
   305d2:	9000      	str	r0, [sp, #0]
   305d4:	f000 f994 	bl	30900 <__tz_unlock>
   305d8:	4b45      	ldr	r3, [pc, #276]	; (306f0 <mktime+0x364>)
   305da:	9800      	ldr	r0, [sp, #0]
   305dc:	9902      	ldr	r1, [sp, #8]
   305de:	f8c5 8020 	str.w	r8, [r5, #32]
   305e2:	3404      	adds	r4, #4
   305e4:	fb83 2304 	smull	r2, r3, r3, r4
   305e8:	191a      	adds	r2, r3, r4
   305ea:	17e3      	asrs	r3, r4, #31
   305ec:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
   305f0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   305f4:	1ae3      	subs	r3, r4, r3
   305f6:	bf48      	it	mi
   305f8:	3307      	addmi	r3, #7
   305fa:	61ab      	str	r3, [r5, #24]
   305fc:	b00d      	add	sp, #52	; 0x34
   305fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30602:	f44f 72b7 	mov.w	r2, #366	; 0x16e
   30606:	e70b      	b.n	30420 <mktime+0x94>
   30608:	4936      	ldr	r1, [pc, #216]	; (306e4 <mktime+0x358>)
   3060a:	f206 736c 	addw	r3, r6, #1900	; 0x76c
   3060e:	fb00 2303 	mla	r3, r0, r3, r2
   30612:	ebb1 1f33 	cmp.w	r1, r3, ror #4
   30616:	f4ff aedb 	bcc.w	303d0 <mktime+0x44>
   3061a:	e7af      	b.n	3057c <mktime+0x1f0>
   3061c:	4592      	cmp	sl, r2
   3061e:	eb7b 0303 	sbcs.w	r3, fp, r3
   30622:	da4a      	bge.n	306ba <mktime+0x32e>
   30624:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   30628:	4592      	cmp	sl, r2
   3062a:	eb7b 0303 	sbcs.w	r3, fp, r3
   3062e:	db44      	blt.n	306ba <mktime+0x32e>
   30630:	f1b9 0f00 	cmp.w	r9, #0
   30634:	ddc6      	ble.n	305c4 <mktime+0x238>
   30636:	ebae 0c0c 	sub.w	ip, lr, ip
   3063a:	f04f 0800 	mov.w	r8, #0
   3063e:	682b      	ldr	r3, [r5, #0]
   30640:	f8d5 900c 	ldr.w	r9, [r5, #12]
   30644:	4463      	add	r3, ip
   30646:	eb1a 0a0c 	adds.w	sl, sl, ip
   3064a:	602b      	str	r3, [r5, #0]
   3064c:	4628      	mov	r0, r5
   3064e:	eb4b 7bec 	adc.w	fp, fp, ip, asr #31
   30652:	f7ff fd9d 	bl	30190 <validate_structure>
   30656:	68ea      	ldr	r2, [r5, #12]
   30658:	ebb2 0209 	subs.w	r2, r2, r9
   3065c:	f43f af55 	beq.w	3050a <mktime+0x17e>
   30660:	2a01      	cmp	r2, #1
   30662:	dd60      	ble.n	30726 <mktime+0x39a>
   30664:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   30668:	69eb      	ldr	r3, [r5, #28]
   3066a:	4414      	add	r4, r2
   3066c:	18d2      	adds	r2, r2, r3
   3066e:	d441      	bmi.n	306f4 <mktime+0x368>
   30670:	07b3      	lsls	r3, r6, #30
   30672:	d160      	bne.n	30736 <mktime+0x3aa>
   30674:	4818      	ldr	r0, [pc, #96]	; (306d8 <mktime+0x34c>)
   30676:	4919      	ldr	r1, [pc, #100]	; (306dc <mktime+0x350>)
   30678:	4b19      	ldr	r3, [pc, #100]	; (306e0 <mktime+0x354>)
   3067a:	fb00 1c06 	mla	ip, r0, r6, r1
   3067e:	ebb3 0fbc 	cmp.w	r3, ip, ror #2
   30682:	d35e      	bcc.n	30742 <mktime+0x3b6>
   30684:	f206 736c 	addw	r3, r6, #1900	; 0x76c
   30688:	4e16      	ldr	r6, [pc, #88]	; (306e4 <mktime+0x358>)
   3068a:	fb00 1303 	mla	r3, r0, r3, r1
   3068e:	ebb6 1f33 	cmp.w	r6, r3, ror #4
   30692:	f240 136d 	movw	r3, #365	; 0x16d
   30696:	bf28      	it	cs
   30698:	f44f 73b7 	movcs.w	r3, #366	; 0x16e
   3069c:	429a      	cmp	r2, r3
   3069e:	bfa8      	it	ge
   306a0:	1ad2      	subge	r2, r2, r3
   306a2:	61ea      	str	r2, [r5, #28]
   306a4:	e731      	b.n	3050a <mktime+0x17e>
   306a6:	f240 136d 	movw	r3, #365	; 0x16d
   306aa:	e6e1      	b.n	30470 <mktime+0xe4>
   306ac:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
   306b0:	4592      	cmp	sl, r2
   306b2:	eb7b 0303 	sbcs.w	r3, fp, r3
   306b6:	f6bf af7a 	bge.w	305ae <mktime+0x222>
   306ba:	f1b9 0f00 	cmp.w	r9, #0
   306be:	f47f af2c 	bne.w	3051a <mktime+0x18e>
   306c2:	ebac 0c0e 	sub.w	ip, ip, lr
   306c6:	f04f 0801 	mov.w	r8, #1
   306ca:	e7b8      	b.n	3063e <mktime+0x2b2>
   306cc:	f44f 73b7 	mov.w	r3, #366	; 0x16e
   306d0:	e6ce      	b.n	30470 <mktime+0xe4>
   306d2:	bf00      	nop
   306d4:	000465c0 	.word	0x000465c0
   306d8:	c28f5c29 	.word	0xc28f5c29
   306dc:	051eb850 	.word	0x051eb850
   306e0:	028f5c28 	.word	0x028f5c28
   306e4:	00a3d70a 	.word	0x00a3d70a
   306e8:	00015180 	.word	0x00015180
   306ec:	1000be98 	.word	0x1000be98
   306f0:	92492493 	.word	0x92492493
   306f4:	1e73      	subs	r3, r6, #1
   306f6:	079a      	lsls	r2, r3, #30
   306f8:	d120      	bne.n	3073c <mktime+0x3b0>
   306fa:	4915      	ldr	r1, [pc, #84]	; (30750 <mktime+0x3c4>)
   306fc:	4a15      	ldr	r2, [pc, #84]	; (30754 <mktime+0x3c8>)
   306fe:	4816      	ldr	r0, [pc, #88]	; (30758 <mktime+0x3cc>)
   30700:	fb01 2303 	mla	r3, r1, r3, r2
   30704:	ebb0 0fb3 	cmp.w	r0, r3, ror #2
   30708:	d31e      	bcc.n	30748 <mktime+0x3bc>
   3070a:	4814      	ldr	r0, [pc, #80]	; (3075c <mktime+0x3d0>)
   3070c:	f206 736b 	addw	r3, r6, #1899	; 0x76b
   30710:	fb01 2303 	mla	r3, r1, r3, r2
   30714:	ebb0 1f33 	cmp.w	r0, r3, ror #4
   30718:	f240 136d 	movw	r3, #365	; 0x16d
   3071c:	bf38      	it	cc
   3071e:	f44f 73b6 	movcc.w	r3, #364	; 0x16c
   30722:	61eb      	str	r3, [r5, #28]
   30724:	e6f1      	b.n	3050a <mktime+0x17e>
   30726:	1c91      	adds	r1, r2, #2
   30728:	bfd8      	it	le
   3072a:	2201      	movle	r2, #1
   3072c:	e79c      	b.n	30668 <mktime+0x2dc>
   3072e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   30732:	4601      	mov	r1, r0
   30734:	e762      	b.n	305fc <mktime+0x270>
   30736:	f240 136d 	movw	r3, #365	; 0x16d
   3073a:	e7af      	b.n	3069c <mktime+0x310>
   3073c:	f44f 73b6 	mov.w	r3, #364	; 0x16c
   30740:	e7ef      	b.n	30722 <mktime+0x396>
   30742:	f44f 73b7 	mov.w	r3, #366	; 0x16e
   30746:	e7a9      	b.n	3069c <mktime+0x310>
   30748:	f240 136d 	movw	r3, #365	; 0x16d
   3074c:	e7e9      	b.n	30722 <mktime+0x396>
   3074e:	bf00      	nop
   30750:	c28f5c29 	.word	0xc28f5c29
   30754:	051eb850 	.word	0x051eb850
   30758:	028f5c28 	.word	0x028f5c28
   3075c:	00a3d70a 	.word	0x00a3d70a

00030760 <__tzcalc_limits>:
   30760:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   30764:	b083      	sub	sp, #12
   30766:	4607      	mov	r7, r0
   30768:	f000 fad2 	bl	30d10 <__gettzinfo>
   3076c:	f240 73b1 	movw	r3, #1969	; 0x7b1
   30770:	429f      	cmp	r7, r3
   30772:	f340 80a9 	ble.w	308c8 <__tzcalc_limits+0x168>
   30776:	495b      	ldr	r1, [pc, #364]	; (308e4 <__tzcalc_limits+0x184>)
   30778:	f8df e174 	ldr.w	lr, [pc, #372]	; 308f0 <__tzcalc_limits+0x190>
   3077c:	6047      	str	r7, [r0, #4]
   3077e:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
   30782:	f2a7 736d 	subw	r3, r7, #1901	; 0x76d
   30786:	18ba      	adds	r2, r7, r2
   30788:	fb81 4c03 	smull	r4, ip, r1, r3
   3078c:	f240 166d 	movw	r6, #365	; 0x16d
   30790:	1094      	asrs	r4, r2, #2
   30792:	17db      	asrs	r3, r3, #31
   30794:	f2a7 72b2 	subw	r2, r7, #1970	; 0x7b2
   30798:	fb81 8507 	smull	r8, r5, r1, r7
   3079c:	fb06 4202 	mla	r2, r6, r2, r4
   307a0:	eba3 136c 	sub.w	r3, r3, ip, asr #5
   307a4:	f46f 64c8 	mvn.w	r4, #1600	; 0x640
   307a8:	ea4f 7ce7 	mov.w	ip, r7, asr #31
   307ac:	ebcc 16e5 	rsb	r6, ip, r5, asr #7
   307b0:	4413      	add	r3, r2
   307b2:	193c      	adds	r4, r7, r4
   307b4:	f44f 72c8 	mov.w	r2, #400	; 0x190
   307b8:	fb02 7616 	mls	r6, r2, r6, r7
   307bc:	fba1 1404 	umull	r1, r4, r1, r4
   307c0:	ebcc 1565 	rsb	r5, ip, r5, asr #5
   307c4:	2264      	movs	r2, #100	; 0x64
   307c6:	eb03 14d4 	add.w	r4, r3, r4, lsr #7
   307ca:	f007 0803 	and.w	r8, r7, #3
   307ce:	2e00      	cmp	r6, #0
   307d0:	bf0c      	ite	eq
   307d2:	2330      	moveq	r3, #48	; 0x30
   307d4:	2300      	movne	r3, #0
   307d6:	fb02 7515 	mls	r5, r2, r5, r7
   307da:	9301      	str	r3, [sp, #4]
   307dc:	4601      	mov	r1, r0
   307de:	f100 0c50 	add.w	ip, r0, #80	; 0x50
   307e2:	4647      	mov	r7, r8
   307e4:	7a0b      	ldrb	r3, [r1, #8]
   307e6:	2b4a      	cmp	r3, #74	; 0x4a
   307e8:	d01e      	beq.n	30828 <__tzcalc_limits+0xc8>
   307ea:	2b44      	cmp	r3, #68	; 0x44
   307ec:	d12c      	bne.n	30848 <__tzcalc_limits+0xe8>
   307ee:	694a      	ldr	r2, [r1, #20]
   307f0:	eb04 0802 	add.w	r8, r4, r2
   307f4:	698a      	ldr	r2, [r1, #24]
   307f6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   307f8:	fb0e 2208 	mla	r2, lr, r8, r2
   307fc:	441a      	add	r2, r3
   307fe:	17d3      	asrs	r3, r2, #31
   30800:	e9c1 2308 	strd	r2, r3, [r1, #32]
   30804:	3128      	adds	r1, #40	; 0x28
   30806:	458c      	cmp	ip, r1
   30808:	d1ec      	bne.n	307e4 <__tzcalc_limits+0x84>
   3080a:	e9d0 4508 	ldrd	r4, r5, [r0, #32]
   3080e:	e9d0 2312 	ldrd	r2, r3, [r0, #72]	; 0x48
   30812:	4294      	cmp	r4, r2
   30814:	eb75 0303 	sbcs.w	r3, r5, r3
   30818:	bfb4      	ite	lt
   3081a:	2301      	movlt	r3, #1
   3081c:	2300      	movge	r3, #0
   3081e:	6003      	str	r3, [r0, #0]
   30820:	2001      	movs	r0, #1
   30822:	b003      	add	sp, #12
   30824:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30828:	694b      	ldr	r3, [r1, #20]
   3082a:	191a      	adds	r2, r3, r4
   3082c:	b937      	cbnz	r7, 3083c <__tzcalc_limits+0xdc>
   3082e:	b12d      	cbz	r5, 3083c <__tzcalc_limits+0xdc>
   30830:	2b3b      	cmp	r3, #59	; 0x3b
   30832:	bfc8      	it	gt
   30834:	3201      	addgt	r2, #1
   30836:	f102 38ff 	add.w	r8, r2, #4294967295	; 0xffffffff
   3083a:	e7db      	b.n	307f4 <__tzcalc_limits+0x94>
   3083c:	2e00      	cmp	r6, #0
   3083e:	d1fa      	bne.n	30836 <__tzcalc_limits+0xd6>
   30840:	2b3b      	cmp	r3, #59	; 0x3b
   30842:	bfc8      	it	gt
   30844:	3201      	addgt	r2, #1
   30846:	e7f6      	b.n	30836 <__tzcalc_limits+0xd6>
   30848:	2f00      	cmp	r7, #0
   3084a:	d041      	beq.n	308d0 <__tzcalc_limits+0x170>
   3084c:	f8dd 9004 	ldr.w	r9, [sp, #4]
   30850:	68cb      	ldr	r3, [r1, #12]
   30852:	4a25      	ldr	r2, [pc, #148]	; (308e8 <__tzcalc_limits+0x188>)
   30854:	2b01      	cmp	r3, #1
   30856:	4491      	add	r9, r2
   30858:	dd41      	ble.n	308de <__tzcalc_limits+0x17e>
   3085a:	ea4f 0b83 	mov.w	fp, r3, lsl #2
   3085e:	f1ab 0a08 	sub.w	sl, fp, #8
   30862:	44ca      	add	sl, r9
   30864:	f1a9 0304 	sub.w	r3, r9, #4
   30868:	4622      	mov	r2, r4
   3086a:	4688      	mov	r8, r1
   3086c:	f853 1f04 	ldr.w	r1, [r3, #4]!
   30870:	459a      	cmp	sl, r3
   30872:	440a      	add	r2, r1
   30874:	d1fa      	bne.n	3086c <__tzcalc_limits+0x10c>
   30876:	f1ab 0b04 	sub.w	fp, fp, #4
   3087a:	4641      	mov	r1, r8
   3087c:	44d9      	add	r9, fp
   3087e:	4b1b      	ldr	r3, [pc, #108]	; (308ec <__tzcalc_limits+0x18c>)
   30880:	f8d9 9000 	ldr.w	r9, [r9]
   30884:	f102 0804 	add.w	r8, r2, #4
   30888:	fb83 a308 	smull	sl, r3, r3, r8
   3088c:	eb03 0a08 	add.w	sl, r3, r8
   30890:	ea4f 73e8 	mov.w	r3, r8, asr #31
   30894:	ebc3 03aa 	rsb	r3, r3, sl, asr #2
   30898:	ebc3 0ac3 	rsb	sl, r3, r3, lsl #3
   3089c:	694b      	ldr	r3, [r1, #20]
   3089e:	eba8 080a 	sub.w	r8, r8, sl
   308a2:	ebb3 0808 	subs.w	r8, r3, r8
   308a6:	690b      	ldr	r3, [r1, #16]
   308a8:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   308ac:	bf48      	it	mi
   308ae:	f108 0807 	addmi.w	r8, r8, #7
   308b2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
   308b6:	4498      	add	r8, r3
   308b8:	45c8      	cmp	r8, r9
   308ba:	db03      	blt.n	308c4 <__tzcalc_limits+0x164>
   308bc:	f1a8 0807 	sub.w	r8, r8, #7
   308c0:	45c8      	cmp	r8, r9
   308c2:	dafb      	bge.n	308bc <__tzcalc_limits+0x15c>
   308c4:	4490      	add	r8, r2
   308c6:	e795      	b.n	307f4 <__tzcalc_limits+0x94>
   308c8:	2000      	movs	r0, #0
   308ca:	b003      	add	sp, #12
   308cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   308d0:	9b01      	ldr	r3, [sp, #4]
   308d2:	2d00      	cmp	r5, #0
   308d4:	bf0c      	ite	eq
   308d6:	4699      	moveq	r9, r3
   308d8:	f04f 0930 	movne.w	r9, #48	; 0x30
   308dc:	e7b8      	b.n	30850 <__tzcalc_limits+0xf0>
   308de:	4622      	mov	r2, r4
   308e0:	e7cd      	b.n	3087e <__tzcalc_limits+0x11e>
   308e2:	bf00      	nop
   308e4:	51eb851f 	.word	0x51eb851f
   308e8:	00046644 	.word	0x00046644
   308ec:	92492493 	.word	0x92492493
   308f0:	00015180 	.word	0x00015180

000308f4 <__tz_lock>:
   308f4:	4801      	ldr	r0, [pc, #4]	; (308fc <__tz_lock+0x8>)
   308f6:	f000 ba0f 	b.w	30d18 <__retarget_lock_acquire>
   308fa:	bf00      	nop
   308fc:	100118d8 	.word	0x100118d8

00030900 <__tz_unlock>:
   30900:	4801      	ldr	r0, [pc, #4]	; (30908 <__tz_unlock+0x8>)
   30902:	f000 ba0d 	b.w	30d20 <__retarget_lock_release>
   30906:	bf00      	nop
   30908:	100118d8 	.word	0x100118d8

0003090c <_tzset_unlocked>:
   3090c:	4b01      	ldr	r3, [pc, #4]	; (30914 <_tzset_unlocked+0x8>)
   3090e:	6818      	ldr	r0, [r3, #0]
   30910:	f000 b802 	b.w	30918 <_tzset_unlocked_r>
   30914:	10002d7c 	.word	0x10002d7c

00030918 <_tzset_unlocked_r>:
   30918:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3091c:	b08b      	sub	sp, #44	; 0x2c
   3091e:	4606      	mov	r6, r0
   30920:	f000 f9f6 	bl	30d10 <__gettzinfo>
   30924:	49ba      	ldr	r1, [pc, #744]	; (30c10 <_tzset_unlocked_r+0x2f8>)
   30926:	4604      	mov	r4, r0
   30928:	4630      	mov	r0, r6
   3092a:	f000 f9e9 	bl	30d00 <_getenv_r>
   3092e:	4605      	mov	r5, r0
   30930:	2800      	cmp	r0, #0
   30932:	f000 8103 	beq.w	30b3c <_tzset_unlocked_r+0x224>
   30936:	4fb7      	ldr	r7, [pc, #732]	; (30c14 <_tzset_unlocked_r+0x2fc>)
   30938:	6839      	ldr	r1, [r7, #0]
   3093a:	b129      	cbz	r1, 30948 <_tzset_unlocked_r+0x30>
   3093c:	f7e7 fdb4 	bl	184a8 <strcmp>
   30940:	2800      	cmp	r0, #0
   30942:	f000 80e0 	beq.w	30b06 <_tzset_unlocked_r+0x1ee>
   30946:	6839      	ldr	r1, [r7, #0]
   30948:	4608      	mov	r0, r1
   3094a:	f000 f9f5 	bl	30d38 <free>
   3094e:	4628      	mov	r0, r5
   30950:	f7e7 fd36 	bl	183c0 <strlen>
   30954:	1c41      	adds	r1, r0, #1
   30956:	4630      	mov	r0, r6
   30958:	f000 f9f6 	bl	30d48 <_malloc_r>
   3095c:	6038      	str	r0, [r7, #0]
   3095e:	b110      	cbz	r0, 30966 <_tzset_unlocked_r+0x4e>
   30960:	4629      	mov	r1, r5
   30962:	f000 fcf7 	bl	31354 <strcpy>
   30966:	782b      	ldrb	r3, [r5, #0]
   30968:	4aab      	ldr	r2, [pc, #684]	; (30c18 <_tzset_unlocked_r+0x300>)
   3096a:	49ac      	ldr	r1, [pc, #688]	; (30c1c <_tzset_unlocked_r+0x304>)
   3096c:	2b3a      	cmp	r3, #58	; 0x3a
   3096e:	bf08      	it	eq
   30970:	3501      	addeq	r5, #1
   30972:	ab08      	add	r3, sp, #32
   30974:	4628      	mov	r0, r5
   30976:	f000 fcbf 	bl	312f8 <siscanf>
   3097a:	2800      	cmp	r0, #0
   3097c:	f340 80c3 	ble.w	30b06 <_tzset_unlocked_r+0x1ee>
   30980:	9808      	ldr	r0, [sp, #32]
   30982:	5c2b      	ldrb	r3, [r5, r0]
   30984:	2b2d      	cmp	r3, #45	; 0x2d
   30986:	4405      	add	r5, r0
   30988:	f000 80c0 	beq.w	30b0c <_tzset_unlocked_r+0x1f4>
   3098c:	2b2b      	cmp	r3, #43	; 0x2b
   3098e:	bf08      	it	eq
   30990:	3501      	addeq	r5, #1
   30992:	f04f 0901 	mov.w	r9, #1
   30996:	ab08      	add	r3, sp, #32
   30998:	af06      	add	r7, sp, #24
   3099a:	f10d 0616 	add.w	r6, sp, #22
   3099e:	f04f 0800 	mov.w	r8, #0
   309a2:	499f      	ldr	r1, [pc, #636]	; (30c20 <_tzset_unlocked_r+0x308>)
   309a4:	9303      	str	r3, [sp, #12]
   309a6:	9301      	str	r3, [sp, #4]
   309a8:	aa05      	add	r2, sp, #20
   309aa:	9702      	str	r7, [sp, #8]
   309ac:	9600      	str	r6, [sp, #0]
   309ae:	4628      	mov	r0, r5
   309b0:	f8ad 8016 	strh.w	r8, [sp, #22]
   309b4:	f8ad 8018 	strh.w	r8, [sp, #24]
   309b8:	f000 fc9e 	bl	312f8 <siscanf>
   309bc:	4540      	cmp	r0, r8
   309be:	f340 80a2 	ble.w	30b06 <_tzset_unlocked_r+0x1ee>
   309c2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
   309c6:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   309ca:	f8bd 2014 	ldrh.w	r2, [sp, #20]
   309ce:	9808      	ldr	r0, [sp, #32]
   309d0:	f8df b264 	ldr.w	fp, [pc, #612]	; 30c38 <_tzset_unlocked_r+0x320>
   309d4:	f8df a254 	ldr.w	sl, [pc, #596]	; 30c2c <_tzset_unlocked_r+0x314>
   309d8:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
   309dc:	eb01 0383 	add.w	r3, r1, r3, lsl #2
   309e0:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   309e4:	fb01 3302 	mla	r3, r1, r2, r3
   309e8:	fb09 f303 	mul.w	r3, r9, r3
   309ec:	62a3      	str	r3, [r4, #40]	; 0x28
   309ee:	4405      	add	r5, r0
   309f0:	4b89      	ldr	r3, [pc, #548]	; (30c18 <_tzset_unlocked_r+0x300>)
   309f2:	f8ca 3000 	str.w	r3, [sl]
   309f6:	4989      	ldr	r1, [pc, #548]	; (30c1c <_tzset_unlocked_r+0x304>)
   309f8:	4628      	mov	r0, r5
   309fa:	465a      	mov	r2, fp
   309fc:	ab08      	add	r3, sp, #32
   309fe:	f000 fc7b 	bl	312f8 <siscanf>
   30a02:	4540      	cmp	r0, r8
   30a04:	f340 80ef 	ble.w	30be6 <_tzset_unlocked_r+0x2ce>
   30a08:	9808      	ldr	r0, [sp, #32]
   30a0a:	f8ca b004 	str.w	fp, [sl, #4]
   30a0e:	5c2b      	ldrb	r3, [r5, r0]
   30a10:	2b2d      	cmp	r3, #45	; 0x2d
   30a12:	4405      	add	r5, r0
   30a14:	d07e      	beq.n	30b14 <_tzset_unlocked_r+0x1fc>
   30a16:	2b2b      	cmp	r3, #43	; 0x2b
   30a18:	bf08      	it	eq
   30a1a:	3501      	addeq	r5, #1
   30a1c:	f04f 0801 	mov.w	r8, #1
   30a20:	ab08      	add	r3, sp, #32
   30a22:	f04f 0c00 	mov.w	ip, #0
   30a26:	e9cd 7302 	strd	r7, r3, [sp, #8]
   30a2a:	e9cd 6300 	strd	r6, r3, [sp]
   30a2e:	497c      	ldr	r1, [pc, #496]	; (30c20 <_tzset_unlocked_r+0x308>)
   30a30:	f8ad c014 	strh.w	ip, [sp, #20]
   30a34:	aa05      	add	r2, sp, #20
   30a36:	4628      	mov	r0, r5
   30a38:	f8ad c016 	strh.w	ip, [sp, #22]
   30a3c:	f8ad c018 	strh.w	ip, [sp, #24]
   30a40:	f8cd c020 	str.w	ip, [sp, #32]
   30a44:	f000 fc58 	bl	312f8 <siscanf>
   30a48:	2800      	cmp	r0, #0
   30a4a:	f340 8085 	ble.w	30b58 <_tzset_unlocked_r+0x240>
   30a4e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   30a52:	f8bd 1018 	ldrh.w	r1, [sp, #24]
   30a56:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   30a5a:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
   30a5e:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   30a62:	f44f 6161 	mov.w	r1, #3600	; 0xe10
   30a66:	fb01 2303 	mla	r3, r1, r3, r2
   30a6a:	fb08 f303 	mul.w	r3, r8, r3
   30a6e:	9a08      	ldr	r2, [sp, #32]
   30a70:	f8df b1c8 	ldr.w	fp, [pc, #456]	; 30c3c <_tzset_unlocked_r+0x324>
   30a74:	6523      	str	r3, [r4, #80]	; 0x50
   30a76:	4415      	add	r5, r2
   30a78:	46a1      	mov	r9, r4
   30a7a:	f04f 0a00 	mov.w	sl, #0
   30a7e:	f895 8000 	ldrb.w	r8, [r5]
   30a82:	f1b8 0f2c 	cmp.w	r8, #44	; 0x2c
   30a86:	bf04      	itt	eq
   30a88:	f895 8001 	ldrbeq.w	r8, [r5, #1]
   30a8c:	3501      	addeq	r5, #1
   30a8e:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
   30a92:	d065      	beq.n	30b60 <_tzset_unlocked_r+0x248>
   30a94:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
   30a98:	bf08      	it	eq
   30a9a:	3501      	addeq	r5, #1
   30a9c:	f04f 020a 	mov.w	r2, #10
   30aa0:	a909      	add	r1, sp, #36	; 0x24
   30aa2:	4628      	mov	r0, r5
   30aa4:	bf18      	it	ne
   30aa6:	f04f 0844 	movne.w	r8, #68	; 0x44
   30aaa:	f000 fd8f 	bl	315cc <strtoul>
   30aae:	9b09      	ldr	r3, [sp, #36]	; 0x24
   30ab0:	f8ad 001e 	strh.w	r0, [sp, #30]
   30ab4:	42ab      	cmp	r3, r5
   30ab6:	d034      	beq.n	30b22 <_tzset_unlocked_r+0x20a>
   30ab8:	b280      	uxth	r0, r0
   30aba:	f8c9 0014 	str.w	r0, [r9, #20]
   30abe:	f889 8008 	strb.w	r8, [r9, #8]
   30ac2:	461d      	mov	r5, r3
   30ac4:	2300      	movs	r3, #0
   30ac6:	2202      	movs	r2, #2
   30ac8:	f8ad 2014 	strh.w	r2, [sp, #20]
   30acc:	f8ad 3016 	strh.w	r3, [sp, #22]
   30ad0:	f8ad 3018 	strh.w	r3, [sp, #24]
   30ad4:	9308      	str	r3, [sp, #32]
   30ad6:	782b      	ldrb	r3, [r5, #0]
   30ad8:	2b2f      	cmp	r3, #47	; 0x2f
   30ada:	d069      	beq.n	30bb0 <_tzset_unlocked_r+0x298>
   30adc:	f44f 53e1 	mov.w	r3, #7200	; 0x1c20
   30ae0:	f8c9 3018 	str.w	r3, [r9, #24]
   30ae4:	f109 0928 	add.w	r9, r9, #40	; 0x28
   30ae8:	f1ba 0f00 	cmp.w	sl, #0
   30aec:	d016      	beq.n	30b1c <_tzset_unlocked_r+0x204>
   30aee:	6860      	ldr	r0, [r4, #4]
   30af0:	f7ff fe36 	bl	30760 <__tzcalc_limits>
   30af4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   30af6:	6d23      	ldr	r3, [r4, #80]	; 0x50
   30af8:	484a      	ldr	r0, [pc, #296]	; (30c24 <_tzset_unlocked_r+0x30c>)
   30afa:	494b      	ldr	r1, [pc, #300]	; (30c28 <_tzset_unlocked_r+0x310>)
   30afc:	1a9b      	subs	r3, r3, r2
   30afe:	bf18      	it	ne
   30b00:	2301      	movne	r3, #1
   30b02:	6003      	str	r3, [r0, #0]
   30b04:	600a      	str	r2, [r1, #0]
   30b06:	b00b      	add	sp, #44	; 0x2c
   30b08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30b0c:	3501      	adds	r5, #1
   30b0e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
   30b12:	e740      	b.n	30996 <_tzset_unlocked_r+0x7e>
   30b14:	3501      	adds	r5, #1
   30b16:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   30b1a:	e781      	b.n	30a20 <_tzset_unlocked_r+0x108>
   30b1c:	f04f 0a01 	mov.w	sl, #1
   30b20:	e7ad      	b.n	30a7e <_tzset_unlocked_r+0x166>
   30b22:	f1ba 0f00 	cmp.w	sl, #0
   30b26:	d069      	beq.n	30bfc <_tzset_unlocked_r+0x2e4>
   30b28:	214d      	movs	r1, #77	; 0x4d
   30b2a:	220b      	movs	r2, #11
   30b2c:	f884 1030 	strb.w	r1, [r4, #48]	; 0x30
   30b30:	6362      	str	r2, [r4, #52]	; 0x34
   30b32:	2101      	movs	r1, #1
   30b34:	2200      	movs	r2, #0
   30b36:	e9c4 120e 	strd	r1, r2, [r4, #56]	; 0x38
   30b3a:	e7c2      	b.n	30ac2 <_tzset_unlocked_r+0x1aa>
   30b3c:	4a3a      	ldr	r2, [pc, #232]	; (30c28 <_tzset_unlocked_r+0x310>)
   30b3e:	4c35      	ldr	r4, [pc, #212]	; (30c14 <_tzset_unlocked_r+0x2fc>)
   30b40:	4938      	ldr	r1, [pc, #224]	; (30c24 <_tzset_unlocked_r+0x30c>)
   30b42:	4b3a      	ldr	r3, [pc, #232]	; (30c2c <_tzset_unlocked_r+0x314>)
   30b44:	6015      	str	r5, [r2, #0]
   30b46:	4a3a      	ldr	r2, [pc, #232]	; (30c30 <_tzset_unlocked_r+0x318>)
   30b48:	6820      	ldr	r0, [r4, #0]
   30b4a:	600d      	str	r5, [r1, #0]
   30b4c:	e9c3 2200 	strd	r2, r2, [r3]
   30b50:	f000 f8f2 	bl	30d38 <free>
   30b54:	6025      	str	r5, [r4, #0]
   30b56:	e7d6      	b.n	30b06 <_tzset_unlocked_r+0x1ee>
   30b58:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   30b5a:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
   30b5e:	e786      	b.n	30a6e <_tzset_unlocked_r+0x156>
   30b60:	a908      	add	r1, sp, #32
   30b62:	f10d 021e 	add.w	r2, sp, #30
   30b66:	ab07      	add	r3, sp, #28
   30b68:	e9cd 1201 	strd	r1, r2, [sp, #4]
   30b6c:	9103      	str	r1, [sp, #12]
   30b6e:	9300      	str	r3, [sp, #0]
   30b70:	f10d 021a 	add.w	r2, sp, #26
   30b74:	460b      	mov	r3, r1
   30b76:	4628      	mov	r0, r5
   30b78:	4659      	mov	r1, fp
   30b7a:	f000 fbbd 	bl	312f8 <siscanf>
   30b7e:	2803      	cmp	r0, #3
   30b80:	d1c1      	bne.n	30b06 <_tzset_unlocked_r+0x1ee>
   30b82:	f8bd 301a 	ldrh.w	r3, [sp, #26]
   30b86:	1e5a      	subs	r2, r3, #1
   30b88:	2a0b      	cmp	r2, #11
   30b8a:	d8bc      	bhi.n	30b06 <_tzset_unlocked_r+0x1ee>
   30b8c:	f8bd 201c 	ldrh.w	r2, [sp, #28]
   30b90:	1e51      	subs	r1, r2, #1
   30b92:	2904      	cmp	r1, #4
   30b94:	d8b7      	bhi.n	30b06 <_tzset_unlocked_r+0x1ee>
   30b96:	f8bd 101e 	ldrh.w	r1, [sp, #30]
   30b9a:	2906      	cmp	r1, #6
   30b9c:	d8b3      	bhi.n	30b06 <_tzset_unlocked_r+0x1ee>
   30b9e:	e9c9 3203 	strd	r3, r2, [r9, #12]
   30ba2:	f889 8008 	strb.w	r8, [r9, #8]
   30ba6:	f8c9 1014 	str.w	r1, [r9, #20]
   30baa:	9b08      	ldr	r3, [sp, #32]
   30bac:	441d      	add	r5, r3
   30bae:	e789      	b.n	30ac4 <_tzset_unlocked_r+0x1ac>
   30bb0:	ab08      	add	r3, sp, #32
   30bb2:	e9cd 7302 	strd	r7, r3, [sp, #8]
   30bb6:	e9cd 6300 	strd	r6, r3, [sp]
   30bba:	491e      	ldr	r1, [pc, #120]	; (30c34 <_tzset_unlocked_r+0x31c>)
   30bbc:	aa05      	add	r2, sp, #20
   30bbe:	4628      	mov	r0, r5
   30bc0:	f000 fb9a 	bl	312f8 <siscanf>
   30bc4:	f8bd 2016 	ldrh.w	r2, [sp, #22]
   30bc8:	f8bd 0018 	ldrh.w	r0, [sp, #24]
   30bcc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
   30bd0:	9908      	ldr	r1, [sp, #32]
   30bd2:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
   30bd6:	eb00 0282 	add.w	r2, r0, r2, lsl #2
   30bda:	f44f 6061 	mov.w	r0, #3600	; 0xe10
   30bde:	fb00 2303 	mla	r3, r0, r3, r2
   30be2:	440d      	add	r5, r1
   30be4:	e77c      	b.n	30ae0 <_tzset_unlocked_r+0x1c8>
   30be6:	4910      	ldr	r1, [pc, #64]	; (30c28 <_tzset_unlocked_r+0x310>)
   30be8:	4a0e      	ldr	r2, [pc, #56]	; (30c24 <_tzset_unlocked_r+0x30c>)
   30bea:	6aa0      	ldr	r0, [r4, #40]	; 0x28
   30bec:	f8da 3000 	ldr.w	r3, [sl]
   30bf0:	6008      	str	r0, [r1, #0]
   30bf2:	f8c2 8000 	str.w	r8, [r2]
   30bf6:	f8ca 3004 	str.w	r3, [sl, #4]
   30bfa:	e784      	b.n	30b06 <_tzset_unlocked_r+0x1ee>
   30bfc:	224d      	movs	r2, #77	; 0x4d
   30bfe:	2103      	movs	r1, #3
   30c00:	7222      	strb	r2, [r4, #8]
   30c02:	2202      	movs	r2, #2
   30c04:	e9c4 1203 	strd	r1, r2, [r4, #12]
   30c08:	f8c4 a014 	str.w	sl, [r4, #20]
   30c0c:	e759      	b.n	30ac2 <_tzset_unlocked_r+0x1aa>
   30c0e:	bf00      	nop
   30c10:	000465f0 	.word	0x000465f0
   30c14:	1000be94 	.word	0x1000be94
   30c18:	1000be88 	.word	0x1000be88
   30c1c:	000465f8 	.word	0x000465f8
   30c20:	00046608 	.word	0x00046608
   30c24:	1000be98 	.word	0x1000be98
   30c28:	1000be9c 	.word	0x1000be9c
   30c2c:	100031a8 	.word	0x100031a8
   30c30:	000465f4 	.word	0x000465f4
   30c34:	00046630 	.word	0x00046630
   30c38:	1000be7c 	.word	0x1000be7c
   30c3c:	0004661c 	.word	0x0004661c

00030c40 <div>:
   30c40:	2900      	cmp	r1, #0
   30c42:	b410      	push	{r4}
   30c44:	fb91 f3f2 	sdiv	r3, r1, r2
   30c48:	fb02 1413 	mls	r4, r2, r3, r1
   30c4c:	db0d      	blt.n	30c6a <div+0x2a>
   30c4e:	2c00      	cmp	r4, #0
   30c50:	db04      	blt.n	30c5c <div+0x1c>
   30c52:	e9c0 3400 	strd	r3, r4, [r0]
   30c56:	f85d 4b04 	ldr.w	r4, [sp], #4
   30c5a:	4770      	bx	lr
   30c5c:	1aa4      	subs	r4, r4, r2
   30c5e:	3301      	adds	r3, #1
   30c60:	e9c0 3400 	strd	r3, r4, [r0]
   30c64:	f85d 4b04 	ldr.w	r4, [sp], #4
   30c68:	4770      	bx	lr
   30c6a:	2c00      	cmp	r4, #0
   30c6c:	bfc4      	itt	gt
   30c6e:	18a4      	addgt	r4, r4, r2
   30c70:	f103 33ff 	addgt.w	r3, r3, #4294967295	; 0xffffffff
   30c74:	e9c0 3400 	strd	r3, r4, [r0]
   30c78:	f85d 4b04 	ldr.w	r4, [sp], #4
   30c7c:	4770      	bx	lr
   30c7e:	bf00      	nop

00030c80 <_findenv_r>:
   30c80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   30c84:	f8df 8074 	ldr.w	r8, [pc, #116]	; 30cfc <_findenv_r+0x7c>
   30c88:	4689      	mov	r9, r1
   30c8a:	4617      	mov	r7, r2
   30c8c:	4606      	mov	r6, r0
   30c8e:	f001 feaf 	bl	329f0 <__env_lock>
   30c92:	f8d8 5000 	ldr.w	r5, [r8]
   30c96:	b155      	cbz	r5, 30cae <_findenv_r+0x2e>
   30c98:	f899 3000 	ldrb.w	r3, [r9]
   30c9c:	461c      	mov	r4, r3
   30c9e:	b173      	cbz	r3, 30cbe <_findenv_r+0x3e>
   30ca0:	464c      	mov	r4, r9
   30ca2:	e002      	b.n	30caa <_findenv_r+0x2a>
   30ca4:	f814 3f01 	ldrb.w	r3, [r4, #1]!
   30ca8:	b13b      	cbz	r3, 30cba <_findenv_r+0x3a>
   30caa:	2b3d      	cmp	r3, #61	; 0x3d
   30cac:	d1fa      	bne.n	30ca4 <_findenv_r+0x24>
   30cae:	4630      	mov	r0, r6
   30cb0:	f001 fea4 	bl	329fc <__env_unlock>
   30cb4:	2000      	movs	r0, #0
   30cb6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30cba:	eba4 0409 	sub.w	r4, r4, r9
   30cbe:	6828      	ldr	r0, [r5, #0]
   30cc0:	2800      	cmp	r0, #0
   30cc2:	d0f4      	beq.n	30cae <_findenv_r+0x2e>
   30cc4:	4622      	mov	r2, r4
   30cc6:	4649      	mov	r1, r9
   30cc8:	f000 fba2 	bl	31410 <strncmp>
   30ccc:	b928      	cbnz	r0, 30cda <_findenv_r+0x5a>
   30cce:	682b      	ldr	r3, [r5, #0]
   30cd0:	5d1a      	ldrb	r2, [r3, r4]
   30cd2:	2a3d      	cmp	r2, #61	; 0x3d
   30cd4:	eb03 0a04 	add.w	sl, r3, r4
   30cd8:	d004      	beq.n	30ce4 <_findenv_r+0x64>
   30cda:	f855 0f04 	ldr.w	r0, [r5, #4]!
   30cde:	2800      	cmp	r0, #0
   30ce0:	d1f0      	bne.n	30cc4 <_findenv_r+0x44>
   30ce2:	e7e4      	b.n	30cae <_findenv_r+0x2e>
   30ce4:	f8d8 3000 	ldr.w	r3, [r8]
   30ce8:	1aed      	subs	r5, r5, r3
   30cea:	10ad      	asrs	r5, r5, #2
   30cec:	4630      	mov	r0, r6
   30cee:	603d      	str	r5, [r7, #0]
   30cf0:	f001 fe84 	bl	329fc <__env_unlock>
   30cf4:	f10a 0001 	add.w	r0, sl, #1
   30cf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   30cfc:	10003618 	.word	0x10003618

00030d00 <_getenv_r>:
   30d00:	b500      	push	{lr}
   30d02:	b083      	sub	sp, #12
   30d04:	aa01      	add	r2, sp, #4
   30d06:	f7ff ffbb 	bl	30c80 <_findenv_r>
   30d0a:	b003      	add	sp, #12
   30d0c:	f85d fb04 	ldr.w	pc, [sp], #4

00030d10 <__gettzinfo>:
   30d10:	4800      	ldr	r0, [pc, #0]	; (30d14 <__gettzinfo+0x4>)
   30d12:	4770      	bx	lr
   30d14:	100031b0 	.word	0x100031b0

00030d18 <__retarget_lock_acquire>:
   30d18:	4770      	bx	lr
   30d1a:	bf00      	nop

00030d1c <__retarget_lock_acquire_recursive>:
   30d1c:	4770      	bx	lr
   30d1e:	bf00      	nop

00030d20 <__retarget_lock_release>:
   30d20:	4770      	bx	lr
   30d22:	bf00      	nop

00030d24 <__retarget_lock_release_recursive>:
   30d24:	4770      	bx	lr
   30d26:	bf00      	nop

00030d28 <malloc>:
   30d28:	4b02      	ldr	r3, [pc, #8]	; (30d34 <malloc+0xc>)
   30d2a:	4601      	mov	r1, r0
   30d2c:	6818      	ldr	r0, [r3, #0]
   30d2e:	f000 b80b 	b.w	30d48 <_malloc_r>
   30d32:	bf00      	nop
   30d34:	10002d7c 	.word	0x10002d7c

00030d38 <free>:
   30d38:	4b02      	ldr	r3, [pc, #8]	; (30d44 <free+0xc>)
   30d3a:	4601      	mov	r1, r0
   30d3c:	6818      	ldr	r0, [r3, #0]
   30d3e:	f001 beb3 	b.w	32aa8 <_free_r>
   30d42:	bf00      	nop
   30d44:	10002d7c 	.word	0x10002d7c

00030d48 <_malloc_r>:
   30d48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   30d4c:	f101 050b 	add.w	r5, r1, #11
   30d50:	2d16      	cmp	r5, #22
   30d52:	b083      	sub	sp, #12
   30d54:	4606      	mov	r6, r0
   30d56:	d824      	bhi.n	30da2 <_malloc_r+0x5a>
   30d58:	2910      	cmp	r1, #16
   30d5a:	f200 80b7 	bhi.w	30ecc <_malloc_r+0x184>
   30d5e:	f000 faad 	bl	312bc <__malloc_lock>
   30d62:	2510      	movs	r5, #16
   30d64:	2102      	movs	r1, #2
   30d66:	2318      	movs	r3, #24
   30d68:	f8df 84f0 	ldr.w	r8, [pc, #1264]	; 3125c <_malloc_r+0x514>
   30d6c:	4443      	add	r3, r8
   30d6e:	f1a3 0208 	sub.w	r2, r3, #8
   30d72:	685c      	ldr	r4, [r3, #4]
   30d74:	4294      	cmp	r4, r2
   30d76:	f000 80b5 	beq.w	30ee4 <_malloc_r+0x19c>
   30d7a:	6863      	ldr	r3, [r4, #4]
   30d7c:	f023 0303 	bic.w	r3, r3, #3
   30d80:	4423      	add	r3, r4
   30d82:	e9d4 5102 	ldrd	r5, r1, [r4, #8]
   30d86:	685a      	ldr	r2, [r3, #4]
   30d88:	60e9      	str	r1, [r5, #12]
   30d8a:	f042 0201 	orr.w	r2, r2, #1
   30d8e:	4630      	mov	r0, r6
   30d90:	608d      	str	r5, [r1, #8]
   30d92:	605a      	str	r2, [r3, #4]
   30d94:	f000 fa98 	bl	312c8 <__malloc_unlock>
   30d98:	3408      	adds	r4, #8
   30d9a:	4620      	mov	r0, r4
   30d9c:	b003      	add	sp, #12
   30d9e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30da2:	f035 0507 	bics.w	r5, r5, #7
   30da6:	f100 8091 	bmi.w	30ecc <_malloc_r+0x184>
   30daa:	42a9      	cmp	r1, r5
   30dac:	f200 808e 	bhi.w	30ecc <_malloc_r+0x184>
   30db0:	f000 fa84 	bl	312bc <__malloc_lock>
   30db4:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
   30db8:	f0c0 8190 	bcc.w	310dc <_malloc_r+0x394>
   30dbc:	0a6b      	lsrs	r3, r5, #9
   30dbe:	f000 808c 	beq.w	30eda <_malloc_r+0x192>
   30dc2:	2b04      	cmp	r3, #4
   30dc4:	f200 8166 	bhi.w	31094 <_malloc_r+0x34c>
   30dc8:	09ab      	lsrs	r3, r5, #6
   30dca:	f103 0139 	add.w	r1, r3, #57	; 0x39
   30dce:	f103 0738 	add.w	r7, r3, #56	; 0x38
   30dd2:	00cb      	lsls	r3, r1, #3
   30dd4:	f8df 8484 	ldr.w	r8, [pc, #1156]	; 3125c <_malloc_r+0x514>
   30dd8:	4443      	add	r3, r8
   30dda:	f1a3 0008 	sub.w	r0, r3, #8
   30dde:	685c      	ldr	r4, [r3, #4]
   30de0:	42a0      	cmp	r0, r4
   30de2:	d106      	bne.n	30df2 <_malloc_r+0xaa>
   30de4:	e00c      	b.n	30e00 <_malloc_r+0xb8>
   30de6:	2a00      	cmp	r2, #0
   30de8:	f280 8122 	bge.w	31030 <_malloc_r+0x2e8>
   30dec:	68e4      	ldr	r4, [r4, #12]
   30dee:	42a0      	cmp	r0, r4
   30df0:	d006      	beq.n	30e00 <_malloc_r+0xb8>
   30df2:	6863      	ldr	r3, [r4, #4]
   30df4:	f023 0303 	bic.w	r3, r3, #3
   30df8:	1b5a      	subs	r2, r3, r5
   30dfa:	2a0f      	cmp	r2, #15
   30dfc:	ddf3      	ble.n	30de6 <_malloc_r+0x9e>
   30dfe:	4639      	mov	r1, r7
   30e00:	f8d8 4010 	ldr.w	r4, [r8, #16]
   30e04:	f8df c458 	ldr.w	ip, [pc, #1112]	; 31260 <_malloc_r+0x518>
   30e08:	4564      	cmp	r4, ip
   30e0a:	d077      	beq.n	30efc <_malloc_r+0x1b4>
   30e0c:	6862      	ldr	r2, [r4, #4]
   30e0e:	f022 0203 	bic.w	r2, r2, #3
   30e12:	1b53      	subs	r3, r2, r5
   30e14:	2b0f      	cmp	r3, #15
   30e16:	f300 816f 	bgt.w	310f8 <_malloc_r+0x3b0>
   30e1a:	2b00      	cmp	r3, #0
   30e1c:	e9c8 cc04 	strd	ip, ip, [r8, #16]
   30e20:	f280 8160 	bge.w	310e4 <_malloc_r+0x39c>
   30e24:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   30e28:	f080 8110 	bcs.w	3104c <_malloc_r+0x304>
   30e2c:	08d3      	lsrs	r3, r2, #3
   30e2e:	3301      	adds	r3, #1
   30e30:	0950      	lsrs	r0, r2, #5
   30e32:	2201      	movs	r2, #1
   30e34:	4082      	lsls	r2, r0
   30e36:	f8d8 0004 	ldr.w	r0, [r8, #4]
   30e3a:	f858 7033 	ldr.w	r7, [r8, r3, lsl #3]
   30e3e:	60a7      	str	r7, [r4, #8]
   30e40:	eb08 0ec3 	add.w	lr, r8, r3, lsl #3
   30e44:	4302      	orrs	r2, r0
   30e46:	f1ae 0008 	sub.w	r0, lr, #8
   30e4a:	60e0      	str	r0, [r4, #12]
   30e4c:	f8c8 2004 	str.w	r2, [r8, #4]
   30e50:	f848 4033 	str.w	r4, [r8, r3, lsl #3]
   30e54:	60fc      	str	r4, [r7, #12]
   30e56:	108b      	asrs	r3, r1, #2
   30e58:	2001      	movs	r0, #1
   30e5a:	4098      	lsls	r0, r3
   30e5c:	4290      	cmp	r0, r2
   30e5e:	d854      	bhi.n	30f0a <_malloc_r+0x1c2>
   30e60:	4210      	tst	r0, r2
   30e62:	d106      	bne.n	30e72 <_malloc_r+0x12a>
   30e64:	f021 0103 	bic.w	r1, r1, #3
   30e68:	0040      	lsls	r0, r0, #1
   30e6a:	4210      	tst	r0, r2
   30e6c:	f101 0104 	add.w	r1, r1, #4
   30e70:	d0fa      	beq.n	30e68 <_malloc_r+0x120>
   30e72:	eb08 09c1 	add.w	r9, r8, r1, lsl #3
   30e76:	464c      	mov	r4, r9
   30e78:	468e      	mov	lr, r1
   30e7a:	68e7      	ldr	r7, [r4, #12]
   30e7c:	42bc      	cmp	r4, r7
   30e7e:	d107      	bne.n	30e90 <_malloc_r+0x148>
   30e80:	e114      	b.n	310ac <_malloc_r+0x364>
   30e82:	2b00      	cmp	r3, #0
   30e84:	f280 811b 	bge.w	310be <_malloc_r+0x376>
   30e88:	68ff      	ldr	r7, [r7, #12]
   30e8a:	42bc      	cmp	r4, r7
   30e8c:	f000 810e 	beq.w	310ac <_malloc_r+0x364>
   30e90:	687a      	ldr	r2, [r7, #4]
   30e92:	f022 0203 	bic.w	r2, r2, #3
   30e96:	1b53      	subs	r3, r2, r5
   30e98:	2b0f      	cmp	r3, #15
   30e9a:	ddf2      	ble.n	30e82 <_malloc_r+0x13a>
   30e9c:	e9d7 e402 	ldrd	lr, r4, [r7, #8]
   30ea0:	1979      	adds	r1, r7, r5
   30ea2:	f045 0501 	orr.w	r5, r5, #1
   30ea6:	607d      	str	r5, [r7, #4]
   30ea8:	f043 0501 	orr.w	r5, r3, #1
   30eac:	f8ce 400c 	str.w	r4, [lr, #12]
   30eb0:	4630      	mov	r0, r6
   30eb2:	f8c4 e008 	str.w	lr, [r4, #8]
   30eb6:	e9c8 1104 	strd	r1, r1, [r8, #16]
   30eba:	e9c1 cc02 	strd	ip, ip, [r1, #8]
   30ebe:	604d      	str	r5, [r1, #4]
   30ec0:	50bb      	str	r3, [r7, r2]
   30ec2:	f000 fa01 	bl	312c8 <__malloc_unlock>
   30ec6:	f107 0408 	add.w	r4, r7, #8
   30eca:	e002      	b.n	30ed2 <_malloc_r+0x18a>
   30ecc:	230c      	movs	r3, #12
   30ece:	6033      	str	r3, [r6, #0]
   30ed0:	2400      	movs	r4, #0
   30ed2:	4620      	mov	r0, r4
   30ed4:	b003      	add	sp, #12
   30ed6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   30eda:	f44f 7300 	mov.w	r3, #512	; 0x200
   30ede:	2140      	movs	r1, #64	; 0x40
   30ee0:	273f      	movs	r7, #63	; 0x3f
   30ee2:	e777      	b.n	30dd4 <_malloc_r+0x8c>
   30ee4:	68dc      	ldr	r4, [r3, #12]
   30ee6:	42a3      	cmp	r3, r4
   30ee8:	bf08      	it	eq
   30eea:	3102      	addeq	r1, #2
   30eec:	f47f af45 	bne.w	30d7a <_malloc_r+0x32>
   30ef0:	f8d8 4010 	ldr.w	r4, [r8, #16]
   30ef4:	f8df c368 	ldr.w	ip, [pc, #872]	; 31260 <_malloc_r+0x518>
   30ef8:	4564      	cmp	r4, ip
   30efa:	d187      	bne.n	30e0c <_malloc_r+0xc4>
   30efc:	f8d8 2004 	ldr.w	r2, [r8, #4]
   30f00:	108b      	asrs	r3, r1, #2
   30f02:	2001      	movs	r0, #1
   30f04:	4098      	lsls	r0, r3
   30f06:	4290      	cmp	r0, r2
   30f08:	d9aa      	bls.n	30e60 <_malloc_r+0x118>
   30f0a:	f8d8 4008 	ldr.w	r4, [r8, #8]
   30f0e:	6867      	ldr	r7, [r4, #4]
   30f10:	f027 0703 	bic.w	r7, r7, #3
   30f14:	42bd      	cmp	r5, r7
   30f16:	d802      	bhi.n	30f1e <_malloc_r+0x1d6>
   30f18:	1b7b      	subs	r3, r7, r5
   30f1a:	2b0f      	cmp	r3, #15
   30f1c:	dc77      	bgt.n	3100e <_malloc_r+0x2c6>
   30f1e:	f8df 9344 	ldr.w	r9, [pc, #836]	; 31264 <_malloc_r+0x51c>
   30f22:	4bca      	ldr	r3, [pc, #808]	; (3124c <_malloc_r+0x504>)
   30f24:	f8d9 2000 	ldr.w	r2, [r9]
   30f28:	681b      	ldr	r3, [r3, #0]
   30f2a:	3201      	adds	r2, #1
   30f2c:	442b      	add	r3, r5
   30f2e:	eb04 0a07 	add.w	sl, r4, r7
   30f32:	f000 812e 	beq.w	31192 <_malloc_r+0x44a>
   30f36:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
   30f3a:	330f      	adds	r3, #15
   30f3c:	f423 6b7f 	bic.w	fp, r3, #4080	; 0xff0
   30f40:	f02b 0b0f 	bic.w	fp, fp, #15
   30f44:	4659      	mov	r1, fp
   30f46:	4630      	mov	r0, r6
   30f48:	f000 f9c4 	bl	312d4 <_sbrk_r>
   30f4c:	1c41      	adds	r1, r0, #1
   30f4e:	4602      	mov	r2, r0
   30f50:	f000 80eb 	beq.w	3112a <_malloc_r+0x3e2>
   30f54:	4582      	cmp	sl, r0
   30f56:	f200 80e6 	bhi.w	31126 <_malloc_r+0x3de>
   30f5a:	4bbd      	ldr	r3, [pc, #756]	; (31250 <_malloc_r+0x508>)
   30f5c:	6819      	ldr	r1, [r3, #0]
   30f5e:	4459      	add	r1, fp
   30f60:	6019      	str	r1, [r3, #0]
   30f62:	4608      	mov	r0, r1
   30f64:	f000 814b 	beq.w	311fe <_malloc_r+0x4b6>
   30f68:	f8d9 1000 	ldr.w	r1, [r9]
   30f6c:	9301      	str	r3, [sp, #4]
   30f6e:	3101      	adds	r1, #1
   30f70:	bf1b      	ittet	ne
   30f72:	eba2 0a0a 	subne.w	sl, r2, sl
   30f76:	4450      	addne	r0, sl
   30f78:	f8c9 2000 	streq.w	r2, [r9]
   30f7c:	6018      	strne	r0, [r3, #0]
   30f7e:	f012 0a07 	ands.w	sl, r2, #7
   30f82:	f000 8114 	beq.w	311ae <_malloc_r+0x466>
   30f86:	f1ca 0108 	rsb	r1, sl, #8
   30f8a:	440a      	add	r2, r1
   30f8c:	f5ca 5180 	rsb	r1, sl, #4096	; 0x1000
   30f90:	4493      	add	fp, r2
   30f92:	3108      	adds	r1, #8
   30f94:	eba1 010b 	sub.w	r1, r1, fp
   30f98:	f3c1 090b 	ubfx	r9, r1, #0, #12
   30f9c:	4649      	mov	r1, r9
   30f9e:	4630      	mov	r0, r6
   30fa0:	9200      	str	r2, [sp, #0]
   30fa2:	f000 f997 	bl	312d4 <_sbrk_r>
   30fa6:	1c42      	adds	r2, r0, #1
   30fa8:	e9dd 2300 	ldrd	r2, r3, [sp]
   30fac:	f000 815c 	beq.w	31268 <_malloc_r+0x520>
   30fb0:	1a80      	subs	r0, r0, r2
   30fb2:	eb00 0b09 	add.w	fp, r0, r9
   30fb6:	6819      	ldr	r1, [r3, #0]
   30fb8:	f8c8 2008 	str.w	r2, [r8, #8]
   30fbc:	f04b 0001 	orr.w	r0, fp, #1
   30fc0:	4449      	add	r1, r9
   30fc2:	4544      	cmp	r4, r8
   30fc4:	6050      	str	r0, [r2, #4]
   30fc6:	6019      	str	r1, [r3, #0]
   30fc8:	f000 8126 	beq.w	31218 <_malloc_r+0x4d0>
   30fcc:	2f0f      	cmp	r7, #15
   30fce:	f240 8125 	bls.w	3121c <_malloc_r+0x4d4>
   30fd2:	6860      	ldr	r0, [r4, #4]
   30fd4:	3f0c      	subs	r7, #12
   30fd6:	f027 0707 	bic.w	r7, r7, #7
   30fda:	f000 0001 	and.w	r0, r0, #1
   30fde:	eb04 0c07 	add.w	ip, r4, r7
   30fe2:	4338      	orrs	r0, r7
   30fe4:	f04f 0e05 	mov.w	lr, #5
   30fe8:	2f0f      	cmp	r7, #15
   30fea:	6060      	str	r0, [r4, #4]
   30fec:	e9cc ee01 	strd	lr, lr, [ip, #4]
   30ff0:	f200 8142 	bhi.w	31278 <_malloc_r+0x530>
   30ff4:	6850      	ldr	r0, [r2, #4]
   30ff6:	4614      	mov	r4, r2
   30ff8:	4b96      	ldr	r3, [pc, #600]	; (31254 <_malloc_r+0x50c>)
   30ffa:	681a      	ldr	r2, [r3, #0]
   30ffc:	428a      	cmp	r2, r1
   30ffe:	bf38      	it	cc
   31000:	6019      	strcc	r1, [r3, #0]
   31002:	4b95      	ldr	r3, [pc, #596]	; (31258 <_malloc_r+0x510>)
   31004:	681a      	ldr	r2, [r3, #0]
   31006:	428a      	cmp	r2, r1
   31008:	bf38      	it	cc
   3100a:	6019      	strcc	r1, [r3, #0]
   3100c:	e090      	b.n	31130 <_malloc_r+0x3e8>
   3100e:	1962      	adds	r2, r4, r5
   31010:	f043 0301 	orr.w	r3, r3, #1
   31014:	f045 0501 	orr.w	r5, r5, #1
   31018:	6065      	str	r5, [r4, #4]
   3101a:	4630      	mov	r0, r6
   3101c:	f8c8 2008 	str.w	r2, [r8, #8]
   31020:	6053      	str	r3, [r2, #4]
   31022:	f000 f951 	bl	312c8 <__malloc_unlock>
   31026:	3408      	adds	r4, #8
   31028:	4620      	mov	r0, r4
   3102a:	b003      	add	sp, #12
   3102c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   31030:	4423      	add	r3, r4
   31032:	68e1      	ldr	r1, [r4, #12]
   31034:	685a      	ldr	r2, [r3, #4]
   31036:	68a5      	ldr	r5, [r4, #8]
   31038:	f042 0201 	orr.w	r2, r2, #1
   3103c:	60e9      	str	r1, [r5, #12]
   3103e:	4630      	mov	r0, r6
   31040:	608d      	str	r5, [r1, #8]
   31042:	605a      	str	r2, [r3, #4]
   31044:	f000 f940 	bl	312c8 <__malloc_unlock>
   31048:	3408      	adds	r4, #8
   3104a:	e742      	b.n	30ed2 <_malloc_r+0x18a>
   3104c:	f5b2 6f20 	cmp.w	r2, #2560	; 0xa00
   31050:	ea4f 2352 	mov.w	r3, r2, lsr #9
   31054:	d361      	bcc.n	3111a <_malloc_r+0x3d2>
   31056:	2b14      	cmp	r3, #20
   31058:	f200 80ba 	bhi.w	311d0 <_malloc_r+0x488>
   3105c:	f103 005c 	add.w	r0, r3, #92	; 0x5c
   31060:	00c0      	lsls	r0, r0, #3
   31062:	335b      	adds	r3, #91	; 0x5b
   31064:	eb08 0700 	add.w	r7, r8, r0
   31068:	f858 0000 	ldr.w	r0, [r8, r0]
   3106c:	3f08      	subs	r7, #8
   3106e:	4287      	cmp	r7, r0
   31070:	f000 8092 	beq.w	31198 <_malloc_r+0x450>
   31074:	6843      	ldr	r3, [r0, #4]
   31076:	f023 0303 	bic.w	r3, r3, #3
   3107a:	4293      	cmp	r3, r2
   3107c:	d902      	bls.n	31084 <_malloc_r+0x33c>
   3107e:	6880      	ldr	r0, [r0, #8]
   31080:	4287      	cmp	r7, r0
   31082:	d1f7      	bne.n	31074 <_malloc_r+0x32c>
   31084:	68c7      	ldr	r7, [r0, #12]
   31086:	f8d8 2004 	ldr.w	r2, [r8, #4]
   3108a:	e9c4 0702 	strd	r0, r7, [r4, #8]
   3108e:	60bc      	str	r4, [r7, #8]
   31090:	60c4      	str	r4, [r0, #12]
   31092:	e6e0      	b.n	30e56 <_malloc_r+0x10e>
   31094:	2b14      	cmp	r3, #20
   31096:	d959      	bls.n	3114c <_malloc_r+0x404>
   31098:	2b54      	cmp	r3, #84	; 0x54
   3109a:	f200 80a1 	bhi.w	311e0 <_malloc_r+0x498>
   3109e:	0b2b      	lsrs	r3, r5, #12
   310a0:	f103 016f 	add.w	r1, r3, #111	; 0x6f
   310a4:	f103 076e 	add.w	r7, r3, #110	; 0x6e
   310a8:	00cb      	lsls	r3, r1, #3
   310aa:	e693      	b.n	30dd4 <_malloc_r+0x8c>
   310ac:	f10e 0e01 	add.w	lr, lr, #1
   310b0:	f01e 0f03 	tst.w	lr, #3
   310b4:	f104 0408 	add.w	r4, r4, #8
   310b8:	f47f aedf 	bne.w	30e7a <_malloc_r+0x132>
   310bc:	e051      	b.n	31162 <_malloc_r+0x41a>
   310be:	443a      	add	r2, r7
   310c0:	463c      	mov	r4, r7
   310c2:	6853      	ldr	r3, [r2, #4]
   310c4:	68f9      	ldr	r1, [r7, #12]
   310c6:	f854 5f08 	ldr.w	r5, [r4, #8]!
   310ca:	f043 0301 	orr.w	r3, r3, #1
   310ce:	6053      	str	r3, [r2, #4]
   310d0:	4630      	mov	r0, r6
   310d2:	60e9      	str	r1, [r5, #12]
   310d4:	608d      	str	r5, [r1, #8]
   310d6:	f000 f8f7 	bl	312c8 <__malloc_unlock>
   310da:	e6fa      	b.n	30ed2 <_malloc_r+0x18a>
   310dc:	08e9      	lsrs	r1, r5, #3
   310de:	f105 0308 	add.w	r3, r5, #8
   310e2:	e641      	b.n	30d68 <_malloc_r+0x20>
   310e4:	4422      	add	r2, r4
   310e6:	4630      	mov	r0, r6
   310e8:	6853      	ldr	r3, [r2, #4]
   310ea:	f043 0301 	orr.w	r3, r3, #1
   310ee:	6053      	str	r3, [r2, #4]
   310f0:	3408      	adds	r4, #8
   310f2:	f000 f8e9 	bl	312c8 <__malloc_unlock>
   310f6:	e6ec      	b.n	30ed2 <_malloc_r+0x18a>
   310f8:	1961      	adds	r1, r4, r5
   310fa:	f043 0701 	orr.w	r7, r3, #1
   310fe:	f045 0501 	orr.w	r5, r5, #1
   31102:	6065      	str	r5, [r4, #4]
   31104:	4630      	mov	r0, r6
   31106:	e9c8 1104 	strd	r1, r1, [r8, #16]
   3110a:	e9c1 cc02 	strd	ip, ip, [r1, #8]
   3110e:	604f      	str	r7, [r1, #4]
   31110:	50a3      	str	r3, [r4, r2]
   31112:	f000 f8d9 	bl	312c8 <__malloc_unlock>
   31116:	3408      	adds	r4, #8
   31118:	e6db      	b.n	30ed2 <_malloc_r+0x18a>
   3111a:	0993      	lsrs	r3, r2, #6
   3111c:	f103 0039 	add.w	r0, r3, #57	; 0x39
   31120:	00c0      	lsls	r0, r0, #3
   31122:	3338      	adds	r3, #56	; 0x38
   31124:	e79e      	b.n	31064 <_malloc_r+0x31c>
   31126:	4544      	cmp	r4, r8
   31128:	d064      	beq.n	311f4 <_malloc_r+0x4ac>
   3112a:	f8d8 4008 	ldr.w	r4, [r8, #8]
   3112e:	6860      	ldr	r0, [r4, #4]
   31130:	f020 0b03 	bic.w	fp, r0, #3
   31134:	455d      	cmp	r5, fp
   31136:	ebab 0305 	sub.w	r3, fp, r5
   3113a:	d802      	bhi.n	31142 <_malloc_r+0x3fa>
   3113c:	2b0f      	cmp	r3, #15
   3113e:	f73f af66 	bgt.w	3100e <_malloc_r+0x2c6>
   31142:	4630      	mov	r0, r6
   31144:	f000 f8c0 	bl	312c8 <__malloc_unlock>
   31148:	2400      	movs	r4, #0
   3114a:	e6c2      	b.n	30ed2 <_malloc_r+0x18a>
   3114c:	f103 015c 	add.w	r1, r3, #92	; 0x5c
   31150:	f103 075b 	add.w	r7, r3, #91	; 0x5b
   31154:	00cb      	lsls	r3, r1, #3
   31156:	e63d      	b.n	30dd4 <_malloc_r+0x8c>
   31158:	f859 3908 	ldr.w	r3, [r9], #-8
   3115c:	454b      	cmp	r3, r9
   3115e:	f040 80aa 	bne.w	312b6 <_malloc_r+0x56e>
   31162:	f011 0f03 	tst.w	r1, #3
   31166:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
   3116a:	d1f5      	bne.n	31158 <_malloc_r+0x410>
   3116c:	f8d8 3004 	ldr.w	r3, [r8, #4]
   31170:	ea23 0300 	bic.w	r3, r3, r0
   31174:	f8c8 3004 	str.w	r3, [r8, #4]
   31178:	0040      	lsls	r0, r0, #1
   3117a:	4298      	cmp	r0, r3
   3117c:	f63f aec5 	bhi.w	30f0a <_malloc_r+0x1c2>
   31180:	b918      	cbnz	r0, 3118a <_malloc_r+0x442>
   31182:	e6c2      	b.n	30f0a <_malloc_r+0x1c2>
   31184:	0040      	lsls	r0, r0, #1
   31186:	f10e 0e04 	add.w	lr, lr, #4
   3118a:	4218      	tst	r0, r3
   3118c:	d0fa      	beq.n	31184 <_malloc_r+0x43c>
   3118e:	4671      	mov	r1, lr
   31190:	e66f      	b.n	30e72 <_malloc_r+0x12a>
   31192:	f103 0b10 	add.w	fp, r3, #16
   31196:	e6d5      	b.n	30f44 <_malloc_r+0x1fc>
   31198:	109a      	asrs	r2, r3, #2
   3119a:	f04f 0e01 	mov.w	lr, #1
   3119e:	f8d8 3004 	ldr.w	r3, [r8, #4]
   311a2:	fa0e f202 	lsl.w	r2, lr, r2
   311a6:	431a      	orrs	r2, r3
   311a8:	f8c8 2004 	str.w	r2, [r8, #4]
   311ac:	e76d      	b.n	3108a <_malloc_r+0x342>
   311ae:	eb02 010b 	add.w	r1, r2, fp
   311b2:	4249      	negs	r1, r1
   311b4:	f3c1 090b 	ubfx	r9, r1, #0, #12
   311b8:	4649      	mov	r1, r9
   311ba:	4630      	mov	r0, r6
   311bc:	9200      	str	r2, [sp, #0]
   311be:	f000 f889 	bl	312d4 <_sbrk_r>
   311c2:	1c43      	adds	r3, r0, #1
   311c4:	e9dd 2300 	ldrd	r2, r3, [sp]
   311c8:	f47f aef2 	bne.w	30fb0 <_malloc_r+0x268>
   311cc:	46d1      	mov	r9, sl
   311ce:	e6f2      	b.n	30fb6 <_malloc_r+0x26e>
   311d0:	2b54      	cmp	r3, #84	; 0x54
   311d2:	d826      	bhi.n	31222 <_malloc_r+0x4da>
   311d4:	0b13      	lsrs	r3, r2, #12
   311d6:	f103 006f 	add.w	r0, r3, #111	; 0x6f
   311da:	00c0      	lsls	r0, r0, #3
   311dc:	336e      	adds	r3, #110	; 0x6e
   311de:	e741      	b.n	31064 <_malloc_r+0x31c>
   311e0:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   311e4:	d826      	bhi.n	31234 <_malloc_r+0x4ec>
   311e6:	0beb      	lsrs	r3, r5, #15
   311e8:	f103 0178 	add.w	r1, r3, #120	; 0x78
   311ec:	f103 0777 	add.w	r7, r3, #119	; 0x77
   311f0:	00cb      	lsls	r3, r1, #3
   311f2:	e5ef      	b.n	30dd4 <_malloc_r+0x8c>
   311f4:	4b16      	ldr	r3, [pc, #88]	; (31250 <_malloc_r+0x508>)
   311f6:	6818      	ldr	r0, [r3, #0]
   311f8:	4458      	add	r0, fp
   311fa:	6018      	str	r0, [r3, #0]
   311fc:	e6b4      	b.n	30f68 <_malloc_r+0x220>
   311fe:	f3ca 0c0b 	ubfx	ip, sl, #0, #12
   31202:	f1bc 0f00 	cmp.w	ip, #0
   31206:	f47f aeaf 	bne.w	30f68 <_malloc_r+0x220>
   3120a:	f8d8 4008 	ldr.w	r4, [r8, #8]
   3120e:	44bb      	add	fp, r7
   31210:	f04b 0001 	orr.w	r0, fp, #1
   31214:	6060      	str	r0, [r4, #4]
   31216:	e6ef      	b.n	30ff8 <_malloc_r+0x2b0>
   31218:	4614      	mov	r4, r2
   3121a:	e6ed      	b.n	30ff8 <_malloc_r+0x2b0>
   3121c:	2301      	movs	r3, #1
   3121e:	6053      	str	r3, [r2, #4]
   31220:	e78f      	b.n	31142 <_malloc_r+0x3fa>
   31222:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   31226:	d833      	bhi.n	31290 <_malloc_r+0x548>
   31228:	0bd3      	lsrs	r3, r2, #15
   3122a:	f103 0078 	add.w	r0, r3, #120	; 0x78
   3122e:	00c0      	lsls	r0, r0, #3
   31230:	3377      	adds	r3, #119	; 0x77
   31232:	e717      	b.n	31064 <_malloc_r+0x31c>
   31234:	f240 5254 	movw	r2, #1364	; 0x554
   31238:	4293      	cmp	r3, r2
   3123a:	d833      	bhi.n	312a4 <_malloc_r+0x55c>
   3123c:	0cab      	lsrs	r3, r5, #18
   3123e:	f103 017d 	add.w	r1, r3, #125	; 0x7d
   31242:	f103 077c 	add.w	r7, r3, #124	; 0x7c
   31246:	00cb      	lsls	r3, r1, #3
   31248:	e5c4      	b.n	30dd4 <_malloc_r+0x8c>
   3124a:	bf00      	nop
   3124c:	1000bed0 	.word	0x1000bed0
   31250:	1000bea0 	.word	0x1000bea0
   31254:	1000bec8 	.word	0x1000bec8
   31258:	1000becc 	.word	0x1000becc
   3125c:	10003208 	.word	0x10003208
   31260:	10003210 	.word	0x10003210
   31264:	10003610 	.word	0x10003610
   31268:	f1aa 0a08 	sub.w	sl, sl, #8
   3126c:	44d3      	add	fp, sl
   3126e:	ebab 0b02 	sub.w	fp, fp, r2
   31272:	f04f 0900 	mov.w	r9, #0
   31276:	e69e      	b.n	30fb6 <_malloc_r+0x26e>
   31278:	f104 0108 	add.w	r1, r4, #8
   3127c:	4630      	mov	r0, r6
   3127e:	9300      	str	r3, [sp, #0]
   31280:	f001 fc12 	bl	32aa8 <_free_r>
   31284:	f8d8 4008 	ldr.w	r4, [r8, #8]
   31288:	9b00      	ldr	r3, [sp, #0]
   3128a:	6860      	ldr	r0, [r4, #4]
   3128c:	6819      	ldr	r1, [r3, #0]
   3128e:	e6b3      	b.n	30ff8 <_malloc_r+0x2b0>
   31290:	f240 5054 	movw	r0, #1364	; 0x554
   31294:	4283      	cmp	r3, r0
   31296:	d80a      	bhi.n	312ae <_malloc_r+0x566>
   31298:	0c93      	lsrs	r3, r2, #18
   3129a:	f103 007d 	add.w	r0, r3, #125	; 0x7d
   3129e:	00c0      	lsls	r0, r0, #3
   312a0:	337c      	adds	r3, #124	; 0x7c
   312a2:	e6df      	b.n	31064 <_malloc_r+0x31c>
   312a4:	f44f 737e 	mov.w	r3, #1016	; 0x3f8
   312a8:	217f      	movs	r1, #127	; 0x7f
   312aa:	277e      	movs	r7, #126	; 0x7e
   312ac:	e592      	b.n	30dd4 <_malloc_r+0x8c>
   312ae:	f44f 707e 	mov.w	r0, #1016	; 0x3f8
   312b2:	237e      	movs	r3, #126	; 0x7e
   312b4:	e6d6      	b.n	31064 <_malloc_r+0x31c>
   312b6:	f8d8 3004 	ldr.w	r3, [r8, #4]
   312ba:	e75d      	b.n	31178 <_malloc_r+0x430>

000312bc <__malloc_lock>:
   312bc:	4801      	ldr	r0, [pc, #4]	; (312c4 <__malloc_lock+0x8>)
   312be:	f7ff bd2d 	b.w	30d1c <__retarget_lock_acquire_recursive>
   312c2:	bf00      	nop
   312c4:	100118cc 	.word	0x100118cc

000312c8 <__malloc_unlock>:
   312c8:	4801      	ldr	r0, [pc, #4]	; (312d0 <__malloc_unlock+0x8>)
   312ca:	f7ff bd2b 	b.w	30d24 <__retarget_lock_release_recursive>
   312ce:	bf00      	nop
   312d0:	100118cc 	.word	0x100118cc

000312d4 <_sbrk_r>:
   312d4:	b538      	push	{r3, r4, r5, lr}
   312d6:	4d07      	ldr	r5, [pc, #28]	; (312f4 <_sbrk_r+0x20>)
   312d8:	2200      	movs	r2, #0
   312da:	4604      	mov	r4, r0
   312dc:	4608      	mov	r0, r1
   312de:	602a      	str	r2, [r5, #0]
   312e0:	f002 f9a2 	bl	33628 <_sbrk>
   312e4:	1c43      	adds	r3, r0, #1
   312e6:	d000      	beq.n	312ea <_sbrk_r+0x16>
   312e8:	bd38      	pop	{r3, r4, r5, pc}
   312ea:	682b      	ldr	r3, [r5, #0]
   312ec:	2b00      	cmp	r3, #0
   312ee:	d0fb      	beq.n	312e8 <_sbrk_r+0x14>
   312f0:	6023      	str	r3, [r4, #0]
   312f2:	bd38      	pop	{r3, r4, r5, pc}
   312f4:	100118e0 	.word	0x100118e0

000312f8 <siscanf>:
   312f8:	b40e      	push	{r1, r2, r3}
   312fa:	b570      	push	{r4, r5, r6, lr}
   312fc:	b09f      	sub	sp, #124	; 0x7c
   312fe:	ac23      	add	r4, sp, #140	; 0x8c
   31300:	f44f 7101 	mov.w	r1, #516	; 0x204
   31304:	f854 2b04 	ldr.w	r2, [r4], #4
   31308:	9201      	str	r2, [sp, #4]
   3130a:	f8ad 101c 	strh.w	r1, [sp, #28]
   3130e:	9004      	str	r0, [sp, #16]
   31310:	9008      	str	r0, [sp, #32]
   31312:	f7e7 f855 	bl	183c0 <strlen>
   31316:	4b0c      	ldr	r3, [pc, #48]	; (31348 <siscanf+0x50>)
   31318:	9403      	str	r4, [sp, #12]
   3131a:	4601      	mov	r1, r0
   3131c:	9105      	str	r1, [sp, #20]
   3131e:	9109      	str	r1, [sp, #36]	; 0x24
   31320:	4e0a      	ldr	r6, [pc, #40]	; (3134c <siscanf+0x54>)
   31322:	6818      	ldr	r0, [r3, #0]
   31324:	9a01      	ldr	r2, [sp, #4]
   31326:	960c      	str	r6, [sp, #48]	; 0x30
   31328:	4623      	mov	r3, r4
   3132a:	f64f 75ff 	movw	r5, #65535	; 0xffff
   3132e:	2400      	movs	r4, #0
   31330:	a904      	add	r1, sp, #16
   31332:	9410      	str	r4, [sp, #64]	; 0x40
   31334:	9415      	str	r4, [sp, #84]	; 0x54
   31336:	f8ad 501e 	strh.w	r5, [sp, #30]
   3133a:	f000 f9ef 	bl	3171c <__ssvfiscanf_r>
   3133e:	b01f      	add	sp, #124	; 0x7c
   31340:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   31344:	b003      	add	sp, #12
   31346:	4770      	bx	lr
   31348:	10002d7c 	.word	0x10002d7c
   3134c:	00031351 	.word	0x00031351

00031350 <__seofread>:
   31350:	2000      	movs	r0, #0
   31352:	4770      	bx	lr

00031354 <strcpy>:
   31354:	ea80 0201 	eor.w	r2, r0, r1
   31358:	4684      	mov	ip, r0
   3135a:	f012 0f03 	tst.w	r2, #3
   3135e:	d14f      	bne.n	31400 <strcpy+0xac>
   31360:	f011 0f03 	tst.w	r1, #3
   31364:	d132      	bne.n	313cc <strcpy+0x78>
   31366:	f84d 4d04 	str.w	r4, [sp, #-4]!
   3136a:	f011 0f04 	tst.w	r1, #4
   3136e:	f851 3b04 	ldr.w	r3, [r1], #4
   31372:	d00b      	beq.n	3138c <strcpy+0x38>
   31374:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   31378:	439a      	bics	r2, r3
   3137a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   3137e:	bf04      	itt	eq
   31380:	f84c 3b04 	streq.w	r3, [ip], #4
   31384:	f851 3b04 	ldreq.w	r3, [r1], #4
   31388:	d116      	bne.n	313b8 <strcpy+0x64>
   3138a:	bf00      	nop
   3138c:	f851 4b04 	ldr.w	r4, [r1], #4
   31390:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   31394:	439a      	bics	r2, r3
   31396:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   3139a:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   3139e:	d10b      	bne.n	313b8 <strcpy+0x64>
   313a0:	f84c 3b04 	str.w	r3, [ip], #4
   313a4:	43a2      	bics	r2, r4
   313a6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   313aa:	bf04      	itt	eq
   313ac:	f851 3b04 	ldreq.w	r3, [r1], #4
   313b0:	f84c 4b04 	streq.w	r4, [ip], #4
   313b4:	d0ea      	beq.n	3138c <strcpy+0x38>
   313b6:	4623      	mov	r3, r4
   313b8:	f80c 3b01 	strb.w	r3, [ip], #1
   313bc:	f013 0fff 	tst.w	r3, #255	; 0xff
   313c0:	ea4f 2333 	mov.w	r3, r3, ror #8
   313c4:	d1f8      	bne.n	313b8 <strcpy+0x64>
   313c6:	f85d 4b04 	ldr.w	r4, [sp], #4
   313ca:	4770      	bx	lr
   313cc:	f011 0f01 	tst.w	r1, #1
   313d0:	d006      	beq.n	313e0 <strcpy+0x8c>
   313d2:	f811 2b01 	ldrb.w	r2, [r1], #1
   313d6:	f80c 2b01 	strb.w	r2, [ip], #1
   313da:	2a00      	cmp	r2, #0
   313dc:	bf08      	it	eq
   313de:	4770      	bxeq	lr
   313e0:	f011 0f02 	tst.w	r1, #2
   313e4:	d0bf      	beq.n	31366 <strcpy+0x12>
   313e6:	f831 2b02 	ldrh.w	r2, [r1], #2
   313ea:	f012 0fff 	tst.w	r2, #255	; 0xff
   313ee:	bf16      	itet	ne
   313f0:	f82c 2b02 	strhne.w	r2, [ip], #2
   313f4:	f88c 2000 	strbeq.w	r2, [ip]
   313f8:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   313fc:	d1b3      	bne.n	31366 <strcpy+0x12>
   313fe:	4770      	bx	lr
   31400:	f811 2b01 	ldrb.w	r2, [r1], #1
   31404:	f80c 2b01 	strb.w	r2, [ip], #1
   31408:	2a00      	cmp	r2, #0
   3140a:	d1f9      	bne.n	31400 <strcpy+0xac>
   3140c:	4770      	bx	lr
   3140e:	bf00      	nop

00031410 <strncmp>:
   31410:	b39a      	cbz	r2, 3147a <strncmp+0x6a>
   31412:	b4f0      	push	{r4, r5, r6, r7}
   31414:	ea40 0501 	orr.w	r5, r0, r1
   31418:	07ad      	lsls	r5, r5, #30
   3141a:	4604      	mov	r4, r0
   3141c:	4603      	mov	r3, r0
   3141e:	4608      	mov	r0, r1
   31420:	d028      	beq.n	31474 <strncmp+0x64>
   31422:	7820      	ldrb	r0, [r4, #0]
   31424:	780e      	ldrb	r6, [r1, #0]
   31426:	4286      	cmp	r6, r0
   31428:	d129      	bne.n	3147e <strncmp+0x6e>
   3142a:	2a01      	cmp	r2, #1
   3142c:	d02a      	beq.n	31484 <strncmp+0x74>
   3142e:	4625      	mov	r5, r4
   31430:	b150      	cbz	r0, 31448 <strncmp+0x38>
   31432:	f815 0f01 	ldrb.w	r0, [r5, #1]!
   31436:	f811 6f01 	ldrb.w	r6, [r1, #1]!
   3143a:	43eb      	mvns	r3, r5
   3143c:	42b0      	cmp	r0, r6
   3143e:	4413      	add	r3, r2
   31440:	d11d      	bne.n	3147e <strncmp+0x6e>
   31442:	18e3      	adds	r3, r4, r3
   31444:	d1f4      	bne.n	31430 <strncmp+0x20>
   31446:	4618      	mov	r0, r3
   31448:	bcf0      	pop	{r4, r5, r6, r7}
   3144a:	4770      	bx	lr
   3144c:	6807      	ldr	r7, [r0, #0]
   3144e:	461c      	mov	r4, r3
   31450:	f853 5b04 	ldr.w	r5, [r3], #4
   31454:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
   31458:	42bd      	cmp	r5, r7
   3145a:	4601      	mov	r1, r0
   3145c:	ea26 0605 	bic.w	r6, r6, r5
   31460:	f100 0004 	add.w	r0, r0, #4
   31464:	d1dd      	bne.n	31422 <strncmp+0x12>
   31466:	3a04      	subs	r2, #4
   31468:	461c      	mov	r4, r3
   3146a:	4601      	mov	r1, r0
   3146c:	d00a      	beq.n	31484 <strncmp+0x74>
   3146e:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
   31472:	d107      	bne.n	31484 <strncmp+0x74>
   31474:	2a03      	cmp	r2, #3
   31476:	d8e9      	bhi.n	3144c <strncmp+0x3c>
   31478:	e7d3      	b.n	31422 <strncmp+0x12>
   3147a:	4610      	mov	r0, r2
   3147c:	4770      	bx	lr
   3147e:	1b80      	subs	r0, r0, r6
   31480:	bcf0      	pop	{r4, r5, r6, r7}
   31482:	4770      	bx	lr
   31484:	2000      	movs	r0, #0
   31486:	bcf0      	pop	{r4, r5, r6, r7}
   31488:	4770      	bx	lr
   3148a:	bf00      	nop

0003148c <_strtoul_l.isra.0>:
   3148c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   31490:	4d4b      	ldr	r5, [pc, #300]	; (315c0 <_strtoul_l.isra.0+0x134>)
   31492:	4686      	mov	lr, r0
   31494:	468c      	mov	ip, r1
   31496:	4660      	mov	r0, ip
   31498:	f81c 4b01 	ldrb.w	r4, [ip], #1
   3149c:	5d2e      	ldrb	r6, [r5, r4]
   3149e:	f016 0608 	ands.w	r6, r6, #8
   314a2:	d1f8      	bne.n	31496 <_strtoul_l.isra.0+0xa>
   314a4:	2c2d      	cmp	r4, #45	; 0x2d
   314a6:	d057      	beq.n	31558 <_strtoul_l.isra.0+0xcc>
   314a8:	2c2b      	cmp	r4, #43	; 0x2b
   314aa:	bf0a      	itet	eq
   314ac:	f89c 5000 	ldrbeq.w	r5, [ip]
   314b0:	4625      	movne	r5, r4
   314b2:	f100 0c02 	addeq.w	ip, r0, #2
   314b6:	b15b      	cbz	r3, 314d0 <_strtoul_l.isra.0+0x44>
   314b8:	2b10      	cmp	r3, #16
   314ba:	d053      	beq.n	31564 <_strtoul_l.isra.0+0xd8>
   314bc:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
   314c0:	fbb8 f8f3 	udiv	r8, r8, r3
   314c4:	fb03 fa08 	mul.w	sl, r3, r8
   314c8:	ea6f 0a0a 	mvn.w	sl, sl
   314cc:	4699      	mov	r9, r3
   314ce:	e007      	b.n	314e0 <_strtoul_l.isra.0+0x54>
   314d0:	2d30      	cmp	r5, #48	; 0x30
   314d2:	d05b      	beq.n	3158c <_strtoul_l.isra.0+0x100>
   314d4:	230a      	movs	r3, #10
   314d6:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 315c4 <_strtoul_l.isra.0+0x138>
   314da:	4699      	mov	r9, r3
   314dc:	f04f 0a05 	mov.w	sl, #5
   314e0:	2700      	movs	r7, #0
   314e2:	4638      	mov	r0, r7
   314e4:	e007      	b.n	314f6 <_strtoul_l.isra.0+0x6a>
   314e6:	4540      	cmp	r0, r8
   314e8:	d813      	bhi.n	31512 <_strtoul_l.isra.0+0x86>
   314ea:	d026      	beq.n	3153a <_strtoul_l.isra.0+0xae>
   314ec:	fb09 4000 	mla	r0, r9, r0, r4
   314f0:	2701      	movs	r7, #1
   314f2:	f81c 5b01 	ldrb.w	r5, [ip], #1
   314f6:	f1a5 0430 	sub.w	r4, r5, #48	; 0x30
   314fa:	2c09      	cmp	r4, #9
   314fc:	d905      	bls.n	3150a <_strtoul_l.isra.0+0x7e>
   314fe:	f1a5 0441 	sub.w	r4, r5, #65	; 0x41
   31502:	2c19      	cmp	r4, #25
   31504:	d808      	bhi.n	31518 <_strtoul_l.isra.0+0x8c>
   31506:	f1a5 0437 	sub.w	r4, r5, #55	; 0x37
   3150a:	42a3      	cmp	r3, r4
   3150c:	dd0c      	ble.n	31528 <_strtoul_l.isra.0+0x9c>
   3150e:	2f00      	cmp	r7, #0
   31510:	dae9      	bge.n	314e6 <_strtoul_l.isra.0+0x5a>
   31512:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   31516:	e7ec      	b.n	314f2 <_strtoul_l.isra.0+0x66>
   31518:	f1a5 0461 	sub.w	r4, r5, #97	; 0x61
   3151c:	2c19      	cmp	r4, #25
   3151e:	d803      	bhi.n	31528 <_strtoul_l.isra.0+0x9c>
   31520:	f1a5 0457 	sub.w	r4, r5, #87	; 0x57
   31524:	42a3      	cmp	r3, r4
   31526:	dcf2      	bgt.n	3150e <_strtoul_l.isra.0+0x82>
   31528:	2f00      	cmp	r7, #0
   3152a:	db0b      	blt.n	31544 <_strtoul_l.isra.0+0xb8>
   3152c:	b106      	cbz	r6, 31530 <_strtoul_l.isra.0+0xa4>
   3152e:	4240      	negs	r0, r0
   31530:	b10a      	cbz	r2, 31536 <_strtoul_l.isra.0+0xaa>
   31532:	b977      	cbnz	r7, 31552 <_strtoul_l.isra.0+0xc6>
   31534:	6011      	str	r1, [r2, #0]
   31536:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3153a:	4554      	cmp	r4, sl
   3153c:	ddd6      	ble.n	314ec <_strtoul_l.isra.0+0x60>
   3153e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   31542:	e7d6      	b.n	314f2 <_strtoul_l.isra.0+0x66>
   31544:	2322      	movs	r3, #34	; 0x22
   31546:	f8ce 3000 	str.w	r3, [lr]
   3154a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3154e:	2a00      	cmp	r2, #0
   31550:	d0f1      	beq.n	31536 <_strtoul_l.isra.0+0xaa>
   31552:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
   31556:	e7ed      	b.n	31534 <_strtoul_l.isra.0+0xa8>
   31558:	f89c 5000 	ldrb.w	r5, [ip]
   3155c:	2601      	movs	r6, #1
   3155e:	f100 0c02 	add.w	ip, r0, #2
   31562:	e7a8      	b.n	314b6 <_strtoul_l.isra.0+0x2a>
   31564:	2d30      	cmp	r5, #48	; 0x30
   31566:	d124      	bne.n	315b2 <_strtoul_l.isra.0+0x126>
   31568:	f89c 0000 	ldrb.w	r0, [ip]
   3156c:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   31570:	2858      	cmp	r0, #88	; 0x58
   31572:	d118      	bne.n	315a6 <_strtoul_l.isra.0+0x11a>
   31574:	f04f 0910 	mov.w	r9, #16
   31578:	f89c 5001 	ldrb.w	r5, [ip, #1]
   3157c:	464b      	mov	r3, r9
   3157e:	f04f 0a0f 	mov.w	sl, #15
   31582:	f10c 0c02 	add.w	ip, ip, #2
   31586:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
   3158a:	e7a9      	b.n	314e0 <_strtoul_l.isra.0+0x54>
   3158c:	f89c 3000 	ldrb.w	r3, [ip]
   31590:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   31594:	2b58      	cmp	r3, #88	; 0x58
   31596:	d0ed      	beq.n	31574 <_strtoul_l.isra.0+0xe8>
   31598:	2308      	movs	r3, #8
   3159a:	4699      	mov	r9, r3
   3159c:	f04f 0a07 	mov.w	sl, #7
   315a0:	f06f 4860 	mvn.w	r8, #3758096384	; 0xe0000000
   315a4:	e79c      	b.n	314e0 <_strtoul_l.isra.0+0x54>
   315a6:	4699      	mov	r9, r3
   315a8:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
   315ac:	f04f 0a0f 	mov.w	sl, #15
   315b0:	e796      	b.n	314e0 <_strtoul_l.isra.0+0x54>
   315b2:	f04f 0a0f 	mov.w	sl, #15
   315b6:	f06f 4870 	mvn.w	r8, #4026531840	; 0xf0000000
   315ba:	4699      	mov	r9, r3
   315bc:	e790      	b.n	314e0 <_strtoul_l.isra.0+0x54>
   315be:	bf00      	nop
   315c0:	000466c9 	.word	0x000466c9
   315c4:	19999999 	.word	0x19999999

000315c8 <_strtoul_r>:
   315c8:	f7ff bf60 	b.w	3148c <_strtoul_l.isra.0>

000315cc <strtoul>:
   315cc:	b430      	push	{r4, r5}
   315ce:	4c04      	ldr	r4, [pc, #16]	; (315e0 <strtoul+0x14>)
   315d0:	460d      	mov	r5, r1
   315d2:	4613      	mov	r3, r2
   315d4:	4601      	mov	r1, r0
   315d6:	462a      	mov	r2, r5
   315d8:	6820      	ldr	r0, [r4, #0]
   315da:	bc30      	pop	{r4, r5}
   315dc:	f7ff bf56 	b.w	3148c <_strtoul_l.isra.0>
   315e0:	10002d7c 	.word	0x10002d7c

000315e4 <_sungetc_r>:
   315e4:	b538      	push	{r3, r4, r5, lr}
   315e6:	1c4b      	adds	r3, r1, #1
   315e8:	d01a      	beq.n	31620 <_sungetc_r+0x3c>
   315ea:	8993      	ldrh	r3, [r2, #12]
   315ec:	4614      	mov	r4, r2
   315ee:	6b12      	ldr	r2, [r2, #48]	; 0x30
   315f0:	f023 0320 	bic.w	r3, r3, #32
   315f4:	b2cd      	uxtb	r5, r1
   315f6:	81a3      	strh	r3, [r4, #12]
   315f8:	b1aa      	cbz	r2, 31626 <_sungetc_r+0x42>
   315fa:	6862      	ldr	r2, [r4, #4]
   315fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
   315fe:	429a      	cmp	r2, r3
   31600:	da09      	bge.n	31616 <_sungetc_r+0x32>
   31602:	6823      	ldr	r3, [r4, #0]
   31604:	1e5a      	subs	r2, r3, #1
   31606:	6022      	str	r2, [r4, #0]
   31608:	f803 5c01 	strb.w	r5, [r3, #-1]
   3160c:	6863      	ldr	r3, [r4, #4]
   3160e:	3301      	adds	r3, #1
   31610:	6063      	str	r3, [r4, #4]
   31612:	4628      	mov	r0, r5
   31614:	bd38      	pop	{r3, r4, r5, pc}
   31616:	4621      	mov	r1, r4
   31618:	f001 f9ae 	bl	32978 <__submore>
   3161c:	2800      	cmp	r0, #0
   3161e:	d0f0      	beq.n	31602 <_sungetc_r+0x1e>
   31620:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   31624:	e7f5      	b.n	31612 <_sungetc_r+0x2e>
   31626:	6922      	ldr	r2, [r4, #16]
   31628:	6823      	ldr	r3, [r4, #0]
   3162a:	b12a      	cbz	r2, 31638 <_sungetc_r+0x54>
   3162c:	429a      	cmp	r2, r3
   3162e:	d203      	bcs.n	31638 <_sungetc_r+0x54>
   31630:	f813 2c01 	ldrb.w	r2, [r3, #-1]
   31634:	42aa      	cmp	r2, r5
   31636:	d00f      	beq.n	31658 <_sungetc_r+0x74>
   31638:	63a3      	str	r3, [r4, #56]	; 0x38
   3163a:	4623      	mov	r3, r4
   3163c:	6860      	ldr	r0, [r4, #4]
   3163e:	63e0      	str	r0, [r4, #60]	; 0x3c
   31640:	f104 0140 	add.w	r1, r4, #64	; 0x40
   31644:	2203      	movs	r2, #3
   31646:	e9c4 120c 	strd	r1, r2, [r4, #48]	; 0x30
   3164a:	f803 5f42 	strb.w	r5, [r3, #66]!
   3164e:	2201      	movs	r2, #1
   31650:	e9c4 3200 	strd	r3, r2, [r4]
   31654:	4628      	mov	r0, r5
   31656:	bd38      	pop	{r3, r4, r5, pc}
   31658:	6862      	ldr	r2, [r4, #4]
   3165a:	3b01      	subs	r3, #1
   3165c:	3201      	adds	r2, #1
   3165e:	e9c4 3200 	strd	r3, r2, [r4]
   31662:	e7d6      	b.n	31612 <_sungetc_r+0x2e>

00031664 <__ssrefill_r>:
   31664:	b510      	push	{r4, lr}
   31666:	460c      	mov	r4, r1
   31668:	6b09      	ldr	r1, [r1, #48]	; 0x30
   3166a:	b169      	cbz	r1, 31688 <__ssrefill_r+0x24>
   3166c:	f104 0340 	add.w	r3, r4, #64	; 0x40
   31670:	4299      	cmp	r1, r3
   31672:	d001      	beq.n	31678 <__ssrefill_r+0x14>
   31674:	f001 fa18 	bl	32aa8 <_free_r>
   31678:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   3167a:	6063      	str	r3, [r4, #4]
   3167c:	2000      	movs	r0, #0
   3167e:	6320      	str	r0, [r4, #48]	; 0x30
   31680:	b113      	cbz	r3, 31688 <__ssrefill_r+0x24>
   31682:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   31684:	6023      	str	r3, [r4, #0]
   31686:	bd10      	pop	{r4, pc}
   31688:	89a3      	ldrh	r3, [r4, #12]
   3168a:	6922      	ldr	r2, [r4, #16]
   3168c:	6022      	str	r2, [r4, #0]
   3168e:	f043 0320 	orr.w	r3, r3, #32
   31692:	2200      	movs	r2, #0
   31694:	81a3      	strh	r3, [r4, #12]
   31696:	6062      	str	r2, [r4, #4]
   31698:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3169c:	bd10      	pop	{r4, pc}
   3169e:	bf00      	nop

000316a0 <_sfread_r>:
   316a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   316a4:	b083      	sub	sp, #12
   316a6:	fb02 fa03 	mul.w	sl, r2, r3
   316aa:	9c0c      	ldr	r4, [sp, #48]	; 0x30
   316ac:	9201      	str	r2, [sp, #4]
   316ae:	469b      	mov	fp, r3
   316b0:	f1ba 0f00 	cmp.w	sl, #0
   316b4:	d025      	beq.n	31702 <_sfread_r+0x62>
   316b6:	4607      	mov	r7, r0
   316b8:	4689      	mov	r9, r1
   316ba:	4656      	mov	r6, sl
   316bc:	f04f 0800 	mov.w	r8, #0
   316c0:	e00f      	b.n	316e2 <_sfread_r+0x42>
   316c2:	6821      	ldr	r1, [r4, #0]
   316c4:	f7e6 fdc6 	bl	18254 <memcpy>
   316c8:	6822      	ldr	r2, [r4, #0]
   316ca:	f8c4 8004 	str.w	r8, [r4, #4]
   316ce:	442a      	add	r2, r5
   316d0:	6022      	str	r2, [r4, #0]
   316d2:	4621      	mov	r1, r4
   316d4:	4638      	mov	r0, r7
   316d6:	f7ff ffc5 	bl	31664 <__ssrefill_r>
   316da:	44a9      	add	r9, r5
   316dc:	1b72      	subs	r2, r6, r5
   316de:	b9a0      	cbnz	r0, 3170a <_sfread_r+0x6a>
   316e0:	4616      	mov	r6, r2
   316e2:	6865      	ldr	r5, [r4, #4]
   316e4:	42b5      	cmp	r5, r6
   316e6:	4648      	mov	r0, r9
   316e8:	462a      	mov	r2, r5
   316ea:	d3ea      	bcc.n	316c2 <_sfread_r+0x22>
   316ec:	6821      	ldr	r1, [r4, #0]
   316ee:	4632      	mov	r2, r6
   316f0:	f7e6 fdb0 	bl	18254 <memcpy>
   316f4:	e9d4 5300 	ldrd	r5, r3, [r4]
   316f8:	1b9b      	subs	r3, r3, r6
   316fa:	4435      	add	r5, r6
   316fc:	e9c4 5300 	strd	r5, r3, [r4]
   31700:	46da      	mov	sl, fp
   31702:	4650      	mov	r0, sl
   31704:	b003      	add	sp, #12
   31706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3170a:	9b01      	ldr	r3, [sp, #4]
   3170c:	4455      	add	r5, sl
   3170e:	1bad      	subs	r5, r5, r6
   31710:	fbb5 faf3 	udiv	sl, r5, r3
   31714:	4650      	mov	r0, sl
   31716:	b003      	add	sp, #12
   31718:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0003171c <__ssvfiscanf_r>:
   3171c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   31720:	ed2d 8b02 	vpush	{d8}
   31724:	b0e1      	sub	sp, #388	; 0x184
   31726:	468b      	mov	fp, r1
   31728:	f9b1 100c 	ldrsh.w	r1, [r1, #12]
   3172c:	af02      	add	r7, sp, #8
   3172e:	048d      	lsls	r5, r1, #18
   31730:	4604      	mov	r4, r0
   31732:	623b      	str	r3, [r7, #32]
   31734:	d409      	bmi.n	3174a <__ssvfiscanf_r+0x2e>
   31736:	f8db 3064 	ldr.w	r3, [fp, #100]	; 0x64
   3173a:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
   3173e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
   31742:	f8ab 100c 	strh.w	r1, [fp, #12]
   31746:	f8cb 3064 	str.w	r3, [fp, #100]	; 0x64
   3174a:	4690      	mov	r8, r2
   3174c:	f818 3b01 	ldrb.w	r3, [r8], #1
   31750:	63fb      	str	r3, [r7, #60]	; 0x3c
   31752:	2b00      	cmp	r3, #0
   31754:	f001 802b 	beq.w	327ae <__ssvfiscanf_r+0x1092>
   31758:	2200      	movs	r2, #0
   3175a:	e9c7 2209 	strd	r2, r2, [r7, #36]	; 0x24
   3175e:	617a      	str	r2, [r7, #20]
   31760:	62fa      	str	r2, [r7, #44]	; 0x2c
   31762:	4692      	mov	sl, r2
   31764:	613a      	str	r2, [r7, #16]
   31766:	4a7c      	ldr	r2, [pc, #496]	; (31958 <__ssvfiscanf_r+0x23c>)
   31768:	46a1      	mov	r9, r4
   3176a:	5cd4      	ldrb	r4, [r2, r3]
   3176c:	f014 0408 	ands.w	r4, r4, #8
   31770:	f040 80ac 	bne.w	318cc <__ssvfiscanf_r+0x1b0>
   31774:	2b25      	cmp	r3, #37	; 0x25
   31776:	f040 8089 	bne.w	3188c <__ssvfiscanf_r+0x170>
   3177a:	f898 2000 	ldrb.w	r2, [r8]
   3177e:	637c      	str	r4, [r7, #52]	; 0x34
   31780:	f1a2 0325 	sub.w	r3, r2, #37	; 0x25
   31784:	f108 0101 	add.w	r1, r8, #1
   31788:	2b55      	cmp	r3, #85	; 0x55
   3178a:	d86e      	bhi.n	3186a <__ssvfiscanf_r+0x14e>
   3178c:	e8df f013 	tbh	[pc, r3, lsl #1]
   31790:	006d007d 	.word	0x006d007d
   31794:	006d006d 	.word	0x006d006d
   31798:	023a006d 	.word	0x023a006d
   3179c:	006d006d 	.word	0x006d006d
   317a0:	006d006d 	.word	0x006d006d
   317a4:	00c9006d 	.word	0x00c9006d
   317a8:	00c900c9 	.word	0x00c900c9
   317ac:	00c900c9 	.word	0x00c900c9
   317b0:	00c900c9 	.word	0x00c900c9
   317b4:	00c900c9 	.word	0x00c900c9
   317b8:	006d00c9 	.word	0x006d00c9
   317bc:	006d006d 	.word	0x006d006d
   317c0:	006d006d 	.word	0x006d006d
   317c4:	006d006d 	.word	0x006d006d
   317c8:	006d006d 	.word	0x006d006d
   317cc:	0231022a 	.word	0x0231022a
   317d0:	006d006d 	.word	0x006d006d
   317d4:	006d006d 	.word	0x006d006d
   317d8:	006d006d 	.word	0x006d006d
   317dc:	00d8006d 	.word	0x00d8006d
   317e0:	006d006d 	.word	0x006d006d
   317e4:	006d01bd 	.word	0x006d01bd
   317e8:	006d006d 	.word	0x006d006d
   317ec:	006d021e 	.word	0x006d021e
   317f0:	006d006d 	.word	0x006d006d
   317f4:	00e6006d 	.word	0x00e6006d
   317f8:	006d006d 	.word	0x006d006d
   317fc:	006d0215 	.word	0x006d0215
   31800:	006d006d 	.word	0x006d006d
   31804:	006d006d 	.word	0x006d006d
   31808:	006d006d 	.word	0x006d006d
   3180c:	05cf05ca 	.word	0x05cf05ca
   31810:	006d006d 	.word	0x006d006d
   31814:	0209006d 	.word	0x0209006d
   31818:	00d80223 	.word	0x00d80223
   3181c:	01d3006d 	.word	0x01d3006d
   31820:	01ed01df 	.word	0x01ed01df
   31824:	01fb05cc 	.word	0x01fb05cc
   31828:	006d006d 	.word	0x006d006d
   3182c:	00e001ff 	.word	0x00e001ff
   31830:	006d0202 	.word	0x006d0202
   31834:	00e6006d 	.word	0x00e6006d
   31838:	00e0006d 	.word	0x00e0006d
   3183c:	4659      	mov	r1, fp
   3183e:	4648      	mov	r0, r9
   31840:	f7ff ff10 	bl	31664 <__ssrefill_r>
   31844:	2800      	cmp	r0, #0
   31846:	f000 83ee 	beq.w	32026 <__ssvfiscanf_r+0x90a>
   3184a:	4633      	mov	r3, r6
   3184c:	4646      	mov	r6, r8
   3184e:	f8d7 8008 	ldr.w	r8, [r7, #8]
   31852:	2b00      	cmp	r3, #0
   31854:	f000 866f 	beq.w	32536 <__ssvfiscanf_r+0xe1a>
   31858:	6abb      	ldr	r3, [r7, #40]	; 0x28
   3185a:	2b00      	cmp	r3, #0
   3185c:	f000 85c3 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   31860:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   31864:	065a      	lsls	r2, r3, #25
   31866:	f100 85be 	bmi.w	323e6 <__ssvfiscanf_r+0xcca>
   3186a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3186c:	b12b      	cbz	r3, 3187a <__ssvfiscanf_r+0x15e>
   3186e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31870:	681e      	ldr	r6, [r3, #0]
   31872:	b116      	cbz	r6, 3187a <__ssvfiscanf_r+0x15e>
   31874:	4630      	mov	r0, r6
   31876:	f7ff fa5f 	bl	30d38 <free>
   3187a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
   3187c:	f507 77be 	add.w	r7, r7, #380	; 0x17c
   31880:	46bd      	mov	sp, r7
   31882:	ecbd 8b02 	vpop	{d8}
   31886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3188a:	4688      	mov	r8, r1
   3188c:	f8db 3004 	ldr.w	r3, [fp, #4]
   31890:	2b00      	cmp	r3, #0
   31892:	dd3f      	ble.n	31914 <__ssvfiscanf_r+0x1f8>
   31894:	f8db 3000 	ldr.w	r3, [fp]
   31898:	f818 2c01 	ldrb.w	r2, [r8, #-1]
   3189c:	7819      	ldrb	r1, [r3, #0]
   3189e:	4291      	cmp	r1, r2
   318a0:	d1e3      	bne.n	3186a <__ssvfiscanf_r+0x14e>
   318a2:	f8db 2004 	ldr.w	r2, [fp, #4]
   318a6:	3301      	adds	r3, #1
   318a8:	3a01      	subs	r2, #1
   318aa:	f8cb 3000 	str.w	r3, [fp]
   318ae:	f10a 0a01 	add.w	sl, sl, #1
   318b2:	f8cb 2004 	str.w	r2, [fp, #4]
   318b6:	f818 3b01 	ldrb.w	r3, [r8], #1
   318ba:	63fb      	str	r3, [r7, #60]	; 0x3c
   318bc:	2b00      	cmp	r3, #0
   318be:	d0d4      	beq.n	3186a <__ssvfiscanf_r+0x14e>
   318c0:	4a25      	ldr	r2, [pc, #148]	; (31958 <__ssvfiscanf_r+0x23c>)
   318c2:	5cd4      	ldrb	r4, [r2, r3]
   318c4:	f014 0408 	ands.w	r4, r4, #8
   318c8:	f43f af54 	beq.w	31774 <__ssvfiscanf_r+0x58>
   318cc:	f8db 2004 	ldr.w	r2, [fp, #4]
   318d0:	e012      	b.n	318f8 <__ssvfiscanf_r+0x1dc>
   318d2:	f8db 3000 	ldr.w	r3, [fp]
   318d6:	4920      	ldr	r1, [pc, #128]	; (31958 <__ssvfiscanf_r+0x23c>)
   318d8:	781a      	ldrb	r2, [r3, #0]
   318da:	5c8a      	ldrb	r2, [r1, r2]
   318dc:	f012 0f08 	tst.w	r2, #8
   318e0:	f103 0301 	add.w	r3, r3, #1
   318e4:	d0e7      	beq.n	318b6 <__ssvfiscanf_r+0x19a>
   318e6:	f8db 2004 	ldr.w	r2, [fp, #4]
   318ea:	f8cb 3000 	str.w	r3, [fp]
   318ee:	3a01      	subs	r2, #1
   318f0:	f10a 0a01 	add.w	sl, sl, #1
   318f4:	f8cb 2004 	str.w	r2, [fp, #4]
   318f8:	2a00      	cmp	r2, #0
   318fa:	dcea      	bgt.n	318d2 <__ssvfiscanf_r+0x1b6>
   318fc:	4659      	mov	r1, fp
   318fe:	4648      	mov	r0, r9
   31900:	f7ff feb0 	bl	31664 <__ssrefill_r>
   31904:	2800      	cmp	r0, #0
   31906:	d0e4      	beq.n	318d2 <__ssvfiscanf_r+0x1b6>
   31908:	f818 3b01 	ldrb.w	r3, [r8], #1
   3190c:	63fb      	str	r3, [r7, #60]	; 0x3c
   3190e:	2b00      	cmp	r3, #0
   31910:	d1d6      	bne.n	318c0 <__ssvfiscanf_r+0x1a4>
   31912:	e7aa      	b.n	3186a <__ssvfiscanf_r+0x14e>
   31914:	4659      	mov	r1, fp
   31916:	4648      	mov	r0, r9
   31918:	f7ff fea4 	bl	31664 <__ssrefill_r>
   3191c:	2800      	cmp	r0, #0
   3191e:	d0b9      	beq.n	31894 <__ssvfiscanf_r+0x178>
   31920:	e79a      	b.n	31858 <__ssvfiscanf_r+0x13c>
   31922:	f014 0f8f 	tst.w	r4, #143	; 0x8f
   31926:	d1a0      	bne.n	3186a <__ssvfiscanf_r+0x14e>
   31928:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   3192a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   3192e:	eb02 0243 	add.w	r2, r2, r3, lsl #1
   31932:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
   31936:	637b      	str	r3, [r7, #52]	; 0x34
   31938:	f898 2001 	ldrb.w	r2, [r8, #1]
   3193c:	4688      	mov	r8, r1
   3193e:	e71f      	b.n	31780 <__ssvfiscanf_r+0x64>
   31940:	0723      	lsls	r3, r4, #28
   31942:	d192      	bne.n	3186a <__ssvfiscanf_r+0x14e>
   31944:	f898 2001 	ldrb.w	r2, [r8, #1]
   31948:	f044 0402 	orr.w	r4, r4, #2
   3194c:	4688      	mov	r8, r1
   3194e:	e717      	b.n	31780 <__ssvfiscanf_r+0x64>
   31950:	0726      	lsls	r6, r4, #28
   31952:	d18a      	bne.n	3186a <__ssvfiscanf_r+0x14e>
   31954:	e7f0      	b.n	31938 <__ssvfiscanf_r+0x21c>
   31956:	bf00      	nop
   31958:	000466c9 	.word	0x000466c9
   3195c:	61b9      	str	r1, [r7, #24]
   3195e:	f444 7400 	orr.w	r4, r4, #512	; 0x200
   31962:	4bad      	ldr	r3, [pc, #692]	; (31c18 <__ssvfiscanf_r+0x4fc>)
   31964:	617b      	str	r3, [r7, #20]
   31966:	2310      	movs	r3, #16
   31968:	627b      	str	r3, [r7, #36]	; 0x24
   3196a:	2503      	movs	r5, #3
   3196c:	f8db 3004 	ldr.w	r3, [fp, #4]
   31970:	2b00      	cmp	r3, #0
   31972:	f340 80d8 	ble.w	31b26 <__ssvfiscanf_r+0x40a>
   31976:	0666      	lsls	r6, r4, #25
   31978:	f140 80b1 	bpl.w	31ade <__ssvfiscanf_r+0x3c2>
   3197c:	2d02      	cmp	r5, #2
   3197e:	f000 82c1 	beq.w	31f04 <__ssvfiscanf_r+0x7e8>
   31982:	2d03      	cmp	r5, #3
   31984:	f000 8204 	beq.w	31d90 <__ssvfiscanf_r+0x674>
   31988:	2d01      	cmp	r5, #1
   3198a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   3198c:	f000 814a 	beq.w	31c24 <__ssvfiscanf_r+0x508>
   31990:	2b01      	cmp	r3, #1
   31992:	bf38      	it	cc
   31994:	2301      	movcc	r3, #1
   31996:	637b      	str	r3, [r7, #52]	; 0x34
   31998:	f014 0301 	ands.w	r3, r4, #1
   3199c:	f000 83e0 	beq.w	32160 <__ssvfiscanf_r+0xa44>
   319a0:	f014 0310 	ands.w	r3, r4, #16
   319a4:	61fb      	str	r3, [r7, #28]
   319a6:	f040 8663 	bne.w	32670 <__ssvfiscanf_r+0xf54>
   319aa:	0621      	lsls	r1, r4, #24
   319ac:	f140 86b9 	bpl.w	32722 <__ssvfiscanf_r+0x1006>
   319b0:	6a3d      	ldr	r5, [r7, #32]
   319b2:	f855 3b04 	ldr.w	r3, [r5], #4
   319b6:	60fb      	str	r3, [r7, #12]
   319b8:	2b00      	cmp	r3, #0
   319ba:	f43f af56 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   319be:	2080      	movs	r0, #128	; 0x80
   319c0:	f7ff f9b2 	bl	30d28 <malloc>
   319c4:	4606      	mov	r6, r0
   319c6:	2800      	cmp	r0, #0
   319c8:	f000 850d 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   319cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   319ce:	68fa      	ldr	r2, [r7, #12]
   319d0:	f8b3 8006 	ldrh.w	r8, [r3, #6]
   319d4:	889c      	ldrh	r4, [r3, #4]
   319d6:	6010      	str	r0, [r2, #0]
   319d8:	45a0      	cmp	r8, r4
   319da:	f080 84c6 	bcs.w	3236a <__ssvfiscanf_r+0xc4e>
   319de:	6818      	ldr	r0, [r3, #0]
   319e0:	68fa      	ldr	r2, [r7, #12]
   319e2:	f840 2028 	str.w	r2, [r0, r8, lsl #2]
   319e6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   319e8:	623d      	str	r5, [r7, #32]
   319ea:	f108 0301 	add.w	r3, r8, #1
   319ee:	80d3      	strh	r3, [r2, #6]
   319f0:	2320      	movs	r3, #32
   319f2:	607e      	str	r6, [r7, #4]
   319f4:	60bb      	str	r3, [r7, #8]
   319f6:	2400      	movs	r4, #0
   319f8:	4625      	mov	r5, r4
   319fa:	693c      	ldr	r4, [r7, #16]
   319fc:	f8c7 a030 	str.w	sl, [r7, #48]	; 0x30
   31a00:	f107 0850 	add.w	r8, r7, #80	; 0x50
   31a04:	f001 f962 	bl	32ccc <__locale_mb_cur_max>
   31a08:	42a8      	cmp	r0, r5
   31a0a:	f43f af25 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31a0e:	e9db 0300 	ldrd	r0, r3, [fp]
   31a12:	2c03      	cmp	r4, #3
   31a14:	f810 1b01 	ldrb.w	r1, [r0], #1
   31a18:	f808 1005 	strb.w	r1, [r8, r5]
   31a1c:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
   31a20:	f105 0a01 	add.w	sl, r5, #1
   31a24:	f8cb 0000 	str.w	r0, [fp]
   31a28:	f8cb 3004 	str.w	r3, [fp, #4]
   31a2c:	f107 0548 	add.w	r5, r7, #72	; 0x48
   31a30:	d102      	bne.n	31a38 <__ssvfiscanf_r+0x31c>
   31a32:	682a      	ldr	r2, [r5, #0]
   31a34:	2a04      	cmp	r2, #4
   31a36:	d004      	beq.n	31a42 <__ssvfiscanf_r+0x326>
   31a38:	2208      	movs	r2, #8
   31a3a:	2100      	movs	r1, #0
   31a3c:	4628      	mov	r0, r5
   31a3e:	f7fe fb57 	bl	300f0 <memset>
   31a42:	4642      	mov	r2, r8
   31a44:	9500      	str	r5, [sp, #0]
   31a46:	4653      	mov	r3, sl
   31a48:	4631      	mov	r1, r6
   31a4a:	4648      	mov	r0, r9
   31a4c:	f001 f944 	bl	32cd8 <_mbrtowc_r>
   31a50:	1c42      	adds	r2, r0, #1
   31a52:	4604      	mov	r4, r0
   31a54:	f43f af00 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31a58:	2800      	cmp	r0, #0
   31a5a:	f040 84e6 	bne.w	3242a <__ssvfiscanf_r+0xd0e>
   31a5e:	69fb      	ldr	r3, [r7, #28]
   31a60:	b903      	cbnz	r3, 31a64 <__ssvfiscanf_r+0x348>
   31a62:	6033      	str	r3, [r6, #0]
   31a64:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   31a66:	4453      	add	r3, sl
   31a68:	633b      	str	r3, [r7, #48]	; 0x30
   31a6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31a6c:	3b01      	subs	r3, #1
   31a6e:	637b      	str	r3, [r7, #52]	; 0x34
   31a70:	69fb      	ldr	r3, [r7, #28]
   31a72:	b94b      	cbnz	r3, 31a88 <__ssvfiscanf_r+0x36c>
   31a74:	68fb      	ldr	r3, [r7, #12]
   31a76:	b133      	cbz	r3, 31a86 <__ssvfiscanf_r+0x36a>
   31a78:	687b      	ldr	r3, [r7, #4]
   31a7a:	1af5      	subs	r5, r6, r3
   31a7c:	68bb      	ldr	r3, [r7, #8]
   31a7e:	ebb3 0fa5 	cmp.w	r3, r5, asr #2
   31a82:	f240 8545 	bls.w	32510 <__ssvfiscanf_r+0xdf4>
   31a86:	3604      	adds	r6, #4
   31a88:	f8db 3004 	ldr.w	r3, [fp, #4]
   31a8c:	2b00      	cmp	r3, #0
   31a8e:	f04f 0500 	mov.w	r5, #0
   31a92:	f340 84d2 	ble.w	3243a <__ssvfiscanf_r+0xd1e>
   31a96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31a98:	2b00      	cmp	r3, #0
   31a9a:	d1b3      	bne.n	31a04 <__ssvfiscanf_r+0x2e8>
   31a9c:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
   31aa0:	613c      	str	r4, [r7, #16]
   31aa2:	68fb      	ldr	r3, [r7, #12]
   31aa4:	b133      	cbz	r3, 31ab4 <__ssvfiscanf_r+0x398>
   31aa6:	687b      	ldr	r3, [r7, #4]
   31aa8:	1af1      	subs	r1, r6, r3
   31aaa:	68bb      	ldr	r3, [r7, #8]
   31aac:	ebb3 0fa1 	cmp.w	r3, r1, asr #2
   31ab0:	f200 8722 	bhi.w	328f8 <__ssvfiscanf_r+0x11dc>
   31ab4:	69fb      	ldr	r3, [r7, #28]
   31ab6:	b913      	cbnz	r3, 31abe <__ssvfiscanf_r+0x3a2>
   31ab8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   31aba:	3301      	adds	r3, #1
   31abc:	62bb      	str	r3, [r7, #40]	; 0x28
   31abe:	f8d7 8018 	ldr.w	r8, [r7, #24]
   31ac2:	f818 3b01 	ldrb.w	r3, [r8], #1
   31ac6:	63fb      	str	r3, [r7, #60]	; 0x3c
   31ac8:	2b00      	cmp	r3, #0
   31aca:	f47f aef9 	bne.w	318c0 <__ssvfiscanf_r+0x1a4>
   31ace:	e6cc      	b.n	3186a <__ssvfiscanf_r+0x14e>
   31ad0:	4659      	mov	r1, fp
   31ad2:	4648      	mov	r0, r9
   31ad4:	f7ff fdc6 	bl	31664 <__ssrefill_r>
   31ad8:	2800      	cmp	r0, #0
   31ada:	f47f aebd 	bne.w	31858 <__ssvfiscanf_r+0x13c>
   31ade:	f8db 2000 	ldr.w	r2, [fp]
   31ae2:	7813      	ldrb	r3, [r2, #0]
   31ae4:	494d      	ldr	r1, [pc, #308]	; (31c1c <__ssvfiscanf_r+0x500>)
   31ae6:	5ccb      	ldrb	r3, [r1, r3]
   31ae8:	0718      	lsls	r0, r3, #28
   31aea:	f57f af47 	bpl.w	3197c <__ssvfiscanf_r+0x260>
   31aee:	f8db 3004 	ldr.w	r3, [fp, #4]
   31af2:	3b01      	subs	r3, #1
   31af4:	2b00      	cmp	r3, #0
   31af6:	f10a 0a01 	add.w	sl, sl, #1
   31afa:	f8cb 3004 	str.w	r3, [fp, #4]
   31afe:	f102 0201 	add.w	r2, r2, #1
   31b02:	dde5      	ble.n	31ad0 <__ssvfiscanf_r+0x3b4>
   31b04:	f8cb 2000 	str.w	r2, [fp]
   31b08:	e7eb      	b.n	31ae2 <__ssvfiscanf_r+0x3c6>
   31b0a:	61b9      	str	r1, [r7, #24]
   31b0c:	f044 0401 	orr.w	r4, r4, #1
   31b10:	4b41      	ldr	r3, [pc, #260]	; (31c18 <__ssvfiscanf_r+0x4fc>)
   31b12:	617b      	str	r3, [r7, #20]
   31b14:	2308      	movs	r3, #8
   31b16:	627b      	str	r3, [r7, #36]	; 0x24
   31b18:	f8db 3004 	ldr.w	r3, [fp, #4]
   31b1c:	2b00      	cmp	r3, #0
   31b1e:	f04f 0503 	mov.w	r5, #3
   31b22:	f73f af28 	bgt.w	31976 <__ssvfiscanf_r+0x25a>
   31b26:	4659      	mov	r1, fp
   31b28:	4648      	mov	r0, r9
   31b2a:	f7ff fd9b 	bl	31664 <__ssrefill_r>
   31b2e:	2800      	cmp	r0, #0
   31b30:	f43f af21 	beq.w	31976 <__ssvfiscanf_r+0x25a>
   31b34:	e690      	b.n	31858 <__ssvfiscanf_r+0x13c>
   31b36:	0720      	lsls	r0, r4, #28
   31b38:	f47f ae97 	bne.w	3186a <__ssvfiscanf_r+0x14e>
   31b3c:	f898 2001 	ldrb.w	r2, [r8, #1]
   31b40:	2a6c      	cmp	r2, #108	; 0x6c
   31b42:	f000 85bd 	beq.w	326c0 <__ssvfiscanf_r+0xfa4>
   31b46:	f044 0401 	orr.w	r4, r4, #1
   31b4a:	4688      	mov	r8, r1
   31b4c:	e618      	b.n	31780 <__ssvfiscanf_r+0x64>
   31b4e:	f014 038f 	ands.w	r3, r4, #143	; 0x8f
   31b52:	f47f ae8a 	bne.w	3186a <__ssvfiscanf_r+0x14e>
   31b56:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   31b58:	2a00      	cmp	r2, #0
   31b5a:	f000 8600 	beq.w	3275e <__ssvfiscanf_r+0x1042>
   31b5e:	f898 2001 	ldrb.w	r2, [r8, #1]
   31b62:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   31b66:	4688      	mov	r8, r1
   31b68:	e60a      	b.n	31780 <__ssvfiscanf_r+0x64>
   31b6a:	06e5      	lsls	r5, r4, #27
   31b6c:	61b9      	str	r1, [r7, #24]
   31b6e:	d4a6      	bmi.n	31abe <__ssvfiscanf_r+0x3a2>
   31b70:	0720      	lsls	r0, r4, #28
   31b72:	f140 861f 	bpl.w	327b4 <__ssvfiscanf_r+0x1098>
   31b76:	6a3a      	ldr	r2, [r7, #32]
   31b78:	f852 3b04 	ldr.w	r3, [r2], #4
   31b7c:	623a      	str	r2, [r7, #32]
   31b7e:	4688      	mov	r8, r1
   31b80:	f883 a000 	strb.w	sl, [r3]
   31b84:	e697      	b.n	318b6 <__ssvfiscanf_r+0x19a>
   31b86:	61b9      	str	r1, [r7, #24]
   31b88:	f444 7408 	orr.w	r4, r4, #544	; 0x220
   31b8c:	e6e9      	b.n	31962 <__ssvfiscanf_r+0x246>
   31b8e:	61b9      	str	r1, [r7, #24]
   31b90:	2502      	movs	r5, #2
   31b92:	e6eb      	b.n	3196c <__ssvfiscanf_r+0x250>
   31b94:	4b20      	ldr	r3, [pc, #128]	; (31c18 <__ssvfiscanf_r+0x4fc>)
   31b96:	617b      	str	r3, [r7, #20]
   31b98:	230a      	movs	r3, #10
   31b9a:	61b9      	str	r1, [r7, #24]
   31b9c:	627b      	str	r3, [r7, #36]	; 0x24
   31b9e:	2503      	movs	r5, #3
   31ba0:	e6e4      	b.n	3196c <__ssvfiscanf_r+0x250>
   31ba2:	0722      	lsls	r2, r4, #28
   31ba4:	f47f ae61 	bne.w	3186a <__ssvfiscanf_r+0x14e>
   31ba8:	f898 2001 	ldrb.w	r2, [r8, #1]
   31bac:	2a68      	cmp	r2, #104	; 0x68
   31bae:	f000 858f 	beq.w	326d0 <__ssvfiscanf_r+0xfb4>
   31bb2:	f044 0404 	orr.w	r4, r4, #4
   31bb6:	4688      	mov	r8, r1
   31bb8:	e5e2      	b.n	31780 <__ssvfiscanf_r+0x64>
   31bba:	f107 0078 	add.w	r0, r7, #120	; 0x78
   31bbe:	f001 fabb 	bl	33138 <__sccl>
   31bc2:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   31bc6:	61b8      	str	r0, [r7, #24]
   31bc8:	2501      	movs	r5, #1
   31bca:	e6cf      	b.n	3196c <__ssvfiscanf_r+0x250>
   31bcc:	61b9      	str	r1, [r7, #24]
   31bce:	f044 0401 	orr.w	r4, r4, #1
   31bd2:	2502      	movs	r5, #2
   31bd4:	e6ca      	b.n	3196c <__ssvfiscanf_r+0x250>
   31bd6:	4b12      	ldr	r3, [pc, #72]	; (31c20 <__ssvfiscanf_r+0x504>)
   31bd8:	617b      	str	r3, [r7, #20]
   31bda:	2300      	movs	r3, #0
   31bdc:	61b9      	str	r1, [r7, #24]
   31bde:	627b      	str	r3, [r7, #36]	; 0x24
   31be0:	2503      	movs	r5, #3
   31be2:	e6c3      	b.n	3196c <__ssvfiscanf_r+0x250>
   31be4:	61b9      	str	r1, [r7, #24]
   31be6:	f044 0401 	orr.w	r4, r4, #1
   31bea:	f044 0440 	orr.w	r4, r4, #64	; 0x40
   31bee:	2500      	movs	r5, #0
   31bf0:	e6bc      	b.n	3196c <__ssvfiscanf_r+0x250>
   31bf2:	61b9      	str	r1, [r7, #24]
   31bf4:	f044 0401 	orr.w	r4, r4, #1
   31bf8:	4b09      	ldr	r3, [pc, #36]	; (31c20 <__ssvfiscanf_r+0x504>)
   31bfa:	617b      	str	r3, [r7, #20]
   31bfc:	230a      	movs	r3, #10
   31bfe:	627b      	str	r3, [r7, #36]	; 0x24
   31c00:	2503      	movs	r5, #3
   31c02:	e6b3      	b.n	3196c <__ssvfiscanf_r+0x250>
   31c04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31c06:	4323      	orrs	r3, r4
   31c08:	637b      	str	r3, [r7, #52]	; 0x34
   31c0a:	f47f ae2e 	bne.w	3186a <__ssvfiscanf_r+0x14e>
   31c0e:	f898 2001 	ldrb.w	r2, [r8, #1]
   31c12:	2410      	movs	r4, #16
   31c14:	4688      	mov	r8, r1
   31c16:	e5b3      	b.n	31780 <__ssvfiscanf_r+0x64>
   31c18:	000315c9 	.word	0x000315c9
   31c1c:	000466c9 	.word	0x000466c9
   31c20:	000332cd 	.word	0x000332cd
   31c24:	2b00      	cmp	r3, #0
   31c26:	bf08      	it	eq
   31c28:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   31c2c:	07e0      	lsls	r0, r4, #31
   31c2e:	637b      	str	r3, [r7, #52]	; 0x34
   31c30:	f140 8222 	bpl.w	32078 <__ssvfiscanf_r+0x95c>
   31c34:	f014 0310 	ands.w	r3, r4, #16
   31c38:	60fb      	str	r3, [r7, #12]
   31c3a:	f040 84d4 	bne.w	325e6 <__ssvfiscanf_r+0xeca>
   31c3e:	0621      	lsls	r1, r4, #24
   31c40:	f140 8583 	bpl.w	3274a <__ssvfiscanf_r+0x102e>
   31c44:	6a3e      	ldr	r6, [r7, #32]
   31c46:	f856 3b04 	ldr.w	r3, [r6], #4
   31c4a:	60bb      	str	r3, [r7, #8]
   31c4c:	2b00      	cmp	r3, #0
   31c4e:	f43f ae0c 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   31c52:	2080      	movs	r0, #128	; 0x80
   31c54:	f7ff f868 	bl	30d28 <malloc>
   31c58:	4605      	mov	r5, r0
   31c5a:	2800      	cmp	r0, #0
   31c5c:	f000 83c3 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   31c60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31c62:	68ba      	ldr	r2, [r7, #8]
   31c64:	f8b3 8006 	ldrh.w	r8, [r3, #6]
   31c68:	889c      	ldrh	r4, [r3, #4]
   31c6a:	6010      	str	r0, [r2, #0]
   31c6c:	45a0      	cmp	r8, r4
   31c6e:	f080 838d 	bcs.w	3238c <__ssvfiscanf_r+0xc70>
   31c72:	6818      	ldr	r0, [r3, #0]
   31c74:	68ba      	ldr	r2, [r7, #8]
   31c76:	f840 2028 	str.w	r2, [r0, r8, lsl #2]
   31c7a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   31c7c:	623e      	str	r6, [r7, #32]
   31c7e:	f108 0301 	add.w	r3, r8, #1
   31c82:	80d3      	strh	r3, [r2, #6]
   31c84:	2320      	movs	r3, #32
   31c86:	607d      	str	r5, [r7, #4]
   31c88:	603b      	str	r3, [r7, #0]
   31c8a:	f8c7 a01c 	str.w	sl, [r7, #28]
   31c8e:	693e      	ldr	r6, [r7, #16]
   31c90:	46ca      	mov	sl, r9
   31c92:	2400      	movs	r4, #0
   31c94:	46a9      	mov	r9, r5
   31c96:	e043      	b.n	31d20 <__ssvfiscanf_r+0x604>
   31c98:	f8c9 0000 	str.w	r0, [r9]
   31c9c:	4605      	mov	r5, r0
   31c9e:	f107 0348 	add.w	r3, r7, #72	; 0x48
   31ca2:	4618      	mov	r0, r3
   31ca4:	2208      	movs	r2, #8
   31ca6:	2100      	movs	r1, #0
   31ca8:	613b      	str	r3, [r7, #16]
   31caa:	f7fe fa21 	bl	300f0 <memset>
   31cae:	4893      	ldr	r0, [pc, #588]	; (31efc <__ssvfiscanf_r+0x7e0>)
   31cb0:	693b      	ldr	r3, [r7, #16]
   31cb2:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
   31cb6:	462a      	mov	r2, r5
   31cb8:	f107 0138 	add.w	r1, r7, #56	; 0x38
   31cbc:	4605      	mov	r5, r0
   31cbe:	4650      	mov	r0, sl
   31cc0:	47a8      	blx	r5
   31cc2:	2801      	cmp	r0, #1
   31cc4:	f000 8417 	beq.w	324f6 <__ssvfiscanf_r+0xdda>
   31cc8:	2200      	movs	r2, #0
   31cca:	f107 0378 	add.w	r3, r7, #120	; 0x78
   31cce:	5c9b      	ldrb	r3, [r3, r2]
   31cd0:	2b00      	cmp	r3, #0
   31cd2:	f000 85e0 	beq.w	32896 <__ssvfiscanf_r+0x117a>
   31cd6:	69fb      	ldr	r3, [r7, #28]
   31cd8:	2e03      	cmp	r6, #3
   31cda:	4443      	add	r3, r8
   31cdc:	61fb      	str	r3, [r7, #28]
   31cde:	f000 840e 	beq.w	324fe <__ssvfiscanf_r+0xde2>
   31ce2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31ce4:	3b01      	subs	r3, #1
   31ce6:	637b      	str	r3, [r7, #52]	; 0x34
   31ce8:	68fb      	ldr	r3, [r7, #12]
   31cea:	2b00      	cmp	r3, #0
   31cec:	f040 83b4 	bne.w	32458 <__ssvfiscanf_r+0xd3c>
   31cf0:	68bb      	ldr	r3, [r7, #8]
   31cf2:	f109 0904 	add.w	r9, r9, #4
   31cf6:	2b00      	cmp	r3, #0
   31cf8:	f000 83ae 	beq.w	32458 <__ssvfiscanf_r+0xd3c>
   31cfc:	687b      	ldr	r3, [r7, #4]
   31cfe:	eba9 0403 	sub.w	r4, r9, r3
   31d02:	683b      	ldr	r3, [r7, #0]
   31d04:	ebb3 0fa4 	cmp.w	r3, r4, asr #2
   31d08:	f240 8430 	bls.w	3256c <__ssvfiscanf_r+0xe50>
   31d0c:	68fc      	ldr	r4, [r7, #12]
   31d0e:	f8db 3004 	ldr.w	r3, [fp, #4]
   31d12:	2b00      	cmp	r3, #0
   31d14:	f340 83a7 	ble.w	32466 <__ssvfiscanf_r+0xd4a>
   31d18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31d1a:	2b00      	cmp	r3, #0
   31d1c:	f000 84ae 	beq.w	3267c <__ssvfiscanf_r+0xf60>
   31d20:	f000 ffd4 	bl	32ccc <__locale_mb_cur_max>
   31d24:	42a0      	cmp	r0, r4
   31d26:	f43f ad97 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31d2a:	e9db 2300 	ldrd	r2, r3, [fp]
   31d2e:	f812 1b01 	ldrb.w	r1, [r2], #1
   31d32:	3b01      	subs	r3, #1
   31d34:	f107 0050 	add.w	r0, r7, #80	; 0x50
   31d38:	e9cb 2300 	strd	r2, r3, [fp]
   31d3c:	2e03      	cmp	r6, #3
   31d3e:	f107 0340 	add.w	r3, r7, #64	; 0x40
   31d42:	5501      	strb	r1, [r0, r4]
   31d44:	f104 0801 	add.w	r8, r4, #1
   31d48:	633b      	str	r3, [r7, #48]	; 0x30
   31d4a:	d102      	bne.n	31d52 <__ssvfiscanf_r+0x636>
   31d4c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
   31d4e:	2b04      	cmp	r3, #4
   31d50:	d004      	beq.n	31d5c <__ssvfiscanf_r+0x640>
   31d52:	6b38      	ldr	r0, [r7, #48]	; 0x30
   31d54:	2208      	movs	r2, #8
   31d56:	2100      	movs	r1, #0
   31d58:	f7fe f9ca 	bl	300f0 <memset>
   31d5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   31d5e:	9300      	str	r3, [sp, #0]
   31d60:	f107 0250 	add.w	r2, r7, #80	; 0x50
   31d64:	4643      	mov	r3, r8
   31d66:	4649      	mov	r1, r9
   31d68:	4650      	mov	r0, sl
   31d6a:	f000 ffb5 	bl	32cd8 <_mbrtowc_r>
   31d6e:	1c42      	adds	r2, r0, #1
   31d70:	4606      	mov	r6, r0
   31d72:	f43f ad71 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31d76:	2800      	cmp	r0, #0
   31d78:	d08e      	beq.n	31c98 <__ssvfiscanf_r+0x57c>
   31d7a:	1c83      	adds	r3, r0, #2
   31d7c:	bf08      	it	eq
   31d7e:	4644      	moveq	r4, r8
   31d80:	d0c5      	beq.n	31d0e <__ssvfiscanf_r+0x5f2>
   31d82:	f8d9 3000 	ldr.w	r3, [r9]
   31d86:	461d      	mov	r5, r3
   31d88:	3301      	adds	r3, #1
   31d8a:	d188      	bne.n	31c9e <__ssvfiscanf_r+0x582>
   31d8c:	462a      	mov	r2, r5
   31d8e:	e79c      	b.n	31cca <__ssvfiscanf_r+0x5ae>
   31d90:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   31d92:	1e53      	subs	r3, r2, #1
   31d94:	2b26      	cmp	r3, #38	; 0x26
   31d96:	f240 821d 	bls.w	321d4 <__ssvfiscanf_r+0xab8>
   31d9a:	f1a2 0327 	sub.w	r3, r2, #39	; 0x27
   31d9e:	461e      	mov	r6, r3
   31da0:	2327      	movs	r3, #39	; 0x27
   31da2:	637b      	str	r3, [r7, #52]	; 0x34
   31da4:	f444 6458 	orr.w	r4, r4, #3456	; 0xd80
   31da8:	f04f 0800 	mov.w	r8, #0
   31dac:	f107 0550 	add.w	r5, r7, #80	; 0x50
   31db0:	4659      	mov	r1, fp
   31db2:	46c3      	mov	fp, r8
   31db4:	46a0      	mov	r8, r4
   31db6:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   31db8:	633d      	str	r5, [r7, #48]	; 0x30
   31dba:	6808      	ldr	r0, [r1, #0]
   31dbc:	f890 c000 	ldrb.w	ip, [r0]
   31dc0:	f1ac 032b 	sub.w	r3, ip, #43	; 0x2b
   31dc4:	2b4d      	cmp	r3, #77	; 0x4d
   31dc6:	d838      	bhi.n	31e3a <__ssvfiscanf_r+0x71e>
   31dc8:	e8df f003 	tbb	[pc, r3]
   31dcc:	37713771 	.word	0x37713771
   31dd0:	5d5d7f37 	.word	0x5d5d7f37
   31dd4:	5d5d5d5d 	.word	0x5d5d5d5d
   31dd8:	3777775d 	.word	0x3777775d
   31ddc:	37373737 	.word	0x37373737
   31de0:	27273737 	.word	0x27273737
   31de4:	27272727 	.word	0x27272727
   31de8:	37373737 	.word	0x37373737
   31dec:	37373737 	.word	0x37373737
   31df0:	37373737 	.word	0x37373737
   31df4:	37373737 	.word	0x37373737
   31df8:	37376537 	.word	0x37376537
   31dfc:	37373737 	.word	0x37373737
   31e00:	27273737 	.word	0x27273737
   31e04:	27272727 	.word	0x27272727
   31e08:	37373737 	.word	0x37373737
   31e0c:	37373737 	.word	0x37373737
   31e10:	37373737 	.word	0x37373737
   31e14:	37373737 	.word	0x37373737
   31e18:	6537      	.short	0x6537
   31e1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   31e1c:	2b0a      	cmp	r3, #10
   31e1e:	dd0c      	ble.n	31e3a <__ssvfiscanf_r+0x71e>
   31e20:	f428 6838 	bic.w	r8, r8, #2944	; 0xb80
   31e24:	f805 cb01 	strb.w	ip, [r5], #1
   31e28:	684b      	ldr	r3, [r1, #4]
   31e2a:	3b01      	subs	r3, #1
   31e2c:	2b00      	cmp	r3, #0
   31e2e:	604b      	str	r3, [r1, #4]
   31e30:	dd5b      	ble.n	31eea <__ssvfiscanf_r+0x7ce>
   31e32:	3001      	adds	r0, #1
   31e34:	6008      	str	r0, [r1, #0]
   31e36:	3c01      	subs	r4, #1
   31e38:	d1bf      	bne.n	31dba <__ssvfiscanf_r+0x69e>
   31e3a:	4644      	mov	r4, r8
   31e3c:	46d8      	mov	r8, fp
   31e3e:	468b      	mov	fp, r1
   31e40:	05e1      	lsls	r1, r4, #23
   31e42:	d507      	bpl.n	31e54 <__ssvfiscanf_r+0x738>
   31e44:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   31e46:	429d      	cmp	r5, r3
   31e48:	f200 83a2 	bhi.w	32590 <__ssvfiscanf_r+0xe74>
   31e4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   31e4e:	429d      	cmp	r5, r3
   31e50:	f43f ad0b 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   31e54:	f014 0210 	ands.w	r2, r4, #16
   31e58:	f040 80ff 	bne.w	3205a <__ssvfiscanf_r+0x93e>
   31e5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   31e5e:	6b39      	ldr	r1, [r7, #48]	; 0x30
   31e60:	697e      	ldr	r6, [r7, #20]
   31e62:	702a      	strb	r2, [r5, #0]
   31e64:	4648      	mov	r0, r9
   31e66:	47b0      	blx	r6
   31e68:	06a2      	lsls	r2, r4, #26
   31e6a:	f100 80ee 	bmi.w	3204a <__ssvfiscanf_r+0x92e>
   31e6e:	0723      	lsls	r3, r4, #28
   31e70:	f100 82ac 	bmi.w	323cc <__ssvfiscanf_r+0xcb0>
   31e74:	0766      	lsls	r6, r4, #29
   31e76:	f140 84f5 	bpl.w	32864 <__ssvfiscanf_r+0x1148>
   31e7a:	6a3a      	ldr	r2, [r7, #32]
   31e7c:	f852 3b04 	ldr.w	r3, [r2], #4
   31e80:	623a      	str	r2, [r7, #32]
   31e82:	8018      	strh	r0, [r3, #0]
   31e84:	e0e6      	b.n	32054 <__ssvfiscanf_r+0x938>
   31e86:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   31e88:	4b1d      	ldr	r3, [pc, #116]	; (31f00 <__ssvfiscanf_r+0x7e4>)
   31e8a:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   31e8e:	627b      	str	r3, [r7, #36]	; 0x24
   31e90:	f428 6838 	bic.w	r8, r8, #2944	; 0xb80
   31e94:	e7c6      	b.n	31e24 <__ssvfiscanf_r+0x708>
   31e96:	f408 63c0 	and.w	r3, r8, #1536	; 0x600
   31e9a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   31e9e:	d1cc      	bne.n	31e3a <__ssvfiscanf_r+0x71e>
   31ea0:	f428 7800 	bic.w	r8, r8, #512	; 0x200
   31ea4:	2310      	movs	r3, #16
   31ea6:	f448 68a0 	orr.w	r8, r8, #1280	; 0x500
   31eaa:	627b      	str	r3, [r7, #36]	; 0x24
   31eac:	e7ba      	b.n	31e24 <__ssvfiscanf_r+0x708>
   31eae:	f018 0f80 	tst.w	r8, #128	; 0x80
   31eb2:	d0c2      	beq.n	31e3a <__ssvfiscanf_r+0x71e>
   31eb4:	f028 0880 	bic.w	r8, r8, #128	; 0x80
   31eb8:	e7b4      	b.n	31e24 <__ssvfiscanf_r+0x708>
   31eba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
   31ebc:	4b10      	ldr	r3, [pc, #64]	; (31f00 <__ssvfiscanf_r+0x7e4>)
   31ebe:	f933 3012 	ldrsh.w	r3, [r3, r2, lsl #1]
   31ec2:	627b      	str	r3, [r7, #36]	; 0x24
   31ec4:	2b08      	cmp	r3, #8
   31ec6:	dcab      	bgt.n	31e20 <__ssvfiscanf_r+0x704>
   31ec8:	e7b7      	b.n	31e3a <__ssvfiscanf_r+0x71e>
   31eca:	f418 6f00 	tst.w	r8, #2048	; 0x800
   31ece:	d0a9      	beq.n	31e24 <__ssvfiscanf_r+0x708>
   31ed0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   31ed2:	b91b      	cbnz	r3, 31edc <__ssvfiscanf_r+0x7c0>
   31ed4:	2308      	movs	r3, #8
   31ed6:	f448 7800 	orr.w	r8, r8, #512	; 0x200
   31eda:	627b      	str	r3, [r7, #36]	; 0x24
   31edc:	f418 6f80 	tst.w	r8, #1024	; 0x400
   31ee0:	f000 81ec 	beq.w	322bc <__ssvfiscanf_r+0xba0>
   31ee4:	f428 68b0 	bic.w	r8, r8, #1408	; 0x580
   31ee8:	e79c      	b.n	31e24 <__ssvfiscanf_r+0x708>
   31eea:	4648      	mov	r0, r9
   31eec:	6379      	str	r1, [r7, #52]	; 0x34
   31eee:	f7ff fbb9 	bl	31664 <__ssrefill_r>
   31ef2:	6b79      	ldr	r1, [r7, #52]	; 0x34
   31ef4:	2800      	cmp	r0, #0
   31ef6:	d09e      	beq.n	31e36 <__ssvfiscanf_r+0x71a>
   31ef8:	e79f      	b.n	31e3a <__ssvfiscanf_r+0x71e>
   31efa:	bf00      	nop
   31efc:	1000361c 	.word	0x1000361c
   31f00:	000466a4 	.word	0x000466a4
   31f04:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31f06:	2b00      	cmp	r3, #0
   31f08:	bf08      	it	eq
   31f0a:	f04f 33ff 	moveq.w	r3, #4294967295	; 0xffffffff
   31f0e:	f014 0501 	ands.w	r5, r4, #1
   31f12:	637b      	str	r3, [r7, #52]	; 0x34
   31f14:	f000 8164 	beq.w	321e0 <__ssvfiscanf_r+0xac4>
   31f18:	f014 0810 	ands.w	r8, r4, #16
   31f1c:	f040 836b 	bne.w	325f6 <__ssvfiscanf_r+0xeda>
   31f20:	0620      	lsls	r0, r4, #24
   31f22:	f140 8408 	bpl.w	32736 <__ssvfiscanf_r+0x101a>
   31f26:	6a3a      	ldr	r2, [r7, #32]
   31f28:	f852 3b04 	ldr.w	r3, [r2], #4
   31f2c:	623a      	str	r2, [r7, #32]
   31f2e:	633b      	str	r3, [r7, #48]	; 0x30
   31f30:	2b00      	cmp	r3, #0
   31f32:	f43f ac9a 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   31f36:	2080      	movs	r0, #128	; 0x80
   31f38:	f7fe fef6 	bl	30d28 <malloc>
   31f3c:	6a3a      	ldr	r2, [r7, #32]
   31f3e:	4606      	mov	r6, r0
   31f40:	2800      	cmp	r0, #0
   31f42:	f000 8250 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   31f46:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   31f48:	6b39      	ldr	r1, [r7, #48]	; 0x30
   31f4a:	88dd      	ldrh	r5, [r3, #6]
   31f4c:	889c      	ldrh	r4, [r3, #4]
   31f4e:	6008      	str	r0, [r1, #0]
   31f50:	42a5      	cmp	r5, r4
   31f52:	f080 822a 	bcs.w	323aa <__ssvfiscanf_r+0xc8e>
   31f56:	6818      	ldr	r0, [r3, #0]
   31f58:	6b39      	ldr	r1, [r7, #48]	; 0x30
   31f5a:	f840 1025 	str.w	r1, [r0, r5, lsl #2]
   31f5e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   31f60:	1c6b      	adds	r3, r5, #1
   31f62:	e9c7 6207 	strd	r6, r2, [r7, #28]
   31f66:	80cb      	strh	r3, [r1, #6]
   31f68:	2320      	movs	r3, #32
   31f6a:	60fb      	str	r3, [r7, #12]
   31f6c:	f8db 3000 	ldr.w	r3, [fp]
   31f70:	4a9a      	ldr	r2, [pc, #616]	; (321dc <__ssvfiscanf_r+0xac0>)
   31f72:	781b      	ldrb	r3, [r3, #0]
   31f74:	5cd4      	ldrb	r4, [r2, r3]
   31f76:	f014 0408 	ands.w	r4, r4, #8
   31f7a:	f040 82dc 	bne.w	32536 <__ssvfiscanf_r+0xe1a>
   31f7e:	f8c7 8008 	str.w	r8, [r7, #8]
   31f82:	f000 fea3 	bl	32ccc <__locale_mb_cur_max>
   31f86:	42a0      	cmp	r0, r4
   31f88:	46b0      	mov	r8, r6
   31f8a:	f43f ac65 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31f8e:	e9db 2300 	ldrd	r2, r3, [fp]
   31f92:	f812 1b01 	ldrb.w	r1, [r2], #1
   31f96:	3b01      	subs	r3, #1
   31f98:	e9cb 2300 	strd	r2, r3, [fp]
   31f9c:	693b      	ldr	r3, [r7, #16]
   31f9e:	f107 0050 	add.w	r0, r7, #80	; 0x50
   31fa2:	2b03      	cmp	r3, #3
   31fa4:	5501      	strb	r1, [r0, r4]
   31fa6:	f104 0601 	add.w	r6, r4, #1
   31faa:	f107 0548 	add.w	r5, r7, #72	; 0x48
   31fae:	d102      	bne.n	31fb6 <__ssvfiscanf_r+0x89a>
   31fb0:	682b      	ldr	r3, [r5, #0]
   31fb2:	2b04      	cmp	r3, #4
   31fb4:	d004      	beq.n	31fc0 <__ssvfiscanf_r+0x8a4>
   31fb6:	2208      	movs	r2, #8
   31fb8:	2100      	movs	r1, #0
   31fba:	4628      	mov	r0, r5
   31fbc:	f7fe f898 	bl	300f0 <memset>
   31fc0:	f107 0250 	add.w	r2, r7, #80	; 0x50
   31fc4:	9500      	str	r5, [sp, #0]
   31fc6:	4633      	mov	r3, r6
   31fc8:	4641      	mov	r1, r8
   31fca:	4648      	mov	r0, r9
   31fcc:	f000 fe84 	bl	32cd8 <_mbrtowc_r>
   31fd0:	4602      	mov	r2, r0
   31fd2:	3201      	adds	r2, #1
   31fd4:	6138      	str	r0, [r7, #16]
   31fd6:	f43f ac3f 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   31fda:	2800      	cmp	r0, #0
   31fdc:	f040 835b 	bne.w	32696 <__ssvfiscanf_r+0xf7a>
   31fe0:	f8c8 0000 	str.w	r0, [r8]
   31fe4:	f000 fe64 	bl	32cb0 <iswspace>
   31fe8:	2800      	cmp	r0, #0
   31fea:	f040 846f 	bne.w	328cc <__ssvfiscanf_r+0x11b0>
   31fee:	44b2      	add	sl, r6
   31ff0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   31ff2:	3b01      	subs	r3, #1
   31ff4:	637b      	str	r3, [r7, #52]	; 0x34
   31ff6:	68bb      	ldr	r3, [r7, #8]
   31ff8:	2b00      	cmp	r3, #0
   31ffa:	f040 8464 	bne.w	328c6 <__ssvfiscanf_r+0x11aa>
   31ffe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   32000:	f108 0804 	add.w	r8, r8, #4
   32004:	2b00      	cmp	r3, #0
   32006:	f000 845e 	beq.w	328c6 <__ssvfiscanf_r+0x11aa>
   3200a:	69fb      	ldr	r3, [r7, #28]
   3200c:	eba8 0403 	sub.w	r4, r8, r3
   32010:	68fb      	ldr	r3, [r7, #12]
   32012:	ebb3 0fa4 	cmp.w	r3, r4, asr #2
   32016:	f240 8493 	bls.w	32940 <__ssvfiscanf_r+0x1224>
   3201a:	68be      	ldr	r6, [r7, #8]
   3201c:	f8db 3004 	ldr.w	r3, [fp, #4]
   32020:	2b00      	cmp	r3, #0
   32022:	f77f ac0b 	ble.w	3183c <__ssvfiscanf_r+0x120>
   32026:	f8db 3000 	ldr.w	r3, [fp]
   3202a:	4a6c      	ldr	r2, [pc, #432]	; (321dc <__ssvfiscanf_r+0xac0>)
   3202c:	781b      	ldrb	r3, [r3, #0]
   3202e:	5cd3      	ldrb	r3, [r2, r3]
   32030:	0719      	lsls	r1, r3, #28
   32032:	f100 827d 	bmi.w	32530 <__ssvfiscanf_r+0xe14>
   32036:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   32038:	2b00      	cmp	r3, #0
   3203a:	f000 8279 	beq.w	32530 <__ssvfiscanf_r+0xe14>
   3203e:	f000 fe45 	bl	32ccc <__locale_mb_cur_max>
   32042:	4634      	mov	r4, r6
   32044:	42a0      	cmp	r0, r4
   32046:	d1a2      	bne.n	31f8e <__ssvfiscanf_r+0x872>
   32048:	e406      	b.n	31858 <__ssvfiscanf_r+0x13c>
   3204a:	6a3a      	ldr	r2, [r7, #32]
   3204c:	f852 3b04 	ldr.w	r3, [r2], #4
   32050:	6018      	str	r0, [r3, #0]
   32052:	623a      	str	r2, [r7, #32]
   32054:	6abb      	ldr	r3, [r7, #40]	; 0x28
   32056:	3301      	adds	r3, #1
   32058:	62bb      	str	r3, [r7, #40]	; 0x28
   3205a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   3205c:	1aed      	subs	r5, r5, r3
   3205e:	eb05 0308 	add.w	r3, r5, r8
   32062:	f8d7 8018 	ldr.w	r8, [r7, #24]
   32066:	449a      	add	sl, r3
   32068:	f818 3b01 	ldrb.w	r3, [r8], #1
   3206c:	63fb      	str	r3, [r7, #60]	; 0x3c
   3206e:	2b00      	cmp	r3, #0
   32070:	f47f ac26 	bne.w	318c0 <__ssvfiscanf_r+0x1a4>
   32074:	f7ff bbf9 	b.w	3186a <__ssvfiscanf_r+0x14e>
   32078:	06e6      	lsls	r6, r4, #27
   3207a:	f100 82c5 	bmi.w	32608 <__ssvfiscanf_r+0xeec>
   3207e:	f014 0480 	ands.w	r4, r4, #128	; 0x80
   32082:	f000 8348 	beq.w	32716 <__ssvfiscanf_r+0xffa>
   32086:	f8d7 8020 	ldr.w	r8, [r7, #32]
   3208a:	f858 3b04 	ldr.w	r3, [r8], #4
   3208e:	633b      	str	r3, [r7, #48]	; 0x30
   32090:	2b00      	cmp	r3, #0
   32092:	f43f abea 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   32096:	2020      	movs	r0, #32
   32098:	f7fe fe46 	bl	30d28 <malloc>
   3209c:	4605      	mov	r5, r0
   3209e:	2800      	cmp	r0, #0
   320a0:	f000 81a1 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   320a4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   320a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   320a8:	88d6      	ldrh	r6, [r2, #6]
   320aa:	8894      	ldrh	r4, [r2, #4]
   320ac:	6018      	str	r0, [r3, #0]
   320ae:	42a6      	cmp	r6, r4
   320b0:	f080 814b 	bcs.w	3234a <__ssvfiscanf_r+0xc2e>
   320b4:	6810      	ldr	r0, [r2, #0]
   320b6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   320b8:	f840 2026 	str.w	r2, [r0, r6, lsl #2]
   320bc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   320be:	f8c7 8020 	str.w	r8, [r7, #32]
   320c2:	1c73      	adds	r3, r6, #1
   320c4:	80d3      	strh	r3, [r2, #6]
   320c6:	2420      	movs	r4, #32
   320c8:	f8db 3000 	ldr.w	r3, [fp]
   320cc:	f107 0878 	add.w	r8, r7, #120	; 0x78
   320d0:	781a      	ldrb	r2, [r3, #0]
   320d2:	f818 2002 	ldrb.w	r2, [r8, r2]
   320d6:	2a00      	cmp	r2, #0
   320d8:	f43f abc7 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   320dc:	ee08 9a10 	vmov	s16, r9
   320e0:	f8c7 a01c 	str.w	sl, [r7, #28]
   320e4:	46c1      	mov	r9, r8
   320e6:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
   320ea:	f8d7 8034 	ldr.w	r8, [r7, #52]	; 0x34
   320ee:	462e      	mov	r6, r5
   320f0:	f8db 1004 	ldr.w	r1, [fp, #4]
   320f4:	1c5a      	adds	r2, r3, #1
   320f6:	1e48      	subs	r0, r1, #1
   320f8:	e9cb 2000 	strd	r2, r0, [fp]
   320fc:	4629      	mov	r1, r5
   320fe:	7818      	ldrb	r0, [r3, #0]
   32100:	f801 0b01 	strb.w	r0, [r1], #1
   32104:	1b8d      	subs	r5, r1, r6
   32106:	f1ba 0f00 	cmp.w	sl, #0
   3210a:	d002      	beq.n	32112 <__ssvfiscanf_r+0x9f6>
   3210c:	42a5      	cmp	r5, r4
   3210e:	f080 8110 	bcs.w	32332 <__ssvfiscanf_r+0xc16>
   32112:	460d      	mov	r5, r1
   32114:	f1b8 0801 	subs.w	r8, r8, #1
   32118:	d00b      	beq.n	32132 <__ssvfiscanf_r+0xa16>
   3211a:	f8db 1004 	ldr.w	r1, [fp, #4]
   3211e:	2900      	cmp	r1, #0
   32120:	f340 81d8 	ble.w	324d4 <__ssvfiscanf_r+0xdb8>
   32124:	f8db 3000 	ldr.w	r3, [fp]
   32128:	7819      	ldrb	r1, [r3, #0]
   3212a:	f819 1001 	ldrb.w	r1, [r9, r1]
   3212e:	2900      	cmp	r1, #0
   32130:	d1de      	bne.n	320f0 <__ssvfiscanf_r+0x9d4>
   32132:	f8d7 a01c 	ldr.w	sl, [r7, #28]
   32136:	ee18 9a10 	vmov	r9, s16
   3213a:	1bae      	subs	r6, r5, r6
   3213c:	f43f ab95 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   32140:	2300      	movs	r3, #0
   32142:	702b      	strb	r3, [r5, #0]
   32144:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   32146:	b11b      	cbz	r3, 32150 <__ssvfiscanf_r+0xa34>
   32148:	1c71      	adds	r1, r6, #1
   3214a:	428c      	cmp	r4, r1
   3214c:	f200 837c 	bhi.w	32848 <__ssvfiscanf_r+0x112c>
   32150:	6abb      	ldr	r3, [r7, #40]	; 0x28
   32152:	f8d7 8018 	ldr.w	r8, [r7, #24]
   32156:	3301      	adds	r3, #1
   32158:	62bb      	str	r3, [r7, #40]	; 0x28
   3215a:	44b2      	add	sl, r6
   3215c:	f7ff bbab 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   32160:	06e5      	lsls	r5, r4, #27
   32162:	f100 821d 	bmi.w	325a0 <__ssvfiscanf_r+0xe84>
   32166:	0624      	lsls	r4, r4, #24
   32168:	f140 80b1 	bpl.w	322ce <__ssvfiscanf_r+0xbb2>
   3216c:	f8d7 8020 	ldr.w	r8, [r7, #32]
   32170:	f858 6b04 	ldr.w	r6, [r8], #4
   32174:	2e00      	cmp	r6, #0
   32176:	f43f ab78 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   3217a:	6b78      	ldr	r0, [r7, #52]	; 0x34
   3217c:	f7fe fdd4 	bl	30d28 <malloc>
   32180:	4604      	mov	r4, r0
   32182:	2800      	cmp	r0, #0
   32184:	f000 812f 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   32188:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3218a:	6030      	str	r0, [r6, #0]
   3218c:	88da      	ldrh	r2, [r3, #6]
   3218e:	8899      	ldrh	r1, [r3, #4]
   32190:	428a      	cmp	r2, r1
   32192:	f080 82f5 	bcs.w	32780 <__ssvfiscanf_r+0x1064>
   32196:	6818      	ldr	r0, [r3, #0]
   32198:	f840 6022 	str.w	r6, [r0, r2, lsl #2]
   3219c:	1c53      	adds	r3, r2, #1
   3219e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   321a0:	4621      	mov	r1, r4
   321a2:	80d3      	strh	r3, [r2, #6]
   321a4:	4648      	mov	r0, r9
   321a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   321a8:	f8cd b000 	str.w	fp, [sp]
   321ac:	2201      	movs	r2, #1
   321ae:	f7ff fa77 	bl	316a0 <_sfread_r>
   321b2:	4604      	mov	r4, r0
   321b4:	2800      	cmp	r0, #0
   321b6:	f000 810f 	beq.w	323d8 <__ssvfiscanf_r+0xcbc>
   321ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   321bc:	4283      	cmp	r3, r0
   321be:	f240 8095 	bls.w	322ec <__ssvfiscanf_r+0xbd0>
   321c2:	4601      	mov	r1, r0
   321c4:	6830      	ldr	r0, [r6, #0]
   321c6:	f000 fdbf 	bl	32d48 <realloc>
   321ca:	2800      	cmp	r0, #0
   321cc:	f000 808e 	beq.w	322ec <__ssvfiscanf_r+0xbd0>
   321d0:	6030      	str	r0, [r6, #0]
   321d2:	e08b      	b.n	322ec <__ssvfiscanf_r+0xbd0>
   321d4:	2300      	movs	r3, #0
   321d6:	461e      	mov	r6, r3
   321d8:	e5e4      	b.n	31da4 <__ssvfiscanf_r+0x688>
   321da:	bf00      	nop
   321dc:	000466c9 	.word	0x000466c9
   321e0:	06e2      	lsls	r2, r4, #27
   321e2:	f100 82fe 	bmi.w	327e2 <__ssvfiscanf_r+0x10c6>
   321e6:	f014 0280 	ands.w	r2, r4, #128	; 0x80
   321ea:	f000 824d 	beq.w	32688 <__ssvfiscanf_r+0xf6c>
   321ee:	6a3a      	ldr	r2, [r7, #32]
   321f0:	f852 8b04 	ldr.w	r8, [r2], #4
   321f4:	633a      	str	r2, [r7, #48]	; 0x30
   321f6:	f1b8 0f00 	cmp.w	r8, #0
   321fa:	f43f ab36 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   321fe:	2020      	movs	r0, #32
   32200:	f7fe fd92 	bl	30d28 <malloc>
   32204:	4604      	mov	r4, r0
   32206:	2800      	cmp	r0, #0
   32208:	f000 80ed 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   3220c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3220e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   32210:	88de      	ldrh	r6, [r3, #6]
   32212:	889d      	ldrh	r5, [r3, #4]
   32214:	f8c8 0000 	str.w	r0, [r8]
   32218:	42ae      	cmp	r6, r5
   3221a:	d271      	bcs.n	32300 <__ssvfiscanf_r+0xbe4>
   3221c:	6818      	ldr	r0, [r3, #0]
   3221e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
   32220:	f840 8026 	str.w	r8, [r0, r6, lsl #2]
   32224:	1c73      	adds	r3, r6, #1
   32226:	80cb      	strh	r3, [r1, #6]
   32228:	623a      	str	r2, [r7, #32]
   3222a:	2620      	movs	r6, #32
   3222c:	f8db 3000 	ldr.w	r3, [fp]
   32230:	49b6      	ldr	r1, [pc, #728]	; (3250c <__ssvfiscanf_r+0xdf0>)
   32232:	781a      	ldrb	r2, [r3, #0]
   32234:	5c8a      	ldrb	r2, [r1, r2]
   32236:	0715      	lsls	r5, r2, #28
   32238:	f100 81e4 	bmi.w	32604 <__ssvfiscanf_r+0xee8>
   3223c:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   3223e:	4619      	mov	r1, r3
   32240:	4653      	mov	r3, sl
   32242:	46c2      	mov	sl, r8
   32244:	46b0      	mov	r8, r6
   32246:	4626      	mov	r6, r4
   32248:	f8db 2004 	ldr.w	r2, [fp, #4]
   3224c:	1c48      	adds	r0, r1, #1
   3224e:	3a01      	subs	r2, #1
   32250:	e9cb 0200 	strd	r0, r2, [fp]
   32254:	780a      	ldrb	r2, [r1, #0]
   32256:	f804 2b01 	strb.w	r2, [r4], #1
   3225a:	1ba2      	subs	r2, r4, r6
   3225c:	f1ba 0f00 	cmp.w	sl, #0
   32260:	d002      	beq.n	32268 <__ssvfiscanf_r+0xb4c>
   32262:	4542      	cmp	r2, r8
   32264:	f080 823c 	bcs.w	326e0 <__ssvfiscanf_r+0xfc4>
   32268:	3d01      	subs	r5, #1
   3226a:	d00b      	beq.n	32284 <__ssvfiscanf_r+0xb68>
   3226c:	f8db 2004 	ldr.w	r2, [fp, #4]
   32270:	2a00      	cmp	r2, #0
   32272:	f340 82ac 	ble.w	327ce <__ssvfiscanf_r+0x10b2>
   32276:	f8db 1000 	ldr.w	r1, [fp]
   3227a:	48a4      	ldr	r0, [pc, #656]	; (3250c <__ssvfiscanf_r+0xdf0>)
   3227c:	780a      	ldrb	r2, [r1, #0]
   3227e:	5c82      	ldrb	r2, [r0, r2]
   32280:	0710      	lsls	r0, r2, #28
   32282:	d5e1      	bpl.n	32248 <__ssvfiscanf_r+0xb2c>
   32284:	4635      	mov	r5, r6
   32286:	1b61      	subs	r1, r4, r5
   32288:	4646      	mov	r6, r8
   3228a:	46d0      	mov	r8, sl
   3228c:	469a      	mov	sl, r3
   3228e:	448a      	add	sl, r1
   32290:	3101      	adds	r1, #1
   32292:	2300      	movs	r3, #0
   32294:	7023      	strb	r3, [r4, #0]
   32296:	f1b8 0f00 	cmp.w	r8, #0
   3229a:	d002      	beq.n	322a2 <__ssvfiscanf_r+0xb86>
   3229c:	428e      	cmp	r6, r1
   3229e:	f200 8265 	bhi.w	3276c <__ssvfiscanf_r+0x1050>
   322a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
   322a4:	f8d7 8018 	ldr.w	r8, [r7, #24]
   322a8:	3301      	adds	r3, #1
   322aa:	62bb      	str	r3, [r7, #40]	; 0x28
   322ac:	f818 3b01 	ldrb.w	r3, [r8], #1
   322b0:	63fb      	str	r3, [r7, #60]	; 0x3c
   322b2:	2b00      	cmp	r3, #0
   322b4:	f47f ab04 	bne.w	318c0 <__ssvfiscanf_r+0x1a4>
   322b8:	f7ff bad7 	b.w	3186a <__ssvfiscanf_r+0x14e>
   322bc:	f428 7860 	bic.w	r8, r8, #896	; 0x380
   322c0:	b116      	cbz	r6, 322c8 <__ssvfiscanf_r+0xbac>
   322c2:	1e73      	subs	r3, r6, #1
   322c4:	461e      	mov	r6, r3
   322c6:	3401      	adds	r4, #1
   322c8:	f10b 0b01 	add.w	fp, fp, #1
   322cc:	e5ac      	b.n	31e28 <__ssvfiscanf_r+0x70c>
   322ce:	6a3d      	ldr	r5, [r7, #32]
   322d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   322d2:	6829      	ldr	r1, [r5, #0]
   322d4:	f8cd b000 	str.w	fp, [sp]
   322d8:	2201      	movs	r2, #1
   322da:	4648      	mov	r0, r9
   322dc:	f7ff f9e0 	bl	316a0 <_sfread_r>
   322e0:	4604      	mov	r4, r0
   322e2:	2800      	cmp	r0, #0
   322e4:	f43f aab8 	beq.w	31858 <__ssvfiscanf_r+0x13c>
   322e8:	f105 0804 	add.w	r8, r5, #4
   322ec:	6abb      	ldr	r3, [r7, #40]	; 0x28
   322ee:	f8c7 8020 	str.w	r8, [r7, #32]
   322f2:	3301      	adds	r3, #1
   322f4:	f8d7 8018 	ldr.w	r8, [r7, #24]
   322f8:	62bb      	str	r3, [r7, #40]	; 0x28
   322fa:	44a2      	add	sl, r4
   322fc:	f7ff badb 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   32300:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   32304:	429d      	cmp	r5, r3
   32306:	633a      	str	r2, [r7, #48]	; 0x30
   32308:	d871      	bhi.n	323ee <__ssvfiscanf_r+0xcd2>
   3230a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   3230c:	3508      	adds	r5, #8
   3230e:	6810      	ldr	r0, [r2, #0]
   32310:	00a9      	lsls	r1, r5, #2
   32312:	f000 fd19 	bl	32d48 <realloc>
   32316:	2800      	cmp	r0, #0
   32318:	d069      	beq.n	323ee <__ssvfiscanf_r+0xcd2>
   3231a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   3231c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   3231e:	6018      	str	r0, [r3, #0]
   32320:	809d      	strh	r5, [r3, #4]
   32322:	e77c      	b.n	3221e <__ssvfiscanf_r+0xb02>
   32324:	61b9      	str	r1, [r7, #24]
   32326:	e460      	b.n	31bea <__ssvfiscanf_r+0x4ce>
   32328:	61b9      	str	r1, [r7, #24]
   3232a:	f7ff bbf1 	b.w	31b10 <__ssvfiscanf_r+0x3f4>
   3232e:	61b9      	str	r1, [r7, #24]
   32330:	e462      	b.n	31bf8 <__ssvfiscanf_r+0x4dc>
   32332:	0064      	lsls	r4, r4, #1
   32334:	4630      	mov	r0, r6
   32336:	4621      	mov	r1, r4
   32338:	f000 fd06 	bl	32d48 <realloc>
   3233c:	4606      	mov	r6, r0
   3233e:	2800      	cmp	r0, #0
   32340:	d051      	beq.n	323e6 <__ssvfiscanf_r+0xcca>
   32342:	4405      	add	r5, r0
   32344:	f8ca 0000 	str.w	r0, [sl]
   32348:	e6e4      	b.n	32114 <__ssvfiscanf_r+0x9f8>
   3234a:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   3234e:	429c      	cmp	r4, r3
   32350:	d84d      	bhi.n	323ee <__ssvfiscanf_r+0xcd2>
   32352:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   32354:	3408      	adds	r4, #8
   32356:	6810      	ldr	r0, [r2, #0]
   32358:	00a1      	lsls	r1, r4, #2
   3235a:	f000 fcf5 	bl	32d48 <realloc>
   3235e:	2800      	cmp	r0, #0
   32360:	d045      	beq.n	323ee <__ssvfiscanf_r+0xcd2>
   32362:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   32364:	6018      	str	r0, [r3, #0]
   32366:	809c      	strh	r4, [r3, #4]
   32368:	e6a5      	b.n	320b6 <__ssvfiscanf_r+0x99a>
   3236a:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   3236e:	429c      	cmp	r4, r3
   32370:	d83d      	bhi.n	323ee <__ssvfiscanf_r+0xcd2>
   32372:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   32374:	3408      	adds	r4, #8
   32376:	6810      	ldr	r0, [r2, #0]
   32378:	00a1      	lsls	r1, r4, #2
   3237a:	f000 fce5 	bl	32d48 <realloc>
   3237e:	2800      	cmp	r0, #0
   32380:	d035      	beq.n	323ee <__ssvfiscanf_r+0xcd2>
   32382:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   32384:	6018      	str	r0, [r3, #0]
   32386:	809c      	strh	r4, [r3, #4]
   32388:	f7ff bb2a 	b.w	319e0 <__ssvfiscanf_r+0x2c4>
   3238c:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   32390:	429c      	cmp	r4, r3
   32392:	d82c      	bhi.n	323ee <__ssvfiscanf_r+0xcd2>
   32394:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   32396:	3408      	adds	r4, #8
   32398:	6810      	ldr	r0, [r2, #0]
   3239a:	00a1      	lsls	r1, r4, #2
   3239c:	f000 fcd4 	bl	32d48 <realloc>
   323a0:	b328      	cbz	r0, 323ee <__ssvfiscanf_r+0xcd2>
   323a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   323a4:	6018      	str	r0, [r3, #0]
   323a6:	809c      	strh	r4, [r3, #4]
   323a8:	e464      	b.n	31c74 <__ssvfiscanf_r+0x558>
   323aa:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   323ae:	429c      	cmp	r4, r3
   323b0:	623a      	str	r2, [r7, #32]
   323b2:	d81c      	bhi.n	323ee <__ssvfiscanf_r+0xcd2>
   323b4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   323b6:	3408      	adds	r4, #8
   323b8:	6810      	ldr	r0, [r2, #0]
   323ba:	00a1      	lsls	r1, r4, #2
   323bc:	f000 fcc4 	bl	32d48 <realloc>
   323c0:	b1a8      	cbz	r0, 323ee <__ssvfiscanf_r+0xcd2>
   323c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   323c4:	6a3a      	ldr	r2, [r7, #32]
   323c6:	6018      	str	r0, [r3, #0]
   323c8:	809c      	strh	r4, [r3, #4]
   323ca:	e5c5      	b.n	31f58 <__ssvfiscanf_r+0x83c>
   323cc:	6a3a      	ldr	r2, [r7, #32]
   323ce:	f852 3b04 	ldr.w	r3, [r2], #4
   323d2:	623a      	str	r2, [r7, #32]
   323d4:	7018      	strb	r0, [r3, #0]
   323d6:	e63d      	b.n	32054 <__ssvfiscanf_r+0x938>
   323d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
   323da:	b143      	cbz	r3, 323ee <__ssvfiscanf_r+0xcd2>
   323dc:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   323e0:	065b      	lsls	r3, r3, #25
   323e2:	f57f aa44 	bpl.w	3186e <__ssvfiscanf_r+0x152>
   323e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   323e8:	2b00      	cmp	r3, #0
   323ea:	f000 81de 	beq.w	327aa <__ssvfiscanf_r+0x108e>
   323ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   323f0:	88dd      	ldrh	r5, [r3, #6]
   323f2:	2d00      	cmp	r5, #0
   323f4:	f000 8186 	beq.w	32704 <__ssvfiscanf_r+0xfe8>
   323f8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   323fa:	681e      	ldr	r6, [r3, #0]
   323fc:	f04f 0800 	mov.w	r8, #0
   32400:	eb06 0585 	add.w	r5, r6, r5, lsl #2
   32404:	4634      	mov	r4, r6
   32406:	6823      	ldr	r3, [r4, #0]
   32408:	6818      	ldr	r0, [r3, #0]
   3240a:	f7fe fc95 	bl	30d38 <free>
   3240e:	f854 3b04 	ldr.w	r3, [r4], #4
   32412:	42ac      	cmp	r4, r5
   32414:	f8c3 8000 	str.w	r8, [r3]
   32418:	d1f5      	bne.n	32406 <__ssvfiscanf_r+0xcea>
   3241a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3241e:	62bb      	str	r3, [r7, #40]	; 0x28
   32420:	2e00      	cmp	r6, #0
   32422:	f47f aa27 	bne.w	31874 <__ssvfiscanf_r+0x158>
   32426:	f7ff ba28 	b.w	3187a <__ssvfiscanf_r+0x15e>
   3242a:	1c83      	adds	r3, r0, #2
   3242c:	d146      	bne.n	324bc <__ssvfiscanf_r+0xda0>
   3242e:	f8db 1004 	ldr.w	r1, [fp, #4]
   32432:	2900      	cmp	r1, #0
   32434:	4655      	mov	r5, sl
   32436:	f73f aae5 	bgt.w	31a04 <__ssvfiscanf_r+0x2e8>
   3243a:	4659      	mov	r1, fp
   3243c:	4648      	mov	r0, r9
   3243e:	f7ff f911 	bl	31664 <__ssrefill_r>
   32442:	2800      	cmp	r0, #0
   32444:	f43f ab27 	beq.w	31a96 <__ssvfiscanf_r+0x37a>
   32448:	f8d7 a030 	ldr.w	sl, [r7, #48]	; 0x30
   3244c:	613c      	str	r4, [r7, #16]
   3244e:	2d00      	cmp	r5, #0
   32450:	f43f ab27 	beq.w	31aa2 <__ssvfiscanf_r+0x386>
   32454:	f7ff ba00 	b.w	31858 <__ssvfiscanf_r+0x13c>
   32458:	f8db 3004 	ldr.w	r3, [fp, #4]
   3245c:	2b00      	cmp	r3, #0
   3245e:	f04f 0400 	mov.w	r4, #0
   32462:	f73f ac59 	bgt.w	31d18 <__ssvfiscanf_r+0x5fc>
   32466:	4659      	mov	r1, fp
   32468:	4650      	mov	r0, sl
   3246a:	f7ff f8fb 	bl	31664 <__ssrefill_r>
   3246e:	2800      	cmp	r0, #0
   32470:	f43f ac52 	beq.w	31d18 <__ssvfiscanf_r+0x5fc>
   32474:	464d      	mov	r5, r9
   32476:	613e      	str	r6, [r7, #16]
   32478:	46d1      	mov	r9, sl
   3247a:	f8d7 a01c 	ldr.w	sl, [r7, #28]
   3247e:	2c00      	cmp	r4, #0
   32480:	f47f a9ea 	bne.w	31858 <__ssvfiscanf_r+0x13c>
   32484:	68fb      	ldr	r3, [r7, #12]
   32486:	2b00      	cmp	r3, #0
   32488:	f47f ab19 	bne.w	31abe <__ssvfiscanf_r+0x3a2>
   3248c:	602b      	str	r3, [r5, #0]
   3248e:	68bb      	ldr	r3, [r7, #8]
   32490:	2b00      	cmp	r3, #0
   32492:	f43f ab11 	beq.w	31ab8 <__ssvfiscanf_r+0x39c>
   32496:	687b      	ldr	r3, [r7, #4]
   32498:	683a      	ldr	r2, [r7, #0]
   3249a:	1ae9      	subs	r1, r5, r3
   3249c:	108b      	asrs	r3, r1, #2
   3249e:	3301      	adds	r3, #1
   324a0:	429a      	cmp	r2, r3
   324a2:	f67f ab09 	bls.w	31ab8 <__ssvfiscanf_r+0x39c>
   324a6:	68bc      	ldr	r4, [r7, #8]
   324a8:	3104      	adds	r1, #4
   324aa:	6820      	ldr	r0, [r4, #0]
   324ac:	f000 fc4c 	bl	32d48 <realloc>
   324b0:	2800      	cmp	r0, #0
   324b2:	f43f ab01 	beq.w	31ab8 <__ssvfiscanf_r+0x39c>
   324b6:	6020      	str	r0, [r4, #0]
   324b8:	f7ff bafe 	b.w	31ab8 <__ssvfiscanf_r+0x39c>
   324bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   324be:	2803      	cmp	r0, #3
   324c0:	4453      	add	r3, sl
   324c2:	633b      	str	r3, [r7, #48]	; 0x30
   324c4:	f47f aad1 	bne.w	31a6a <__ssvfiscanf_r+0x34e>
   324c8:	682b      	ldr	r3, [r5, #0]
   324ca:	2b04      	cmp	r3, #4
   324cc:	f47f aacd 	bne.w	31a6a <__ssvfiscanf_r+0x34e>
   324d0:	f7ff bace 	b.w	31a70 <__ssvfiscanf_r+0x354>
   324d4:	ee18 0a10 	vmov	r0, s16
   324d8:	4659      	mov	r1, fp
   324da:	f7ff f8c3 	bl	31664 <__ssrefill_r>
   324de:	2800      	cmp	r0, #0
   324e0:	f43f ae20 	beq.w	32124 <__ssvfiscanf_r+0xa08>
   324e4:	42b5      	cmp	r5, r6
   324e6:	f8d7 a01c 	ldr.w	sl, [r7, #28]
   324ea:	ee18 9a10 	vmov	r9, s16
   324ee:	f47f ae24 	bne.w	3213a <__ssvfiscanf_r+0xa1e>
   324f2:	f7ff b9b1 	b.w	31858 <__ssvfiscanf_r+0x13c>
   324f6:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
   324fa:	f7ff bbe6 	b.w	31cca <__ssvfiscanf_r+0x5ae>
   324fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   32500:	681b      	ldr	r3, [r3, #0]
   32502:	2b04      	cmp	r3, #4
   32504:	f47f abed 	bne.w	31ce2 <__ssvfiscanf_r+0x5c6>
   32508:	f7ff bbee 	b.w	31ce8 <__ssvfiscanf_r+0x5cc>
   3250c:	000466c9 	.word	0x000466c9
   32510:	6878      	ldr	r0, [r7, #4]
   32512:	00d9      	lsls	r1, r3, #3
   32514:	f000 fc18 	bl	32d48 <realloc>
   32518:	6078      	str	r0, [r7, #4]
   3251a:	2800      	cmp	r0, #0
   3251c:	f43f af63 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   32520:	68bb      	ldr	r3, [r7, #8]
   32522:	68fa      	ldr	r2, [r7, #12]
   32524:	005b      	lsls	r3, r3, #1
   32526:	1946      	adds	r6, r0, r5
   32528:	6010      	str	r0, [r2, #0]
   3252a:	60bb      	str	r3, [r7, #8]
   3252c:	f7ff baab 	b.w	31a86 <__ssvfiscanf_r+0x36a>
   32530:	4646      	mov	r6, r8
   32532:	f8d7 8008 	ldr.w	r8, [r7, #8]
   32536:	f1b8 0f00 	cmp.w	r8, #0
   3253a:	f47f aac0 	bne.w	31abe <__ssvfiscanf_r+0x3a2>
   3253e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   32540:	f8c6 8000 	str.w	r8, [r6]
   32544:	2b00      	cmp	r3, #0
   32546:	f43f aab7 	beq.w	31ab8 <__ssvfiscanf_r+0x39c>
   3254a:	69fb      	ldr	r3, [r7, #28]
   3254c:	68fa      	ldr	r2, [r7, #12]
   3254e:	1af1      	subs	r1, r6, r3
   32550:	108b      	asrs	r3, r1, #2
   32552:	3301      	adds	r3, #1
   32554:	429a      	cmp	r2, r3
   32556:	f67f aaaf 	bls.w	31ab8 <__ssvfiscanf_r+0x39c>
   3255a:	6b3c      	ldr	r4, [r7, #48]	; 0x30
   3255c:	3104      	adds	r1, #4
   3255e:	6820      	ldr	r0, [r4, #0]
   32560:	f000 fbf2 	bl	32d48 <realloc>
   32564:	2800      	cmp	r0, #0
   32566:	d1a6      	bne.n	324b6 <__ssvfiscanf_r+0xd9a>
   32568:	f7ff baa6 	b.w	31ab8 <__ssvfiscanf_r+0x39c>
   3256c:	6878      	ldr	r0, [r7, #4]
   3256e:	00d9      	lsls	r1, r3, #3
   32570:	461d      	mov	r5, r3
   32572:	f000 fbe9 	bl	32d48 <realloc>
   32576:	6078      	str	r0, [r7, #4]
   32578:	2800      	cmp	r0, #0
   3257a:	f43f af34 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   3257e:	68ba      	ldr	r2, [r7, #8]
   32580:	006b      	lsls	r3, r5, #1
   32582:	eb00 0904 	add.w	r9, r0, r4
   32586:	6010      	str	r0, [r2, #0]
   32588:	68fc      	ldr	r4, [r7, #12]
   3258a:	603b      	str	r3, [r7, #0]
   3258c:	f7ff bbbf 	b.w	31d0e <__ssvfiscanf_r+0x5f2>
   32590:	f815 1c01 	ldrb.w	r1, [r5, #-1]
   32594:	465a      	mov	r2, fp
   32596:	4648      	mov	r0, r9
   32598:	f7ff f824 	bl	315e4 <_sungetc_r>
   3259c:	3d01      	subs	r5, #1
   3259e:	e455      	b.n	31e4c <__ssvfiscanf_r+0x730>
   325a0:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   325a2:	461c      	mov	r4, r3
   325a4:	e00b      	b.n	325be <__ssvfiscanf_r+0xea2>
   325a6:	f8db 3000 	ldr.w	r3, [fp]
   325aa:	4413      	add	r3, r2
   325ac:	f8cb 3000 	str.w	r3, [fp]
   325b0:	4414      	add	r4, r2
   325b2:	1aad      	subs	r5, r5, r2
   325b4:	f7ff f856 	bl	31664 <__ssrefill_r>
   325b8:	2800      	cmp	r0, #0
   325ba:	f040 814e 	bne.w	3285a <__ssvfiscanf_r+0x113e>
   325be:	f8db 2004 	ldr.w	r2, [fp, #4]
   325c2:	4295      	cmp	r5, r2
   325c4:	4659      	mov	r1, fp
   325c6:	4648      	mov	r0, r9
   325c8:	dced      	bgt.n	325a6 <__ssvfiscanf_r+0xe8a>
   325ca:	f8db 3000 	ldr.w	r3, [fp]
   325ce:	1b52      	subs	r2, r2, r5
   325d0:	442b      	add	r3, r5
   325d2:	f8cb 2004 	str.w	r2, [fp, #4]
   325d6:	442c      	add	r4, r5
   325d8:	f8cb 3000 	str.w	r3, [fp]
   325dc:	f8d7 8018 	ldr.w	r8, [r7, #24]
   325e0:	44a2      	add	sl, r4
   325e2:	f7ff b968 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   325e6:	2300      	movs	r3, #0
   325e8:	e9c7 3300 	strd	r3, r3, [r7]
   325ec:	60bb      	str	r3, [r7, #8]
   325ee:	f107 053c 	add.w	r5, r7, #60	; 0x3c
   325f2:	f7ff bb4a 	b.w	31c8a <__ssvfiscanf_r+0x56e>
   325f6:	2300      	movs	r3, #0
   325f8:	60fb      	str	r3, [r7, #12]
   325fa:	61fb      	str	r3, [r7, #28]
   325fc:	633b      	str	r3, [r7, #48]	; 0x30
   325fe:	f107 063c 	add.w	r6, r7, #60	; 0x3c
   32602:	e4b3      	b.n	31f6c <__ssvfiscanf_r+0x850>
   32604:	2101      	movs	r1, #1
   32606:	e644      	b.n	32292 <__ssvfiscanf_r+0xb76>
   32608:	f8db 2000 	ldr.w	r2, [fp]
   3260c:	f107 0878 	add.w	r8, r7, #120	; 0x78
   32610:	7813      	ldrb	r3, [r2, #0]
   32612:	f818 3003 	ldrb.w	r3, [r8, r3]
   32616:	2b00      	cmp	r3, #0
   32618:	f43f a927 	beq.w	3186a <__ssvfiscanf_r+0x14e>
   3261c:	f8db 3004 	ldr.w	r3, [fp, #4]
   32620:	3201      	adds	r2, #1
   32622:	3b01      	subs	r3, #1
   32624:	e9cb 2300 	strd	r2, r3, [fp]
   32628:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   3262a:	2a01      	cmp	r2, #1
   3262c:	d01b      	beq.n	32666 <__ssvfiscanf_r+0xf4a>
   3262e:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   32630:	461a      	mov	r2, r3
   32632:	e010      	b.n	32656 <__ssvfiscanf_r+0xf3a>
   32634:	f8db 3000 	ldr.w	r3, [fp]
   32638:	781a      	ldrb	r2, [r3, #0]
   3263a:	f818 2002 	ldrb.w	r2, [r8, r2]
   3263e:	3301      	adds	r3, #1
   32640:	b18a      	cbz	r2, 32666 <__ssvfiscanf_r+0xf4a>
   32642:	f8db 2004 	ldr.w	r2, [fp, #4]
   32646:	f8cb 3000 	str.w	r3, [fp]
   3264a:	3501      	adds	r5, #1
   3264c:	3a01      	subs	r2, #1
   3264e:	42ac      	cmp	r4, r5
   32650:	f8cb 2004 	str.w	r2, [fp, #4]
   32654:	d007      	beq.n	32666 <__ssvfiscanf_r+0xf4a>
   32656:	2a00      	cmp	r2, #0
   32658:	dcec      	bgt.n	32634 <__ssvfiscanf_r+0xf18>
   3265a:	4659      	mov	r1, fp
   3265c:	4648      	mov	r0, r9
   3265e:	f7ff f801 	bl	31664 <__ssrefill_r>
   32662:	2800      	cmp	r0, #0
   32664:	d0e6      	beq.n	32634 <__ssvfiscanf_r+0xf18>
   32666:	f8d7 8018 	ldr.w	r8, [r7, #24]
   3266a:	44aa      	add	sl, r5
   3266c:	f7ff b923 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   32670:	2600      	movs	r6, #0
   32672:	e9c7 6601 	strd	r6, r6, [r7, #4]
   32676:	60fe      	str	r6, [r7, #12]
   32678:	f7ff b9bd 	b.w	319f6 <__ssvfiscanf_r+0x2da>
   3267c:	464d      	mov	r5, r9
   3267e:	613e      	str	r6, [r7, #16]
   32680:	46d1      	mov	r9, sl
   32682:	f8d7 a01c 	ldr.w	sl, [r7, #28]
   32686:	e6fd      	b.n	32484 <__ssvfiscanf_r+0xd68>
   32688:	6a3b      	ldr	r3, [r7, #32]
   3268a:	f853 4b04 	ldr.w	r4, [r3], #4
   3268e:	623b      	str	r3, [r7, #32]
   32690:	4616      	mov	r6, r2
   32692:	4690      	mov	r8, r2
   32694:	e5ca      	b.n	3222c <__ssvfiscanf_r+0xb10>
   32696:	693b      	ldr	r3, [r7, #16]
   32698:	3302      	adds	r3, #2
   3269a:	f43f acbf 	beq.w	3201c <__ssvfiscanf_r+0x900>
   3269e:	f8d8 0000 	ldr.w	r0, [r8]
   326a2:	f000 fb05 	bl	32cb0 <iswspace>
   326a6:	2800      	cmp	r0, #0
   326a8:	f040 8110 	bne.w	328cc <__ssvfiscanf_r+0x11b0>
   326ac:	693b      	ldr	r3, [r7, #16]
   326ae:	2b03      	cmp	r3, #3
   326b0:	44b2      	add	sl, r6
   326b2:	f47f ac9d 	bne.w	31ff0 <__ssvfiscanf_r+0x8d4>
   326b6:	682b      	ldr	r3, [r5, #0]
   326b8:	2b04      	cmp	r3, #4
   326ba:	f47f ac99 	bne.w	31ff0 <__ssvfiscanf_r+0x8d4>
   326be:	e49a      	b.n	31ff6 <__ssvfiscanf_r+0x8da>
   326c0:	f898 2002 	ldrb.w	r2, [r8, #2]
   326c4:	f044 0402 	orr.w	r4, r4, #2
   326c8:	f108 0802 	add.w	r8, r8, #2
   326cc:	f7ff b858 	b.w	31780 <__ssvfiscanf_r+0x64>
   326d0:	f898 2002 	ldrb.w	r2, [r8, #2]
   326d4:	f044 0408 	orr.w	r4, r4, #8
   326d8:	f108 0802 	add.w	r8, r8, #2
   326dc:	f7ff b850 	b.w	31780 <__ssvfiscanf_r+0x64>
   326e0:	ea4f 0848 	mov.w	r8, r8, lsl #1
   326e4:	4630      	mov	r0, r6
   326e6:	4641      	mov	r1, r8
   326e8:	e9c7 320c 	strd	r3, r2, [r7, #48]	; 0x30
   326ec:	f000 fb2c 	bl	32d48 <realloc>
   326f0:	4606      	mov	r6, r0
   326f2:	2800      	cmp	r0, #0
   326f4:	f43f ae77 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   326f8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
   326fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   326fc:	f8ca 0000 	str.w	r0, [sl]
   32700:	1884      	adds	r4, r0, r2
   32702:	e5b1      	b.n	32268 <__ssvfiscanf_r+0xb4c>
   32704:	681e      	ldr	r6, [r3, #0]
   32706:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3270a:	62bb      	str	r3, [r7, #40]	; 0x28
   3270c:	2e00      	cmp	r6, #0
   3270e:	f47f a8b1 	bne.w	31874 <__ssvfiscanf_r+0x158>
   32712:	f7ff b8b2 	b.w	3187a <__ssvfiscanf_r+0x15e>
   32716:	6a3b      	ldr	r3, [r7, #32]
   32718:	633c      	str	r4, [r7, #48]	; 0x30
   3271a:	f853 5b04 	ldr.w	r5, [r3], #4
   3271e:	623b      	str	r3, [r7, #32]
   32720:	e4d2      	b.n	320c8 <__ssvfiscanf_r+0x9ac>
   32722:	e9d7 2307 	ldrd	r2, r3, [r7, #28]
   32726:	f853 6b04 	ldr.w	r6, [r3], #4
   3272a:	60ba      	str	r2, [r7, #8]
   3272c:	607a      	str	r2, [r7, #4]
   3272e:	623b      	str	r3, [r7, #32]
   32730:	60fa      	str	r2, [r7, #12]
   32732:	f7ff b960 	b.w	319f6 <__ssvfiscanf_r+0x2da>
   32736:	6a3b      	ldr	r3, [r7, #32]
   32738:	f8c7 800c 	str.w	r8, [r7, #12]
   3273c:	f853 6b04 	ldr.w	r6, [r3], #4
   32740:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
   32744:	e9c7 8307 	strd	r8, r3, [r7, #28]
   32748:	e410      	b.n	31f6c <__ssvfiscanf_r+0x850>
   3274a:	6a3b      	ldr	r3, [r7, #32]
   3274c:	68fa      	ldr	r2, [r7, #12]
   3274e:	f853 5b04 	ldr.w	r5, [r3], #4
   32752:	603a      	str	r2, [r7, #0]
   32754:	607a      	str	r2, [r7, #4]
   32756:	623b      	str	r3, [r7, #32]
   32758:	60ba      	str	r2, [r7, #8]
   3275a:	f7ff ba96 	b.w	31c8a <__ssvfiscanf_r+0x56e>
   3275e:	b082      	sub	sp, #8
   32760:	aa02      	add	r2, sp, #8
   32762:	62fa      	str	r2, [r7, #44]	; 0x2c
   32764:	6013      	str	r3, [r2, #0]
   32766:	9303      	str	r3, [sp, #12]
   32768:	f7ff b9f9 	b.w	31b5e <__ssvfiscanf_r+0x442>
   3276c:	f8d8 0000 	ldr.w	r0, [r8]
   32770:	f000 faea 	bl	32d48 <realloc>
   32774:	2800      	cmp	r0, #0
   32776:	f43f ad94 	beq.w	322a2 <__ssvfiscanf_r+0xb86>
   3277a:	f8c8 0000 	str.w	r0, [r8]
   3277e:	e590      	b.n	322a2 <__ssvfiscanf_r+0xb86>
   32780:	f64f 73f6 	movw	r3, #65526	; 0xfff6
   32784:	4299      	cmp	r1, r3
   32786:	633a      	str	r2, [r7, #48]	; 0x30
   32788:	f63f ae31 	bhi.w	323ee <__ssvfiscanf_r+0xcd2>
   3278c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   3278e:	f101 0508 	add.w	r5, r1, #8
   32792:	6810      	ldr	r0, [r2, #0]
   32794:	00a9      	lsls	r1, r5, #2
   32796:	f000 fad7 	bl	32d48 <realloc>
   3279a:	2800      	cmp	r0, #0
   3279c:	f43f ae27 	beq.w	323ee <__ssvfiscanf_r+0xcd2>
   327a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   327a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   327a4:	6018      	str	r0, [r3, #0]
   327a6:	809d      	strh	r5, [r3, #4]
   327a8:	e4f6      	b.n	32198 <__ssvfiscanf_r+0xa7c>
   327aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   327ae:	62bb      	str	r3, [r7, #40]	; 0x28
   327b0:	f7ff b863 	b.w	3187a <__ssvfiscanf_r+0x15e>
   327b4:	0761      	lsls	r1, r4, #29
   327b6:	f140 80a9 	bpl.w	3290c <__ssvfiscanf_r+0x11f0>
   327ba:	6a3a      	ldr	r2, [r7, #32]
   327bc:	f8d7 8018 	ldr.w	r8, [r7, #24]
   327c0:	f852 3b04 	ldr.w	r3, [r2], #4
   327c4:	623a      	str	r2, [r7, #32]
   327c6:	f8a3 a000 	strh.w	sl, [r3]
   327ca:	f7ff b874 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   327ce:	4659      	mov	r1, fp
   327d0:	4648      	mov	r0, r9
   327d2:	637b      	str	r3, [r7, #52]	; 0x34
   327d4:	f7fe ff46 	bl	31664 <__ssrefill_r>
   327d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   327da:	2800      	cmp	r0, #0
   327dc:	f43f ad4b 	beq.w	32276 <__ssvfiscanf_r+0xb5a>
   327e0:	e550      	b.n	32284 <__ssvfiscanf_r+0xb68>
   327e2:	f8db 2000 	ldr.w	r2, [fp]
   327e6:	4962      	ldr	r1, [pc, #392]	; (32970 <__ssvfiscanf_r+0x1254>)
   327e8:	7813      	ldrb	r3, [r2, #0]
   327ea:	5ccb      	ldrb	r3, [r1, r3]
   327ec:	071b      	lsls	r3, r3, #28
   327ee:	f53f af3a 	bmi.w	32666 <__ssvfiscanf_r+0xf4a>
   327f2:	f8db 3004 	ldr.w	r3, [fp, #4]
   327f6:	6b7c      	ldr	r4, [r7, #52]	; 0x34
   327f8:	3201      	adds	r2, #1
   327fa:	3b01      	subs	r3, #1
   327fc:	2c01      	cmp	r4, #1
   327fe:	e9cb 2300 	strd	r2, r3, [fp]
   32802:	f000 80b2 	beq.w	3296a <__ssvfiscanf_r+0x124e>
   32806:	2501      	movs	r5, #1
   32808:	461a      	mov	r2, r3
   3280a:	e014      	b.n	32836 <__ssvfiscanf_r+0x111a>
   3280c:	f8db 3000 	ldr.w	r3, [fp]
   32810:	4957      	ldr	r1, [pc, #348]	; (32970 <__ssvfiscanf_r+0x1254>)
   32812:	781a      	ldrb	r2, [r3, #0]
   32814:	5c8a      	ldrb	r2, [r1, r2]
   32816:	0716      	lsls	r6, r2, #28
   32818:	f103 0301 	add.w	r3, r3, #1
   3281c:	f53f af23 	bmi.w	32666 <__ssvfiscanf_r+0xf4a>
   32820:	f8db 2004 	ldr.w	r2, [fp, #4]
   32824:	f8cb 3000 	str.w	r3, [fp]
   32828:	3501      	adds	r5, #1
   3282a:	3a01      	subs	r2, #1
   3282c:	42ac      	cmp	r4, r5
   3282e:	f8cb 2004 	str.w	r2, [fp, #4]
   32832:	f43f af18 	beq.w	32666 <__ssvfiscanf_r+0xf4a>
   32836:	2a00      	cmp	r2, #0
   32838:	dce8      	bgt.n	3280c <__ssvfiscanf_r+0x10f0>
   3283a:	4659      	mov	r1, fp
   3283c:	4648      	mov	r0, r9
   3283e:	f7fe ff11 	bl	31664 <__ssrefill_r>
   32842:	2800      	cmp	r0, #0
   32844:	d0e2      	beq.n	3280c <__ssvfiscanf_r+0x10f0>
   32846:	e70e      	b.n	32666 <__ssvfiscanf_r+0xf4a>
   32848:	6818      	ldr	r0, [r3, #0]
   3284a:	461c      	mov	r4, r3
   3284c:	f000 fa7c 	bl	32d48 <realloc>
   32850:	2800      	cmp	r0, #0
   32852:	f43f ac7d 	beq.w	32150 <__ssvfiscanf_r+0xa34>
   32856:	6020      	str	r0, [r4, #0]
   32858:	e47a      	b.n	32150 <__ssvfiscanf_r+0xa34>
   3285a:	2c00      	cmp	r4, #0
   3285c:	f47f aebe 	bne.w	325dc <__ssvfiscanf_r+0xec0>
   32860:	f7fe bffa 	b.w	31858 <__ssvfiscanf_r+0x13c>
   32864:	f014 0201 	ands.w	r2, r4, #1
   32868:	f47f abef 	bne.w	3204a <__ssvfiscanf_r+0x92e>
   3286c:	07a1      	lsls	r1, r4, #30
   3286e:	f57f abec 	bpl.w	3204a <__ssvfiscanf_r+0x92e>
   32872:	697b      	ldr	r3, [r7, #20]
   32874:	4619      	mov	r1, r3
   32876:	4b3f      	ldr	r3, [pc, #252]	; (32974 <__ssvfiscanf_r+0x1258>)
   32878:	4299      	cmp	r1, r3
   3287a:	4648      	mov	r0, r9
   3287c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   3287e:	6b39      	ldr	r1, [r7, #48]	; 0x30
   32880:	d070      	beq.n	32964 <__ssvfiscanf_r+0x1248>
   32882:	f000 fde3 	bl	3344c <_strtoll_r>
   32886:	6a3a      	ldr	r2, [r7, #32]
   32888:	f852 3b04 	ldr.w	r3, [r2], #4
   3288c:	623a      	str	r2, [r7, #32]
   3288e:	e9c3 0100 	strd	r0, r1, [r3]
   32892:	f7ff bbdf 	b.w	32054 <__ssvfiscanf_r+0x938>
   32896:	464d      	mov	r5, r9
   32898:	613e      	str	r6, [r7, #16]
   3289a:	46d1      	mov	r9, sl
   3289c:	f8d7 a01c 	ldr.w	sl, [r7, #28]
   328a0:	f1b8 0f00 	cmp.w	r8, #0
   328a4:	f43f adee 	beq.w	32484 <__ssvfiscanf_r+0xd68>
   328a8:	f107 0350 	add.w	r3, r7, #80	; 0x50
   328ac:	441c      	add	r4, r3
   328ae:	7821      	ldrb	r1, [r4, #0]
   328b0:	465a      	mov	r2, fp
   328b2:	4648      	mov	r0, r9
   328b4:	f7fe fe96 	bl	315e4 <_sungetc_r>
   328b8:	f107 0350 	add.w	r3, r7, #80	; 0x50
   328bc:	42a3      	cmp	r3, r4
   328be:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
   328c2:	d1f4      	bne.n	328ae <__ssvfiscanf_r+0x1192>
   328c4:	e5de      	b.n	32484 <__ssvfiscanf_r+0xd68>
   328c6:	2600      	movs	r6, #0
   328c8:	f7ff bba8 	b.w	3201c <__ssvfiscanf_r+0x900>
   328cc:	4633      	mov	r3, r6
   328ce:	4646      	mov	r6, r8
   328d0:	f8d7 8008 	ldr.w	r8, [r7, #8]
   328d4:	2b00      	cmp	r3, #0
   328d6:	f43f ae2e 	beq.w	32536 <__ssvfiscanf_r+0xe1a>
   328da:	f107 0350 	add.w	r3, r7, #80	; 0x50
   328de:	441c      	add	r4, r3
   328e0:	7821      	ldrb	r1, [r4, #0]
   328e2:	465a      	mov	r2, fp
   328e4:	4648      	mov	r0, r9
   328e6:	f7fe fe7d 	bl	315e4 <_sungetc_r>
   328ea:	f107 0350 	add.w	r3, r7, #80	; 0x50
   328ee:	42a3      	cmp	r3, r4
   328f0:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
   328f4:	d1f4      	bne.n	328e0 <__ssvfiscanf_r+0x11c4>
   328f6:	e61e      	b.n	32536 <__ssvfiscanf_r+0xe1a>
   328f8:	68fc      	ldr	r4, [r7, #12]
   328fa:	6820      	ldr	r0, [r4, #0]
   328fc:	f000 fa24 	bl	32d48 <realloc>
   32900:	2800      	cmp	r0, #0
   32902:	f43f a8d7 	beq.w	31ab4 <__ssvfiscanf_r+0x398>
   32906:	6020      	str	r0, [r4, #0]
   32908:	f7ff b8d4 	b.w	31ab4 <__ssvfiscanf_r+0x398>
   3290c:	07e2      	lsls	r2, r4, #31
   3290e:	d40d      	bmi.n	3292c <__ssvfiscanf_r+0x1210>
   32910:	07a3      	lsls	r3, r4, #30
   32912:	d50b      	bpl.n	3292c <__ssvfiscanf_r+0x1210>
   32914:	6a3b      	ldr	r3, [r7, #32]
   32916:	f8d7 8018 	ldr.w	r8, [r7, #24]
   3291a:	f853 1b04 	ldr.w	r1, [r3], #4
   3291e:	623b      	str	r3, [r7, #32]
   32920:	4652      	mov	r2, sl
   32922:	17d3      	asrs	r3, r2, #31
   32924:	e9c1 2300 	strd	r2, r3, [r1]
   32928:	f7fe bfc5 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   3292c:	6a3a      	ldr	r2, [r7, #32]
   3292e:	f8d7 8018 	ldr.w	r8, [r7, #24]
   32932:	f852 3b04 	ldr.w	r3, [r2], #4
   32936:	f8c3 a000 	str.w	sl, [r3]
   3293a:	623a      	str	r2, [r7, #32]
   3293c:	f7fe bfbb 	b.w	318b6 <__ssvfiscanf_r+0x19a>
   32940:	69f8      	ldr	r0, [r7, #28]
   32942:	00d9      	lsls	r1, r3, #3
   32944:	461d      	mov	r5, r3
   32946:	f000 f9ff 	bl	32d48 <realloc>
   3294a:	61f8      	str	r0, [r7, #28]
   3294c:	2800      	cmp	r0, #0
   3294e:	f43f ad4a 	beq.w	323e6 <__ssvfiscanf_r+0xcca>
   32952:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   32954:	68be      	ldr	r6, [r7, #8]
   32956:	6010      	str	r0, [r2, #0]
   32958:	006b      	lsls	r3, r5, #1
   3295a:	eb00 0804 	add.w	r8, r0, r4
   3295e:	60fb      	str	r3, [r7, #12]
   32960:	f7ff bb5c 	b.w	3201c <__ssvfiscanf_r+0x900>
   32964:	f000 fe50 	bl	33608 <_strtoull_r>
   32968:	e78d      	b.n	32886 <__ssvfiscanf_r+0x116a>
   3296a:	6b7d      	ldr	r5, [r7, #52]	; 0x34
   3296c:	e67b      	b.n	32666 <__ssvfiscanf_r+0xf4a>
   3296e:	bf00      	nop
   32970:	000466c9 	.word	0x000466c9
   32974:	000315c9 	.word	0x000315c9

00032978 <__submore>:
   32978:	f101 0340 	add.w	r3, r1, #64	; 0x40
   3297c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   32980:	460c      	mov	r4, r1
   32982:	6b09      	ldr	r1, [r1, #48]	; 0x30
   32984:	4299      	cmp	r1, r3
   32986:	d014      	beq.n	329b2 <__submore+0x3a>
   32988:	6b66      	ldr	r6, [r4, #52]	; 0x34
   3298a:	0077      	lsls	r7, r6, #1
   3298c:	463a      	mov	r2, r7
   3298e:	f000 f9e3 	bl	32d58 <_realloc_r>
   32992:	4605      	mov	r5, r0
   32994:	b340      	cbz	r0, 329e8 <__submore+0x70>
   32996:	eb00 0806 	add.w	r8, r0, r6
   3299a:	4632      	mov	r2, r6
   3299c:	4640      	mov	r0, r8
   3299e:	4629      	mov	r1, r5
   329a0:	f7e5 fc58 	bl	18254 <memcpy>
   329a4:	e9c4 570c 	strd	r5, r7, [r4, #48]	; 0x30
   329a8:	f8c4 8000 	str.w	r8, [r4]
   329ac:	2000      	movs	r0, #0
   329ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   329b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
   329b6:	f7fe f9c7 	bl	30d48 <_malloc_r>
   329ba:	b1a8      	cbz	r0, 329e8 <__submore+0x70>
   329bc:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
   329c0:	f44f 6280 	mov.w	r2, #1024	; 0x400
   329c4:	e9c4 020c 	strd	r0, r2, [r4, #48]	; 0x30
   329c8:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
   329cc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
   329d0:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
   329d4:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
   329d8:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
   329dc:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
   329e0:	6020      	str	r0, [r4, #0]
   329e2:	2000      	movs	r0, #0
   329e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   329e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   329ec:	e7df      	b.n	329ae <__submore+0x36>
   329ee:	bf00      	nop

000329f0 <__env_lock>:
   329f0:	4801      	ldr	r0, [pc, #4]	; (329f8 <__env_lock+0x8>)
   329f2:	f7fe b993 	b.w	30d1c <__retarget_lock_acquire_recursive>
   329f6:	bf00      	nop
   329f8:	100118c4 	.word	0x100118c4

000329fc <__env_unlock>:
   329fc:	4801      	ldr	r0, [pc, #4]	; (32a04 <__env_unlock+0x8>)
   329fe:	f7fe b991 	b.w	30d24 <__retarget_lock_release_recursive>
   32a02:	bf00      	nop
   32a04:	100118c4 	.word	0x100118c4

00032a08 <_malloc_trim_r>:
   32a08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   32a0a:	4f24      	ldr	r7, [pc, #144]	; (32a9c <_malloc_trim_r+0x94>)
   32a0c:	460c      	mov	r4, r1
   32a0e:	4606      	mov	r6, r0
   32a10:	f7fe fc54 	bl	312bc <__malloc_lock>
   32a14:	68bb      	ldr	r3, [r7, #8]
   32a16:	685d      	ldr	r5, [r3, #4]
   32a18:	f5c4 617e 	rsb	r1, r4, #4064	; 0xfe0
   32a1c:	310f      	adds	r1, #15
   32a1e:	f025 0503 	bic.w	r5, r5, #3
   32a22:	194b      	adds	r3, r1, r5
   32a24:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
   32a28:	f023 030f 	bic.w	r3, r3, #15
   32a2c:	f5a3 5480 	sub.w	r4, r3, #4096	; 0x1000
   32a30:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
   32a34:	db07      	blt.n	32a46 <_malloc_trim_r+0x3e>
   32a36:	2100      	movs	r1, #0
   32a38:	4630      	mov	r0, r6
   32a3a:	f7fe fc4b 	bl	312d4 <_sbrk_r>
   32a3e:	68bb      	ldr	r3, [r7, #8]
   32a40:	442b      	add	r3, r5
   32a42:	4298      	cmp	r0, r3
   32a44:	d004      	beq.n	32a50 <_malloc_trim_r+0x48>
   32a46:	4630      	mov	r0, r6
   32a48:	f7fe fc3e 	bl	312c8 <__malloc_unlock>
   32a4c:	2000      	movs	r0, #0
   32a4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32a50:	4261      	negs	r1, r4
   32a52:	4630      	mov	r0, r6
   32a54:	f7fe fc3e 	bl	312d4 <_sbrk_r>
   32a58:	3001      	adds	r0, #1
   32a5a:	d00d      	beq.n	32a78 <_malloc_trim_r+0x70>
   32a5c:	4a10      	ldr	r2, [pc, #64]	; (32aa0 <_malloc_trim_r+0x98>)
   32a5e:	68b9      	ldr	r1, [r7, #8]
   32a60:	6813      	ldr	r3, [r2, #0]
   32a62:	1b2d      	subs	r5, r5, r4
   32a64:	f045 0501 	orr.w	r5, r5, #1
   32a68:	4630      	mov	r0, r6
   32a6a:	1b1b      	subs	r3, r3, r4
   32a6c:	604d      	str	r5, [r1, #4]
   32a6e:	6013      	str	r3, [r2, #0]
   32a70:	f7fe fc2a 	bl	312c8 <__malloc_unlock>
   32a74:	2001      	movs	r0, #1
   32a76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   32a78:	2100      	movs	r1, #0
   32a7a:	4630      	mov	r0, r6
   32a7c:	f7fe fc2a 	bl	312d4 <_sbrk_r>
   32a80:	68ba      	ldr	r2, [r7, #8]
   32a82:	1a83      	subs	r3, r0, r2
   32a84:	2b0f      	cmp	r3, #15
   32a86:	ddde      	ble.n	32a46 <_malloc_trim_r+0x3e>
   32a88:	4c06      	ldr	r4, [pc, #24]	; (32aa4 <_malloc_trim_r+0x9c>)
   32a8a:	4905      	ldr	r1, [pc, #20]	; (32aa0 <_malloc_trim_r+0x98>)
   32a8c:	6824      	ldr	r4, [r4, #0]
   32a8e:	f043 0301 	orr.w	r3, r3, #1
   32a92:	1b00      	subs	r0, r0, r4
   32a94:	6053      	str	r3, [r2, #4]
   32a96:	6008      	str	r0, [r1, #0]
   32a98:	e7d5      	b.n	32a46 <_malloc_trim_r+0x3e>
   32a9a:	bf00      	nop
   32a9c:	10003208 	.word	0x10003208
   32aa0:	1000bea0 	.word	0x1000bea0
   32aa4:	10003610 	.word	0x10003610

00032aa8 <_free_r>:
   32aa8:	2900      	cmp	r1, #0
   32aaa:	d05e      	beq.n	32b6a <_free_r+0xc2>
   32aac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   32aae:	460c      	mov	r4, r1
   32ab0:	4606      	mov	r6, r0
   32ab2:	f7fe fc03 	bl	312bc <__malloc_lock>
   32ab6:	f854 3c04 	ldr.w	r3, [r4, #-4]
   32aba:	f8df c1f0 	ldr.w	ip, [pc, #496]	; 32cac <_free_r+0x204>
   32abe:	f023 0101 	bic.w	r1, r3, #1
   32ac2:	f1a4 0008 	sub.w	r0, r4, #8
   32ac6:	1842      	adds	r2, r0, r1
   32ac8:	f8dc 7008 	ldr.w	r7, [ip, #8]
   32acc:	6855      	ldr	r5, [r2, #4]
   32ace:	4297      	cmp	r7, r2
   32ad0:	f025 0503 	bic.w	r5, r5, #3
   32ad4:	f000 8088 	beq.w	32be8 <_free_r+0x140>
   32ad8:	07df      	lsls	r7, r3, #31
   32ada:	6055      	str	r5, [r2, #4]
   32adc:	d433      	bmi.n	32b46 <_free_r+0x9e>
   32ade:	f854 7c08 	ldr.w	r7, [r4, #-8]
   32ae2:	1bc0      	subs	r0, r0, r7
   32ae4:	f10c 0408 	add.w	r4, ip, #8
   32ae8:	6883      	ldr	r3, [r0, #8]
   32aea:	42a3      	cmp	r3, r4
   32aec:	4439      	add	r1, r7
   32aee:	d069      	beq.n	32bc4 <_free_r+0x11c>
   32af0:	1957      	adds	r7, r2, r5
   32af2:	f8d0 e00c 	ldr.w	lr, [r0, #12]
   32af6:	687f      	ldr	r7, [r7, #4]
   32af8:	f8c3 e00c 	str.w	lr, [r3, #12]
   32afc:	f8ce 3008 	str.w	r3, [lr, #8]
   32b00:	07fb      	lsls	r3, r7, #31
   32b02:	f140 8096 	bpl.w	32c32 <_free_r+0x18a>
   32b06:	f041 0301 	orr.w	r3, r1, #1
   32b0a:	6043      	str	r3, [r0, #4]
   32b0c:	6011      	str	r1, [r2, #0]
   32b0e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   32b12:	d233      	bcs.n	32b7c <_free_r+0xd4>
   32b14:	08cb      	lsrs	r3, r1, #3
   32b16:	f8dc 4004 	ldr.w	r4, [ip, #4]
   32b1a:	3301      	adds	r3, #1
   32b1c:	094a      	lsrs	r2, r1, #5
   32b1e:	2101      	movs	r1, #1
   32b20:	4091      	lsls	r1, r2
   32b22:	4321      	orrs	r1, r4
   32b24:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
   32b28:	f85c 4033 	ldr.w	r4, [ip, r3, lsl #3]
   32b2c:	f8cc 1004 	str.w	r1, [ip, #4]
   32b30:	3a08      	subs	r2, #8
   32b32:	e9c0 4202 	strd	r4, r2, [r0, #8]
   32b36:	f84c 0033 	str.w	r0, [ip, r3, lsl #3]
   32b3a:	60e0      	str	r0, [r4, #12]
   32b3c:	4630      	mov	r0, r6
   32b3e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   32b42:	f7fe bbc1 	b.w	312c8 <__malloc_unlock>
   32b46:	1953      	adds	r3, r2, r5
   32b48:	685b      	ldr	r3, [r3, #4]
   32b4a:	07df      	lsls	r7, r3, #31
   32b4c:	d40e      	bmi.n	32b6c <_free_r+0xc4>
   32b4e:	4429      	add	r1, r5
   32b50:	f10c 0408 	add.w	r4, ip, #8
   32b54:	6893      	ldr	r3, [r2, #8]
   32b56:	42a3      	cmp	r3, r4
   32b58:	d073      	beq.n	32c42 <_free_r+0x19a>
   32b5a:	68d4      	ldr	r4, [r2, #12]
   32b5c:	60dc      	str	r4, [r3, #12]
   32b5e:	f041 0201 	orr.w	r2, r1, #1
   32b62:	60a3      	str	r3, [r4, #8]
   32b64:	6042      	str	r2, [r0, #4]
   32b66:	5041      	str	r1, [r0, r1]
   32b68:	e7d1      	b.n	32b0e <_free_r+0x66>
   32b6a:	4770      	bx	lr
   32b6c:	f041 0301 	orr.w	r3, r1, #1
   32b70:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   32b74:	f844 3c04 	str.w	r3, [r4, #-4]
   32b78:	6011      	str	r1, [r2, #0]
   32b7a:	d3cb      	bcc.n	32b14 <_free_r+0x6c>
   32b7c:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
   32b80:	ea4f 2351 	mov.w	r3, r1, lsr #9
   32b84:	d24a      	bcs.n	32c1c <_free_r+0x174>
   32b86:	098b      	lsrs	r3, r1, #6
   32b88:	f103 0539 	add.w	r5, r3, #57	; 0x39
   32b8c:	00ed      	lsls	r5, r5, #3
   32b8e:	f103 0238 	add.w	r2, r3, #56	; 0x38
   32b92:	f85c 3005 	ldr.w	r3, [ip, r5]
   32b96:	eb0c 0405 	add.w	r4, ip, r5
   32b9a:	3c08      	subs	r4, #8
   32b9c:	429c      	cmp	r4, r3
   32b9e:	d059      	beq.n	32c54 <_free_r+0x1ac>
   32ba0:	685a      	ldr	r2, [r3, #4]
   32ba2:	f022 0203 	bic.w	r2, r2, #3
   32ba6:	428a      	cmp	r2, r1
   32ba8:	d902      	bls.n	32bb0 <_free_r+0x108>
   32baa:	689b      	ldr	r3, [r3, #8]
   32bac:	429c      	cmp	r4, r3
   32bae:	d1f7      	bne.n	32ba0 <_free_r+0xf8>
   32bb0:	68dc      	ldr	r4, [r3, #12]
   32bb2:	e9c0 3402 	strd	r3, r4, [r0, #8]
   32bb6:	60a0      	str	r0, [r4, #8]
   32bb8:	60d8      	str	r0, [r3, #12]
   32bba:	4630      	mov	r0, r6
   32bbc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   32bc0:	f7fe bb82 	b.w	312c8 <__malloc_unlock>
   32bc4:	1953      	adds	r3, r2, r5
   32bc6:	685b      	ldr	r3, [r3, #4]
   32bc8:	07db      	lsls	r3, r3, #31
   32bca:	d466      	bmi.n	32c9a <_free_r+0x1f2>
   32bcc:	e9d2 2302 	ldrd	r2, r3, [r2, #8]
   32bd0:	4429      	add	r1, r5
   32bd2:	f041 0401 	orr.w	r4, r1, #1
   32bd6:	60d3      	str	r3, [r2, #12]
   32bd8:	609a      	str	r2, [r3, #8]
   32bda:	6044      	str	r4, [r0, #4]
   32bdc:	5041      	str	r1, [r0, r1]
   32bde:	4630      	mov	r0, r6
   32be0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   32be4:	f7fe bb70 	b.w	312c8 <__malloc_unlock>
   32be8:	07db      	lsls	r3, r3, #31
   32bea:	4429      	add	r1, r5
   32bec:	d407      	bmi.n	32bfe <_free_r+0x156>
   32bee:	f854 3c08 	ldr.w	r3, [r4, #-8]
   32bf2:	1ac0      	subs	r0, r0, r3
   32bf4:	4419      	add	r1, r3
   32bf6:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
   32bfa:	60d3      	str	r3, [r2, #12]
   32bfc:	609a      	str	r2, [r3, #8]
   32bfe:	4b29      	ldr	r3, [pc, #164]	; (32ca4 <_free_r+0x1fc>)
   32c00:	681b      	ldr	r3, [r3, #0]
   32c02:	f041 0201 	orr.w	r2, r1, #1
   32c06:	428b      	cmp	r3, r1
   32c08:	6042      	str	r2, [r0, #4]
   32c0a:	f8cc 0008 	str.w	r0, [ip, #8]
   32c0e:	d895      	bhi.n	32b3c <_free_r+0x94>
   32c10:	4b25      	ldr	r3, [pc, #148]	; (32ca8 <_free_r+0x200>)
   32c12:	4630      	mov	r0, r6
   32c14:	6819      	ldr	r1, [r3, #0]
   32c16:	f7ff fef7 	bl	32a08 <_malloc_trim_r>
   32c1a:	e78f      	b.n	32b3c <_free_r+0x94>
   32c1c:	2b14      	cmp	r3, #20
   32c1e:	d90a      	bls.n	32c36 <_free_r+0x18e>
   32c20:	2b54      	cmp	r3, #84	; 0x54
   32c22:	d821      	bhi.n	32c68 <_free_r+0x1c0>
   32c24:	0b0b      	lsrs	r3, r1, #12
   32c26:	f103 056f 	add.w	r5, r3, #111	; 0x6f
   32c2a:	00ed      	lsls	r5, r5, #3
   32c2c:	f103 026e 	add.w	r2, r3, #110	; 0x6e
   32c30:	e7af      	b.n	32b92 <_free_r+0xea>
   32c32:	4429      	add	r1, r5
   32c34:	e78e      	b.n	32b54 <_free_r+0xac>
   32c36:	f103 055c 	add.w	r5, r3, #92	; 0x5c
   32c3a:	00ed      	lsls	r5, r5, #3
   32c3c:	f103 025b 	add.w	r2, r3, #91	; 0x5b
   32c40:	e7a7      	b.n	32b92 <_free_r+0xea>
   32c42:	f041 0301 	orr.w	r3, r1, #1
   32c46:	e9cc 0004 	strd	r0, r0, [ip, #16]
   32c4a:	e9c0 4402 	strd	r4, r4, [r0, #8]
   32c4e:	6043      	str	r3, [r0, #4]
   32c50:	5041      	str	r1, [r0, r1]
   32c52:	e773      	b.n	32b3c <_free_r+0x94>
   32c54:	f8dc 1004 	ldr.w	r1, [ip, #4]
   32c58:	1092      	asrs	r2, r2, #2
   32c5a:	2501      	movs	r5, #1
   32c5c:	fa05 f202 	lsl.w	r2, r5, r2
   32c60:	430a      	orrs	r2, r1
   32c62:	f8cc 2004 	str.w	r2, [ip, #4]
   32c66:	e7a4      	b.n	32bb2 <_free_r+0x10a>
   32c68:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
   32c6c:	d806      	bhi.n	32c7c <_free_r+0x1d4>
   32c6e:	0bcb      	lsrs	r3, r1, #15
   32c70:	f103 0578 	add.w	r5, r3, #120	; 0x78
   32c74:	00ed      	lsls	r5, r5, #3
   32c76:	f103 0277 	add.w	r2, r3, #119	; 0x77
   32c7a:	e78a      	b.n	32b92 <_free_r+0xea>
   32c7c:	f240 5254 	movw	r2, #1364	; 0x554
   32c80:	4293      	cmp	r3, r2
   32c82:	d806      	bhi.n	32c92 <_free_r+0x1ea>
   32c84:	0c8b      	lsrs	r3, r1, #18
   32c86:	f103 057d 	add.w	r5, r3, #125	; 0x7d
   32c8a:	00ed      	lsls	r5, r5, #3
   32c8c:	f103 027c 	add.w	r2, r3, #124	; 0x7c
   32c90:	e77f      	b.n	32b92 <_free_r+0xea>
   32c92:	f44f 757e 	mov.w	r5, #1016	; 0x3f8
   32c96:	227e      	movs	r2, #126	; 0x7e
   32c98:	e77b      	b.n	32b92 <_free_r+0xea>
   32c9a:	f041 0301 	orr.w	r3, r1, #1
   32c9e:	6043      	str	r3, [r0, #4]
   32ca0:	6011      	str	r1, [r2, #0]
   32ca2:	e74b      	b.n	32b3c <_free_r+0x94>
   32ca4:	10003614 	.word	0x10003614
   32ca8:	1000bed0 	.word	0x1000bed0
   32cac:	10003208 	.word	0x10003208

00032cb0 <iswspace>:
   32cb0:	2100      	movs	r1, #0
   32cb2:	f000 b801 	b.w	32cb8 <iswspace_l>
   32cb6:	bf00      	nop

00032cb8 <iswspace_l>:
   32cb8:	28ff      	cmp	r0, #255	; 0xff
   32cba:	bf9d      	ittte	ls
   32cbc:	4b02      	ldrls	r3, [pc, #8]	; (32cc8 <iswspace_l+0x10>)
   32cbe:	5cc0      	ldrbls	r0, [r0, r3]
   32cc0:	f000 0008 	andls.w	r0, r0, #8
   32cc4:	2000      	movhi	r0, #0
   32cc6:	4770      	bx	lr
   32cc8:	000466c9 	.word	0x000466c9

00032ccc <__locale_mb_cur_max>:
   32ccc:	4b01      	ldr	r3, [pc, #4]	; (32cd4 <__locale_mb_cur_max+0x8>)
   32cce:	f893 0128 	ldrb.w	r0, [r3, #296]	; 0x128
   32cd2:	4770      	bx	lr
   32cd4:	1000361c 	.word	0x1000361c

00032cd8 <_mbrtowc_r>:
   32cd8:	b570      	push	{r4, r5, r6, lr}
   32cda:	b082      	sub	sp, #8
   32cdc:	4606      	mov	r6, r0
   32cde:	9c06      	ldr	r4, [sp, #24]
   32ce0:	b142      	cbz	r2, 32cf4 <_mbrtowc_r+0x1c>
   32ce2:	4d0c      	ldr	r5, [pc, #48]	; (32d14 <_mbrtowc_r+0x3c>)
   32ce4:	9400      	str	r4, [sp, #0]
   32ce6:	f8d5 50e4 	ldr.w	r5, [r5, #228]	; 0xe4
   32cea:	47a8      	blx	r5
   32cec:	1c43      	adds	r3, r0, #1
   32cee:	d00b      	beq.n	32d08 <_mbrtowc_r+0x30>
   32cf0:	b002      	add	sp, #8
   32cf2:	bd70      	pop	{r4, r5, r6, pc}
   32cf4:	4b07      	ldr	r3, [pc, #28]	; (32d14 <_mbrtowc_r+0x3c>)
   32cf6:	9400      	str	r4, [sp, #0]
   32cf8:	f8d3 50e4 	ldr.w	r5, [r3, #228]	; 0xe4
   32cfc:	4611      	mov	r1, r2
   32cfe:	2301      	movs	r3, #1
   32d00:	4a05      	ldr	r2, [pc, #20]	; (32d18 <_mbrtowc_r+0x40>)
   32d02:	47a8      	blx	r5
   32d04:	1c43      	adds	r3, r0, #1
   32d06:	d1f3      	bne.n	32cf0 <_mbrtowc_r+0x18>
   32d08:	2200      	movs	r2, #0
   32d0a:	238a      	movs	r3, #138	; 0x8a
   32d0c:	6022      	str	r2, [r4, #0]
   32d0e:	6033      	str	r3, [r6, #0]
   32d10:	b002      	add	sp, #8
   32d12:	bd70      	pop	{r4, r5, r6, pc}
   32d14:	1000361c 	.word	0x1000361c
   32d18:	000467d8 	.word	0x000467d8

00032d1c <__ascii_mbtowc>:
   32d1c:	b082      	sub	sp, #8
   32d1e:	b149      	cbz	r1, 32d34 <__ascii_mbtowc+0x18>
   32d20:	b15a      	cbz	r2, 32d3a <__ascii_mbtowc+0x1e>
   32d22:	b16b      	cbz	r3, 32d40 <__ascii_mbtowc+0x24>
   32d24:	7813      	ldrb	r3, [r2, #0]
   32d26:	600b      	str	r3, [r1, #0]
   32d28:	7812      	ldrb	r2, [r2, #0]
   32d2a:	1e10      	subs	r0, r2, #0
   32d2c:	bf18      	it	ne
   32d2e:	2001      	movne	r0, #1
   32d30:	b002      	add	sp, #8
   32d32:	4770      	bx	lr
   32d34:	a901      	add	r1, sp, #4
   32d36:	2a00      	cmp	r2, #0
   32d38:	d1f3      	bne.n	32d22 <__ascii_mbtowc+0x6>
   32d3a:	4610      	mov	r0, r2
   32d3c:	b002      	add	sp, #8
   32d3e:	4770      	bx	lr
   32d40:	f06f 0001 	mvn.w	r0, #1
   32d44:	e7f4      	b.n	32d30 <__ascii_mbtowc+0x14>
   32d46:	bf00      	nop

00032d48 <realloc>:
   32d48:	4b02      	ldr	r3, [pc, #8]	; (32d54 <realloc+0xc>)
   32d4a:	460a      	mov	r2, r1
   32d4c:	4601      	mov	r1, r0
   32d4e:	6818      	ldr	r0, [r3, #0]
   32d50:	f000 b802 	b.w	32d58 <_realloc_r>
   32d54:	10002d7c 	.word	0x10002d7c

00032d58 <_realloc_r>:
   32d58:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32d5c:	4617      	mov	r7, r2
   32d5e:	2900      	cmp	r1, #0
   32d60:	f000 80bc 	beq.w	32edc <_realloc_r+0x184>
   32d64:	f107 050b 	add.w	r5, r7, #11
   32d68:	460c      	mov	r4, r1
   32d6a:	4680      	mov	r8, r0
   32d6c:	f7fe faa6 	bl	312bc <__malloc_lock>
   32d70:	2d16      	cmp	r5, #22
   32d72:	d85f      	bhi.n	32e34 <_realloc_r+0xdc>
   32d74:	2510      	movs	r5, #16
   32d76:	462a      	mov	r2, r5
   32d78:	42af      	cmp	r7, r5
   32d7a:	d860      	bhi.n	32e3e <_realloc_r+0xe6>
   32d7c:	f854 1c04 	ldr.w	r1, [r4, #-4]
   32d80:	f021 0603 	bic.w	r6, r1, #3
   32d84:	4296      	cmp	r6, r2
   32d86:	f1a4 0908 	sub.w	r9, r4, #8
   32d8a:	f280 8086 	bge.w	32e9a <_realloc_r+0x142>
   32d8e:	4bc9      	ldr	r3, [pc, #804]	; (330b4 <_realloc_r+0x35c>)
   32d90:	f8d3 c008 	ldr.w	ip, [r3, #8]
   32d94:	eb09 0006 	add.w	r0, r9, r6
   32d98:	4584      	cmp	ip, r0
   32d9a:	f000 80ba 	beq.w	32f12 <_realloc_r+0x1ba>
   32d9e:	f8d0 c004 	ldr.w	ip, [r0, #4]
   32da2:	f02c 0301 	bic.w	r3, ip, #1
   32da6:	4403      	add	r3, r0
   32da8:	685b      	ldr	r3, [r3, #4]
   32daa:	07db      	lsls	r3, r3, #31
   32dac:	f100 808b 	bmi.w	32ec6 <_realloc_r+0x16e>
   32db0:	f02c 0c03 	bic.w	ip, ip, #3
   32db4:	eb06 030c 	add.w	r3, r6, ip
   32db8:	4293      	cmp	r3, r2
   32dba:	f280 8116 	bge.w	32fea <_realloc_r+0x292>
   32dbe:	07cb      	lsls	r3, r1, #31
   32dc0:	d40f      	bmi.n	32de2 <_realloc_r+0x8a>
   32dc2:	f854 3c08 	ldr.w	r3, [r4, #-8]
   32dc6:	eba9 0a03 	sub.w	sl, r9, r3
   32dca:	f8da 3004 	ldr.w	r3, [sl, #4]
   32dce:	f023 0103 	bic.w	r1, r3, #3
   32dd2:	448c      	add	ip, r1
   32dd4:	44b4      	add	ip, r6
   32dd6:	4594      	cmp	ip, r2
   32dd8:	da38      	bge.n	32e4c <_realloc_r+0xf4>
   32dda:	1873      	adds	r3, r6, r1
   32ddc:	4293      	cmp	r3, r2
   32dde:	f280 8110 	bge.w	33002 <_realloc_r+0x2aa>
   32de2:	4639      	mov	r1, r7
   32de4:	4640      	mov	r0, r8
   32de6:	f7fd ffaf 	bl	30d48 <_malloc_r>
   32dea:	4607      	mov	r7, r0
   32dec:	b1e0      	cbz	r0, 32e28 <_realloc_r+0xd0>
   32dee:	f854 3c04 	ldr.w	r3, [r4, #-4]
   32df2:	f023 0301 	bic.w	r3, r3, #1
   32df6:	444b      	add	r3, r9
   32df8:	f1a0 0208 	sub.w	r2, r0, #8
   32dfc:	4293      	cmp	r3, r2
   32dfe:	f000 80fa 	beq.w	32ff6 <_realloc_r+0x29e>
   32e02:	1f32      	subs	r2, r6, #4
   32e04:	2a24      	cmp	r2, #36	; 0x24
   32e06:	f200 811d 	bhi.w	33044 <_realloc_r+0x2ec>
   32e0a:	2a13      	cmp	r2, #19
   32e0c:	f200 80ce 	bhi.w	32fac <_realloc_r+0x254>
   32e10:	4603      	mov	r3, r0
   32e12:	4622      	mov	r2, r4
   32e14:	6811      	ldr	r1, [r2, #0]
   32e16:	6019      	str	r1, [r3, #0]
   32e18:	6851      	ldr	r1, [r2, #4]
   32e1a:	6059      	str	r1, [r3, #4]
   32e1c:	6892      	ldr	r2, [r2, #8]
   32e1e:	609a      	str	r2, [r3, #8]
   32e20:	4621      	mov	r1, r4
   32e22:	4640      	mov	r0, r8
   32e24:	f7ff fe40 	bl	32aa8 <_free_r>
   32e28:	4640      	mov	r0, r8
   32e2a:	f7fe fa4d 	bl	312c8 <__malloc_unlock>
   32e2e:	4638      	mov	r0, r7
   32e30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   32e34:	f025 0507 	bic.w	r5, r5, #7
   32e38:	2d00      	cmp	r5, #0
   32e3a:	462a      	mov	r2, r5
   32e3c:	da9c      	bge.n	32d78 <_realloc_r+0x20>
   32e3e:	230c      	movs	r3, #12
   32e40:	f8c8 3000 	str.w	r3, [r8]
   32e44:	2700      	movs	r7, #0
   32e46:	4638      	mov	r0, r7
   32e48:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   32e4c:	e9d0 2302 	ldrd	r2, r3, [r0, #8]
   32e50:	4657      	mov	r7, sl
   32e52:	60d3      	str	r3, [r2, #12]
   32e54:	609a      	str	r2, [r3, #8]
   32e56:	f857 1f08 	ldr.w	r1, [r7, #8]!
   32e5a:	f8da 300c 	ldr.w	r3, [sl, #12]
   32e5e:	60cb      	str	r3, [r1, #12]
   32e60:	1f32      	subs	r2, r6, #4
   32e62:	2a24      	cmp	r2, #36	; 0x24
   32e64:	6099      	str	r1, [r3, #8]
   32e66:	f200 8108 	bhi.w	3307a <_realloc_r+0x322>
   32e6a:	2a13      	cmp	r2, #19
   32e6c:	f240 8103 	bls.w	33076 <_realloc_r+0x31e>
   32e70:	6823      	ldr	r3, [r4, #0]
   32e72:	f8ca 3008 	str.w	r3, [sl, #8]
   32e76:	6863      	ldr	r3, [r4, #4]
   32e78:	f8ca 300c 	str.w	r3, [sl, #12]
   32e7c:	2a1b      	cmp	r2, #27
   32e7e:	f200 811b 	bhi.w	330b8 <_realloc_r+0x360>
   32e82:	3408      	adds	r4, #8
   32e84:	f10a 0310 	add.w	r3, sl, #16
   32e88:	6822      	ldr	r2, [r4, #0]
   32e8a:	601a      	str	r2, [r3, #0]
   32e8c:	6862      	ldr	r2, [r4, #4]
   32e8e:	605a      	str	r2, [r3, #4]
   32e90:	68a2      	ldr	r2, [r4, #8]
   32e92:	609a      	str	r2, [r3, #8]
   32e94:	4666      	mov	r6, ip
   32e96:	46d1      	mov	r9, sl
   32e98:	463c      	mov	r4, r7
   32e9a:	1b73      	subs	r3, r6, r5
   32e9c:	2b0f      	cmp	r3, #15
   32e9e:	d822      	bhi.n	32ee6 <_realloc_r+0x18e>
   32ea0:	f8d9 3004 	ldr.w	r3, [r9, #4]
   32ea4:	f003 0301 	and.w	r3, r3, #1
   32ea8:	4333      	orrs	r3, r6
   32eaa:	444e      	add	r6, r9
   32eac:	f8c9 3004 	str.w	r3, [r9, #4]
   32eb0:	6873      	ldr	r3, [r6, #4]
   32eb2:	f043 0301 	orr.w	r3, r3, #1
   32eb6:	6073      	str	r3, [r6, #4]
   32eb8:	4640      	mov	r0, r8
   32eba:	4627      	mov	r7, r4
   32ebc:	f7fe fa04 	bl	312c8 <__malloc_unlock>
   32ec0:	4638      	mov	r0, r7
   32ec2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   32ec6:	07c9      	lsls	r1, r1, #31
   32ec8:	d48b      	bmi.n	32de2 <_realloc_r+0x8a>
   32eca:	f854 3c08 	ldr.w	r3, [r4, #-8]
   32ece:	eba9 0a03 	sub.w	sl, r9, r3
   32ed2:	f8da 1004 	ldr.w	r1, [sl, #4]
   32ed6:	f021 0103 	bic.w	r1, r1, #3
   32eda:	e77e      	b.n	32dda <_realloc_r+0x82>
   32edc:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   32ee0:	4611      	mov	r1, r2
   32ee2:	f7fd bf31 	b.w	30d48 <_malloc_r>
   32ee6:	f8d9 2004 	ldr.w	r2, [r9, #4]
   32eea:	eb09 0105 	add.w	r1, r9, r5
   32eee:	f002 0201 	and.w	r2, r2, #1
   32ef2:	444e      	add	r6, r9
   32ef4:	f043 0301 	orr.w	r3, r3, #1
   32ef8:	4315      	orrs	r5, r2
   32efa:	f8c9 5004 	str.w	r5, [r9, #4]
   32efe:	604b      	str	r3, [r1, #4]
   32f00:	6873      	ldr	r3, [r6, #4]
   32f02:	f043 0301 	orr.w	r3, r3, #1
   32f06:	3108      	adds	r1, #8
   32f08:	6073      	str	r3, [r6, #4]
   32f0a:	4640      	mov	r0, r8
   32f0c:	f7ff fdcc 	bl	32aa8 <_free_r>
   32f10:	e7d2      	b.n	32eb8 <_realloc_r+0x160>
   32f12:	f8dc 0004 	ldr.w	r0, [ip, #4]
   32f16:	f020 0b03 	bic.w	fp, r0, #3
   32f1a:	eb06 0c0b 	add.w	ip, r6, fp
   32f1e:	f105 0010 	add.w	r0, r5, #16
   32f22:	4584      	cmp	ip, r0
   32f24:	da4d      	bge.n	32fc2 <_realloc_r+0x26a>
   32f26:	07c9      	lsls	r1, r1, #31
   32f28:	f53f af5b 	bmi.w	32de2 <_realloc_r+0x8a>
   32f2c:	f854 1c08 	ldr.w	r1, [r4, #-8]
   32f30:	eba9 0a01 	sub.w	sl, r9, r1
   32f34:	f8da 1004 	ldr.w	r1, [sl, #4]
   32f38:	f021 0103 	bic.w	r1, r1, #3
   32f3c:	448b      	add	fp, r1
   32f3e:	44b3      	add	fp, r6
   32f40:	4558      	cmp	r0, fp
   32f42:	f73f af4a 	bgt.w	32dda <_realloc_r+0x82>
   32f46:	4657      	mov	r7, sl
   32f48:	f8da 100c 	ldr.w	r1, [sl, #12]
   32f4c:	f857 0f08 	ldr.w	r0, [r7, #8]!
   32f50:	1f32      	subs	r2, r6, #4
   32f52:	2a24      	cmp	r2, #36	; 0x24
   32f54:	60c1      	str	r1, [r0, #12]
   32f56:	6088      	str	r0, [r1, #8]
   32f58:	f200 80bc 	bhi.w	330d4 <_realloc_r+0x37c>
   32f5c:	2a13      	cmp	r2, #19
   32f5e:	f240 80b7 	bls.w	330d0 <_realloc_r+0x378>
   32f62:	6821      	ldr	r1, [r4, #0]
   32f64:	f8ca 1008 	str.w	r1, [sl, #8]
   32f68:	6861      	ldr	r1, [r4, #4]
   32f6a:	f8ca 100c 	str.w	r1, [sl, #12]
   32f6e:	2a1b      	cmp	r2, #27
   32f70:	f200 80c0 	bhi.w	330f4 <_realloc_r+0x39c>
   32f74:	3408      	adds	r4, #8
   32f76:	f10a 0210 	add.w	r2, sl, #16
   32f7a:	6821      	ldr	r1, [r4, #0]
   32f7c:	6011      	str	r1, [r2, #0]
   32f7e:	6861      	ldr	r1, [r4, #4]
   32f80:	6051      	str	r1, [r2, #4]
   32f82:	68a1      	ldr	r1, [r4, #8]
   32f84:	6091      	str	r1, [r2, #8]
   32f86:	eb0a 0105 	add.w	r1, sl, r5
   32f8a:	ebab 0205 	sub.w	r2, fp, r5
   32f8e:	f042 0201 	orr.w	r2, r2, #1
   32f92:	6099      	str	r1, [r3, #8]
   32f94:	604a      	str	r2, [r1, #4]
   32f96:	f8da 3004 	ldr.w	r3, [sl, #4]
   32f9a:	f003 0301 	and.w	r3, r3, #1
   32f9e:	431d      	orrs	r5, r3
   32fa0:	4640      	mov	r0, r8
   32fa2:	f8ca 5004 	str.w	r5, [sl, #4]
   32fa6:	f7fe f98f 	bl	312c8 <__malloc_unlock>
   32faa:	e74c      	b.n	32e46 <_realloc_r+0xee>
   32fac:	6823      	ldr	r3, [r4, #0]
   32fae:	6003      	str	r3, [r0, #0]
   32fb0:	6863      	ldr	r3, [r4, #4]
   32fb2:	6043      	str	r3, [r0, #4]
   32fb4:	2a1b      	cmp	r2, #27
   32fb6:	d849      	bhi.n	3304c <_realloc_r+0x2f4>
   32fb8:	f104 0208 	add.w	r2, r4, #8
   32fbc:	f100 0308 	add.w	r3, r0, #8
   32fc0:	e728      	b.n	32e14 <_realloc_r+0xbc>
   32fc2:	eb09 0105 	add.w	r1, r9, r5
   32fc6:	ebac 0205 	sub.w	r2, ip, r5
   32fca:	f042 0201 	orr.w	r2, r2, #1
   32fce:	6099      	str	r1, [r3, #8]
   32fd0:	604a      	str	r2, [r1, #4]
   32fd2:	f854 3c04 	ldr.w	r3, [r4, #-4]
   32fd6:	f003 0301 	and.w	r3, r3, #1
   32fda:	431d      	orrs	r5, r3
   32fdc:	4640      	mov	r0, r8
   32fde:	f844 5c04 	str.w	r5, [r4, #-4]
   32fe2:	f7fe f971 	bl	312c8 <__malloc_unlock>
   32fe6:	4627      	mov	r7, r4
   32fe8:	e72d      	b.n	32e46 <_realloc_r+0xee>
   32fea:	e9d0 1202 	ldrd	r1, r2, [r0, #8]
   32fee:	461e      	mov	r6, r3
   32ff0:	60ca      	str	r2, [r1, #12]
   32ff2:	6091      	str	r1, [r2, #8]
   32ff4:	e751      	b.n	32e9a <_realloc_r+0x142>
   32ff6:	f850 3c04 	ldr.w	r3, [r0, #-4]
   32ffa:	f023 0303 	bic.w	r3, r3, #3
   32ffe:	441e      	add	r6, r3
   33000:	e74b      	b.n	32e9a <_realloc_r+0x142>
   33002:	4657      	mov	r7, sl
   33004:	f8da 100c 	ldr.w	r1, [sl, #12]
   33008:	f857 0f08 	ldr.w	r0, [r7, #8]!
   3300c:	1f32      	subs	r2, r6, #4
   3300e:	2a24      	cmp	r2, #36	; 0x24
   33010:	60c1      	str	r1, [r0, #12]
   33012:	6088      	str	r0, [r1, #8]
   33014:	d827      	bhi.n	33066 <_realloc_r+0x30e>
   33016:	2a13      	cmp	r2, #19
   33018:	d923      	bls.n	33062 <_realloc_r+0x30a>
   3301a:	6821      	ldr	r1, [r4, #0]
   3301c:	f8ca 1008 	str.w	r1, [sl, #8]
   33020:	6861      	ldr	r1, [r4, #4]
   33022:	f8ca 100c 	str.w	r1, [sl, #12]
   33026:	2a1b      	cmp	r2, #27
   33028:	d82f      	bhi.n	3308a <_realloc_r+0x332>
   3302a:	3408      	adds	r4, #8
   3302c:	f10a 0210 	add.w	r2, sl, #16
   33030:	6821      	ldr	r1, [r4, #0]
   33032:	6011      	str	r1, [r2, #0]
   33034:	6861      	ldr	r1, [r4, #4]
   33036:	6051      	str	r1, [r2, #4]
   33038:	68a1      	ldr	r1, [r4, #8]
   3303a:	6091      	str	r1, [r2, #8]
   3303c:	461e      	mov	r6, r3
   3303e:	46d1      	mov	r9, sl
   33040:	463c      	mov	r4, r7
   33042:	e72a      	b.n	32e9a <_realloc_r+0x142>
   33044:	4621      	mov	r1, r4
   33046:	f7fc ffe7 	bl	30018 <memmove>
   3304a:	e6e9      	b.n	32e20 <_realloc_r+0xc8>
   3304c:	68a3      	ldr	r3, [r4, #8]
   3304e:	6083      	str	r3, [r0, #8]
   33050:	68e3      	ldr	r3, [r4, #12]
   33052:	60c3      	str	r3, [r0, #12]
   33054:	2a24      	cmp	r2, #36	; 0x24
   33056:	d024      	beq.n	330a2 <_realloc_r+0x34a>
   33058:	f104 0210 	add.w	r2, r4, #16
   3305c:	f100 0310 	add.w	r3, r0, #16
   33060:	e6d8      	b.n	32e14 <_realloc_r+0xbc>
   33062:	463a      	mov	r2, r7
   33064:	e7e4      	b.n	33030 <_realloc_r+0x2d8>
   33066:	4621      	mov	r1, r4
   33068:	4638      	mov	r0, r7
   3306a:	461e      	mov	r6, r3
   3306c:	46d1      	mov	r9, sl
   3306e:	f7fc ffd3 	bl	30018 <memmove>
   33072:	463c      	mov	r4, r7
   33074:	e711      	b.n	32e9a <_realloc_r+0x142>
   33076:	463b      	mov	r3, r7
   33078:	e706      	b.n	32e88 <_realloc_r+0x130>
   3307a:	4621      	mov	r1, r4
   3307c:	4638      	mov	r0, r7
   3307e:	4666      	mov	r6, ip
   33080:	46d1      	mov	r9, sl
   33082:	f7fc ffc9 	bl	30018 <memmove>
   33086:	463c      	mov	r4, r7
   33088:	e707      	b.n	32e9a <_realloc_r+0x142>
   3308a:	68a1      	ldr	r1, [r4, #8]
   3308c:	f8ca 1010 	str.w	r1, [sl, #16]
   33090:	68e1      	ldr	r1, [r4, #12]
   33092:	f8ca 1014 	str.w	r1, [sl, #20]
   33096:	2a24      	cmp	r2, #36	; 0x24
   33098:	d022      	beq.n	330e0 <_realloc_r+0x388>
   3309a:	3410      	adds	r4, #16
   3309c:	f10a 0218 	add.w	r2, sl, #24
   330a0:	e7c6      	b.n	33030 <_realloc_r+0x2d8>
   330a2:	6923      	ldr	r3, [r4, #16]
   330a4:	6103      	str	r3, [r0, #16]
   330a6:	6963      	ldr	r3, [r4, #20]
   330a8:	6143      	str	r3, [r0, #20]
   330aa:	f104 0218 	add.w	r2, r4, #24
   330ae:	f100 0318 	add.w	r3, r0, #24
   330b2:	e6af      	b.n	32e14 <_realloc_r+0xbc>
   330b4:	10003208 	.word	0x10003208
   330b8:	68a3      	ldr	r3, [r4, #8]
   330ba:	f8ca 3010 	str.w	r3, [sl, #16]
   330be:	68e3      	ldr	r3, [r4, #12]
   330c0:	f8ca 3014 	str.w	r3, [sl, #20]
   330c4:	2a24      	cmp	r2, #36	; 0x24
   330c6:	d021      	beq.n	3310c <_realloc_r+0x3b4>
   330c8:	3410      	adds	r4, #16
   330ca:	f10a 0318 	add.w	r3, sl, #24
   330ce:	e6db      	b.n	32e88 <_realloc_r+0x130>
   330d0:	463a      	mov	r2, r7
   330d2:	e752      	b.n	32f7a <_realloc_r+0x222>
   330d4:	4621      	mov	r1, r4
   330d6:	4638      	mov	r0, r7
   330d8:	f7fc ff9e 	bl	30018 <memmove>
   330dc:	4b15      	ldr	r3, [pc, #84]	; (33134 <_realloc_r+0x3dc>)
   330de:	e752      	b.n	32f86 <_realloc_r+0x22e>
   330e0:	6922      	ldr	r2, [r4, #16]
   330e2:	f8ca 2018 	str.w	r2, [sl, #24]
   330e6:	6962      	ldr	r2, [r4, #20]
   330e8:	f8ca 201c 	str.w	r2, [sl, #28]
   330ec:	3418      	adds	r4, #24
   330ee:	f10a 0220 	add.w	r2, sl, #32
   330f2:	e79d      	b.n	33030 <_realloc_r+0x2d8>
   330f4:	68a1      	ldr	r1, [r4, #8]
   330f6:	f8ca 1010 	str.w	r1, [sl, #16]
   330fa:	68e1      	ldr	r1, [r4, #12]
   330fc:	f8ca 1014 	str.w	r1, [sl, #20]
   33100:	2a24      	cmp	r2, #36	; 0x24
   33102:	d00d      	beq.n	33120 <_realloc_r+0x3c8>
   33104:	3410      	adds	r4, #16
   33106:	f10a 0218 	add.w	r2, sl, #24
   3310a:	e736      	b.n	32f7a <_realloc_r+0x222>
   3310c:	6923      	ldr	r3, [r4, #16]
   3310e:	f8ca 3018 	str.w	r3, [sl, #24]
   33112:	6963      	ldr	r3, [r4, #20]
   33114:	f8ca 301c 	str.w	r3, [sl, #28]
   33118:	3418      	adds	r4, #24
   3311a:	f10a 0320 	add.w	r3, sl, #32
   3311e:	e6b3      	b.n	32e88 <_realloc_r+0x130>
   33120:	6922      	ldr	r2, [r4, #16]
   33122:	f8ca 2018 	str.w	r2, [sl, #24]
   33126:	6962      	ldr	r2, [r4, #20]
   33128:	f8ca 201c 	str.w	r2, [sl, #28]
   3312c:	3418      	adds	r4, #24
   3312e:	f10a 0220 	add.w	r2, sl, #32
   33132:	e722      	b.n	32f7a <_realloc_r+0x222>
   33134:	10003208 	.word	0x10003208

00033138 <__sccl>:
   33138:	b4f0      	push	{r4, r5, r6, r7}
   3313a:	780d      	ldrb	r5, [r1, #0]
   3313c:	2d5e      	cmp	r5, #94	; 0x5e
   3313e:	4604      	mov	r4, r0
   33140:	d021      	beq.n	33186 <__sccl+0x4e>
   33142:	2200      	movs	r2, #0
   33144:	1c48      	adds	r0, r1, #1
   33146:	4616      	mov	r6, r2
   33148:	1e63      	subs	r3, r4, #1
   3314a:	f104 01ff 	add.w	r1, r4, #255	; 0xff
   3314e:	f803 2f01 	strb.w	r2, [r3, #1]!
   33152:	428b      	cmp	r3, r1
   33154:	d1fb      	bne.n	3314e <__sccl+0x16>
   33156:	b19d      	cbz	r5, 33180 <__sccl+0x48>
   33158:	f086 0201 	eor.w	r2, r6, #1
   3315c:	43e7      	mvns	r7, r4
   3315e:	5562      	strb	r2, [r4, r5]
   33160:	1c41      	adds	r1, r0, #1
   33162:	f811 3c01 	ldrb.w	r3, [r1, #-1]
   33166:	2b2d      	cmp	r3, #45	; 0x2d
   33168:	f101 36ff 	add.w	r6, r1, #4294967295	; 0xffffffff
   3316c:	4608      	mov	r0, r1
   3316e:	d00f      	beq.n	33190 <__sccl+0x58>
   33170:	2b5d      	cmp	r3, #93	; 0x5d
   33172:	d003      	beq.n	3317c <__sccl+0x44>
   33174:	b10b      	cbz	r3, 3317a <__sccl+0x42>
   33176:	461d      	mov	r5, r3
   33178:	e7f1      	b.n	3315e <__sccl+0x26>
   3317a:	4630      	mov	r0, r6
   3317c:	bcf0      	pop	{r4, r5, r6, r7}
   3317e:	4770      	bx	lr
   33180:	3801      	subs	r0, #1
   33182:	bcf0      	pop	{r4, r5, r6, r7}
   33184:	4770      	bx	lr
   33186:	2201      	movs	r2, #1
   33188:	784d      	ldrb	r5, [r1, #1]
   3318a:	4616      	mov	r6, r2
   3318c:	1c88      	adds	r0, r1, #2
   3318e:	e7db      	b.n	33148 <__sccl+0x10>
   33190:	780e      	ldrb	r6, [r1, #0]
   33192:	2e5d      	cmp	r6, #93	; 0x5d
   33194:	d0ef      	beq.n	33176 <__sccl+0x3e>
   33196:	42b5      	cmp	r5, r6
   33198:	dced      	bgt.n	33176 <__sccl+0x3e>
   3319a:	f105 0c01 	add.w	ip, r5, #1
   3319e:	eb04 030c 	add.w	r3, r4, ip
   331a2:	f803 2b01 	strb.w	r2, [r3], #1
   331a6:	18f8      	adds	r0, r7, r3
   331a8:	4286      	cmp	r6, r0
   331aa:	dcfa      	bgt.n	331a2 <__sccl+0x6a>
   331ac:	43eb      	mvns	r3, r5
   331ae:	4433      	add	r3, r6
   331b0:	42b5      	cmp	r5, r6
   331b2:	bfa8      	it	ge
   331b4:	2300      	movge	r3, #0
   331b6:	3102      	adds	r1, #2
   331b8:	eb03 050c 	add.w	r5, r3, ip
   331bc:	e7d1      	b.n	33162 <__sccl+0x2a>
   331be:	bf00      	nop

000331c0 <_strtol_l.isra.0>:
   331c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   331c4:	4f40      	ldr	r7, [pc, #256]	; (332c8 <_strtol_l.isra.0+0x108>)
   331c6:	4681      	mov	r9, r0
   331c8:	460d      	mov	r5, r1
   331ca:	4628      	mov	r0, r5
   331cc:	f815 4b01 	ldrb.w	r4, [r5], #1
   331d0:	5d3e      	ldrb	r6, [r7, r4]
   331d2:	f016 0608 	ands.w	r6, r6, #8
   331d6:	d1f8      	bne.n	331ca <_strtol_l.isra.0+0xa>
   331d8:	2c2d      	cmp	r4, #45	; 0x2d
   331da:	d04f      	beq.n	3327c <_strtol_l.isra.0+0xbc>
   331dc:	2c2b      	cmp	r4, #43	; 0x2b
   331de:	bf0a      	itet	eq
   331e0:	f895 b000 	ldrbeq.w	fp, [r5]
   331e4:	46a3      	movne	fp, r4
   331e6:	1c85      	addeq	r5, r0, #2
   331e8:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
   331ec:	b11b      	cbz	r3, 331f6 <_strtol_l.isra.0+0x36>
   331ee:	2b10      	cmp	r3, #16
   331f0:	d04b      	beq.n	3328a <_strtol_l.isra.0+0xca>
   331f2:	469e      	mov	lr, r3
   331f4:	e004      	b.n	33200 <_strtol_l.isra.0+0x40>
   331f6:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
   331fa:	d050      	beq.n	3329e <_strtol_l.isra.0+0xde>
   331fc:	230a      	movs	r3, #10
   331fe:	469e      	mov	lr, r3
   33200:	2700      	movs	r7, #0
   33202:	fbb8 fcfe 	udiv	ip, r8, lr
   33206:	4638      	mov	r0, r7
   33208:	fb0e 8a1c 	mls	sl, lr, ip, r8
   3320c:	e005      	b.n	3321a <_strtol_l.isra.0+0x5a>
   3320e:	d029      	beq.n	33264 <_strtol_l.isra.0+0xa4>
   33210:	fb0e 4000 	mla	r0, lr, r0, r4
   33214:	2701      	movs	r7, #1
   33216:	f815 bb01 	ldrb.w	fp, [r5], #1
   3321a:	f1ab 0430 	sub.w	r4, fp, #48	; 0x30
   3321e:	2c09      	cmp	r4, #9
   33220:	d905      	bls.n	3322e <_strtol_l.isra.0+0x6e>
   33222:	f1ab 0441 	sub.w	r4, fp, #65	; 0x41
   33226:	2c19      	cmp	r4, #25
   33228:	d80b      	bhi.n	33242 <_strtol_l.isra.0+0x82>
   3322a:	f1ab 0437 	sub.w	r4, fp, #55	; 0x37
   3322e:	42a3      	cmp	r3, r4
   33230:	dd0f      	ble.n	33252 <_strtol_l.isra.0+0x92>
   33232:	f1b7 3fff 	cmp.w	r7, #4294967295	; 0xffffffff
   33236:	d0ee      	beq.n	33216 <_strtol_l.isra.0+0x56>
   33238:	4584      	cmp	ip, r0
   3323a:	d2e8      	bcs.n	3320e <_strtol_l.isra.0+0x4e>
   3323c:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   33240:	e7e9      	b.n	33216 <_strtol_l.isra.0+0x56>
   33242:	f1ab 0461 	sub.w	r4, fp, #97	; 0x61
   33246:	2c19      	cmp	r4, #25
   33248:	d803      	bhi.n	33252 <_strtol_l.isra.0+0x92>
   3324a:	f1ab 0457 	sub.w	r4, fp, #87	; 0x57
   3324e:	42a3      	cmp	r3, r4
   33250:	dcef      	bgt.n	33232 <_strtol_l.isra.0+0x72>
   33252:	1c7b      	adds	r3, r7, #1
   33254:	d00b      	beq.n	3326e <_strtol_l.isra.0+0xae>
   33256:	b106      	cbz	r6, 3325a <_strtol_l.isra.0+0x9a>
   33258:	4240      	negs	r0, r0
   3325a:	b10a      	cbz	r2, 33260 <_strtol_l.isra.0+0xa0>
   3325c:	bb77      	cbnz	r7, 332bc <_strtol_l.isra.0+0xfc>
   3325e:	6011      	str	r1, [r2, #0]
   33260:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33264:	45a2      	cmp	sl, r4
   33266:	dad3      	bge.n	33210 <_strtol_l.isra.0+0x50>
   33268:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   3326c:	e7d3      	b.n	33216 <_strtol_l.isra.0+0x56>
   3326e:	2322      	movs	r3, #34	; 0x22
   33270:	f8c9 3000 	str.w	r3, [r9]
   33274:	b1fa      	cbz	r2, 332b6 <_strtol_l.isra.0+0xf6>
   33276:	1e69      	subs	r1, r5, #1
   33278:	4640      	mov	r0, r8
   3327a:	e7f0      	b.n	3325e <_strtol_l.isra.0+0x9e>
   3327c:	f895 b000 	ldrb.w	fp, [r5]
   33280:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
   33284:	1c85      	adds	r5, r0, #2
   33286:	2601      	movs	r6, #1
   33288:	e7b0      	b.n	331ec <_strtol_l.isra.0+0x2c>
   3328a:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
   3328e:	d1b0      	bne.n	331f2 <_strtol_l.isra.0+0x32>
   33290:	7828      	ldrb	r0, [r5, #0]
   33292:	f000 00df 	and.w	r0, r0, #223	; 0xdf
   33296:	2858      	cmp	r0, #88	; 0x58
   33298:	d006      	beq.n	332a8 <_strtol_l.isra.0+0xe8>
   3329a:	469e      	mov	lr, r3
   3329c:	e7b0      	b.n	33200 <_strtol_l.isra.0+0x40>
   3329e:	782b      	ldrb	r3, [r5, #0]
   332a0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   332a4:	2b58      	cmp	r3, #88	; 0x58
   332a6:	d10b      	bne.n	332c0 <_strtol_l.isra.0+0x100>
   332a8:	f04f 0e10 	mov.w	lr, #16
   332ac:	f895 b001 	ldrb.w	fp, [r5, #1]
   332b0:	4673      	mov	r3, lr
   332b2:	3502      	adds	r5, #2
   332b4:	e7a4      	b.n	33200 <_strtol_l.isra.0+0x40>
   332b6:	4640      	mov	r0, r8
   332b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   332bc:	4680      	mov	r8, r0
   332be:	e7da      	b.n	33276 <_strtol_l.isra.0+0xb6>
   332c0:	2308      	movs	r3, #8
   332c2:	469e      	mov	lr, r3
   332c4:	e79c      	b.n	33200 <_strtol_l.isra.0+0x40>
   332c6:	bf00      	nop
   332c8:	000466c9 	.word	0x000466c9

000332cc <_strtol_r>:
   332cc:	f7ff bf78 	b.w	331c0 <_strtol_l.isra.0>

000332d0 <_strtoll_l.isra.0>:
   332d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   332d4:	b087      	sub	sp, #28
   332d6:	460f      	mov	r7, r1
   332d8:	495b      	ldr	r1, [pc, #364]	; (33448 <_strtoll_l.isra.0+0x178>)
   332da:	9005      	str	r0, [sp, #20]
   332dc:	9201      	str	r2, [sp, #4]
   332de:	461e      	mov	r6, r3
   332e0:	463d      	mov	r5, r7
   332e2:	462a      	mov	r2, r5
   332e4:	f815 4b01 	ldrb.w	r4, [r5], #1
   332e8:	5d0b      	ldrb	r3, [r1, r4]
   332ea:	f013 0308 	ands.w	r3, r3, #8
   332ee:	d1f8      	bne.n	332e2 <_strtoll_l.isra.0+0x12>
   332f0:	2c2d      	cmp	r4, #45	; 0x2d
   332f2:	d078      	beq.n	333e6 <_strtoll_l.isra.0+0x116>
   332f4:	2c2b      	cmp	r4, #43	; 0x2b
   332f6:	d03d      	beq.n	33374 <_strtoll_l.isra.0+0xa4>
   332f8:	9304      	str	r3, [sp, #16]
   332fa:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
   332fe:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   33302:	e9cd e302 	strd	lr, r3, [sp, #8]
   33306:	2e00      	cmp	r6, #0
   33308:	d03f      	beq.n	3338a <_strtoll_l.isra.0+0xba>
   3330a:	2e10      	cmp	r6, #16
   3330c:	d075      	beq.n	333fa <_strtoll_l.isra.0+0x12a>
   3330e:	46b0      	mov	r8, r6
   33310:	ea4f 79e6 	mov.w	r9, r6, asr #31
   33314:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   33318:	4642      	mov	r2, r8
   3331a:	464b      	mov	r3, r9
   3331c:	f7e5 face 	bl	188bc <__aeabi_uldivmod>
   33320:	2300      	movs	r3, #0
   33322:	4682      	mov	sl, r0
   33324:	468b      	mov	fp, r1
   33326:	4694      	mov	ip, r2
   33328:	2000      	movs	r0, #0
   3332a:	2100      	movs	r1, #0
   3332c:	e00d      	b.n	3334a <_strtoll_l.isra.0+0x7a>
   3332e:	d04c      	beq.n	333ca <_strtoll_l.isra.0+0xfa>
   33330:	fb00 f309 	mul.w	r3, r0, r9
   33334:	fb08 3301 	mla	r3, r8, r1, r3
   33338:	fba0 0108 	umull	r0, r1, r0, r8
   3333c:	4419      	add	r1, r3
   3333e:	1880      	adds	r0, r0, r2
   33340:	eb41 71e2 	adc.w	r1, r1, r2, asr #31
   33344:	2301      	movs	r3, #1
   33346:	f815 4b01 	ldrb.w	r4, [r5], #1
   3334a:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
   3334e:	2a09      	cmp	r2, #9
   33350:	d905      	bls.n	3335e <_strtoll_l.isra.0+0x8e>
   33352:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
   33356:	2a19      	cmp	r2, #25
   33358:	d81f      	bhi.n	3339a <_strtoll_l.isra.0+0xca>
   3335a:	f1a4 0237 	sub.w	r2, r4, #55	; 0x37
   3335e:	4296      	cmp	r6, r2
   33360:	dd23      	ble.n	333aa <_strtoll_l.isra.0+0xda>
   33362:	1c5c      	adds	r4, r3, #1
   33364:	d0ef      	beq.n	33346 <_strtoll_l.isra.0+0x76>
   33366:	458b      	cmp	fp, r1
   33368:	bf08      	it	eq
   3336a:	4582      	cmpeq	sl, r0
   3336c:	d2df      	bcs.n	3332e <_strtoll_l.isra.0+0x5e>
   3336e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   33372:	e7e8      	b.n	33346 <_strtoll_l.isra.0+0x76>
   33374:	9304      	str	r3, [sp, #16]
   33376:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   3337a:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
   3337e:	782c      	ldrb	r4, [r5, #0]
   33380:	e9cd c302 	strd	ip, r3, [sp, #8]
   33384:	1c95      	adds	r5, r2, #2
   33386:	2e00      	cmp	r6, #0
   33388:	d1bf      	bne.n	3330a <_strtoll_l.isra.0+0x3a>
   3338a:	2c30      	cmp	r4, #48	; 0x30
   3338c:	d049      	beq.n	33422 <_strtoll_l.isra.0+0x152>
   3338e:	f04f 080a 	mov.w	r8, #10
   33392:	f04f 0900 	mov.w	r9, #0
   33396:	260a      	movs	r6, #10
   33398:	e7bc      	b.n	33314 <_strtoll_l.isra.0+0x44>
   3339a:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
   3339e:	2a19      	cmp	r2, #25
   333a0:	d803      	bhi.n	333aa <_strtoll_l.isra.0+0xda>
   333a2:	f1a4 0257 	sub.w	r2, r4, #87	; 0x57
   333a6:	4296      	cmp	r6, r2
   333a8:	dcdb      	bgt.n	33362 <_strtoll_l.isra.0+0x92>
   333aa:	1c5a      	adds	r2, r3, #1
   333ac:	d012      	beq.n	333d4 <_strtoll_l.isra.0+0x104>
   333ae:	9a04      	ldr	r2, [sp, #16]
   333b0:	b112      	cbz	r2, 333b8 <_strtoll_l.isra.0+0xe8>
   333b2:	4240      	negs	r0, r0
   333b4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   333b8:	9a01      	ldr	r2, [sp, #4]
   333ba:	b11a      	cbz	r2, 333c4 <_strtoll_l.isra.0+0xf4>
   333bc:	2b00      	cmp	r3, #0
   333be:	d140      	bne.n	33442 <_strtoll_l.isra.0+0x172>
   333c0:	9b01      	ldr	r3, [sp, #4]
   333c2:	601f      	str	r7, [r3, #0]
   333c4:	b007      	add	sp, #28
   333c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   333ca:	4594      	cmp	ip, r2
   333cc:	dab0      	bge.n	33330 <_strtoll_l.isra.0+0x60>
   333ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   333d2:	e7b8      	b.n	33346 <_strtoll_l.isra.0+0x76>
   333d4:	9a05      	ldr	r2, [sp, #20]
   333d6:	2322      	movs	r3, #34	; 0x22
   333d8:	6013      	str	r3, [r2, #0]
   333da:	9b01      	ldr	r3, [sp, #4]
   333dc:	b363      	cbz	r3, 33438 <_strtoll_l.isra.0+0x168>
   333de:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   333e2:	1e6f      	subs	r7, r5, #1
   333e4:	e7ec      	b.n	333c0 <_strtoll_l.isra.0+0xf0>
   333e6:	2300      	movs	r3, #0
   333e8:	9302      	str	r3, [sp, #8]
   333ea:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
   333ee:	2301      	movs	r3, #1
   333f0:	782c      	ldrb	r4, [r5, #0]
   333f2:	e9cd 8303 	strd	r8, r3, [sp, #12]
   333f6:	1c95      	adds	r5, r2, #2
   333f8:	e785      	b.n	33306 <_strtoll_l.isra.0+0x36>
   333fa:	2c30      	cmp	r4, #48	; 0x30
   333fc:	d104      	bne.n	33408 <_strtoll_l.isra.0+0x138>
   333fe:	782b      	ldrb	r3, [r5, #0]
   33400:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   33404:	2b58      	cmp	r3, #88	; 0x58
   33406:	d004      	beq.n	33412 <_strtoll_l.isra.0+0x142>
   33408:	f04f 0810 	mov.w	r8, #16
   3340c:	f04f 0900 	mov.w	r9, #0
   33410:	e780      	b.n	33314 <_strtoll_l.isra.0+0x44>
   33412:	786c      	ldrb	r4, [r5, #1]
   33414:	f04f 0810 	mov.w	r8, #16
   33418:	f04f 0900 	mov.w	r9, #0
   3341c:	3502      	adds	r5, #2
   3341e:	2610      	movs	r6, #16
   33420:	e778      	b.n	33314 <_strtoll_l.isra.0+0x44>
   33422:	782b      	ldrb	r3, [r5, #0]
   33424:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   33428:	2b58      	cmp	r3, #88	; 0x58
   3342a:	d0f2      	beq.n	33412 <_strtoll_l.isra.0+0x142>
   3342c:	f04f 0808 	mov.w	r8, #8
   33430:	f04f 0900 	mov.w	r9, #0
   33434:	2608      	movs	r6, #8
   33436:	e76d      	b.n	33314 <_strtoll_l.isra.0+0x44>
   33438:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
   3343c:	b007      	add	sp, #28
   3343e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33442:	e9cd 0102 	strd	r0, r1, [sp, #8]
   33446:	e7ca      	b.n	333de <_strtoll_l.isra.0+0x10e>
   33448:	000466c9 	.word	0x000466c9

0003344c <_strtoll_r>:
   3344c:	f7ff bf40 	b.w	332d0 <_strtoll_l.isra.0>

00033450 <_strtoull_l.isra.0>:
   33450:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   33454:	b085      	sub	sp, #20
   33456:	468b      	mov	fp, r1
   33458:	4969      	ldr	r1, [pc, #420]	; (33600 <_strtoull_l.isra.0+0x1b0>)
   3345a:	9003      	str	r0, [sp, #12]
   3345c:	9201      	str	r2, [sp, #4]
   3345e:	469a      	mov	sl, r3
   33460:	465d      	mov	r5, fp
   33462:	462a      	mov	r2, r5
   33464:	f815 4b01 	ldrb.w	r4, [r5], #1
   33468:	5d0b      	ldrb	r3, [r1, r4]
   3346a:	f013 0308 	ands.w	r3, r3, #8
   3346e:	d1f8      	bne.n	33462 <_strtoull_l.isra.0+0x12>
   33470:	2c2d      	cmp	r4, #45	; 0x2d
   33472:	f000 808a 	beq.w	3358a <_strtoull_l.isra.0+0x13a>
   33476:	2c2b      	cmp	r4, #43	; 0x2b
   33478:	bf09      	itett	eq
   3347a:	782c      	ldrbeq	r4, [r5, #0]
   3347c:	9302      	strne	r3, [sp, #8]
   3347e:	9302      	streq	r3, [sp, #8]
   33480:	1c95      	addeq	r5, r2, #2
   33482:	f1ba 0f00 	cmp.w	sl, #0
   33486:	d01a      	beq.n	334be <_strtoull_l.isra.0+0x6e>
   33488:	f1ba 0f10 	cmp.w	sl, #16
   3348c:	f000 8082 	beq.w	33594 <_strtoull_l.isra.0+0x144>
   33490:	46d0      	mov	r8, sl
   33492:	ea4f 79ea 	mov.w	r9, sl, asr #31
   33496:	4642      	mov	r2, r8
   33498:	464b      	mov	r3, r9
   3349a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3349e:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   334a2:	f7e5 fa0b 	bl	188bc <__aeabi_uldivmod>
   334a6:	4642      	mov	r2, r8
   334a8:	468c      	mov	ip, r1
   334aa:	4606      	mov	r6, r0
   334ac:	464b      	mov	r3, r9
   334ae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   334b2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   334b6:	4667      	mov	r7, ip
   334b8:	f7e5 fa00 	bl	188bc <__aeabi_uldivmod>
   334bc:	e00b      	b.n	334d6 <_strtoull_l.isra.0+0x86>
   334be:	2c30      	cmp	r4, #48	; 0x30
   334c0:	d07d      	beq.n	335be <_strtoull_l.isra.0+0x16e>
   334c2:	4f50      	ldr	r7, [pc, #320]	; (33604 <_strtoull_l.isra.0+0x1b4>)
   334c4:	2205      	movs	r2, #5
   334c6:	f04f 3699 	mov.w	r6, #2576980377	; 0x99999999
   334ca:	f04f 080a 	mov.w	r8, #10
   334ce:	f04f 0900 	mov.w	r9, #0
   334d2:	f04f 0a0a 	mov.w	sl, #10
   334d6:	f04f 0c00 	mov.w	ip, #0
   334da:	2000      	movs	r0, #0
   334dc:	2100      	movs	r1, #0
   334de:	e015      	b.n	3350c <_strtoull_l.isra.0+0xbc>
   334e0:	428f      	cmp	r7, r1
   334e2:	bf08      	it	eq
   334e4:	4286      	cmpeq	r6, r0
   334e6:	d320      	bcc.n	3352a <_strtoull_l.isra.0+0xda>
   334e8:	42b9      	cmp	r1, r7
   334ea:	bf08      	it	eq
   334ec:	42b0      	cmpeq	r0, r6
   334ee:	d03a      	beq.n	33566 <_strtoull_l.isra.0+0x116>
   334f0:	fb00 f409 	mul.w	r4, r0, r9
   334f4:	fb08 4401 	mla	r4, r8, r1, r4
   334f8:	fba0 0108 	umull	r0, r1, r0, r8
   334fc:	4421      	add	r1, r4
   334fe:	18c0      	adds	r0, r0, r3
   33500:	eb41 71e3 	adc.w	r1, r1, r3, asr #31
   33504:	f04f 0c01 	mov.w	ip, #1
   33508:	f815 4b01 	ldrb.w	r4, [r5], #1
   3350c:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
   33510:	2b09      	cmp	r3, #9
   33512:	d905      	bls.n	33520 <_strtoull_l.isra.0+0xd0>
   33514:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
   33518:	2b19      	cmp	r3, #25
   3351a:	d809      	bhi.n	33530 <_strtoull_l.isra.0+0xe0>
   3351c:	f1a4 0337 	sub.w	r3, r4, #55	; 0x37
   33520:	459a      	cmp	sl, r3
   33522:	dd0d      	ble.n	33540 <_strtoull_l.isra.0+0xf0>
   33524:	f1bc 0f00 	cmp.w	ip, #0
   33528:	dada      	bge.n	334e0 <_strtoull_l.isra.0+0x90>
   3352a:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   3352e:	e7eb      	b.n	33508 <_strtoull_l.isra.0+0xb8>
   33530:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
   33534:	2b19      	cmp	r3, #25
   33536:	d803      	bhi.n	33540 <_strtoull_l.isra.0+0xf0>
   33538:	f1a4 0357 	sub.w	r3, r4, #87	; 0x57
   3353c:	459a      	cmp	sl, r3
   3353e:	dcf1      	bgt.n	33524 <_strtoull_l.isra.0+0xd4>
   33540:	f1bc 0f00 	cmp.w	ip, #0
   33544:	db14      	blt.n	33570 <_strtoull_l.isra.0+0x120>
   33546:	9b02      	ldr	r3, [sp, #8]
   33548:	b113      	cbz	r3, 33550 <_strtoull_l.isra.0+0x100>
   3354a:	4240      	negs	r0, r0
   3354c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   33550:	9b01      	ldr	r3, [sp, #4]
   33552:	b12b      	cbz	r3, 33560 <_strtoull_l.isra.0+0x110>
   33554:	f1bc 0f00 	cmp.w	ip, #0
   33558:	d114      	bne.n	33584 <_strtoull_l.isra.0+0x134>
   3355a:	9b01      	ldr	r3, [sp, #4]
   3355c:	f8c3 b000 	str.w	fp, [r3]
   33560:	b005      	add	sp, #20
   33562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   33566:	4293      	cmp	r3, r2
   33568:	ddc2      	ble.n	334f0 <_strtoull_l.isra.0+0xa0>
   3356a:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
   3356e:	e7cb      	b.n	33508 <_strtoull_l.isra.0+0xb8>
   33570:	9a03      	ldr	r2, [sp, #12]
   33572:	2322      	movs	r3, #34	; 0x22
   33574:	6013      	str	r3, [r2, #0]
   33576:	9b01      	ldr	r3, [sp, #4]
   33578:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3357c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   33580:	2b00      	cmp	r3, #0
   33582:	d0ed      	beq.n	33560 <_strtoull_l.isra.0+0x110>
   33584:	f105 3bff 	add.w	fp, r5, #4294967295	; 0xffffffff
   33588:	e7e7      	b.n	3355a <_strtoull_l.isra.0+0x10a>
   3358a:	2301      	movs	r3, #1
   3358c:	782c      	ldrb	r4, [r5, #0]
   3358e:	9302      	str	r3, [sp, #8]
   33590:	1c95      	adds	r5, r2, #2
   33592:	e776      	b.n	33482 <_strtoull_l.isra.0+0x32>
   33594:	2c30      	cmp	r4, #48	; 0x30
   33596:	d128      	bne.n	335ea <_strtoull_l.isra.0+0x19a>
   33598:	782b      	ldrb	r3, [r5, #0]
   3359a:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   3359e:	2b58      	cmp	r3, #88	; 0x58
   335a0:	d11e      	bne.n	335e0 <_strtoull_l.isra.0+0x190>
   335a2:	786c      	ldrb	r4, [r5, #1]
   335a4:	220f      	movs	r2, #15
   335a6:	3502      	adds	r5, #2
   335a8:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   335ac:	f06f 4770 	mvn.w	r7, #4026531840	; 0xf0000000
   335b0:	f04f 0810 	mov.w	r8, #16
   335b4:	f04f 0900 	mov.w	r9, #0
   335b8:	f04f 0a10 	mov.w	sl, #16
   335bc:	e78b      	b.n	334d6 <_strtoull_l.isra.0+0x86>
   335be:	782b      	ldrb	r3, [r5, #0]
   335c0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
   335c4:	2b58      	cmp	r3, #88	; 0x58
   335c6:	d0ec      	beq.n	335a2 <_strtoull_l.isra.0+0x152>
   335c8:	2207      	movs	r2, #7
   335ca:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   335ce:	f06f 4760 	mvn.w	r7, #3758096384	; 0xe0000000
   335d2:	f04f 0808 	mov.w	r8, #8
   335d6:	f04f 0900 	mov.w	r9, #0
   335da:	f04f 0a08 	mov.w	sl, #8
   335de:	e77a      	b.n	334d6 <_strtoull_l.isra.0+0x86>
   335e0:	f04f 0810 	mov.w	r8, #16
   335e4:	f04f 0900 	mov.w	r9, #0
   335e8:	e755      	b.n	33496 <_strtoull_l.isra.0+0x46>
   335ea:	220f      	movs	r2, #15
   335ec:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
   335f0:	f06f 4770 	mvn.w	r7, #4026531840	; 0xf0000000
   335f4:	f04f 0810 	mov.w	r8, #16
   335f8:	f04f 0900 	mov.w	r9, #0
   335fc:	e76b      	b.n	334d6 <_strtoull_l.isra.0+0x86>
   335fe:	bf00      	nop
   33600:	000466c9 	.word	0x000466c9
   33604:	19999999 	.word	0x19999999

00033608 <_strtoull_r>:
   33608:	f7ff bf22 	b.w	33450 <_strtoull_l.isra.0>

0003360c <__ascii_wctomb>:
   3360c:	b149      	cbz	r1, 33622 <__ascii_wctomb+0x16>
   3360e:	2aff      	cmp	r2, #255	; 0xff
   33610:	d802      	bhi.n	33618 <__ascii_wctomb+0xc>
   33612:	700a      	strb	r2, [r1, #0]
   33614:	2001      	movs	r0, #1
   33616:	4770      	bx	lr
   33618:	238a      	movs	r3, #138	; 0x8a
   3361a:	6003      	str	r3, [r0, #0]
   3361c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   33620:	4770      	bx	lr
   33622:	4608      	mov	r0, r1
   33624:	4770      	bx	lr
   33626:	bf00      	nop

00033628 <_sbrk>:
   33628:	4a04      	ldr	r2, [pc, #16]	; (3363c <_sbrk+0x14>)
   3362a:	4905      	ldr	r1, [pc, #20]	; (33640 <_sbrk+0x18>)
   3362c:	6813      	ldr	r3, [r2, #0]
   3362e:	2b00      	cmp	r3, #0
   33630:	bf08      	it	eq
   33632:	460b      	moveq	r3, r1
   33634:	4418      	add	r0, r3
   33636:	6010      	str	r0, [r2, #0]
   33638:	4618      	mov	r0, r3
   3363a:	4770      	bx	lr
   3363c:	1000bed8 	.word	0x1000bed8
   33640:	10002b00 	.word	0x10002b00

00033644 <am_bsp_itm_printf_enable>:
   33644:	4b18      	ldr	r3, [pc, #96]	; (336a8 <am_bsp_itm_printf_enable+0x64>)
   33646:	689b      	ldr	r3, [r3, #8]
   33648:	02da      	lsls	r2, r3, #11
   3364a:	d529      	bpl.n	336a0 <am_bsp_itm_printf_enable+0x5c>
   3364c:	b510      	push	{r4, lr}
   3364e:	4b17      	ldr	r3, [pc, #92]	; (336ac <am_bsp_itm_printf_enable+0x68>)
   33650:	f8d3 4a7c 	ldr.w	r4, [r3, #2684]	; 0xa7c
   33654:	f014 0401 	ands.w	r4, r4, #1
   33658:	b082      	sub	sp, #8
   3365a:	d01e      	beq.n	3369a <am_bsp_itm_printf_enable+0x56>
   3365c:	a801      	add	r0, sp, #4
   3365e:	f002 f9cb 	bl	359f8 <am_hal_dcu_get>
   33662:	9b01      	ldr	r3, [sp, #4]
   33664:	06db      	lsls	r3, r3, #27
   33666:	d512      	bpl.n	3368e <am_bsp_itm_printf_enable+0x4a>
   33668:	4b11      	ldr	r3, [pc, #68]	; (336b0 <am_bsp_itm_printf_enable+0x6c>)
   3366a:	2201      	movs	r2, #1
   3366c:	701a      	strb	r2, [r3, #0]
   3366e:	f001 f98b 	bl	34988 <am_hal_itm_enable>
   33672:	4810      	ldr	r0, [pc, #64]	; (336b4 <am_bsp_itm_printf_enable+0x70>)
   33674:	f001 fdf2 	bl	3525c <am_hal_tpiu_enable>
   33678:	4b0f      	ldr	r3, [pc, #60]	; (336b8 <am_bsp_itm_printf_enable+0x74>)
   3367a:	201c      	movs	r0, #28
   3367c:	6819      	ldr	r1, [r3, #0]
   3367e:	f002 fa5b 	bl	35b38 <am_hal_gpio_pinconfig>
   33682:	480e      	ldr	r0, [pc, #56]	; (336bc <am_bsp_itm_printf_enable+0x78>)
   33684:	f7e6 fbe2 	bl	19e4c <am_util_stdio_printf_init>
   33688:	2000      	movs	r0, #0
   3368a:	b002      	add	sp, #8
   3368c:	bd10      	pop	{r4, pc}
   3368e:	2110      	movs	r1, #16
   33690:	4620      	mov	r0, r4
   33692:	f002 f9f9 	bl	35a88 <am_hal_dcu_update>
   33696:	2800      	cmp	r0, #0
   33698:	d0e6      	beq.n	33668 <am_bsp_itm_printf_enable+0x24>
   3369a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3369e:	e7f4      	b.n	3368a <am_bsp_itm_printf_enable+0x46>
   336a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   336a4:	4770      	bx	lr
   336a6:	bf00      	nop
   336a8:	40021000 	.word	0x40021000
   336ac:	400c0000 	.word	0x400c0000
   336b0:	1000bedc 	.word	0x1000bedc
   336b4:	000f4240 	.word	0x000f4240
   336b8:	10003824 	.word	0x10003824
   336bc:	000349d1 	.word	0x000349d1

000336c0 <am_bsp_iom_pins_enable>:
   336c0:	2807      	cmp	r0, #7
   336c2:	d825      	bhi.n	33710 <am_bsp_iom_pins_enable+0x50>
   336c4:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
   336c8:	b508      	push	{r3, lr}
   336ca:	291d      	cmp	r1, #29
   336cc:	d81f      	bhi.n	3370e <am_bsp_iom_pins_enable+0x4e>
   336ce:	e8df f011 	tbh	[pc, r1, lsl #1]
   336d2:	010e      	.short	0x010e
   336d4:	001e0102 	.word	0x001e0102
   336d8:	00ec001e 	.word	0x00ec001e
   336dc:	001e00e0 	.word	0x001e00e0
   336e0:	00ca001e 	.word	0x00ca001e
   336e4:	001e00be 	.word	0x001e00be
   336e8:	00a8001e 	.word	0x00a8001e
   336ec:	001e009c 	.word	0x001e009c
   336f0:	0086001e 	.word	0x0086001e
   336f4:	001e001e 	.word	0x001e001e
   336f8:	0070001e 	.word	0x0070001e
   336fc:	001e0064 	.word	0x001e0064
   33700:	004e001e 	.word	0x004e001e
   33704:	001e0042 	.word	0x001e0042
   33708:	002c001e 	.word	0x002c001e
   3370c:	0020      	.short	0x0020
   3370e:	bd08      	pop	{r3, pc}
   33710:	4770      	bx	lr
   33712:	4b82      	ldr	r3, [pc, #520]	; (3391c <am_bsp_iom_pins_enable+0x25c>)
   33714:	2016      	movs	r0, #22
   33716:	6819      	ldr	r1, [r3, #0]
   33718:	f002 fa0e 	bl	35b38 <am_hal_gpio_pinconfig>
   3371c:	4b80      	ldr	r3, [pc, #512]	; (33920 <am_bsp_iom_pins_enable+0x260>)
   3371e:	2017      	movs	r0, #23
   33720:	6819      	ldr	r1, [r3, #0]
   33722:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33726:	f002 ba07 	b.w	35b38 <am_hal_gpio_pinconfig>
   3372a:	4b7e      	ldr	r3, [pc, #504]	; (33924 <am_bsp_iom_pins_enable+0x264>)
   3372c:	2016      	movs	r0, #22
   3372e:	6819      	ldr	r1, [r3, #0]
   33730:	f002 fa02 	bl	35b38 <am_hal_gpio_pinconfig>
   33734:	4b7c      	ldr	r3, [pc, #496]	; (33928 <am_bsp_iom_pins_enable+0x268>)
   33736:	2018      	movs	r0, #24
   33738:	6819      	ldr	r1, [r3, #0]
   3373a:	f002 f9fd 	bl	35b38 <am_hal_gpio_pinconfig>
   3373e:	4b7b      	ldr	r3, [pc, #492]	; (3392c <am_bsp_iom_pins_enable+0x26c>)
   33740:	2017      	movs	r0, #23
   33742:	6819      	ldr	r1, [r3, #0]
   33744:	f002 f9f8 	bl	35b38 <am_hal_gpio_pinconfig>
   33748:	4b79      	ldr	r3, [pc, #484]	; (33930 <am_bsp_iom_pins_enable+0x270>)
   3374a:	2058      	movs	r0, #88	; 0x58
   3374c:	6819      	ldr	r1, [r3, #0]
   3374e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33752:	f002 b9f1 	b.w	35b38 <am_hal_gpio_pinconfig>
   33756:	4b77      	ldr	r3, [pc, #476]	; (33934 <am_bsp_iom_pins_enable+0x274>)
   33758:	203d      	movs	r0, #61	; 0x3d
   3375a:	6819      	ldr	r1, [r3, #0]
   3375c:	f002 f9ec 	bl	35b38 <am_hal_gpio_pinconfig>
   33760:	4b75      	ldr	r3, [pc, #468]	; (33938 <am_bsp_iom_pins_enable+0x278>)
   33762:	203e      	movs	r0, #62	; 0x3e
   33764:	6819      	ldr	r1, [r3, #0]
   33766:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3376a:	f002 b9e5 	b.w	35b38 <am_hal_gpio_pinconfig>
   3376e:	4b73      	ldr	r3, [pc, #460]	; (3393c <am_bsp_iom_pins_enable+0x27c>)
   33770:	203d      	movs	r0, #61	; 0x3d
   33772:	6819      	ldr	r1, [r3, #0]
   33774:	f002 f9e0 	bl	35b38 <am_hal_gpio_pinconfig>
   33778:	4b71      	ldr	r3, [pc, #452]	; (33940 <am_bsp_iom_pins_enable+0x280>)
   3377a:	203f      	movs	r0, #63	; 0x3f
   3377c:	6819      	ldr	r1, [r3, #0]
   3377e:	f002 f9db 	bl	35b38 <am_hal_gpio_pinconfig>
   33782:	4b70      	ldr	r3, [pc, #448]	; (33944 <am_bsp_iom_pins_enable+0x284>)
   33784:	203e      	movs	r0, #62	; 0x3e
   33786:	6819      	ldr	r1, [r3, #0]
   33788:	f002 f9d6 	bl	35b38 <am_hal_gpio_pinconfig>
   3378c:	4b6e      	ldr	r3, [pc, #440]	; (33948 <am_bsp_iom_pins_enable+0x288>)
   3378e:	201e      	movs	r0, #30
   33790:	6819      	ldr	r1, [r3, #0]
   33792:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33796:	f002 b9cf 	b.w	35b38 <am_hal_gpio_pinconfig>
   3379a:	4b6c      	ldr	r3, [pc, #432]	; (3394c <am_bsp_iom_pins_enable+0x28c>)
   3379c:	202f      	movs	r0, #47	; 0x2f
   3379e:	6819      	ldr	r1, [r3, #0]
   337a0:	f002 f9ca 	bl	35b38 <am_hal_gpio_pinconfig>
   337a4:	4b6a      	ldr	r3, [pc, #424]	; (33950 <am_bsp_iom_pins_enable+0x290>)
   337a6:	2030      	movs	r0, #48	; 0x30
   337a8:	6819      	ldr	r1, [r3, #0]
   337aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   337ae:	f002 b9c3 	b.w	35b38 <am_hal_gpio_pinconfig>
   337b2:	4b68      	ldr	r3, [pc, #416]	; (33954 <am_bsp_iom_pins_enable+0x294>)
   337b4:	202f      	movs	r0, #47	; 0x2f
   337b6:	6819      	ldr	r1, [r3, #0]
   337b8:	f002 f9be 	bl	35b38 <am_hal_gpio_pinconfig>
   337bc:	4b66      	ldr	r3, [pc, #408]	; (33958 <am_bsp_iom_pins_enable+0x298>)
   337be:	2031      	movs	r0, #49	; 0x31
   337c0:	6819      	ldr	r1, [r3, #0]
   337c2:	f002 f9b9 	bl	35b38 <am_hal_gpio_pinconfig>
   337c6:	4b65      	ldr	r3, [pc, #404]	; (3395c <am_bsp_iom_pins_enable+0x29c>)
   337c8:	2030      	movs	r0, #48	; 0x30
   337ca:	6819      	ldr	r1, [r3, #0]
   337cc:	f002 f9b4 	bl	35b38 <am_hal_gpio_pinconfig>
   337d0:	4b63      	ldr	r3, [pc, #396]	; (33960 <am_bsp_iom_pins_enable+0x2a0>)
   337d2:	203c      	movs	r0, #60	; 0x3c
   337d4:	6819      	ldr	r1, [r3, #0]
   337d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   337da:	f002 b9ad 	b.w	35b38 <am_hal_gpio_pinconfig>
   337de:	4b61      	ldr	r3, [pc, #388]	; (33964 <am_bsp_iom_pins_enable+0x2a4>)
   337e0:	2022      	movs	r0, #34	; 0x22
   337e2:	6819      	ldr	r1, [r3, #0]
   337e4:	f002 f9a8 	bl	35b38 <am_hal_gpio_pinconfig>
   337e8:	4b5f      	ldr	r3, [pc, #380]	; (33968 <am_bsp_iom_pins_enable+0x2a8>)
   337ea:	2024      	movs	r0, #36	; 0x24
   337ec:	6819      	ldr	r1, [r3, #0]
   337ee:	f002 f9a3 	bl	35b38 <am_hal_gpio_pinconfig>
   337f2:	4b5e      	ldr	r3, [pc, #376]	; (3396c <am_bsp_iom_pins_enable+0x2ac>)
   337f4:	2023      	movs	r0, #35	; 0x23
   337f6:	6819      	ldr	r1, [r3, #0]
   337f8:	f002 f99e 	bl	35b38 <am_hal_gpio_pinconfig>
   337fc:	4b5c      	ldr	r3, [pc, #368]	; (33970 <am_bsp_iom_pins_enable+0x2b0>)
   337fe:	202b      	movs	r0, #43	; 0x2b
   33800:	6819      	ldr	r1, [r3, #0]
   33802:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33806:	f002 b997 	b.w	35b38 <am_hal_gpio_pinconfig>
   3380a:	4b5a      	ldr	r3, [pc, #360]	; (33974 <am_bsp_iom_pins_enable+0x2b4>)
   3380c:	201f      	movs	r0, #31
   3380e:	6819      	ldr	r1, [r3, #0]
   33810:	f002 f992 	bl	35b38 <am_hal_gpio_pinconfig>
   33814:	4b58      	ldr	r3, [pc, #352]	; (33978 <am_bsp_iom_pins_enable+0x2b8>)
   33816:	2020      	movs	r0, #32
   33818:	6819      	ldr	r1, [r3, #0]
   3381a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3381e:	f002 b98b 	b.w	35b38 <am_hal_gpio_pinconfig>
   33822:	4b56      	ldr	r3, [pc, #344]	; (3397c <am_bsp_iom_pins_enable+0x2bc>)
   33824:	201f      	movs	r0, #31
   33826:	6819      	ldr	r1, [r3, #0]
   33828:	f002 f986 	bl	35b38 <am_hal_gpio_pinconfig>
   3382c:	4b54      	ldr	r3, [pc, #336]	; (33980 <am_bsp_iom_pins_enable+0x2c0>)
   3382e:	2021      	movs	r0, #33	; 0x21
   33830:	6819      	ldr	r1, [r3, #0]
   33832:	f002 f981 	bl	35b38 <am_hal_gpio_pinconfig>
   33836:	4b53      	ldr	r3, [pc, #332]	; (33984 <am_bsp_iom_pins_enable+0x2c4>)
   33838:	2020      	movs	r0, #32
   3383a:	6819      	ldr	r1, [r3, #0]
   3383c:	f002 f97c 	bl	35b38 <am_hal_gpio_pinconfig>
   33840:	4b51      	ldr	r3, [pc, #324]	; (33988 <am_bsp_iom_pins_enable+0x2c8>)
   33842:	2055      	movs	r0, #85	; 0x55
   33844:	6819      	ldr	r1, [r3, #0]
   33846:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3384a:	f002 b975 	b.w	35b38 <am_hal_gpio_pinconfig>
   3384e:	4b4f      	ldr	r3, [pc, #316]	; (3398c <am_bsp_iom_pins_enable+0x2cc>)
   33850:	2019      	movs	r0, #25
   33852:	6819      	ldr	r1, [r3, #0]
   33854:	f002 f970 	bl	35b38 <am_hal_gpio_pinconfig>
   33858:	4b4d      	ldr	r3, [pc, #308]	; (33990 <am_bsp_iom_pins_enable+0x2d0>)
   3385a:	201a      	movs	r0, #26
   3385c:	6819      	ldr	r1, [r3, #0]
   3385e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33862:	f002 b969 	b.w	35b38 <am_hal_gpio_pinconfig>
   33866:	4b4b      	ldr	r3, [pc, #300]	; (33994 <am_bsp_iom_pins_enable+0x2d4>)
   33868:	2019      	movs	r0, #25
   3386a:	6819      	ldr	r1, [r3, #0]
   3386c:	f002 f964 	bl	35b38 <am_hal_gpio_pinconfig>
   33870:	4b49      	ldr	r3, [pc, #292]	; (33998 <am_bsp_iom_pins_enable+0x2d8>)
   33872:	201b      	movs	r0, #27
   33874:	6819      	ldr	r1, [r3, #0]
   33876:	f002 f95f 	bl	35b38 <am_hal_gpio_pinconfig>
   3387a:	4b48      	ldr	r3, [pc, #288]	; (3399c <am_bsp_iom_pins_enable+0x2dc>)
   3387c:	201a      	movs	r0, #26
   3387e:	6819      	ldr	r1, [r3, #0]
   33880:	f002 f95a 	bl	35b38 <am_hal_gpio_pinconfig>
   33884:	4b46      	ldr	r3, [pc, #280]	; (339a0 <am_bsp_iom_pins_enable+0x2e0>)
   33886:	2025      	movs	r0, #37	; 0x25
   33888:	6819      	ldr	r1, [r3, #0]
   3388a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   3388e:	f002 b953 	b.w	35b38 <am_hal_gpio_pinconfig>
   33892:	4b44      	ldr	r3, [pc, #272]	; (339a4 <am_bsp_iom_pins_enable+0x2e4>)
   33894:	2008      	movs	r0, #8
   33896:	6819      	ldr	r1, [r3, #0]
   33898:	f002 f94e 	bl	35b38 <am_hal_gpio_pinconfig>
   3389c:	4b42      	ldr	r3, [pc, #264]	; (339a8 <am_bsp_iom_pins_enable+0x2e8>)
   3389e:	2009      	movs	r0, #9
   338a0:	6819      	ldr	r1, [r3, #0]
   338a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   338a6:	f002 b947 	b.w	35b38 <am_hal_gpio_pinconfig>
   338aa:	4b40      	ldr	r3, [pc, #256]	; (339ac <am_bsp_iom_pins_enable+0x2ec>)
   338ac:	2008      	movs	r0, #8
   338ae:	6819      	ldr	r1, [r3, #0]
   338b0:	f002 f942 	bl	35b38 <am_hal_gpio_pinconfig>
   338b4:	4b3e      	ldr	r3, [pc, #248]	; (339b0 <am_bsp_iom_pins_enable+0x2f0>)
   338b6:	200a      	movs	r0, #10
   338b8:	6819      	ldr	r1, [r3, #0]
   338ba:	f002 f93d 	bl	35b38 <am_hal_gpio_pinconfig>
   338be:	4b3d      	ldr	r3, [pc, #244]	; (339b4 <am_bsp_iom_pins_enable+0x2f4>)
   338c0:	2009      	movs	r0, #9
   338c2:	6819      	ldr	r1, [r3, #0]
   338c4:	f002 f938 	bl	35b38 <am_hal_gpio_pinconfig>
   338c8:	4b3b      	ldr	r3, [pc, #236]	; (339b8 <am_bsp_iom_pins_enable+0x2f8>)
   338ca:	200b      	movs	r0, #11
   338cc:	6819      	ldr	r1, [r3, #0]
   338ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   338d2:	f002 b931 	b.w	35b38 <am_hal_gpio_pinconfig>
   338d6:	4b39      	ldr	r3, [pc, #228]	; (339bc <am_bsp_iom_pins_enable+0x2fc>)
   338d8:	2005      	movs	r0, #5
   338da:	6819      	ldr	r1, [r3, #0]
   338dc:	f002 f92c 	bl	35b38 <am_hal_gpio_pinconfig>
   338e0:	4b37      	ldr	r3, [pc, #220]	; (339c0 <am_bsp_iom_pins_enable+0x300>)
   338e2:	2006      	movs	r0, #6
   338e4:	6819      	ldr	r1, [r3, #0]
   338e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   338ea:	f002 b925 	b.w	35b38 <am_hal_gpio_pinconfig>
   338ee:	4b35      	ldr	r3, [pc, #212]	; (339c4 <am_bsp_iom_pins_enable+0x304>)
   338f0:	2005      	movs	r0, #5
   338f2:	6819      	ldr	r1, [r3, #0]
   338f4:	f002 f920 	bl	35b38 <am_hal_gpio_pinconfig>
   338f8:	4b33      	ldr	r3, [pc, #204]	; (339c8 <am_bsp_iom_pins_enable+0x308>)
   338fa:	2007      	movs	r0, #7
   338fc:	6819      	ldr	r1, [r3, #0]
   338fe:	f002 f91b 	bl	35b38 <am_hal_gpio_pinconfig>
   33902:	4b32      	ldr	r3, [pc, #200]	; (339cc <am_bsp_iom_pins_enable+0x30c>)
   33904:	2006      	movs	r0, #6
   33906:	6819      	ldr	r1, [r3, #0]
   33908:	f002 f916 	bl	35b38 <am_hal_gpio_pinconfig>
   3390c:	4b30      	ldr	r3, [pc, #192]	; (339d0 <am_bsp_iom_pins_enable+0x310>)
   3390e:	2048      	movs	r0, #72	; 0x48
   33910:	6819      	ldr	r1, [r3, #0]
   33912:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   33916:	f002 b90f 	b.w	35b38 <am_hal_gpio_pinconfig>
   3391a:	bf00      	nop
   3391c:	1000381c 	.word	0x1000381c
   33920:	10003820 	.word	0x10003820
   33924:	10003818 	.word	0x10003818
   33928:	1000bef8 	.word	0x1000bef8
   3392c:	10003814 	.word	0x10003814
   33930:	10003810 	.word	0x10003810
   33934:	10003808 	.word	0x10003808
   33938:	1000380c 	.word	0x1000380c
   3393c:	10003804 	.word	0x10003804
   33940:	1000bef4 	.word	0x1000bef4
   33944:	10003800 	.word	0x10003800
   33948:	100037fc 	.word	0x100037fc
   3394c:	100037f4 	.word	0x100037f4
   33950:	100037f8 	.word	0x100037f8
   33954:	100037f0 	.word	0x100037f0
   33958:	1000bef0 	.word	0x1000bef0
   3395c:	100037ec 	.word	0x100037ec
   33960:	100037e8 	.word	0x100037e8
   33964:	100037e4 	.word	0x100037e4
   33968:	1000beec 	.word	0x1000beec
   3396c:	100037e0 	.word	0x100037e0
   33970:	100037dc 	.word	0x100037dc
   33974:	100037d4 	.word	0x100037d4
   33978:	100037d8 	.word	0x100037d8
   3397c:	100037d0 	.word	0x100037d0
   33980:	1000bee8 	.word	0x1000bee8
   33984:	100037cc 	.word	0x100037cc
   33988:	100037c8 	.word	0x100037c8
   3398c:	100037c0 	.word	0x100037c0
   33990:	100037c4 	.word	0x100037c4
   33994:	100037bc 	.word	0x100037bc
   33998:	1000bee4 	.word	0x1000bee4
   3399c:	100037b8 	.word	0x100037b8
   339a0:	100037b4 	.word	0x100037b4
   339a4:	100037ac 	.word	0x100037ac
   339a8:	100037b0 	.word	0x100037b0
   339ac:	100037a8 	.word	0x100037a8
   339b0:	100037a0 	.word	0x100037a0
   339b4:	100037a4 	.word	0x100037a4
   339b8:	1000379c 	.word	0x1000379c
   339bc:	10003794 	.word	0x10003794
   339c0:	10003798 	.word	0x10003798
   339c4:	10003790 	.word	0x10003790
   339c8:	1000bee0 	.word	0x1000bee0
   339cc:	1000378c 	.word	0x1000378c
   339d0:	10003788 	.word	0x10003788

000339d4 <am_bsp_iom_pins_disable>:
   339d4:	2807      	cmp	r0, #7
   339d6:	d825      	bhi.n	33a24 <am_bsp_iom_pins_disable+0x50>
   339d8:	ea41 0180 	orr.w	r1, r1, r0, lsl #2
   339dc:	b510      	push	{r4, lr}
   339de:	291d      	cmp	r1, #29
   339e0:	d81f      	bhi.n	33a22 <am_bsp_iom_pins_disable+0x4e>
   339e2:	e8df f011 	tbh	[pc, r1, lsl #1]
   339e6:	0100      	.short	0x0100
   339e8:	001e00f4 	.word	0x001e00f4
   339ec:	00e0001e 	.word	0x00e0001e
   339f0:	001e00d4 	.word	0x001e00d4
   339f4:	00c0001e 	.word	0x00c0001e
   339f8:	001e00b4 	.word	0x001e00b4
   339fc:	00a0001e 	.word	0x00a0001e
   33a00:	001e0094 	.word	0x001e0094
   33a04:	0080001e 	.word	0x0080001e
   33a08:	001e001e 	.word	0x001e001e
   33a0c:	006c001e 	.word	0x006c001e
   33a10:	001e0060 	.word	0x001e0060
   33a14:	004c001e 	.word	0x004c001e
   33a18:	001e0040 	.word	0x001e0040
   33a1c:	002c001e 	.word	0x002c001e
   33a20:	0020      	.short	0x0020
   33a22:	bd10      	pop	{r4, pc}
   33a24:	4770      	bx	lr
   33a26:	4b7a      	ldr	r3, [pc, #488]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33a28:	681c      	ldr	r4, [r3, #0]
   33a2a:	2016      	movs	r0, #22
   33a2c:	4621      	mov	r1, r4
   33a2e:	f002 f883 	bl	35b38 <am_hal_gpio_pinconfig>
   33a32:	4621      	mov	r1, r4
   33a34:	2017      	movs	r0, #23
   33a36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33a3a:	f002 b87d 	b.w	35b38 <am_hal_gpio_pinconfig>
   33a3e:	4b74      	ldr	r3, [pc, #464]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33a40:	681c      	ldr	r4, [r3, #0]
   33a42:	2016      	movs	r0, #22
   33a44:	4621      	mov	r1, r4
   33a46:	f002 f877 	bl	35b38 <am_hal_gpio_pinconfig>
   33a4a:	4621      	mov	r1, r4
   33a4c:	2018      	movs	r0, #24
   33a4e:	f002 f873 	bl	35b38 <am_hal_gpio_pinconfig>
   33a52:	4621      	mov	r1, r4
   33a54:	2017      	movs	r0, #23
   33a56:	f002 f86f 	bl	35b38 <am_hal_gpio_pinconfig>
   33a5a:	4621      	mov	r1, r4
   33a5c:	2058      	movs	r0, #88	; 0x58
   33a5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33a62:	f002 b869 	b.w	35b38 <am_hal_gpio_pinconfig>
   33a66:	4b6a      	ldr	r3, [pc, #424]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33a68:	681c      	ldr	r4, [r3, #0]
   33a6a:	203d      	movs	r0, #61	; 0x3d
   33a6c:	4621      	mov	r1, r4
   33a6e:	f002 f863 	bl	35b38 <am_hal_gpio_pinconfig>
   33a72:	4621      	mov	r1, r4
   33a74:	203e      	movs	r0, #62	; 0x3e
   33a76:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33a7a:	f002 b85d 	b.w	35b38 <am_hal_gpio_pinconfig>
   33a7e:	4b64      	ldr	r3, [pc, #400]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33a80:	681c      	ldr	r4, [r3, #0]
   33a82:	203d      	movs	r0, #61	; 0x3d
   33a84:	4621      	mov	r1, r4
   33a86:	f002 f857 	bl	35b38 <am_hal_gpio_pinconfig>
   33a8a:	4621      	mov	r1, r4
   33a8c:	203f      	movs	r0, #63	; 0x3f
   33a8e:	f002 f853 	bl	35b38 <am_hal_gpio_pinconfig>
   33a92:	4621      	mov	r1, r4
   33a94:	203e      	movs	r0, #62	; 0x3e
   33a96:	f002 f84f 	bl	35b38 <am_hal_gpio_pinconfig>
   33a9a:	4621      	mov	r1, r4
   33a9c:	201e      	movs	r0, #30
   33a9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33aa2:	f002 b849 	b.w	35b38 <am_hal_gpio_pinconfig>
   33aa6:	4b5a      	ldr	r3, [pc, #360]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33aa8:	681c      	ldr	r4, [r3, #0]
   33aaa:	202f      	movs	r0, #47	; 0x2f
   33aac:	4621      	mov	r1, r4
   33aae:	f002 f843 	bl	35b38 <am_hal_gpio_pinconfig>
   33ab2:	4621      	mov	r1, r4
   33ab4:	2030      	movs	r0, #48	; 0x30
   33ab6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33aba:	f002 b83d 	b.w	35b38 <am_hal_gpio_pinconfig>
   33abe:	4b54      	ldr	r3, [pc, #336]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33ac0:	681c      	ldr	r4, [r3, #0]
   33ac2:	202f      	movs	r0, #47	; 0x2f
   33ac4:	4621      	mov	r1, r4
   33ac6:	f002 f837 	bl	35b38 <am_hal_gpio_pinconfig>
   33aca:	4621      	mov	r1, r4
   33acc:	2031      	movs	r0, #49	; 0x31
   33ace:	f002 f833 	bl	35b38 <am_hal_gpio_pinconfig>
   33ad2:	4621      	mov	r1, r4
   33ad4:	2030      	movs	r0, #48	; 0x30
   33ad6:	f002 f82f 	bl	35b38 <am_hal_gpio_pinconfig>
   33ada:	4621      	mov	r1, r4
   33adc:	203c      	movs	r0, #60	; 0x3c
   33ade:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33ae2:	f002 b829 	b.w	35b38 <am_hal_gpio_pinconfig>
   33ae6:	4b4a      	ldr	r3, [pc, #296]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33ae8:	681c      	ldr	r4, [r3, #0]
   33aea:	2022      	movs	r0, #34	; 0x22
   33aec:	4621      	mov	r1, r4
   33aee:	f002 f823 	bl	35b38 <am_hal_gpio_pinconfig>
   33af2:	4621      	mov	r1, r4
   33af4:	2024      	movs	r0, #36	; 0x24
   33af6:	f002 f81f 	bl	35b38 <am_hal_gpio_pinconfig>
   33afa:	4621      	mov	r1, r4
   33afc:	2023      	movs	r0, #35	; 0x23
   33afe:	f002 f81b 	bl	35b38 <am_hal_gpio_pinconfig>
   33b02:	4621      	mov	r1, r4
   33b04:	202b      	movs	r0, #43	; 0x2b
   33b06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33b0a:	f002 b815 	b.w	35b38 <am_hal_gpio_pinconfig>
   33b0e:	4b40      	ldr	r3, [pc, #256]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33b10:	681c      	ldr	r4, [r3, #0]
   33b12:	201f      	movs	r0, #31
   33b14:	4621      	mov	r1, r4
   33b16:	f002 f80f 	bl	35b38 <am_hal_gpio_pinconfig>
   33b1a:	4621      	mov	r1, r4
   33b1c:	2020      	movs	r0, #32
   33b1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33b22:	f002 b809 	b.w	35b38 <am_hal_gpio_pinconfig>
   33b26:	4b3a      	ldr	r3, [pc, #232]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33b28:	681c      	ldr	r4, [r3, #0]
   33b2a:	201f      	movs	r0, #31
   33b2c:	4621      	mov	r1, r4
   33b2e:	f002 f803 	bl	35b38 <am_hal_gpio_pinconfig>
   33b32:	4621      	mov	r1, r4
   33b34:	2021      	movs	r0, #33	; 0x21
   33b36:	f001 ffff 	bl	35b38 <am_hal_gpio_pinconfig>
   33b3a:	4621      	mov	r1, r4
   33b3c:	2020      	movs	r0, #32
   33b3e:	f001 fffb 	bl	35b38 <am_hal_gpio_pinconfig>
   33b42:	4621      	mov	r1, r4
   33b44:	2055      	movs	r0, #85	; 0x55
   33b46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33b4a:	f001 bff5 	b.w	35b38 <am_hal_gpio_pinconfig>
   33b4e:	4b30      	ldr	r3, [pc, #192]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33b50:	681c      	ldr	r4, [r3, #0]
   33b52:	2019      	movs	r0, #25
   33b54:	4621      	mov	r1, r4
   33b56:	f001 ffef 	bl	35b38 <am_hal_gpio_pinconfig>
   33b5a:	4621      	mov	r1, r4
   33b5c:	201a      	movs	r0, #26
   33b5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33b62:	f001 bfe9 	b.w	35b38 <am_hal_gpio_pinconfig>
   33b66:	4b2a      	ldr	r3, [pc, #168]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33b68:	681c      	ldr	r4, [r3, #0]
   33b6a:	2019      	movs	r0, #25
   33b6c:	4621      	mov	r1, r4
   33b6e:	f001 ffe3 	bl	35b38 <am_hal_gpio_pinconfig>
   33b72:	4621      	mov	r1, r4
   33b74:	201b      	movs	r0, #27
   33b76:	f001 ffdf 	bl	35b38 <am_hal_gpio_pinconfig>
   33b7a:	4621      	mov	r1, r4
   33b7c:	201a      	movs	r0, #26
   33b7e:	f001 ffdb 	bl	35b38 <am_hal_gpio_pinconfig>
   33b82:	4621      	mov	r1, r4
   33b84:	2025      	movs	r0, #37	; 0x25
   33b86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33b8a:	f001 bfd5 	b.w	35b38 <am_hal_gpio_pinconfig>
   33b8e:	4b20      	ldr	r3, [pc, #128]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33b90:	681c      	ldr	r4, [r3, #0]
   33b92:	2008      	movs	r0, #8
   33b94:	4621      	mov	r1, r4
   33b96:	f001 ffcf 	bl	35b38 <am_hal_gpio_pinconfig>
   33b9a:	4621      	mov	r1, r4
   33b9c:	2009      	movs	r0, #9
   33b9e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33ba2:	f001 bfc9 	b.w	35b38 <am_hal_gpio_pinconfig>
   33ba6:	4b1a      	ldr	r3, [pc, #104]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33ba8:	681c      	ldr	r4, [r3, #0]
   33baa:	2008      	movs	r0, #8
   33bac:	4621      	mov	r1, r4
   33bae:	f001 ffc3 	bl	35b38 <am_hal_gpio_pinconfig>
   33bb2:	4621      	mov	r1, r4
   33bb4:	200a      	movs	r0, #10
   33bb6:	f001 ffbf 	bl	35b38 <am_hal_gpio_pinconfig>
   33bba:	4621      	mov	r1, r4
   33bbc:	2009      	movs	r0, #9
   33bbe:	f001 ffbb 	bl	35b38 <am_hal_gpio_pinconfig>
   33bc2:	4621      	mov	r1, r4
   33bc4:	200b      	movs	r0, #11
   33bc6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33bca:	f001 bfb5 	b.w	35b38 <am_hal_gpio_pinconfig>
   33bce:	4b10      	ldr	r3, [pc, #64]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33bd0:	681c      	ldr	r4, [r3, #0]
   33bd2:	2005      	movs	r0, #5
   33bd4:	4621      	mov	r1, r4
   33bd6:	f001 ffaf 	bl	35b38 <am_hal_gpio_pinconfig>
   33bda:	4621      	mov	r1, r4
   33bdc:	2006      	movs	r0, #6
   33bde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33be2:	f001 bfa9 	b.w	35b38 <am_hal_gpio_pinconfig>
   33be6:	4b0a      	ldr	r3, [pc, #40]	; (33c10 <am_bsp_iom_pins_disable+0x23c>)
   33be8:	681c      	ldr	r4, [r3, #0]
   33bea:	2005      	movs	r0, #5
   33bec:	4621      	mov	r1, r4
   33bee:	f001 ffa3 	bl	35b38 <am_hal_gpio_pinconfig>
   33bf2:	4621      	mov	r1, r4
   33bf4:	2007      	movs	r0, #7
   33bf6:	f001 ff9f 	bl	35b38 <am_hal_gpio_pinconfig>
   33bfa:	4621      	mov	r1, r4
   33bfc:	2006      	movs	r0, #6
   33bfe:	f001 ff9b 	bl	35b38 <am_hal_gpio_pinconfig>
   33c02:	4621      	mov	r1, r4
   33c04:	2048      	movs	r0, #72	; 0x48
   33c06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   33c0a:	f001 bf95 	b.w	35b38 <am_hal_gpio_pinconfig>
   33c0e:	bf00      	nop
   33c10:	00046800 	.word	0x00046800

00033c14 <am_hal_cachectrl_config>:
   33c14:	b530      	push	{r4, r5, lr}
   33c16:	b083      	sub	sp, #12
   33c18:	4604      	mov	r4, r0
   33c1a:	f000 f8ef 	bl	33dfc <am_hal_interrupt_master_disable>
   33c1e:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
   33c22:	9001      	str	r0, [sp, #4]
   33c24:	682b      	ldr	r3, [r5, #0]
   33c26:	f423 7340 	bic.w	r3, r3, #768	; 0x300
   33c2a:	602b      	str	r3, [r5, #0]
   33c2c:	9801      	ldr	r0, [sp, #4]
   33c2e:	f000 f8e9 	bl	33e04 <am_hal_interrupt_master_set>
   33c32:	7863      	ldrb	r3, [r4, #1]
   33c34:	7822      	ldrb	r2, [r4, #0]
   33c36:	78a1      	ldrb	r1, [r4, #2]
   33c38:	021b      	lsls	r3, r3, #8
   33c3a:	f403 7340 	and.w	r3, r3, #768	; 0x300
   33c3e:	0112      	lsls	r2, r2, #4
   33c40:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
   33c44:	b2d2      	uxtb	r2, r2
   33c46:	4313      	orrs	r3, r2
   33c48:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   33c4c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   33c50:	2000      	movs	r0, #0
   33c52:	602b      	str	r3, [r5, #0]
   33c54:	b003      	add	sp, #12
   33c56:	bd30      	pop	{r4, r5, pc}

00033c58 <am_hal_cachectrl_enable>:
   33c58:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
   33c5c:	2000      	movs	r0, #0
   33c5e:	681a      	ldr	r2, [r3, #0]
   33c60:	f042 0201 	orr.w	r2, r2, #1
   33c64:	601a      	str	r2, [r3, #0]
   33c66:	689a      	ldr	r2, [r3, #8]
   33c68:	f042 0201 	orr.w	r2, r2, #1
   33c6c:	609a      	str	r2, [r3, #8]
   33c6e:	4770      	bx	lr

00033c70 <am_hal_daxi_config>:
   33c70:	b530      	push	{r4, r5, lr}
   33c72:	b083      	sub	sp, #12
   33c74:	4605      	mov	r5, r0
   33c76:	f000 f8c1 	bl	33dfc <am_hal_interrupt_master_disable>
   33c7a:	9000      	str	r0, [sp, #0]
   33c7c:	f000 f8be 	bl	33dfc <am_hal_interrupt_master_disable>
   33c80:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
   33c84:	9001      	str	r0, [sp, #4]
   33c86:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   33c88:	0752      	lsls	r2, r2, #29
   33c8a:	d40c      	bmi.n	33ca6 <am_hal_daxi_config+0x36>
   33c8c:	f3bf 8f4f 	dsb	sy
   33c90:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33c92:	491a      	ldr	r1, [pc, #104]	; (33cfc <am_hal_daxi_config+0x8c>)
   33c94:	f042 0201 	orr.w	r2, r2, #1
   33c98:	655a      	str	r2, [r3, #84]	; 0x54
   33c9a:	680a      	ldr	r2, [r1, #0]
   33c9c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33c9e:	f042 0202 	orr.w	r2, r2, #2
   33ca2:	655a      	str	r2, [r3, #84]	; 0x54
   33ca4:	680b      	ldr	r3, [r1, #0]
   33ca6:	f04f 4490 	mov.w	r4, #1207959552	; 0x48000000
   33caa:	6d63      	ldr	r3, [r4, #84]	; 0x54
   33cac:	075b      	lsls	r3, r3, #29
   33cae:	d5fc      	bpl.n	33caa <am_hal_daxi_config+0x3a>
   33cb0:	9801      	ldr	r0, [sp, #4]
   33cb2:	f000 f8a7 	bl	33e04 <am_hal_interrupt_master_set>
   33cb6:	b1ed      	cbz	r5, 33cf4 <am_hal_daxi_config+0x84>
   33cb8:	792b      	ldrb	r3, [r5, #4]
   33cba:	78ea      	ldrb	r2, [r5, #3]
   33cbc:	7869      	ldrb	r1, [r5, #1]
   33cbe:	6828      	ldr	r0, [r5, #0]
   33cc0:	f003 0301 	and.w	r3, r3, #1
   33cc4:	0212      	lsls	r2, r2, #8
   33cc6:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
   33cca:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
   33cce:	4313      	orrs	r3, r2
   33cd0:	78aa      	ldrb	r2, [r5, #2]
   33cd2:	490b      	ldr	r1, [pc, #44]	; (33d00 <am_hal_daxi_config+0x90>)
   33cd4:	0412      	lsls	r2, r2, #16
   33cd6:	f402 12f8 	and.w	r2, r2, #2031616	; 0x1f0000
   33cda:	4313      	orrs	r3, r2
   33cdc:	6523      	str	r3, [r4, #80]	; 0x50
   33cde:	6008      	str	r0, [r1, #0]
   33ce0:	792b      	ldrb	r3, [r5, #4]
   33ce2:	710b      	strb	r3, [r1, #4]
   33ce4:	4b05      	ldr	r3, [pc, #20]	; (33cfc <am_hal_daxi_config+0x8c>)
   33ce6:	681b      	ldr	r3, [r3, #0]
   33ce8:	9800      	ldr	r0, [sp, #0]
   33cea:	f000 f88b 	bl	33e04 <am_hal_interrupt_master_set>
   33cee:	2000      	movs	r0, #0
   33cf0:	b003      	add	sp, #12
   33cf2:	bd30      	pop	{r4, r5, pc}
   33cf4:	2306      	movs	r3, #6
   33cf6:	6523      	str	r3, [r4, #80]	; 0x50
   33cf8:	e7f4      	b.n	33ce4 <am_hal_daxi_config+0x74>
   33cfa:	bf00      	nop
   33cfc:	47ff0000 	.word	0x47ff0000
   33d00:	10003828 	.word	0x10003828

00033d04 <am_hal_daxi_control>:
   33d04:	b510      	push	{r4, lr}
   33d06:	b084      	sub	sp, #16
   33d08:	2803      	cmp	r0, #3
   33d0a:	d866      	bhi.n	33dda <am_hal_daxi_control+0xd6>
   33d0c:	e8df f000 	tbb	[pc, r0]
   33d10:	02083252 	.word	0x02083252
   33d14:	4832      	ldr	r0, [pc, #200]	; (33de0 <am_hal_daxi_control+0xdc>)
   33d16:	f7ff ffab 	bl	33c70 <am_hal_daxi_config>
   33d1a:	2000      	movs	r0, #0
   33d1c:	b004      	add	sp, #16
   33d1e:	bd10      	pop	{r4, pc}
   33d20:	f000 f86c 	bl	33dfc <am_hal_interrupt_master_disable>
   33d24:	9002      	str	r0, [sp, #8]
   33d26:	f000 f869 	bl	33dfc <am_hal_interrupt_master_disable>
   33d2a:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
   33d2e:	9003      	str	r0, [sp, #12]
   33d30:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   33d32:	0752      	lsls	r2, r2, #29
   33d34:	d40c      	bmi.n	33d50 <am_hal_daxi_control+0x4c>
   33d36:	f3bf 8f4f 	dsb	sy
   33d3a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33d3c:	4929      	ldr	r1, [pc, #164]	; (33de4 <am_hal_daxi_control+0xe0>)
   33d3e:	f042 0201 	orr.w	r2, r2, #1
   33d42:	655a      	str	r2, [r3, #84]	; 0x54
   33d44:	680a      	ldr	r2, [r1, #0]
   33d46:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33d48:	f042 0202 	orr.w	r2, r2, #2
   33d4c:	655a      	str	r2, [r3, #84]	; 0x54
   33d4e:	680b      	ldr	r3, [r1, #0]
   33d50:	f04f 4490 	mov.w	r4, #1207959552	; 0x48000000
   33d54:	6d63      	ldr	r3, [r4, #84]	; 0x54
   33d56:	075b      	lsls	r3, r3, #29
   33d58:	d5fc      	bpl.n	33d54 <am_hal_daxi_control+0x50>
   33d5a:	9803      	ldr	r0, [sp, #12]
   33d5c:	f000 f852 	bl	33e04 <am_hal_interrupt_master_set>
   33d60:	2206      	movs	r2, #6
   33d62:	4b20      	ldr	r3, [pc, #128]	; (33de4 <am_hal_daxi_control+0xe0>)
   33d64:	6522      	str	r2, [r4, #80]	; 0x50
   33d66:	681b      	ldr	r3, [r3, #0]
   33d68:	9802      	ldr	r0, [sp, #8]
   33d6a:	f000 f84b 	bl	33e04 <am_hal_interrupt_master_set>
   33d6e:	2000      	movs	r0, #0
   33d70:	b004      	add	sp, #16
   33d72:	bd10      	pop	{r4, pc}
   33d74:	f000 f842 	bl	33dfc <am_hal_interrupt_master_disable>
   33d78:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
   33d7c:	9001      	str	r0, [sp, #4]
   33d7e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   33d80:	0754      	lsls	r4, r2, #29
   33d82:	d40c      	bmi.n	33d9e <am_hal_daxi_control+0x9a>
   33d84:	f3bf 8f4f 	dsb	sy
   33d88:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33d8a:	4916      	ldr	r1, [pc, #88]	; (33de4 <am_hal_daxi_control+0xe0>)
   33d8c:	f042 0201 	orr.w	r2, r2, #1
   33d90:	655a      	str	r2, [r3, #84]	; 0x54
   33d92:	680a      	ldr	r2, [r1, #0]
   33d94:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33d96:	f042 0202 	orr.w	r2, r2, #2
   33d9a:	655a      	str	r2, [r3, #84]	; 0x54
   33d9c:	680b      	ldr	r3, [r1, #0]
   33d9e:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
   33da2:	6d53      	ldr	r3, [r2, #84]	; 0x54
   33da4:	0758      	lsls	r0, r3, #29
   33da6:	d5fc      	bpl.n	33da2 <am_hal_daxi_control+0x9e>
   33da8:	9801      	ldr	r0, [sp, #4]
   33daa:	f000 f82b 	bl	33e04 <am_hal_interrupt_master_set>
   33dae:	2000      	movs	r0, #0
   33db0:	b004      	add	sp, #16
   33db2:	bd10      	pop	{r4, pc}
   33db4:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
   33db8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
   33dba:	0751      	lsls	r1, r2, #29
   33dbc:	f3c2 0080 	ubfx	r0, r2, #2, #1
   33dc0:	d409      	bmi.n	33dd6 <am_hal_daxi_control+0xd2>
   33dc2:	f3bf 8f4f 	dsb	sy
   33dc6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
   33dc8:	4906      	ldr	r1, [pc, #24]	; (33de4 <am_hal_daxi_control+0xe0>)
   33dca:	f042 0202 	orr.w	r2, r2, #2
   33dce:	655a      	str	r2, [r3, #84]	; 0x54
   33dd0:	680b      	ldr	r3, [r1, #0]
   33dd2:	b004      	add	sp, #16
   33dd4:	bd10      	pop	{r4, pc}
   33dd6:	2000      	movs	r0, #0
   33dd8:	e7a0      	b.n	33d1c <am_hal_daxi_control+0x18>
   33dda:	2006      	movs	r0, #6
   33ddc:	e79e      	b.n	33d1c <am_hal_daxi_control+0x18>
   33dde:	bf00      	nop
   33de0:	10003828 	.word	0x10003828
   33de4:	47ff0000 	.word	0x47ff0000

00033de8 <am_hal_fault_capture_enable>:
   33de8:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
   33dec:	2000      	movs	r0, #0
   33dee:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
   33df2:	f043 0301 	orr.w	r3, r3, #1
   33df6:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
   33dfa:	4770      	bx	lr

00033dfc <am_hal_interrupt_master_disable>:
   33dfc:	f3ef 8010 	mrs	r0, PRIMASK
   33e00:	b672      	cpsid	i
   33e02:	4770      	bx	lr

00033e04 <am_hal_interrupt_master_set>:
   33e04:	f380 8810 	msr	PRIMASK, r0
   33e08:	4770      	bx	lr
   33e0a:	bf00      	nop

00033e0c <internal_iom_reset_on_error>:
   33e0c:	b570      	push	{r4, r5, r6, lr}
   33e0e:	6844      	ldr	r4, [r0, #4]
   33e10:	f8d0 0864 	ldr.w	r0, [r0, #2148]	; 0x864
   33e14:	f504 2480 	add.w	r4, r4, #262144	; 0x40000
   33e18:	3450      	adds	r4, #80	; 0x50
   33e1a:	0324      	lsls	r4, r4, #12
   33e1c:	2300      	movs	r3, #0
   33e1e:	050e      	lsls	r6, r1, #20
   33e20:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   33e24:	f8c4 3200 	str.w	r3, [r4, #512]	; 0x200
   33e28:	d52a      	bpl.n	33e80 <internal_iom_reset_on_error+0x74>
   33e2a:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
   33e2e:	079a      	lsls	r2, r3, #30
   33e30:	d45d      	bmi.n	33eee <internal_iom_reset_on_error+0xe2>
   33e32:	f8d4 3248 	ldr.w	r3, [r4, #584]	; 0x248
   33e36:	079b      	lsls	r3, r3, #30
   33e38:	d508      	bpl.n	33e4c <internal_iom_reset_on_error+0x40>
   33e3a:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   33e3e:	f3c3 4307 	ubfx	r3, r3, #16, #8
   33e42:	2b03      	cmp	r3, #3
   33e44:	d9f5      	bls.n	33e32 <internal_iom_reset_on_error+0x26>
   33e46:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
   33e4a:	e7f6      	b.n	33e3a <internal_iom_reset_on_error+0x2e>
   33e4c:	f8d4 3248 	ldr.w	r3, [r4, #584]	; 0x248
   33e50:	f003 0306 	and.w	r3, r3, #6
   33e54:	2b04      	cmp	r3, #4
   33e56:	d1f9      	bne.n	33e4c <internal_iom_reset_on_error+0x40>
   33e58:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   33e5c:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
   33e60:	d00e      	beq.n	33e80 <internal_iom_reset_on_error+0x74>
   33e62:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   33e66:	f3c3 4307 	ubfx	r3, r3, #16, #8
   33e6a:	2b03      	cmp	r3, #3
   33e6c:	d9f4      	bls.n	33e58 <internal_iom_reset_on_error+0x4c>
   33e6e:	f8d4 3108 	ldr.w	r3, [r4, #264]	; 0x108
   33e72:	e7f6      	b.n	33e62 <internal_iom_reset_on_error+0x56>
   33e74:	f8d4 3248 	ldr.w	r3, [r4, #584]	; 0x248
   33e78:	f003 0306 	and.w	r3, r3, #6
   33e7c:	2b04      	cmp	r3, #4
   33e7e:	d1f9      	bne.n	33e74 <internal_iom_reset_on_error+0x68>
   33e80:	f411 7f04 	tst.w	r1, #528	; 0x210
   33e84:	d02c      	beq.n	33ee0 <internal_iom_reset_on_error+0xd4>
   33e86:	f8d4 6388 	ldr.w	r6, [r4, #904]	; 0x388
   33e8a:	f8d4 3248 	ldr.w	r3, [r4, #584]	; 0x248
   33e8e:	f003 0306 	and.w	r3, r3, #6
   33e92:	2b04      	cmp	r3, #4
   33e94:	d1f9      	bne.n	33e8a <internal_iom_reset_on_error+0x7e>
   33e96:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   33e9a:	f36f 1304 	bfc	r3, #4, #1
   33e9e:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
   33ea2:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
   33ea6:	f36f 0341 	bfc	r3, #1, #1
   33eaa:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   33eae:	f8d4 3388 	ldr.w	r3, [r4, #904]	; 0x388
   33eb2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
   33eb6:	f043 0302 	orr.w	r3, r3, #2
   33eba:	f8c4 3388 	str.w	r3, [r4, #904]	; 0x388
   33ebe:	0040      	lsls	r0, r0, #1
   33ec0:	f001 fa02 	bl	352c8 <am_hal_delay_us>
   33ec4:	f8c4 6388 	str.w	r6, [r4, #904]	; 0x388
   33ec8:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
   33ecc:	f043 0302 	orr.w	r3, r3, #2
   33ed0:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
   33ed4:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
   33ed8:	f043 0310 	orr.w	r3, r3, #16
   33edc:	f8c4 311c 	str.w	r3, [r4, #284]	; 0x11c
   33ee0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   33ee4:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
   33ee8:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
   33eec:	bd70      	pop	{r4, r5, r6, pc}
   33eee:	f8d4 221c 	ldr.w	r2, [r4, #540]	; 0x21c
   33ef2:	4e07      	ldr	r6, [pc, #28]	; (33f10 <internal_iom_reset_on_error+0x104>)
   33ef4:	2a00      	cmp	r2, #0
   33ef6:	d0bd      	beq.n	33e74 <internal_iom_reset_on_error+0x68>
   33ef8:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   33efc:	f3c3 2307 	ubfx	r3, r3, #8, #8
   33f00:	2b03      	cmp	r3, #3
   33f02:	d9f9      	bls.n	33ef8 <internal_iom_reset_on_error+0xec>
   33f04:	2a04      	cmp	r2, #4
   33f06:	f8c4 610c 	str.w	r6, [r4, #268]	; 0x10c
   33f0a:	d9b3      	bls.n	33e74 <internal_iom_reset_on_error+0x68>
   33f0c:	3a04      	subs	r2, #4
   33f0e:	e7f1      	b.n	33ef4 <internal_iom_reset_on_error+0xe8>
   33f10:	deadbeef 	.word	0xdeadbeef

00033f14 <am_hal_iom_uninitialize>:
   33f14:	b398      	cbz	r0, 33f7e <am_hal_iom_uninitialize+0x6a>
   33f16:	b538      	push	{r3, r4, r5, lr}
   33f18:	6803      	ldr	r3, [r0, #0]
   33f1a:	4a1a      	ldr	r2, [pc, #104]	; (33f84 <am_hal_iom_uninitialize+0x70>)
   33f1c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   33f20:	4293      	cmp	r3, r2
   33f22:	4604      	mov	r4, r0
   33f24:	d108      	bne.n	33f38 <am_hal_iom_uninitialize+0x24>
   33f26:	78c3      	ldrb	r3, [r0, #3]
   33f28:	079b      	lsls	r3, r3, #30
   33f2a:	d407      	bmi.n	33f3c <am_hal_iom_uninitialize+0x28>
   33f2c:	78e3      	ldrb	r3, [r4, #3]
   33f2e:	f36f 0300 	bfc	r3, #0, #1
   33f32:	2000      	movs	r0, #0
   33f34:	70e3      	strb	r3, [r4, #3]
   33f36:	bd38      	pop	{r3, r4, r5, pc}
   33f38:	2002      	movs	r0, #2
   33f3a:	bd38      	pop	{r3, r4, r5, pc}
   33f3c:	6a45      	ldr	r5, [r0, #36]	; 0x24
   33f3e:	2d00      	cmp	r5, #0
   33f40:	d1f4      	bne.n	33f2c <am_hal_iom_uninitialize+0x18>
   33f42:	6843      	ldr	r3, [r0, #4]
   33f44:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   33f48:	3350      	adds	r3, #80	; 0x50
   33f4a:	031b      	lsls	r3, r3, #12
   33f4c:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   33f50:	f365 0200 	bfi	r2, r5, #0, #1
   33f54:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   33f58:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   33f5c:	f365 1204 	bfi	r2, r5, #4, #1
   33f60:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   33f64:	f8d0 0828 	ldr.w	r0, [r0, #2088]	; 0x828
   33f68:	b120      	cbz	r0, 33f74 <am_hal_iom_uninitialize+0x60>
   33f6a:	2101      	movs	r1, #1
   33f6c:	f002 ff3a 	bl	36de4 <am_hal_cmdq_term>
   33f70:	f8c4 5828 	str.w	r5, [r4, #2088]	; 0x828
   33f74:	78e3      	ldrb	r3, [r4, #3]
   33f76:	f36f 0341 	bfc	r3, #1, #1
   33f7a:	70e3      	strb	r3, [r4, #3]
   33f7c:	e7d6      	b.n	33f2c <am_hal_iom_uninitialize+0x18>
   33f7e:	2002      	movs	r0, #2
   33f80:	4770      	bx	lr
   33f82:	bf00      	nop
   33f84:	01123456 	.word	0x01123456

00033f88 <am_hal_iom_initialize>:
   33f88:	2807      	cmp	r0, #7
   33f8a:	d81a      	bhi.n	33fc2 <am_hal_iom_initialize+0x3a>
   33f8c:	b1e9      	cbz	r1, 33fca <am_hal_iom_initialize+0x42>
   33f8e:	b530      	push	{r4, r5, lr}
   33f90:	f640 0ca8 	movw	ip, #2216	; 0x8a8
   33f94:	4d0e      	ldr	r5, [pc, #56]	; (33fd0 <am_hal_iom_initialize+0x48>)
   33f96:	fb0c fc00 	mul.w	ip, ip, r0
   33f9a:	eb05 040c 	add.w	r4, r5, ip
   33f9e:	4602      	mov	r2, r0
   33fa0:	78e3      	ldrb	r3, [r4, #3]
   33fa2:	f013 0301 	ands.w	r3, r3, #1
   33fa6:	d10e      	bne.n	33fc6 <am_hal_iom_initialize+0x3e>
   33fa8:	4618      	mov	r0, r3
   33faa:	f855 300c 	ldr.w	r3, [r5, ip]
   33fae:	f003 4e7c 	and.w	lr, r3, #4227858432	; 0xfc000000
   33fb2:	4b08      	ldr	r3, [pc, #32]	; (33fd4 <am_hal_iom_initialize+0x4c>)
   33fb4:	ea4e 0303 	orr.w	r3, lr, r3
   33fb8:	f845 300c 	str.w	r3, [r5, ip]
   33fbc:	6062      	str	r2, [r4, #4]
   33fbe:	600c      	str	r4, [r1, #0]
   33fc0:	bd30      	pop	{r4, r5, pc}
   33fc2:	2005      	movs	r0, #5
   33fc4:	4770      	bx	lr
   33fc6:	2007      	movs	r0, #7
   33fc8:	bd30      	pop	{r4, r5, pc}
   33fca:	2006      	movs	r0, #6
   33fcc:	4770      	bx	lr
   33fce:	bf00      	nop
   33fd0:	1000befc 	.word	0x1000befc
   33fd4:	01123456 	.word	0x01123456

00033fd8 <am_hal_iom_enable>:
   33fd8:	2800      	cmp	r0, #0
   33fda:	d06b      	beq.n	340b4 <am_hal_iom_enable+0xdc>
   33fdc:	b530      	push	{r4, r5, lr}
   33fde:	6803      	ldr	r3, [r0, #0]
   33fe0:	4a37      	ldr	r2, [pc, #220]	; (340c0 <am_hal_iom_enable+0xe8>)
   33fe2:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   33fe6:	4293      	cmp	r3, r2
   33fe8:	b085      	sub	sp, #20
   33fea:	4604      	mov	r4, r0
   33fec:	d155      	bne.n	3409a <am_hal_iom_enable+0xc2>
   33fee:	78c3      	ldrb	r3, [r0, #3]
   33ff0:	079b      	lsls	r3, r3, #30
   33ff2:	d455      	bmi.n	340a0 <am_hal_iom_enable+0xc8>
   33ff4:	6840      	ldr	r0, [r0, #4]
   33ff6:	7a23      	ldrb	r3, [r4, #8]
   33ff8:	f500 2280 	add.w	r2, r0, #262144	; 0x40000
   33ffc:	3250      	adds	r2, #80	; 0x50
   33ffe:	0311      	lsls	r1, r2, #12
   34000:	3b00      	subs	r3, #0
   34002:	f8d1 211c 	ldr.w	r2, [r1, #284]	; 0x11c
   34006:	bf18      	it	ne
   34008:	2301      	movne	r3, #1
   3400a:	f3c2 0242 	ubfx	r2, r2, #1, #3
   3400e:	4293      	cmp	r3, r2
   34010:	d04c      	beq.n	340ac <am_hal_iom_enable+0xd4>
   34012:	f8d1 211c 	ldr.w	r2, [r1, #284]	; 0x11c
   34016:	f3c2 1242 	ubfx	r2, r2, #5, #3
   3401a:	4293      	cmp	r3, r2
   3401c:	d143      	bne.n	340a6 <am_hal_iom_enable+0xce>
   3401e:	2310      	movs	r3, #16
   34020:	f8c1 311c 	str.w	r3, [r1, #284]	; 0x11c
   34024:	68e3      	ldr	r3, [r4, #12]
   34026:	b38b      	cbz	r3, 3408c <am_hal_iom_enable+0xb4>
   34028:	4a26      	ldr	r2, [pc, #152]	; (340c4 <am_hal_iom_enable+0xec>)
   3402a:	9302      	str	r3, [sp, #8]
   3402c:	2300      	movs	r3, #0
   3402e:	6263      	str	r3, [r4, #36]	; 0x24
   34030:	61e3      	str	r3, [r4, #28]
   34032:	f8c1 2238 	str.w	r2, [r1, #568]	; 0x238
   34036:	6922      	ldr	r2, [r4, #16]
   34038:	f8c4 3854 	str.w	r3, [r4, #2132]	; 0x854
   3403c:	0852      	lsrs	r2, r2, #1
   3403e:	f44f 7580 	mov.w	r5, #256	; 0x100
   34042:	f884 383c 	strb.w	r3, [r4, #2108]	; 0x83c
   34046:	f8c4 3838 	str.w	r3, [r4, #2104]	; 0x838
   3404a:	f8c4 3844 	str.w	r3, [r4, #2116]	; 0x844
   3404e:	f8c4 3840 	str.w	r3, [r4, #2112]	; 0x840
   34052:	f8c4 3830 	str.w	r3, [r4, #2096]	; 0x830
   34056:	f8c4 3828 	str.w	r3, [r4, #2088]	; 0x828
   3405a:	6223      	str	r3, [r4, #32]
   3405c:	f8c4 385c 	str.w	r3, [r4, #2140]	; 0x85c
   34060:	9201      	str	r2, [sp, #4]
   34062:	2301      	movs	r3, #1
   34064:	f604 0228 	addw	r2, r4, #2088	; 0x828
   34068:	b2c0      	uxtb	r0, r0
   3406a:	f8a4 582c 	strh.w	r5, [r4, #2092]	; 0x82c
   3406e:	a901      	add	r1, sp, #4
   34070:	f88d 300c 	strb.w	r3, [sp, #12]
   34074:	f002 fe16 	bl	36ca4 <am_hal_cmdq_init>
   34078:	6863      	ldr	r3, [r4, #4]
   3407a:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   3407e:	3350      	adds	r3, #80	; 0x50
   34080:	2202      	movs	r2, #2
   34082:	031b      	lsls	r3, r3, #12
   34084:	b9c0      	cbnz	r0, 340b8 <am_hal_iom_enable+0xe0>
   34086:	6225      	str	r5, [r4, #32]
   34088:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
   3408c:	78e3      	ldrb	r3, [r4, #3]
   3408e:	2000      	movs	r0, #0
   34090:	f043 0302 	orr.w	r3, r3, #2
   34094:	70e3      	strb	r3, [r4, #3]
   34096:	b005      	add	sp, #20
   34098:	bd30      	pop	{r4, r5, pc}
   3409a:	2002      	movs	r0, #2
   3409c:	b005      	add	sp, #20
   3409e:	bd30      	pop	{r4, r5, pc}
   340a0:	2000      	movs	r0, #0
   340a2:	b005      	add	sp, #20
   340a4:	bd30      	pop	{r4, r5, pc}
   340a6:	2009      	movs	r0, #9
   340a8:	b005      	add	sp, #20
   340aa:	bd30      	pop	{r4, r5, pc}
   340ac:	2301      	movs	r3, #1
   340ae:	f8c1 311c 	str.w	r3, [r1, #284]	; 0x11c
   340b2:	e7b7      	b.n	34024 <am_hal_iom_enable+0x4c>
   340b4:	2002      	movs	r0, #2
   340b6:	4770      	bx	lr
   340b8:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
   340bc:	e7ee      	b.n	3409c <am_hal_iom_enable+0xc4>
   340be:	bf00      	nop
   340c0:	01123456 	.word	0x01123456
   340c4:	00800040 	.word	0x00800040

000340c8 <am_hal_iom_disable>:
   340c8:	b538      	push	{r3, r4, r5, lr}
   340ca:	b358      	cbz	r0, 34124 <am_hal_iom_disable+0x5c>
   340cc:	6803      	ldr	r3, [r0, #0]
   340ce:	4a18      	ldr	r2, [pc, #96]	; (34130 <am_hal_iom_disable+0x68>)
   340d0:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   340d4:	4293      	cmp	r3, r2
   340d6:	4604      	mov	r4, r0
   340d8:	d124      	bne.n	34124 <am_hal_iom_disable+0x5c>
   340da:	78c5      	ldrb	r5, [r0, #3]
   340dc:	f015 0502 	ands.w	r5, r5, #2
   340e0:	d01e      	beq.n	34120 <am_hal_iom_disable+0x58>
   340e2:	6a45      	ldr	r5, [r0, #36]	; 0x24
   340e4:	bb0d      	cbnz	r5, 3412a <am_hal_iom_disable+0x62>
   340e6:	6843      	ldr	r3, [r0, #4]
   340e8:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   340ec:	3350      	adds	r3, #80	; 0x50
   340ee:	031b      	lsls	r3, r3, #12
   340f0:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   340f4:	f365 0200 	bfi	r2, r5, #0, #1
   340f8:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   340fc:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   34100:	f365 1204 	bfi	r2, r5, #4, #1
   34104:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   34108:	f8d0 0828 	ldr.w	r0, [r0, #2088]	; 0x828
   3410c:	b120      	cbz	r0, 34118 <am_hal_iom_disable+0x50>
   3410e:	2101      	movs	r1, #1
   34110:	f002 fe68 	bl	36de4 <am_hal_cmdq_term>
   34114:	f8c4 5828 	str.w	r5, [r4, #2088]	; 0x828
   34118:	78e3      	ldrb	r3, [r4, #3]
   3411a:	f36f 0341 	bfc	r3, #1, #1
   3411e:	70e3      	strb	r3, [r4, #3]
   34120:	4628      	mov	r0, r5
   34122:	bd38      	pop	{r3, r4, r5, pc}
   34124:	2502      	movs	r5, #2
   34126:	4628      	mov	r0, r5
   34128:	bd38      	pop	{r3, r4, r5, pc}
   3412a:	2503      	movs	r5, #3
   3412c:	e7f8      	b.n	34120 <am_hal_iom_disable+0x58>
   3412e:	bf00      	nop
   34130:	01123456 	.word	0x01123456

00034134 <am_hal_iom_power_ctrl>:
   34134:	2800      	cmp	r0, #0
   34136:	f000 80c5 	beq.w	342c4 <am_hal_iom_power_ctrl+0x190>
   3413a:	b530      	push	{r4, r5, lr}
   3413c:	6803      	ldr	r3, [r0, #0]
   3413e:	4604      	mov	r4, r0
   34140:	4873      	ldr	r0, [pc, #460]	; (34310 <am_hal_iom_power_ctrl+0x1dc>)
   34142:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   34146:	4283      	cmp	r3, r0
   34148:	b083      	sub	sp, #12
   3414a:	d169      	bne.n	34220 <am_hal_iom_power_ctrl+0xec>
   3414c:	2900      	cmp	r1, #0
   3414e:	d06d      	beq.n	3422c <am_hal_iom_power_ctrl+0xf8>
   34150:	3901      	subs	r1, #1
   34152:	2901      	cmp	r1, #1
   34154:	d867      	bhi.n	34226 <am_hal_iom_power_ctrl+0xf2>
   34156:	78e3      	ldrb	r3, [r4, #3]
   34158:	6860      	ldr	r0, [r4, #4]
   3415a:	f013 0f02 	tst.w	r3, #2
   3415e:	f500 2380 	add.w	r3, r0, #262144	; 0x40000
   34162:	f103 0350 	add.w	r3, r3, #80	; 0x50
   34166:	ea4f 3303 	mov.w	r3, r3, lsl #12
   3416a:	d00a      	beq.n	34182 <am_hal_iom_power_ctrl+0x4e>
   3416c:	f8d3 1248 	ldr.w	r1, [r3, #584]	; 0x248
   34170:	f001 0106 	and.w	r1, r1, #6
   34174:	2904      	cmp	r1, #4
   34176:	f040 80ba 	bne.w	342ee <am_hal_iom_power_ctrl+0x1ba>
   3417a:	6a61      	ldr	r1, [r4, #36]	; 0x24
   3417c:	2900      	cmp	r1, #0
   3417e:	f040 80b6 	bne.w	342ee <am_hal_iom_power_ctrl+0x1ba>
   34182:	b3d2      	cbz	r2, 341fa <am_hal_iom_power_ctrl+0xc6>
   34184:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
   34188:	f8d3 2118 	ldr.w	r2, [r3, #280]	; 0x118
   3418c:	f8c4 2874 	str.w	r2, [r4, #2164]	; 0x874
   34190:	f8c4 186c 	str.w	r1, [r4, #2156]	; 0x86c
   34194:	f8d3 111c 	ldr.w	r1, [r3, #284]	; 0x11c
   34198:	f8d3 2228 	ldr.w	r2, [r3, #552]	; 0x228
   3419c:	f8c4 287c 	str.w	r2, [r4, #2172]	; 0x87c
   341a0:	f8c4 1878 	str.w	r1, [r4, #2168]	; 0x878
   341a4:	f8d3 122c 	ldr.w	r1, [r3, #556]	; 0x22c
   341a8:	f8d3 2234 	ldr.w	r2, [r3, #564]	; 0x234
   341ac:	f8c4 2884 	str.w	r2, [r4, #2180]	; 0x884
   341b0:	f8c4 1880 	str.w	r1, [r4, #2176]	; 0x880
   341b4:	f8d3 123c 	ldr.w	r1, [r3, #572]	; 0x23c
   341b8:	f8d3 2240 	ldr.w	r2, [r3, #576]	; 0x240
   341bc:	f8c4 288c 	str.w	r2, [r4, #2188]	; 0x88c
   341c0:	f8c4 1888 	str.w	r1, [r4, #2184]	; 0x888
   341c4:	f8d3 1244 	ldr.w	r1, [r3, #580]	; 0x244
   341c8:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
   341cc:	f8c4 2894 	str.w	r2, [r4, #2196]	; 0x894
   341d0:	f8c4 1890 	str.w	r1, [r4, #2192]	; 0x890
   341d4:	f8d3 12c0 	ldr.w	r1, [r3, #704]	; 0x2c0
   341d8:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   341dc:	f8c4 289c 	str.w	r2, [r4, #2204]	; 0x89c
   341e0:	f8c4 1898 	str.w	r1, [r4, #2200]	; 0x898
   341e4:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
   341e8:	f8d3 2228 	ldr.w	r2, [r3, #552]	; 0x228
   341ec:	f8c4 1870 	str.w	r1, [r4, #2160]	; 0x870
   341f0:	07d1      	lsls	r1, r2, #31
   341f2:	d472      	bmi.n	342da <am_hal_iom_power_ctrl+0x1a6>
   341f4:	2201      	movs	r2, #1
   341f6:	f884 2868 	strb.w	r2, [r4, #2152]	; 0x868
   341fa:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   341fe:	f36f 0200 	bfc	r2, #0, #1
   34202:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   34206:	f8d3 211c 	ldr.w	r2, [r3, #284]	; 0x11c
   3420a:	3001      	adds	r0, #1
   3420c:	f36f 1204 	bfc	r2, #4, #1
   34210:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
   34214:	b2c0      	uxtb	r0, r0
   34216:	f002 f903 	bl	36420 <am_hal_pwrctrl_periph_disable>
   3421a:	2000      	movs	r0, #0
   3421c:	b003      	add	sp, #12
   3421e:	bd30      	pop	{r4, r5, pc}
   34220:	2002      	movs	r0, #2
   34222:	b003      	add	sp, #12
   34224:	bd30      	pop	{r4, r5, pc}
   34226:	2006      	movs	r0, #6
   34228:	b003      	add	sp, #12
   3422a:	bd30      	pop	{r4, r5, pc}
   3422c:	2a00      	cmp	r2, #0
   3422e:	d04b      	beq.n	342c8 <am_hal_iom_power_ctrl+0x194>
   34230:	f894 3868 	ldrb.w	r3, [r4, #2152]	; 0x868
   34234:	2b00      	cmp	r3, #0
   34236:	d05c      	beq.n	342f2 <am_hal_iom_power_ctrl+0x1be>
   34238:	6860      	ldr	r0, [r4, #4]
   3423a:	3001      	adds	r0, #1
   3423c:	b2c0      	uxtb	r0, r0
   3423e:	f002 f81f 	bl	36280 <am_hal_pwrctrl_periph_enable>
   34242:	6863      	ldr	r3, [r4, #4]
   34244:	f8d4 086c 	ldr.w	r0, [r4, #2156]	; 0x86c
   34248:	f8d4 1874 	ldr.w	r1, [r4, #2164]	; 0x874
   3424c:	f8d4 287c 	ldr.w	r2, [r4, #2172]	; 0x87c
   34250:	f8d4 5870 	ldr.w	r5, [r4, #2160]	; 0x870
   34254:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   34258:	3350      	adds	r3, #80	; 0x50
   3425a:	031b      	lsls	r3, r3, #12
   3425c:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
   34260:	f8d4 0880 	ldr.w	r0, [r4, #2176]	; 0x880
   34264:	f8c3 1118 	str.w	r1, [r3, #280]	; 0x118
   34268:	f8d4 1884 	ldr.w	r1, [r4, #2180]	; 0x884
   3426c:	f8c3 022c 	str.w	r0, [r3, #556]	; 0x22c
   34270:	f8d4 0888 	ldr.w	r0, [r4, #2184]	; 0x888
   34274:	f8c3 1234 	str.w	r1, [r3, #564]	; 0x234
   34278:	f8d4 188c 	ldr.w	r1, [r4, #2188]	; 0x88c
   3427c:	f8c3 023c 	str.w	r0, [r3, #572]	; 0x23c
   34280:	f8d4 0890 	ldr.w	r0, [r4, #2192]	; 0x890
   34284:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
   34288:	f8d4 1894 	ldr.w	r1, [r4, #2196]	; 0x894
   3428c:	f8c3 0244 	str.w	r0, [r3, #580]	; 0x244
   34290:	f8d4 0898 	ldr.w	r0, [r4, #2200]	; 0x898
   34294:	f8c3 1280 	str.w	r1, [r3, #640]	; 0x280
   34298:	f8d4 189c 	ldr.w	r1, [r4, #2204]	; 0x89c
   3429c:	f8c3 02c0 	str.w	r0, [r3, #704]	; 0x2c0
   342a0:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
   342a4:	f022 0001 	bic.w	r0, r2, #1
   342a8:	f8d4 1878 	ldr.w	r1, [r4, #2168]	; 0x878
   342ac:	f8c3 5210 	str.w	r5, [r3, #528]	; 0x210
   342b0:	07d2      	lsls	r2, r2, #31
   342b2:	f8c3 0228 	str.w	r0, [r3, #552]	; 0x228
   342b6:	f8c3 111c 	str.w	r1, [r3, #284]	; 0x11c
   342ba:	d41c      	bmi.n	342f6 <am_hal_iom_power_ctrl+0x1c2>
   342bc:	2000      	movs	r0, #0
   342be:	f884 0868 	strb.w	r0, [r4, #2152]	; 0x868
   342c2:	e7ae      	b.n	34222 <am_hal_iom_power_ctrl+0xee>
   342c4:	2002      	movs	r0, #2
   342c6:	4770      	bx	lr
   342c8:	6860      	ldr	r0, [r4, #4]
   342ca:	9201      	str	r2, [sp, #4]
   342cc:	3001      	adds	r0, #1
   342ce:	b2c0      	uxtb	r0, r0
   342d0:	f001 ffd6 	bl	36280 <am_hal_pwrctrl_periph_enable>
   342d4:	9a01      	ldr	r2, [sp, #4]
   342d6:	4610      	mov	r0, r2
   342d8:	e7a3      	b.n	34222 <am_hal_iom_power_ctrl+0xee>
   342da:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
   342de:	f002 fd65 	bl	36dac <am_hal_cmdq_disable>
   342e2:	6860      	ldr	r0, [r4, #4]
   342e4:	f500 2380 	add.w	r3, r0, #262144	; 0x40000
   342e8:	3350      	adds	r3, #80	; 0x50
   342ea:	031b      	lsls	r3, r3, #12
   342ec:	e782      	b.n	341f4 <am_hal_iom_power_ctrl+0xc0>
   342ee:	2003      	movs	r0, #3
   342f0:	e797      	b.n	34222 <am_hal_iom_power_ctrl+0xee>
   342f2:	2007      	movs	r0, #7
   342f4:	e795      	b.n	34222 <am_hal_iom_power_ctrl+0xee>
   342f6:	6a62      	ldr	r2, [r4, #36]	; 0x24
   342f8:	b92a      	cbnz	r2, 34306 <am_hal_iom_power_ctrl+0x1d2>
   342fa:	f8d3 222c 	ldr.w	r2, [r3, #556]	; 0x22c
   342fe:	f503 730b 	add.w	r3, r3, #556	; 0x22c
   34302:	e9c2 3200 	strd	r3, r2, [r2]
   34306:	f8d4 0828 	ldr.w	r0, [r4, #2088]	; 0x828
   3430a:	f002 fd23 	bl	36d54 <am_hal_cmdq_enable>
   3430e:	e7d5      	b.n	342bc <am_hal_iom_power_ctrl+0x188>
   34310:	01123456 	.word	0x01123456

00034314 <am_hal_iom_configure>:
   34314:	b380      	cbz	r0, 34378 <am_hal_iom_configure+0x64>
   34316:	6803      	ldr	r3, [r0, #0]
   34318:	4aa1      	ldr	r2, [pc, #644]	; (345a0 <am_hal_iom_configure+0x28c>)
   3431a:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   3431e:	4293      	cmp	r3, r2
   34320:	d12a      	bne.n	34378 <am_hal_iom_configure+0x64>
   34322:	2900      	cmp	r1, #0
   34324:	f000 810c 	beq.w	34540 <am_hal_iom_configure+0x22c>
   34328:	6843      	ldr	r3, [r0, #4]
   3432a:	2b07      	cmp	r3, #7
   3432c:	f200 8108 	bhi.w	34540 <am_hal_iom_configure+0x22c>
   34330:	78c2      	ldrb	r2, [r0, #3]
   34332:	0792      	lsls	r2, r2, #30
   34334:	f100 8106 	bmi.w	34544 <am_hal_iom_configure+0x230>
   34338:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3433c:	f503 2380 	add.w	r3, r3, #262144	; 0x40000
   34340:	3350      	adds	r3, #80	; 0x50
   34342:	780a      	ldrb	r2, [r1, #0]
   34344:	7202      	strb	r2, [r0, #8]
   34346:	031b      	lsls	r3, r3, #12
   34348:	f241 0410 	movw	r4, #4112	; 0x1010
   3434c:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
   34350:	b1a2      	cbz	r2, 3437c <am_hal_iom_configure+0x68>
   34352:	2a01      	cmp	r2, #1
   34354:	f040 80f8 	bne.w	34548 <am_hal_iom_configure+0x234>
   34358:	684a      	ldr	r2, [r1, #4]
   3435a:	4c92      	ldr	r4, [pc, #584]	; (345a4 <am_hal_iom_configure+0x290>)
   3435c:	42a2      	cmp	r2, r4
   3435e:	f000 8114 	beq.w	3458a <am_hal_iom_configure+0x276>
   34362:	4c91      	ldr	r4, [pc, #580]	; (345a8 <am_hal_iom_configure+0x294>)
   34364:	42a2      	cmp	r2, r4
   34366:	f000 810b 	beq.w	34580 <am_hal_iom_configure+0x26c>
   3436a:	4c90      	ldr	r4, [pc, #576]	; (345ac <am_hal_iom_configure+0x298>)
   3436c:	42a2      	cmp	r2, r4
   3436e:	f000 8102 	beq.w	34576 <am_hal_iom_configure+0x262>
   34372:	2006      	movs	r0, #6
   34374:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34378:	2002      	movs	r0, #2
   3437a:	4770      	bx	lr
   3437c:	7a0d      	ldrb	r5, [r1, #8]
   3437e:	2d03      	cmp	r5, #3
   34380:	d8f7      	bhi.n	34372 <am_hal_iom_configure+0x5e>
   34382:	684a      	ldr	r2, [r1, #4]
   34384:	4c8a      	ldr	r4, [pc, #552]	; (345b0 <am_hal_iom_configure+0x29c>)
   34386:	42a2      	cmp	r2, r4
   34388:	d8f3      	bhi.n	34372 <am_hal_iom_configure+0x5e>
   3438a:	2a00      	cmp	r2, #0
   3438c:	f000 80e8 	beq.w	34560 <am_hal_iom_configure+0x24c>
   34390:	4c88      	ldr	r4, [pc, #544]	; (345b4 <am_hal_iom_configure+0x2a0>)
   34392:	fbb4 fef2 	udiv	lr, r4, r2
   34396:	fb02 441e 	mls	r4, r2, lr, r4
   3439a:	2c00      	cmp	r4, #0
   3439c:	bf18      	it	ne
   3439e:	f10e 0e01 	addne.w	lr, lr, #1
   343a2:	f1ce 0400 	rsb	r4, lr, #0
   343a6:	ea04 040e 	and.w	r4, r4, lr
   343aa:	fab4 f484 	clz	r4, r4
   343ae:	f1c4 041f 	rsb	r4, r4, #31
   343b2:	2c06      	cmp	r4, #6
   343b4:	f241 66e2 	movw	r6, #5858	; 0x16e2
   343b8:	bfa8      	it	ge
   343ba:	2406      	movge	r4, #6
   343bc:	42b2      	cmp	r2, r6
   343be:	f240 80c5 	bls.w	3454c <am_hal_iom_configure+0x238>
   343c2:	4e7d      	ldr	r6, [pc, #500]	; (345b8 <am_hal_iom_configure+0x2a4>)
   343c4:	42b2      	cmp	r2, r6
   343c6:	f0c0 80e5 	bcc.w	34594 <am_hal_iom_configure+0x280>
   343ca:	4e79      	ldr	r6, [pc, #484]	; (345b0 <am_hal_iom_configure+0x29c>)
   343cc:	ebb2 0c06 	subs.w	ip, r2, r6
   343d0:	bf18      	it	ne
   343d2:	f04f 0c01 	movne.w	ip, #1
   343d6:	ea4f 094c 	mov.w	r9, ip, lsl #1
   343da:	f109 0901 	add.w	r9, r9, #1
   343de:	fa09 f604 	lsl.w	r6, r9, r4
   343e2:	fbbe faf6 	udiv	sl, lr, r6
   343e6:	fb06 e61a 	mls	r6, r6, sl, lr
   343ea:	2e00      	cmp	r6, #0
   343ec:	bf18      	it	ne
   343ee:	f10a 0a01 	addne.w	sl, sl, #1
   343f2:	faba f78a 	clz	r7, sl
   343f6:	f1c7 061f 	rsb	r6, r7, #31
   343fa:	2e07      	cmp	r6, #7
   343fc:	f240 80b2 	bls.w	34564 <am_hal_iom_configure+0x250>
   34400:	3c07      	subs	r4, #7
   34402:	4434      	add	r4, r6
   34404:	1c66      	adds	r6, r4, #1
   34406:	2e07      	cmp	r6, #7
   34408:	f200 80aa 	bhi.w	34560 <am_hal_iom_configure+0x24c>
   3440c:	f1c7 0718 	rsb	r7, r7, #24
   34410:	f04f 0801 	mov.w	r8, #1
   34414:	fa08 f807 	lsl.w	r8, r8, r7
   34418:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
   3441c:	fa2a f707 	lsr.w	r7, sl, r7
   34420:	ea08 080a 	and.w	r8, r8, sl
   34424:	f1b8 0f00 	cmp.w	r8, #0
   34428:	bf0c      	ite	eq
   3442a:	46ba      	moveq	sl, r7
   3442c:	f107 0a01 	addne.w	sl, r7, #1
   34430:	4f62      	ldr	r7, [pc, #392]	; (345bc <am_hal_iom_configure+0x2a8>)
   34432:	42ba      	cmp	r2, r7
   34434:	f080 8098 	bcs.w	34568 <am_hal_iom_configure+0x254>
   34438:	2701      	movs	r7, #1
   3443a:	40a7      	lsls	r7, r4
   3443c:	45be      	cmp	lr, r7
   3443e:	f000 8093 	beq.w	34568 <am_hal_iom_configure+0x254>
   34442:	f10a 37ff 	add.w	r7, sl, #4294967295	; 0xffffffff
   34446:	46d3      	mov	fp, sl
   34448:	f44f 5880 	mov.w	r8, #4096	; 0x1000
   3444c:	ea4f 0e65 	mov.w	lr, r5, asr #1
   34450:	f1be 0f01 	cmp.w	lr, #1
   34454:	ea4f 2ccc 	mov.w	ip, ip, lsl #11
   34458:	bf08      	it	eq
   3445a:	f1aa 0e02 	subeq.w	lr, sl, #2
   3445e:	ea4c 2c06 	orr.w	ip, ip, r6, lsl #8
   34462:	bf14      	ite	ne
   34464:	ea4f 0e57 	movne.w	lr, r7, lsr #1
   34468:	ea4f 0e5e 	moveq.w	lr, lr, lsr #1
   3446c:	ea4c 0c08 	orr.w	ip, ip, r8
   34470:	fa09 f404 	lsl.w	r4, r9, r4
   34474:	ea4c 6c07 	orr.w	ip, ip, r7, lsl #24
   34478:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
   3447c:	4f4d      	ldr	r7, [pc, #308]	; (345b4 <am_hal_iom_configure+0x2a0>)
   3447e:	fb0b f404 	mul.w	r4, fp, r4
   34482:	f40e 0e7f 	and.w	lr, lr, #16711680	; 0xff0000
   34486:	fbb7 f9f4 	udiv	r9, r7, r4
   3448a:	ea4c 0c0e 	orr.w	ip, ip, lr
   3448e:	fb04 7819 	mls	r8, r4, r9, r7
   34492:	ea4f 2e06 	mov.w	lr, r6, lsl #8
   34496:	0864      	lsrs	r4, r4, #1
   34498:	4e49      	ldr	r6, [pc, #292]	; (345c0 <am_hal_iom_configure+0x2ac>)
   3449a:	4544      	cmp	r4, r8
   3449c:	bf2c      	ite	cs
   3449e:	464f      	movcs	r7, r9
   344a0:	f109 0701 	addcc.w	r7, r9, #1
   344a4:	f8df 8140 	ldr.w	r8, [pc, #320]	; 345e8 <am_hal_iom_configure+0x2d4>
   344a8:	fba6 6407 	umull	r6, r4, r6, r7
   344ac:	4e45      	ldr	r6, [pc, #276]	; (345c4 <am_hal_iom_configure+0x2b0>)
   344ae:	0c24      	lsrs	r4, r4, #16
   344b0:	4547      	cmp	r7, r8
   344b2:	fb06 7614 	mls	r6, r6, r4, r7
   344b6:	d905      	bls.n	344c4 <am_hal_iom_configure+0x1b0>
   344b8:	1e67      	subs	r7, r4, #1
   344ba:	403c      	ands	r4, r7
   344bc:	4334      	orrs	r4, r6
   344be:	d101      	bne.n	344c4 <am_hal_iom_configure+0x1b0>
   344c0:	f44e 6c00 	orr.w	ip, lr, #2048	; 0x800
   344c4:	f04c 0401 	orr.w	r4, ip, #1
   344c8:	f8c3 5280 	str.w	r5, [r3, #640]	; 0x280
   344cc:	f8c3 4118 	str.w	r4, [r3, #280]	; 0x118
   344d0:	e9d1 4303 	ldrd	r4, r3, [r1, #12]
   344d4:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
   344d8:	4933      	ldr	r1, [pc, #204]	; (345a8 <am_hal_iom_configure+0x294>)
   344da:	f8c0 5860 	str.w	r5, [r0, #2144]	; 0x860
   344de:	fbb1 f2f2 	udiv	r2, r1, r2
   344e2:	60c4      	str	r4, [r0, #12]
   344e4:	f8c0 2864 	str.w	r2, [r0, #2148]	; 0x864
   344e8:	6103      	str	r3, [r0, #16]
   344ea:	b31c      	cbz	r4, 34534 <am_hal_iom_configure+0x220>
   344ec:	4936      	ldr	r1, [pc, #216]	; (345c8 <am_hal_iom_configure+0x2b4>)
   344ee:	eb04 0583 	add.w	r5, r4, r3, lsl #2
   344f2:	428d      	cmp	r5, r1
   344f4:	bf94      	ite	ls
   344f6:	2101      	movls	r1, #1
   344f8:	2100      	movhi	r1, #0
   344fa:	ea4f 0283 	mov.w	r2, r3, lsl #2
   344fe:	f880 18a4 	strb.w	r1, [r0, #2212]	; 0x8a4
   34502:	d909      	bls.n	34518 <am_hal_iom_configure+0x204>
   34504:	f004 030f 	and.w	r3, r4, #15
   34508:	1ad3      	subs	r3, r2, r3
   3450a:	340f      	adds	r4, #15
   3450c:	091b      	lsrs	r3, r3, #4
   3450e:	f024 040f 	bic.w	r4, r4, #15
   34512:	009b      	lsls	r3, r3, #2
   34514:	e9c0 4303 	strd	r4, r3, [r0, #12]
   34518:	3b08      	subs	r3, #8
   3451a:	f246 015f 	movw	r1, #24671	; 0x605f
   3451e:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
   34522:	ea4f 0283 	mov.w	r2, r3, lsl #2
   34526:	d316      	bcc.n	34556 <am_hal_iom_configure+0x242>
   34528:	4b28      	ldr	r3, [pc, #160]	; (345cc <am_hal_iom_configure+0x2b8>)
   3452a:	fba3 3202 	umull	r3, r2, r3, r2
   3452e:	0992      	lsrs	r2, r2, #6
   34530:	f8c0 2858 	str.w	r2, [r0, #2136]	; 0x858
   34534:	2300      	movs	r3, #0
   34536:	f8c0 38a0 	str.w	r3, [r0, #2208]	; 0x8a0
   3453a:	4618      	mov	r0, r3
   3453c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34540:	2006      	movs	r0, #6
   34542:	4770      	bx	lr
   34544:	2007      	movs	r0, #7
   34546:	4770      	bx	lr
   34548:	2005      	movs	r0, #5
   3454a:	e713      	b.n	34374 <am_hal_iom_configure+0x60>
   3454c:	f04f 0903 	mov.w	r9, #3
   34550:	f04f 0c01 	mov.w	ip, #1
   34554:	e743      	b.n	343de <am_hal_iom_configure+0xca>
   34556:	f44f 7380 	mov.w	r3, #256	; 0x100
   3455a:	f8c0 3858 	str.w	r3, [r0, #2136]	; 0x858
   3455e:	e7e9      	b.n	34534 <am_hal_iom_configure+0x220>
   34560:	2401      	movs	r4, #1
   34562:	e7b1      	b.n	344c8 <am_hal_iom_configure+0x1b4>
   34564:	1c66      	adds	r6, r4, #1
   34566:	e763      	b.n	34430 <am_hal_iom_configure+0x11c>
   34568:	f10a 37ff 	add.w	r7, sl, #4294967295	; 0xffffffff
   3456c:	f04f 0b01 	mov.w	fp, #1
   34570:	f04f 0800 	mov.w	r8, #0
   34574:	e76a      	b.n	3444c <am_hal_iom_configure+0x138>
   34576:	4c16      	ldr	r4, [pc, #88]	; (345d0 <am_hal_iom_configure+0x2bc>)
   34578:	f8c3 42c0 	str.w	r4, [r3, #704]	; 0x2c0
   3457c:	4c15      	ldr	r4, [pc, #84]	; (345d4 <am_hal_iom_configure+0x2c0>)
   3457e:	e7a5      	b.n	344cc <am_hal_iom_configure+0x1b8>
   34580:	4c15      	ldr	r4, [pc, #84]	; (345d8 <am_hal_iom_configure+0x2c4>)
   34582:	f8c3 42c0 	str.w	r4, [r3, #704]	; 0x2c0
   34586:	4c15      	ldr	r4, [pc, #84]	; (345dc <am_hal_iom_configure+0x2c8>)
   34588:	e7a0      	b.n	344cc <am_hal_iom_configure+0x1b8>
   3458a:	4c15      	ldr	r4, [pc, #84]	; (345e0 <am_hal_iom_configure+0x2cc>)
   3458c:	f8c3 42c0 	str.w	r4, [r3, #704]	; 0x2c0
   34590:	4c14      	ldr	r4, [pc, #80]	; (345e4 <am_hal_iom_configure+0x2d0>)
   34592:	e79b      	b.n	344cc <am_hal_iom_configure+0x1b8>
   34594:	f04f 0901 	mov.w	r9, #1
   34598:	f04f 0c00 	mov.w	ip, #0
   3459c:	e71f      	b.n	343de <am_hal_iom_configure+0xca>
   3459e:	bf00      	nop
   345a0:	01123456 	.word	0x01123456
   345a4:	00061a80 	.word	0x00061a80
   345a8:	000f4240 	.word	0x000f4240
   345ac:	000186a0 	.word	0x000186a0
   345b0:	02dc6c00 	.word	0x02dc6c00
   345b4:	05b8d800 	.word	0x05b8d800
   345b8:	01e84800 	.word	0x01e84800
   345bc:	016e3600 	.word	0x016e3600
   345c0:	431bde83 	.word	0x431bde83
   345c4:	0003d090 	.word	0x0003d090
   345c8:	1005ffff 	.word	0x1005ffff
   345cc:	aaaaaaab 	.word	0xaaaaaaab
   345d0:	0003f070 	.word	0x0003f070
   345d4:	773b1301 	.word	0x773b1301
   345d8:	00023040 	.word	0x00023040
   345dc:	0b051301 	.word	0x0b051301
   345e0:	0003f270 	.word	0x0003f270
   345e4:	1d0e1301 	.word	0x1d0e1301
   345e8:	0003d08f 	.word	0x0003d08f

000345ec <am_hal_iom_blocking_transfer>:
   345ec:	2800      	cmp	r0, #0
   345ee:	f000 813e 	beq.w	3486e <am_hal_iom_blocking_transfer+0x282>
   345f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   345f6:	6803      	ldr	r3, [r0, #0]
   345f8:	4abd      	ldr	r2, [pc, #756]	; (348f0 <am_hal_iom_blocking_transfer+0x304>)
   345fa:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   345fe:	4293      	cmp	r3, r2
   34600:	b087      	sub	sp, #28
   34602:	4606      	mov	r6, r0
   34604:	f040 8117 	bne.w	34836 <am_hal_iom_blocking_transfer+0x24a>
   34608:	460d      	mov	r5, r1
   3460a:	2900      	cmp	r1, #0
   3460c:	f000 811c 	beq.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34610:	f891 8014 	ldrb.w	r8, [r1, #20]
   34614:	f1b8 0f01 	cmp.w	r8, #1
   34618:	f200 811f 	bhi.w	3485a <am_hal_iom_blocking_transfer+0x26e>
   3461c:	f8d1 9010 	ldr.w	r9, [r1, #16]
   34620:	f1b9 0f00 	cmp.w	r9, #0
   34624:	f000 8115 	beq.w	34852 <am_hal_iom_blocking_transfer+0x266>
   34628:	f8d5 a004 	ldr.w	sl, [r5, #4]
   3462c:	f1ba 0f05 	cmp.w	sl, #5
   34630:	f200 810a 	bhi.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34634:	ea4f 01ca 	mov.w	r1, sl, lsl #3
   34638:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3463c:	f1a1 0420 	sub.w	r4, r1, #32
   34640:	f1c1 0020 	rsb	r0, r1, #32
   34644:	fa03 f201 	lsl.w	r2, r3, r1
   34648:	fa03 f404 	lsl.w	r4, r3, r4
   3464c:	fa23 f000 	lsr.w	r0, r3, r0
   34650:	408b      	lsls	r3, r1
   34652:	68a9      	ldr	r1, [r5, #8]
   34654:	9102      	str	r1, [sp, #8]
   34656:	400b      	ands	r3, r1
   34658:	4322      	orrs	r2, r4
   3465a:	68e9      	ldr	r1, [r5, #12]
   3465c:	9103      	str	r1, [sp, #12]
   3465e:	4302      	orrs	r2, r0
   34660:	400a      	ands	r2, r1
   34662:	4313      	orrs	r3, r2
   34664:	f040 80f0 	bne.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34668:	f1b9 0f00 	cmp.w	r9, #0
   3466c:	f000 80fa 	beq.w	34864 <am_hal_iom_blocking_transfer+0x278>
   34670:	f1b8 0f00 	cmp.w	r8, #0
   34674:	f000 80e4 	beq.w	34840 <am_hal_iom_blocking_transfer+0x254>
   34678:	69eb      	ldr	r3, [r5, #28]
   3467a:	2b00      	cmp	r3, #0
   3467c:	f000 80e4 	beq.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34680:	7a33      	ldrb	r3, [r6, #8]
   34682:	2b01      	cmp	r3, #1
   34684:	d004      	beq.n	34690 <am_hal_iom_blocking_transfer+0xa4>
   34686:	b93b      	cbnz	r3, 34698 <am_hal_iom_blocking_transfer+0xac>
   34688:	682b      	ldr	r3, [r5, #0]
   3468a:	2b04      	cmp	r3, #4
   3468c:	f200 80dc 	bhi.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34690:	f5b9 5f80 	cmp.w	r9, #4096	; 0x1000
   34694:	f080 80d8 	bcs.w	34848 <am_hal_iom_blocking_transfer+0x25c>
   34698:	f896 382c 	ldrb.w	r3, [r6, #2092]	; 0x82c
   3469c:	2b02      	cmp	r3, #2
   3469e:	f000 80dc 	beq.w	3485a <am_hal_iom_blocking_transfer+0x26e>
   346a2:	e9d5 3706 	ldrd	r3, r7, [r5, #24]
   346a6:	f04f 0b01 	mov.w	fp, #1
   346aa:	f8cd b000 	str.w	fp, [sp]
   346ae:	6874      	ldr	r4, [r6, #4]
   346b0:	9404      	str	r4, [sp, #16]
   346b2:	f8d6 0860 	ldr.w	r0, [r6, #2144]	; 0x860
   346b6:	f895 4020 	ldrb.w	r4, [r5, #32]
   346ba:	9405      	str	r4, [sp, #20]
   346bc:	f1b8 0f00 	cmp.w	r8, #0
   346c0:	bf08      	it	eq
   346c2:	461f      	moveq	r7, r3
   346c4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   346c8:	2300      	movs	r3, #0
   346ca:	f106 0124 	add.w	r1, r6, #36	; 0x24
   346ce:	f000 fe3f 	bl	35350 <am_hal_delay_us_status_check>
   346d2:	4603      	mov	r3, r0
   346d4:	2800      	cmp	r0, #0
   346d6:	f040 80af 	bne.w	34838 <am_hal_iom_blocking_transfer+0x24c>
   346da:	9b04      	ldr	r3, [sp, #16]
   346dc:	f8cd b000 	str.w	fp, [sp]
   346e0:	f503 2480 	add.w	r4, r3, #262144	; 0x40000
   346e4:	3450      	adds	r4, #80	; 0x50
   346e6:	0324      	lsls	r4, r4, #12
   346e8:	f504 7b12 	add.w	fp, r4, #584	; 0x248
   346ec:	2304      	movs	r3, #4
   346ee:	f8d6 0860 	ldr.w	r0, [r6, #2144]	; 0x860
   346f2:	2206      	movs	r2, #6
   346f4:	4659      	mov	r1, fp
   346f6:	f000 fe2b 	bl	35350 <am_hal_delay_us_status_check>
   346fa:	4603      	mov	r3, r0
   346fc:	2800      	cmp	r0, #0
   346fe:	f040 809b 	bne.w	34838 <am_hal_iom_blocking_transfer+0x24c>
   34702:	f8d4 2200 	ldr.w	r2, [r4, #512]	; 0x200
   34706:	9204      	str	r2, [sp, #16]
   34708:	f8c4 0200 	str.w	r0, [r4, #512]	; 0x200
   3470c:	f8d4 2218 	ldr.w	r2, [r4, #536]	; 0x218
   34710:	f360 0200 	bfi	r2, r0, #0, #1
   34714:	f8c4 2218 	str.w	r2, [r4, #536]	; 0x218
   34718:	682a      	ldr	r2, [r5, #0]
   3471a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   3471e:	f8c4 1208 	str.w	r1, [r4, #520]	; 0x208
   34722:	f8c4 22c4 	str.w	r2, [r4, #708]	; 0x2c4
   34726:	7a31      	ldrb	r1, [r6, #8]
   34728:	2900      	cmp	r1, #0
   3472a:	f000 80a3 	beq.w	34874 <am_hal_iom_blocking_transfer+0x288>
   3472e:	f8c4 0124 	str.w	r0, [r4, #292]	; 0x124
   34732:	4a70      	ldr	r2, [pc, #448]	; (348f4 <am_hal_iom_blocking_transfer+0x308>)
   34734:	f1b8 0f01 	cmp.w	r8, #1
   34738:	ea02 2909 	and.w	r9, r2, r9, lsl #8
   3473c:	ea49 0303 	orr.w	r3, r9, r3
   34740:	f000 80de 	beq.w	34900 <am_hal_iom_blocking_transfer+0x314>
   34744:	9a02      	ldr	r2, [sp, #8]
   34746:	9903      	ldr	r1, [sp, #12]
   34748:	692d      	ldr	r5, [r5, #16]
   3474a:	0a12      	lsrs	r2, r2, #8
   3474c:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
   34750:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
   34754:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
   34758:	f3c2 2207 	ubfx	r2, r2, #8, #8
   3475c:	2a03      	cmp	r2, #3
   3475e:	46b9      	mov	r9, r7
   34760:	d917      	bls.n	34792 <am_hal_iom_blocking_transfer+0x1a6>
   34762:	b1b5      	cbz	r5, 34792 <am_hal_iom_blocking_transfer+0x1a6>
   34764:	f859 1b04 	ldr.w	r1, [r9], #4
   34768:	f8c4 110c 	str.w	r1, [r4, #268]	; 0x10c
   3476c:	2d03      	cmp	r5, #3
   3476e:	d90f      	bls.n	34790 <am_hal_iom_blocking_transfer+0x1a4>
   34770:	3a04      	subs	r2, #4
   34772:	f022 0203 	bic.w	r2, r2, #3
   34776:	3204      	adds	r2, #4
   34778:	4417      	add	r7, r2
   3477a:	454f      	cmp	r7, r9
   3477c:	f1a5 0504 	sub.w	r5, r5, #4
   34780:	d007      	beq.n	34792 <am_hal_iom_blocking_transfer+0x1a6>
   34782:	b135      	cbz	r5, 34792 <am_hal_iom_blocking_transfer+0x1a6>
   34784:	f859 2b04 	ldr.w	r2, [r9], #4
   34788:	f8c4 210c 	str.w	r2, [r4, #268]	; 0x10c
   3478c:	2d03      	cmp	r5, #3
   3478e:	d8f4      	bhi.n	3477a <am_hal_iom_blocking_transfer+0x18e>
   34790:	4645      	mov	r5, r8
   34792:	9a05      	ldr	r2, [sp, #20]
   34794:	ea43 130a 	orr.w	r3, r3, sl, lsl #4
   34798:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   3479c:	9a02      	ldr	r2, [sp, #8]
   3479e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   347a2:	f043 0301 	orr.w	r3, r3, #1
   347a6:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
   347aa:	2d00      	cmp	r5, #0
   347ac:	f000 8088 	beq.w	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   347b0:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   347b4:	f3c3 2307 	ubfx	r3, r3, #8, #8
   347b8:	2b03      	cmp	r3, #3
   347ba:	f200 8083 	bhi.w	348c4 <am_hal_iom_blocking_transfer+0x2d8>
   347be:	4f4e      	ldr	r7, [pc, #312]	; (348f8 <am_hal_iom_blocking_transfer+0x30c>)
   347c0:	e009      	b.n	347d6 <am_hal_iom_blocking_transfer+0x1ea>
   347c2:	3f01      	subs	r7, #1
   347c4:	d00d      	beq.n	347e2 <am_hal_iom_blocking_transfer+0x1f6>
   347c6:	f000 fd7f 	bl	352c8 <am_hal_delay_us>
   347ca:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   347ce:	f3c3 2307 	ubfx	r3, r3, #8, #8
   347d2:	2b03      	cmp	r3, #3
   347d4:	d876      	bhi.n	348c4 <am_hal_iom_blocking_transfer+0x2d8>
   347d6:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
   347da:	07db      	lsls	r3, r3, #31
   347dc:	f04f 0001 	mov.w	r0, #1
   347e0:	d5ef      	bpl.n	347c2 <am_hal_iom_blocking_transfer+0x1d6>
   347e2:	2701      	movs	r7, #1
   347e4:	2304      	movs	r3, #4
   347e6:	4845      	ldr	r0, [pc, #276]	; (348fc <am_hal_iom_blocking_transfer+0x310>)
   347e8:	9700      	str	r7, [sp, #0]
   347ea:	4659      	mov	r1, fp
   347ec:	2206      	movs	r2, #6
   347ee:	f000 fdaf 	bl	35350 <am_hal_delay_us_status_check>
   347f2:	4603      	mov	r3, r0
   347f4:	b980      	cbnz	r0, 34818 <am_hal_iom_blocking_transfer+0x22c>
   347f6:	f8d4 3204 	ldr.w	r3, [r4, #516]	; 0x204
   347fa:	f013 0f6c 	tst.w	r3, #108	; 0x6c
   347fe:	f040 80b6 	bne.w	3496e <am_hal_iom_blocking_transfer+0x382>
   34802:	0599      	lsls	r1, r3, #22
   34804:	f100 80b6 	bmi.w	34974 <am_hal_iom_blocking_transfer+0x388>
   34808:	06da      	lsls	r2, r3, #27
   3480a:	f100 80b5 	bmi.w	34978 <am_hal_iom_blocking_transfer+0x38c>
   3480e:	f403 4390 	and.w	r3, r3, #18432	; 0x4800
   34812:	432b      	orrs	r3, r5
   34814:	d007      	beq.n	34826 <am_hal_iom_blocking_transfer+0x23a>
   34816:	463b      	mov	r3, r7
   34818:	f8d4 1204 	ldr.w	r1, [r4, #516]	; 0x204
   3481c:	9302      	str	r3, [sp, #8]
   3481e:	4630      	mov	r0, r6
   34820:	f7ff faf4 	bl	33e0c <internal_iom_reset_on_error>
   34824:	9b02      	ldr	r3, [sp, #8]
   34826:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   3482a:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
   3482e:	9a04      	ldr	r2, [sp, #16]
   34830:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   34834:	e000      	b.n	34838 <am_hal_iom_blocking_transfer+0x24c>
   34836:	2302      	movs	r3, #2
   34838:	4618      	mov	r0, r3
   3483a:	b007      	add	sp, #28
   3483c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34840:	69ab      	ldr	r3, [r5, #24]
   34842:	2b00      	cmp	r3, #0
   34844:	f47f af1c 	bne.w	34680 <am_hal_iom_blocking_transfer+0x94>
   34848:	2306      	movs	r3, #6
   3484a:	4618      	mov	r0, r3
   3484c:	b007      	add	sp, #28
   3484e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34852:	f881 9014 	strb.w	r9, [r1, #20]
   34856:	46c8      	mov	r8, r9
   34858:	e6e6      	b.n	34628 <am_hal_iom_blocking_transfer+0x3c>
   3485a:	2307      	movs	r3, #7
   3485c:	4618      	mov	r0, r3
   3485e:	b007      	add	sp, #28
   34860:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34864:	7a33      	ldrb	r3, [r6, #8]
   34866:	2b01      	cmp	r3, #1
   34868:	f47f af0d 	bne.w	34686 <am_hal_iom_blocking_transfer+0x9a>
   3486c:	e714      	b.n	34698 <am_hal_iom_blocking_transfer+0xac>
   3486e:	2302      	movs	r3, #2
   34870:	4618      	mov	r0, r3
   34872:	4770      	bx	lr
   34874:	18b1      	adds	r1, r6, r2
   34876:	0513      	lsls	r3, r2, #20
   34878:	f891 28a0 	ldrb.w	r2, [r1, #2208]	; 0x8a0
   3487c:	f8c4 2124 	str.w	r2, [r4, #292]	; 0x124
   34880:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
   34884:	e755      	b.n	34732 <am_hal_iom_blocking_transfer+0x146>
   34886:	2b03      	cmp	r3, #3
   34888:	f8c8 1000 	str.w	r1, [r8]
   3488c:	f1a5 0504 	sub.w	r5, r5, #4
   34890:	f108 0804 	add.w	r8, r8, #4
   34894:	d968      	bls.n	34968 <am_hal_iom_blocking_transfer+0x37c>
   34896:	b19d      	cbz	r5, 348c0 <am_hal_iom_blocking_transfer+0x2d4>
   34898:	2d03      	cmp	r5, #3
   3489a:	f8d4 1108 	ldr.w	r1, [r4, #264]	; 0x108
   3489e:	f1a3 0304 	sub.w	r3, r3, #4
   348a2:	d8f0      	bhi.n	34886 <am_hal_iom_blocking_transfer+0x29a>
   348a4:	3d01      	subs	r5, #1
   348a6:	f888 1000 	strb.w	r1, [r8]
   348aa:	ea4f 2311 	mov.w	r3, r1, lsr #8
   348ae:	d007      	beq.n	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   348b0:	2d01      	cmp	r5, #1
   348b2:	f888 3001 	strb.w	r3, [r8, #1]
   348b6:	ea4f 4111 	mov.w	r1, r1, lsr #16
   348ba:	d001      	beq.n	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   348bc:	f888 1002 	strb.w	r1, [r8, #2]
   348c0:	2500      	movs	r5, #0
   348c2:	e78e      	b.n	347e2 <am_hal_iom_blocking_transfer+0x1f6>
   348c4:	f005 0003 	and.w	r0, r5, #3
   348c8:	464a      	mov	r2, r9
   348ca:	f852 1b04 	ldr.w	r1, [r2], #4
   348ce:	f8c4 110c 	str.w	r1, [r4, #268]	; 0x10c
   348d2:	42a8      	cmp	r0, r5
   348d4:	eba9 0102 	sub.w	r1, r9, r2
   348d8:	4419      	add	r1, r3
   348da:	f1a5 0504 	sub.w	r5, r5, #4
   348de:	d004      	beq.n	348ea <am_hal_iom_blocking_transfer+0x2fe>
   348e0:	2903      	cmp	r1, #3
   348e2:	d903      	bls.n	348ec <am_hal_iom_blocking_transfer+0x300>
   348e4:	2d00      	cmp	r5, #0
   348e6:	d1f0      	bne.n	348ca <am_hal_iom_blocking_transfer+0x2de>
   348e8:	e7ea      	b.n	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   348ea:	4645      	mov	r5, r8
   348ec:	4691      	mov	r9, r2
   348ee:	e75c      	b.n	347aa <am_hal_iom_blocking_transfer+0x1be>
   348f0:	01123456 	.word	0x01123456
   348f4:	000fff00 	.word	0x000fff00
   348f8:	0007a121 	.word	0x0007a121
   348fc:	0007a120 	.word	0x0007a120
   34900:	9a05      	ldr	r2, [sp, #20]
   34902:	9903      	ldr	r1, [sp, #12]
   34904:	692d      	ldr	r5, [r5, #16]
   34906:	ea43 130a 	orr.w	r3, r3, sl, lsl #4
   3490a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   3490e:	9a02      	ldr	r2, [sp, #8]
   34910:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   34914:	0a12      	lsrs	r2, r2, #8
   34916:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
   3491a:	f043 0302 	orr.w	r3, r3, #2
   3491e:	f8c4 2128 	str.w	r2, [r4, #296]	; 0x128
   34922:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
   34926:	2d00      	cmp	r5, #0
   34928:	d0ca      	beq.n	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   3492a:	2200      	movs	r2, #0
   3492c:	46b8      	mov	r8, r7
   3492e:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   34932:	f3c3 4307 	ubfx	r3, r3, #16, #8
   34936:	2b03      	cmp	r3, #3
   34938:	d8ae      	bhi.n	34898 <am_hal_iom_blocking_transfer+0x2ac>
   3493a:	4f10      	ldr	r7, [pc, #64]	; (3497c <am_hal_iom_blocking_transfer+0x390>)
   3493c:	e002      	b.n	34944 <am_hal_iom_blocking_transfer+0x358>
   3493e:	3f01      	subs	r7, #1
   34940:	f43f af4f 	beq.w	347e2 <am_hal_iom_blocking_transfer+0x1f6>
   34944:	2001      	movs	r0, #1
   34946:	b112      	cbz	r2, 3494e <am_hal_iom_blocking_transfer+0x362>
   34948:	42ab      	cmp	r3, r5
   3494a:	f4ff af4a 	bcc.w	347e2 <am_hal_iom_blocking_transfer+0x1f6>
   3494e:	f000 fcbb 	bl	352c8 <am_hal_delay_us>
   34952:	f8d4 2204 	ldr.w	r2, [r4, #516]	; 0x204
   34956:	f8d4 3100 	ldr.w	r3, [r4, #256]	; 0x100
   3495a:	f3c3 4307 	ubfx	r3, r3, #16, #8
   3495e:	2b03      	cmp	r3, #3
   34960:	f002 0201 	and.w	r2, r2, #1
   34964:	d9eb      	bls.n	3493e <am_hal_iom_blocking_transfer+0x352>
   34966:	e797      	b.n	34898 <am_hal_iom_blocking_transfer+0x2ac>
   34968:	2d00      	cmp	r5, #0
   3496a:	d1e0      	bne.n	3492e <am_hal_iom_blocking_transfer+0x342>
   3496c:	e7a8      	b.n	348c0 <am_hal_iom_blocking_transfer+0x2d4>
   3496e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   34972:	e751      	b.n	34818 <am_hal_iom_blocking_transfer+0x22c>
   34974:	4b02      	ldr	r3, [pc, #8]	; (34980 <am_hal_iom_blocking_transfer+0x394>)
   34976:	e74f      	b.n	34818 <am_hal_iom_blocking_transfer+0x22c>
   34978:	4b02      	ldr	r3, [pc, #8]	; (34984 <am_hal_iom_blocking_transfer+0x398>)
   3497a:	e74d      	b.n	34818 <am_hal_iom_blocking_transfer+0x22c>
   3497c:	0007a120 	.word	0x0007a120
   34980:	08000001 	.word	0x08000001
   34984:	08000002 	.word	0x08000002

00034988 <am_hal_itm_enable>:
   34988:	4a0e      	ldr	r2, [pc, #56]	; (349c4 <am_hal_itm_enable+0x3c>)
   3498a:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   3498e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   34992:	b410      	push	{r4}
   34994:	f8c2 30fc 	str.w	r3, [r2, #252]	; 0xfc
   34998:	f8d2 30fc 	ldr.w	r3, [r2, #252]	; 0xfc
   3499c:	01db      	lsls	r3, r3, #7
   3499e:	d5fb      	bpl.n	34998 <am_hal_itm_enable+0x10>
   349a0:	f04f 4360 	mov.w	r3, #3758096384	; 0xe0000000
   349a4:	4c08      	ldr	r4, [pc, #32]	; (349c8 <am_hal_itm_enable+0x40>)
   349a6:	4a09      	ldr	r2, [pc, #36]	; (349cc <am_hal_itm_enable+0x44>)
   349a8:	f8c3 4fb0 	str.w	r4, [r3, #4016]	; 0xfb0
   349ac:	200f      	movs	r0, #15
   349ae:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
   349b2:	f8c3 0e40 	str.w	r0, [r3, #3648]	; 0xe40
   349b6:	f85d 4b04 	ldr.w	r4, [sp], #4
   349ba:	f8c3 1e00 	str.w	r1, [r3, #3584]	; 0xe00
   349be:	f8c3 2e80 	str.w	r2, [r3, #3712]	; 0xe80
   349c2:	4770      	bx	lr
   349c4:	e000ed00 	.word	0xe000ed00
   349c8:	c5acce55 	.word	0xc5acce55
   349cc:	00150511 	.word	0x00150511

000349d0 <am_hal_itm_print>:
   349d0:	7803      	ldrb	r3, [r0, #0]
   349d2:	b1a3      	cbz	r3, 349fe <am_hal_itm_print+0x2e>
   349d4:	4603      	mov	r3, r0
   349d6:	f1c0 0c01 	rsb	ip, r0, #1
   349da:	eb0c 0103 	add.w	r1, ip, r3
   349de:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   349e2:	2a00      	cmp	r2, #0
   349e4:	d1f9      	bne.n	349da <am_hal_itm_print+0xa>
   349e6:	4401      	add	r1, r0
   349e8:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   349ec:	f810 cb01 	ldrb.w	ip, [r0], #1
   349f0:	6813      	ldr	r3, [r2, #0]
   349f2:	2b00      	cmp	r3, #0
   349f4:	d0fc      	beq.n	349f0 <am_hal_itm_print+0x20>
   349f6:	4288      	cmp	r0, r1
   349f8:	f882 c000 	strb.w	ip, [r2]
   349fc:	d1f6      	bne.n	349ec <am_hal_itm_print+0x1c>
   349fe:	4770      	bx	lr

00034a00 <am_hal_mcuctrl_control>:
   34a00:	b530      	push	{r4, r5, lr}
   34a02:	460d      	mov	r5, r1
   34a04:	b083      	sub	sp, #12
   34a06:	2804      	cmp	r0, #4
   34a08:	f200 80e7 	bhi.w	34bda <am_hal_mcuctrl_control+0x1da>
   34a0c:	e8df f000 	tbb	[pc, r0]
   34a10:	9e4d3b29 	.word	0x9e4d3b29
   34a14:	03          	.byte	0x03
   34a15:	00          	.byte	0x00
   34a16:	4b72      	ldr	r3, [pc, #456]	; (34be0 <am_hal_mcuctrl_control+0x1e0>)
   34a18:	4a72      	ldr	r2, [pc, #456]	; (34be4 <am_hal_mcuctrl_control+0x1e4>)
   34a1a:	681b      	ldr	r3, [r3, #0]
   34a1c:	6812      	ldr	r2, [r2, #0]
   34a1e:	019b      	lsls	r3, r3, #6
   34a20:	f002 023f 	and.w	r2, r2, #63	; 0x3f
   34a24:	f403 7370 	and.w	r3, r3, #960	; 0x3c0
   34a28:	4313      	orrs	r3, r2
   34a2a:	f043 7344 	orr.w	r3, r3, #51380224	; 0x3100000
   34a2e:	f443 33f8 	orr.w	r3, r3, #126976	; 0x1f000
   34a32:	9301      	str	r3, [sp, #4]
   34a34:	4a6c      	ldr	r2, [pc, #432]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34a36:	9b01      	ldr	r3, [sp, #4]
   34a38:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128
   34a3c:	f8d2 312c 	ldr.w	r3, [r2, #300]	; 0x12c
   34a40:	9301      	str	r3, [sp, #4]
   34a42:	9b01      	ldr	r3, [sp, #4]
   34a44:	f423 73d5 	bic.w	r3, r3, #426	; 0x1aa
   34a48:	f023 0301 	bic.w	r3, r3, #1
   34a4c:	9301      	str	r3, [sp, #4]
   34a4e:	9b01      	ldr	r3, [sp, #4]
   34a50:	f043 0382 	orr.w	r3, r3, #130	; 0x82
   34a54:	9301      	str	r3, [sp, #4]
   34a56:	9b01      	ldr	r3, [sp, #4]
   34a58:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
   34a5c:	2000      	movs	r0, #0
   34a5e:	b003      	add	sp, #12
   34a60:	bd30      	pop	{r4, r5, pc}
   34a62:	4a61      	ldr	r2, [pc, #388]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34a64:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   34a68:	9301      	str	r3, [sp, #4]
   34a6a:	9b01      	ldr	r3, [sp, #4]
   34a6c:	f023 031f 	bic.w	r3, r3, #31
   34a70:	9301      	str	r3, [sp, #4]
   34a72:	9b01      	ldr	r3, [sp, #4]
   34a74:	f043 0319 	orr.w	r3, r3, #25
   34a78:	9301      	str	r3, [sp, #4]
   34a7a:	9b01      	ldr	r3, [sp, #4]
   34a7c:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   34a80:	2000      	movs	r0, #0
   34a82:	b003      	add	sp, #12
   34a84:	bd30      	pop	{r4, r5, pc}
   34a86:	4a58      	ldr	r2, [pc, #352]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34a88:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
   34a8c:	9301      	str	r3, [sp, #4]
   34a8e:	9b01      	ldr	r3, [sp, #4]
   34a90:	f023 031f 	bic.w	r3, r3, #31
   34a94:	9301      	str	r3, [sp, #4]
   34a96:	9b01      	ldr	r3, [sp, #4]
   34a98:	f043 0318 	orr.w	r3, r3, #24
   34a9c:	9301      	str	r3, [sp, #4]
   34a9e:	9b01      	ldr	r3, [sp, #4]
   34aa0:	f8c2 3120 	str.w	r3, [r2, #288]	; 0x120
   34aa4:	2000      	movs	r0, #0
   34aa6:	b003      	add	sp, #12
   34aa8:	bd30      	pop	{r4, r5, pc}
   34aaa:	4b4d      	ldr	r3, [pc, #308]	; (34be0 <am_hal_mcuctrl_control+0x1e0>)
   34aac:	4a4d      	ldr	r2, [pc, #308]	; (34be4 <am_hal_mcuctrl_control+0x1e4>)
   34aae:	681b      	ldr	r3, [r3, #0]
   34ab0:	6811      	ldr	r1, [r2, #0]
   34ab2:	4a4e      	ldr	r2, [pc, #312]	; (34bec <am_hal_mcuctrl_control+0x1ec>)
   34ab4:	4c4c      	ldr	r4, [pc, #304]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34ab6:	019b      	lsls	r3, r3, #6
   34ab8:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   34abc:	f403 7370 	and.w	r3, r3, #960	; 0x3c0
   34ac0:	430b      	orrs	r3, r1
   34ac2:	431a      	orrs	r2, r3
   34ac4:	9201      	str	r2, [sp, #4]
   34ac6:	9b01      	ldr	r3, [sp, #4]
   34ac8:	f8c4 3128 	str.w	r3, [r4, #296]	; 0x128
   34acc:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34ad0:	9301      	str	r3, [sp, #4]
   34ad2:	9b01      	ldr	r3, [sp, #4]
   34ad4:	f023 03a2 	bic.w	r3, r3, #162	; 0xa2
   34ad8:	9301      	str	r3, [sp, #4]
   34ada:	9b01      	ldr	r3, [sp, #4]
   34adc:	f043 0382 	orr.w	r3, r3, #130	; 0x82
   34ae0:	9301      	str	r3, [sp, #4]
   34ae2:	9b01      	ldr	r3, [sp, #4]
   34ae4:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34ae8:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34aec:	f043 0301 	orr.w	r3, r3, #1
   34af0:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34af4:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34af8:	f043 0310 	orr.w	r3, r3, #16
   34afc:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34b00:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34b04:	f043 0308 	orr.w	r3, r3, #8
   34b08:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34b0c:	2005      	movs	r0, #5
   34b0e:	f000 fbdb 	bl	352c8 <am_hal_delay_us>
   34b12:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34b16:	f36f 1304 	bfc	r3, #4, #1
   34b1a:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34b1e:	2d00      	cmp	r5, #0
   34b20:	d059      	beq.n	34bd6 <am_hal_mcuctrl_control+0x1d6>
   34b22:	7828      	ldrb	r0, [r5, #0]
   34b24:	2800      	cmp	r0, #0
   34b26:	d09a      	beq.n	34a5e <am_hal_mcuctrl_control+0x5e>
   34b28:	f8d4 312c 	ldr.w	r3, [r4, #300]	; 0x12c
   34b2c:	9301      	str	r3, [sp, #4]
   34b2e:	9b01      	ldr	r3, [sp, #4]
   34b30:	f423 7384 	bic.w	r3, r3, #264	; 0x108
   34b34:	f023 0301 	bic.w	r3, r3, #1
   34b38:	9301      	str	r3, [sp, #4]
   34b3a:	9b01      	ldr	r3, [sp, #4]
   34b3c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   34b40:	9301      	str	r3, [sp, #4]
   34b42:	9b01      	ldr	r3, [sp, #4]
   34b44:	f8c4 312c 	str.w	r3, [r4, #300]	; 0x12c
   34b48:	2000      	movs	r0, #0
   34b4a:	e788      	b.n	34a5e <am_hal_mcuctrl_control+0x5e>
   34b4c:	4b24      	ldr	r3, [pc, #144]	; (34be0 <am_hal_mcuctrl_control+0x1e0>)
   34b4e:	4a25      	ldr	r2, [pc, #148]	; (34be4 <am_hal_mcuctrl_control+0x1e4>)
   34b50:	681b      	ldr	r3, [r3, #0]
   34b52:	6811      	ldr	r1, [r2, #0]
   34b54:	4a25      	ldr	r2, [pc, #148]	; (34bec <am_hal_mcuctrl_control+0x1ec>)
   34b56:	019b      	lsls	r3, r3, #6
   34b58:	f403 7370 	and.w	r3, r3, #960	; 0x3c0
   34b5c:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   34b60:	430b      	orrs	r3, r1
   34b62:	431a      	orrs	r2, r3
   34b64:	9201      	str	r2, [sp, #4]
   34b66:	4b20      	ldr	r3, [pc, #128]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34b68:	9a01      	ldr	r2, [sp, #4]
   34b6a:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
   34b6e:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
   34b72:	9201      	str	r2, [sp, #4]
   34b74:	9a01      	ldr	r2, [sp, #4]
   34b76:	f022 02a2 	bic.w	r2, r2, #162	; 0xa2
   34b7a:	9201      	str	r2, [sp, #4]
   34b7c:	9a01      	ldr	r2, [sp, #4]
   34b7e:	f042 02a2 	orr.w	r2, r2, #162	; 0xa2
   34b82:	9201      	str	r2, [sp, #4]
   34b84:	9a01      	ldr	r2, [sp, #4]
   34b86:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
   34b8a:	f8d3 212c 	ldr.w	r2, [r3, #300]	; 0x12c
   34b8e:	f042 0201 	orr.w	r2, r2, #1
   34b92:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
   34b96:	f8d3 312c 	ldr.w	r3, [r3, #300]	; 0x12c
   34b9a:	9301      	str	r3, [sp, #4]
   34b9c:	b195      	cbz	r5, 34bc4 <am_hal_mcuctrl_control+0x1c4>
   34b9e:	782b      	ldrb	r3, [r5, #0]
   34ba0:	b183      	cbz	r3, 34bc4 <am_hal_mcuctrl_control+0x1c4>
   34ba2:	9b01      	ldr	r3, [sp, #4]
   34ba4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   34ba8:	f023 0301 	bic.w	r3, r3, #1
   34bac:	9301      	str	r3, [sp, #4]
   34bae:	9b01      	ldr	r3, [sp, #4]
   34bb0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   34bb4:	9301      	str	r3, [sp, #4]
   34bb6:	4b0c      	ldr	r3, [pc, #48]	; (34be8 <am_hal_mcuctrl_control+0x1e8>)
   34bb8:	9a01      	ldr	r2, [sp, #4]
   34bba:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
   34bbe:	2000      	movs	r0, #0
   34bc0:	b003      	add	sp, #12
   34bc2:	bd30      	pop	{r4, r5, pc}
   34bc4:	9b01      	ldr	r3, [sp, #4]
   34bc6:	f023 0328 	bic.w	r3, r3, #40	; 0x28
   34bca:	9301      	str	r3, [sp, #4]
   34bcc:	9b01      	ldr	r3, [sp, #4]
   34bce:	f043 0308 	orr.w	r3, r3, #8
   34bd2:	9301      	str	r3, [sp, #4]
   34bd4:	e7ef      	b.n	34bb6 <am_hal_mcuctrl_control+0x1b6>
   34bd6:	4628      	mov	r0, r5
   34bd8:	e741      	b.n	34a5e <am_hal_mcuctrl_control+0x5e>
   34bda:	2006      	movs	r0, #6
   34bdc:	e73f      	b.n	34a5e <am_hal_mcuctrl_control+0x5e>
   34bde:	bf00      	nop
   34be0:	10003834 	.word	0x10003834
   34be4:	10003830 	.word	0x10003830
   34be8:	40020000 	.word	0x40020000
   34bec:	0fff8c00 	.word	0x0fff8c00

00034bf0 <am_hal_mcuctrl_info_get>:
   34bf0:	b119      	cbz	r1, 34bfa <am_hal_mcuctrl_info_get+0xa>
   34bf2:	2800      	cmp	r0, #0
   34bf4:	d064      	beq.n	34cc0 <am_hal_mcuctrl_info_get+0xd0>
   34bf6:	2801      	cmp	r0, #1
   34bf8:	d001      	beq.n	34bfe <am_hal_mcuctrl_info_get+0xe>
   34bfa:	2006      	movs	r0, #6
   34bfc:	4770      	bx	lr
   34bfe:	4b40      	ldr	r3, [pc, #256]	; (34d00 <am_hal_mcuctrl_info_get+0x110>)
   34c00:	681a      	ldr	r2, [r3, #0]
   34c02:	600a      	str	r2, [r1, #0]
   34c04:	685a      	ldr	r2, [r3, #4]
   34c06:	604a      	str	r2, [r1, #4]
   34c08:	689a      	ldr	r2, [r3, #8]
   34c0a:	608a      	str	r2, [r1, #8]
   34c0c:	68da      	ldr	r2, [r3, #12]
   34c0e:	60ca      	str	r2, [r1, #12]
   34c10:	691a      	ldr	r2, [r3, #16]
   34c12:	610a      	str	r2, [r1, #16]
   34c14:	695a      	ldr	r2, [r3, #20]
   34c16:	b410      	push	{r4}
   34c18:	e9c1 2005 	strd	r2, r0, [r1, #20]
   34c1c:	695a      	ldr	r2, [r3, #20]
   34c1e:	4c39      	ldr	r4, [pc, #228]	; (34d04 <am_hal_mcuctrl_info_get+0x114>)
   34c20:	f3c2 0281 	ubfx	r2, r2, #2, #2
   34c24:	f44f 20c0 	mov.w	r0, #393216	; 0x60000
   34c28:	f834 2012 	ldrh.w	r2, [r4, r2, lsl #1]
   34c2c:	6208      	str	r0, [r1, #32]
   34c2e:	0292      	lsls	r2, r2, #10
   34c30:	628a      	str	r2, [r1, #40]	; 0x28
   34c32:	6958      	ldr	r0, [r3, #20]
   34c34:	695a      	ldr	r2, [r3, #20]
   34c36:	4c34      	ldr	r4, [pc, #208]	; (34d08 <am_hal_mcuctrl_info_get+0x118>)
   34c38:	f002 0203 	and.w	r2, r2, #3
   34c3c:	eb04 0282 	add.w	r2, r4, r2, lsl #2
   34c40:	f000 0303 	and.w	r3, r0, #3
   34c44:	8850      	ldrh	r0, [r2, #2]
   34c46:	f834 3023 	ldrh.w	r3, [r4, r3, lsl #2]
   34c4a:	4a30      	ldr	r2, [pc, #192]	; (34d0c <am_hal_mcuctrl_info_get+0x11c>)
   34c4c:	4403      	add	r3, r0
   34c4e:	029b      	lsls	r3, r3, #10
   34c50:	624b      	str	r3, [r1, #36]	; 0x24
   34c52:	f8d2 30e0 	ldr.w	r3, [r2, #224]	; 0xe0
   34c56:	f8d2 00e4 	ldr.w	r0, [r2, #228]	; 0xe4
   34c5a:	b2db      	uxtb	r3, r3
   34c5c:	f000 000f 	and.w	r0, r0, #15
   34c60:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
   34c64:	62cb      	str	r3, [r1, #44]	; 0x2c
   34c66:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
   34c6a:	f8d2 00e8 	ldr.w	r0, [r2, #232]	; 0xe8
   34c6e:	f3c3 1303 	ubfx	r3, r3, #4, #4
   34c72:	f000 000f 	and.w	r0, r0, #15
   34c76:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
   34c7a:	630b      	str	r3, [r1, #48]	; 0x30
   34c7c:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
   34c80:	f8d2 00ec 	ldr.w	r0, [r2, #236]	; 0xec
   34c84:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
   34c88:	f3c0 1003 	ubfx	r0, r0, #4, #4
   34c8c:	4303      	orrs	r3, r0
   34c8e:	634b      	str	r3, [r1, #52]	; 0x34
   34c90:	f8d2 40fc 	ldr.w	r4, [r2, #252]	; 0xfc
   34c94:	f8d2 30f8 	ldr.w	r3, [r2, #248]	; 0xf8
   34c98:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
   34c9c:	f8d2 20f0 	ldr.w	r2, [r2, #240]	; 0xf0
   34ca0:	b2db      	uxtb	r3, r3
   34ca2:	041b      	lsls	r3, r3, #16
   34ca4:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
   34ca8:	fa5f fc82 	uxtb.w	ip, r2
   34cac:	ea43 030c 	orr.w	r3, r3, ip
   34cb0:	b2c2      	uxtb	r2, r0
   34cb2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   34cb6:	2000      	movs	r0, #0
   34cb8:	f85d 4b04 	ldr.w	r4, [sp], #4
   34cbc:	638b      	str	r3, [r1, #56]	; 0x38
   34cbe:	4770      	bx	lr
   34cc0:	4b0f      	ldr	r3, [pc, #60]	; (34d00 <am_hal_mcuctrl_info_get+0x110>)
   34cc2:	7008      	strb	r0, [r1, #0]
   34cc4:	695a      	ldr	r2, [r3, #20]
   34cc6:	f3c2 0201 	ubfx	r2, r2, #0, #2
   34cca:	704a      	strb	r2, [r1, #1]
   34ccc:	695a      	ldr	r2, [r3, #20]
   34cce:	f3c2 0281 	ubfx	r2, r2, #2, #2
   34cd2:	708a      	strb	r2, [r1, #2]
   34cd4:	695a      	ldr	r2, [r3, #20]
   34cd6:	f3c2 1280 	ubfx	r2, r2, #6, #1
   34cda:	70ca      	strb	r2, [r1, #3]
   34cdc:	695a      	ldr	r2, [r3, #20]
   34cde:	f3c2 12c0 	ubfx	r2, r2, #7, #1
   34ce2:	710a      	strb	r2, [r1, #4]
   34ce4:	695a      	ldr	r2, [r3, #20]
   34ce6:	f3c2 2200 	ubfx	r2, r2, #8, #1
   34cea:	714a      	strb	r2, [r1, #5]
   34cec:	695a      	ldr	r2, [r3, #20]
   34cee:	f3c2 2240 	ubfx	r2, r2, #9, #1
   34cf2:	718a      	strb	r2, [r1, #6]
   34cf4:	695b      	ldr	r3, [r3, #20]
   34cf6:	f3c3 2380 	ubfx	r3, r3, #10, #1
   34cfa:	71cb      	strb	r3, [r1, #7]
   34cfc:	4770      	bx	lr
   34cfe:	bf00      	nop
   34d00:	40020000 	.word	0x40020000
   34d04:	000467e8 	.word	0x000467e8
   34d08:	000467f0 	.word	0x000467f0
   34d0c:	f0000f00 	.word	0xf0000f00

00034d10 <am_hal_mram_info_read>:
   34d10:	b9c0      	cbnz	r0, 34d44 <am_hal_mram_info_read+0x34>
   34d12:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
   34d16:	d228      	bcs.n	34d6a <am_hal_mram_info_read+0x5a>
   34d18:	1888      	adds	r0, r1, r2
   34d1a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
   34d1e:	d824      	bhi.n	34d6a <am_hal_mram_info_read+0x5a>
   34d20:	f101 5184 	add.w	r1, r1, #276824064	; 0x10800000
   34d24:	0089      	lsls	r1, r1, #2
   34d26:	b312      	cbz	r2, 34d6e <am_hal_mram_info_read+0x5e>
   34d28:	b410      	push	{r4}
   34d2a:	2000      	movs	r0, #0
   34d2c:	3001      	adds	r0, #1
   34d2e:	680c      	ldr	r4, [r1, #0]
   34d30:	f843 4b04 	str.w	r4, [r3], #4
   34d34:	4282      	cmp	r2, r0
   34d36:	f101 0104 	add.w	r1, r1, #4
   34d3a:	d1f7      	bne.n	34d2c <am_hal_mram_info_read+0x1c>
   34d3c:	2000      	movs	r0, #0
   34d3e:	f85d 4b04 	ldr.w	r4, [sp], #4
   34d42:	4770      	bx	lr
   34d44:	2801      	cmp	r0, #1
   34d46:	d10e      	bne.n	34d66 <am_hal_mram_info_read+0x56>
   34d48:	f5a1 6090 	sub.w	r0, r1, #1152	; 0x480
   34d4c:	f5b0 7fc0 	cmp.w	r0, #384	; 0x180
   34d50:	d20b      	bcs.n	34d6a <am_hal_mram_info_read+0x5a>
   34d52:	1888      	adds	r0, r1, r2
   34d54:	f5b0 6fc0 	cmp.w	r0, #1536	; 0x600
   34d58:	d807      	bhi.n	34d6a <am_hal_mram_info_read+0x5a>
   34d5a:	f101 5184 	add.w	r1, r1, #276824064	; 0x10800000
   34d5e:	f501 6100 	add.w	r1, r1, #2048	; 0x800
   34d62:	0089      	lsls	r1, r1, #2
   34d64:	e7df      	b.n	34d26 <am_hal_mram_info_read+0x16>
   34d66:	2001      	movs	r0, #1
   34d68:	4770      	bx	lr
   34d6a:	2002      	movs	r0, #2
   34d6c:	4770      	bx	lr
   34d6e:	2000      	movs	r0, #0
   34d70:	4770      	bx	lr
   34d72:	bf00      	nop

00034d74 <am_hal_reset_status_get>:
   34d74:	b3c0      	cbz	r0, 34de8 <am_hal_reset_status_get+0x74>
   34d76:	491e      	ldr	r1, [pc, #120]	; (34df0 <am_hal_reset_status_get+0x7c>)
   34d78:	680b      	ldr	r3, [r1, #0]
   34d7a:	b38b      	cbz	r3, 34de0 <am_hal_reset_status_get+0x6c>
   34d7c:	f3c3 020a 	ubfx	r2, r3, #0, #11
   34d80:	f002 0c01 	and.w	ip, r2, #1
   34d84:	600a      	str	r2, [r1, #0]
   34d86:	f880 c002 	strb.w	ip, [r0, #2]
   34d8a:	f3c3 0180 	ubfx	r1, r3, #2, #1
   34d8e:	f3c3 0c40 	ubfx	ip, r3, #1, #1
   34d92:	f880 c003 	strb.w	ip, [r0, #3]
   34d96:	7101      	strb	r1, [r0, #4]
   34d98:	f3c3 0cc0 	ubfx	ip, r3, #3, #1
   34d9c:	f3c3 1100 	ubfx	r1, r3, #4, #1
   34da0:	f880 c005 	strb.w	ip, [r0, #5]
   34da4:	7181      	strb	r1, [r0, #6]
   34da6:	f3c3 1c40 	ubfx	ip, r3, #5, #1
   34daa:	f3c3 1180 	ubfx	r1, r3, #6, #1
   34dae:	8002      	strh	r2, [r0, #0]
   34db0:	f880 c007 	strb.w	ip, [r0, #7]
   34db4:	7201      	strb	r1, [r0, #8]
   34db6:	f3c3 1cc0 	ubfx	ip, r3, #7, #1
   34dba:	f3c3 2100 	ubfx	r1, r3, #8, #1
   34dbe:	fab2 f282 	clz	r2, r2
   34dc2:	f880 c009 	strb.w	ip, [r0, #9]
   34dc6:	7281      	strb	r1, [r0, #10]
   34dc8:	f3c3 2c40 	ubfx	ip, r3, #9, #1
   34dcc:	2100      	movs	r1, #0
   34dce:	f3c3 2380 	ubfx	r3, r3, #10, #1
   34dd2:	0952      	lsrs	r2, r2, #5
   34dd4:	f880 c00b 	strb.w	ip, [r0, #11]
   34dd8:	7303      	strb	r3, [r0, #12]
   34dda:	7341      	strb	r1, [r0, #13]
   34ddc:	4610      	mov	r0, r2
   34dde:	4770      	bx	lr
   34de0:	4b04      	ldr	r3, [pc, #16]	; (34df4 <am_hal_reset_status_get+0x80>)
   34de2:	f8d3 385c 	ldr.w	r3, [r3, #2140]	; 0x85c
   34de6:	e7c9      	b.n	34d7c <am_hal_reset_status_get+0x8>
   34de8:	2206      	movs	r2, #6
   34dea:	4610      	mov	r0, r2
   34dec:	4770      	bx	lr
   34dee:	bf00      	nop
   34df0:	1001043c 	.word	0x1001043c
   34df4:	40008000 	.word	0x40008000

00034df8 <am_hal_rtc_time_set>:
   34df8:	6a83      	ldr	r3, [r0, #40]	; 0x28
   34dfa:	2b63      	cmp	r3, #99	; 0x63
   34dfc:	f200 80ad 	bhi.w	34f5a <am_hal_rtc_time_set+0x162>
   34e00:	6a41      	ldr	r1, [r0, #36]	; 0x24
   34e02:	293b      	cmp	r1, #59	; 0x3b
   34e04:	f200 80a9 	bhi.w	34f5a <am_hal_rtc_time_set+0x162>
   34e08:	6a02      	ldr	r2, [r0, #32]
   34e0a:	2a3b      	cmp	r2, #59	; 0x3b
   34e0c:	f200 80a5 	bhi.w	34f5a <am_hal_rtc_time_set+0x162>
   34e10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   34e14:	69c7      	ldr	r7, [r0, #28]
   34e16:	2f17      	cmp	r7, #23
   34e18:	b083      	sub	sp, #12
   34e1a:	f200 80a0 	bhi.w	34f5e <am_hal_rtc_time_set+0x166>
   34e1e:	6984      	ldr	r4, [r0, #24]
   34e20:	1e65      	subs	r5, r4, #1
   34e22:	2d1e      	cmp	r5, #30
   34e24:	f200 809b 	bhi.w	34f5e <am_hal_rtc_time_set+0x166>
   34e28:	6945      	ldr	r5, [r0, #20]
   34e2a:	1e6e      	subs	r6, r5, #1
   34e2c:	2e0b      	cmp	r6, #11
   34e2e:	f200 8096 	bhi.w	34f5e <am_hal_rtc_time_set+0x166>
   34e32:	f8d0 8010 	ldr.w	r8, [r0, #16]
   34e36:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
   34e3a:	f200 8090 	bhi.w	34f5e <am_hal_rtc_time_set+0x166>
   34e3e:	6886      	ldr	r6, [r0, #8]
   34e40:	9601      	str	r6, [sp, #4]
   34e42:	2e06      	cmp	r6, #6
   34e44:	f200 808b 	bhi.w	34f5e <am_hal_rtc_time_set+0x166>
   34e48:	fa5f fc81 	uxtb.w	ip, r1
   34e4c:	4946      	ldr	r1, [pc, #280]	; (34f68 <am_hal_rtc_time_set+0x170>)
   34e4e:	fa5f fe82 	uxtb.w	lr, r2
   34e52:	fa5f f688 	uxtb.w	r6, r8
   34e56:	fba1 980e 	umull	r9, r8, r1, lr
   34e5a:	ea4f 02d8 	mov.w	r2, r8, lsr #3
   34e5e:	fa5f fb87 	uxtb.w	fp, r7
   34e62:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   34e66:	ebae 0242 	sub.w	r2, lr, r2, lsl #1
   34e6a:	b2db      	uxtb	r3, r3
   34e6c:	fba1 ea0b 	umull	lr, sl, r1, fp
   34e70:	ea4f 08d8 	mov.w	r8, r8, lsr #3
   34e74:	fba1 e903 	umull	lr, r9, r1, r3
   34e78:	ea42 1208 	orr.w	r2, r2, r8, lsl #4
   34e7c:	fba1 e80c 	umull	lr, r8, r1, ip
   34e80:	ea4f 0eda 	mov.w	lr, sl, lsr #3
   34e84:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
   34e88:	ebab 0e4e 	sub.w	lr, fp, lr, lsl #1
   34e8c:	ea4f 0ada 	mov.w	sl, sl, lsr #3
   34e90:	b252      	sxtb	r2, r2
   34e92:	0412      	lsls	r2, r2, #16
   34e94:	ea4e 1e0a 	orr.w	lr, lr, sl, lsl #4
   34e98:	ea42 6e0e 	orr.w	lr, r2, lr, lsl #24
   34e9c:	ea4f 02d9 	mov.w	r2, r9, lsr #3
   34ea0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   34ea4:	eba3 0242 	sub.w	r2, r3, r2, lsl #1
   34ea8:	ea4f 03d8 	mov.w	r3, r8, lsr #3
   34eac:	4f2f      	ldr	r7, [pc, #188]	; (34f6c <am_hal_rtc_time_set+0x174>)
   34eae:	ea4f 09d9 	mov.w	r9, r9, lsr #3
   34eb2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   34eb6:	ea42 1209 	orr.w	r2, r2, r9, lsl #4
   34eba:	ebac 0c43 	sub.w	ip, ip, r3, lsl #1
   34ebe:	ea4f 08d8 	mov.w	r8, r8, lsr #3
   34ec2:	683b      	ldr	r3, [r7, #0]
   34ec4:	ea4c 1c08 	orr.w	ip, ip, r8, lsl #4
   34ec8:	b2d2      	uxtb	r2, r2
   34eca:	fa4f fc8c 	sxtb.w	ip, ip
   34ece:	ea4e 0202 	orr.w	r2, lr, r2
   34ed2:	ea42 220c 	orr.w	r2, r2, ip, lsl #8
   34ed6:	f043 0301 	orr.w	r3, r3, #1
   34eda:	603b      	str	r3, [r7, #0]
   34edc:	623a      	str	r2, [r7, #32]
   34ede:	6843      	ldr	r3, [r0, #4]
   34ee0:	68c2      	ldr	r2, [r0, #12]
   34ee2:	075b      	lsls	r3, r3, #29
   34ee4:	0712      	lsls	r2, r2, #28
   34ee6:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
   34eea:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
   34eee:	4313      	orrs	r3, r2
   34ef0:	9a01      	ldr	r2, [sp, #4]
   34ef2:	b2e4      	uxtb	r4, r4
   34ef4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   34ef8:	b2ed      	uxtb	r5, r5
   34efa:	fba1 2006 	umull	r2, r0, r1, r6
   34efe:	fba1 c204 	umull	ip, r2, r1, r4
   34f02:	fba1 c105 	umull	ip, r1, r1, r5
   34f06:	ea4f 0cd0 	mov.w	ip, r0, lsr #3
   34f0a:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
   34f0e:	eba6 064c 	sub.w	r6, r6, ip, lsl #1
   34f12:	08c0      	lsrs	r0, r0, #3
   34f14:	ea46 1600 	orr.w	r6, r6, r0, lsl #4
   34f18:	b2f6      	uxtb	r6, r6
   34f1a:	ea43 4606 	orr.w	r6, r3, r6, lsl #16
   34f1e:	08d3      	lsrs	r3, r2, #3
   34f20:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   34f24:	eba4 0443 	sub.w	r4, r4, r3, lsl #1
   34f28:	08cb      	lsrs	r3, r1, #3
   34f2a:	08d2      	lsrs	r2, r2, #3
   34f2c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   34f30:	ea44 1402 	orr.w	r4, r4, r2, lsl #4
   34f34:	eba5 0543 	sub.w	r5, r5, r3, lsl #1
   34f38:	08c9      	lsrs	r1, r1, #3
   34f3a:	ea45 1501 	orr.w	r5, r5, r1, lsl #4
   34f3e:	b2e4      	uxtb	r4, r4
   34f40:	4334      	orrs	r4, r6
   34f42:	b26d      	sxtb	r5, r5
   34f44:	ea44 2505 	orr.w	r5, r4, r5, lsl #8
   34f48:	627d      	str	r5, [r7, #36]	; 0x24
   34f4a:	683b      	ldr	r3, [r7, #0]
   34f4c:	2000      	movs	r0, #0
   34f4e:	f36f 0300 	bfc	r3, #0, #1
   34f52:	603b      	str	r3, [r7, #0]
   34f54:	b003      	add	sp, #12
   34f56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34f5a:	2001      	movs	r0, #1
   34f5c:	4770      	bx	lr
   34f5e:	2001      	movs	r0, #1
   34f60:	b003      	add	sp, #12
   34f62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   34f66:	bf00      	nop
   34f68:	cccccccd 	.word	0xcccccccd
   34f6c:	40004800 	.word	0x40004800

00034f70 <am_hal_rtc_time_get>:
   34f70:	4b2b      	ldr	r3, [pc, #172]	; (35020 <am_hal_rtc_time_get+0xb0>)
   34f72:	6a1a      	ldr	r2, [r3, #32]
   34f74:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   34f76:	0fd9      	lsrs	r1, r3, #31
   34f78:	6001      	str	r1, [r0, #0]
   34f7a:	2900      	cmp	r1, #0
   34f7c:	d14e      	bne.n	3501c <am_hal_rtc_time_get+0xac>
   34f7e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   34f82:	f3c3 5403 	ubfx	r4, r3, #20, #4
   34f86:	f3c2 1503 	ubfx	r5, r2, #4, #4
   34f8a:	eb04 0784 	add.w	r7, r4, r4, lsl #2
   34f8e:	f3c2 7601 	ubfx	r6, r2, #28, #2
   34f92:	f3c3 4403 	ubfx	r4, r3, #16, #4
   34f96:	eb05 0885 	add.w	r8, r5, r5, lsl #2
   34f9a:	eb04 0447 	add.w	r4, r4, r7, lsl #1
   34f9e:	f002 050f 	and.w	r5, r2, #15
   34fa2:	f3c2 6703 	ubfx	r7, r2, #24, #4
   34fa6:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   34faa:	eb07 0646 	add.w	r6, r7, r6, lsl #1
   34fae:	f3c2 3c02 	ubfx	ip, r2, #12, #3
   34fb2:	eb05 0548 	add.w	r5, r5, r8, lsl #1
   34fb6:	61c6      	str	r6, [r0, #28]
   34fb8:	f3c2 5e02 	ubfx	lr, r2, #20, #3
   34fbc:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
   34fc0:	b2ed      	uxtb	r5, r5
   34fc2:	f3c2 4603 	ubfx	r6, r2, #16, #4
   34fc6:	f3c2 2203 	ubfx	r2, r2, #8, #4
   34fca:	6285      	str	r5, [r0, #40]	; 0x28
   34fcc:	eb02 024c 	add.w	r2, r2, ip, lsl #1
   34fd0:	b2e4      	uxtb	r4, r4
   34fd2:	f3c3 3500 	ubfx	r5, r3, #12, #1
   34fd6:	6104      	str	r4, [r0, #16]
   34fd8:	6242      	str	r2, [r0, #36]	; 0x24
   34fda:	f3c3 1401 	ubfx	r4, r3, #4, #2
   34fde:	f3c3 2203 	ubfx	r2, r3, #8, #4
   34fe2:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   34fe6:	eb02 0545 	add.w	r5, r2, r5, lsl #1
   34fea:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   34fee:	f003 020f 	and.w	r2, r3, #15
   34ff2:	eb02 0444 	add.w	r4, r2, r4, lsl #1
   34ff6:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
   34ffa:	6184      	str	r4, [r0, #24]
   34ffc:	f3c3 7200 	ubfx	r2, r3, #28, #1
   35000:	f3c3 7440 	ubfx	r4, r3, #29, #1
   35004:	eb06 064e 	add.w	r6, r6, lr, lsl #1
   35008:	f3c3 6302 	ubfx	r3, r3, #24, #3
   3500c:	e9c0 3202 	strd	r3, r2, [r0, #8]
   35010:	6206      	str	r6, [r0, #32]
   35012:	6145      	str	r5, [r0, #20]
   35014:	6044      	str	r4, [r0, #4]
   35016:	4608      	mov	r0, r1
   35018:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3501c:	4608      	mov	r0, r1
   3501e:	4770      	bx	lr
   35020:	40004800 	.word	0x40004800

00035024 <am_hal_rtc_alarm_get>:
   35024:	4a38      	ldr	r2, [pc, #224]	; (35108 <am_hal_rtc_alarm_get+0xe4>)
   35026:	6b13      	ldr	r3, [r2, #48]	; 0x30
   35028:	6b52      	ldr	r2, [r2, #52]	; 0x34
   3502a:	2800      	cmp	r0, #0
   3502c:	d049      	beq.n	350c2 <am_hal_rtc_alarm_get+0x9e>
   3502e:	b5f0      	push	{r4, r5, r6, r7, lr}
   35030:	f3c3 7601 	ubfx	r6, r3, #28, #2
   35034:	f3c3 6703 	ubfx	r7, r3, #24, #4
   35038:	eb06 0686 	add.w	r6, r6, r6, lsl #2
   3503c:	f3c3 1403 	ubfx	r4, r3, #4, #4
   35040:	f3c3 3e02 	ubfx	lr, r3, #12, #3
   35044:	eb07 0646 	add.w	r6, r7, r6, lsl #1
   35048:	eb04 0c84 	add.w	ip, r4, r4, lsl #2
   3504c:	f3c3 5502 	ubfx	r5, r3, #20, #3
   35050:	f003 040f 	and.w	r4, r3, #15
   35054:	eb0e 0e8e 	add.w	lr, lr, lr, lsl #2
   35058:	61c6      	str	r6, [r0, #28]
   3505a:	f3c3 4603 	ubfx	r6, r3, #16, #4
   3505e:	f3c3 2303 	ubfx	r3, r3, #8, #4
   35062:	eb04 044c 	add.w	r4, r4, ip, lsl #1
   35066:	eb03 034e 	add.w	r3, r3, lr, lsl #1
   3506a:	f3c2 3c00 	ubfx	ip, r2, #12, #1
   3506e:	b2e4      	uxtb	r4, r4
   35070:	eb0c 0c8c 	add.w	ip, ip, ip, lsl #2
   35074:	6243      	str	r3, [r0, #36]	; 0x24
   35076:	f3c2 2303 	ubfx	r3, r2, #8, #4
   3507a:	eb03 034c 	add.w	r3, r3, ip, lsl #1
   3507e:	6284      	str	r4, [r0, #40]	; 0x28
   35080:	f3c2 1401 	ubfx	r4, r2, #4, #2
   35084:	eb05 0585 	add.w	r5, r5, r5, lsl #2
   35088:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   3508c:	6143      	str	r3, [r0, #20]
   3508e:	f002 030f 	and.w	r3, r2, #15
   35092:	eb03 0444 	add.w	r4, r3, r4, lsl #1
   35096:	eb06 0545 	add.w	r5, r6, r5, lsl #1
   3509a:	2300      	movs	r3, #0
   3509c:	f3c2 4202 	ubfx	r2, r2, #16, #3
   350a0:	e9c0 3300 	strd	r3, r3, [r0]
   350a4:	e9c0 3303 	strd	r3, r3, [r0, #12]
   350a8:	6205      	str	r5, [r0, #32]
   350aa:	6082      	str	r2, [r0, #8]
   350ac:	6184      	str	r4, [r0, #24]
   350ae:	b131      	cbz	r1, 350be <am_hal_rtc_alarm_get+0x9a>
   350b0:	4a15      	ldr	r2, [pc, #84]	; (35108 <am_hal_rtc_alarm_get+0xe4>)
   350b2:	6813      	ldr	r3, [r2, #0]
   350b4:	f3c3 0342 	ubfx	r3, r3, #1, #3
   350b8:	2b07      	cmp	r3, #7
   350ba:	d00c      	beq.n	350d6 <am_hal_rtc_alarm_get+0xb2>
   350bc:	700b      	strb	r3, [r1, #0]
   350be:	2000      	movs	r0, #0
   350c0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   350c2:	b131      	cbz	r1, 350d2 <am_hal_rtc_alarm_get+0xae>
   350c4:	4a10      	ldr	r2, [pc, #64]	; (35108 <am_hal_rtc_alarm_get+0xe4>)
   350c6:	6813      	ldr	r3, [r2, #0]
   350c8:	f3c3 0342 	ubfx	r3, r3, #1, #3
   350cc:	2b07      	cmp	r3, #7
   350ce:	d00c      	beq.n	350ea <am_hal_rtc_alarm_get+0xc6>
   350d0:	700b      	strb	r3, [r1, #0]
   350d2:	2000      	movs	r0, #0
   350d4:	4770      	bx	lr
   350d6:	6b13      	ldr	r3, [r2, #48]	; 0x30
   350d8:	b2db      	uxtb	r3, r3
   350da:	2bf0      	cmp	r3, #240	; 0xf0
   350dc:	d00e      	beq.n	350fc <am_hal_rtc_alarm_get+0xd8>
   350de:	2bff      	cmp	r3, #255	; 0xff
   350e0:	bf0c      	ite	eq
   350e2:	2309      	moveq	r3, #9
   350e4:	2307      	movne	r3, #7
   350e6:	700b      	strb	r3, [r1, #0]
   350e8:	e7e9      	b.n	350be <am_hal_rtc_alarm_get+0x9a>
   350ea:	6b13      	ldr	r3, [r2, #48]	; 0x30
   350ec:	b2db      	uxtb	r3, r3
   350ee:	2bf0      	cmp	r3, #240	; 0xf0
   350f0:	d007      	beq.n	35102 <am_hal_rtc_alarm_get+0xde>
   350f2:	2bff      	cmp	r3, #255	; 0xff
   350f4:	bf0c      	ite	eq
   350f6:	2309      	moveq	r3, #9
   350f8:	2307      	movne	r3, #7
   350fa:	e7e9      	b.n	350d0 <am_hal_rtc_alarm_get+0xac>
   350fc:	2308      	movs	r3, #8
   350fe:	700b      	strb	r3, [r1, #0]
   35100:	e7dd      	b.n	350be <am_hal_rtc_alarm_get+0x9a>
   35102:	2308      	movs	r3, #8
   35104:	e7e4      	b.n	350d0 <am_hal_rtc_alarm_get+0xac>
   35106:	bf00      	nop
   35108:	40004800 	.word	0x40004800

0003510c <am_hal_rtc_interrupt_clear>:
   3510c:	4b02      	ldr	r3, [pc, #8]	; (35118 <am_hal_rtc_interrupt_clear+0xc>)
   3510e:	f8c3 0208 	str.w	r0, [r3, #520]	; 0x208
   35112:	2000      	movs	r0, #0
   35114:	4770      	bx	lr
   35116:	bf00      	nop
   35118:	40004800 	.word	0x40004800

0003511c <am_hal_sysctrl_sleep>:
   3511c:	b530      	push	{r4, r5, lr}
   3511e:	b083      	sub	sp, #12
   35120:	f10d 4370 	add.w	r3, sp, #4026531840	; 0xf0000000
   35124:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
   35128:	d300      	bcc.n	3512c <am_hal_sysctrl_sleep+0x10>
   3512a:	e7fe      	b.n	3512a <am_hal_sysctrl_sleep+0xe>
   3512c:	4604      	mov	r4, r0
   3512e:	f7fe fe65 	bl	33dfc <am_hal_interrupt_master_disable>
   35132:	4935      	ldr	r1, [pc, #212]	; (35208 <am_hal_sysctrl_sleep+0xec>)
   35134:	9001      	str	r0, [sp, #4]
   35136:	f8d1 3108 	ldr.w	r3, [r1, #264]	; 0x108
   3513a:	f3c3 1301 	ubfx	r3, r3, #4, #2
   3513e:	b384      	cbz	r4, 351a2 <am_hal_sysctrl_sleep+0x86>
   35140:	4a32      	ldr	r2, [pc, #200]	; (3520c <am_hal_sysctrl_sleep+0xf0>)
   35142:	f8d2 5250 	ldr.w	r5, [r2, #592]	; 0x250
   35146:	f015 0501 	ands.w	r5, r5, #1
   3514a:	d12a      	bne.n	351a2 <am_hal_sysctrl_sleep+0x86>
   3514c:	2b03      	cmp	r3, #3
   3514e:	d03a      	beq.n	351c6 <am_hal_sysctrl_sleep+0xaa>
   35150:	4a2f      	ldr	r2, [pc, #188]	; (35210 <am_hal_sysctrl_sleep+0xf4>)
   35152:	6913      	ldr	r3, [r2, #16]
   35154:	f043 0304 	orr.w	r3, r3, #4
   35158:	2100      	movs	r1, #0
   3515a:	6113      	str	r3, [r2, #16]
   3515c:	2001      	movs	r0, #1
   3515e:	f7fe fdd1 	bl	33d04 <am_hal_daxi_control>
   35162:	bf30      	wfi
   35164:	f3bf 8f6f 	isb	sy
   35168:	b33d      	cbz	r5, 351ba <am_hal_sysctrl_sleep+0x9e>
   3516a:	2001      	movs	r0, #1
   3516c:	f001 fadc 	bl	36728 <buck_ldo_update_override>
   35170:	4b26      	ldr	r3, [pc, #152]	; (3520c <am_hal_sysctrl_sleep+0xf0>)
   35172:	f8d3 2380 	ldr.w	r2, [r3, #896]	; 0x380
   35176:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   3517a:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380
   3517e:	f8d3 2380 	ldr.w	r2, [r3, #896]	; 0x380
   35182:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
   35186:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380
   3518a:	f8d3 2370 	ldr.w	r2, [r3, #880]	; 0x370
   3518e:	f36f 5219 	bfc	r2, #20, #6
   35192:	f8c3 2370 	str.w	r2, [r3, #880]	; 0x370
   35196:	9801      	ldr	r0, [sp, #4]
   35198:	b003      	add	sp, #12
   3519a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   3519e:	f7fe be31 	b.w	33e04 <am_hal_interrupt_master_set>
   351a2:	4a1b      	ldr	r2, [pc, #108]	; (35210 <am_hal_sysctrl_sleep+0xf4>)
   351a4:	6913      	ldr	r3, [r2, #16]
   351a6:	f023 0304 	bic.w	r3, r3, #4
   351aa:	2100      	movs	r1, #0
   351ac:	6113      	str	r3, [r2, #16]
   351ae:	2001      	movs	r0, #1
   351b0:	f7fe fda8 	bl	33d04 <am_hal_daxi_control>
   351b4:	bf30      	wfi
   351b6:	f3bf 8f6f 	isb	sy
   351ba:	9801      	ldr	r0, [sp, #4]
   351bc:	b003      	add	sp, #12
   351be:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   351c2:	f7fe be1f 	b.w	33e04 <am_hal_interrupt_master_set>
   351c6:	690b      	ldr	r3, [r1, #16]
   351c8:	055b      	lsls	r3, r3, #21
   351ca:	d4c1      	bmi.n	35150 <am_hal_sysctrl_sleep+0x34>
   351cc:	688b      	ldr	r3, [r1, #8]
   351ce:	f033 437e 	bics.w	r3, r3, #4261412864	; 0xfe000000
   351d2:	d1bd      	bne.n	35150 <am_hal_sysctrl_sleep+0x34>
   351d4:	490f      	ldr	r1, [pc, #60]	; (35214 <am_hal_sysctrl_sleep+0xf8>)
   351d6:	f8d2 3370 	ldr.w	r3, [r2, #880]	; 0x370
   351da:	6809      	ldr	r1, [r1, #0]
   351dc:	f361 5319 	bfi	r3, r1, #20, #6
   351e0:	f8c2 3370 	str.w	r3, [r2, #880]	; 0x370
   351e4:	f8d2 3380 	ldr.w	r3, [r2, #896]	; 0x380
   351e8:	f365 73df 	bfi	r3, r5, #31, #1
   351ec:	f8c2 3380 	str.w	r3, [r2, #896]	; 0x380
   351f0:	f8d2 3380 	ldr.w	r3, [r2, #896]	; 0x380
   351f4:	f365 739e 	bfi	r3, r5, #30, #1
   351f8:	4628      	mov	r0, r5
   351fa:	f8c2 3380 	str.w	r3, [r2, #896]	; 0x380
   351fe:	f001 fa93 	bl	36728 <buck_ldo_update_override>
   35202:	4625      	mov	r5, r4
   35204:	e7a4      	b.n	35150 <am_hal_sysctrl_sleep+0x34>
   35206:	bf00      	nop
   35208:	40021000 	.word	0x40021000
   3520c:	40020000 	.word	0x40020000
   35210:	e000ed00 	.word	0xe000ed00
   35214:	10003844 	.word	0x10003844

00035218 <am_hal_sysctrl_fpu_enable>:
   35218:	4b02      	ldr	r3, [pc, #8]	; (35224 <am_hal_sysctrl_fpu_enable+0xc>)
   3521a:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   3521e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
   35222:	4770      	bx	lr
   35224:	e000ed00 	.word	0xe000ed00

00035228 <am_hal_sysctrl_fpu_stacking_enable>:
   35228:	b510      	push	{r4, lr}
   3522a:	b082      	sub	sp, #8
   3522c:	4604      	mov	r4, r0
   3522e:	f7fe fde5 	bl	33dfc <am_hal_interrupt_master_disable>
   35232:	4909      	ldr	r1, [pc, #36]	; (35258 <am_hal_sysctrl_fpu_stacking_enable+0x30>)
   35234:	9001      	str	r0, [sp, #4]
   35236:	6b4a      	ldr	r2, [r1, #52]	; 0x34
   35238:	2c00      	cmp	r4, #0
   3523a:	f022 4240 	bic.w	r2, r2, #3221225472	; 0xc0000000
   3523e:	bf14      	ite	ne
   35240:	f04f 4340 	movne.w	r3, #3221225472	; 0xc0000000
   35244:	f04f 4300 	moveq.w	r3, #2147483648	; 0x80000000
   35248:	4313      	orrs	r3, r2
   3524a:	634b      	str	r3, [r1, #52]	; 0x34
   3524c:	9801      	ldr	r0, [sp, #4]
   3524e:	b002      	add	sp, #8
   35250:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   35254:	f7fe bdd6 	b.w	33e04 <am_hal_interrupt_master_set>
   35258:	e000ef00 	.word	0xe000ef00

0003525c <am_hal_tpiu_enable>:
   3525c:	4b16      	ldr	r3, [pc, #88]	; (352b8 <am_hal_tpiu_enable+0x5c>)
   3525e:	4a17      	ldr	r2, [pc, #92]	; (352bc <am_hal_tpiu_enable+0x60>)
   35260:	b410      	push	{r4}
   35262:	2101      	movs	r1, #1
   35264:	2400      	movs	r4, #0
   35266:	f8c3 4304 	str.w	r4, [r3, #772]	; 0x304
   3526a:	6059      	str	r1, [r3, #4]
   3526c:	f5a0 4361 	sub.w	r3, r0, #57600	; 0xe100
   35270:	4293      	cmp	r3, r2
   35272:	4a11      	ldr	r2, [pc, #68]	; (352b8 <am_hal_tpiu_enable+0x5c>)
   35274:	bf9a      	itte	ls
   35276:	4b12      	ldrls	r3, [pc, #72]	; (352c0 <am_hal_tpiu_enable+0x64>)
   35278:	fbb3 f0f0 	udivls	r0, r3, r0
   3527c:	202f      	movhi	r0, #47	; 0x2f
   3527e:	4b11      	ldr	r3, [pc, #68]	; (352c4 <am_hal_tpiu_enable+0x68>)
   35280:	bf98      	it	ls
   35282:	f100 30ff 	addls.w	r0, r0, #4294967295	; 0xffffffff
   35286:	2102      	movs	r1, #2
   35288:	2400      	movs	r4, #0
   3528a:	6110      	str	r0, [r2, #16]
   3528c:	f8c2 10f0 	str.w	r1, [r2, #240]	; 0xf0
   35290:	f8c2 4f00 	str.w	r4, [r2, #3840]	; 0xf00
   35294:	f8d3 2250 	ldr.w	r2, [r3, #592]	; 0x250
   35298:	f361 0243 	bfi	r2, r1, #1, #3
   3529c:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
   352a0:	f8d3 2250 	ldr.w	r2, [r3, #592]	; 0x250
   352a4:	f042 0201 	orr.w	r2, r2, #1
   352a8:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
   352ac:	f85d 4b04 	ldr.w	r4, [sp], #4
   352b0:	2064      	movs	r0, #100	; 0x64
   352b2:	f000 b809 	b.w	352c8 <am_hal_delay_us>
   352b6:	bf00      	nop
   352b8:	e0040000 	.word	0xe0040000
   352bc:	001da380 	.word	0x001da380
   352c0:	02dc6c00 	.word	0x02dc6c00
   352c4:	40020000 	.word	0x40020000

000352c8 <am_hal_delay_us>:
   352c8:	4b09      	ldr	r3, [pc, #36]	; (352f0 <am_hal_delay_us+0x28>)
   352ca:	681b      	ldr	r3, [r3, #0]
   352cc:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   352d0:	2b02      	cmp	r3, #2
   352d2:	bf0b      	itete	eq
   352d4:	0182      	lsleq	r2, r0, #6
   352d6:	0142      	lslne	r2, r0, #5
   352d8:	2015      	moveq	r0, #21
   352da:	200f      	movne	r0, #15
   352dc:	4282      	cmp	r2, r0
   352de:	d906      	bls.n	352ee <am_hal_delay_us+0x26>
   352e0:	4b04      	ldr	r3, [pc, #16]	; (352f4 <am_hal_delay_us+0x2c>)
   352e2:	b082      	sub	sp, #8
   352e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   352e6:	9301      	str	r3, [sp, #4]
   352e8:	1a10      	subs	r0, r2, r0
   352ea:	b002      	add	sp, #8
   352ec:	4718      	bx	r3
   352ee:	4770      	bx	lr
   352f0:	40021000 	.word	0x40021000
   352f4:	00046a4c 	.word	0x00046a4c

000352f8 <am_hal_delay_us_status_change>:
   352f8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   352fc:	460c      	mov	r4, r1
   352fe:	6809      	ldr	r1, [r1, #0]
   35300:	4011      	ands	r1, r2
   35302:	428b      	cmp	r3, r1
   35304:	d01a      	beq.n	3533c <am_hal_delay_us_status_change+0x44>
   35306:	f100 39ff 	add.w	r9, r0, #4294967295	; 0xffffffff
   3530a:	b1d0      	cbz	r0, 35342 <am_hal_delay_us_status_change+0x4a>
   3530c:	461e      	mov	r6, r3
   3530e:	4b0e      	ldr	r3, [pc, #56]	; (35348 <am_hal_delay_us_status_change+0x50>)
   35310:	4f0e      	ldr	r7, [pc, #56]	; (3534c <am_hal_delay_us_status_change+0x54>)
   35312:	f8d3 8024 	ldr.w	r8, [r3, #36]	; 0x24
   35316:	4615      	mov	r5, r2
   35318:	e002      	b.n	35320 <am_hal_delay_us_status_change+0x28>
   3531a:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   3531e:	d010      	beq.n	35342 <am_hal_delay_us_status_change+0x4a>
   35320:	6838      	ldr	r0, [r7, #0]
   35322:	f3c0 00c1 	ubfx	r0, r0, #3, #2
   35326:	2802      	cmp	r0, #2
   35328:	bf14      	ite	ne
   3532a:	2011      	movne	r0, #17
   3532c:	202b      	moveq	r0, #43	; 0x2b
   3532e:	47c0      	blx	r8
   35330:	6820      	ldr	r0, [r4, #0]
   35332:	4028      	ands	r0, r5
   35334:	42b0      	cmp	r0, r6
   35336:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
   3533a:	d1ee      	bne.n	3531a <am_hal_delay_us_status_change+0x22>
   3533c:	2000      	movs	r0, #0
   3533e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   35342:	2004      	movs	r0, #4
   35344:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   35348:	00046a4c 	.word	0x00046a4c
   3534c:	40021000 	.word	0x40021000

00035350 <am_hal_delay_us_status_check>:
   35350:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   35354:	f89d c020 	ldrb.w	ip, [sp, #32]
   35358:	f8df 8068 	ldr.w	r8, [pc, #104]	; 353c4 <am_hal_delay_us_status_check+0x74>
   3535c:	f8df 9068 	ldr.w	r9, [pc, #104]	; 353c8 <am_hal_delay_us_status_check+0x78>
   35360:	4604      	mov	r4, r0
   35362:	460d      	mov	r5, r1
   35364:	4616      	mov	r6, r2
   35366:	461f      	mov	r7, r3
   35368:	f1bc 0f00 	cmp.w	ip, #0
   3536c:	d00d      	beq.n	3538a <am_hal_delay_us_status_check+0x3a>
   3536e:	e020      	b.n	353b2 <am_hal_delay_us_status_check+0x62>
   35370:	b324      	cbz	r4, 353bc <am_hal_delay_us_status_check+0x6c>
   35372:	f8d8 3000 	ldr.w	r3, [r8]
   35376:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
   3537a:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   3537e:	2b02      	cmp	r3, #2
   35380:	bf14      	ite	ne
   35382:	2011      	movne	r0, #17
   35384:	202b      	moveq	r0, #43	; 0x2b
   35386:	4790      	blx	r2
   35388:	3c01      	subs	r4, #1
   3538a:	6828      	ldr	r0, [r5, #0]
   3538c:	4030      	ands	r0, r6
   3538e:	42b8      	cmp	r0, r7
   35390:	d0ee      	beq.n	35370 <am_hal_delay_us_status_check+0x20>
   35392:	2000      	movs	r0, #0
   35394:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   35398:	b184      	cbz	r4, 353bc <am_hal_delay_us_status_check+0x6c>
   3539a:	f8d8 3000 	ldr.w	r3, [r8]
   3539e:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
   353a2:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   353a6:	2b02      	cmp	r3, #2
   353a8:	bf14      	ite	ne
   353aa:	2011      	movne	r0, #17
   353ac:	202b      	moveq	r0, #43	; 0x2b
   353ae:	4790      	blx	r2
   353b0:	3c01      	subs	r4, #1
   353b2:	6828      	ldr	r0, [r5, #0]
   353b4:	4030      	ands	r0, r6
   353b6:	42b8      	cmp	r0, r7
   353b8:	d1ee      	bne.n	35398 <am_hal_delay_us_status_check+0x48>
   353ba:	e7ea      	b.n	35392 <am_hal_delay_us_status_check+0x42>
   353bc:	2004      	movs	r0, #4
   353be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   353c2:	bf00      	nop
   353c4:	40021000 	.word	0x40021000
   353c8:	00046a4c 	.word	0x00046a4c

000353cc <ForceFIFOpop>:
   353cc:	4b1e      	ldr	r3, [pc, #120]	; (35448 <ForceFIFOpop+0x7c>)
   353ce:	681a      	ldr	r2, [r3, #0]
   353d0:	b570      	push	{r4, r5, r6, lr}
   353d2:	0754      	lsls	r4, r2, #29
   353d4:	4605      	mov	r5, r0
   353d6:	d402      	bmi.n	353de <ForceFIFOpop+0x12>
   353d8:	681b      	ldr	r3, [r3, #0]
   353da:	07d8      	lsls	r0, r3, #31
   353dc:	d409      	bmi.n	353f2 <ForceFIFOpop+0x26>
   353de:	4b1a      	ldr	r3, [pc, #104]	; (35448 <ForceFIFOpop+0x7c>)
   353e0:	681a      	ldr	r2, [r3, #0]
   353e2:	07d1      	lsls	r1, r2, #31
   353e4:	d526      	bpl.n	35434 <ForceFIFOpop+0x68>
   353e6:	681a      	ldr	r2, [r3, #0]
   353e8:	0752      	lsls	r2, r2, #29
   353ea:	d523      	bpl.n	35434 <ForceFIFOpop+0x68>
   353ec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   353ee:	2b00      	cmp	r3, #0
   353f0:	da20      	bge.n	35434 <ForceFIFOpop+0x68>
   353f2:	4c15      	ldr	r4, [pc, #84]	; (35448 <ForceFIFOpop+0x7c>)
   353f4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   353f6:	f013 6f7f 	tst.w	r3, #267386880	; 0xff00000
   353fa:	d110      	bne.n	3541e <ForceFIFOpop+0x52>
   353fc:	4e13      	ldr	r6, [pc, #76]	; (3544c <ForceFIFOpop+0x80>)
   353fe:	682b      	ldr	r3, [r5, #0]
   35400:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   35404:	42b3      	cmp	r3, r6
   35406:	f04f 0237 	mov.w	r2, #55	; 0x37
   3540a:	f04f 001e 	mov.w	r0, #30
   3540e:	d112      	bne.n	35436 <ForceFIFOpop+0x6a>
   35410:	60a2      	str	r2, [r4, #8]
   35412:	f7ff ff59 	bl	352c8 <am_hal_delay_us>
   35416:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   35418:	f013 6f7f 	tst.w	r3, #267386880	; 0xff00000
   3541c:	d0ef      	beq.n	353fe <ForceFIFOpop+0x32>
   3541e:	4b0a      	ldr	r3, [pc, #40]	; (35448 <ForceFIFOpop+0x7c>)
   35420:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   35422:	f012 6f7f 	tst.w	r2, #267386880	; 0xff00000
   35426:	d005      	beq.n	35434 <ForceFIFOpop+0x68>
   35428:	2100      	movs	r1, #0
   3542a:	6399      	str	r1, [r3, #56]	; 0x38
   3542c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   3542e:	f012 6f7f 	tst.w	r2, #267386880	; 0xff00000
   35432:	d1fa      	bne.n	3542a <ForceFIFOpop+0x5e>
   35434:	bd70      	pop	{r4, r5, r6, pc}
   35436:	201e      	movs	r0, #30
   35438:	f7ff ff46 	bl	352c8 <am_hal_delay_us>
   3543c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   3543e:	f013 6f7f 	tst.w	r3, #267386880	; 0xff00000
   35442:	d0dc      	beq.n	353fe <ForceFIFOpop+0x32>
   35444:	e7eb      	b.n	3541e <ForceFIFOpop+0x52>
   35446:	bf00      	nop
   35448:	40038000 	.word	0x40038000
   3544c:	01afafaf 	.word	0x01afafaf

00035450 <am_hal_adc_enable>:
   35450:	6802      	ldr	r2, [r0, #0]
   35452:	4914      	ldr	r1, [pc, #80]	; (354a4 <am_hal_adc_enable+0x54>)
   35454:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   35458:	428a      	cmp	r2, r1
   3545a:	d121      	bne.n	354a0 <am_hal_adc_enable+0x50>
   3545c:	78c2      	ldrb	r2, [r0, #3]
   3545e:	f012 0202 	ands.w	r2, r2, #2
   35462:	d001      	beq.n	35468 <am_hal_adc_enable+0x18>
   35464:	2000      	movs	r0, #0
   35466:	4770      	bx	lr
   35468:	b570      	push	{r4, r5, r6, lr}
   3546a:	4c0f      	ldr	r4, [pc, #60]	; (354a8 <am_hal_adc_enable+0x58>)
   3546c:	f8d4 5200 	ldr.w	r5, [r4, #512]	; 0x200
   35470:	f8c4 2200 	str.w	r2, [r4, #512]	; 0x200
   35474:	f8d4 6204 	ldr.w	r6, [r4, #516]	; 0x204
   35478:	6822      	ldr	r2, [r4, #0]
   3547a:	f042 0201 	orr.w	r2, r2, #1
   3547e:	6022      	str	r2, [r4, #0]
   35480:	78c2      	ldrb	r2, [r0, #3]
   35482:	f042 0202 	orr.w	r2, r2, #2
   35486:	70c2      	strb	r2, [r0, #3]
   35488:	f7ff ffa0 	bl	353cc <ForceFIFOpop>
   3548c:	07b3      	lsls	r3, r6, #30
   3548e:	bf04      	itt	eq
   35490:	2303      	moveq	r3, #3
   35492:	f8c4 3208 	streq.w	r3, [r4, #520]	; 0x208
   35496:	4b04      	ldr	r3, [pc, #16]	; (354a8 <am_hal_adc_enable+0x58>)
   35498:	2000      	movs	r0, #0
   3549a:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
   3549e:	bd70      	pop	{r4, r5, r6, pc}
   354a0:	2002      	movs	r0, #2
   354a2:	4770      	bx	lr
   354a4:	01afafaf 	.word	0x01afafaf
   354a8:	40038000 	.word	0x40038000

000354ac <am_hal_adc_interrupt_enable>:
   354ac:	6803      	ldr	r3, [r0, #0]
   354ae:	4a07      	ldr	r2, [pc, #28]	; (354cc <am_hal_adc_interrupt_enable+0x20>)
   354b0:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   354b4:	4293      	cmp	r3, r2
   354b6:	d107      	bne.n	354c8 <am_hal_adc_interrupt_enable+0x1c>
   354b8:	4a05      	ldr	r2, [pc, #20]	; (354d0 <am_hal_adc_interrupt_enable+0x24>)
   354ba:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   354be:	4319      	orrs	r1, r3
   354c0:	2000      	movs	r0, #0
   354c2:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   354c6:	4770      	bx	lr
   354c8:	2002      	movs	r0, #2
   354ca:	4770      	bx	lr
   354cc:	01afafaf 	.word	0x01afafaf
   354d0:	40038000 	.word	0x40038000

000354d4 <am_hal_adc_interrupt_disable>:
   354d4:	6803      	ldr	r3, [r0, #0]
   354d6:	4a08      	ldr	r2, [pc, #32]	; (354f8 <am_hal_adc_interrupt_disable+0x24>)
   354d8:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   354dc:	4293      	cmp	r3, r2
   354de:	d108      	bne.n	354f2 <am_hal_adc_interrupt_disable+0x1e>
   354e0:	4a06      	ldr	r2, [pc, #24]	; (354fc <am_hal_adc_interrupt_disable+0x28>)
   354e2:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   354e6:	ea23 0101 	bic.w	r1, r3, r1
   354ea:	2000      	movs	r0, #0
   354ec:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   354f0:	4770      	bx	lr
   354f2:	2002      	movs	r0, #2
   354f4:	4770      	bx	lr
   354f6:	bf00      	nop
   354f8:	01afafaf 	.word	0x01afafaf
   354fc:	40038000 	.word	0x40038000

00035500 <am_hal_adc_interrupt_status>:
   35500:	6803      	ldr	r3, [r0, #0]
   35502:	b410      	push	{r4}
   35504:	4c0e      	ldr	r4, [pc, #56]	; (35540 <am_hal_adc_interrupt_status+0x40>)
   35506:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   3550a:	42a3      	cmp	r3, r4
   3550c:	d113      	bne.n	35536 <am_hal_adc_interrupt_status+0x36>
   3550e:	b93a      	cbnz	r2, 35520 <am_hal_adc_interrupt_status+0x20>
   35510:	4b0c      	ldr	r3, [pc, #48]	; (35544 <am_hal_adc_interrupt_status+0x44>)
   35512:	f85d 4b04 	ldr.w	r4, [sp], #4
   35516:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
   3551a:	600b      	str	r3, [r1, #0]
   3551c:	4610      	mov	r0, r2
   3551e:	4770      	bx	lr
   35520:	4a08      	ldr	r2, [pc, #32]	; (35544 <am_hal_adc_interrupt_status+0x44>)
   35522:	f8d2 4204 	ldr.w	r4, [r2, #516]	; 0x204
   35526:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
   3552a:	4023      	ands	r3, r4
   3552c:	2000      	movs	r0, #0
   3552e:	f85d 4b04 	ldr.w	r4, [sp], #4
   35532:	600b      	str	r3, [r1, #0]
   35534:	4770      	bx	lr
   35536:	2002      	movs	r0, #2
   35538:	f85d 4b04 	ldr.w	r4, [sp], #4
   3553c:	4770      	bx	lr
   3553e:	bf00      	nop
   35540:	01afafaf 	.word	0x01afafaf
   35544:	40038000 	.word	0x40038000

00035548 <am_hal_adc_interrupt_clear>:
   35548:	6803      	ldr	r3, [r0, #0]
   3554a:	4a05      	ldr	r2, [pc, #20]	; (35560 <am_hal_adc_interrupt_clear+0x18>)
   3554c:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   35550:	4293      	cmp	r3, r2
   35552:	bf03      	ittte	eq
   35554:	4b03      	ldreq	r3, [pc, #12]	; (35564 <am_hal_adc_interrupt_clear+0x1c>)
   35556:	2000      	moveq	r0, #0
   35558:	f8c3 1208 	streq.w	r1, [r3, #520]	; 0x208
   3555c:	2002      	movne	r0, #2
   3555e:	4770      	bx	lr
   35560:	01afafaf 	.word	0x01afafaf
   35564:	40038000 	.word	0x40038000

00035568 <am_hal_adc_samples_read>:
   35568:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3556c:	6804      	ldr	r4, [r0, #0]
   3556e:	4dc3      	ldr	r5, [pc, #780]	; (3587c <am_hal_adc_samples_read+0x314>)
   35570:	9806      	ldr	r0, [sp, #24]
   35572:	f024 447e 	bic.w	r4, r4, #4261412864	; 0xfe000000
   35576:	42ac      	cmp	r4, r5
   35578:	d161      	bne.n	3563e <am_hal_adc_samples_read+0xd6>
   3557a:	2800      	cmp	r0, #0
   3557c:	f000 812c 	beq.w	357d8 <am_hal_adc_samples_read+0x270>
   35580:	2500      	movs	r5, #0
   35582:	681c      	ldr	r4, [r3, #0]
   35584:	601d      	str	r5, [r3, #0]
   35586:	2a00      	cmp	r2, #0
   35588:	f000 80ac 	beq.w	356e4 <am_hal_adc_samples_read+0x17c>
   3558c:	49bc      	ldr	r1, [pc, #752]	; (35880 <am_hal_adc_samples_read+0x318>)
   3558e:	68cd      	ldr	r5, [r1, #12]
   35590:	6909      	ldr	r1, [r1, #16]
   35592:	f3c1 2103 	ubfx	r1, r1, #8, #4
   35596:	2908      	cmp	r1, #8
   35598:	49b9      	ldr	r1, [pc, #740]	; (35880 <am_hal_adc_samples_read+0x318>)
   3559a:	f3c5 2e03 	ubfx	lr, r5, #8, #4
   3559e:	6949      	ldr	r1, [r1, #20]
   355a0:	f1ae 0e08 	sub.w	lr, lr, #8
   355a4:	fabe fe8e 	clz	lr, lr
   355a8:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
   355ac:	f3c1 2103 	ubfx	r1, r1, #8, #4
   355b0:	bf08      	it	eq
   355b2:	f04e 0e02 	orreq.w	lr, lr, #2
   355b6:	2908      	cmp	r1, #8
   355b8:	49b1      	ldr	r1, [pc, #708]	; (35880 <am_hal_adc_samples_read+0x318>)
   355ba:	6989      	ldr	r1, [r1, #24]
   355bc:	f3c1 2103 	ubfx	r1, r1, #8, #4
   355c0:	bf08      	it	eq
   355c2:	f04e 0e04 	orreq.w	lr, lr, #4
   355c6:	2908      	cmp	r1, #8
   355c8:	49ad      	ldr	r1, [pc, #692]	; (35880 <am_hal_adc_samples_read+0x318>)
   355ca:	69c9      	ldr	r1, [r1, #28]
   355cc:	f3c1 2103 	ubfx	r1, r1, #8, #4
   355d0:	bf08      	it	eq
   355d2:	f04e 0e08 	orreq.w	lr, lr, #8
   355d6:	2908      	cmp	r1, #8
   355d8:	49a9      	ldr	r1, [pc, #676]	; (35880 <am_hal_adc_samples_read+0x318>)
   355da:	6a09      	ldr	r1, [r1, #32]
   355dc:	f3c1 2103 	ubfx	r1, r1, #8, #4
   355e0:	bf08      	it	eq
   355e2:	f04e 0e10 	orreq.w	lr, lr, #16
   355e6:	2908      	cmp	r1, #8
   355e8:	49a5      	ldr	r1, [pc, #660]	; (35880 <am_hal_adc_samples_read+0x318>)
   355ea:	6a49      	ldr	r1, [r1, #36]	; 0x24
   355ec:	f3c1 2103 	ubfx	r1, r1, #8, #4
   355f0:	bf08      	it	eq
   355f2:	f04e 0e20 	orreq.w	lr, lr, #32
   355f6:	2908      	cmp	r1, #8
   355f8:	49a1      	ldr	r1, [pc, #644]	; (35880 <am_hal_adc_samples_read+0x318>)
   355fa:	6a89      	ldr	r1, [r1, #40]	; 0x28
   355fc:	f3c1 2103 	ubfx	r1, r1, #8, #4
   35600:	bf08      	it	eq
   35602:	f04e 0e40 	orreq.w	lr, lr, #64	; 0x40
   35606:	2908      	cmp	r1, #8
   35608:	499e      	ldr	r1, [pc, #632]	; (35884 <am_hal_adc_samples_read+0x31c>)
   3560a:	7809      	ldrb	r1, [r1, #0]
   3560c:	bf08      	it	eq
   3560e:	f04e 0e80 	orreq.w	lr, lr, #128	; 0x80
   35612:	b9b9      	cbnz	r1, 35644 <am_hal_adc_samples_read+0xdc>
   35614:	f100 0108 	add.w	r1, r0, #8
   35618:	f1a2 0c04 	sub.w	ip, r2, #4
   3561c:	f85c 2f04 	ldr.w	r2, [ip, #4]!
   35620:	3108      	adds	r1, #8
   35622:	f3c2 108d 	ubfx	r0, r2, #6, #14
   35626:	f3c2 7202 	ubfx	r2, r2, #28, #3
   3562a:	e941 0204 	strd	r0, r2, [r1, #-16]
   3562e:	681a      	ldr	r2, [r3, #0]
   35630:	3201      	adds	r2, #1
   35632:	4294      	cmp	r4, r2
   35634:	601a      	str	r2, [r3, #0]
   35636:	d8f1      	bhi.n	3561c <am_hal_adc_samples_read+0xb4>
   35638:	2000      	movs	r0, #0
   3563a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3563e:	2002      	movs	r0, #2
   35640:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35644:	ed9f 4a90 	vldr	s8, [pc, #576]	; 35888 <am_hal_adc_samples_read+0x320>
   35648:	eddf 4a90 	vldr	s9, [pc, #576]	; 3588c <am_hal_adc_samples_read+0x324>
   3564c:	ed9f 5a90 	vldr	s10, [pc, #576]	; 35890 <am_hal_adc_samples_read+0x328>
   35650:	4e90      	ldr	r6, [pc, #576]	; (35894 <am_hal_adc_samples_read+0x32c>)
   35652:	f100 0108 	add.w	r1, r0, #8
   35656:	f1a2 0c04 	sub.w	ip, r2, #4
   3565a:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   3565e:	f240 45a6 	movw	r5, #1190	; 0x4a6
   35662:	f85c 2f04 	ldr.w	r2, [ip, #4]!
   35666:	f3c2 7702 	ubfx	r7, r2, #28, #3
   3566a:	f3c2 0213 	ubfx	r2, r2, #0, #20
   3566e:	0990      	lsrs	r0, r2, #6
   35670:	fa2e f807 	lsr.w	r8, lr, r7
   35674:	fb05 f000 	mul.w	r0, r5, r0
   35678:	f018 0f01 	tst.w	r8, #1
   3567c:	ea4f 3010 	mov.w	r0, r0, lsr #12
   35680:	ea4f 1292 	mov.w	r2, r2, lsr #6
   35684:	d124      	bne.n	356d0 <am_hal_adc_samples_read+0x168>
   35686:	ed96 6a01 	vldr	s12, [r6, #4]
   3568a:	ed96 7a00 	vldr	s14, [r6]
   3568e:	f841 7c04 	str.w	r7, [r1, #-4]
   35692:	ee07 0a90 	vmov	s15, r0
   35696:	ee35 6ac6 	vsub.f32	s12, s11, s12
   3569a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3569e:	ee67 6a04 	vmul.f32	s13, s14, s8
   356a2:	ee87 7a86 	vdiv.f32	s14, s15, s12
   356a6:	3108      	adds	r1, #8
   356a8:	ee37 7a66 	vsub.f32	s14, s14, s13
   356ac:	ee27 7a24 	vmul.f32	s14, s14, s9
   356b0:	eec7 7a05 	vdiv.f32	s15, s14, s10
   356b4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   356b8:	ee17 2a90 	vmov	r2, s15
   356bc:	f3c2 020b 	ubfx	r2, r2, #0, #12
   356c0:	f841 2c10 	str.w	r2, [r1, #-16]
   356c4:	681a      	ldr	r2, [r3, #0]
   356c6:	3201      	adds	r2, #1
   356c8:	4294      	cmp	r4, r2
   356ca:	601a      	str	r2, [r3, #0]
   356cc:	d8c9      	bhi.n	35662 <am_hal_adc_samples_read+0xfa>
   356ce:	e7b3      	b.n	35638 <am_hal_adc_samples_read+0xd0>
   356d0:	e941 2702 	strd	r2, r7, [r1, #-8]
   356d4:	681a      	ldr	r2, [r3, #0]
   356d6:	3201      	adds	r2, #1
   356d8:	42a2      	cmp	r2, r4
   356da:	f101 0108 	add.w	r1, r1, #8
   356de:	601a      	str	r2, [r3, #0]
   356e0:	d3bf      	bcc.n	35662 <am_hal_adc_samples_read+0xfa>
   356e2:	e7a9      	b.n	35638 <am_hal_adc_samples_read+0xd0>
   356e4:	4a67      	ldr	r2, [pc, #412]	; (35884 <am_hal_adc_samples_read+0x31c>)
   356e6:	7812      	ldrb	r2, [r2, #0]
   356e8:	b9f2      	cbnz	r2, 35728 <am_hal_adc_samples_read+0x1c0>
   356ea:	4f65      	ldr	r7, [pc, #404]	; (35880 <am_hal_adc_samples_read+0x318>)
   356ec:	4e6a      	ldr	r6, [pc, #424]	; (35898 <am_hal_adc_samples_read+0x330>)
   356ee:	2900      	cmp	r1, #0
   356f0:	f040 80c1 	bne.w	35876 <am_hal_adc_samples_read+0x30e>
   356f4:	f100 0108 	add.w	r1, r0, #8
   356f8:	e001      	b.n	356fe <am_hal_adc_samples_read+0x196>
   356fa:	4294      	cmp	r4, r2
   356fc:	d99c      	bls.n	35638 <am_hal_adc_samples_read+0xd0>
   356fe:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   35700:	f3c0 7502 	ubfx	r5, r0, #28, #3
   35704:	19aa      	adds	r2, r5, r6
   35706:	0092      	lsls	r2, r2, #2
   35708:	3108      	adds	r1, #8
   3570a:	6812      	ldr	r2, [r2, #0]
   3570c:	f841 5c0c 	str.w	r5, [r1, #-12]
   35710:	f3c0 128d 	ubfx	r2, r0, #6, #14
   35714:	f841 2c10 	str.w	r2, [r1, #-16]
   35718:	681a      	ldr	r2, [r3, #0]
   3571a:	f010 6f7f 	tst.w	r0, #267386880	; 0xff00000
   3571e:	f102 0201 	add.w	r2, r2, #1
   35722:	601a      	str	r2, [r3, #0]
   35724:	d1e9      	bne.n	356fa <am_hal_adc_samples_read+0x192>
   35726:	e787      	b.n	35638 <am_hal_adc_samples_read+0xd0>
   35728:	f8df c154 	ldr.w	ip, [pc, #340]	; 35880 <am_hal_adc_samples_read+0x318>
   3572c:	4f5a      	ldr	r7, [pc, #360]	; (35898 <am_hal_adc_samples_read+0x330>)
   3572e:	ed9f 4a56 	vldr	s8, [pc, #344]	; 35888 <am_hal_adc_samples_read+0x320>
   35732:	eddf 4a56 	vldr	s9, [pc, #344]	; 3588c <am_hal_adc_samples_read+0x324>
   35736:	ed9f 5a56 	vldr	s10, [pc, #344]	; 35890 <am_hal_adc_samples_read+0x328>
   3573a:	2900      	cmp	r1, #0
   3573c:	d14e      	bne.n	357dc <am_hal_adc_samples_read+0x274>
   3573e:	f8df e154 	ldr.w	lr, [pc, #340]	; 35894 <am_hal_adc_samples_read+0x32c>
   35742:	f100 0108 	add.w	r1, r0, #8
   35746:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   3574a:	f240 46a6 	movw	r6, #1190	; 0x4a6
   3574e:	e002      	b.n	35756 <am_hal_adc_samples_read+0x1ee>
   35750:	4294      	cmp	r4, r2
   35752:	f67f af71 	bls.w	35638 <am_hal_adc_samples_read+0xd0>
   35756:	f8dc 503c 	ldr.w	r5, [ip, #60]	; 0x3c
   3575a:	f3c5 7802 	ubfx	r8, r5, #28, #3
   3575e:	eb08 0007 	add.w	r0, r8, r7
   35762:	0080      	lsls	r0, r0, #2
   35764:	f3c5 128d 	ubfx	r2, r5, #6, #14
   35768:	6800      	ldr	r0, [r0, #0]
   3576a:	f3c0 2003 	ubfx	r0, r0, #8, #4
   3576e:	fb06 f202 	mul.w	r2, r6, r2
   35772:	2808      	cmp	r0, #8
   35774:	ea4f 3212 	mov.w	r2, r2, lsr #12
   35778:	d01e      	beq.n	357b8 <am_hal_adc_samples_read+0x250>
   3577a:	ee07 2a90 	vmov	s15, r2
   3577e:	ed9e 6a01 	vldr	s12, [lr, #4]
   35782:	ed9e 7a00 	vldr	s14, [lr]
   35786:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3578a:	ee35 6ac6 	vsub.f32	s12, s11, s12
   3578e:	ee67 6a04 	vmul.f32	s13, s14, s8
   35792:	ee87 7a86 	vdiv.f32	s14, s15, s12
   35796:	ee37 7a66 	vsub.f32	s14, s14, s13
   3579a:	ee27 7a24 	vmul.f32	s14, s14, s9
   3579e:	eec7 7a05 	vdiv.f32	s15, s14, s10
   357a2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   357a6:	ee17 2a90 	vmov	r2, s15
   357aa:	0192      	lsls	r2, r2, #6
   357ac:	f3c2 0211 	ubfx	r2, r2, #0, #18
   357b0:	f362 0513 	bfi	r5, r2, #0, #20
   357b4:	f3c5 7802 	ubfx	r8, r5, #28, #3
   357b8:	f3c5 128d 	ubfx	r2, r5, #6, #14
   357bc:	f841 8c04 	str.w	r8, [r1, #-4]
   357c0:	f841 2c08 	str.w	r2, [r1, #-8]
   357c4:	681a      	ldr	r2, [r3, #0]
   357c6:	f015 6f7f 	tst.w	r5, #267386880	; 0xff00000
   357ca:	f102 0201 	add.w	r2, r2, #1
   357ce:	f101 0108 	add.w	r1, r1, #8
   357d2:	601a      	str	r2, [r3, #0]
   357d4:	d1bc      	bne.n	35750 <am_hal_adc_samples_read+0x1e8>
   357d6:	e72f      	b.n	35638 <am_hal_adc_samples_read+0xd0>
   357d8:	2006      	movs	r0, #6
   357da:	e72e      	b.n	3563a <am_hal_adc_samples_read+0xd2>
   357dc:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 35894 <am_hal_adc_samples_read+0x32c>
   357e0:	f100 0108 	add.w	r1, r0, #8
   357e4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
   357e8:	f240 46a6 	movw	r6, #1190	; 0x4a6
   357ec:	e002      	b.n	357f4 <am_hal_adc_samples_read+0x28c>
   357ee:	42a2      	cmp	r2, r4
   357f0:	f4bf af22 	bcs.w	35638 <am_hal_adc_samples_read+0xd0>
   357f4:	f8dc 503c 	ldr.w	r5, [ip, #60]	; 0x3c
   357f8:	f3c5 7802 	ubfx	r8, r5, #28, #3
   357fc:	eb08 0007 	add.w	r0, r8, r7
   35800:	0080      	lsls	r0, r0, #2
   35802:	f3c5 128d 	ubfx	r2, r5, #6, #14
   35806:	6800      	ldr	r0, [r0, #0]
   35808:	f3c0 2003 	ubfx	r0, r0, #8, #4
   3580c:	fb06 f202 	mul.w	r2, r6, r2
   35810:	2808      	cmp	r0, #8
   35812:	ea4f 3212 	mov.w	r2, r2, lsr #12
   35816:	d01e      	beq.n	35856 <am_hal_adc_samples_read+0x2ee>
   35818:	ee07 2a90 	vmov	s15, r2
   3581c:	ed9e 6a01 	vldr	s12, [lr, #4]
   35820:	ed9e 7a00 	vldr	s14, [lr]
   35824:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   35828:	ee35 6ac6 	vsub.f32	s12, s11, s12
   3582c:	ee67 6a04 	vmul.f32	s13, s14, s8
   35830:	ee87 7a86 	vdiv.f32	s14, s15, s12
   35834:	ee37 7a66 	vsub.f32	s14, s14, s13
   35838:	ee27 7a24 	vmul.f32	s14, s14, s9
   3583c:	eec7 7a05 	vdiv.f32	s15, s14, s10
   35840:	eefc 7ae7 	vcvt.u32.f32	s15, s15
   35844:	ee17 2a90 	vmov	r2, s15
   35848:	0192      	lsls	r2, r2, #6
   3584a:	f3c2 0211 	ubfx	r2, r2, #0, #18
   3584e:	f362 0513 	bfi	r5, r2, #0, #20
   35852:	f3c5 7802 	ubfx	r8, r5, #28, #3
   35856:	f3c5 0213 	ubfx	r2, r5, #0, #20
   3585a:	f841 8c04 	str.w	r8, [r1, #-4]
   3585e:	f841 2c08 	str.w	r2, [r1, #-8]
   35862:	681a      	ldr	r2, [r3, #0]
   35864:	f015 6f7f 	tst.w	r5, #267386880	; 0xff00000
   35868:	f102 0201 	add.w	r2, r2, #1
   3586c:	f101 0108 	add.w	r1, r1, #8
   35870:	601a      	str	r2, [r3, #0]
   35872:	d1bc      	bne.n	357ee <am_hal_adc_samples_read+0x286>
   35874:	e6e0      	b.n	35638 <am_hal_adc_samples_read+0xd0>
   35876:	f100 0108 	add.w	r1, r0, #8
   3587a:	e012      	b.n	358a2 <am_hal_adc_samples_read+0x33a>
   3587c:	01afafaf 	.word	0x01afafaf
   35880:	40038000 	.word	0x40038000
   35884:	10010440 	.word	0x10010440
   35888:	447a0000 	.word	0x447a0000
   3588c:	45800000 	.word	0x45800000
   35890:	4494c000 	.word	0x4494c000
   35894:	10010444 	.word	0x10010444
   35898:	1000e003 	.word	0x1000e003
   3589c:	4294      	cmp	r4, r2
   3589e:	f67f aecb 	bls.w	35638 <am_hal_adc_samples_read+0xd0>
   358a2:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
   358a4:	f3c0 7502 	ubfx	r5, r0, #28, #3
   358a8:	19aa      	adds	r2, r5, r6
   358aa:	0092      	lsls	r2, r2, #2
   358ac:	3108      	adds	r1, #8
   358ae:	6812      	ldr	r2, [r2, #0]
   358b0:	f841 5c0c 	str.w	r5, [r1, #-12]
   358b4:	f3c0 0213 	ubfx	r2, r0, #0, #20
   358b8:	f841 2c10 	str.w	r2, [r1, #-16]
   358bc:	681a      	ldr	r2, [r3, #0]
   358be:	f010 6f7f 	tst.w	r0, #267386880	; 0xff00000
   358c2:	f102 0201 	add.w	r2, r2, #1
   358c6:	601a      	str	r2, [r3, #0]
   358c8:	d1e8      	bne.n	3589c <am_hal_adc_samples_read+0x334>
   358ca:	e6b5      	b.n	35638 <am_hal_adc_samples_read+0xd0>

000358cc <am_hal_adc_sw_trigger>:
   358cc:	6803      	ldr	r3, [r0, #0]
   358ce:	4a06      	ldr	r2, [pc, #24]	; (358e8 <am_hal_adc_sw_trigger+0x1c>)
   358d0:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   358d4:	4293      	cmp	r3, r2
   358d6:	d104      	bne.n	358e2 <am_hal_adc_sw_trigger+0x16>
   358d8:	4b04      	ldr	r3, [pc, #16]	; (358ec <am_hal_adc_sw_trigger+0x20>)
   358da:	2237      	movs	r2, #55	; 0x37
   358dc:	609a      	str	r2, [r3, #8]
   358de:	2000      	movs	r0, #0
   358e0:	4770      	bx	lr
   358e2:	2002      	movs	r0, #2
   358e4:	4770      	bx	lr
   358e6:	bf00      	nop
   358e8:	01afafaf 	.word	0x01afafaf
   358ec:	40038000 	.word	0x40038000

000358f0 <am_hal_adc_power_control>:
   358f0:	b5f0      	push	{r4, r5, r6, r7, lr}
   358f2:	4604      	mov	r4, r0
   358f4:	483e      	ldr	r0, [pc, #248]	; (359f0 <am_hal_adc_power_control+0x100>)
   358f6:	6823      	ldr	r3, [r4, #0]
   358f8:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   358fc:	4283      	cmp	r3, r0
   358fe:	b083      	sub	sp, #12
   35900:	d169      	bne.n	359d6 <am_hal_adc_power_control+0xe6>
   35902:	2900      	cmp	r1, #0
   35904:	d027      	beq.n	35956 <am_hal_adc_power_control+0x66>
   35906:	3901      	subs	r1, #1
   35908:	2901      	cmp	r1, #1
   3590a:	d861      	bhi.n	359d0 <am_hal_adc_power_control+0xe0>
   3590c:	b1ea      	cbz	r2, 3594a <am_hal_adc_power_control+0x5a>
   3590e:	4b39      	ldr	r3, [pc, #228]	; (359f4 <am_hal_adc_power_control+0x104>)
   35910:	68d9      	ldr	r1, [r3, #12]
   35912:	6161      	str	r1, [r4, #20]
   35914:	6919      	ldr	r1, [r3, #16]
   35916:	61a1      	str	r1, [r4, #24]
   35918:	6959      	ldr	r1, [r3, #20]
   3591a:	61e1      	str	r1, [r4, #28]
   3591c:	6999      	ldr	r1, [r3, #24]
   3591e:	6221      	str	r1, [r4, #32]
   35920:	69d9      	ldr	r1, [r3, #28]
   35922:	6261      	str	r1, [r4, #36]	; 0x24
   35924:	6a19      	ldr	r1, [r3, #32]
   35926:	62a1      	str	r1, [r4, #40]	; 0x28
   35928:	6a59      	ldr	r1, [r3, #36]	; 0x24
   3592a:	62e1      	str	r1, [r4, #44]	; 0x2c
   3592c:	6a99      	ldr	r1, [r3, #40]	; 0x28
   3592e:	6321      	str	r1, [r4, #48]	; 0x30
   35930:	6c19      	ldr	r1, [r3, #64]	; 0x40
   35932:	6361      	str	r1, [r4, #52]	; 0x34
   35934:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
   35936:	63a1      	str	r1, [r4, #56]	; 0x38
   35938:	6b19      	ldr	r1, [r3, #48]	; 0x30
   3593a:	63e1      	str	r1, [r4, #60]	; 0x3c
   3593c:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
   35940:	6421      	str	r1, [r4, #64]	; 0x40
   35942:	681b      	ldr	r3, [r3, #0]
   35944:	6123      	str	r3, [r4, #16]
   35946:	2201      	movs	r2, #1
   35948:	7322      	strb	r2, [r4, #12]
   3594a:	200d      	movs	r0, #13
   3594c:	f000 fd68 	bl	36420 <am_hal_pwrctrl_periph_disable>
   35950:	2000      	movs	r0, #0
   35952:	b003      	add	sp, #12
   35954:	bdf0      	pop	{r4, r5, r6, r7, pc}
   35956:	2a00      	cmp	r2, #0
   35958:	d040      	beq.n	359dc <am_hal_adc_power_control+0xec>
   3595a:	7b23      	ldrb	r3, [r4, #12]
   3595c:	2b00      	cmp	r3, #0
   3595e:	d044      	beq.n	359ea <am_hal_adc_power_control+0xfa>
   35960:	4d24      	ldr	r5, [pc, #144]	; (359f4 <am_hal_adc_power_control+0x104>)
   35962:	9101      	str	r1, [sp, #4]
   35964:	200d      	movs	r0, #13
   35966:	f000 fc8b 	bl	36280 <am_hal_pwrctrl_periph_enable>
   3596a:	6963      	ldr	r3, [r4, #20]
   3596c:	60eb      	str	r3, [r5, #12]
   3596e:	69a3      	ldr	r3, [r4, #24]
   35970:	612b      	str	r3, [r5, #16]
   35972:	69e3      	ldr	r3, [r4, #28]
   35974:	616b      	str	r3, [r5, #20]
   35976:	6a23      	ldr	r3, [r4, #32]
   35978:	61ab      	str	r3, [r5, #24]
   3597a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3597c:	61eb      	str	r3, [r5, #28]
   3597e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   35980:	622b      	str	r3, [r5, #32]
   35982:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   35984:	626b      	str	r3, [r5, #36]	; 0x24
   35986:	6b23      	ldr	r3, [r4, #48]	; 0x30
   35988:	62ab      	str	r3, [r5, #40]	; 0x28
   3598a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3598c:	642b      	str	r3, [r5, #64]	; 0x40
   3598e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   35990:	62eb      	str	r3, [r5, #44]	; 0x2c
   35992:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   35994:	9901      	ldr	r1, [sp, #4]
   35996:	632b      	str	r3, [r5, #48]	; 0x30
   35998:	f8c5 1200 	str.w	r1, [r5, #512]	; 0x200
   3599c:	f8d5 6200 	ldr.w	r6, [r5, #512]	; 0x200
   359a0:	f8c5 1200 	str.w	r1, [r5, #512]	; 0x200
   359a4:	f8d5 7204 	ldr.w	r7, [r5, #516]	; 0x204
   359a8:	6923      	ldr	r3, [r4, #16]
   359aa:	602b      	str	r3, [r5, #0]
   359ac:	4620      	mov	r0, r4
   359ae:	f7ff fd0d 	bl	353cc <ForceFIFOpop>
   359b2:	07bb      	lsls	r3, r7, #30
   359b4:	d102      	bne.n	359bc <am_hal_adc_power_control+0xcc>
   359b6:	2303      	movs	r3, #3
   359b8:	f8c5 3208 	str.w	r3, [r5, #520]	; 0x208
   359bc:	4a0d      	ldr	r2, [pc, #52]	; (359f4 <am_hal_adc_power_control+0x104>)
   359be:	f8c2 6200 	str.w	r6, [r2, #512]	; 0x200
   359c2:	2300      	movs	r3, #0
   359c4:	6c21      	ldr	r1, [r4, #64]	; 0x40
   359c6:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
   359ca:	4618      	mov	r0, r3
   359cc:	7323      	strb	r3, [r4, #12]
   359ce:	e000      	b.n	359d2 <am_hal_adc_power_control+0xe2>
   359d0:	2006      	movs	r0, #6
   359d2:	b003      	add	sp, #12
   359d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   359d6:	2002      	movs	r0, #2
   359d8:	b003      	add	sp, #12
   359da:	bdf0      	pop	{r4, r5, r6, r7, pc}
   359dc:	200d      	movs	r0, #13
   359de:	9201      	str	r2, [sp, #4]
   359e0:	f000 fc4e 	bl	36280 <am_hal_pwrctrl_periph_enable>
   359e4:	9a01      	ldr	r2, [sp, #4]
   359e6:	4610      	mov	r0, r2
   359e8:	e7f3      	b.n	359d2 <am_hal_adc_power_control+0xe2>
   359ea:	2007      	movs	r0, #7
   359ec:	e7f1      	b.n	359d2 <am_hal_adc_power_control+0xe2>
   359ee:	bf00      	nop
   359f0:	01afafaf 	.word	0x01afafaf
   359f4:	40038000 	.word	0x40038000

000359f8 <am_hal_dcu_get>:
   359f8:	4b1f      	ldr	r3, [pc, #124]	; (35a78 <am_hal_dcu_get+0x80>)
   359fa:	689b      	ldr	r3, [r3, #8]
   359fc:	02da      	lsls	r2, r3, #11
   359fe:	d538      	bpl.n	35a72 <am_hal_dcu_get+0x7a>
   35a00:	4b1e      	ldr	r3, [pc, #120]	; (35a7c <am_hal_dcu_get+0x84>)
   35a02:	f8d3 3a7c 	ldr.w	r3, [r3, #2684]	; 0xa7c
   35a06:	07db      	lsls	r3, r3, #31
   35a08:	d533      	bpl.n	35a72 <am_hal_dcu_get+0x7a>
   35a0a:	b510      	push	{r4, lr}
   35a0c:	4b1c      	ldr	r3, [pc, #112]	; (35a80 <am_hal_dcu_get+0x88>)
   35a0e:	4a1d      	ldr	r2, [pc, #116]	; (35a84 <am_hal_dcu_get+0x8c>)
   35a10:	681b      	ldr	r3, [r3, #0]
   35a12:	6814      	ldr	r4, [r2, #0]
   35a14:	685a      	ldr	r2, [r3, #4]
   35a16:	b082      	sub	sp, #8
   35a18:	f04f 0e01 	mov.w	lr, #1
   35a1c:	9201      	str	r2, [sp, #4]
   35a1e:	681b      	ldr	r3, [r3, #0]
   35a20:	9300      	str	r3, [sp, #0]
   35a22:	e9dd 3100 	ldrd	r3, r1, [sp]
   35a26:	f1c4 0220 	rsb	r2, r4, #32
   35a2a:	fa01 f202 	lsl.w	r2, r1, r2
   35a2e:	40e3      	lsrs	r3, r4
   35a30:	4313      	orrs	r3, r2
   35a32:	f1a4 0220 	sub.w	r2, r4, #32
   35a36:	fa21 f202 	lsr.w	r2, r1, r2
   35a3a:	4313      	orrs	r3, r2
   35a3c:	2200      	movs	r2, #0
   35a3e:	40e1      	lsrs	r1, r4
   35a40:	4614      	mov	r4, r2
   35a42:	f003 0c07 	and.w	ip, r3, #7
   35a46:	f1bc 0f05 	cmp.w	ip, #5
   35a4a:	bf08      	it	eq
   35a4c:	fa0e fc02 	lsleq.w	ip, lr, r2
   35a50:	f102 0201 	add.w	r2, r2, #1
   35a54:	ea4f 03d3 	mov.w	r3, r3, lsr #3
   35a58:	bf08      	it	eq
   35a5a:	ea44 040c 	orreq.w	r4, r4, ip
   35a5e:	2a14      	cmp	r2, #20
   35a60:	ea43 7341 	orr.w	r3, r3, r1, lsl #29
   35a64:	ea4f 01d1 	mov.w	r1, r1, lsr #3
   35a68:	d1eb      	bne.n	35a42 <am_hal_dcu_get+0x4a>
   35a6a:	6004      	str	r4, [r0, #0]
   35a6c:	2000      	movs	r0, #0
   35a6e:	b002      	add	sp, #8
   35a70:	bd10      	pop	{r4, pc}
   35a72:	2007      	movs	r0, #7
   35a74:	4770      	bx	lr
   35a76:	bf00      	nop
   35a78:	40021000 	.word	0x40021000
   35a7c:	400c0000 	.word	0x400c0000
   35a80:	10003838 	.word	0x10003838
   35a84:	10010450 	.word	0x10010450

00035a88 <am_hal_dcu_update>:
   35a88:	4b26      	ldr	r3, [pc, #152]	; (35b24 <am_hal_dcu_update+0x9c>)
   35a8a:	689b      	ldr	r3, [r3, #8]
   35a8c:	02d8      	lsls	r0, r3, #11
   35a8e:	d544      	bpl.n	35b1a <am_hal_dcu_update+0x92>
   35a90:	4b25      	ldr	r3, [pc, #148]	; (35b28 <am_hal_dcu_update+0xa0>)
   35a92:	f8d3 3a7c 	ldr.w	r3, [r3, #2684]	; 0xa7c
   35a96:	07da      	lsls	r2, r3, #31
   35a98:	d53f      	bpl.n	35b1a <am_hal_dcu_update+0x92>
   35a9a:	b570      	push	{r4, r5, r6, lr}
   35a9c:	4b23      	ldr	r3, [pc, #140]	; (35b2c <am_hal_dcu_update+0xa4>)
   35a9e:	681b      	ldr	r3, [r3, #0]
   35aa0:	2400      	movs	r4, #0
   35aa2:	b084      	sub	sp, #16
   35aa4:	0849      	lsrs	r1, r1, #1
   35aa6:	f103 063c 	add.w	r6, r3, #60	; 0x3c
   35aaa:	4625      	mov	r5, r4
   35aac:	f04f 0e07 	mov.w	lr, #7
   35ab0:	f011 0f01 	tst.w	r1, #1
   35ab4:	f1a3 0220 	sub.w	r2, r3, #32
   35ab8:	ea4f 0151 	mov.w	r1, r1, lsr #1
   35abc:	f1c3 0020 	rsb	r0, r3, #32
   35ac0:	d009      	beq.n	35ad6 <am_hal_dcu_update+0x4e>
   35ac2:	fa2e f000 	lsr.w	r0, lr, r0
   35ac6:	fa0e f202 	lsl.w	r2, lr, r2
   35aca:	fa0e fc03 	lsl.w	ip, lr, r3
   35ace:	4302      	orrs	r2, r0
   35ad0:	4660      	mov	r0, ip
   35ad2:	4304      	orrs	r4, r0
   35ad4:	4315      	orrs	r5, r2
   35ad6:	3303      	adds	r3, #3
   35ad8:	429e      	cmp	r6, r3
   35ada:	d1e9      	bne.n	35ab0 <am_hal_dcu_update+0x28>
   35adc:	4b14      	ldr	r3, [pc, #80]	; (35b30 <am_hal_dcu_update+0xa8>)
   35ade:	681b      	ldr	r3, [r3, #0]
   35ae0:	685a      	ldr	r2, [r3, #4]
   35ae2:	9203      	str	r2, [sp, #12]
   35ae4:	681b      	ldr	r3, [r3, #0]
   35ae6:	9302      	str	r3, [sp, #8]
   35ae8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
   35aec:	4014      	ands	r4, r2
   35aee:	401d      	ands	r5, r3
   35af0:	ea54 0305 	orrs.w	r3, r4, r5
   35af4:	d113      	bne.n	35b1e <am_hal_dcu_update+0x96>
   35af6:	4b0f      	ldr	r3, [pc, #60]	; (35b34 <am_hal_dcu_update+0xac>)
   35af8:	4a0b      	ldr	r2, [pc, #44]	; (35b28 <am_hal_dcu_update+0xa0>)
   35afa:	681b      	ldr	r3, [r3, #0]
   35afc:	6859      	ldr	r1, [r3, #4]
   35afe:	9101      	str	r1, [sp, #4]
   35b00:	6819      	ldr	r1, [r3, #0]
   35b02:	9100      	str	r1, [sp, #0]
   35b04:	9901      	ldr	r1, [sp, #4]
   35b06:	6059      	str	r1, [r3, #4]
   35b08:	9900      	ldr	r1, [sp, #0]
   35b0a:	6019      	str	r1, [r3, #0]
   35b0c:	f8d2 3a7c 	ldr.w	r3, [r2, #2684]	; 0xa7c
   35b10:	07db      	lsls	r3, r3, #31
   35b12:	d5fb      	bpl.n	35b0c <am_hal_dcu_update+0x84>
   35b14:	2000      	movs	r0, #0
   35b16:	b004      	add	sp, #16
   35b18:	bd70      	pop	{r4, r5, r6, pc}
   35b1a:	2007      	movs	r0, #7
   35b1c:	4770      	bx	lr
   35b1e:	2007      	movs	r0, #7
   35b20:	b004      	add	sp, #16
   35b22:	bd70      	pop	{r4, r5, r6, pc}
   35b24:	40021000 	.word	0x40021000
   35b28:	400c0000 	.word	0x400c0000
   35b2c:	10010450 	.word	0x10010450
   35b30:	1000383c 	.word	0x1000383c
   35b34:	10003838 	.word	0x10003838

00035b38 <am_hal_gpio_pinconfig>:
   35b38:	287f      	cmp	r0, #127	; 0x7f
   35b3a:	d81f      	bhi.n	35b7c <am_hal_gpio_pinconfig+0x44>
   35b3c:	f3c1 2381 	ubfx	r3, r1, #10, #2
   35b40:	2b01      	cmp	r3, #1
   35b42:	b410      	push	{r4}
   35b44:	d909      	bls.n	35b5a <am_hal_gpio_pinconfig+0x22>
   35b46:	4b10      	ldr	r3, [pc, #64]	; (35b88 <am_hal_gpio_pinconfig+0x50>)
   35b48:	0942      	lsrs	r2, r0, #5
   35b4a:	f000 041f 	and.w	r4, r0, #31
   35b4e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   35b52:	2301      	movs	r3, #1
   35b54:	40a3      	lsls	r3, r4
   35b56:	4213      	tst	r3, r2
   35b58:	d012      	beq.n	35b80 <am_hal_gpio_pinconfig+0x48>
   35b5a:	0080      	lsls	r0, r0, #2
   35b5c:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
   35b60:	4b0a      	ldr	r3, [pc, #40]	; (35b8c <am_hal_gpio_pinconfig+0x54>)
   35b62:	f500 3080 	add.w	r0, r0, #65536	; 0x10000
   35b66:	2200      	movs	r2, #0
   35b68:	2473      	movs	r4, #115	; 0x73
   35b6a:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
   35b6e:	6001      	str	r1, [r0, #0]
   35b70:	f85d 4b04 	ldr.w	r4, [sp], #4
   35b74:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   35b78:	4610      	mov	r0, r2
   35b7a:	4770      	bx	lr
   35b7c:	2005      	movs	r0, #5
   35b7e:	4770      	bx	lr
   35b80:	2007      	movs	r0, #7
   35b82:	f85d 4b04 	ldr.w	r4, [sp], #4
   35b86:	4770      	bx	lr
   35b88:	0004680c 	.word	0x0004680c
   35b8c:	40010000 	.word	0x40010000

00035b90 <am_hal_gpio_interrupt_control>:
   35b90:	2a00      	cmp	r2, #0
   35b92:	f000 80c1 	beq.w	35d18 <am_hal_gpio_interrupt_control+0x188>
   35b96:	b5f0      	push	{r4, r5, r6, r7, lr}
   35b98:	2903      	cmp	r1, #3
   35b9a:	b083      	sub	sp, #12
   35b9c:	460d      	mov	r5, r1
   35b9e:	d86f      	bhi.n	35c80 <am_hal_gpio_interrupt_control+0xf0>
   35ba0:	2901      	cmp	r1, #1
   35ba2:	4606      	mov	r6, r0
   35ba4:	4614      	mov	r4, r2
   35ba6:	d825      	bhi.n	35bf4 <am_hal_gpio_interrupt_control+0x64>
   35ba8:	6813      	ldr	r3, [r2, #0]
   35baa:	2b7f      	cmp	r3, #127	; 0x7f
   35bac:	f200 80b6 	bhi.w	35d1c <am_hal_gpio_interrupt_control+0x18c>
   35bb0:	4c5b      	ldr	r4, [pc, #364]	; (35d20 <am_hal_gpio_interrupt_control+0x190>)
   35bb2:	f003 021f 	and.w	r2, r3, #31
   35bb6:	2701      	movs	r7, #1
   35bb8:	eb04 1453 	add.w	r4, r4, r3, lsr #5
   35bbc:	2801      	cmp	r0, #1
   35bbe:	fa07 f702 	lsl.w	r7, r7, r2
   35bc2:	ea4f 1404 	mov.w	r4, r4, lsl #4
   35bc6:	f000 809d 	beq.w	35d04 <am_hal_gpio_interrupt_control+0x174>
   35bca:	f7fe f917 	bl	33dfc <am_hal_interrupt_master_disable>
   35bce:	2d01      	cmp	r5, #1
   35bd0:	9001      	str	r0, [sp, #4]
   35bd2:	d04b      	beq.n	35c6c <am_hal_gpio_interrupt_control+0xdc>
   35bd4:	6823      	ldr	r3, [r4, #0]
   35bd6:	43fa      	mvns	r2, r7
   35bd8:	2e02      	cmp	r6, #2
   35bda:	ea23 0707 	bic.w	r7, r3, r7
   35bde:	6027      	str	r7, [r4, #0]
   35be0:	d102      	bne.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35be2:	6c23      	ldr	r3, [r4, #64]	; 0x40
   35be4:	401a      	ands	r2, r3
   35be6:	6422      	str	r2, [r4, #64]	; 0x40
   35be8:	9801      	ldr	r0, [sp, #4]
   35bea:	f7fe f90b 	bl	33e04 <am_hal_interrupt_master_set>
   35bee:	2000      	movs	r0, #0
   35bf0:	b003      	add	sp, #12
   35bf2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   35bf4:	f7fe f902 	bl	33dfc <am_hal_interrupt_master_disable>
   35bf8:	2d02      	cmp	r5, #2
   35bfa:	9001      	str	r0, [sp, #4]
   35bfc:	d043      	beq.n	35c86 <am_hal_gpio_interrupt_control+0xf6>
   35bfe:	2e01      	cmp	r6, #1
   35c00:	d01a      	beq.n	35c38 <am_hal_gpio_interrupt_control+0xa8>
   35c02:	4b48      	ldr	r3, [pc, #288]	; (35d24 <am_hal_gpio_interrupt_control+0x194>)
   35c04:	6821      	ldr	r1, [r4, #0]
   35c06:	f8d3 22c0 	ldr.w	r2, [r3, #704]	; 0x2c0
   35c0a:	430a      	orrs	r2, r1
   35c0c:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
   35c10:	6861      	ldr	r1, [r4, #4]
   35c12:	f8d3 22d0 	ldr.w	r2, [r3, #720]	; 0x2d0
   35c16:	430a      	orrs	r2, r1
   35c18:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
   35c1c:	68a1      	ldr	r1, [r4, #8]
   35c1e:	f8d3 22e0 	ldr.w	r2, [r3, #736]	; 0x2e0
   35c22:	430a      	orrs	r2, r1
   35c24:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
   35c28:	68e1      	ldr	r1, [r4, #12]
   35c2a:	f8d3 22f0 	ldr.w	r2, [r3, #752]	; 0x2f0
   35c2e:	430a      	orrs	r2, r1
   35c30:	f8c3 22f0 	str.w	r2, [r3, #752]	; 0x2f0
   35c34:	2e00      	cmp	r6, #0
   35c36:	d0d7      	beq.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35c38:	4b3a      	ldr	r3, [pc, #232]	; (35d24 <am_hal_gpio_interrupt_control+0x194>)
   35c3a:	6821      	ldr	r1, [r4, #0]
   35c3c:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
   35c40:	430a      	orrs	r2, r1
   35c42:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
   35c46:	6861      	ldr	r1, [r4, #4]
   35c48:	f8d3 2310 	ldr.w	r2, [r3, #784]	; 0x310
   35c4c:	430a      	orrs	r2, r1
   35c4e:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
   35c52:	68a1      	ldr	r1, [r4, #8]
   35c54:	f8d3 2320 	ldr.w	r2, [r3, #800]	; 0x320
   35c58:	430a      	orrs	r2, r1
   35c5a:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
   35c5e:	68e1      	ldr	r1, [r4, #12]
   35c60:	f8d3 2330 	ldr.w	r2, [r3, #816]	; 0x330
   35c64:	430a      	orrs	r2, r1
   35c66:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
   35c6a:	e7bd      	b.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35c6c:	6823      	ldr	r3, [r4, #0]
   35c6e:	2e02      	cmp	r6, #2
   35c70:	ea43 0307 	orr.w	r3, r3, r7
   35c74:	6023      	str	r3, [r4, #0]
   35c76:	d1b7      	bne.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35c78:	6c23      	ldr	r3, [r4, #64]	; 0x40
   35c7a:	431f      	orrs	r7, r3
   35c7c:	6427      	str	r7, [r4, #64]	; 0x40
   35c7e:	e7b3      	b.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35c80:	2006      	movs	r0, #6
   35c82:	b003      	add	sp, #12
   35c84:	bdf0      	pop	{r4, r5, r6, r7, pc}
   35c86:	2e01      	cmp	r6, #1
   35c88:	d01e      	beq.n	35cc8 <am_hal_gpio_interrupt_control+0x138>
   35c8a:	4b26      	ldr	r3, [pc, #152]	; (35d24 <am_hal_gpio_interrupt_control+0x194>)
   35c8c:	6821      	ldr	r1, [r4, #0]
   35c8e:	f8d3 22c0 	ldr.w	r2, [r3, #704]	; 0x2c0
   35c92:	ea22 0201 	bic.w	r2, r2, r1
   35c96:	f8c3 22c0 	str.w	r2, [r3, #704]	; 0x2c0
   35c9a:	6861      	ldr	r1, [r4, #4]
   35c9c:	f8d3 22d0 	ldr.w	r2, [r3, #720]	; 0x2d0
   35ca0:	ea22 0201 	bic.w	r2, r2, r1
   35ca4:	f8c3 22d0 	str.w	r2, [r3, #720]	; 0x2d0
   35ca8:	68a1      	ldr	r1, [r4, #8]
   35caa:	f8d3 22e0 	ldr.w	r2, [r3, #736]	; 0x2e0
   35cae:	ea22 0201 	bic.w	r2, r2, r1
   35cb2:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
   35cb6:	68e1      	ldr	r1, [r4, #12]
   35cb8:	f8d3 22f0 	ldr.w	r2, [r3, #752]	; 0x2f0
   35cbc:	ea22 0201 	bic.w	r2, r2, r1
   35cc0:	f8c3 22f0 	str.w	r2, [r3, #752]	; 0x2f0
   35cc4:	2e00      	cmp	r6, #0
   35cc6:	d08f      	beq.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35cc8:	4b16      	ldr	r3, [pc, #88]	; (35d24 <am_hal_gpio_interrupt_control+0x194>)
   35cca:	6821      	ldr	r1, [r4, #0]
   35ccc:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
   35cd0:	ea22 0201 	bic.w	r2, r2, r1
   35cd4:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300
   35cd8:	6861      	ldr	r1, [r4, #4]
   35cda:	f8d3 2310 	ldr.w	r2, [r3, #784]	; 0x310
   35cde:	ea22 0201 	bic.w	r2, r2, r1
   35ce2:	f8c3 2310 	str.w	r2, [r3, #784]	; 0x310
   35ce6:	68a1      	ldr	r1, [r4, #8]
   35ce8:	f8d3 2320 	ldr.w	r2, [r3, #800]	; 0x320
   35cec:	ea22 0201 	bic.w	r2, r2, r1
   35cf0:	f8c3 2320 	str.w	r2, [r3, #800]	; 0x320
   35cf4:	68e1      	ldr	r1, [r4, #12]
   35cf6:	f8d3 2330 	ldr.w	r2, [r3, #816]	; 0x330
   35cfa:	ea22 0201 	bic.w	r2, r2, r1
   35cfe:	f8c3 2330 	str.w	r2, [r3, #816]	; 0x330
   35d02:	e771      	b.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35d04:	f7fe f87a 	bl	33dfc <am_hal_interrupt_master_disable>
   35d08:	2d01      	cmp	r5, #1
   35d0a:	9001      	str	r0, [sp, #4]
   35d0c:	d0b4      	beq.n	35c78 <am_hal_gpio_interrupt_control+0xe8>
   35d0e:	6c23      	ldr	r3, [r4, #64]	; 0x40
   35d10:	ea23 0707 	bic.w	r7, r3, r7
   35d14:	6427      	str	r7, [r4, #64]	; 0x40
   35d16:	e767      	b.n	35be8 <am_hal_gpio_interrupt_control+0x58>
   35d18:	2006      	movs	r0, #6
   35d1a:	4770      	bx	lr
   35d1c:	2005      	movs	r0, #5
   35d1e:	e767      	b.n	35bf0 <am_hal_gpio_interrupt_control+0x60>
   35d20:	0400102c 	.word	0x0400102c
   35d24:	40010000 	.word	0x40010000

00035d28 <am_hal_gpio_interrupt_irq_status_get>:
   35d28:	2a00      	cmp	r2, #0
   35d2a:	d033      	beq.n	35d94 <am_hal_gpio_interrupt_irq_status_get+0x6c>
   35d2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   35d30:	f1a0 0638 	sub.w	r6, r0, #56	; 0x38
   35d34:	2e07      	cmp	r6, #7
   35d36:	b082      	sub	sp, #8
   35d38:	4605      	mov	r5, r0
   35d3a:	d827      	bhi.n	35d8c <am_hal_gpio_interrupt_irq_status_get+0x64>
   35d3c:	4614      	mov	r4, r2
   35d3e:	460f      	mov	r7, r1
   35d40:	f7fe f85c 	bl	33dfc <am_hal_interrupt_master_disable>
   35d44:	ea4f 1806 	mov.w	r8, r6, lsl #4
   35d48:	4a13      	ldr	r2, [pc, #76]	; (35d98 <am_hal_gpio_interrupt_irq_status_get+0x70>)
   35d4a:	9001      	str	r0, [sp, #4]
   35d4c:	b96f      	cbnz	r7, 35d6a <am_hal_gpio_interrupt_irq_status_get+0x42>
   35d4e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   35d52:	6023      	str	r3, [r4, #0]
   35d54:	f858 2002 	ldr.w	r2, [r8, r2]
   35d58:	9801      	ldr	r0, [sp, #4]
   35d5a:	4013      	ands	r3, r2
   35d5c:	6023      	str	r3, [r4, #0]
   35d5e:	f7fe f851 	bl	33e04 <am_hal_interrupt_master_set>
   35d62:	2000      	movs	r0, #0
   35d64:	b002      	add	sp, #8
   35d66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35d6a:	2d3b      	cmp	r5, #59	; 0x3b
   35d6c:	bf8c      	ite	hi
   35d6e:	2301      	movhi	r3, #1
   35d70:	2300      	movls	r3, #0
   35d72:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
   35d76:	bf8c      	ite	hi
   35d78:	2104      	movhi	r1, #4
   35d7a:	2100      	movls	r1, #0
   35d7c:	f203 430b 	addw	r3, r3, #1035	; 0x40b
   35d80:	1a76      	subs	r6, r6, r1
   35d82:	eb06 0683 	add.w	r6, r6, r3, lsl #2
   35d86:	0136      	lsls	r6, r6, #4
   35d88:	6833      	ldr	r3, [r6, #0]
   35d8a:	e7e2      	b.n	35d52 <am_hal_gpio_interrupt_irq_status_get+0x2a>
   35d8c:	2006      	movs	r0, #6
   35d8e:	b002      	add	sp, #8
   35d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   35d94:	2006      	movs	r0, #6
   35d96:	4770      	bx	lr
   35d98:	400102c4 	.word	0x400102c4

00035d9c <am_hal_gpio_interrupt_irq_clear>:
   35d9c:	3838      	subs	r0, #56	; 0x38
   35d9e:	2807      	cmp	r0, #7
   35da0:	d804      	bhi.n	35dac <am_hal_gpio_interrupt_irq_clear+0x10>
   35da2:	0103      	lsls	r3, r0, #4
   35da4:	4a02      	ldr	r2, [pc, #8]	; (35db0 <am_hal_gpio_interrupt_irq_clear+0x14>)
   35da6:	2000      	movs	r0, #0
   35da8:	5099      	str	r1, [r3, r2]
   35daa:	4770      	bx	lr
   35dac:	2006      	movs	r0, #6
   35dae:	4770      	bx	lr
   35db0:	400102c8 	.word	0x400102c8

00035db4 <am_hal_gpio_interrupt_register>:
   35db4:	b410      	push	{r4}
   35db6:	ea4f 1c51 	mov.w	ip, r1, lsr #5
   35dba:	b960      	cbnz	r0, 35dd6 <am_hal_gpio_interrupt_register+0x22>
   35dbc:	f001 011f 	and.w	r1, r1, #31
   35dc0:	4c1b      	ldr	r4, [pc, #108]	; (35e30 <am_hal_gpio_interrupt_register+0x7c>)
   35dc2:	eb01 114c 	add.w	r1, r1, ip, lsl #5
   35dc6:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
   35dca:	4b1a      	ldr	r3, [pc, #104]	; (35e34 <am_hal_gpio_interrupt_register+0x80>)
   35dcc:	f85d 4b04 	ldr.w	r4, [sp], #4
   35dd0:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
   35dd4:	4770      	bx	lr
   35dd6:	2801      	cmp	r0, #1
   35dd8:	f10c 0404 	add.w	r4, ip, #4
   35ddc:	d015      	beq.n	35e0a <am_hal_gpio_interrupt_register+0x56>
   35dde:	2802      	cmp	r0, #2
   35de0:	d121      	bne.n	35e26 <am_hal_gpio_interrupt_register+0x72>
   35de2:	f001 011f 	and.w	r1, r1, #31
   35de6:	eb01 1c4c 	add.w	ip, r1, ip, lsl #5
   35dea:	eb01 1144 	add.w	r1, r1, r4, lsl #5
   35dee:	4c11      	ldr	r4, [pc, #68]	; (35e34 <am_hal_gpio_interrupt_register+0x80>)
   35df0:	f844 202c 	str.w	r2, [r4, ip, lsl #2]
   35df4:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
   35df8:	4a0d      	ldr	r2, [pc, #52]	; (35e30 <am_hal_gpio_interrupt_register+0x7c>)
   35dfa:	f85d 4b04 	ldr.w	r4, [sp], #4
   35dfe:	f842 302c 	str.w	r3, [r2, ip, lsl #2]
   35e02:	2000      	movs	r0, #0
   35e04:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
   35e08:	4770      	bx	lr
   35e0a:	f001 011f 	and.w	r1, r1, #31
   35e0e:	eb01 1144 	add.w	r1, r1, r4, lsl #5
   35e12:	4807      	ldr	r0, [pc, #28]	; (35e30 <am_hal_gpio_interrupt_register+0x7c>)
   35e14:	4c07      	ldr	r4, [pc, #28]	; (35e34 <am_hal_gpio_interrupt_register+0x80>)
   35e16:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
   35e1a:	f844 2021 	str.w	r2, [r4, r1, lsl #2]
   35e1e:	2000      	movs	r0, #0
   35e20:	f85d 4b04 	ldr.w	r4, [sp], #4
   35e24:	4770      	bx	lr
   35e26:	2006      	movs	r0, #6
   35e28:	f85d 4b04 	ldr.w	r4, [sp], #4
   35e2c:	4770      	bx	lr
   35e2e:	bf00      	nop
   35e30:	10010854 	.word	0x10010854
   35e34:	10010454 	.word	0x10010454

00035e38 <am_hal_gpio_interrupt_service>:
   35e38:	3838      	subs	r0, #56	; 0x38
   35e3a:	2807      	cmp	r0, #7
   35e3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   35e40:	d826      	bhi.n	35e90 <am_hal_gpio_interrupt_service+0x58>
   35e42:	4689      	mov	r9, r1
   35e44:	b349      	cbz	r1, 35e9a <am_hal_gpio_interrupt_service+0x62>
   35e46:	4e16      	ldr	r6, [pc, #88]	; (35ea0 <am_hal_gpio_interrupt_service+0x68>)
   35e48:	4f16      	ldr	r7, [pc, #88]	; (35ea4 <am_hal_gpio_interrupt_service+0x6c>)
   35e4a:	f04f 0800 	mov.w	r8, #0
   35e4e:	0144      	lsls	r4, r0, #5
   35e50:	2501      	movs	r5, #1
   35e52:	f1c9 0300 	rsb	r3, r9, #0
   35e56:	ea03 0309 	and.w	r3, r3, r9
   35e5a:	fab3 f383 	clz	r3, r3
   35e5e:	f1c3 031f 	rsb	r3, r3, #31
   35e62:	18e1      	adds	r1, r4, r3
   35e64:	fa05 f303 	lsl.w	r3, r5, r3
   35e68:	f856 2021 	ldr.w	r2, [r6, r1, lsl #2]
   35e6c:	ea29 0903 	bic.w	r9, r9, r3
   35e70:	b142      	cbz	r2, 35e84 <am_hal_gpio_interrupt_service+0x4c>
   35e72:	f857 0021 	ldr.w	r0, [r7, r1, lsl #2]
   35e76:	4790      	blx	r2
   35e78:	f1b9 0f00 	cmp.w	r9, #0
   35e7c:	d1e9      	bne.n	35e52 <am_hal_gpio_interrupt_service+0x1a>
   35e7e:	4640      	mov	r0, r8
   35e80:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   35e84:	f04f 0807 	mov.w	r8, #7
   35e88:	f1b9 0f00 	cmp.w	r9, #0
   35e8c:	d1e1      	bne.n	35e52 <am_hal_gpio_interrupt_service+0x1a>
   35e8e:	e7f6      	b.n	35e7e <am_hal_gpio_interrupt_service+0x46>
   35e90:	f04f 0805 	mov.w	r8, #5
   35e94:	4640      	mov	r0, r8
   35e96:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   35e9a:	4688      	mov	r8, r1
   35e9c:	e7ef      	b.n	35e7e <am_hal_gpio_interrupt_service+0x46>
   35e9e:	bf00      	nop
   35ea0:	10010454 	.word	0x10010454
   35ea4:	10010854 	.word	0x10010854

00035ea8 <am_hal_pwrctrl_mcu_memory_config>:
   35ea8:	b570      	push	{r4, r5, r6, lr}
   35eaa:	7803      	ldrb	r3, [r0, #0]
   35eac:	2b01      	cmp	r3, #1
   35eae:	b082      	sub	sp, #8
   35eb0:	4605      	mov	r5, r0
   35eb2:	d073      	beq.n	35f9c <am_hal_pwrctrl_mcu_memory_config+0xf4>
   35eb4:	2b02      	cmp	r3, #2
   35eb6:	d067      	beq.n	35f88 <am_hal_pwrctrl_mcu_memory_config+0xe0>
   35eb8:	2b00      	cmp	r3, #0
   35eba:	d05b      	beq.n	35f74 <am_hal_pwrctrl_mcu_memory_config+0xcc>
   35ebc:	4c4f      	ldr	r4, [pc, #316]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35ebe:	78aa      	ldrb	r2, [r5, #2]
   35ec0:	6963      	ldr	r3, [r4, #20]
   35ec2:	494f      	ldr	r1, [pc, #316]	; (36000 <am_hal_pwrctrl_mcu_memory_config+0x158>)
   35ec4:	f362 0302 	bfi	r3, r2, #0, #3
   35ec8:	6163      	str	r3, [r4, #20]
   35eca:	6963      	ldr	r3, [r4, #20]
   35ecc:	792a      	ldrb	r2, [r5, #4]
   35ece:	f362 03c3 	bfi	r3, r2, #3, #1
   35ed2:	6163      	str	r3, [r4, #20]
   35ed4:	2601      	movs	r6, #1
   35ed6:	6963      	ldr	r3, [r4, #20]
   35ed8:	9600      	str	r6, [sp, #0]
   35eda:	223f      	movs	r2, #63	; 0x3f
   35edc:	2005      	movs	r0, #5
   35ede:	f7ff fa37 	bl	35350 <am_hal_delay_us_status_check>
   35ee2:	b940      	cbnz	r0, 35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35ee4:	69a2      	ldr	r2, [r4, #24]
   35ee6:	6963      	ldr	r3, [r4, #20]
   35ee8:	f3c2 1200 	ubfx	r2, r2, #4, #1
   35eec:	f3c3 1300 	ubfx	r3, r3, #4, #1
   35ef0:	429a      	cmp	r2, r3
   35ef2:	d002      	beq.n	35efa <am_hal_pwrctrl_mcu_memory_config+0x52>
   35ef4:	4630      	mov	r0, r6
   35ef6:	b002      	add	sp, #8
   35ef8:	bd70      	pop	{r4, r5, r6, pc}
   35efa:	69a2      	ldr	r2, [r4, #24]
   35efc:	6963      	ldr	r3, [r4, #20]
   35efe:	f3c2 1240 	ubfx	r2, r2, #5, #1
   35f02:	f3c3 1340 	ubfx	r3, r3, #5, #1
   35f06:	429a      	cmp	r2, r3
   35f08:	d1f4      	bne.n	35ef4 <am_hal_pwrctrl_mcu_memory_config+0x4c>
   35f0a:	69a2      	ldr	r2, [r4, #24]
   35f0c:	6963      	ldr	r3, [r4, #20]
   35f0e:	f002 0207 	and.w	r2, r2, #7
   35f12:	f003 0307 	and.w	r3, r3, #7
   35f16:	429a      	cmp	r2, r3
   35f18:	d1ec      	bne.n	35ef4 <am_hal_pwrctrl_mcu_memory_config+0x4c>
   35f1a:	69a2      	ldr	r2, [r4, #24]
   35f1c:	6963      	ldr	r3, [r4, #20]
   35f1e:	f3c2 02c0 	ubfx	r2, r2, #3, #1
   35f22:	f3c3 03c0 	ubfx	r3, r3, #3, #1
   35f26:	429a      	cmp	r2, r3
   35f28:	d1e4      	bne.n	35ef4 <am_hal_pwrctrl_mcu_memory_config+0x4c>
   35f2a:	786b      	ldrb	r3, [r5, #1]
   35f2c:	2b00      	cmp	r3, #0
   35f2e:	d05f      	beq.n	35ff0 <am_hal_pwrctrl_mcu_memory_config+0x148>
   35f30:	69e3      	ldr	r3, [r4, #28]
   35f32:	f360 1304 	bfi	r3, r0, #4, #1
   35f36:	61e3      	str	r3, [r4, #28]
   35f38:	796b      	ldrb	r3, [r5, #5]
   35f3a:	2b00      	cmp	r3, #0
   35f3c:	d052      	beq.n	35fe4 <am_hal_pwrctrl_mcu_memory_config+0x13c>
   35f3e:	4b2f      	ldr	r3, [pc, #188]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35f40:	69da      	ldr	r2, [r3, #28]
   35f42:	f36f 02c3 	bfc	r2, #3, #1
   35f46:	61da      	str	r2, [r3, #28]
   35f48:	78eb      	ldrb	r3, [r5, #3]
   35f4a:	2b07      	cmp	r3, #7
   35f4c:	d8d3      	bhi.n	35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35f4e:	a201      	add	r2, pc, #4	; (adr r2, 35f54 <am_hal_pwrctrl_mcu_memory_config+0xac>)
   35f50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   35f54:	00035fd9 	.word	0x00035fd9
   35f58:	00035fcb 	.word	0x00035fcb
   35f5c:	00035ef7 	.word	0x00035ef7
   35f60:	00035fbd 	.word	0x00035fbd
   35f64:	00035ef7 	.word	0x00035ef7
   35f68:	00035ef7 	.word	0x00035ef7
   35f6c:	00035ef7 	.word	0x00035ef7
   35f70:	00035fb1 	.word	0x00035fb1
   35f74:	4a21      	ldr	r2, [pc, #132]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35f76:	6951      	ldr	r1, [r2, #20]
   35f78:	f363 1104 	bfi	r1, r3, #4, #1
   35f7c:	6151      	str	r1, [r2, #20]
   35f7e:	6951      	ldr	r1, [r2, #20]
   35f80:	f363 1145 	bfi	r1, r3, #5, #1
   35f84:	6151      	str	r1, [r2, #20]
   35f86:	e799      	b.n	35ebc <am_hal_pwrctrl_mcu_memory_config+0x14>
   35f88:	4b1c      	ldr	r3, [pc, #112]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35f8a:	695a      	ldr	r2, [r3, #20]
   35f8c:	f042 0210 	orr.w	r2, r2, #16
   35f90:	615a      	str	r2, [r3, #20]
   35f92:	695a      	ldr	r2, [r3, #20]
   35f94:	f042 0220 	orr.w	r2, r2, #32
   35f98:	615a      	str	r2, [r3, #20]
   35f9a:	e78f      	b.n	35ebc <am_hal_pwrctrl_mcu_memory_config+0x14>
   35f9c:	4b17      	ldr	r3, [pc, #92]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35f9e:	695a      	ldr	r2, [r3, #20]
   35fa0:	f042 0210 	orr.w	r2, r2, #16
   35fa4:	615a      	str	r2, [r3, #20]
   35fa6:	695a      	ldr	r2, [r3, #20]
   35fa8:	f36f 1245 	bfc	r2, #5, #1
   35fac:	615a      	str	r2, [r3, #20]
   35fae:	e785      	b.n	35ebc <am_hal_pwrctrl_mcu_memory_config+0x14>
   35fb0:	4b12      	ldr	r3, [pc, #72]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35fb2:	69da      	ldr	r2, [r3, #28]
   35fb4:	f36f 0202 	bfc	r2, #0, #3
   35fb8:	61da      	str	r2, [r3, #28]
   35fba:	e79c      	b.n	35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35fbc:	4b0f      	ldr	r3, [pc, #60]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35fbe:	69da      	ldr	r2, [r3, #28]
   35fc0:	2104      	movs	r1, #4
   35fc2:	f361 0202 	bfi	r2, r1, #0, #3
   35fc6:	61da      	str	r2, [r3, #28]
   35fc8:	e795      	b.n	35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35fca:	4b0c      	ldr	r3, [pc, #48]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35fcc:	69da      	ldr	r2, [r3, #28]
   35fce:	2106      	movs	r1, #6
   35fd0:	f361 0202 	bfi	r2, r1, #0, #3
   35fd4:	61da      	str	r2, [r3, #28]
   35fd6:	e78e      	b.n	35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35fd8:	4a08      	ldr	r2, [pc, #32]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35fda:	69d3      	ldr	r3, [r2, #28]
   35fdc:	f043 0307 	orr.w	r3, r3, #7
   35fe0:	61d3      	str	r3, [r2, #28]
   35fe2:	e788      	b.n	35ef6 <am_hal_pwrctrl_mcu_memory_config+0x4e>
   35fe4:	4a05      	ldr	r2, [pc, #20]	; (35ffc <am_hal_pwrctrl_mcu_memory_config+0x154>)
   35fe6:	69d3      	ldr	r3, [r2, #28]
   35fe8:	f043 0308 	orr.w	r3, r3, #8
   35fec:	61d3      	str	r3, [r2, #28]
   35fee:	e7ab      	b.n	35f48 <am_hal_pwrctrl_mcu_memory_config+0xa0>
   35ff0:	69e3      	ldr	r3, [r4, #28]
   35ff2:	f043 0310 	orr.w	r3, r3, #16
   35ff6:	61e3      	str	r3, [r4, #28]
   35ff8:	e79e      	b.n	35f38 <am_hal_pwrctrl_mcu_memory_config+0x90>
   35ffa:	bf00      	nop
   35ffc:	40021000 	.word	0x40021000
   36000:	40021018 	.word	0x40021018

00036004 <am_hal_pwrctrl_sram_config>:
   36004:	b570      	push	{r4, r5, r6, lr}
   36006:	4c29      	ldr	r4, [pc, #164]	; (360ac <am_hal_pwrctrl_sram_config+0xa8>)
   36008:	7802      	ldrb	r2, [r0, #0]
   3600a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3600c:	4928      	ldr	r1, [pc, #160]	; (360b0 <am_hal_pwrctrl_sram_config+0xac>)
   3600e:	f362 0301 	bfi	r3, r2, #0, #2
   36012:	b082      	sub	sp, #8
   36014:	6263      	str	r3, [r4, #36]	; 0x24
   36016:	2601      	movs	r6, #1
   36018:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3601a:	9600      	str	r6, [sp, #0]
   3601c:	4605      	mov	r5, r0
   3601e:	2203      	movs	r2, #3
   36020:	2005      	movs	r0, #5
   36022:	f7ff f995 	bl	35350 <am_hal_delay_us_status_check>
   36026:	b940      	cbnz	r0, 3603a <am_hal_pwrctrl_sram_config+0x36>
   36028:	6aa2      	ldr	r2, [r4, #40]	; 0x28
   3602a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3602c:	f002 0203 	and.w	r2, r2, #3
   36030:	f003 0303 	and.w	r3, r3, #3
   36034:	429a      	cmp	r2, r3
   36036:	d002      	beq.n	3603e <am_hal_pwrctrl_sram_config+0x3a>
   36038:	4630      	mov	r0, r6
   3603a:	b002      	add	sp, #8
   3603c:	bd70      	pop	{r4, r5, r6, pc}
   3603e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   36040:	786b      	ldrb	r3, [r5, #1]
   36042:	f895 c002 	ldrb.w	ip, [r5, #2]
   36046:	78ee      	ldrb	r6, [r5, #3]
   36048:	7929      	ldrb	r1, [r5, #4]
   3604a:	f363 0283 	bfi	r2, r3, #2, #2
   3604e:	796b      	ldrb	r3, [r5, #5]
   36050:	62e2      	str	r2, [r4, #44]	; 0x2c
   36052:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   36054:	f36c 1287 	bfi	r2, ip, #6, #2
   36058:	62e2      	str	r2, [r4, #44]	; 0x2c
   3605a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   3605c:	f366 2209 	bfi	r2, r6, #8, #2
   36060:	62e2      	str	r2, [r4, #44]	; 0x2c
   36062:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   36064:	f361 1205 	bfi	r2, r1, #4, #2
   36068:	62e2      	str	r2, [r4, #44]	; 0x2c
   3606a:	2b03      	cmp	r3, #3
   3606c:	d8e5      	bhi.n	3603a <am_hal_pwrctrl_sram_config+0x36>
   3606e:	e8df f003 	tbb	[pc, r3]
   36072:	0f16      	.short	0x0f16
   36074:	0208      	.short	0x0208
   36076:	4b0d      	ldr	r3, [pc, #52]	; (360ac <am_hal_pwrctrl_sram_config+0xa8>)
   36078:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   3607a:	f36f 0201 	bfc	r2, #0, #2
   3607e:	62da      	str	r2, [r3, #44]	; 0x2c
   36080:	e7db      	b.n	3603a <am_hal_pwrctrl_sram_config+0x36>
   36082:	4b0a      	ldr	r3, [pc, #40]	; (360ac <am_hal_pwrctrl_sram_config+0xa8>)
   36084:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   36086:	2101      	movs	r1, #1
   36088:	f361 0201 	bfi	r2, r1, #0, #2
   3608c:	62da      	str	r2, [r3, #44]	; 0x2c
   3608e:	e7d4      	b.n	3603a <am_hal_pwrctrl_sram_config+0x36>
   36090:	4b06      	ldr	r3, [pc, #24]	; (360ac <am_hal_pwrctrl_sram_config+0xa8>)
   36092:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   36094:	2102      	movs	r1, #2
   36096:	f361 0201 	bfi	r2, r1, #0, #2
   3609a:	62da      	str	r2, [r3, #44]	; 0x2c
   3609c:	e7cd      	b.n	3603a <am_hal_pwrctrl_sram_config+0x36>
   3609e:	4a03      	ldr	r2, [pc, #12]	; (360ac <am_hal_pwrctrl_sram_config+0xa8>)
   360a0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   360a2:	f043 0303 	orr.w	r3, r3, #3
   360a6:	62d3      	str	r3, [r2, #44]	; 0x2c
   360a8:	e7c7      	b.n	3603a <am_hal_pwrctrl_sram_config+0x36>
   360aa:	bf00      	nop
   360ac:	40021000 	.word	0x40021000
   360b0:	40021028 	.word	0x40021028

000360b4 <am_hal_pwrctrl_dsp_memory_config>:
   360b4:	b530      	push	{r4, r5, lr}
   360b6:	460c      	mov	r4, r1
   360b8:	b083      	sub	sp, #12
   360ba:	2800      	cmp	r0, #0
   360bc:	d053      	beq.n	36166 <am_hal_pwrctrl_dsp_memory_config+0xb2>
   360be:	2801      	cmp	r0, #1
   360c0:	d14e      	bne.n	36160 <am_hal_pwrctrl_dsp_memory_config+0xac>
   360c2:	780b      	ldrb	r3, [r1, #0]
   360c4:	4a6b      	ldr	r2, [pc, #428]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   360c6:	2b00      	cmp	r3, #0
   360c8:	f000 809d 	beq.w	36206 <am_hal_pwrctrl_dsp_memory_config+0x152>
   360cc:	6f93      	ldr	r3, [r2, #120]	; 0x78
   360ce:	f043 0302 	orr.w	r3, r3, #2
   360d2:	6793      	str	r3, [r2, #120]	; 0x78
   360d4:	78a3      	ldrb	r3, [r4, #2]
   360d6:	4a67      	ldr	r2, [pc, #412]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   360d8:	2b00      	cmp	r3, #0
   360da:	f000 809d 	beq.w	36218 <am_hal_pwrctrl_dsp_memory_config+0x164>
   360de:	6f93      	ldr	r3, [r2, #120]	; 0x78
   360e0:	f043 0301 	orr.w	r3, r3, #1
   360e4:	6793      	str	r3, [r2, #120]	; 0x78
   360e6:	4d63      	ldr	r5, [pc, #396]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   360e8:	4963      	ldr	r1, [pc, #396]	; (36278 <am_hal_pwrctrl_dsp_memory_config+0x1c4>)
   360ea:	6fab      	ldr	r3, [r5, #120]	; 0x78
   360ec:	2201      	movs	r2, #1
   360ee:	9200      	str	r2, [sp, #0]
   360f0:	2005      	movs	r0, #5
   360f2:	2203      	movs	r2, #3
   360f4:	f7ff f92c 	bl	35350 <am_hal_delay_us_status_check>
   360f8:	bb98      	cbnz	r0, 36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   360fa:	6fea      	ldr	r2, [r5, #124]	; 0x7c
   360fc:	6fab      	ldr	r3, [r5, #120]	; 0x78
   360fe:	f3c2 0240 	ubfx	r2, r2, #1, #1
   36102:	f3c3 0340 	ubfx	r3, r3, #1, #1
   36106:	429a      	cmp	r2, r3
   36108:	f040 808b 	bne.w	36222 <am_hal_pwrctrl_dsp_memory_config+0x16e>
   3610c:	6fea      	ldr	r2, [r5, #124]	; 0x7c
   3610e:	6fab      	ldr	r3, [r5, #120]	; 0x78
   36110:	f002 0201 	and.w	r2, r2, #1
   36114:	f003 0301 	and.w	r3, r3, #1
   36118:	429a      	cmp	r2, r3
   3611a:	f040 8082 	bne.w	36222 <am_hal_pwrctrl_dsp_memory_config+0x16e>
   3611e:	7863      	ldrb	r3, [r4, #1]
   36120:	2b00      	cmp	r3, #0
   36122:	f040 8081 	bne.w	36228 <am_hal_pwrctrl_dsp_memory_config+0x174>
   36126:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
   3612a:	f043 0304 	orr.w	r3, r3, #4
   3612e:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
   36132:	78e3      	ldrb	r3, [r4, #3]
   36134:	4a4f      	ldr	r2, [pc, #316]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36136:	2b00      	cmp	r3, #0
   36138:	f000 8095 	beq.w	36266 <am_hal_pwrctrl_dsp_memory_config+0x1b2>
   3613c:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   36140:	f043 0302 	orr.w	r3, r3, #2
   36144:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
   36148:	7923      	ldrb	r3, [r4, #4]
   3614a:	2b00      	cmp	r3, #0
   3614c:	f000 8083 	beq.w	36256 <am_hal_pwrctrl_dsp_memory_config+0x1a2>
   36150:	4b48      	ldr	r3, [pc, #288]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36152:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
   36156:	f36f 0200 	bfc	r2, #0, #1
   3615a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   3615e:	e000      	b.n	36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   36160:	2000      	movs	r0, #0
   36162:	b003      	add	sp, #12
   36164:	bd30      	pop	{r4, r5, pc}
   36166:	780b      	ldrb	r3, [r1, #0]
   36168:	4a42      	ldr	r2, [pc, #264]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   3616a:	2b00      	cmp	r3, #0
   3616c:	d13e      	bne.n	361ec <am_hal_pwrctrl_dsp_memory_config+0x138>
   3616e:	6d91      	ldr	r1, [r2, #88]	; 0x58
   36170:	f363 0141 	bfi	r1, r3, #1, #1
   36174:	6591      	str	r1, [r2, #88]	; 0x58
   36176:	78a3      	ldrb	r3, [r4, #2]
   36178:	4a3e      	ldr	r2, [pc, #248]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   3617a:	2b00      	cmp	r3, #0
   3617c:	d03e      	beq.n	361fc <am_hal_pwrctrl_dsp_memory_config+0x148>
   3617e:	6d93      	ldr	r3, [r2, #88]	; 0x58
   36180:	f043 0301 	orr.w	r3, r3, #1
   36184:	6593      	str	r3, [r2, #88]	; 0x58
   36186:	4d3b      	ldr	r5, [pc, #236]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36188:	493c      	ldr	r1, [pc, #240]	; (3627c <am_hal_pwrctrl_dsp_memory_config+0x1c8>)
   3618a:	6dab      	ldr	r3, [r5, #88]	; 0x58
   3618c:	2201      	movs	r2, #1
   3618e:	9200      	str	r2, [sp, #0]
   36190:	2005      	movs	r0, #5
   36192:	2203      	movs	r2, #3
   36194:	f7ff f8dc 	bl	35350 <am_hal_delay_us_status_check>
   36198:	2800      	cmp	r0, #0
   3619a:	d1e2      	bne.n	36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   3619c:	6dea      	ldr	r2, [r5, #92]	; 0x5c
   3619e:	6dab      	ldr	r3, [r5, #88]	; 0x58
   361a0:	f3c2 0240 	ubfx	r2, r2, #1, #1
   361a4:	f3c3 0340 	ubfx	r3, r3, #1, #1
   361a8:	429a      	cmp	r2, r3
   361aa:	d13a      	bne.n	36222 <am_hal_pwrctrl_dsp_memory_config+0x16e>
   361ac:	6dea      	ldr	r2, [r5, #92]	; 0x5c
   361ae:	6dab      	ldr	r3, [r5, #88]	; 0x58
   361b0:	f002 0201 	and.w	r2, r2, #1
   361b4:	f003 0301 	and.w	r3, r3, #1
   361b8:	429a      	cmp	r2, r3
   361ba:	d132      	bne.n	36222 <am_hal_pwrctrl_dsp_memory_config+0x16e>
   361bc:	7863      	ldrb	r3, [r4, #1]
   361be:	2b00      	cmp	r3, #0
   361c0:	d139      	bne.n	36236 <am_hal_pwrctrl_dsp_memory_config+0x182>
   361c2:	6e2b      	ldr	r3, [r5, #96]	; 0x60
   361c4:	f043 0304 	orr.w	r3, r3, #4
   361c8:	662b      	str	r3, [r5, #96]	; 0x60
   361ca:	78e3      	ldrb	r3, [r4, #3]
   361cc:	4a29      	ldr	r2, [pc, #164]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   361ce:	2b00      	cmp	r3, #0
   361d0:	d03c      	beq.n	3624c <am_hal_pwrctrl_dsp_memory_config+0x198>
   361d2:	6e13      	ldr	r3, [r2, #96]	; 0x60
   361d4:	f043 0302 	orr.w	r3, r3, #2
   361d8:	6613      	str	r3, [r2, #96]	; 0x60
   361da:	7923      	ldrb	r3, [r4, #4]
   361dc:	2b00      	cmp	r3, #0
   361de:	d02f      	beq.n	36240 <am_hal_pwrctrl_dsp_memory_config+0x18c>
   361e0:	4b24      	ldr	r3, [pc, #144]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   361e2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   361e4:	f36f 0200 	bfc	r2, #0, #1
   361e8:	661a      	str	r2, [r3, #96]	; 0x60
   361ea:	e7ba      	b.n	36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   361ec:	6d93      	ldr	r3, [r2, #88]	; 0x58
   361ee:	f043 0302 	orr.w	r3, r3, #2
   361f2:	6593      	str	r3, [r2, #88]	; 0x58
   361f4:	78a3      	ldrb	r3, [r4, #2]
   361f6:	4a1f      	ldr	r2, [pc, #124]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   361f8:	2b00      	cmp	r3, #0
   361fa:	d1c0      	bne.n	3617e <am_hal_pwrctrl_dsp_memory_config+0xca>
   361fc:	6d91      	ldr	r1, [r2, #88]	; 0x58
   361fe:	f363 0100 	bfi	r1, r3, #0, #1
   36202:	6591      	str	r1, [r2, #88]	; 0x58
   36204:	e7bf      	b.n	36186 <am_hal_pwrctrl_dsp_memory_config+0xd2>
   36206:	6f91      	ldr	r1, [r2, #120]	; 0x78
   36208:	f363 0141 	bfi	r1, r3, #1, #1
   3620c:	6791      	str	r1, [r2, #120]	; 0x78
   3620e:	78a3      	ldrb	r3, [r4, #2]
   36210:	4a18      	ldr	r2, [pc, #96]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36212:	2b00      	cmp	r3, #0
   36214:	f47f af63 	bne.w	360de <am_hal_pwrctrl_dsp_memory_config+0x2a>
   36218:	6f91      	ldr	r1, [r2, #120]	; 0x78
   3621a:	f363 0100 	bfi	r1, r3, #0, #1
   3621e:	6791      	str	r1, [r2, #120]	; 0x78
   36220:	e761      	b.n	360e6 <am_hal_pwrctrl_dsp_memory_config+0x32>
   36222:	2001      	movs	r0, #1
   36224:	b003      	add	sp, #12
   36226:	bd30      	pop	{r4, r5, pc}
   36228:	f8d5 3080 	ldr.w	r3, [r5, #128]	; 0x80
   3622c:	f360 0382 	bfi	r3, r0, #2, #1
   36230:	f8c5 3080 	str.w	r3, [r5, #128]	; 0x80
   36234:	e77d      	b.n	36132 <am_hal_pwrctrl_dsp_memory_config+0x7e>
   36236:	6e2b      	ldr	r3, [r5, #96]	; 0x60
   36238:	f360 0382 	bfi	r3, r0, #2, #1
   3623c:	662b      	str	r3, [r5, #96]	; 0x60
   3623e:	e7c4      	b.n	361ca <am_hal_pwrctrl_dsp_memory_config+0x116>
   36240:	4a0c      	ldr	r2, [pc, #48]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36242:	6e13      	ldr	r3, [r2, #96]	; 0x60
   36244:	f043 0301 	orr.w	r3, r3, #1
   36248:	6613      	str	r3, [r2, #96]	; 0x60
   3624a:	e78a      	b.n	36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   3624c:	6e11      	ldr	r1, [r2, #96]	; 0x60
   3624e:	f363 0141 	bfi	r1, r3, #1, #1
   36252:	6611      	str	r1, [r2, #96]	; 0x60
   36254:	e7c1      	b.n	361da <am_hal_pwrctrl_dsp_memory_config+0x126>
   36256:	4a07      	ldr	r2, [pc, #28]	; (36274 <am_hal_pwrctrl_dsp_memory_config+0x1c0>)
   36258:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
   3625c:	f043 0301 	orr.w	r3, r3, #1
   36260:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
   36264:	e77d      	b.n	36162 <am_hal_pwrctrl_dsp_memory_config+0xae>
   36266:	f8d2 1080 	ldr.w	r1, [r2, #128]	; 0x80
   3626a:	f363 0141 	bfi	r1, r3, #1, #1
   3626e:	f8c2 1080 	str.w	r1, [r2, #128]	; 0x80
   36272:	e769      	b.n	36148 <am_hal_pwrctrl_dsp_memory_config+0x94>
   36274:	40021000 	.word	0x40021000
   36278:	4002107c 	.word	0x4002107c
   3627c:	4002105c 	.word	0x4002105c

00036280 <am_hal_pwrctrl_periph_enable>:
   36280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   36284:	2821      	cmp	r0, #33	; 0x21
   36286:	b089      	sub	sp, #36	; 0x24
   36288:	d831      	bhi.n	362ee <am_hal_pwrctrl_periph_enable+0x6e>
   3628a:	4b5e      	ldr	r3, [pc, #376]	; (36404 <am_hal_pwrctrl_periph_enable+0x184>)
   3628c:	0101      	lsls	r1, r0, #4
   3628e:	eb03 1200 	add.w	r2, r3, r0, lsl #4
   36292:	585f      	ldr	r7, [r3, r1]
   36294:	f8d2 8004 	ldr.w	r8, [r2, #4]
   36298:	6839      	ldr	r1, [r7, #0]
   3629a:	ea11 0f08 	tst.w	r1, r8
   3629e:	4604      	mov	r4, r0
   362a0:	d120      	bne.n	362e4 <am_hal_pwrctrl_periph_enable+0x64>
   362a2:	2814      	cmp	r0, #20
   362a4:	e9d2 6502 	ldrd	r6, r5, [r2, #8]
   362a8:	d026      	beq.n	362f8 <am_hal_pwrctrl_periph_enable+0x78>
   362aa:	f7fd fda7 	bl	33dfc <am_hal_interrupt_master_disable>
   362ae:	9005      	str	r0, [sp, #20]
   362b0:	683b      	ldr	r3, [r7, #0]
   362b2:	ea43 0308 	orr.w	r3, r3, r8
   362b6:	603b      	str	r3, [r7, #0]
   362b8:	9805      	ldr	r0, [sp, #20]
   362ba:	f7fd fda3 	bl	33e04 <am_hal_interrupt_master_set>
   362be:	2301      	movs	r3, #1
   362c0:	9300      	str	r3, [sp, #0]
   362c2:	462a      	mov	r2, r5
   362c4:	462b      	mov	r3, r5
   362c6:	4631      	mov	r1, r6
   362c8:	2005      	movs	r0, #5
   362ca:	f7ff f841 	bl	35350 <am_hal_delay_us_status_check>
   362ce:	4604      	mov	r4, r0
   362d0:	b920      	cbnz	r0, 362dc <am_hal_pwrctrl_periph_enable+0x5c>
   362d2:	6833      	ldr	r3, [r6, #0]
   362d4:	422b      	tst	r3, r5
   362d6:	bf0c      	ite	eq
   362d8:	2401      	moveq	r4, #1
   362da:	2400      	movne	r4, #0
   362dc:	4620      	mov	r0, r4
   362de:	b009      	add	sp, #36	; 0x24
   362e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   362e4:	2400      	movs	r4, #0
   362e6:	4620      	mov	r0, r4
   362e8:	b009      	add	sp, #36	; 0x24
   362ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   362ee:	2406      	movs	r4, #6
   362f0:	4620      	mov	r0, r4
   362f2:	b009      	add	sp, #36	; 0x24
   362f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   362f8:	f8df 9120 	ldr.w	r9, [pc, #288]	; 3641c <am_hal_pwrctrl_periph_enable+0x19c>
   362fc:	f8d9 a000 	ldr.w	sl, [r9]
   36300:	f1ba 0f00 	cmp.w	sl, #0
   36304:	d02f      	beq.n	36366 <am_hal_pwrctrl_periph_enable+0xe6>
   36306:	f8df b108 	ldr.w	fp, [pc, #264]	; 36410 <am_hal_pwrctrl_periph_enable+0x190>
   3630a:	f89b 3000 	ldrb.w	r3, [fp]
   3630e:	bb53      	cbnz	r3, 36366 <am_hal_pwrctrl_periph_enable+0xe6>
   36310:	f7fd fd74 	bl	33dfc <am_hal_interrupt_master_disable>
   36314:	4a3c      	ldr	r2, [pc, #240]	; (36408 <am_hal_pwrctrl_periph_enable+0x188>)
   36316:	493d      	ldr	r1, [pc, #244]	; (3640c <am_hal_pwrctrl_periph_enable+0x18c>)
   36318:	6813      	ldr	r3, [r2, #0]
   3631a:	9006      	str	r0, [sp, #24]
   3631c:	4453      	add	r3, sl
   3631e:	6013      	str	r3, [r2, #0]
   36320:	f383 0006 	usat	r0, #6, r3
   36324:	680b      	ldr	r3, [r1, #0]
   36326:	2201      	movs	r2, #1
   36328:	4453      	add	r3, sl
   3632a:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 36414 <am_hal_pwrctrl_periph_enable+0x194>
   3632e:	600b      	str	r3, [r1, #0]
   36330:	9303      	str	r3, [sp, #12]
   36332:	f88b 2000 	strb.w	r2, [fp]
   36336:	f8da 236c 	ldr.w	r2, [sl, #876]	; 0x36c
   3633a:	f360 5219 	bfi	r2, r0, #20, #6
   3633e:	f8ca 236c 	str.w	r2, [sl, #876]	; 0x36c
   36342:	4620      	mov	r0, r4
   36344:	f7fe ffc0 	bl	352c8 <am_hal_delay_us>
   36348:	9b03      	ldr	r3, [sp, #12]
   3634a:	f8da 2088 	ldr.w	r2, [sl, #136]	; 0x88
   3634e:	f383 0306 	usat	r3, #6, r3
   36352:	f363 0205 	bfi	r2, r3, #0, #6
   36356:	f8ca 2088 	str.w	r2, [sl, #136]	; 0x88
   3635a:	9806      	ldr	r0, [sp, #24]
   3635c:	f7fd fd52 	bl	33e04 <am_hal_interrupt_master_set>
   36360:	4620      	mov	r0, r4
   36362:	f7fe ffb1 	bl	352c8 <am_hal_delay_us>
   36366:	f7fd fd49 	bl	33dfc <am_hal_interrupt_master_disable>
   3636a:	9005      	str	r0, [sp, #20]
   3636c:	683b      	ldr	r3, [r7, #0]
   3636e:	ea48 0303 	orr.w	r3, r8, r3
   36372:	603b      	str	r3, [r7, #0]
   36374:	9805      	ldr	r0, [sp, #20]
   36376:	f7fd fd45 	bl	33e04 <am_hal_interrupt_master_set>
   3637a:	2301      	movs	r3, #1
   3637c:	9300      	str	r3, [sp, #0]
   3637e:	462a      	mov	r2, r5
   36380:	462b      	mov	r3, r5
   36382:	4631      	mov	r1, r6
   36384:	2005      	movs	r0, #5
   36386:	f7fe ffe3 	bl	35350 <am_hal_delay_us_status_check>
   3638a:	4604      	mov	r4, r0
   3638c:	b378      	cbz	r0, 363ee <am_hal_pwrctrl_periph_enable+0x16e>
   3638e:	f8d9 5000 	ldr.w	r5, [r9]
   36392:	2d00      	cmp	r5, #0
   36394:	d0a2      	beq.n	362dc <am_hal_pwrctrl_periph_enable+0x5c>
   36396:	4e1e      	ldr	r6, [pc, #120]	; (36410 <am_hal_pwrctrl_periph_enable+0x190>)
   36398:	7833      	ldrb	r3, [r6, #0]
   3639a:	2b00      	cmp	r3, #0
   3639c:	d09e      	beq.n	362dc <am_hal_pwrctrl_periph_enable+0x5c>
   3639e:	f7fd fd2d 	bl	33dfc <am_hal_interrupt_master_disable>
   363a2:	4b19      	ldr	r3, [pc, #100]	; (36408 <am_hal_pwrctrl_periph_enable+0x188>)
   363a4:	4f1b      	ldr	r7, [pc, #108]	; (36414 <am_hal_pwrctrl_periph_enable+0x194>)
   363a6:	9007      	str	r0, [sp, #28]
   363a8:	2200      	movs	r2, #0
   363aa:	7032      	strb	r2, [r6, #0]
   363ac:	681e      	ldr	r6, [r3, #0]
   363ae:	4a17      	ldr	r2, [pc, #92]	; (3640c <am_hal_pwrctrl_periph_enable+0x18c>)
   363b0:	1b76      	subs	r6, r6, r5
   363b2:	601e      	str	r6, [r3, #0]
   363b4:	6813      	ldr	r3, [r2, #0]
   363b6:	1b5d      	subs	r5, r3, r5
   363b8:	6015      	str	r5, [r2, #0]
   363ba:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
   363be:	f385 0506 	usat	r5, #6, r5
   363c2:	f365 0305 	bfi	r3, r5, #0, #6
   363c6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
   363ca:	2014      	movs	r0, #20
   363cc:	f7fe ff7c 	bl	352c8 <am_hal_delay_us>
   363d0:	f8d7 336c 	ldr.w	r3, [r7, #876]	; 0x36c
   363d4:	f386 0606 	usat	r6, #6, r6
   363d8:	f366 5319 	bfi	r3, r6, #20, #6
   363dc:	f8c7 336c 	str.w	r3, [r7, #876]	; 0x36c
   363e0:	9807      	ldr	r0, [sp, #28]
   363e2:	f7fd fd0f 	bl	33e04 <am_hal_interrupt_master_set>
   363e6:	2014      	movs	r0, #20
   363e8:	f7fe ff6e 	bl	352c8 <am_hal_delay_us>
   363ec:	e776      	b.n	362dc <am_hal_pwrctrl_periph_enable+0x5c>
   363ee:	2301      	movs	r3, #1
   363f0:	4909      	ldr	r1, [pc, #36]	; (36418 <am_hal_pwrctrl_periph_enable+0x198>)
   363f2:	461a      	mov	r2, r3
   363f4:	2064      	movs	r0, #100	; 0x64
   363f6:	f7fe ff7f 	bl	352f8 <am_hal_delay_us_status_change>
   363fa:	4604      	mov	r4, r0
   363fc:	2800      	cmp	r0, #0
   363fe:	f43f af68 	beq.w	362d2 <am_hal_pwrctrl_periph_enable+0x52>
   36402:	e76b      	b.n	362dc <am_hal_pwrctrl_periph_enable+0x5c>
   36404:	0004681c 	.word	0x0004681c
   36408:	10010c5c 	.word	0x10010c5c
   3640c:	10010c58 	.word	0x10010c58
   36410:	10010c54 	.word	0x10010c54
   36414:	40020000 	.word	0x40020000
   36418:	400c1f10 	.word	0x400c1f10
   3641c:	10010c78 	.word	0x10010c78

00036420 <am_hal_pwrctrl_periph_disable>:
   36420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   36424:	2821      	cmp	r0, #33	; 0x21
   36426:	b085      	sub	sp, #20
   36428:	d82b      	bhi.n	36482 <am_hal_pwrctrl_periph_disable+0x62>
   3642a:	4b55      	ldr	r3, [pc, #340]	; (36580 <am_hal_pwrctrl_periph_disable+0x160>)
   3642c:	0101      	lsls	r1, r0, #4
   3642e:	eb03 1200 	add.w	r2, r3, r0, lsl #4
   36432:	585d      	ldr	r5, [r3, r1]
   36434:	6857      	ldr	r7, [r2, #4]
   36436:	682b      	ldr	r3, [r5, #0]
   36438:	423b      	tst	r3, r7
   3643a:	4604      	mov	r4, r0
   3643c:	d01c      	beq.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   3643e:	2814      	cmp	r0, #20
   36440:	e9d2 9802 	ldrd	r9, r8, [r2, #8]
   36444:	d105      	bne.n	36452 <am_hal_pwrctrl_periph_disable+0x32>
   36446:	f8df a150 	ldr.w	sl, [pc, #336]	; 36598 <am_hal_pwrctrl_periph_disable+0x178>
   3644a:	f8da 3fe0 	ldr.w	r3, [sl, #4064]	; 0xfe0
   3644e:	2bc0      	cmp	r3, #192	; 0xc0
   36450:	d037      	beq.n	364c2 <am_hal_pwrctrl_periph_disable+0xa2>
   36452:	f7fd fcd3 	bl	33dfc <am_hal_interrupt_master_disable>
   36456:	9002      	str	r0, [sp, #8]
   36458:	682b      	ldr	r3, [r5, #0]
   3645a:	ea23 0707 	bic.w	r7, r3, r7
   3645e:	602f      	str	r7, [r5, #0]
   36460:	9802      	ldr	r0, [sp, #8]
   36462:	f7fd fccf 	bl	33e04 <am_hal_interrupt_master_set>
   36466:	2300      	movs	r3, #0
   36468:	9300      	str	r3, [sp, #0]
   3646a:	4642      	mov	r2, r8
   3646c:	4643      	mov	r3, r8
   3646e:	4649      	mov	r1, r9
   36470:	2005      	movs	r0, #5
   36472:	f7fe ff6d 	bl	35350 <am_hal_delay_us_status_check>
   36476:	b948      	cbnz	r0, 3648c <am_hal_pwrctrl_periph_disable+0x6c>
   36478:	2600      	movs	r6, #0
   3647a:	4630      	mov	r0, r6
   3647c:	b005      	add	sp, #20
   3647e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   36482:	2606      	movs	r6, #6
   36484:	4630      	mov	r0, r6
   36486:	b005      	add	sp, #20
   36488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3648c:	f5b8 7ff0 	cmp.w	r8, #480	; 0x1e0
   36490:	d070      	beq.n	36574 <am_hal_pwrctrl_periph_disable+0x154>
   36492:	d90b      	bls.n	364ac <am_hal_pwrctrl_periph_disable+0x8c>
   36494:	f5b8 5ff0 	cmp.w	r8, #7680	; 0x1e00
   36498:	d067      	beq.n	3656a <am_hal_pwrctrl_periph_disable+0x14a>
   3649a:	f5b8 3fe0 	cmp.w	r8, #114688	; 0x1c000
   3649e:	d1eb      	bne.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   364a0:	682b      	ldr	r3, [r5, #0]
   364a2:	f413 3fe0 	tst.w	r3, #114688	; 0x1c000
   364a6:	d0e7      	beq.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   364a8:	682b      	ldr	r3, [r5, #0]
   364aa:	e7e5      	b.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   364ac:	f1b8 0f1e 	cmp.w	r8, #30
   364b0:	d056      	beq.n	36560 <am_hal_pwrctrl_periph_disable+0x140>
   364b2:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
   364b6:	d1df      	bne.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   364b8:	682b      	ldr	r3, [r5, #0]
   364ba:	b2db      	uxtb	r3, r3
   364bc:	2b00      	cmp	r3, #0
   364be:	d0db      	beq.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   364c0:	e7f2      	b.n	364a8 <am_hal_pwrctrl_periph_disable+0x88>
   364c2:	2301      	movs	r3, #1
   364c4:	492f      	ldr	r1, [pc, #188]	; (36584 <am_hal_pwrctrl_periph_disable+0x164>)
   364c6:	461a      	mov	r2, r3
   364c8:	2064      	movs	r0, #100	; 0x64
   364ca:	f7fe ff15 	bl	352f8 <am_hal_delay_us_status_change>
   364ce:	4606      	mov	r6, r0
   364d0:	2800      	cmp	r0, #0
   364d2:	d1d2      	bne.n	3647a <am_hal_pwrctrl_periph_disable+0x5a>
   364d4:	2301      	movs	r3, #1
   364d6:	492c      	ldr	r1, [pc, #176]	; (36588 <am_hal_pwrctrl_periph_disable+0x168>)
   364d8:	461a      	mov	r2, r3
   364da:	2064      	movs	r0, #100	; 0x64
   364dc:	f7fe ff0c 	bl	352f8 <am_hal_delay_us_status_change>
   364e0:	4606      	mov	r6, r0
   364e2:	2800      	cmp	r0, #0
   364e4:	d1c9      	bne.n	3647a <am_hal_pwrctrl_periph_disable+0x5a>
   364e6:	f8da 3a80 	ldr.w	r3, [sl, #2688]	; 0xa80
   364ea:	f043 0301 	orr.w	r3, r3, #1
   364ee:	f8ca 3a80 	str.w	r3, [sl, #2688]	; 0xa80
   364f2:	4b26      	ldr	r3, [pc, #152]	; (3658c <am_hal_pwrctrl_periph_disable+0x16c>)
   364f4:	f8d3 a000 	ldr.w	sl, [r3]
   364f8:	f1ba 0f00 	cmp.w	sl, #0
   364fc:	d0a9      	beq.n	36452 <am_hal_pwrctrl_periph_disable+0x32>
   364fe:	f8df b09c 	ldr.w	fp, [pc, #156]	; 3659c <am_hal_pwrctrl_periph_disable+0x17c>
   36502:	f89b 3000 	ldrb.w	r3, [fp]
   36506:	2b00      	cmp	r3, #0
   36508:	d0a3      	beq.n	36452 <am_hal_pwrctrl_periph_disable+0x32>
   3650a:	f7fd fc77 	bl	33dfc <am_hal_interrupt_master_disable>
   3650e:	4b20      	ldr	r3, [pc, #128]	; (36590 <am_hal_pwrctrl_periph_disable+0x170>)
   36510:	f88b 6000 	strb.w	r6, [fp]
   36514:	681e      	ldr	r6, [r3, #0]
   36516:	4a1f      	ldr	r2, [pc, #124]	; (36594 <am_hal_pwrctrl_periph_disable+0x174>)
   36518:	9003      	str	r0, [sp, #12]
   3651a:	eba6 060a 	sub.w	r6, r6, sl
   3651e:	601e      	str	r6, [r3, #0]
   36520:	6813      	ldr	r3, [r2, #0]
   36522:	eba3 030a 	sub.w	r3, r3, sl
   36526:	f8df a078 	ldr.w	sl, [pc, #120]	; 365a0 <am_hal_pwrctrl_periph_disable+0x180>
   3652a:	6013      	str	r3, [r2, #0]
   3652c:	f8da 2088 	ldr.w	r2, [sl, #136]	; 0x88
   36530:	f383 0306 	usat	r3, #6, r3
   36534:	f363 0205 	bfi	r2, r3, #0, #6
   36538:	4620      	mov	r0, r4
   3653a:	f8ca 2088 	str.w	r2, [sl, #136]	; 0x88
   3653e:	f7fe fec3 	bl	352c8 <am_hal_delay_us>
   36542:	f8da 336c 	ldr.w	r3, [sl, #876]	; 0x36c
   36546:	f386 0606 	usat	r6, #6, r6
   3654a:	f366 5319 	bfi	r3, r6, #20, #6
   3654e:	f8ca 336c 	str.w	r3, [sl, #876]	; 0x36c
   36552:	9803      	ldr	r0, [sp, #12]
   36554:	f7fd fc56 	bl	33e04 <am_hal_interrupt_master_set>
   36558:	4620      	mov	r0, r4
   3655a:	f7fe feb5 	bl	352c8 <am_hal_delay_us>
   3655e:	e778      	b.n	36452 <am_hal_pwrctrl_periph_disable+0x32>
   36560:	682b      	ldr	r3, [r5, #0]
   36562:	f013 0f1e 	tst.w	r3, #30
   36566:	d087      	beq.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   36568:	e79e      	b.n	364a8 <am_hal_pwrctrl_periph_disable+0x88>
   3656a:	682b      	ldr	r3, [r5, #0]
   3656c:	f413 5ff0 	tst.w	r3, #7680	; 0x1e00
   36570:	d082      	beq.n	36478 <am_hal_pwrctrl_periph_disable+0x58>
   36572:	e799      	b.n	364a8 <am_hal_pwrctrl_periph_disable+0x88>
   36574:	682b      	ldr	r3, [r5, #0]
   36576:	f413 7ff0 	tst.w	r3, #480	; 0x1e0
   3657a:	f43f af7d 	beq.w	36478 <am_hal_pwrctrl_periph_disable+0x58>
   3657e:	e793      	b.n	364a8 <am_hal_pwrctrl_periph_disable+0x88>
   36580:	0004681c 	.word	0x0004681c
   36584:	400c0a7c 	.word	0x400c0a7c
   36588:	400c1f10 	.word	0x400c1f10
   3658c:	10010c78 	.word	0x10010c78
   36590:	10010c5c 	.word	0x10010c5c
   36594:	10010c58 	.word	0x10010c58
   36598:	400c0000 	.word	0x400c0000
   3659c:	10010c54 	.word	0x10010c54
   365a0:	40020000 	.word	0x40020000

000365a4 <am_hal_pwrctrl_low_power_init>:
   365a4:	b530      	push	{r4, r5, lr}
   365a6:	4c51      	ldr	r4, [pc, #324]	; (366ec <am_hal_pwrctrl_low_power_init+0x148>)
   365a8:	4a51      	ldr	r2, [pc, #324]	; (366f0 <am_hal_pwrctrl_low_power_init+0x14c>)
   365aa:	68a3      	ldr	r3, [r4, #8]
   365ac:	4851      	ldr	r0, [pc, #324]	; (366f4 <am_hal_pwrctrl_low_power_init+0x150>)
   365ae:	b083      	sub	sp, #12
   365b0:	f04f 2540 	mov.w	r5, #1073758208	; 0x40004000
   365b4:	f3c3 5300 	ubfx	r3, r3, #20, #1
   365b8:	7013      	strb	r3, [r2, #0]
   365ba:	f7ff fc75 	bl	35ea8 <am_hal_pwrctrl_mcu_memory_config>
   365be:	484e      	ldr	r0, [pc, #312]	; (366f8 <am_hal_pwrctrl_low_power_init+0x154>)
   365c0:	f7ff fd20 	bl	36004 <am_hal_pwrctrl_sram_config>
   365c4:	6c6a      	ldr	r2, [r5, #68]	; 0x44
   365c6:	484d      	ldr	r0, [pc, #308]	; (366fc <am_hal_pwrctrl_low_power_init+0x158>)
   365c8:	2300      	movs	r3, #0
   365ca:	f442 027c 	orr.w	r2, r2, #16515072	; 0xfc0000
   365ce:	646a      	str	r2, [r5, #68]	; 0x44
   365d0:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
   365d4:	f8c4 3144 	str.w	r3, [r4, #324]	; 0x144
   365d8:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   365dc:	f8c4 314c 	str.w	r3, [r4, #332]	; 0x14c
   365e0:	f8c4 3150 	str.w	r3, [r4, #336]	; 0x150
   365e4:	f8c4 3154 	str.w	r3, [r4, #340]	; 0x154
   365e8:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
   365ec:	f8c4 315c 	str.w	r3, [r4, #348]	; 0x15c
   365f0:	f8c4 3160 	str.w	r3, [r4, #352]	; 0x160
   365f4:	f8c4 3164 	str.w	r3, [r4, #356]	; 0x164
   365f8:	f8c4 3168 	str.w	r3, [r4, #360]	; 0x168
   365fc:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
   36600:	f8c4 3170 	str.w	r3, [r4, #368]	; 0x170
   36604:	f8c4 3174 	str.w	r3, [r4, #372]	; 0x174
   36608:	f8c4 3178 	str.w	r3, [r4, #376]	; 0x178
   3660c:	f8c4 317c 	str.w	r3, [r4, #380]	; 0x17c
   36610:	f8c4 3180 	str.w	r3, [r4, #384]	; 0x180
   36614:	f8c4 3184 	str.w	r3, [r4, #388]	; 0x184
   36618:	f8c4 3188 	str.w	r3, [r4, #392]	; 0x188
   3661c:	f7fd fb28 	bl	33c70 <am_hal_daxi_config>
   36620:	2064      	movs	r0, #100	; 0x64
   36622:	f7fe fe51 	bl	352c8 <am_hal_delay_us>
   36626:	6c6a      	ldr	r2, [r5, #68]	; 0x44
   36628:	4b35      	ldr	r3, [pc, #212]	; (36700 <am_hal_pwrctrl_low_power_init+0x15c>)
   3662a:	4c36      	ldr	r4, [pc, #216]	; (36704 <am_hal_pwrctrl_low_power_init+0x160>)
   3662c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   36630:	646a      	str	r2, [r5, #68]	; 0x44
   36632:	f8d3 237c 	ldr.w	r2, [r3, #892]	; 0x37c
   36636:	f042 62bf 	orr.w	r2, r2, #100139008	; 0x5f80000
   3663a:	f442 22d0 	orr.w	r2, r2, #425984	; 0x68000
   3663e:	f8c3 237c 	str.w	r2, [r3, #892]	; 0x37c
   36642:	f8d3 2444 	ldr.w	r2, [r3, #1092]	; 0x444
   36646:	2104      	movs	r1, #4
   36648:	f361 220f 	bfi	r2, r1, #8, #8
   3664c:	f8c3 2444 	str.w	r2, [r3, #1092]	; 0x444
   36650:	7822      	ldrb	r2, [r4, #0]
   36652:	b1da      	cbz	r2, 3668c <am_hal_pwrctrl_low_power_init+0xe8>
   36654:	4a2c      	ldr	r2, [pc, #176]	; (36708 <am_hal_pwrctrl_low_power_init+0x164>)
   36656:	4b2d      	ldr	r3, [pc, #180]	; (3670c <am_hal_pwrctrl_low_power_init+0x168>)
   36658:	6810      	ldr	r0, [r2, #0]
   3665a:	6819      	ldr	r1, [r3, #0]
   3665c:	4b2c      	ldr	r3, [pc, #176]	; (36710 <am_hal_pwrctrl_low_power_init+0x16c>)
   3665e:	4d2d      	ldr	r5, [pc, #180]	; (36714 <am_hal_pwrctrl_low_power_init+0x170>)
   36660:	4c2d      	ldr	r4, [pc, #180]	; (36718 <am_hal_pwrctrl_low_power_init+0x174>)
   36662:	6018      	str	r0, [r3, #0]
   36664:	2201      	movs	r2, #1
   36666:	2300      	movs	r3, #0
   36668:	6029      	str	r1, [r5, #0]
   3666a:	6023      	str	r3, [r4, #0]
   3666c:	f44f 6192 	mov.w	r1, #1168	; 0x490
   36670:	ab01      	add	r3, sp, #4
   36672:	4610      	mov	r0, r2
   36674:	f7fe fb4c 	bl	34d10 <am_hal_mram_info_read>
   36678:	b928      	cbnz	r0, 36686 <am_hal_pwrctrl_low_power_init+0xe2>
   3667a:	9b01      	ldr	r3, [sp, #4]
   3667c:	f013 0f06 	tst.w	r3, #6
   36680:	d123      	bne.n	366ca <am_hal_pwrctrl_low_power_init+0x126>
   36682:	2303      	movs	r3, #3
   36684:	6023      	str	r3, [r4, #0]
   36686:	2000      	movs	r0, #0
   36688:	b003      	add	sp, #12
   3668a:	bd30      	pop	{r4, r5, pc}
   3668c:	f8d3 036c 	ldr.w	r0, [r3, #876]	; 0x36c
   36690:	4a1d      	ldr	r2, [pc, #116]	; (36708 <am_hal_pwrctrl_low_power_init+0x164>)
   36692:	4d22      	ldr	r5, [pc, #136]	; (3671c <am_hal_pwrctrl_low_power_init+0x178>)
   36694:	f3c0 5005 	ubfx	r0, r0, #20, #6
   36698:	6010      	str	r0, [r2, #0]
   3669a:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
   3669e:	4a1b      	ldr	r2, [pc, #108]	; (3670c <am_hal_pwrctrl_low_power_init+0x168>)
   366a0:	f001 013f 	and.w	r1, r1, #63	; 0x3f
   366a4:	6011      	str	r1, [r2, #0]
   366a6:	f8d3 236c 	ldr.w	r2, [r3, #876]	; 0x36c
   366aa:	0e92      	lsrs	r2, r2, #26
   366ac:	602a      	str	r2, [r5, #0]
   366ae:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   366b2:	4d1b      	ldr	r5, [pc, #108]	; (36720 <am_hal_pwrctrl_low_power_init+0x17c>)
   366b4:	f3c2 4285 	ubfx	r2, r2, #18, #6
   366b8:	602a      	str	r2, [r5, #0]
   366ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   366bc:	4a19      	ldr	r2, [pc, #100]	; (36724 <am_hal_pwrctrl_low_power_init+0x180>)
   366be:	f3c3 13c6 	ubfx	r3, r3, #7, #7
   366c2:	6013      	str	r3, [r2, #0]
   366c4:	2301      	movs	r3, #1
   366c6:	7023      	strb	r3, [r4, #0]
   366c8:	e7c8      	b.n	3665c <am_hal_pwrctrl_low_power_init+0xb8>
   366ca:	079a      	lsls	r2, r3, #30
   366cc:	d404      	bmi.n	366d8 <am_hal_pwrctrl_low_power_init+0x134>
   366ce:	2306      	movs	r3, #6
   366d0:	2000      	movs	r0, #0
   366d2:	6023      	str	r3, [r4, #0]
   366d4:	b003      	add	sp, #12
   366d6:	bd30      	pop	{r4, r5, pc}
   366d8:	075b      	lsls	r3, r3, #29
   366da:	bf54      	ite	pl
   366dc:	2309      	movpl	r3, #9
   366de:	6020      	strmi	r0, [r4, #0]
   366e0:	f04f 0000 	mov.w	r0, #0
   366e4:	bf58      	it	pl
   366e6:	6023      	strpl	r3, [r4, #0]
   366e8:	b003      	add	sp, #12
   366ea:	bd30      	pop	{r4, r5, pc}
   366ec:	40021000 	.word	0x40021000
   366f0:	10010c54 	.word	0x10010c54
   366f4:	00046a3c 	.word	0x00046a3c
   366f8:	00046a44 	.word	0x00046a44
   366fc:	000467e0 	.word	0x000467e0
   36700:	40020000 	.word	0x40020000
   36704:	10010c55 	.word	0x10010c55
   36708:	10010c60 	.word	0x10010c60
   3670c:	10010c68 	.word	0x10010c68
   36710:	10010c5c 	.word	0x10010c5c
   36714:	10010c58 	.word	0x10010c58
   36718:	10010c78 	.word	0x10010c78
   3671c:	10010c64 	.word	0x10010c64
   36720:	10010c6c 	.word	0x10010c6c
   36724:	10010c70 	.word	0x10010c70

00036728 <buck_ldo_update_override>:
   36728:	4b06      	ldr	r3, [pc, #24]	; (36744 <buck_ldo_update_override+0x1c>)
   3672a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   3672c:	f360 4210 	bfi	r2, r0, #16, #1
   36730:	661a      	str	r2, [r3, #96]	; 0x60
   36732:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36734:	f360 0200 	bfi	r2, r0, #0, #1
   36738:	661a      	str	r2, [r3, #96]	; 0x60
   3673a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   3673c:	f360 1245 	bfi	r2, r0, #5, #1
   36740:	661a      	str	r2, [r3, #96]	; 0x60
   36742:	4770      	bx	lr
   36744:	40020000 	.word	0x40020000

00036748 <am_hal_pwrctrl_control>:
   36748:	2804      	cmp	r0, #4
   3674a:	f200 812b 	bhi.w	369a4 <am_hal_pwrctrl_control+0x25c>
   3674e:	e8df f000 	tbb	[pc, r0]
   36752:	8c0b      	.short	0x8c0b
   36754:	a093      	.short	0xa093
   36756:	03          	.byte	0x03
   36757:	00          	.byte	0x00
   36758:	2900      	cmp	r1, #0
   3675a:	f000 8123 	beq.w	369a4 <am_hal_pwrctrl_control+0x25c>
   3675e:	4b92      	ldr	r3, [pc, #584]	; (369a8 <am_hal_pwrctrl_control+0x260>)
   36760:	681b      	ldr	r3, [r3, #0]
   36762:	600b      	str	r3, [r1, #0]
   36764:	2006      	movs	r0, #6
   36766:	4770      	bx	lr
   36768:	b510      	push	{r4, lr}
   3676a:	4c90      	ldr	r4, [pc, #576]	; (369ac <am_hal_pwrctrl_control+0x264>)
   3676c:	6822      	ldr	r2, [r4, #0]
   3676e:	1c51      	adds	r1, r2, #1
   36770:	f000 8093 	beq.w	3689a <am_hal_pwrctrl_control+0x152>
   36774:	2a02      	cmp	r2, #2
   36776:	f240 809e 	bls.w	368b6 <am_hal_pwrctrl_control+0x16e>
   3677a:	4b8d      	ldr	r3, [pc, #564]	; (369b0 <am_hal_pwrctrl_control+0x268>)
   3677c:	4c8d      	ldr	r4, [pc, #564]	; (369b4 <am_hal_pwrctrl_control+0x26c>)
   3677e:	f8d3 1348 	ldr.w	r1, [r3, #840]	; 0x348
   36782:	200a      	movs	r0, #10
   36784:	f360 619d 	bfi	r1, r0, #26, #4
   36788:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
   3678c:	f8d3 1348 	ldr.w	r1, [r3, #840]	; 0x348
   36790:	f360 3150 	bfi	r1, r0, #13, #4
   36794:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
   36798:	f8d3 135c 	ldr.w	r1, [r3, #860]	; 0x35c
   3679c:	f041 7170 	orr.w	r1, r1, #62914560	; 0x3c00000
   367a0:	f8c3 135c 	str.w	r1, [r3, #860]	; 0x35c
   367a4:	f8d3 135c 	ldr.w	r1, [r3, #860]	; 0x35c
   367a8:	f441 51f0 	orr.w	r1, r1, #7680	; 0x1e00
   367ac:	f8c3 135c 	str.w	r1, [r3, #860]	; 0x35c
   367b0:	f8d3 1380 	ldr.w	r1, [r3, #896]	; 0x380
   367b4:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
   367b8:	f8c3 1380 	str.w	r1, [r3, #896]	; 0x380
   367bc:	f8d3 1380 	ldr.w	r1, [r3, #896]	; 0x380
   367c0:	f041 4180 	orr.w	r1, r1, #1073741824	; 0x40000000
   367c4:	f8c3 1380 	str.w	r1, [r3, #896]	; 0x380
   367c8:	f8d3 1370 	ldr.w	r1, [r3, #880]	; 0x370
   367cc:	f3c1 5105 	ubfx	r1, r1, #20, #6
   367d0:	6021      	str	r1, [r4, #0]
   367d2:	f8d3 1370 	ldr.w	r1, [r3, #880]	; 0x370
   367d6:	2007      	movs	r0, #7
   367d8:	f36f 5119 	bfc	r1, #20, #6
   367dc:	2a05      	cmp	r2, #5
   367de:	f8c3 1370 	str.w	r1, [r3, #880]	; 0x370
   367e2:	f8c3 033c 	str.w	r0, [r3, #828]	; 0x33c
   367e6:	d908      	bls.n	367fa <am_hal_pwrctrl_control+0xb2>
   367e8:	220f      	movs	r2, #15
   367ea:	f8c3 233c 	str.w	r2, [r3, #828]	; 0x33c
   367ee:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
   367f2:	f022 0218 	bic.w	r2, r2, #24
   367f6:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
   367fa:	496f      	ldr	r1, [pc, #444]	; (369b8 <am_hal_pwrctrl_control+0x270>)
   367fc:	4b6c      	ldr	r3, [pc, #432]	; (369b0 <am_hal_pwrctrl_control+0x268>)
   367fe:	f8d1 2100 	ldr.w	r2, [r1, #256]	; 0x100
   36802:	f042 0201 	orr.w	r2, r2, #1
   36806:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
   3680a:	f8d3 2378 	ldr.w	r2, [r3, #888]	; 0x378
   3680e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   36812:	f8c3 2378 	str.w	r2, [r3, #888]	; 0x378
   36816:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36818:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
   3681c:	661a      	str	r2, [r3, #96]	; 0x60
   3681e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36820:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
   36824:	661a      	str	r2, [r3, #96]	; 0x60
   36826:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36828:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
   3682c:	661a      	str	r2, [r3, #96]	; 0x60
   3682e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36830:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   36834:	661a      	str	r2, [r3, #96]	; 0x60
   36836:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36838:	f36f 1204 	bfc	r2, #4, #1
   3683c:	661a      	str	r2, [r3, #96]	; 0x60
   3683e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36840:	f042 020e 	orr.w	r2, r2, #14
   36844:	661a      	str	r2, [r3, #96]	; 0x60
   36846:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36848:	f042 0201 	orr.w	r2, r2, #1
   3684c:	661a      	str	r2, [r3, #96]	; 0x60
   3684e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36850:	f36f 2249 	bfc	r2, #9, #1
   36854:	661a      	str	r2, [r3, #96]	; 0x60
   36856:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36858:	f442 72e0 	orr.w	r2, r2, #448	; 0x1c0
   3685c:	661a      	str	r2, [r3, #96]	; 0x60
   3685e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
   36860:	f042 0220 	orr.w	r2, r2, #32
   36864:	661a      	str	r2, [r3, #96]	; 0x60
   36866:	2000      	movs	r0, #0
   36868:	bd10      	pop	{r4, pc}
   3686a:	4b53      	ldr	r3, [pc, #332]	; (369b8 <am_hal_pwrctrl_control+0x270>)
   3686c:	6898      	ldr	r0, [r3, #8]
   3686e:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
   36872:	f040 8094 	bne.w	3699e <am_hal_pwrctrl_control+0x256>
   36876:	4770      	bx	lr
   36878:	4b4d      	ldr	r3, [pc, #308]	; (369b0 <am_hal_pwrctrl_control+0x268>)
   3687a:	f8d3 2124 	ldr.w	r2, [r3, #292]	; 0x124
   3687e:	2020      	movs	r0, #32
   36880:	f360 0287 	bfi	r2, r0, #2, #6
   36884:	2101      	movs	r1, #1
   36886:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
   3688a:	2000      	movs	r0, #0
   3688c:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   36890:	4770      	bx	lr
   36892:	4b49      	ldr	r3, [pc, #292]	; (369b8 <am_hal_pwrctrl_control+0x270>)
   36894:	2000      	movs	r0, #0
   36896:	6058      	str	r0, [r3, #4]
   36898:	4770      	bx	lr
   3689a:	2201      	movs	r2, #1
   3689c:	4623      	mov	r3, r4
   3689e:	f240 41c4 	movw	r1, #1220	; 0x4c4
   368a2:	4610      	mov	r0, r2
   368a4:	f7fe fa34 	bl	34d10 <am_hal_mram_info_read>
   368a8:	b918      	cbnz	r0, 368b2 <am_hal_pwrctrl_control+0x16a>
   368aa:	6822      	ldr	r2, [r4, #0]
   368ac:	1c53      	adds	r3, r2, #1
   368ae:	f47f af61 	bne.w	36774 <am_hal_pwrctrl_control+0x2c>
   368b2:	2300      	movs	r3, #0
   368b4:	6023      	str	r3, [r4, #0]
   368b6:	4b3e      	ldr	r3, [pc, #248]	; (369b0 <am_hal_pwrctrl_control+0x268>)
   368b8:	483e      	ldr	r0, [pc, #248]	; (369b4 <am_hal_pwrctrl_control+0x26c>)
   368ba:	f8d3 1378 	ldr.w	r1, [r3, #888]	; 0x378
   368be:	f36f 611c 	bfc	r1, #24, #5
   368c2:	f8c3 1378 	str.w	r1, [r3, #888]	; 0x378
   368c6:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   368ca:	f36f 4196 	bfc	r1, #18, #5
   368ce:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   368d2:	f8d3 1344 	ldr.w	r1, [r3, #836]	; 0x344
   368d6:	220a      	movs	r2, #10
   368d8:	f362 611c 	bfi	r1, r2, #24, #5
   368dc:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
   368e0:	f8d3 1344 	ldr.w	r1, [r3, #836]	; 0x344
   368e4:	f362 21ce 	bfi	r1, r2, #11, #4
   368e8:	f8c3 1344 	str.w	r1, [r3, #836]	; 0x344
   368ec:	f8d3 1358 	ldr.w	r1, [r3, #856]	; 0x358
   368f0:	240f      	movs	r4, #15
   368f2:	f364 210c 	bfi	r1, r4, #8, #5
   368f6:	f8c3 1358 	str.w	r1, [r3, #856]	; 0x358
   368fa:	f8d3 1354 	ldr.w	r1, [r3, #852]	; 0x354
   368fe:	f441 11f0 	orr.w	r1, r1, #1966080	; 0x1e0000
   36902:	f8c3 1354 	str.w	r1, [r3, #852]	; 0x354
   36906:	f8d3 1360 	ldr.w	r1, [r3, #864]	; 0x360
   3690a:	f364 519a 	bfi	r1, r4, #22, #5
   3690e:	f8c3 1360 	str.w	r1, [r3, #864]	; 0x360
   36912:	f8d3 1360 	ldr.w	r1, [r3, #864]	; 0x360
   36916:	f441 11f0 	orr.w	r1, r1, #1966080	; 0x1e0000
   3691a:	f8c3 1360 	str.w	r1, [r3, #864]	; 0x360
   3691e:	f8d3 1348 	ldr.w	r1, [r3, #840]	; 0x348
   36922:	f362 619d 	bfi	r1, r2, #26, #4
   36926:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
   3692a:	f8d3 1348 	ldr.w	r1, [r3, #840]	; 0x348
   3692e:	f362 3150 	bfi	r1, r2, #13, #4
   36932:	f8c3 1348 	str.w	r1, [r3, #840]	; 0x348
   36936:	f8d3 235c 	ldr.w	r2, [r3, #860]	; 0x35c
   3693a:	f042 7270 	orr.w	r2, r2, #62914560	; 0x3c00000
   3693e:	f8c3 235c 	str.w	r2, [r3, #860]	; 0x35c
   36942:	f8d3 235c 	ldr.w	r2, [r3, #860]	; 0x35c
   36946:	f442 52f0 	orr.w	r2, r2, #7680	; 0x1e00
   3694a:	f8c3 235c 	str.w	r2, [r3, #860]	; 0x35c
   3694e:	f8d3 2380 	ldr.w	r2, [r3, #896]	; 0x380
   36952:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
   36956:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380
   3695a:	f8d3 2380 	ldr.w	r2, [r3, #896]	; 0x380
   3695e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
   36962:	f8c3 2380 	str.w	r2, [r3, #896]	; 0x380
   36966:	f8d3 2370 	ldr.w	r2, [r3, #880]	; 0x370
   3696a:	f3c2 5205 	ubfx	r2, r2, #20, #6
   3696e:	6002      	str	r2, [r0, #0]
   36970:	f8d3 2370 	ldr.w	r2, [r3, #880]	; 0x370
   36974:	2407      	movs	r4, #7
   36976:	f36f 5219 	bfc	r2, #20, #6
   3697a:	f8c3 2370 	str.w	r2, [r3, #880]	; 0x370
   3697e:	f8c3 433c 	str.w	r4, [r3, #828]	; 0x33c
   36982:	f8d3 2340 	ldr.w	r2, [r3, #832]	; 0x340
   36986:	f36f 5299 	bfc	r2, #22, #4
   3698a:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
   3698e:	f8d3 2340 	ldr.w	r2, [r3, #832]	; 0x340
   36992:	2101      	movs	r1, #1
   36994:	f361 128a 	bfi	r2, r1, #6, #5
   36998:	f8c3 2340 	str.w	r2, [r3, #832]	; 0x340
   3699c:	e72d      	b.n	367fa <am_hal_pwrctrl_control+0xb2>
   3699e:	2014      	movs	r0, #20
   369a0:	f7ff bd3e 	b.w	36420 <am_hal_pwrctrl_periph_disable>
   369a4:	2006      	movs	r0, #6
   369a6:	4770      	bx	lr
   369a8:	10010c74 	.word	0x10010c74
   369ac:	10003840 	.word	0x10003840
   369b0:	40020000 	.word	0x40020000
   369b4:	10003844 	.word	0x10003844
   369b8:	40021000 	.word	0x40021000

000369bc <am_hal_crc32>:
   369bc:	b33a      	cbz	r2, 36a0e <am_hal_crc32+0x52>
   369be:	b538      	push	{r3, r4, r5, lr}
   369c0:	f011 0503 	ands.w	r5, r1, #3
   369c4:	d121      	bne.n	36a0a <am_hal_crc32+0x4e>
   369c6:	4b13      	ldr	r3, [pc, #76]	; (36a14 <am_hal_crc32+0x58>)
   369c8:	4614      	mov	r4, r2
   369ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   369ce:	631a      	str	r2, [r3, #48]	; 0x30
   369d0:	6118      	str	r0, [r3, #16]
   369d2:	6219      	str	r1, [r3, #32]
   369d4:	681a      	ldr	r2, [r3, #0]
   369d6:	4408      	add	r0, r1
   369d8:	490f      	ldr	r1, [pc, #60]	; (36a18 <am_hal_crc32+0x5c>)
   369da:	f365 1207 	bfi	r2, r5, #4, #4
   369de:	4288      	cmp	r0, r1
   369e0:	601a      	str	r2, [r3, #0]
   369e2:	d80d      	bhi.n	36a00 <am_hal_crc32+0x44>
   369e4:	4d0b      	ldr	r5, [pc, #44]	; (36a14 <am_hal_crc32+0x58>)
   369e6:	480d      	ldr	r0, [pc, #52]	; (36a1c <am_hal_crc32+0x60>)
   369e8:	6829      	ldr	r1, [r5, #0]
   369ea:	2201      	movs	r2, #1
   369ec:	4311      	orrs	r1, r2
   369ee:	6029      	str	r1, [r5, #0]
   369f0:	2300      	movs	r3, #0
   369f2:	4629      	mov	r1, r5
   369f4:	f7fe fc80 	bl	352f8 <am_hal_delay_us_status_change>
   369f8:	b908      	cbnz	r0, 369fe <am_hal_crc32+0x42>
   369fa:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   369fc:	6023      	str	r3, [r4, #0]
   369fe:	bd38      	pop	{r3, r4, r5, pc}
   36a00:	4629      	mov	r1, r5
   36a02:	2001      	movs	r0, #1
   36a04:	f7fd f97e 	bl	33d04 <am_hal_daxi_control>
   36a08:	e7ec      	b.n	369e4 <am_hal_crc32+0x28>
   36a0a:	2006      	movs	r0, #6
   36a0c:	bd38      	pop	{r3, r4, r5, pc}
   36a0e:	2006      	movs	r0, #6
   36a10:	4770      	bx	lr
   36a12:	bf00      	nop
   36a14:	40030000 	.word	0x40030000
   36a18:	1005ffff 	.word	0x1005ffff
   36a1c:	000186a0 	.word	0x000186a0

00036a20 <am_hal_stimer_config>:
   36a20:	4a04      	ldr	r2, [pc, #16]	; (36a34 <am_hal_stimer_config+0x14>)
   36a22:	4905      	ldr	r1, [pc, #20]	; (36a38 <am_hal_stimer_config+0x18>)
   36a24:	4603      	mov	r3, r0
   36a26:	f04f 0c01 	mov.w	ip, #1
   36a2a:	6810      	ldr	r0, [r2, #0]
   36a2c:	6013      	str	r3, [r2, #0]
   36a2e:	f881 c000 	strb.w	ip, [r1]
   36a32:	4770      	bx	lr
   36a34:	40008800 	.word	0x40008800
   36a38:	10010c7c 	.word	0x10010c7c

00036a3c <am_hal_stimer_counter_get>:
   36a3c:	b500      	push	{lr}
   36a3e:	b085      	sub	sp, #20
   36a40:	4805      	ldr	r0, [pc, #20]	; (36a58 <am_hal_stimer_counter_get+0x1c>)
   36a42:	a901      	add	r1, sp, #4
   36a44:	f000 fa12 	bl	36e6c <am_hal_triple_read>
   36a48:	e9dd 3001 	ldrd	r3, r0, [sp, #4]
   36a4c:	4283      	cmp	r3, r0
   36a4e:	bf18      	it	ne
   36a50:	9803      	ldrne	r0, [sp, #12]
   36a52:	b005      	add	sp, #20
   36a54:	f85d fb04 	ldr.w	pc, [sp], #4
   36a58:	40008804 	.word	0x40008804

00036a5c <am_hal_stimer_compare_delta_set>:
   36a5c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   36a60:	b085      	sub	sp, #20
   36a62:	4604      	mov	r4, r0
   36a64:	460d      	mov	r5, r1
   36a66:	4831      	ldr	r0, [pc, #196]	; (36b2c <am_hal_stimer_compare_delta_set+0xd0>)
   36a68:	a901      	add	r1, sp, #4
   36a6a:	f000 f9ff 	bl	36e6c <am_hal_triple_read>
   36a6e:	e9dd 3601 	ldrd	r3, r6, [sp, #4]
   36a72:	42b3      	cmp	r3, r6
   36a74:	bf18      	it	ne
   36a76:	9e03      	ldrne	r6, [sp, #12]
   36a78:	2c07      	cmp	r4, #7
   36a7a:	d852      	bhi.n	36b22 <am_hal_stimer_compare_delta_set+0xc6>
   36a7c:	4a2c      	ldr	r2, [pc, #176]	; (36b30 <am_hal_stimer_compare_delta_set+0xd4>)
   36a7e:	f8df 80b8 	ldr.w	r8, [pc, #184]	; 36b38 <am_hal_stimer_compare_delta_set+0xdc>
   36a82:	6817      	ldr	r7, [r2, #0]
   36a84:	6811      	ldr	r1, [r2, #0]
   36a86:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 36b2c <am_hal_stimer_compare_delta_set+0xd0>
   36a8a:	f44f 7380 	mov.w	r3, #256	; 0x100
   36a8e:	40a3      	lsls	r3, r4
   36a90:	401f      	ands	r7, r3
   36a92:	ea21 0303 	bic.w	r3, r1, r3
   36a96:	6013      	str	r3, [r2, #0]
   36a98:	4633      	mov	r3, r6
   36a9a:	f858 2024 	ldr.w	r2, [r8, r4, lsl #2]
   36a9e:	429a      	cmp	r2, r3
   36aa0:	a901      	add	r1, sp, #4
   36aa2:	4648      	mov	r0, r9
   36aa4:	f102 0c01 	add.w	ip, r2, #1
   36aa8:	d001      	beq.n	36aae <am_hal_stimer_compare_delta_set+0x52>
   36aaa:	459c      	cmp	ip, r3
   36aac:	d107      	bne.n	36abe <am_hal_stimer_compare_delta_set+0x62>
   36aae:	f000 f9dd 	bl	36e6c <am_hal_triple_read>
   36ab2:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   36ab6:	429a      	cmp	r2, r3
   36ab8:	d0ef      	beq.n	36a9a <am_hal_stimer_compare_delta_set+0x3e>
   36aba:	9b03      	ldr	r3, [sp, #12]
   36abc:	e7ed      	b.n	36a9a <am_hal_stimer_compare_delta_set+0x3e>
   36abe:	f7fd f99d 	bl	33dfc <am_hal_interrupt_master_disable>
   36ac2:	a901      	add	r1, sp, #4
   36ac4:	9000      	str	r0, [sp, #0]
   36ac6:	4819      	ldr	r0, [pc, #100]	; (36b2c <am_hal_stimer_compare_delta_set+0xd0>)
   36ac8:	f000 f9d0 	bl	36e6c <am_hal_triple_read>
   36acc:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   36ad0:	429a      	cmp	r2, r3
   36ad2:	bf18      	it	ne
   36ad4:	9b03      	ldrne	r3, [sp, #12]
   36ad6:	f1c6 0203 	rsb	r2, r6, #3
   36ada:	441a      	add	r2, r3
   36adc:	42aa      	cmp	r2, r5
   36ade:	d31b      	bcc.n	36b18 <am_hal_stimer_compare_delta_set+0xbc>
   36ae0:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   36ae4:	2601      	movs	r6, #1
   36ae6:	4b13      	ldr	r3, [pc, #76]	; (36b34 <am_hal_stimer_compare_delta_set+0xd8>)
   36ae8:	4a11      	ldr	r2, [pc, #68]	; (36b30 <am_hal_stimer_compare_delta_set+0xd4>)
   36aea:	f843 6024 	str.w	r6, [r3, r4, lsl #2]
   36aee:	6813      	ldr	r3, [r2, #0]
   36af0:	480e      	ldr	r0, [pc, #56]	; (36b2c <am_hal_stimer_compare_delta_set+0xd0>)
   36af2:	431f      	orrs	r7, r3
   36af4:	a901      	add	r1, sp, #4
   36af6:	6017      	str	r7, [r2, #0]
   36af8:	f000 f9b8 	bl	36e6c <am_hal_triple_read>
   36afc:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
   36b00:	429a      	cmp	r2, r3
   36b02:	bf18      	it	ne
   36b04:	9b03      	ldrne	r3, [sp, #12]
   36b06:	9800      	ldr	r0, [sp, #0]
   36b08:	f848 3024 	str.w	r3, [r8, r4, lsl #2]
   36b0c:	f7fd f97a 	bl	33e04 <am_hal_interrupt_master_set>
   36b10:	4628      	mov	r0, r5
   36b12:	b005      	add	sp, #20
   36b14:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   36b18:	3d03      	subs	r5, #3
   36b1a:	442e      	add	r6, r5
   36b1c:	1af6      	subs	r6, r6, r3
   36b1e:	2500      	movs	r5, #0
   36b20:	e7e1      	b.n	36ae6 <am_hal_stimer_compare_delta_set+0x8a>
   36b22:	2505      	movs	r5, #5
   36b24:	4628      	mov	r0, r5
   36b26:	b005      	add	sp, #20
   36b28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   36b2c:	40008804 	.word	0x40008804
   36b30:	40008800 	.word	0x40008800
   36b34:	40008820 	.word	0x40008820
   36b38:	10003848 	.word	0x10003848

00036b3c <am_hal_stimer_int_enable>:
   36b3c:	4a03      	ldr	r2, [pc, #12]	; (36b4c <am_hal_stimer_int_enable+0x10>)
   36b3e:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
   36b42:	4318      	orrs	r0, r3
   36b44:	f8c2 0100 	str.w	r0, [r2, #256]	; 0x100
   36b48:	4770      	bx	lr
   36b4a:	bf00      	nop
   36b4c:	40008800 	.word	0x40008800

00036b50 <am_hal_stimer_int_clear>:
   36b50:	4b01      	ldr	r3, [pc, #4]	; (36b58 <am_hal_stimer_int_clear+0x8>)
   36b52:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
   36b56:	4770      	bx	lr
   36b58:	40008800 	.word	0x40008800

00036b5c <am_hal_stimer_int_status_get>:
   36b5c:	4a04      	ldr	r2, [pc, #16]	; (36b70 <am_hal_stimer_int_status_get+0x14>)
   36b5e:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
   36b62:	b110      	cbz	r0, 36b6a <am_hal_stimer_int_status_get+0xe>
   36b64:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
   36b68:	4013      	ands	r3, r2
   36b6a:	4618      	mov	r0, r3
   36b6c:	4770      	bx	lr
   36b6e:	bf00      	nop
   36b70:	40008800 	.word	0x40008800

00036b74 <am_hal_timer_config>:
   36b74:	b470      	push	{r4, r5, r6}
   36b76:	f891 c001 	ldrb.w	ip, [r1, #1]
   36b7a:	690c      	ldr	r4, [r1, #16]
   36b7c:	f10c 33ff 	add.w	r3, ip, #4294967295	; 0xffffffff
   36b80:	e9d1 6502 	ldrd	r6, r5, [r1, #8]
   36b84:	2b0c      	cmp	r3, #12
   36b86:	d80a      	bhi.n	36b9e <am_hal_timer_config+0x2a>
   36b88:	e8df f003 	tbb	[pc, r3]
   36b8c:	1009100c 	.word	0x1009100c
   36b90:	09090909 	.word	0x09090909
   36b94:	07090909 	.word	0x07090909
   36b98:	07          	.byte	0x07
   36b99:	00          	.byte	0x00
   36b9a:	2e3f      	cmp	r6, #63	; 0x3f
   36b9c:	d906      	bls.n	36bac <am_hal_timer_config+0x38>
   36b9e:	2007      	movs	r0, #7
   36ba0:	bc70      	pop	{r4, r5, r6}
   36ba2:	4770      	bx	lr
   36ba4:	1c63      	adds	r3, r4, #1
   36ba6:	d001      	beq.n	36bac <am_hal_timer_config+0x38>
   36ba8:	42a5      	cmp	r5, r4
   36baa:	d9f8      	bls.n	36b9e <am_hal_timer_config+0x2a>
   36bac:	78ca      	ldrb	r2, [r1, #3]
   36bae:	f100 7300 	add.w	r3, r0, #33554432	; 0x2000000
   36bb2:	7808      	ldrb	r0, [r1, #0]
   36bb4:	00d2      	lsls	r2, r2, #3
   36bb6:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
   36bba:	7888      	ldrb	r0, [r1, #2]
   36bbc:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
   36bc0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   36bc4:	015b      	lsls	r3, r3, #5
   36bc6:	ea42 0280 	orr.w	r2, r2, r0, lsl #2
   36bca:	7908      	ldrb	r0, [r1, #4]
   36bcc:	794e      	ldrb	r6, [r1, #5]
   36bce:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
   36bd2:	0401      	lsls	r1, r0, #16
   36bd4:	fa5f fc8c 	uxtb.w	ip, ip
   36bd8:	f8d3 0200 	ldr.w	r0, [r3, #512]	; 0x200
   36bdc:	ea42 020c 	orr.w	r2, r2, ip
   36be0:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
   36be4:	430a      	orrs	r2, r1
   36be6:	0236      	lsls	r6, r6, #8
   36be8:	f36f 0000 	bfc	r0, #0, #1
   36bec:	f8c3 0200 	str.w	r0, [r3, #512]	; 0x200
   36bf0:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36bf4:	f8c3 6210 	str.w	r6, [r3, #528]	; 0x210
   36bf8:	f8c3 5208 	str.w	r5, [r3, #520]	; 0x208
   36bfc:	f8c3 420c 	str.w	r4, [r3, #524]	; 0x20c
   36c00:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c04:	f042 0202 	orr.w	r2, r2, #2
   36c08:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c0c:	2000      	movs	r0, #0
   36c0e:	bc70      	pop	{r4, r5, r6}
   36c10:	4770      	bx	lr
   36c12:	bf00      	nop

00036c14 <am_hal_timer_disable>:
   36c14:	b510      	push	{r4, lr}
   36c16:	4604      	mov	r4, r0
   36c18:	b082      	sub	sp, #8
   36c1a:	f7fd f8ef 	bl	33dfc <am_hal_interrupt_master_disable>
   36c1e:	f104 7300 	add.w	r3, r4, #33554432	; 0x2000000
   36c22:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   36c26:	015b      	lsls	r3, r3, #5
   36c28:	9001      	str	r0, [sp, #4]
   36c2a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c2e:	f36f 0200 	bfc	r2, #0, #1
   36c32:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c36:	9801      	ldr	r0, [sp, #4]
   36c38:	f7fd f8e4 	bl	33e04 <am_hal_interrupt_master_set>
   36c3c:	2000      	movs	r0, #0
   36c3e:	b002      	add	sp, #8
   36c40:	bd10      	pop	{r4, pc}
   36c42:	bf00      	nop

00036c44 <am_hal_timer_clear>:
   36c44:	b510      	push	{r4, lr}
   36c46:	4604      	mov	r4, r0
   36c48:	b082      	sub	sp, #8
   36c4a:	f7fd f8d7 	bl	33dfc <am_hal_interrupt_master_disable>
   36c4e:	f104 7300 	add.w	r3, r4, #33554432	; 0x2000000
   36c52:	f503 6380 	add.w	r3, r3, #1024	; 0x400
   36c56:	015b      	lsls	r3, r3, #5
   36c58:	9001      	str	r0, [sp, #4]
   36c5a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c5e:	f36f 0200 	bfc	r2, #0, #1
   36c62:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c66:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c6a:	f042 0202 	orr.w	r2, r2, #2
   36c6e:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c72:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c76:	f36f 0241 	bfc	r2, #1, #1
   36c7a:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c7e:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
   36c82:	f042 0201 	orr.w	r2, r2, #1
   36c86:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
   36c8a:	9801      	ldr	r0, [sp, #4]
   36c8c:	f7fd f8ba 	bl	33e04 <am_hal_interrupt_master_set>
   36c90:	2000      	movs	r0, #0
   36c92:	b002      	add	sp, #8
   36c94:	bd10      	pop	{r4, pc}
   36c96:	bf00      	nop

00036c98 <am_hal_timer_interrupt_clear>:
   36c98:	4b01      	ldr	r3, [pc, #4]	; (36ca0 <am_hal_timer_interrupt_clear+0x8>)
   36c9a:	6698      	str	r0, [r3, #104]	; 0x68
   36c9c:	2000      	movs	r0, #0
   36c9e:	4770      	bx	lr
   36ca0:	40008000 	.word	0x40008000

00036ca4 <am_hal_cmdq_init>:
   36ca4:	280a      	cmp	r0, #10
   36ca6:	d849      	bhi.n	36d3c <am_hal_cmdq_init+0x98>
   36ca8:	2900      	cmp	r1, #0
   36caa:	d04b      	beq.n	36d44 <am_hal_cmdq_init+0xa0>
   36cac:	b5f0      	push	{r4, r5, r6, r7, lr}
   36cae:	684e      	ldr	r6, [r1, #4]
   36cb0:	2e00      	cmp	r6, #0
   36cb2:	d041      	beq.n	36d38 <am_hal_cmdq_init+0x94>
   36cb4:	2a00      	cmp	r2, #0
   36cb6:	d03f      	beq.n	36d38 <am_hal_cmdq_init+0x94>
   36cb8:	680c      	ldr	r4, [r1, #0]
   36cba:	2c01      	cmp	r4, #1
   36cbc:	d93c      	bls.n	36d38 <am_hal_cmdq_init+0x94>
   36cbe:	4f22      	ldr	r7, [pc, #136]	; (36d48 <am_hal_cmdq_init+0xa4>)
   36cc0:	f04f 0e2c 	mov.w	lr, #44	; 0x2c
   36cc4:	fb0e fe00 	mul.w	lr, lr, r0
   36cc8:	eb07 030e 	add.w	r3, r7, lr
   36ccc:	78dd      	ldrb	r5, [r3, #3]
   36cce:	f015 0501 	ands.w	r5, r5, #1
   36cd2:	d135      	bne.n	36d40 <am_hal_cmdq_init+0x9c>
   36cd4:	00e4      	lsls	r4, r4, #3
   36cd6:	619c      	str	r4, [r3, #24]
   36cd8:	4434      	add	r4, r6
   36cda:	e9c3 6401 	strd	r6, r4, [r3, #4]
   36cde:	e9c3 6604 	strd	r6, r6, [r3, #16]
   36ce2:	60de      	str	r6, [r3, #12]
   36ce4:	eb00 0c80 	add.w	ip, r0, r0, lsl #2
   36ce8:	4818      	ldr	r0, [pc, #96]	; (36d4c <am_hal_cmdq_init+0xa8>)
   36cea:	f857 400e 	ldr.w	r4, [r7, lr]
   36cee:	eb00 00cc 	add.w	r0, r0, ip, lsl #3
   36cf2:	f8df c05c 	ldr.w	ip, [pc, #92]	; 36d50 <am_hal_cmdq_init+0xac>
   36cf6:	f004 447c 	and.w	r4, r4, #4227858432	; 0xfc000000
   36cfa:	ea44 040c 	orr.w	r4, r4, ip
   36cfe:	f847 400e 	str.w	r4, [r7, lr]
   36d02:	6258      	str	r0, [r3, #36]	; 0x24
   36d04:	6880      	ldr	r0, [r0, #8]
   36d06:	e9c3 5507 	strd	r5, r5, [r3, #28]
   36d0a:	6005      	str	r5, [r0, #0]
   36d0c:	6a58      	ldr	r0, [r3, #36]	; 0x24
   36d0e:	68c0      	ldr	r0, [r0, #12]
   36d10:	6005      	str	r5, [r0, #0]
   36d12:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   36d14:	4628      	mov	r0, r5
   36d16:	e9d4 5704 	ldrd	r5, r7, [r4, #16]
   36d1a:	682c      	ldr	r4, [r5, #0]
   36d1c:	433c      	orrs	r4, r7
   36d1e:	602c      	str	r4, [r5, #0]
   36d20:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   36d22:	6864      	ldr	r4, [r4, #4]
   36d24:	6026      	str	r6, [r4, #0]
   36d26:	6a5c      	ldr	r4, [r3, #36]	; 0x24
   36d28:	7a09      	ldrb	r1, [r1, #8]
   36d2a:	6824      	ldr	r4, [r4, #0]
   36d2c:	0049      	lsls	r1, r1, #1
   36d2e:	f001 0102 	and.w	r1, r1, #2
   36d32:	6021      	str	r1, [r4, #0]
   36d34:	6013      	str	r3, [r2, #0]
   36d36:	bdf0      	pop	{r4, r5, r6, r7, pc}
   36d38:	2006      	movs	r0, #6
   36d3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   36d3c:	2005      	movs	r0, #5
   36d3e:	4770      	bx	lr
   36d40:	2007      	movs	r0, #7
   36d42:	bdf0      	pop	{r4, r5, r6, r7, pc}
   36d44:	2006      	movs	r0, #6
   36d46:	4770      	bx	lr
   36d48:	10010c80 	.word	0x10010c80
   36d4c:	00046a74 	.word	0x00046a74
   36d50:	01cdcdcd 	.word	0x01cdcdcd

00036d54 <am_hal_cmdq_enable>:
   36d54:	b318      	cbz	r0, 36d9e <am_hal_cmdq_enable+0x4a>
   36d56:	6803      	ldr	r3, [r0, #0]
   36d58:	4a12      	ldr	r2, [pc, #72]	; (36da4 <am_hal_cmdq_enable+0x50>)
   36d5a:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   36d5e:	4293      	cmp	r3, r2
   36d60:	b510      	push	{r4, lr}
   36d62:	4604      	mov	r4, r0
   36d64:	d113      	bne.n	36d8e <am_hal_cmdq_enable+0x3a>
   36d66:	78c1      	ldrb	r1, [r0, #3]
   36d68:	f011 0102 	ands.w	r1, r1, #2
   36d6c:	d111      	bne.n	36d92 <am_hal_cmdq_enable+0x3e>
   36d6e:	4b0e      	ldr	r3, [pc, #56]	; (36da8 <am_hal_cmdq_enable+0x54>)
   36d70:	6882      	ldr	r2, [r0, #8]
   36d72:	429a      	cmp	r2, r3
   36d74:	d80f      	bhi.n	36d96 <am_hal_cmdq_enable+0x42>
   36d76:	6a63      	ldr	r3, [r4, #36]	; 0x24
   36d78:	681a      	ldr	r2, [r3, #0]
   36d7a:	6813      	ldr	r3, [r2, #0]
   36d7c:	f043 0301 	orr.w	r3, r3, #1
   36d80:	6013      	str	r3, [r2, #0]
   36d82:	78e3      	ldrb	r3, [r4, #3]
   36d84:	f043 0302 	orr.w	r3, r3, #2
   36d88:	2000      	movs	r0, #0
   36d8a:	70e3      	strb	r3, [r4, #3]
   36d8c:	bd10      	pop	{r4, pc}
   36d8e:	2002      	movs	r0, #2
   36d90:	bd10      	pop	{r4, pc}
   36d92:	2000      	movs	r0, #0
   36d94:	bd10      	pop	{r4, pc}
   36d96:	2001      	movs	r0, #1
   36d98:	f7fc ffb4 	bl	33d04 <am_hal_daxi_control>
   36d9c:	e7eb      	b.n	36d76 <am_hal_cmdq_enable+0x22>
   36d9e:	2002      	movs	r0, #2
   36da0:	4770      	bx	lr
   36da2:	bf00      	nop
   36da4:	01cdcdcd 	.word	0x01cdcdcd
   36da8:	1005ffff 	.word	0x1005ffff

00036dac <am_hal_cmdq_disable>:
   36dac:	4603      	mov	r3, r0
   36dae:	b1a8      	cbz	r0, 36ddc <am_hal_cmdq_disable+0x30>
   36db0:	6802      	ldr	r2, [r0, #0]
   36db2:	490b      	ldr	r1, [pc, #44]	; (36de0 <am_hal_cmdq_disable+0x34>)
   36db4:	f022 427e 	bic.w	r2, r2, #4261412864	; 0xfe000000
   36db8:	428a      	cmp	r2, r1
   36dba:	d10f      	bne.n	36ddc <am_hal_cmdq_disable+0x30>
   36dbc:	78c0      	ldrb	r0, [r0, #3]
   36dbe:	f010 0002 	ands.w	r0, r0, #2
   36dc2:	d00c      	beq.n	36dde <am_hal_cmdq_disable+0x32>
   36dc4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
   36dc6:	6811      	ldr	r1, [r2, #0]
   36dc8:	680a      	ldr	r2, [r1, #0]
   36dca:	f022 0201 	bic.w	r2, r2, #1
   36dce:	600a      	str	r2, [r1, #0]
   36dd0:	78da      	ldrb	r2, [r3, #3]
   36dd2:	f36f 0241 	bfc	r2, #1, #1
   36dd6:	2000      	movs	r0, #0
   36dd8:	70da      	strb	r2, [r3, #3]
   36dda:	4770      	bx	lr
   36ddc:	2002      	movs	r0, #2
   36dde:	4770      	bx	lr
   36de0:	01cdcdcd 	.word	0x01cdcdcd

00036de4 <am_hal_cmdq_term>:
   36de4:	2800      	cmp	r0, #0
   36de6:	d03d      	beq.n	36e64 <am_hal_cmdq_term+0x80>
   36de8:	b570      	push	{r4, r5, r6, lr}
   36dea:	6803      	ldr	r3, [r0, #0]
   36dec:	4a1e      	ldr	r2, [pc, #120]	; (36e68 <am_hal_cmdq_term+0x84>)
   36dee:	f023 437e 	bic.w	r3, r3, #4261412864	; 0xfe000000
   36df2:	4293      	cmp	r3, r2
   36df4:	b082      	sub	sp, #8
   36df6:	4604      	mov	r4, r0
   36df8:	d002      	beq.n	36e00 <am_hal_cmdq_term+0x1c>
   36dfa:	2002      	movs	r0, #2
   36dfc:	b002      	add	sp, #8
   36dfe:	bd70      	pop	{r4, r5, r6, pc}
   36e00:	460d      	mov	r5, r1
   36e02:	f7fc fffb 	bl	33dfc <am_hal_interrupt_master_disable>
   36e06:	6a66      	ldr	r6, [r4, #36]	; 0x24
   36e08:	9001      	str	r0, [sp, #4]
   36e0a:	68b3      	ldr	r3, [r6, #8]
   36e0c:	6a22      	ldr	r2, [r4, #32]
   36e0e:	6819      	ldr	r1, [r3, #0]
   36e10:	f022 03ff 	bic.w	r3, r2, #255	; 0xff
   36e14:	b2c9      	uxtb	r1, r1
   36e16:	430b      	orrs	r3, r1
   36e18:	1ad2      	subs	r2, r2, r3
   36e1a:	2a00      	cmp	r2, #0
   36e1c:	bfb8      	it	lt
   36e1e:	f5a3 7380 	sublt.w	r3, r3, #256	; 0x100
   36e22:	61e3      	str	r3, [r4, #28]
   36e24:	6873      	ldr	r3, [r6, #4]
   36e26:	681b      	ldr	r3, [r3, #0]
   36e28:	60e3      	str	r3, [r4, #12]
   36e2a:	9801      	ldr	r0, [sp, #4]
   36e2c:	f7fc ffea 	bl	33e04 <am_hal_interrupt_master_set>
   36e30:	b91d      	cbnz	r5, 36e3a <am_hal_cmdq_term+0x56>
   36e32:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
   36e36:	429a      	cmp	r2, r3
   36e38:	d112      	bne.n	36e60 <am_hal_cmdq_term+0x7c>
   36e3a:	6a62      	ldr	r2, [r4, #36]	; 0x24
   36e3c:	78e3      	ldrb	r3, [r4, #3]
   36e3e:	6810      	ldr	r0, [r2, #0]
   36e40:	6911      	ldr	r1, [r2, #16]
   36e42:	f36f 0300 	bfc	r3, #0, #1
   36e46:	70e3      	strb	r3, [r4, #3]
   36e48:	6803      	ldr	r3, [r0, #0]
   36e4a:	f023 0301 	bic.w	r3, r3, #1
   36e4e:	6003      	str	r3, [r0, #0]
   36e50:	680b      	ldr	r3, [r1, #0]
   36e52:	6952      	ldr	r2, [r2, #20]
   36e54:	2000      	movs	r0, #0
   36e56:	ea23 0302 	bic.w	r3, r3, r2
   36e5a:	600b      	str	r3, [r1, #0]
   36e5c:	b002      	add	sp, #8
   36e5e:	bd70      	pop	{r4, r5, r6, pc}
   36e60:	2003      	movs	r0, #3
   36e62:	e7cb      	b.n	36dfc <am_hal_cmdq_term+0x18>
   36e64:	2002      	movs	r0, #2
   36e66:	4770      	bx	lr
   36e68:	01cdcdcd 	.word	0x01cdcdcd

00036e6c <am_hal_triple_read>:
   36e6c:	b412      	push	{r1, r4}
   36e6e:	f3ef 8410 	mrs	r4, PRIMASK
   36e72:	b672      	cpsid	i
   36e74:	6801      	ldr	r1, [r0, #0]
   36e76:	6802      	ldr	r2, [r0, #0]
   36e78:	6803      	ldr	r3, [r0, #0]
   36e7a:	f384 8810 	msr	PRIMASK, r4
   36e7e:	bc11      	pop	{r0, r4}
   36e80:	6001      	str	r1, [r0, #0]
   36e82:	6042      	str	r2, [r0, #4]
   36e84:	6083      	str	r3, [r0, #8]
   36e86:	4770      	bx	lr

00036e88 <interface_tx_frame>:
   36e88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   36e8c:	b085      	sub	sp, #20
   36e8e:	4605      	mov	r5, r0
   36e90:	461c      	mov	r4, r3
   36e92:	6883      	ldr	r3, [r0, #8]
   36e94:	695e      	ldr	r6, [r3, #20]
   36e96:	b1e2      	cbz	r2, 36ed2 <interface_tx_frame+0x4a>
   36e98:	9102      	str	r1, [sp, #8]
   36e9a:	fa1f f882 	uxth.w	r8, r2
   36e9e:	f8ad 800c 	strh.w	r8, [sp, #12]
   36ea2:	f04f 0900 	mov.w	r9, #0
   36ea6:	f8ad 900e 	strh.w	r9, [sp, #14]
   36eaa:	6b77      	ldr	r7, [r6, #52]	; 0x34
   36eac:	ab02      	add	r3, sp, #8
   36eae:	464a      	mov	r2, r9
   36eb0:	2120      	movs	r1, #32
   36eb2:	47b8      	blx	r7
   36eb4:	f8ad 8000 	strh.w	r8, [sp]
   36eb8:	f8ad 9002 	strh.w	r9, [sp, #2]
   36ebc:	68e3      	ldr	r3, [r4, #12]
   36ebe:	f3c3 1380 	ubfx	r3, r3, #6, #1
   36ec2:	f88d 3004 	strb.w	r3, [sp, #4]
   36ec6:	6b77      	ldr	r7, [r6, #52]	; 0x34
   36ec8:	466b      	mov	r3, sp
   36eca:	464a      	mov	r2, r9
   36ecc:	2137      	movs	r1, #55	; 0x37
   36ece:	4628      	mov	r0, r5
   36ed0:	47b8      	blx	r7
   36ed2:	68e3      	ldr	r3, [r4, #12]
   36ed4:	f013 0f1d 	tst.w	r3, #29
   36ed8:	d005      	beq.n	36ee6 <interface_tx_frame+0x5e>
   36eda:	6b77      	ldr	r7, [r6, #52]	; 0x34
   36edc:	4623      	mov	r3, r4
   36ede:	2200      	movs	r2, #0
   36ee0:	2105      	movs	r1, #5
   36ee2:	4628      	mov	r0, r5
   36ee4:	47b8      	blx	r7
   36ee6:	6863      	ldr	r3, [r4, #4]
   36ee8:	2b00      	cmp	r3, #0
   36eea:	db0c      	blt.n	36f06 <interface_tx_frame+0x7e>
   36eec:	6b77      	ldr	r7, [r6, #52]	; 0x34
   36eee:	1d23      	adds	r3, r4, #4
   36ef0:	2200      	movs	r2, #0
   36ef2:	2110      	movs	r1, #16
   36ef4:	4628      	mov	r0, r5
   36ef6:	47b8      	blx	r7
   36ef8:	6b77      	ldr	r7, [r6, #52]	; 0x34
   36efa:	f104 0308 	add.w	r3, r4, #8
   36efe:	2200      	movs	r2, #0
   36f00:	2151      	movs	r1, #81	; 0x51
   36f02:	4628      	mov	r0, r5
   36f04:	47b8      	blx	r7
   36f06:	6b76      	ldr	r6, [r6, #52]	; 0x34
   36f08:	f104 030c 	add.w	r3, r4, #12
   36f0c:	2200      	movs	r2, #0
   36f0e:	2104      	movs	r1, #4
   36f10:	4628      	mov	r0, r5
   36f12:	47b0      	blx	r6
   36f14:	b005      	add	sp, #20
   36f16:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

00036f1a <interface_get_timestamp>:
   36f1a:	b530      	push	{r4, r5, lr}
   36f1c:	b083      	sub	sp, #12
   36f1e:	ab02      	add	r3, sp, #8
   36f20:	2400      	movs	r4, #0
   36f22:	2500      	movs	r5, #0
   36f24:	e963 4502 	strd	r4, r5, [r3, #-8]!
   36f28:	6882      	ldr	r2, [r0, #8]
   36f2a:	6952      	ldr	r2, [r2, #20]
   36f2c:	6b54      	ldr	r4, [r2, #52]	; 0x34
   36f2e:	2200      	movs	r2, #0
   36f30:	215f      	movs	r1, #95	; 0x5f
   36f32:	47a0      	blx	r4
   36f34:	e9dd 0100 	ldrd	r0, r1, [sp]
   36f38:	b003      	add	sp, #12
   36f3a:	bd30      	pop	{r4, r5, pc}

00036f3c <interface_rx_disable>:
   36f3c:	b510      	push	{r4, lr}
   36f3e:	6883      	ldr	r3, [r0, #8]
   36f40:	695b      	ldr	r3, [r3, #20]
   36f42:	6b5c      	ldr	r4, [r3, #52]	; 0x34
   36f44:	2300      	movs	r3, #0
   36f46:	461a      	mov	r2, r3
   36f48:	2103      	movs	r1, #3
   36f4a:	47a0      	blx	r4
   36f4c:	bd10      	pop	{r4, pc}
	...

00036f50 <interface_rx_enable>:
   36f50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   36f54:	b084      	sub	sp, #16
   36f56:	4604      	mov	r4, r0
   36f58:	6883      	ldr	r3, [r0, #8]
   36f5a:	695d      	ldr	r5, [r3, #20]
   36f5c:	f8d1 a008 	ldr.w	sl, [r1, #8]
   36f60:	680b      	ldr	r3, [r1, #0]
   36f62:	9303      	str	r3, [sp, #12]
   36f64:	684a      	ldr	r2, [r1, #4]
   36f66:	ab04      	add	r3, sp, #16
   36f68:	f843 2d08 	str.w	r2, [r3, #-8]!
   36f6c:	6b6f      	ldr	r7, [r5, #52]	; 0x34
   36f6e:	2200      	movs	r2, #0
   36f70:	214f      	movs	r1, #79	; 0x4f
   36f72:	47b8      	blx	r7
   36f74:	4607      	mov	r7, r0
   36f76:	b118      	cbz	r0, 36f80 <interface_rx_enable+0x30>
   36f78:	4638      	mov	r0, r7
   36f7a:	b004      	add	sp, #16
   36f7c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   36f80:	68a3      	ldr	r3, [r4, #8]
   36f82:	695a      	ldr	r2, [r3, #20]
   36f84:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   36f88:	2b00      	cmp	r3, #0
   36f8a:	db3c      	blt.n	37006 <interface_rx_enable+0xb6>
   36f8c:	6b57      	ldr	r7, [r2, #52]	; 0x34
   36f8e:	ab01      	add	r3, sp, #4
   36f90:	2200      	movs	r2, #0
   36f92:	2157      	movs	r1, #87	; 0x57
   36f94:	4620      	mov	r0, r4
   36f96:	47b8      	blx	r7
   36f98:	bba8      	cbnz	r0, 37006 <interface_rx_enable+0xb6>
   36f9a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   36f9e:	f89d 3006 	ldrb.w	r3, [sp, #6]
   36fa2:	041b      	lsls	r3, r3, #16
   36fa4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   36fa8:	f89d 2004 	ldrb.w	r2, [sp, #4]
   36fac:	4313      	orrs	r3, r2
   36fae:	f89d 2005 	ldrb.w	r2, [sp, #5]
   36fb2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   36fb6:	f1ba 0f00 	cmp.w	sl, #0
   36fba:	d131      	bne.n	37020 <interface_rx_enable+0xd0>
   36fbc:	f503 3378 	add.w	r3, r3, #253952	; 0x3e000
   36fc0:	f503 7320 	add.w	r3, r3, #640	; 0x280
   36fc4:	9303      	str	r3, [sp, #12]
   36fc6:	f04f 0a01 	mov.w	sl, #1
   36fca:	68a3      	ldr	r3, [r4, #8]
   36fcc:	695f      	ldr	r7, [r3, #20]
   36fce:	f10d 0302 	add.w	r3, sp, #2
   36fd2:	2200      	movs	r2, #0
   36fd4:	217b      	movs	r1, #123	; 0x7b
   36fd6:	4620      	mov	r0, r4
   36fd8:	6b7e      	ldr	r6, [r7, #52]	; 0x34
   36fda:	47b0      	blx	r6
   36fdc:	f994 304d 	ldrsb.w	r3, [r4, #77]	; 0x4d
   36fe0:	2b01      	cmp	r3, #1
   36fe2:	d04e      	beq.n	37082 <interface_rx_enable+0x132>
   36fe4:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   36fe8:	2201      	movs	r2, #1
   36fea:	fa02 f303 	lsl.w	r3, r2, r3
   36fee:	f8bd 2002 	ldrh.w	r2, [sp, #2]
   36ff2:	ea22 0203 	bic.w	r2, r2, r3
   36ff6:	ab04      	add	r3, sp, #16
   36ff8:	f823 2d0e 	strh.w	r2, [r3, #-14]!
   36ffc:	6b7f      	ldr	r7, [r7, #52]	; 0x34
   36ffe:	2200      	movs	r2, #0
   37000:	216b      	movs	r1, #107	; 0x6b
   37002:	4620      	mov	r0, r4
   37004:	47b8      	blx	r7
   37006:	f1ba 0f00 	cmp.w	sl, #0
   3700a:	d14a      	bne.n	370a2 <interface_rx_enable+0x152>
   3700c:	6b6d      	ldr	r5, [r5, #52]	; 0x34
   3700e:	2300      	movs	r3, #0
   37010:	461a      	mov	r2, r3
   37012:	211f      	movs	r1, #31
   37014:	4620      	mov	r0, r4
   37016:	47a8      	blx	r5
   37018:	4607      	mov	r7, r0
   3701a:	2800      	cmp	r0, #0
   3701c:	d150      	bne.n	370c0 <interface_rx_enable+0x170>
   3701e:	e7ab      	b.n	36f78 <interface_rx_enable+0x28>
   37020:	9a03      	ldr	r2, [sp, #12]
   37022:	1ad3      	subs	r3, r2, r3
   37024:	4698      	mov	r8, r3
   37026:	ea4f 79e3 	mov.w	r9, r3, asr #31
   3702a:	ea4f 1249 	mov.w	r2, r9, lsl #5
   3702e:	0158      	lsls	r0, r3, #5
   37030:	ea42 61d3 	orr.w	r1, r2, r3, lsr #27
   37034:	1ac0      	subs	r0, r0, r3
   37036:	eb61 0109 	sbc.w	r1, r1, r9
   3703a:	024b      	lsls	r3, r1, #9
   3703c:	ea43 53d0 	orr.w	r3, r3, r0, lsr #23
   37040:	0242      	lsls	r2, r0, #9
   37042:	eb12 0008 	adds.w	r0, r2, r8
   37046:	eb43 0109 	adc.w	r1, r3, r9
   3704a:	018b      	lsls	r3, r1, #6
   3704c:	ea43 6390 	orr.w	r3, r3, r0, lsr #26
   37050:	0182      	lsls	r2, r0, #6
   37052:	1a12      	subs	r2, r2, r0
   37054:	eb63 0301 	sbc.w	r3, r3, r1
   37058:	4616      	mov	r6, r2
   3705a:	461f      	mov	r7, r3
   3705c:	4a31      	ldr	r2, [pc, #196]	; (37124 <interface_rx_enable+0x1d4>)
   3705e:	2300      	movs	r3, #0
   37060:	eb16 0008 	adds.w	r0, r6, r8
   37064:	eb47 0109 	adc.w	r1, r7, r9
   37068:	f7e1 fc28 	bl	188bc <__aeabi_uldivmod>
   3706c:	f5b0 7f7f 	cmp.w	r0, #1020	; 0x3fc
   37070:	ddab      	ble.n	36fca <interface_rx_enable+0x7a>
   37072:	68a3      	ldr	r3, [r4, #8]
   37074:	695f      	ldr	r7, [r3, #20]
   37076:	f5b0 707f 	subs.w	r0, r0, #1020	; 0x3fc
   3707a:	d0a8      	beq.n	36fce <interface_rx_enable+0x7e>
   3707c:	f7f7 fbb7 	bl	2e7ee <deca_usleep>
   37080:	e7a5      	b.n	36fce <interface_rx_enable+0x7e>
   37082:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   37086:	2201      	movs	r2, #1
   37088:	409a      	lsls	r2, r3
   3708a:	f8bd 3002 	ldrh.w	r3, [sp, #2]
   3708e:	431a      	orrs	r2, r3
   37090:	ab04      	add	r3, sp, #16
   37092:	f823 2d0e 	strh.w	r2, [r3, #-14]!
   37096:	6b7f      	ldr	r7, [r7, #52]	; 0x34
   37098:	2200      	movs	r2, #0
   3709a:	216b      	movs	r1, #107	; 0x6b
   3709c:	4620      	mov	r0, r4
   3709e:	47b8      	blx	r7
   370a0:	e7b1      	b.n	37006 <interface_rx_enable+0xb6>
   370a2:	6b6e      	ldr	r6, [r5, #52]	; 0x34
   370a4:	ab03      	add	r3, sp, #12
   370a6:	2200      	movs	r2, #0
   370a8:	2105      	movs	r1, #5
   370aa:	4620      	mov	r0, r4
   370ac:	47b0      	blx	r6
   370ae:	4607      	mov	r7, r0
   370b0:	b930      	cbnz	r0, 370c0 <interface_rx_enable+0x170>
   370b2:	6b6d      	ldr	r5, [r5, #52]	; 0x34
   370b4:	2300      	movs	r3, #0
   370b6:	2201      	movs	r2, #1
   370b8:	211f      	movs	r1, #31
   370ba:	4620      	mov	r0, r4
   370bc:	47a8      	blx	r5
   370be:	4607      	mov	r7, r0
   370c0:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   370c4:	2b00      	cmp	r3, #0
   370c6:	f6ff af57 	blt.w	36f78 <interface_rx_enable+0x28>
   370ca:	68a3      	ldr	r3, [r4, #8]
   370cc:	695d      	ldr	r5, [r3, #20]
   370ce:	6b6e      	ldr	r6, [r5, #52]	; 0x34
   370d0:	ab01      	add	r3, sp, #4
   370d2:	2200      	movs	r2, #0
   370d4:	217b      	movs	r1, #123	; 0x7b
   370d6:	4620      	mov	r0, r4
   370d8:	47b0      	blx	r6
   370da:	f994 304d 	ldrsb.w	r3, [r4, #77]	; 0x4d
   370de:	b18b      	cbz	r3, 37104 <interface_rx_enable+0x1b4>
   370e0:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   370e4:	2201      	movs	r2, #1
   370e6:	fa02 f303 	lsl.w	r3, r2, r3
   370ea:	f8bd 2004 	ldrh.w	r2, [sp, #4]
   370ee:	ea22 0203 	bic.w	r2, r2, r3
   370f2:	ab04      	add	r3, sp, #16
   370f4:	f823 2d0c 	strh.w	r2, [r3, #-12]!
   370f8:	6b6d      	ldr	r5, [r5, #52]	; 0x34
   370fa:	2200      	movs	r2, #0
   370fc:	216b      	movs	r1, #107	; 0x6b
   370fe:	4620      	mov	r0, r4
   37100:	47a8      	blx	r5
   37102:	e739      	b.n	36f78 <interface_rx_enable+0x28>
   37104:	f994 304c 	ldrsb.w	r3, [r4, #76]	; 0x4c
   37108:	2201      	movs	r2, #1
   3710a:	409a      	lsls	r2, r3
   3710c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
   37110:	431a      	orrs	r2, r3
   37112:	ab04      	add	r3, sp, #16
   37114:	f823 2d0c 	strh.w	r2, [r3, #-12]!
   37118:	6b6d      	ldr	r5, [r5, #52]	; 0x34
   3711a:	2200      	movs	r2, #0
   3711c:	216b      	movs	r1, #107	; 0x6b
   3711e:	4620      	mov	r0, r4
   37120:	47a8      	blx	r5
   37122:	e729      	b.n	36f78 <interface_rx_enable+0x28>
   37124:	0ee09800 	.word	0x0ee09800

00037128 <interface_read_rx_frame>:
   37128:	b510      	push	{r4, lr}
   3712a:	b082      	sub	sp, #8
   3712c:	9100      	str	r1, [sp, #0]
   3712e:	f8ad 2004 	strh.w	r2, [sp, #4]
   37132:	2200      	movs	r2, #0
   37134:	f8ad 2006 	strh.w	r2, [sp, #6]
   37138:	6883      	ldr	r3, [r0, #8]
   3713a:	695b      	ldr	r3, [r3, #20]
   3713c:	6b5c      	ldr	r4, [r3, #52]	; 0x34
   3713e:	466b      	mov	r3, sp
   37140:	2121      	movs	r1, #33	; 0x21
   37142:	47a0      	blx	r4
   37144:	b002      	add	sp, #8
   37146:	bd10      	pop	{r4, pc}

00037148 <dwt_forcetrxoff>:
   37148:	b510      	push	{r4, lr}
   3714a:	4b05      	ldr	r3, [pc, #20]	; (37160 <dwt_forcetrxoff+0x18>)
   3714c:	6818      	ldr	r0, [r3, #0]
   3714e:	6883      	ldr	r3, [r0, #8]
   37150:	691b      	ldr	r3, [r3, #16]
   37152:	6adc      	ldr	r4, [r3, #44]	; 0x2c
   37154:	2300      	movs	r3, #0
   37156:	461a      	mov	r2, r3
   37158:	2103      	movs	r1, #3
   3715a:	47a0      	blx	r4
   3715c:	bd10      	pop	{r4, pc}
   3715e:	bf00      	nop
   37160:	10010e64 	.word	0x10010e64

00037164 <dwt_rxenable>:
   37164:	b508      	push	{r3, lr}
   37166:	4b04      	ldr	r3, [pc, #16]	; (37178 <dwt_rxenable+0x14>)
   37168:	681b      	ldr	r3, [r3, #0]
   3716a:	689a      	ldr	r2, [r3, #8]
   3716c:	6912      	ldr	r2, [r2, #16]
   3716e:	6a12      	ldr	r2, [r2, #32]
   37170:	4601      	mov	r1, r0
   37172:	4618      	mov	r0, r3
   37174:	4790      	blx	r2
   37176:	bd08      	pop	{r3, pc}
   37178:	10010e64 	.word	0x10010e64

0003717c <dwt_generatecrc8>:
   3717c:	2900      	cmp	r1, #0
   3717e:	dd0d      	ble.n	3719c <dwt_generatecrc8+0x20>
   37180:	b410      	push	{r4}
   37182:	1e43      	subs	r3, r0, #1
   37184:	4419      	add	r1, r3
   37186:	4610      	mov	r0, r2
   37188:	4c05      	ldr	r4, [pc, #20]	; (371a0 <dwt_generatecrc8+0x24>)
   3718a:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   3718e:	4050      	eors	r0, r2
   37190:	5c20      	ldrb	r0, [r4, r0]
   37192:	428b      	cmp	r3, r1
   37194:	d1f9      	bne.n	3718a <dwt_generatecrc8+0xe>
   37196:	f85d 4b04 	ldr.w	r4, [sp], #4
   3719a:	4770      	bx	lr
   3719c:	4610      	mov	r0, r2
   3719e:	4770      	bx	lr
   371a0:	00046c2c 	.word	0x00046c2c

000371a4 <dwt_dbg_fn>:
   371a4:	2998      	cmp	r1, #152	; 0x98
   371a6:	4802      	ldr	r0, [pc, #8]	; (371b0 <dwt_dbg_fn+0xc>)
   371a8:	bf18      	it	ne
   371aa:	2000      	movne	r0, #0
   371ac:	4770      	bx	lr
   371ae:	bf00      	nop
   371b0:	00046e24 	.word	0x00046e24

000371b4 <_deinit>:
   371b4:	4770      	bx	lr

000371b6 <dwt_xfer3xxx>:
   371b6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   371ba:	b084      	sub	sp, #16
   371bc:	4605      	mov	r5, r0
   371be:	460e      	mov	r6, r1
   371c0:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
   371c4:	1990      	adds	r0, r2, r6
   371c6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   371ca:	4432      	add	r2, r6
   371cc:	f3c2 4204 	ubfx	r2, r2, #16, #5
   371d0:	0084      	lsls	r4, r0, #2
   371d2:	ea44 2442 	orr.w	r4, r4, r2, lsl #9
   371d6:	ea41 0204 	orr.w	r2, r1, r4
   371da:	0a12      	lsrs	r2, r2, #8
   371dc:	f88d 200c 	strb.w	r2, [sp, #12]
   371e0:	f001 0703 	and.w	r7, r1, #3
   371e4:	433c      	orrs	r4, r7
   371e6:	f88d 400d 	strb.w	r4, [sp, #13]
   371ea:	461f      	mov	r7, r3
   371ec:	b973      	cbnz	r3, 3720c <dwt_xfer3xxx+0x56>
   371ee:	2900      	cmp	r1, #0
   371f0:	d05c      	beq.n	372ac <dwt_xfer3xxx+0xf6>
   371f2:	0073      	lsls	r3, r6, #1
   371f4:	f063 037e 	orn	r3, r3, #126	; 0x7e
   371f8:	f88d 300c 	strb.w	r3, [sp, #12]
   371fc:	2401      	movs	r4, #1
   371fe:	2900      	cmp	r1, #0
   37200:	d02f      	beq.n	37262 <dwt_xfer3xxx+0xac>
   37202:	f5a1 4100 	sub.w	r1, r1, #32768	; 0x8000
   37206:	2903      	cmp	r1, #3
   37208:	d90a      	bls.n	37220 <dwt_xfer3xxx+0x6a>
   3720a:	e7fe      	b.n	3720a <dwt_xfer3xxx+0x54>
   3720c:	2800      	cmp	r0, #0
   3720e:	d14f      	bne.n	372b0 <dwt_xfer3xxx+0xfa>
   37210:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
   37214:	d003      	beq.n	3721e <dwt_xfer3xxx+0x68>
   37216:	2900      	cmp	r1, #0
   37218:	d14a      	bne.n	372b0 <dwt_xfer3xxx+0xfa>
   3721a:	2401      	movs	r4, #1
   3721c:	e021      	b.n	37262 <dwt_xfer3xxx+0xac>
   3721e:	2401      	movs	r4, #1
   37220:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   37222:	7d9b      	ldrb	r3, [r3, #22]
   37224:	b94b      	cbnz	r3, 3723a <dwt_xfer3xxx+0x84>
   37226:	682b      	ldr	r3, [r5, #0]
   37228:	685d      	ldr	r5, [r3, #4]
   3722a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3722c:	463a      	mov	r2, r7
   3722e:	a903      	add	r1, sp, #12
   37230:	4620      	mov	r0, r4
   37232:	47a8      	blx	r5
   37234:	b004      	add	sp, #16
   37236:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3723a:	2200      	movs	r2, #0
   3723c:	4621      	mov	r1, r4
   3723e:	a803      	add	r0, sp, #12
   37240:	f7ff ff9c 	bl	3717c <dwt_generatecrc8>
   37244:	4602      	mov	r2, r0
   37246:	4639      	mov	r1, r7
   37248:	980a      	ldr	r0, [sp, #40]	; 0x28
   3724a:	f7ff ff97 	bl	3717c <dwt_generatecrc8>
   3724e:	682b      	ldr	r3, [r5, #0]
   37250:	9000      	str	r0, [sp, #0]
   37252:	689d      	ldr	r5, [r3, #8]
   37254:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   37256:	463a      	mov	r2, r7
   37258:	a903      	add	r1, sp, #12
   3725a:	4620      	mov	r0, r4
   3725c:	47a8      	blx	r5
   3725e:	e7e9      	b.n	37234 <dwt_xfer3xxx+0x7e>
   37260:	2401      	movs	r4, #1
   37262:	682b      	ldr	r3, [r5, #0]
   37264:	f8d3 8000 	ldr.w	r8, [r3]
   37268:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3726a:	463a      	mov	r2, r7
   3726c:	a903      	add	r1, sp, #12
   3726e:	4620      	mov	r0, r4
   37270:	47c0      	blx	r8
   37272:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   37274:	7d9b      	ldrb	r3, [r3, #22]
   37276:	2b02      	cmp	r3, #2
   37278:	d1dc      	bne.n	37234 <dwt_xfer3xxx+0x7e>
   3727a:	2e18      	cmp	r6, #24
   3727c:	d0da      	beq.n	37234 <dwt_xfer3xxx+0x7e>
   3727e:	2200      	movs	r2, #0
   37280:	4621      	mov	r1, r4
   37282:	a803      	add	r0, sp, #12
   37284:	f7ff ff7a 	bl	3717c <dwt_generatecrc8>
   37288:	4602      	mov	r2, r0
   3728a:	4639      	mov	r1, r7
   3728c:	980a      	ldr	r0, [sp, #40]	; 0x28
   3728e:	f7ff ff75 	bl	3717c <dwt_generatecrc8>
   37292:	4604      	mov	r4, r0
   37294:	2200      	movs	r2, #0
   37296:	2118      	movs	r1, #24
   37298:	4628      	mov	r0, r5
   3729a:	f000 f841 	bl	37320 <dwt_read8bitoffsetreg>
   3729e:	4284      	cmp	r4, r0
   372a0:	d0c8      	beq.n	37234 <dwt_xfer3xxx+0x7e>
   372a2:	68eb      	ldr	r3, [r5, #12]
   372a4:	2b00      	cmp	r3, #0
   372a6:	d0c5      	beq.n	37234 <dwt_xfer3xxx+0x7e>
   372a8:	4798      	blx	r3
   372aa:	e7c3      	b.n	37234 <dwt_xfer3xxx+0x7e>
   372ac:	2800      	cmp	r0, #0
   372ae:	d0d7      	beq.n	37260 <dwt_xfer3xxx+0xaa>
   372b0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   372b4:	f88d 200c 	strb.w	r2, [sp, #12]
   372b8:	2402      	movs	r4, #2
   372ba:	e7a0      	b.n	371fe <dwt_xfer3xxx+0x48>

000372bc <dwt_readfromdevice>:
   372bc:	b510      	push	{r4, lr}
   372be:	b082      	sub	sp, #8
   372c0:	2400      	movs	r4, #0
   372c2:	9401      	str	r4, [sp, #4]
   372c4:	9c04      	ldr	r4, [sp, #16]
   372c6:	9400      	str	r4, [sp, #0]
   372c8:	f7ff ff75 	bl	371b6 <dwt_xfer3xxx>
   372cc:	b002      	add	sp, #8
   372ce:	bd10      	pop	{r4, pc}

000372d0 <dwt_read32bitoffsetreg>:
   372d0:	b500      	push	{lr}
   372d2:	b085      	sub	sp, #20
   372d4:	ab03      	add	r3, sp, #12
   372d6:	9300      	str	r3, [sp, #0]
   372d8:	2304      	movs	r3, #4
   372da:	b292      	uxth	r2, r2
   372dc:	f7ff ffee 	bl	372bc <dwt_readfromdevice>
   372e0:	f10d 030f 	add.w	r3, sp, #15
   372e4:	f10d 010b 	add.w	r1, sp, #11
   372e8:	2000      	movs	r0, #0
   372ea:	f813 2901 	ldrb.w	r2, [r3], #-1
   372ee:	eb02 2000 	add.w	r0, r2, r0, lsl #8
   372f2:	428b      	cmp	r3, r1
   372f4:	d1f9      	bne.n	372ea <dwt_read32bitoffsetreg+0x1a>
   372f6:	b005      	add	sp, #20
   372f8:	f85d fb04 	ldr.w	pc, [sp], #4

000372fc <dwt_read16bitoffsetreg>:
   372fc:	b500      	push	{lr}
   372fe:	b085      	sub	sp, #20
   37300:	ab03      	add	r3, sp, #12
   37302:	9300      	str	r3, [sp, #0]
   37304:	2302      	movs	r3, #2
   37306:	b292      	uxth	r2, r2
   37308:	f7ff ffd8 	bl	372bc <dwt_readfromdevice>
   3730c:	f89d 300d 	ldrb.w	r3, [sp, #13]
   37310:	f89d 000c 	ldrb.w	r0, [sp, #12]
   37314:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   37318:	b280      	uxth	r0, r0
   3731a:	b005      	add	sp, #20
   3731c:	f85d fb04 	ldr.w	pc, [sp], #4

00037320 <dwt_read8bitoffsetreg>:
   37320:	b500      	push	{lr}
   37322:	b085      	sub	sp, #20
   37324:	f10d 030f 	add.w	r3, sp, #15
   37328:	9300      	str	r3, [sp, #0]
   3732a:	2301      	movs	r3, #1
   3732c:	b292      	uxth	r2, r2
   3732e:	f7ff ffc5 	bl	372bc <dwt_readfromdevice>
   37332:	f89d 000f 	ldrb.w	r0, [sp, #15]
   37336:	b005      	add	sp, #20
   37338:	f85d fb04 	ldr.w	pc, [sp], #4

0003733c <ull_readdiagnostics>:
   3733c:	b530      	push	{r4, r5, lr}
   3733e:	b0bd      	sub	sp, #244	; 0xf4
   37340:	4605      	mov	r5, r0
   37342:	460c      	mov	r4, r1
   37344:	6d03      	ldr	r3, [r0, #80]	; 0x50
   37346:	7bda      	ldrb	r2, [r3, #15]
   37348:	2a01      	cmp	r2, #1
   3734a:	d01c      	beq.n	37386 <ull_readdiagnostics+0x4a>
   3734c:	2a03      	cmp	r2, #3
   3734e:	f040 81d4 	bne.w	376fa <ull_readdiagnostics+0x3be>
   37352:	7e1b      	ldrb	r3, [r3, #24]
   37354:	f013 0f08 	tst.w	r3, #8
   37358:	d10c      	bne.n	37374 <ull_readdiagnostics+0x38>
   3735a:	f013 0f04 	tst.w	r3, #4
   3735e:	ab02      	add	r3, sp, #8
   37360:	9300      	str	r3, [sp, #0]
   37362:	bf14      	ite	ne
   37364:	2338      	movne	r3, #56	; 0x38
   37366:	2320      	moveq	r3, #32
   37368:	2200      	movs	r2, #0
   3736a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3736e:	f7ff ffa5 	bl	372bc <dwt_readfromdevice>
   37372:	e019      	b.n	373a8 <ull_readdiagnostics+0x6c>
   37374:	ab02      	add	r3, sp, #8
   37376:	9300      	str	r3, [sp, #0]
   37378:	23e8      	movs	r3, #232	; 0xe8
   3737a:	2200      	movs	r2, #0
   3737c:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   37380:	f7ff ff9c 	bl	372bc <dwt_readfromdevice>
   37384:	e010      	b.n	373a8 <ull_readdiagnostics+0x6c>
   37386:	7e1b      	ldrb	r3, [r3, #24]
   37388:	f013 0f08 	tst.w	r3, #8
   3738c:	f040 81ac 	bne.w	376e8 <ull_readdiagnostics+0x3ac>
   37390:	f013 0f04 	tst.w	r3, #4
   37394:	ab02      	add	r3, sp, #8
   37396:	9300      	str	r3, [sp, #0]
   37398:	bf14      	ite	ne
   3739a:	2338      	movne	r3, #56	; 0x38
   3739c:	2320      	moveq	r3, #32
   3739e:	2200      	movs	r2, #0
   373a0:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   373a4:	f7ff ff8a 	bl	372bc <dwt_readfromdevice>
   373a8:	f10d 0217 	add.w	r2, sp, #23
   373ac:	f104 031a 	add.w	r3, r4, #26
   373b0:	f104 0020 	add.w	r0, r4, #32
   373b4:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   373b8:	f803 1b01 	strb.w	r1, [r3], #1
   373bc:	4283      	cmp	r3, r0
   373be:	d1f9      	bne.n	373b4 <ull_readdiagnostics+0x78>
   373c0:	f89d 2015 	ldrb.w	r2, [sp, #21]
   373c4:	f89d 3014 	ldrb.w	r3, [sp, #20]
   373c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   373cc:	f3c3 030c 	ubfx	r3, r3, #0, #13
   373d0:	8463      	strh	r3, [r4, #34]	; 0x22
   373d2:	f89d 201f 	ldrb.w	r2, [sp, #31]
   373d6:	f89d 301e 	ldrb.w	r3, [sp, #30]
   373da:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   373de:	f3c3 030d 	ubfx	r3, r3, #0, #14
   373e2:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   373e6:	bf1c      	itt	ne
   373e8:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   373ec:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   373f0:	8423      	strh	r3, [r4, #32]
   373f2:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
   373f6:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   373fa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   373fe:	f3c3 030b 	ubfx	r3, r3, #0, #12
   37402:	87e3      	strh	r3, [r4, #62]	; 0x3e
   37404:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   37406:	7e1b      	ldrb	r3, [r3, #24]
   37408:	f013 0f02 	tst.w	r3, #2
   3740c:	f040 816a 	bne.w	376e4 <ull_readdiagnostics+0x3a8>
   37410:	aa0a      	add	r2, sp, #40	; 0x28
   37412:	1e63      	subs	r3, r4, #1
   37414:	1d20      	adds	r0, r4, #4
   37416:	f812 1b01 	ldrb.w	r1, [r2], #1
   3741a:	f803 1f01 	strb.w	r1, [r3, #1]!
   3741e:	79d1      	ldrb	r1, [r2, #7]
   37420:	7219      	strb	r1, [r3, #8]
   37422:	7bd1      	ldrb	r1, [r2, #15]
   37424:	7459      	strb	r1, [r3, #17]
   37426:	4283      	cmp	r3, r0
   37428:	d1f5      	bne.n	37416 <ull_readdiagnostics+0xda>
   3742a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   3742e:	7163      	strb	r3, [r4, #5]
   37430:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
   37434:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
   37438:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3743c:	80e3      	strh	r3, [r4, #6]
   3743e:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   37442:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   37446:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3744a:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3744e:	f8a4 300d 	strh.w	r3, [r4, #13]
   37452:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   37456:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   3745a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3745e:	f8a4 300f 	strh.w	r3, [r4, #15]
   37462:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   37466:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   3746a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3746e:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   37472:	82e3      	strh	r3, [r4, #22]
   37474:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
   37478:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
   3747c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37480:	8323      	strh	r3, [r4, #24]
   37482:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   37484:	7e1b      	ldrb	r3, [r3, #24]
   37486:	f013 0f04 	tst.w	r3, #4
   3748a:	f040 812b 	bne.w	376e4 <ull_readdiagnostics+0x3a8>
   3748e:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   37492:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   37496:	041b      	lsls	r3, r3, #16
   37498:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3749c:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   374a0:	4313      	orrs	r3, r2
   374a2:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   374a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   374aa:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   374ae:	6263      	str	r3, [r4, #36]	; 0x24
   374b0:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
   374b4:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
   374b8:	041b      	lsls	r3, r3, #16
   374ba:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   374be:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
   374c2:	4313      	orrs	r3, r2
   374c4:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
   374c8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   374cc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   374d0:	62a3      	str	r3, [r4, #40]	; 0x28
   374d2:	f89d 204b 	ldrb.w	r2, [sp, #75]	; 0x4b
   374d6:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   374da:	041b      	lsls	r3, r3, #16
   374dc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   374e0:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
   374e4:	4313      	orrs	r3, r2
   374e6:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
   374ea:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   374ee:	f3c3 0310 	ubfx	r3, r3, #0, #17
   374f2:	62e3      	str	r3, [r4, #44]	; 0x2c
   374f4:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
   374f8:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
   374fc:	041b      	lsls	r3, r3, #16
   374fe:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37502:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   37506:	4313      	orrs	r3, r2
   37508:	f89d 204d 	ldrb.w	r2, [sp, #77]	; 0x4d
   3750c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37510:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37514:	6323      	str	r3, [r4, #48]	; 0x30
   37516:	f89d 2053 	ldrb.w	r2, [sp, #83]	; 0x53
   3751a:	f89d 3052 	ldrb.w	r3, [sp, #82]	; 0x52
   3751e:	041b      	lsls	r3, r3, #16
   37520:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37524:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
   37528:	4313      	orrs	r3, r2
   3752a:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   3752e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37532:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37536:	6363      	str	r3, [r4, #52]	; 0x34
   37538:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   3753c:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
   37540:	041b      	lsls	r3, r3, #16
   37542:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37546:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
   3754a:	4313      	orrs	r3, r2
   3754c:	f89d 2055 	ldrb.w	r2, [sp, #85]	; 0x55
   37550:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37554:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37558:	63a3      	str	r3, [r4, #56]	; 0x38
   3755a:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   3755e:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
   37562:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37566:	87a3      	strh	r3, [r4, #60]	; 0x3c
   37568:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   3756c:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   37570:	041b      	lsls	r3, r3, #16
   37572:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37576:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   3757a:	4313      	orrs	r3, r2
   3757c:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   37580:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37584:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   37588:	6423      	str	r3, [r4, #64]	; 0x40
   3758a:	f89d 2079 	ldrb.w	r2, [sp, #121]	; 0x79
   3758e:	f89d 3078 	ldrb.w	r3, [sp, #120]	; 0x78
   37592:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37596:	6463      	str	r3, [r4, #68]	; 0x44
   37598:	f89d 207f 	ldrb.w	r2, [sp, #127]	; 0x7f
   3759c:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
   375a0:	041b      	lsls	r3, r3, #16
   375a2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   375a6:	f89d 207c 	ldrb.w	r2, [sp, #124]	; 0x7c
   375aa:	4313      	orrs	r3, r2
   375ac:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   375b0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   375b4:	f3c3 0315 	ubfx	r3, r3, #0, #22
   375b8:	64a3      	str	r3, [r4, #72]	; 0x48
   375ba:	f89d 2083 	ldrb.w	r2, [sp, #131]	; 0x83
   375be:	f89d 3082 	ldrb.w	r3, [sp, #130]	; 0x82
   375c2:	041b      	lsls	r3, r3, #16
   375c4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   375c8:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
   375cc:	4313      	orrs	r3, r2
   375ce:	f89d 2081 	ldrb.w	r2, [sp, #129]	; 0x81
   375d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   375d6:	f3c3 0315 	ubfx	r3, r3, #0, #22
   375da:	64e3      	str	r3, [r4, #76]	; 0x4c
   375dc:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
   375e0:	f89d 3086 	ldrb.w	r3, [sp, #134]	; 0x86
   375e4:	041b      	lsls	r3, r3, #16
   375e6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   375ea:	f89d 2084 	ldrb.w	r2, [sp, #132]	; 0x84
   375ee:	4313      	orrs	r3, r2
   375f0:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   375f4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   375f8:	f3c3 0315 	ubfx	r3, r3, #0, #22
   375fc:	6523      	str	r3, [r4, #80]	; 0x50
   375fe:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   37602:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   37606:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3760a:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3760e:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   37612:	f89d 20a5 	ldrb.w	r2, [sp, #165]	; 0xa5
   37616:	f89d 30a4 	ldrb.w	r3, [sp, #164]	; 0xa4
   3761a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3761e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   37622:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   37626:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   3762a:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   3762e:	041b      	lsls	r3, r3, #16
   37630:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37634:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   37638:	4313      	orrs	r3, r2
   3763a:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   3763e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37642:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   37646:	65a3      	str	r3, [r4, #88]	; 0x58
   37648:	f89d 20c1 	ldrb.w	r2, [sp, #193]	; 0xc1
   3764c:	f89d 30c0 	ldrb.w	r3, [sp, #192]	; 0xc0
   37650:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37654:	65e3      	str	r3, [r4, #92]	; 0x5c
   37656:	f89d 20c7 	ldrb.w	r2, [sp, #199]	; 0xc7
   3765a:	f89d 30c6 	ldrb.w	r3, [sp, #198]	; 0xc6
   3765e:	041b      	lsls	r3, r3, #16
   37660:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37664:	f89d 20c4 	ldrb.w	r2, [sp, #196]	; 0xc4
   37668:	4313      	orrs	r3, r2
   3766a:	f89d 20c5 	ldrb.w	r2, [sp, #197]	; 0xc5
   3766e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37672:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37676:	6623      	str	r3, [r4, #96]	; 0x60
   37678:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   3767c:	f89d 30ca 	ldrb.w	r3, [sp, #202]	; 0xca
   37680:	041b      	lsls	r3, r3, #16
   37682:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37686:	f89d 20c8 	ldrb.w	r2, [sp, #200]	; 0xc8
   3768a:	4313      	orrs	r3, r2
   3768c:	f89d 20c9 	ldrb.w	r2, [sp, #201]	; 0xc9
   37690:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37694:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37698:	6663      	str	r3, [r4, #100]	; 0x64
   3769a:	f89d 20cf 	ldrb.w	r2, [sp, #207]	; 0xcf
   3769e:	f89d 30ce 	ldrb.w	r3, [sp, #206]	; 0xce
   376a2:	041b      	lsls	r3, r3, #16
   376a4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   376a8:	f89d 20cc 	ldrb.w	r2, [sp, #204]	; 0xcc
   376ac:	4313      	orrs	r3, r2
   376ae:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   376b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   376b6:	f3c3 0315 	ubfx	r3, r3, #0, #22
   376ba:	66a3      	str	r3, [r4, #104]	; 0x68
   376bc:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   376c0:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   376c4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   376c8:	f3c3 030e 	ubfx	r3, r3, #0, #15
   376cc:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   376d0:	f89d 20ed 	ldrb.w	r2, [sp, #237]	; 0xed
   376d4:	f89d 30ec 	ldrb.w	r3, [sp, #236]	; 0xec
   376d8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   376dc:	f3c3 030b 	ubfx	r3, r3, #0, #12
   376e0:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   376e4:	b03d      	add	sp, #244	; 0xf4
   376e6:	bd30      	pop	{r4, r5, pc}
   376e8:	ab02      	add	r3, sp, #8
   376ea:	9300      	str	r3, [sp, #0]
   376ec:	23e8      	movs	r3, #232	; 0xe8
   376ee:	2200      	movs	r2, #0
   376f0:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   376f4:	f7ff fde2 	bl	372bc <dwt_readfromdevice>
   376f8:	e656      	b.n	373a8 <ull_readdiagnostics+0x6c>
   376fa:	7e1b      	ldrb	r3, [r3, #24]
   376fc:	f013 0f01 	tst.w	r3, #1
   37700:	f000 819f 	beq.w	37a42 <ull_readdiagnostics+0x706>
   37704:	ab02      	add	r3, sp, #8
   37706:	9300      	str	r3, [sp, #0]
   37708:	236c      	movs	r3, #108	; 0x6c
   3770a:	2200      	movs	r2, #0
   3770c:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   37710:	f7ff fdd4 	bl	372bc <dwt_readfromdevice>
   37714:	ab1d      	add	r3, sp, #116	; 0x74
   37716:	9300      	str	r3, [sp, #0]
   37718:	236c      	movs	r3, #108	; 0x6c
   3771a:	2200      	movs	r2, #0
   3771c:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   37720:	4628      	mov	r0, r5
   37722:	f7ff fdcb 	bl	372bc <dwt_readfromdevice>
   37726:	aa02      	add	r2, sp, #8
   37728:	1e63      	subs	r3, r4, #1
   3772a:	1d20      	adds	r0, r4, #4
   3772c:	f812 1b01 	ldrb.w	r1, [r2], #1
   37730:	f803 1f01 	strb.w	r1, [r3, #1]!
   37734:	79d1      	ldrb	r1, [r2, #7]
   37736:	7219      	strb	r1, [r3, #8]
   37738:	7bd1      	ldrb	r1, [r2, #15]
   3773a:	7459      	strb	r1, [r3, #17]
   3773c:	7dd1      	ldrb	r1, [r2, #23]
   3773e:	7699      	strb	r1, [r3, #26]
   37740:	4283      	cmp	r3, r0
   37742:	d1f3      	bne.n	3772c <ull_readdiagnostics+0x3f0>
   37744:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   37748:	77e3      	strb	r3, [r4, #31]
   3774a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   3774e:	7163      	strb	r3, [r4, #5]
   37750:	f89d 200e 	ldrb.w	r2, [sp, #14]
   37754:	f89d 300d 	ldrb.w	r3, [sp, #13]
   37758:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3775c:	80e3      	strh	r3, [r4, #6]
   3775e:	f89d 3016 	ldrb.w	r3, [sp, #22]
   37762:	f89d 2017 	ldrb.w	r2, [sp, #23]
   37766:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
   3776a:	f3c2 12cf 	ubfx	r2, r2, #7, #16
   3776e:	f8a4 200d 	strh.w	r2, [r4, #13]
   37772:	f89d 2015 	ldrb.w	r2, [sp, #21]
   37776:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   3777a:	f8a4 200f 	strh.w	r2, [r4, #15]
   3777e:	f89d 201f 	ldrb.w	r2, [sp, #31]
   37782:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37786:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3778a:	82e3      	strh	r3, [r4, #22]
   3778c:	f89d 201e 	ldrb.w	r2, [sp, #30]
   37790:	f89d 301d 	ldrb.w	r3, [sp, #29]
   37794:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37798:	8323      	strh	r3, [r4, #24]
   3779a:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   3779e:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   377a2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   377a6:	f3c3 030d 	ubfx	r3, r3, #0, #14
   377aa:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   377ae:	bf1c      	itt	ne
   377b0:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   377b4:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   377b8:	8423      	strh	r3, [r4, #32]
   377ba:	f89d 2029 	ldrb.w	r2, [sp, #41]	; 0x29
   377be:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   377c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   377c6:	f3c3 030c 	ubfx	r3, r3, #0, #13
   377ca:	8463      	strh	r3, [r4, #34]	; 0x22
   377cc:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   377d0:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
   377d4:	041b      	lsls	r3, r3, #16
   377d6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   377da:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   377de:	4313      	orrs	r3, r2
   377e0:	f89d 202d 	ldrb.w	r2, [sp, #45]	; 0x2d
   377e4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   377e8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   377ec:	6263      	str	r3, [r4, #36]	; 0x24
   377ee:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   377f0:	7e1b      	ldrb	r3, [r3, #24]
   377f2:	f013 0f01 	tst.w	r3, #1
   377f6:	f43f af75 	beq.w	376e4 <ull_readdiagnostics+0x3a8>
   377fa:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
   377fe:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   37802:	041b      	lsls	r3, r3, #16
   37804:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37808:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   3780c:	4313      	orrs	r3, r2
   3780e:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   37812:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37816:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3781a:	62a3      	str	r3, [r4, #40]	; 0x28
   3781c:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   37820:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   37824:	041b      	lsls	r3, r3, #16
   37826:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3782a:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
   3782e:	4313      	orrs	r3, r2
   37830:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
   37834:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37838:	f3c3 0310 	ubfx	r3, r3, #0, #17
   3783c:	62e3      	str	r3, [r4, #44]	; 0x2c
   3783e:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   37842:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
   37846:	041b      	lsls	r3, r3, #16
   37848:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3784c:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
   37850:	4313      	orrs	r3, r2
   37852:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
   37856:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3785a:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3785e:	6323      	str	r3, [r4, #48]	; 0x30
   37860:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   37864:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   37868:	041b      	lsls	r3, r3, #16
   3786a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3786e:	f89d 203c 	ldrb.w	r2, [sp, #60]	; 0x3c
   37872:	4313      	orrs	r3, r2
   37874:	f89d 203d 	ldrb.w	r2, [sp, #61]	; 0x3d
   37878:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3787c:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37880:	6363      	str	r3, [r4, #52]	; 0x34
   37882:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   37886:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   3788a:	041b      	lsls	r3, r3, #16
   3788c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37890:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   37894:	4313      	orrs	r3, r2
   37896:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   3789a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3789e:	f3c3 0315 	ubfx	r3, r3, #0, #22
   378a2:	63a3      	str	r3, [r4, #56]	; 0x38
   378a4:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   378a8:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
   378ac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   378b0:	87a3      	strh	r3, [r4, #60]	; 0x3c
   378b2:	f89d 2061 	ldrb.w	r2, [sp, #97]	; 0x61
   378b6:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
   378ba:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   378be:	f3c3 030b 	ubfx	r3, r3, #0, #12
   378c2:	87e3      	strh	r3, [r4, #62]	; 0x3e
   378c4:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
   378c8:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
   378cc:	041b      	lsls	r3, r3, #16
   378ce:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   378d2:	f89d 2064 	ldrb.w	r2, [sp, #100]	; 0x64
   378d6:	4313      	orrs	r3, r2
   378d8:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   378dc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   378e0:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   378e4:	6423      	str	r3, [r4, #64]	; 0x40
   378e6:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
   378ea:	f89d 3068 	ldrb.w	r3, [sp, #104]	; 0x68
   378ee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   378f2:	6463      	str	r3, [r4, #68]	; 0x44
   378f4:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
   378f8:	f89d 306e 	ldrb.w	r3, [sp, #110]	; 0x6e
   378fc:	041b      	lsls	r3, r3, #16
   378fe:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37902:	f89d 206c 	ldrb.w	r2, [sp, #108]	; 0x6c
   37906:	4313      	orrs	r3, r2
   37908:	f89d 206d 	ldrb.w	r2, [sp, #109]	; 0x6d
   3790c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37910:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37914:	64a3      	str	r3, [r4, #72]	; 0x48
   37916:	f89d 2073 	ldrb.w	r2, [sp, #115]	; 0x73
   3791a:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
   3791e:	041b      	lsls	r3, r3, #16
   37920:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37924:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   37928:	4313      	orrs	r3, r2
   3792a:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   3792e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37932:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37936:	64e3      	str	r3, [r4, #76]	; 0x4c
   37938:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   3793c:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   37940:	041b      	lsls	r3, r3, #16
   37942:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37946:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   3794a:	4313      	orrs	r3, r2
   3794c:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   37950:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37954:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37958:	6523      	str	r3, [r4, #80]	; 0x50
   3795a:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   3795e:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
   37962:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37966:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3796a:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   3796e:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   37972:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   37976:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3797a:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3797e:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   37982:	f89d 20af 	ldrb.w	r2, [sp, #175]	; 0xaf
   37986:	f89d 30ae 	ldrb.w	r3, [sp, #174]	; 0xae
   3798a:	041b      	lsls	r3, r3, #16
   3798c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37990:	f89d 20ac 	ldrb.w	r2, [sp, #172]	; 0xac
   37994:	4313      	orrs	r3, r2
   37996:	f89d 20ad 	ldrb.w	r2, [sp, #173]	; 0xad
   3799a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3799e:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   379a2:	65a3      	str	r3, [r4, #88]	; 0x58
   379a4:	f89d 20b1 	ldrb.w	r2, [sp, #177]	; 0xb1
   379a8:	f89d 30b0 	ldrb.w	r3, [sp, #176]	; 0xb0
   379ac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   379b0:	65e3      	str	r3, [r4, #92]	; 0x5c
   379b2:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   379b6:	f89d 30b6 	ldrb.w	r3, [sp, #182]	; 0xb6
   379ba:	041b      	lsls	r3, r3, #16
   379bc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   379c0:	f89d 20b4 	ldrb.w	r2, [sp, #180]	; 0xb4
   379c4:	4313      	orrs	r3, r2
   379c6:	f89d 20b5 	ldrb.w	r2, [sp, #181]	; 0xb5
   379ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   379ce:	f3c3 0315 	ubfx	r3, r3, #0, #22
   379d2:	6623      	str	r3, [r4, #96]	; 0x60
   379d4:	f89d 20bb 	ldrb.w	r2, [sp, #187]	; 0xbb
   379d8:	f89d 30ba 	ldrb.w	r3, [sp, #186]	; 0xba
   379dc:	041b      	lsls	r3, r3, #16
   379de:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   379e2:	f89d 20b8 	ldrb.w	r2, [sp, #184]	; 0xb8
   379e6:	4313      	orrs	r3, r2
   379e8:	f89d 20b9 	ldrb.w	r2, [sp, #185]	; 0xb9
   379ec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   379f0:	f3c3 0315 	ubfx	r3, r3, #0, #22
   379f4:	6663      	str	r3, [r4, #100]	; 0x64
   379f6:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   379fa:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   379fe:	041b      	lsls	r3, r3, #16
   37a00:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   37a04:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   37a08:	4313      	orrs	r3, r2
   37a0a:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   37a0e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37a12:	f3c3 0315 	ubfx	r3, r3, #0, #22
   37a16:	66a3      	str	r3, [r4, #104]	; 0x68
   37a18:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   37a1c:	f89d 30cc 	ldrb.w	r3, [sp, #204]	; 0xcc
   37a20:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37a24:	f3c3 030e 	ubfx	r3, r3, #0, #15
   37a28:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   37a2c:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   37a30:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   37a34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   37a38:	f3c3 030b 	ubfx	r3, r3, #0, #12
   37a3c:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   37a40:	e650      	b.n	376e4 <ull_readdiagnostics+0x3a8>
   37a42:	ab02      	add	r3, sp, #8
   37a44:	9300      	str	r3, [sp, #0]
   37a46:	2328      	movs	r3, #40	; 0x28
   37a48:	2200      	movs	r2, #0
   37a4a:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   37a4e:	f7ff fc35 	bl	372bc <dwt_readfromdevice>
   37a52:	e668      	b.n	37726 <ull_readdiagnostics+0x3ea>

00037a54 <ull_readrxtimestamp>:
   37a54:	b500      	push	{lr}
   37a56:	b083      	sub	sp, #12
   37a58:	6d03      	ldr	r3, [r0, #80]	; 0x50
   37a5a:	7bdb      	ldrb	r3, [r3, #15]
   37a5c:	2b01      	cmp	r3, #1
   37a5e:	d00b      	beq.n	37a78 <ull_readrxtimestamp+0x24>
   37a60:	2b03      	cmp	r3, #3
   37a62:	d110      	bne.n	37a86 <ull_readrxtimestamp+0x32>
   37a64:	9100      	str	r1, [sp, #0]
   37a66:	2305      	movs	r3, #5
   37a68:	2204      	movs	r2, #4
   37a6a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   37a6e:	f7ff fc25 	bl	372bc <dwt_readfromdevice>
   37a72:	b003      	add	sp, #12
   37a74:	f85d fb04 	ldr.w	pc, [sp], #4
   37a78:	9100      	str	r1, [sp, #0]
   37a7a:	2305      	movs	r3, #5
   37a7c:	2200      	movs	r2, #0
   37a7e:	4905      	ldr	r1, [pc, #20]	; (37a94 <ull_readrxtimestamp+0x40>)
   37a80:	f7ff fc1c 	bl	372bc <dwt_readfromdevice>
   37a84:	e7f5      	b.n	37a72 <ull_readrxtimestamp+0x1e>
   37a86:	9100      	str	r1, [sp, #0]
   37a88:	2305      	movs	r3, #5
   37a8a:	2200      	movs	r2, #0
   37a8c:	2164      	movs	r1, #100	; 0x64
   37a8e:	f7ff fc15 	bl	372bc <dwt_readfromdevice>
   37a92:	e7ee      	b.n	37a72 <ull_readrxtimestamp+0x1e>
   37a94:	00180004 	.word	0x00180004

00037a98 <dwt_writetodevice>:
   37a98:	b510      	push	{r4, lr}
   37a9a:	b082      	sub	sp, #8
   37a9c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
   37aa0:	9401      	str	r4, [sp, #4]
   37aa2:	9c04      	ldr	r4, [sp, #16]
   37aa4:	9400      	str	r4, [sp, #0]
   37aa6:	f7ff fb86 	bl	371b6 <dwt_xfer3xxx>
   37aaa:	b002      	add	sp, #8
   37aac:	bd10      	pop	{r4, pc}

00037aae <dwt_write8bitoffsetreg>:
   37aae:	b510      	push	{r4, lr}
   37ab0:	b084      	sub	sp, #16
   37ab2:	ac04      	add	r4, sp, #16
   37ab4:	f804 3d01 	strb.w	r3, [r4, #-1]!
   37ab8:	9400      	str	r4, [sp, #0]
   37aba:	2301      	movs	r3, #1
   37abc:	b292      	uxth	r2, r2
   37abe:	f7ff ffeb 	bl	37a98 <dwt_writetodevice>
   37ac2:	b004      	add	sp, #16
   37ac4:	bd10      	pop	{r4, pc}
	...

00037ac8 <ull_getframelength>:
   37ac8:	b510      	push	{r4, lr}
   37aca:	4604      	mov	r4, r0
   37acc:	6d03      	ldr	r3, [r0, #80]	; 0x50
   37ace:	7bdb      	ldrb	r3, [r3, #15]
   37ad0:	2b01      	cmp	r3, #1
   37ad2:	d013      	beq.n	37afc <ull_getframelength+0x34>
   37ad4:	2b03      	cmp	r3, #3
   37ad6:	d11d      	bne.n	37b14 <ull_getframelength+0x4c>
   37ad8:	23f0      	movs	r3, #240	; 0xf0
   37ada:	2200      	movs	r2, #0
   37adc:	4912      	ldr	r1, [pc, #72]	; (37b28 <ull_getframelength+0x60>)
   37ade:	f7ff ffe6 	bl	37aae <dwt_write8bitoffsetreg>
   37ae2:	2200      	movs	r2, #0
   37ae4:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   37ae8:	4620      	mov	r0, r4
   37aea:	f7ff fc07 	bl	372fc <dwt_read16bitoffsetreg>
   37aee:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37af0:	7b1a      	ldrb	r2, [r3, #12]
   37af2:	b1a2      	cbz	r2, 37b1e <ull_getframelength+0x56>
   37af4:	f3c0 0009 	ubfx	r0, r0, #0, #10
   37af8:	8458      	strh	r0, [r3, #34]	; 0x22
   37afa:	bd10      	pop	{r4, pc}
   37afc:	230f      	movs	r3, #15
   37afe:	2200      	movs	r2, #0
   37b00:	4909      	ldr	r1, [pc, #36]	; (37b28 <ull_getframelength+0x60>)
   37b02:	f7ff ffd4 	bl	37aae <dwt_write8bitoffsetreg>
   37b06:	2200      	movs	r2, #0
   37b08:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   37b0c:	4620      	mov	r0, r4
   37b0e:	f7ff fbf5 	bl	372fc <dwt_read16bitoffsetreg>
   37b12:	e7ec      	b.n	37aee <ull_getframelength+0x26>
   37b14:	2200      	movs	r2, #0
   37b16:	214c      	movs	r1, #76	; 0x4c
   37b18:	f7ff fbf0 	bl	372fc <dwt_read16bitoffsetreg>
   37b1c:	e7e7      	b.n	37aee <ull_getframelength+0x26>
   37b1e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   37b22:	8458      	strh	r0, [r3, #34]	; 0x22
   37b24:	e7e9      	b.n	37afa <ull_getframelength+0x32>
   37b26:	bf00      	nop
   37b28:	00010024 	.word	0x00010024

00037b2c <ull_configeventcounters>:
   37b2c:	b538      	push	{r3, r4, r5, lr}
   37b2e:	4605      	mov	r5, r0
   37b30:	460c      	mov	r4, r1
   37b32:	2302      	movs	r3, #2
   37b34:	2200      	movs	r2, #0
   37b36:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   37b3a:	f7ff ffb8 	bl	37aae <dwt_write8bitoffsetreg>
   37b3e:	b904      	cbnz	r4, 37b42 <ull_configeventcounters+0x16>
   37b40:	bd38      	pop	{r3, r4, r5, pc}
   37b42:	2301      	movs	r3, #1
   37b44:	2200      	movs	r2, #0
   37b46:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   37b4a:	4628      	mov	r0, r5
   37b4c:	f7ff ffaf 	bl	37aae <dwt_write8bitoffsetreg>
   37b50:	e7f6      	b.n	37b40 <ull_configeventcounters+0x14>

00037b52 <dwt_write16bitoffsetreg>:
   37b52:	b500      	push	{lr}
   37b54:	b085      	sub	sp, #20
   37b56:	f88d 300c 	strb.w	r3, [sp, #12]
   37b5a:	0a1b      	lsrs	r3, r3, #8
   37b5c:	f88d 300d 	strb.w	r3, [sp, #13]
   37b60:	ab03      	add	r3, sp, #12
   37b62:	9300      	str	r3, [sp, #0]
   37b64:	2302      	movs	r3, #2
   37b66:	b292      	uxth	r2, r2
   37b68:	f7ff ff96 	bl	37a98 <dwt_writetodevice>
   37b6c:	b005      	add	sp, #20
   37b6e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00037b74 <ull_clearaonconfig>:
   37b74:	b538      	push	{r3, r4, r5, lr}
   37b76:	4604      	mov	r4, r0
   37b78:	2300      	movs	r3, #0
   37b7a:	461a      	mov	r2, r3
   37b7c:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   37b80:	f7ff ffe7 	bl	37b52 <dwt_write16bitoffsetreg>
   37b84:	2300      	movs	r3, #0
   37b86:	461a      	mov	r2, r3
   37b88:	4908      	ldr	r1, [pc, #32]	; (37bac <ull_clearaonconfig+0x38>)
   37b8a:	4620      	mov	r0, r4
   37b8c:	f7ff ff8f 	bl	37aae <dwt_write8bitoffsetreg>
   37b90:	4d07      	ldr	r5, [pc, #28]	; (37bb0 <ull_clearaonconfig+0x3c>)
   37b92:	2300      	movs	r3, #0
   37b94:	461a      	mov	r2, r3
   37b96:	4629      	mov	r1, r5
   37b98:	4620      	mov	r0, r4
   37b9a:	f7ff ff88 	bl	37aae <dwt_write8bitoffsetreg>
   37b9e:	2302      	movs	r3, #2
   37ba0:	2200      	movs	r2, #0
   37ba2:	4629      	mov	r1, r5
   37ba4:	4620      	mov	r0, r4
   37ba6:	f7ff ff82 	bl	37aae <dwt_write8bitoffsetreg>
   37baa:	bd38      	pop	{r3, r4, r5, pc}
   37bac:	000a0014 	.word	0x000a0014
   37bb0:	000a0004 	.word	0x000a0004

00037bb4 <ull_force_clocks>:
   37bb4:	b508      	push	{r3, lr}
   37bb6:	2901      	cmp	r1, #1
   37bb8:	d002      	beq.n	37bc0 <ull_force_clocks+0xc>
   37bba:	2905      	cmp	r1, #5
   37bbc:	d007      	beq.n	37bce <ull_force_clocks+0x1a>
   37bbe:	bd08      	pop	{r3, pc}
   37bc0:	f641 0322 	movw	r3, #6178	; 0x1822
   37bc4:	2200      	movs	r2, #0
   37bc6:	4905      	ldr	r1, [pc, #20]	; (37bdc <ull_force_clocks+0x28>)
   37bc8:	f7ff ffc3 	bl	37b52 <dwt_write16bitoffsetreg>
   37bcc:	e7f7      	b.n	37bbe <ull_force_clocks+0xa>
   37bce:	f44f 7300 	mov.w	r3, #512	; 0x200
   37bd2:	2200      	movs	r2, #0
   37bd4:	4901      	ldr	r1, [pc, #4]	; (37bdc <ull_force_clocks+0x28>)
   37bd6:	f7ff ffbc 	bl	37b52 <dwt_write16bitoffsetreg>
   37bda:	e7f0      	b.n	37bbe <ull_force_clocks+0xa>
   37bdc:	00110004 	.word	0x00110004

00037be0 <__dwt_otp_write_wdata_id_reg>:
   37be0:	b538      	push	{r3, r4, r5, lr}
   37be2:	4605      	mov	r5, r0
   37be4:	460c      	mov	r4, r1
   37be6:	f441 7300 	orr.w	r3, r1, #512	; 0x200
   37bea:	b29b      	uxth	r3, r3
   37bec:	2200      	movs	r2, #0
   37bee:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   37bf2:	f7ff ffae 	bl	37b52 <dwt_write16bitoffsetreg>
   37bf6:	b2a3      	uxth	r3, r4
   37bf8:	2200      	movs	r2, #0
   37bfa:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   37bfe:	4628      	mov	r0, r5
   37c00:	f7ff ffa7 	bl	37b52 <dwt_write16bitoffsetreg>
   37c04:	bd38      	pop	{r3, r4, r5, pc}
	...

00037c08 <_dwt_otpread>:
   37c08:	b570      	push	{r4, r5, r6, lr}
   37c0a:	4604      	mov	r4, r0
   37c0c:	460e      	mov	r6, r1
   37c0e:	4d0c      	ldr	r5, [pc, #48]	; (37c40 <_dwt_otpread+0x38>)
   37c10:	2301      	movs	r3, #1
   37c12:	2200      	movs	r2, #0
   37c14:	4629      	mov	r1, r5
   37c16:	f7ff ff9c 	bl	37b52 <dwt_write16bitoffsetreg>
   37c1a:	4633      	mov	r3, r6
   37c1c:	2200      	movs	r2, #0
   37c1e:	4909      	ldr	r1, [pc, #36]	; (37c44 <_dwt_otpread+0x3c>)
   37c20:	4620      	mov	r0, r4
   37c22:	f7ff ff96 	bl	37b52 <dwt_write16bitoffsetreg>
   37c26:	2302      	movs	r3, #2
   37c28:	2200      	movs	r2, #0
   37c2a:	4629      	mov	r1, r5
   37c2c:	4620      	mov	r0, r4
   37c2e:	f7ff ff90 	bl	37b52 <dwt_write16bitoffsetreg>
   37c32:	2200      	movs	r2, #0
   37c34:	4904      	ldr	r1, [pc, #16]	; (37c48 <_dwt_otpread+0x40>)
   37c36:	4620      	mov	r0, r4
   37c38:	f7ff fb4a 	bl	372d0 <dwt_read32bitoffsetreg>
   37c3c:	bd70      	pop	{r4, r5, r6, pc}
   37c3e:	bf00      	nop
   37c40:	000b0008 	.word	0x000b0008
   37c44:	000b0004 	.word	0x000b0004
   37c48:	000b0010 	.word	0x000b0010

00037c4c <ull_aon_read>:
   37c4c:	b538      	push	{r3, r4, r5, lr}
   37c4e:	4604      	mov	r4, r0
   37c50:	460b      	mov	r3, r1
   37c52:	2200      	movs	r2, #0
   37c54:	490a      	ldr	r1, [pc, #40]	; (37c80 <ull_aon_read+0x34>)
   37c56:	f7ff ff7c 	bl	37b52 <dwt_write16bitoffsetreg>
   37c5a:	4d0a      	ldr	r5, [pc, #40]	; (37c84 <ull_aon_read+0x38>)
   37c5c:	2388      	movs	r3, #136	; 0x88
   37c5e:	2200      	movs	r2, #0
   37c60:	4629      	mov	r1, r5
   37c62:	4620      	mov	r0, r4
   37c64:	f7ff ff23 	bl	37aae <dwt_write8bitoffsetreg>
   37c68:	2300      	movs	r3, #0
   37c6a:	461a      	mov	r2, r3
   37c6c:	4629      	mov	r1, r5
   37c6e:	4620      	mov	r0, r4
   37c70:	f7ff ff1d 	bl	37aae <dwt_write8bitoffsetreg>
   37c74:	2200      	movs	r2, #0
   37c76:	4904      	ldr	r1, [pc, #16]	; (37c88 <ull_aon_read+0x3c>)
   37c78:	4620      	mov	r0, r4
   37c7a:	f7ff fb51 	bl	37320 <dwt_read8bitoffsetreg>
   37c7e:	bd38      	pop	{r3, r4, r5, pc}
   37c80:	000a000c 	.word	0x000a000c
   37c84:	000a0004 	.word	0x000a0004
   37c88:	000a0008 	.word	0x000a0008

00037c8c <ull_aon_write>:
   37c8c:	b570      	push	{r4, r5, r6, lr}
   37c8e:	4604      	mov	r4, r0
   37c90:	460b      	mov	r3, r1
   37c92:	4615      	mov	r5, r2
   37c94:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   37c98:	bf34      	ite	cc
   37c9a:	2600      	movcc	r6, #0
   37c9c:	2620      	movcs	r6, #32
   37c9e:	2200      	movs	r2, #0
   37ca0:	490b      	ldr	r1, [pc, #44]	; (37cd0 <ull_aon_write+0x44>)
   37ca2:	f7ff ff56 	bl	37b52 <dwt_write16bitoffsetreg>
   37ca6:	462b      	mov	r3, r5
   37ca8:	2200      	movs	r2, #0
   37caa:	490a      	ldr	r1, [pc, #40]	; (37cd4 <ull_aon_write+0x48>)
   37cac:	4620      	mov	r0, r4
   37cae:	f7ff fefe 	bl	37aae <dwt_write8bitoffsetreg>
   37cb2:	4d09      	ldr	r5, [pc, #36]	; (37cd8 <ull_aon_write+0x4c>)
   37cb4:	f046 0390 	orr.w	r3, r6, #144	; 0x90
   37cb8:	2200      	movs	r2, #0
   37cba:	4629      	mov	r1, r5
   37cbc:	4620      	mov	r0, r4
   37cbe:	f7ff fef6 	bl	37aae <dwt_write8bitoffsetreg>
   37cc2:	2300      	movs	r3, #0
   37cc4:	461a      	mov	r2, r3
   37cc6:	4629      	mov	r1, r5
   37cc8:	4620      	mov	r0, r4
   37cca:	f7ff fef0 	bl	37aae <dwt_write8bitoffsetreg>
   37cce:	bd70      	pop	{r4, r5, r6, pc}
   37cd0:	000a000c 	.word	0x000a000c
   37cd4:	000a0010 	.word	0x000a0010
   37cd8:	000a0004 	.word	0x000a0004

00037cdc <ull_configuresleep>:
   37cdc:	b570      	push	{r4, r5, r6, lr}
   37cde:	4604      	mov	r4, r0
   37ce0:	460d      	mov	r5, r1
   37ce2:	4616      	mov	r6, r2
   37ce4:	2200      	movs	r2, #0
   37ce6:	f240 110b 	movw	r1, #267	; 0x10b
   37cea:	f7ff ffcf 	bl	37c8c <ull_aon_write>
   37cee:	f44f 7182 	mov.w	r1, #260	; 0x104
   37cf2:	4620      	mov	r0, r4
   37cf4:	f7ff ffaa 	bl	37c4c <ull_aon_read>
   37cf8:	f000 021f 	and.w	r2, r0, #31
   37cfc:	f44f 7182 	mov.w	r1, #260	; 0x104
   37d00:	4620      	mov	r0, r4
   37d02:	f7ff ffc3 	bl	37c8c <ull_aon_write>
   37d06:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37d08:	8a5a      	ldrh	r2, [r3, #18]
   37d0a:	4315      	orrs	r5, r2
   37d0c:	825d      	strh	r5, [r3, #18]
   37d0e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37d10:	8a5b      	ldrh	r3, [r3, #18]
   37d12:	2200      	movs	r2, #0
   37d14:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   37d18:	4620      	mov	r0, r4
   37d1a:	f7ff ff1a 	bl	37b52 <dwt_write16bitoffsetreg>
   37d1e:	4633      	mov	r3, r6
   37d20:	2200      	movs	r2, #0
   37d22:	4902      	ldr	r1, [pc, #8]	; (37d2c <ull_configuresleep+0x50>)
   37d24:	4620      	mov	r0, r4
   37d26:	f7ff fec2 	bl	37aae <dwt_write8bitoffsetreg>
   37d2a:	bd70      	pop	{r4, r5, r6, pc}
   37d2c:	000a0014 	.word	0x000a0014

00037d30 <ull_signal_rx_buff_free>:
   37d30:	b510      	push	{r4, lr}
   37d32:	b082      	sub	sp, #8
   37d34:	4604      	mov	r4, r0
   37d36:	2200      	movs	r2, #0
   37d38:	9200      	str	r2, [sp, #0]
   37d3a:	4613      	mov	r3, r2
   37d3c:	2113      	movs	r1, #19
   37d3e:	f7ff feab 	bl	37a98 <dwt_writetodevice>
   37d42:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37d44:	7bda      	ldrb	r2, [r3, #15]
   37d46:	2a03      	cmp	r2, #3
   37d48:	bf0c      	ite	eq
   37d4a:	2201      	moveq	r2, #1
   37d4c:	2203      	movne	r2, #3
   37d4e:	73da      	strb	r2, [r3, #15]
   37d50:	b002      	add	sp, #8
   37d52:	bd10      	pop	{r4, pc}

00037d54 <dwt_write32bitoffsetreg>:
   37d54:	b510      	push	{r4, lr}
   37d56:	b084      	sub	sp, #16
   37d58:	f88d 300c 	strb.w	r3, [sp, #12]
   37d5c:	0a1c      	lsrs	r4, r3, #8
   37d5e:	f88d 400d 	strb.w	r4, [sp, #13]
   37d62:	0c1c      	lsrs	r4, r3, #16
   37d64:	f88d 400e 	strb.w	r4, [sp, #14]
   37d68:	0e1b      	lsrs	r3, r3, #24
   37d6a:	f88d 300f 	strb.w	r3, [sp, #15]
   37d6e:	ab03      	add	r3, sp, #12
   37d70:	9300      	str	r3, [sp, #0]
   37d72:	2304      	movs	r3, #4
   37d74:	b292      	uxth	r2, r2
   37d76:	f7ff fe8f 	bl	37a98 <dwt_writetodevice>
   37d7a:	b004      	add	sp, #16
   37d7c:	bd10      	pop	{r4, pc}
	...

00037d80 <ull_isr>:
   37d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   37d82:	4604      	mov	r4, r0
   37d84:	2200      	movs	r2, #0
   37d86:	f44f 11f8 	mov.w	r1, #2031616	; 0x1f0000
   37d8a:	f7ff fac9 	bl	37320 <dwt_read8bitoffsetreg>
   37d8e:	4605      	mov	r5, r0
   37d90:	2200      	movs	r2, #0
   37d92:	2144      	movs	r1, #68	; 0x44
   37d94:	4620      	mov	r0, r4
   37d96:	f7ff fa9b 	bl	372d0 <dwt_read32bitoffsetreg>
   37d9a:	4606      	mov	r6, r0
   37d9c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37d9e:	2200      	movs	r2, #0
   37da0:	845a      	strh	r2, [r3, #34]	; 0x22
   37da2:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   37da6:	61da      	str	r2, [r3, #28]
   37da8:	841a      	strh	r2, [r3, #32]
   37daa:	629a      	str	r2, [r3, #40]	; 0x28
   37dac:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37dae:	629c      	str	r4, [r3, #40]	; 0x28
   37db0:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37db2:	61d8      	str	r0, [r3, #28]
   37db4:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37db6:	7dd3      	ldrb	r3, [r2, #23]
   37db8:	f003 0303 	and.w	r3, r3, #3
   37dbc:	2b03      	cmp	r3, #3
   37dbe:	d079      	beq.n	37eb4 <ull_isr+0x134>
   37dc0:	f416 6f80 	tst.w	r6, #1024	; 0x400
   37dc4:	d005      	beq.n	37dd2 <ull_isr+0x52>
   37dc6:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   37dca:	f043 0304 	orr.w	r3, r3, #4
   37dce:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   37dd2:	f015 0f80 	tst.w	r5, #128	; 0x80
   37dd6:	d174      	bne.n	37ec2 <ull_isr+0x142>
   37dd8:	f015 0f01 	tst.w	r5, #1
   37ddc:	f040 80a3 	bne.w	37f26 <ull_isr+0x1a6>
   37de0:	f015 0f40 	tst.w	r5, #64	; 0x40
   37de4:	d00b      	beq.n	37dfe <ull_isr+0x7e>
   37de6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   37de8:	b113      	cbz	r3, 37df0 <ull_isr+0x70>
   37dea:	6d20      	ldr	r0, [r4, #80]	; 0x50
   37dec:	301c      	adds	r0, #28
   37dee:	4798      	blx	r3
   37df0:	f44f 73c0 	mov.w	r3, #384	; 0x180
   37df4:	2202      	movs	r2, #2
   37df6:	2144      	movs	r1, #68	; 0x44
   37df8:	4620      	mov	r0, r4
   37dfa:	f7ff feaa 	bl	37b52 <dwt_write16bitoffsetreg>
   37dfe:	f015 0f08 	tst.w	r5, #8
   37e02:	f000 80ea 	beq.w	37fda <ull_isr+0x25a>
   37e06:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37e08:	2200      	movs	r2, #0
   37e0a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   37e0e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37e10:	7bdb      	ldrb	r3, [r3, #15]
   37e12:	2b00      	cmp	r3, #0
   37e14:	f040 8095 	bne.w	37f42 <ull_isr+0x1c2>
   37e18:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37e1a:	61de      	str	r6, [r3, #28]
   37e1c:	f416 2f80 	tst.w	r6, #262144	; 0x40000
   37e20:	f000 80a9 	beq.w	37f76 <ull_isr+0x1f6>
   37e24:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37e26:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   37e2a:	f043 0308 	orr.w	r3, r3, #8
   37e2e:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   37e32:	f44f 2780 	mov.w	r7, #262144	; 0x40000
   37e36:	f016 5f80 	tst.w	r6, #268435456	; 0x10000000
   37e3a:	d008      	beq.n	37e4e <ull_isr+0xce>
   37e3c:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37e3e:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   37e42:	f043 0310 	orr.w	r3, r3, #16
   37e46:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   37e4a:	f047 5780 	orr.w	r7, r7, #268435456	; 0x10000000
   37e4e:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   37e52:	d006      	beq.n	37e62 <ull_isr+0xe2>
   37e54:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37e56:	7dd3      	ldrb	r3, [r2, #23]
   37e58:	f003 0303 	and.w	r3, r3, #3
   37e5c:	2b03      	cmp	r3, #3
   37e5e:	f000 8096 	beq.w	37f8e <ull_isr+0x20e>
   37e62:	f416 4f80 	tst.w	r6, #16384	; 0x4000
   37e66:	f040 809e 	bne.w	37fa6 <ull_isr+0x226>
   37e6a:	f447 43de 	orr.w	r3, r7, #28416	; 0x6f00
   37e6e:	2200      	movs	r2, #0
   37e70:	2144      	movs	r1, #68	; 0x44
   37e72:	4620      	mov	r0, r4
   37e74:	f7ff ff6e 	bl	37d54 <dwt_write32bitoffsetreg>
   37e78:	6d20      	ldr	r0, [r4, #80]	; 0x50
   37e7a:	8c43      	ldrh	r3, [r0, #34]	; 0x22
   37e7c:	2b00      	cmp	r3, #0
   37e7e:	f040 80a1 	bne.w	37fc4 <ull_isr+0x244>
   37e82:	7dc3      	ldrb	r3, [r0, #23]
   37e84:	f003 0303 	and.w	r3, r3, #3
   37e88:	2b03      	cmp	r3, #3
   37e8a:	f000 809b 	beq.w	37fc4 <ull_isr+0x244>
   37e8e:	69c3      	ldr	r3, [r0, #28]
   37e90:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
   37e94:	61c3      	str	r3, [r0, #28]
   37e96:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37e98:	69d3      	ldr	r3, [r2, #28]
   37e9a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   37e9e:	61d3      	str	r3, [r2, #28]
   37ea0:	69e3      	ldr	r3, [r4, #28]
   37ea2:	b113      	cbz	r3, 37eaa <ull_isr+0x12a>
   37ea4:	6d20      	ldr	r0, [r4, #80]	; 0x50
   37ea6:	301c      	adds	r0, #28
   37ea8:	4798      	blx	r3
   37eaa:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37eac:	2200      	movs	r2, #0
   37eae:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   37eb2:	e08b      	b.n	37fcc <ull_isr+0x24c>
   37eb4:	f410 5f00 	tst.w	r0, #8192	; 0x2000
   37eb8:	bf1c      	itt	ne
   37eba:	f045 0508 	orrne.w	r5, r5, #8
   37ebe:	b2ed      	uxtbne	r5, r5
   37ec0:	e77e      	b.n	37dc0 <ull_isr+0x40>
   37ec2:	6d27      	ldr	r7, [r4, #80]	; 0x50
   37ec4:	2200      	movs	r2, #0
   37ec6:	2148      	movs	r1, #72	; 0x48
   37ec8:	4620      	mov	r0, r4
   37eca:	f7ff fa17 	bl	372fc <dwt_read16bitoffsetreg>
   37ece:	8438      	strh	r0, [r7, #32]
   37ed0:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37ed2:	7d9a      	ldrb	r2, [r3, #22]
   37ed4:	b11a      	cbz	r2, 37ede <ull_isr+0x15e>
   37ed6:	69da      	ldr	r2, [r3, #28]
   37ed8:	f012 0f04 	tst.w	r2, #4
   37edc:	d103      	bne.n	37ee6 <ull_isr+0x166>
   37ede:	8c1b      	ldrh	r3, [r3, #32]
   37ee0:	f403 6360 	and.w	r3, r3, #3584	; 0xe00
   37ee4:	b18b      	cbz	r3, 37f0a <ull_isr+0x18a>
   37ee6:	2304      	movs	r3, #4
   37ee8:	2200      	movs	r2, #0
   37eea:	2144      	movs	r1, #68	; 0x44
   37eec:	4620      	mov	r0, r4
   37eee:	f7ff fdde 	bl	37aae <dwt_write8bitoffsetreg>
   37ef2:	f44f 6360 	mov.w	r3, #3584	; 0xe00
   37ef6:	2200      	movs	r2, #0
   37ef8:	2148      	movs	r1, #72	; 0x48
   37efa:	4620      	mov	r0, r4
   37efc:	f7ff fe29 	bl	37b52 <dwt_write16bitoffsetreg>
   37f00:	6a23      	ldr	r3, [r4, #32]
   37f02:	b113      	cbz	r3, 37f0a <ull_isr+0x18a>
   37f04:	6d20      	ldr	r0, [r4, #80]	; 0x50
   37f06:	301c      	adds	r0, #28
   37f08:	4798      	blx	r3
   37f0a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37f0c:	8c1b      	ldrh	r3, [r3, #32]
   37f0e:	f413 7f80 	tst.w	r3, #256	; 0x100
   37f12:	f43f af61 	beq.w	37dd8 <ull_isr+0x58>
   37f16:	f44f 7380 	mov.w	r3, #256	; 0x100
   37f1a:	2200      	movs	r2, #0
   37f1c:	2148      	movs	r1, #72	; 0x48
   37f1e:	4620      	mov	r0, r4
   37f20:	f7ff fe17 	bl	37b52 <dwt_write16bitoffsetreg>
   37f24:	e758      	b.n	37dd8 <ull_isr+0x58>
   37f26:	23f8      	movs	r3, #248	; 0xf8
   37f28:	2200      	movs	r2, #0
   37f2a:	2144      	movs	r1, #68	; 0x44
   37f2c:	4620      	mov	r0, r4
   37f2e:	f7ff fdbe 	bl	37aae <dwt_write8bitoffsetreg>
   37f32:	6923      	ldr	r3, [r4, #16]
   37f34:	2b00      	cmp	r3, #0
   37f36:	f43f af53 	beq.w	37de0 <ull_isr+0x60>
   37f3a:	6d20      	ldr	r0, [r4, #80]	; 0x50
   37f3c:	301c      	adds	r0, #28
   37f3e:	4798      	blx	r3
   37f40:	e74e      	b.n	37de0 <ull_isr+0x60>
   37f42:	493b      	ldr	r1, [pc, #236]	; (38030 <ull_isr+0x2b0>)
   37f44:	4620      	mov	r0, r4
   37f46:	f7ff f9eb 	bl	37320 <dwt_read8bitoffsetreg>
   37f4a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37f4c:	7bdb      	ldrb	r3, [r3, #15]
   37f4e:	2b03      	cmp	r3, #3
   37f50:	bf08      	it	eq
   37f52:	f3c0 1007 	ubfxeq	r0, r0, #4, #8
   37f56:	f010 0f01 	tst.w	r0, #1
   37f5a:	bf18      	it	ne
   37f5c:	f446 4680 	orrne.w	r6, r6, #16384	; 0x4000
   37f60:	f010 0f02 	tst.w	r0, #2
   37f64:	bf18      	it	ne
   37f66:	f446 5600 	orrne.w	r6, r6, #8192	; 0x2000
   37f6a:	f010 0f04 	tst.w	r0, #4
   37f6e:	bf18      	it	ne
   37f70:	f446 6680 	orrne.w	r6, r6, #1024	; 0x400
   37f74:	e750      	b.n	37e18 <ull_isr+0x98>
   37f76:	f416 6f80 	tst.w	r6, #1024	; 0x400
   37f7a:	bf1f      	itttt	ne
   37f7c:	6d22      	ldrne	r2, [r4, #80]	; 0x50
   37f7e:	f892 3024 	ldrbne.w	r3, [r2, #36]	; 0x24
   37f82:	f043 0304 	orrne.w	r3, r3, #4
   37f86:	f882 3024 	strbne.w	r3, [r2, #36]	; 0x24
   37f8a:	2700      	movs	r7, #0
   37f8c:	e753      	b.n	37e36 <ull_isr+0xb6>
   37f8e:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   37f92:	f043 0302 	orr.w	r3, r3, #2
   37f96:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   37f9a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37f9c:	2200      	movs	r2, #0
   37f9e:	845a      	strh	r2, [r3, #34]	; 0x22
   37fa0:	f447 4700 	orr.w	r7, r7, #32768	; 0x8000
   37fa4:	e761      	b.n	37e6a <ull_isr+0xea>
   37fa6:	4620      	mov	r0, r4
   37fa8:	f7ff fd8e 	bl	37ac8 <ull_getframelength>
   37fac:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   37fb0:	f43f af5b 	beq.w	37e6a <ull_isr+0xea>
   37fb4:	6d22      	ldr	r2, [r4, #80]	; 0x50
   37fb6:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
   37fba:	f043 0301 	orr.w	r3, r3, #1
   37fbe:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
   37fc2:	e752      	b.n	37e6a <ull_isr+0xea>
   37fc4:	6963      	ldr	r3, [r4, #20]
   37fc6:	b10b      	cbz	r3, 37fcc <ull_isr+0x24c>
   37fc8:	301c      	adds	r0, #28
   37fca:	4798      	blx	r3
   37fcc:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37fce:	7bdb      	ldrb	r3, [r3, #15]
   37fd0:	b953      	cbnz	r3, 37fe8 <ull_isr+0x268>
   37fd2:	6d23      	ldr	r3, [r4, #80]	; 0x50
   37fd4:	2200      	movs	r2, #0
   37fd6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   37fda:	f015 0f10 	tst.w	r5, #16
   37fde:	d107      	bne.n	37ff0 <ull_isr+0x270>
   37fe0:	f015 0f20 	tst.w	r5, #32
   37fe4:	d114      	bne.n	38010 <ull_isr+0x290>
   37fe6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   37fe8:	4620      	mov	r0, r4
   37fea:	f7ff fea1 	bl	37d30 <ull_signal_rx_buff_free>
   37fee:	e7f0      	b.n	37fd2 <ull_isr+0x252>
   37ff0:	4b10      	ldr	r3, [pc, #64]	; (38034 <ull_isr+0x2b4>)
   37ff2:	2200      	movs	r2, #0
   37ff4:	2144      	movs	r1, #68	; 0x44
   37ff6:	4620      	mov	r0, r4
   37ff8:	f7ff feac 	bl	37d54 <dwt_write32bitoffsetreg>
   37ffc:	69e3      	ldr	r3, [r4, #28]
   37ffe:	b113      	cbz	r3, 38006 <ull_isr+0x286>
   38000:	6d20      	ldr	r0, [r4, #80]	; 0x50
   38002:	301c      	adds	r0, #28
   38004:	4798      	blx	r3
   38006:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38008:	2200      	movs	r2, #0
   3800a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   3800e:	e7e7      	b.n	37fe0 <ull_isr+0x260>
   38010:	4b09      	ldr	r3, [pc, #36]	; (38038 <ull_isr+0x2b8>)
   38012:	2200      	movs	r2, #0
   38014:	2144      	movs	r1, #68	; 0x44
   38016:	4620      	mov	r0, r4
   38018:	f7ff fe9c 	bl	37d54 <dwt_write32bitoffsetreg>
   3801c:	69a3      	ldr	r3, [r4, #24]
   3801e:	b113      	cbz	r3, 38026 <ull_isr+0x2a6>
   38020:	6d20      	ldr	r0, [r4, #80]	; 0x50
   38022:	301c      	adds	r0, #28
   38024:	4798      	blx	r3
   38026:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38028:	2200      	movs	r2, #0
   3802a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
   3802e:	e7da      	b.n	37fe6 <ull_isr+0x266>
   38030:	00010024 	.word	0x00010024
   38034:	34059400 	.word	0x34059400
   38038:	10220400 	.word	0x10220400

0003803c <_dwt_adjust_delaytime>:
   3803c:	b538      	push	{r3, r4, r5, lr}
   3803e:	4604      	mov	r4, r0
   38040:	b989      	cbnz	r1, 38066 <_dwt_adjust_delaytime+0x2a>
   38042:	2200      	movs	r2, #0
   38044:	212c      	movs	r1, #44	; 0x2c
   38046:	f7ff f943 	bl	372d0 <dwt_read32bitoffsetreg>
   3804a:	4605      	mov	r5, r0
   3804c:	2201      	movs	r2, #1
   3804e:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   38052:	4620      	mov	r0, r4
   38054:	f7ff f964 	bl	37320 <dwt_read8bitoffsetreg>
   38058:	1a2b      	subs	r3, r5, r0
   3805a:	2200      	movs	r2, #0
   3805c:	212c      	movs	r1, #44	; 0x2c
   3805e:	4620      	mov	r0, r4
   38060:	f7ff fe78 	bl	37d54 <dwt_write32bitoffsetreg>
   38064:	bd38      	pop	{r3, r4, r5, pc}
   38066:	2200      	movs	r2, #0
   38068:	212c      	movs	r1, #44	; 0x2c
   3806a:	f7ff f931 	bl	372d0 <dwt_read32bitoffsetreg>
   3806e:	4605      	mov	r5, r0
   38070:	2201      	movs	r2, #1
   38072:	4905      	ldr	r1, [pc, #20]	; (38088 <_dwt_adjust_delaytime+0x4c>)
   38074:	4620      	mov	r0, r4
   38076:	f7ff f953 	bl	37320 <dwt_read8bitoffsetreg>
   3807a:	1a2b      	subs	r3, r5, r0
   3807c:	2200      	movs	r2, #0
   3807e:	212c      	movs	r1, #44	; 0x2c
   38080:	4620      	mov	r0, r4
   38082:	f7ff fe67 	bl	37d54 <dwt_write32bitoffsetreg>
   38086:	e7ed      	b.n	38064 <_dwt_adjust_delaytime+0x28>
   38088:	00010004 	.word	0x00010004

0003808c <ull_setrxaftertxdelay>:
   3808c:	b570      	push	{r4, r5, r6, lr}
   3808e:	4606      	mov	r6, r0
   38090:	460c      	mov	r4, r1
   38092:	4d08      	ldr	r5, [pc, #32]	; (380b4 <ull_setrxaftertxdelay+0x28>)
   38094:	2200      	movs	r2, #0
   38096:	4629      	mov	r1, r5
   38098:	f7ff f91a 	bl	372d0 <dwt_read32bitoffsetreg>
   3809c:	0d00      	lsrs	r0, r0, #20
   3809e:	0500      	lsls	r0, r0, #20
   380a0:	f3c4 0313 	ubfx	r3, r4, #0, #20
   380a4:	4303      	orrs	r3, r0
   380a6:	2200      	movs	r2, #0
   380a8:	4629      	mov	r1, r5
   380aa:	4630      	mov	r0, r6
   380ac:	f7ff fe52 	bl	37d54 <dwt_write32bitoffsetreg>
   380b0:	bd70      	pop	{r4, r5, r6, pc}
   380b2:	bf00      	nop
   380b4:	00010008 	.word	0x00010008

000380b8 <ull_setlnapamode>:
   380b8:	b538      	push	{r3, r4, r5, lr}
   380ba:	4605      	mov	r5, r0
   380bc:	460c      	mov	r4, r1
   380be:	2200      	movs	r2, #0
   380c0:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   380c4:	f7ff f904 	bl	372d0 <dwt_read32bitoffsetreg>
   380c8:	4b0b      	ldr	r3, [pc, #44]	; (380f8 <ull_setlnapamode+0x40>)
   380ca:	4003      	ands	r3, r0
   380cc:	f014 0f01 	tst.w	r4, #1
   380d0:	bf18      	it	ne
   380d2:	f443 2380 	orrne.w	r3, r3, #262144	; 0x40000
   380d6:	f014 0f02 	tst.w	r4, #2
   380da:	bf18      	it	ne
   380dc:	f443 4310 	orrne.w	r3, r3, #36864	; 0x9000
   380e0:	f014 0f04 	tst.w	r4, #4
   380e4:	bf18      	it	ne
   380e6:	f043 0312 	orrne.w	r3, r3, #18
   380ea:	2200      	movs	r2, #0
   380ec:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   380f0:	4628      	mov	r0, r5
   380f2:	f7ff fe2f 	bl	37d54 <dwt_write32bitoffsetreg>
   380f6:	bd38      	pop	{r3, r4, r5, pc}
   380f8:	ffe00fc0 	.word	0xffe00fc0

000380fc <ull_configurestskey>:
   380fc:	b538      	push	{r3, r4, r5, lr}
   380fe:	4605      	mov	r5, r0
   38100:	460c      	mov	r4, r1
   38102:	680b      	ldr	r3, [r1, #0]
   38104:	2200      	movs	r2, #0
   38106:	490b      	ldr	r1, [pc, #44]	; (38134 <ull_configurestskey+0x38>)
   38108:	f7ff fe24 	bl	37d54 <dwt_write32bitoffsetreg>
   3810c:	6863      	ldr	r3, [r4, #4]
   3810e:	2200      	movs	r2, #0
   38110:	4909      	ldr	r1, [pc, #36]	; (38138 <ull_configurestskey+0x3c>)
   38112:	4628      	mov	r0, r5
   38114:	f7ff fe1e 	bl	37d54 <dwt_write32bitoffsetreg>
   38118:	68a3      	ldr	r3, [r4, #8]
   3811a:	2200      	movs	r2, #0
   3811c:	4907      	ldr	r1, [pc, #28]	; (3813c <ull_configurestskey+0x40>)
   3811e:	4628      	mov	r0, r5
   38120:	f7ff fe18 	bl	37d54 <dwt_write32bitoffsetreg>
   38124:	68e3      	ldr	r3, [r4, #12]
   38126:	2200      	movs	r2, #0
   38128:	4905      	ldr	r1, [pc, #20]	; (38140 <ull_configurestskey+0x44>)
   3812a:	4628      	mov	r0, r5
   3812c:	f7ff fe12 	bl	37d54 <dwt_write32bitoffsetreg>
   38130:	bd38      	pop	{r3, r4, r5, pc}
   38132:	bf00      	nop
   38134:	0002000c 	.word	0x0002000c
   38138:	00020010 	.word	0x00020010
   3813c:	00020014 	.word	0x00020014
   38140:	00020018 	.word	0x00020018

00038144 <ull_configurestsiv>:
   38144:	b538      	push	{r3, r4, r5, lr}
   38146:	4605      	mov	r5, r0
   38148:	460c      	mov	r4, r1
   3814a:	680b      	ldr	r3, [r1, #0]
   3814c:	2200      	movs	r2, #0
   3814e:	490b      	ldr	r1, [pc, #44]	; (3817c <ull_configurestsiv+0x38>)
   38150:	f7ff fe00 	bl	37d54 <dwt_write32bitoffsetreg>
   38154:	6863      	ldr	r3, [r4, #4]
   38156:	2200      	movs	r2, #0
   38158:	4909      	ldr	r1, [pc, #36]	; (38180 <ull_configurestsiv+0x3c>)
   3815a:	4628      	mov	r0, r5
   3815c:	f7ff fdfa 	bl	37d54 <dwt_write32bitoffsetreg>
   38160:	68a3      	ldr	r3, [r4, #8]
   38162:	2200      	movs	r2, #0
   38164:	4907      	ldr	r1, [pc, #28]	; (38184 <ull_configurestsiv+0x40>)
   38166:	4628      	mov	r0, r5
   38168:	f7ff fdf4 	bl	37d54 <dwt_write32bitoffsetreg>
   3816c:	68e3      	ldr	r3, [r4, #12]
   3816e:	2200      	movs	r2, #0
   38170:	4905      	ldr	r1, [pc, #20]	; (38188 <ull_configurestsiv+0x44>)
   38172:	4628      	mov	r0, r5
   38174:	f7ff fdee 	bl	37d54 <dwt_write32bitoffsetreg>
   38178:	bd38      	pop	{r3, r4, r5, pc}
   3817a:	bf00      	nop
   3817c:	0002001c 	.word	0x0002001c
   38180:	00020020 	.word	0x00020020
   38184:	00020024 	.word	0x00020024
   38188:	00020028 	.word	0x00020028

0003818c <ull_configmrxlut>:
   3818c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   38190:	4604      	mov	r4, r0
   38192:	2905      	cmp	r1, #5
   38194:	d040      	beq.n	38218 <ull_configmrxlut+0x8c>
   38196:	4d26      	ldr	r5, [pc, #152]	; (38230 <ull_configmrxlut+0xa4>)
   38198:	462e      	mov	r6, r5
   3819a:	4f26      	ldr	r7, [pc, #152]	; (38234 <ull_configmrxlut+0xa8>)
   3819c:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 38278 <ull_configmrxlut+0xec>
   381a0:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 3827c <ull_configmrxlut+0xf0>
   381a4:	f8df a0d8 	ldr.w	sl, [pc, #216]	; 38280 <ull_configmrxlut+0xf4>
   381a8:	4b23      	ldr	r3, [pc, #140]	; (38238 <ull_configmrxlut+0xac>)
   381aa:	2200      	movs	r2, #0
   381ac:	4923      	ldr	r1, [pc, #140]	; (3823c <ull_configmrxlut+0xb0>)
   381ae:	4620      	mov	r0, r4
   381b0:	f7ff fdd0 	bl	37d54 <dwt_write32bitoffsetreg>
   381b4:	4653      	mov	r3, sl
   381b6:	2200      	movs	r2, #0
   381b8:	4921      	ldr	r1, [pc, #132]	; (38240 <ull_configmrxlut+0xb4>)
   381ba:	4620      	mov	r0, r4
   381bc:	f7ff fdca 	bl	37d54 <dwt_write32bitoffsetreg>
   381c0:	464b      	mov	r3, r9
   381c2:	2200      	movs	r2, #0
   381c4:	491f      	ldr	r1, [pc, #124]	; (38244 <ull_configmrxlut+0xb8>)
   381c6:	4620      	mov	r0, r4
   381c8:	f7ff fdc4 	bl	37d54 <dwt_write32bitoffsetreg>
   381cc:	4643      	mov	r3, r8
   381ce:	2200      	movs	r2, #0
   381d0:	491d      	ldr	r1, [pc, #116]	; (38248 <ull_configmrxlut+0xbc>)
   381d2:	4620      	mov	r0, r4
   381d4:	f7ff fdbe 	bl	37d54 <dwt_write32bitoffsetreg>
   381d8:	463b      	mov	r3, r7
   381da:	2200      	movs	r2, #0
   381dc:	491b      	ldr	r1, [pc, #108]	; (3824c <ull_configmrxlut+0xc0>)
   381de:	4620      	mov	r0, r4
   381e0:	f7ff fdb8 	bl	37d54 <dwt_write32bitoffsetreg>
   381e4:	4633      	mov	r3, r6
   381e6:	2200      	movs	r2, #0
   381e8:	4919      	ldr	r1, [pc, #100]	; (38250 <ull_configmrxlut+0xc4>)
   381ea:	4620      	mov	r0, r4
   381ec:	f7ff fdb2 	bl	37d54 <dwt_write32bitoffsetreg>
   381f0:	462b      	mov	r3, r5
   381f2:	2200      	movs	r2, #0
   381f4:	4917      	ldr	r1, [pc, #92]	; (38254 <ull_configmrxlut+0xc8>)
   381f6:	4620      	mov	r0, r4
   381f8:	f7ff fdac 	bl	37d54 <dwt_write32bitoffsetreg>
   381fc:	4b16      	ldr	r3, [pc, #88]	; (38258 <ull_configmrxlut+0xcc>)
   381fe:	2200      	movs	r2, #0
   38200:	4916      	ldr	r1, [pc, #88]	; (3825c <ull_configmrxlut+0xd0>)
   38202:	4620      	mov	r0, r4
   38204:	f7ff fda6 	bl	37d54 <dwt_write32bitoffsetreg>
   38208:	4b15      	ldr	r3, [pc, #84]	; (38260 <ull_configmrxlut+0xd4>)
   3820a:	2200      	movs	r2, #0
   3820c:	4915      	ldr	r1, [pc, #84]	; (38264 <ull_configmrxlut+0xd8>)
   3820e:	4620      	mov	r0, r4
   38210:	f7ff fda0 	bl	37d54 <dwt_write32bitoffsetreg>
   38214:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   38218:	4d13      	ldr	r5, [pc, #76]	; (38268 <ull_configmrxlut+0xdc>)
   3821a:	4e14      	ldr	r6, [pc, #80]	; (3826c <ull_configmrxlut+0xe0>)
   3821c:	4f14      	ldr	r7, [pc, #80]	; (38270 <ull_configmrxlut+0xe4>)
   3821e:	f8df 8064 	ldr.w	r8, [pc, #100]	; 38284 <ull_configmrxlut+0xf8>
   38222:	f8df 9064 	ldr.w	r9, [pc, #100]	; 38288 <ull_configmrxlut+0xfc>
   38226:	f8df a064 	ldr.w	sl, [pc, #100]	; 3828c <ull_configmrxlut+0x100>
   3822a:	4b12      	ldr	r3, [pc, #72]	; (38274 <ull_configmrxlut+0xe8>)
   3822c:	e7bd      	b.n	381aa <ull_configmrxlut+0x1e>
   3822e:	bf00      	nop
   38230:	0002afb5 	.word	0x0002afb5
   38234:	0002af7d 	.word	0x0002af7d
   38238:	0002a8fe 	.word	0x0002a8fe
   3823c:	00030038 	.word	0x00030038
   38240:	0003003c 	.word	0x0003003c
   38244:	00030040 	.word	0x00030040
   38248:	00030044 	.word	0x00030044
   3824c:	00030048 	.word	0x00030048
   38250:	0003004c 	.word	0x0003004c
   38254:	00030050 	.word	0x00030050
   38258:	10000240 	.word	0x10000240
   3825c:	0003001c 	.word	0x0003001c
   38260:	1b6da489 	.word	0x1b6da489
   38264:	00030020 	.word	0x00030020
   38268:	0001cff5 	.word	0x0001cff5
   3826c:	0001cfb5 	.word	0x0001cfb5
   38270:	0001cf36 	.word	0x0001cf36
   38274:	0001c0fd 	.word	0x0001c0fd
   38278:	0002af3e 	.word	0x0002af3e
   3827c:	0002a5fe 	.word	0x0002a5fe
   38280:	0002ac36 	.word	0x0002ac36
   38284:	0001c77e 	.word	0x0001c77e
   38288:	0001c6be 	.word	0x0001c6be
   3828c:	0001c43e 	.word	0x0001c43e

00038290 <ull_disable_rftx_blocks>:
   38290:	b508      	push	{r3, lr}
   38292:	2300      	movs	r3, #0
   38294:	461a      	mov	r2, r3
   38296:	4902      	ldr	r1, [pc, #8]	; (382a0 <ull_disable_rftx_blocks+0x10>)
   38298:	f7ff fd5c 	bl	37d54 <dwt_write32bitoffsetreg>
   3829c:	bd08      	pop	{r3, pc}
   3829e:	bf00      	nop
   382a0:	00070004 	.word	0x00070004

000382a4 <ull_disable_rf_tx>:
   382a4:	b538      	push	{r3, r4, r5, lr}
   382a6:	4604      	mov	r4, r0
   382a8:	460d      	mov	r5, r1
   382aa:	2300      	movs	r3, #0
   382ac:	461a      	mov	r2, r3
   382ae:	490a      	ldr	r1, [pc, #40]	; (382d8 <ull_disable_rf_tx+0x34>)
   382b0:	f7ff fd50 	bl	37d54 <dwt_write32bitoffsetreg>
   382b4:	2300      	movs	r3, #0
   382b6:	461a      	mov	r2, r3
   382b8:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   382bc:	4620      	mov	r0, r4
   382be:	f7ff fd49 	bl	37d54 <dwt_write32bitoffsetreg>
   382c2:	b905      	cbnz	r5, 382c6 <ull_disable_rf_tx+0x22>
   382c4:	bd38      	pop	{r3, r4, r5, pc}
   382c6:	f04f 53e0 	mov.w	r3, #469762048	; 0x1c000000
   382ca:	2200      	movs	r2, #0
   382cc:	4903      	ldr	r1, [pc, #12]	; (382dc <ull_disable_rf_tx+0x38>)
   382ce:	4620      	mov	r0, r4
   382d0:	f7ff fd40 	bl	37d54 <dwt_write32bitoffsetreg>
   382d4:	e7f6      	b.n	382c4 <ull_disable_rf_tx+0x20>
   382d6:	bf00      	nop
   382d8:	00070048 	.word	0x00070048
   382dc:	00070014 	.word	0x00070014

000382e0 <ull_readrxdata>:
   382e0:	b5f0      	push	{r4, r5, r6, r7, lr}
   382e2:	b083      	sub	sp, #12
   382e4:	6d04      	ldr	r4, [r0, #80]	; 0x50
   382e6:	7be4      	ldrb	r4, [r4, #15]
   382e8:	2c03      	cmp	r4, #3
   382ea:	bf0c      	ite	eq
   382ec:	f44f 1c98 	moveq.w	ip, #1245184	; 0x130000
   382f0:	f44f 1c90 	movne.w	ip, #1179648	; 0x120000
   382f4:	189c      	adds	r4, r3, r2
   382f6:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   382fa:	da19      	bge.n	38330 <ull_readrxdata+0x50>
   382fc:	461d      	mov	r5, r3
   382fe:	4616      	mov	r6, r2
   38300:	460f      	mov	r7, r1
   38302:	4604      	mov	r4, r0
   38304:	2b7f      	cmp	r3, #127	; 0x7f
   38306:	d915      	bls.n	38334 <ull_readrxdata+0x54>
   38308:	ea4f 431c 	mov.w	r3, ip, lsr #16
   3830c:	2200      	movs	r2, #0
   3830e:	490d      	ldr	r1, [pc, #52]	; (38344 <ull_readrxdata+0x64>)
   38310:	f7ff fd20 	bl	37d54 <dwt_write32bitoffsetreg>
   38314:	462b      	mov	r3, r5
   38316:	2200      	movs	r2, #0
   38318:	490b      	ldr	r1, [pc, #44]	; (38348 <ull_readrxdata+0x68>)
   3831a:	4620      	mov	r0, r4
   3831c:	f7ff fd1a 	bl	37d54 <dwt_write32bitoffsetreg>
   38320:	9700      	str	r7, [sp, #0]
   38322:	4633      	mov	r3, r6
   38324:	2200      	movs	r2, #0
   38326:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3832a:	4620      	mov	r0, r4
   3832c:	f7fe ffc6 	bl	372bc <dwt_readfromdevice>
   38330:	b003      	add	sp, #12
   38332:	bdf0      	pop	{r4, r5, r6, r7, pc}
   38334:	9100      	str	r1, [sp, #0]
   38336:	4613      	mov	r3, r2
   38338:	462a      	mov	r2, r5
   3833a:	4661      	mov	r1, ip
   3833c:	f7fe ffbe 	bl	372bc <dwt_readfromdevice>
   38340:	e7f6      	b.n	38330 <ull_readrxdata+0x50>
   38342:	bf00      	nop
   38344:	001f0004 	.word	0x001f0004
   38348:	001f0008 	.word	0x001f0008

0003834c <ull_rxenable>:
   3834c:	b530      	push	{r4, r5, lr}
   3834e:	b083      	sub	sp, #12
   38350:	4605      	mov	r5, r0
   38352:	460c      	mov	r4, r1
   38354:	b171      	cbz	r1, 38374 <ull_rxenable+0x28>
   38356:	f021 0302 	bic.w	r3, r1, #2
   3835a:	3b01      	subs	r3, #1
   3835c:	2b0f      	cmp	r3, #15
   3835e:	d856      	bhi.n	3840e <ull_rxenable+0xc2>
   38360:	e8df f003 	tbb	[pc, r3]
   38364:	21555510 	.word	0x21555510
   38368:	28555555 	.word	0x28555555
   3836c:	55555555 	.word	0x55555555
   38370:	33555555 	.word	0x33555555
   38374:	2200      	movs	r2, #0
   38376:	9200      	str	r2, [sp, #0]
   38378:	4613      	mov	r3, r2
   3837a:	2102      	movs	r1, #2
   3837c:	f7ff fb8c 	bl	37a98 <dwt_writetodevice>
   38380:	4620      	mov	r0, r4
   38382:	e00e      	b.n	383a2 <ull_rxenable+0x56>
   38384:	2200      	movs	r2, #0
   38386:	9200      	str	r2, [sp, #0]
   38388:	4613      	mov	r3, r2
   3838a:	2104      	movs	r1, #4
   3838c:	f7ff fb84 	bl	37a98 <dwt_writetodevice>
   38390:	2203      	movs	r2, #3
   38392:	2144      	movs	r1, #68	; 0x44
   38394:	4628      	mov	r0, r5
   38396:	f7fe ffc3 	bl	37320 <dwt_read8bitoffsetreg>
   3839a:	f010 0f08 	tst.w	r0, #8
   3839e:	d11f      	bne.n	383e0 <ull_rxenable+0x94>
   383a0:	2000      	movs	r0, #0
   383a2:	b003      	add	sp, #12
   383a4:	bd30      	pop	{r4, r5, pc}
   383a6:	2200      	movs	r2, #0
   383a8:	9200      	str	r2, [sp, #0]
   383aa:	4613      	mov	r3, r2
   383ac:	210a      	movs	r1, #10
   383ae:	f7ff fb73 	bl	37a98 <dwt_writetodevice>
   383b2:	e7ed      	b.n	38390 <ull_rxenable+0x44>
   383b4:	2100      	movs	r1, #0
   383b6:	f7ff fe41 	bl	3803c <_dwt_adjust_delaytime>
   383ba:	2200      	movs	r2, #0
   383bc:	9200      	str	r2, [sp, #0]
   383be:	4613      	mov	r3, r2
   383c0:	2108      	movs	r1, #8
   383c2:	4628      	mov	r0, r5
   383c4:	f7ff fb68 	bl	37a98 <dwt_writetodevice>
   383c8:	e7e2      	b.n	38390 <ull_rxenable+0x44>
   383ca:	2101      	movs	r1, #1
   383cc:	f7ff fe36 	bl	3803c <_dwt_adjust_delaytime>
   383d0:	2200      	movs	r2, #0
   383d2:	9200      	str	r2, [sp, #0]
   383d4:	4613      	mov	r3, r2
   383d6:	2106      	movs	r1, #6
   383d8:	4628      	mov	r0, r5
   383da:	f7ff fb5d 	bl	37a98 <dwt_writetodevice>
   383de:	e7d7      	b.n	38390 <ull_rxenable+0x44>
   383e0:	2100      	movs	r1, #0
   383e2:	9100      	str	r1, [sp, #0]
   383e4:	460b      	mov	r3, r1
   383e6:	460a      	mov	r2, r1
   383e8:	4628      	mov	r0, r5
   383ea:	f7ff fb55 	bl	37a98 <dwt_writetodevice>
   383ee:	f014 0f02 	tst.w	r4, #2
   383f2:	d002      	beq.n	383fa <ull_rxenable+0xae>
   383f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   383f8:	e7d3      	b.n	383a2 <ull_rxenable+0x56>
   383fa:	2200      	movs	r2, #0
   383fc:	9200      	str	r2, [sp, #0]
   383fe:	4613      	mov	r3, r2
   38400:	2102      	movs	r1, #2
   38402:	4628      	mov	r0, r5
   38404:	f7ff fb48 	bl	37a98 <dwt_writetodevice>
   38408:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3840c:	e7c9      	b.n	383a2 <ull_rxenable+0x56>
   3840e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   38412:	e7c6      	b.n	383a2 <ull_rxenable+0x56>

00038414 <ull_writetxdata>:
   38414:	b5f0      	push	{r4, r5, r6, r7, lr}
   38416:	b083      	sub	sp, #12
   38418:	185c      	adds	r4, r3, r1
   3841a:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   3841e:	da24      	bge.n	3846a <ull_writetxdata+0x56>
   38420:	461c      	mov	r4, r3
   38422:	4617      	mov	r7, r2
   38424:	460e      	mov	r6, r1
   38426:	4605      	mov	r5, r0
   38428:	2b7f      	cmp	r3, #127	; 0x7f
   3842a:	d915      	bls.n	38458 <ull_writetxdata+0x44>
   3842c:	2314      	movs	r3, #20
   3842e:	2200      	movs	r2, #0
   38430:	490f      	ldr	r1, [pc, #60]	; (38470 <ull_writetxdata+0x5c>)
   38432:	f7ff fc8f 	bl	37d54 <dwt_write32bitoffsetreg>
   38436:	4623      	mov	r3, r4
   38438:	2200      	movs	r2, #0
   3843a:	490e      	ldr	r1, [pc, #56]	; (38474 <ull_writetxdata+0x60>)
   3843c:	4628      	mov	r0, r5
   3843e:	f7ff fc89 	bl	37d54 <dwt_write32bitoffsetreg>
   38442:	9700      	str	r7, [sp, #0]
   38444:	4633      	mov	r3, r6
   38446:	2200      	movs	r2, #0
   38448:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3844c:	4628      	mov	r0, r5
   3844e:	f7ff fb23 	bl	37a98 <dwt_writetodevice>
   38452:	2000      	movs	r0, #0
   38454:	b003      	add	sp, #12
   38456:	bdf0      	pop	{r4, r5, r6, r7, pc}
   38458:	9200      	str	r2, [sp, #0]
   3845a:	460b      	mov	r3, r1
   3845c:	4622      	mov	r2, r4
   3845e:	f44f 11a0 	mov.w	r1, #1310720	; 0x140000
   38462:	f7ff fb19 	bl	37a98 <dwt_writetodevice>
   38466:	2000      	movs	r0, #0
   38468:	e7f4      	b.n	38454 <ull_writetxdata+0x40>
   3846a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3846e:	e7f1      	b.n	38454 <ull_writetxdata+0x40>
   38470:	001f0004 	.word	0x001f0004
   38474:	001f0008 	.word	0x001f0008

00038478 <dwt_modify32bitoffsetreg>:
   38478:	b530      	push	{r4, r5, lr}
   3847a:	b085      	sub	sp, #20
   3847c:	9c08      	ldr	r4, [sp, #32]
   3847e:	f88d 3008 	strb.w	r3, [sp, #8]
   38482:	0a1d      	lsrs	r5, r3, #8
   38484:	f88d 5009 	strb.w	r5, [sp, #9]
   38488:	0c1d      	lsrs	r5, r3, #16
   3848a:	f88d 500a 	strb.w	r5, [sp, #10]
   3848e:	0e1b      	lsrs	r3, r3, #24
   38490:	f88d 300b 	strb.w	r3, [sp, #11]
   38494:	f88d 400c 	strb.w	r4, [sp, #12]
   38498:	0a23      	lsrs	r3, r4, #8
   3849a:	f88d 300d 	strb.w	r3, [sp, #13]
   3849e:	0c23      	lsrs	r3, r4, #16
   384a0:	f88d 300e 	strb.w	r3, [sp, #14]
   384a4:	0e24      	lsrs	r4, r4, #24
   384a6:	f88d 400f 	strb.w	r4, [sp, #15]
   384aa:	f248 0303 	movw	r3, #32771	; 0x8003
   384ae:	9301      	str	r3, [sp, #4]
   384b0:	ab02      	add	r3, sp, #8
   384b2:	9300      	str	r3, [sp, #0]
   384b4:	2308      	movs	r3, #8
   384b6:	b292      	uxth	r2, r2
   384b8:	f7fe fe7d 	bl	371b6 <dwt_xfer3xxx>
   384bc:	b005      	add	sp, #20
   384be:	bd30      	pop	{r4, r5, pc}

000384c0 <_dwt_kick_dgc_on_wakeup>:
   384c0:	b500      	push	{lr}
   384c2:	b083      	sub	sp, #12
   384c4:	2905      	cmp	r1, #5
   384c6:	d004      	beq.n	384d2 <_dwt_kick_dgc_on_wakeup+0x12>
   384c8:	2909      	cmp	r1, #9
   384ca:	d00b      	beq.n	384e4 <_dwt_kick_dgc_on_wakeup+0x24>
   384cc:	b003      	add	sp, #12
   384ce:	f85d fb04 	ldr.w	pc, [sp], #4
   384d2:	2340      	movs	r3, #64	; 0x40
   384d4:	9300      	str	r3, [sp, #0]
   384d6:	f46f 5300 	mvn.w	r3, #8192	; 0x2000
   384da:	2200      	movs	r2, #0
   384dc:	4906      	ldr	r1, [pc, #24]	; (384f8 <_dwt_kick_dgc_on_wakeup+0x38>)
   384de:	f7ff ffcb 	bl	38478 <dwt_modify32bitoffsetreg>
   384e2:	e7f3      	b.n	384cc <_dwt_kick_dgc_on_wakeup+0xc>
   384e4:	f44f 5301 	mov.w	r3, #8256	; 0x2040
   384e8:	9300      	str	r3, [sp, #0]
   384ea:	f46f 5300 	mvn.w	r3, #8192	; 0x2000
   384ee:	2200      	movs	r2, #0
   384f0:	4901      	ldr	r1, [pc, #4]	; (384f8 <_dwt_kick_dgc_on_wakeup+0x38>)
   384f2:	f7ff ffc1 	bl	38478 <dwt_modify32bitoffsetreg>
   384f6:	e7e9      	b.n	384cc <_dwt_kick_dgc_on_wakeup+0xc>
   384f8:	000b0008 	.word	0x000b0008

000384fc <ull_enable_rf_tx>:
   384fc:	b570      	push	{r4, r5, r6, lr}
   384fe:	b082      	sub	sp, #8
   38500:	4604      	mov	r4, r0
   38502:	460e      	mov	r6, r1
   38504:	4d13      	ldr	r5, [pc, #76]	; (38554 <ull_enable_rf_tx+0x58>)
   38506:	f04f 2308 	mov.w	r3, #134219776	; 0x8000800
   3850a:	9300      	str	r3, [sp, #0]
   3850c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38510:	2200      	movs	r2, #0
   38512:	4629      	mov	r1, r5
   38514:	f7ff ffb0 	bl	38478 <dwt_modify32bitoffsetreg>
   38518:	f04f 1360 	mov.w	r3, #6291552	; 0x600060
   3851c:	9300      	str	r3, [sp, #0]
   3851e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38522:	2200      	movs	r2, #0
   38524:	4629      	mov	r1, r5
   38526:	4620      	mov	r0, r4
   38528:	f7ff ffa6 	bl	38478 <dwt_modify32bitoffsetreg>
   3852c:	4b0a      	ldr	r3, [pc, #40]	; (38558 <ull_enable_rf_tx+0x5c>)
   3852e:	9300      	str	r3, [sp, #0]
   38530:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38534:	2200      	movs	r2, #0
   38536:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   3853a:	4620      	mov	r0, r4
   3853c:	f7ff ff9c 	bl	38478 <dwt_modify32bitoffsetreg>
   38540:	b90e      	cbnz	r6, 38546 <ull_enable_rf_tx+0x4a>
   38542:	b002      	add	sp, #8
   38544:	bd70      	pop	{r4, r5, r6, pc}
   38546:	4b05      	ldr	r3, [pc, #20]	; (3855c <ull_enable_rf_tx+0x60>)
   38548:	2200      	movs	r2, #0
   3854a:	4905      	ldr	r1, [pc, #20]	; (38560 <ull_enable_rf_tx+0x64>)
   3854c:	4620      	mov	r0, r4
   3854e:	f7ff fc01 	bl	37d54 <dwt_write32bitoffsetreg>
   38552:	e7f6      	b.n	38542 <ull_enable_rf_tx+0x46>
   38554:	00070048 	.word	0x00070048
   38558:	02003c00 	.word	0x02003c00
   3855c:	01011100 	.word	0x01011100
   38560:	00070014 	.word	0x00070014

00038564 <ull_enable_rftx_blocks>:
   38564:	b500      	push	{lr}
   38566:	b083      	sub	sp, #12
   38568:	4b05      	ldr	r3, [pc, #20]	; (38580 <ull_enable_rftx_blocks+0x1c>)
   3856a:	9300      	str	r3, [sp, #0]
   3856c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38570:	2200      	movs	r2, #0
   38572:	4904      	ldr	r1, [pc, #16]	; (38584 <ull_enable_rftx_blocks+0x20>)
   38574:	f7ff ff80 	bl	38478 <dwt_modify32bitoffsetreg>
   38578:	b003      	add	sp, #12
   3857a:	f85d fb04 	ldr.w	pc, [sp], #4
   3857e:	bf00      	nop
   38580:	02003c00 	.word	0x02003c00
   38584:	00070004 	.word	0x00070004

00038588 <_dwt_otpprogword32>:
   38588:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3858c:	b083      	sub	sp, #12
   3858e:	4604      	mov	r4, r0
   38590:	460d      	mov	r5, r1
   38592:	4617      	mov	r7, r2
   38594:	4e56      	ldr	r6, [pc, #344]	; (386f0 <_dwt_otpprogword32+0x168>)
   38596:	2200      	movs	r2, #0
   38598:	4631      	mov	r1, r6
   3859a:	f7fe fe99 	bl	372d0 <dwt_read32bitoffsetreg>
   3859e:	4681      	mov	r9, r0
   385a0:	f44f 4370 	mov.w	r3, #61440	; 0xf000
   385a4:	9300      	str	r3, [sp, #0]
   385a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   385aa:	2200      	movs	r2, #0
   385ac:	4631      	mov	r1, r6
   385ae:	4620      	mov	r0, r4
   385b0:	f7ff ff62 	bl	38478 <dwt_modify32bitoffsetreg>
   385b4:	f8df 813c 	ldr.w	r8, [pc, #316]	; 386f4 <_dwt_otpprogword32+0x16c>
   385b8:	2318      	movs	r3, #24
   385ba:	2200      	movs	r2, #0
   385bc:	4641      	mov	r1, r8
   385be:	4620      	mov	r0, r4
   385c0:	f7ff fac7 	bl	37b52 <dwt_write16bitoffsetreg>
   385c4:	2125      	movs	r1, #37	; 0x25
   385c6:	4620      	mov	r0, r4
   385c8:	f7ff fb0a 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385cc:	2102      	movs	r1, #2
   385ce:	4620      	mov	r0, r4
   385d0:	f7ff fb06 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385d4:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
   385d8:	4620      	mov	r0, r4
   385da:	f7ff fb01 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385de:	b2f9      	uxtb	r1, r7
   385e0:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   385e4:	4620      	mov	r0, r4
   385e6:	f7ff fafb 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385ea:	f44f 7180 	mov.w	r1, #256	; 0x100
   385ee:	4620      	mov	r0, r4
   385f0:	f7ff faf6 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385f4:	2100      	movs	r1, #0
   385f6:	4620      	mov	r0, r4
   385f8:	f7ff faf2 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   385fc:	2102      	movs	r1, #2
   385fe:	4620      	mov	r0, r4
   38600:	f7ff faee 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38604:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
   38608:	4620      	mov	r0, r4
   3860a:	f7ff fae9 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   3860e:	b2e9      	uxtb	r1, r5
   38610:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   38614:	4620      	mov	r0, r4
   38616:	f7ff fae3 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   3861a:	f3c5 2107 	ubfx	r1, r5, #8, #8
   3861e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   38622:	4620      	mov	r0, r4
   38624:	f7ff fadc 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38628:	f3c5 4107 	ubfx	r1, r5, #16, #8
   3862c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   38630:	4620      	mov	r0, r4
   38632:	f7ff fad5 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38636:	0e29      	lsrs	r1, r5, #24
   38638:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3863c:	4620      	mov	r0, r4
   3863e:	f7ff facf 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38642:	2100      	movs	r1, #0
   38644:	4620      	mov	r0, r4
   38646:	f7ff facb 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   3864a:	213a      	movs	r1, #58	; 0x3a
   3864c:	4620      	mov	r0, r4
   3864e:	f7ff fac7 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38652:	f240 11ff 	movw	r1, #511	; 0x1ff
   38656:	4620      	mov	r0, r4
   38658:	f7ff fac2 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   3865c:	f44f 7185 	mov.w	r1, #266	; 0x10a
   38660:	4620      	mov	r0, r4
   38662:	f7ff fabd 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38666:	2100      	movs	r1, #0
   38668:	4620      	mov	r0, r4
   3866a:	f7ff fab9 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   3866e:	213a      	movs	r1, #58	; 0x3a
   38670:	4620      	mov	r0, r4
   38672:	f7ff fab5 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38676:	f240 1101 	movw	r1, #257	; 0x101
   3867a:	4620      	mov	r0, r4
   3867c:	f7ff fab0 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   38680:	2302      	movs	r3, #2
   38682:	2200      	movs	r2, #0
   38684:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   38688:	4620      	mov	r0, r4
   3868a:	f7ff fa62 	bl	37b52 <dwt_write16bitoffsetreg>
   3868e:	2300      	movs	r3, #0
   38690:	461a      	mov	r2, r3
   38692:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   38696:	4620      	mov	r0, r4
   38698:	f7ff fa5b 	bl	37b52 <dwt_write16bitoffsetreg>
   3869c:	2002      	movs	r0, #2
   3869e:	f7f6 f896 	bl	2e7ce <deca_sleep>
   386a2:	213a      	movs	r1, #58	; 0x3a
   386a4:	4620      	mov	r0, r4
   386a6:	f7ff fa9b 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   386aa:	f44f 7181 	mov.w	r1, #258	; 0x102
   386ae:	4620      	mov	r0, r4
   386b0:	f7ff fa96 	bl	37be0 <__dwt_otp_write_wdata_id_reg>
   386b4:	2302      	movs	r3, #2
   386b6:	2200      	movs	r2, #0
   386b8:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   386bc:	4620      	mov	r0, r4
   386be:	f7ff fa48 	bl	37b52 <dwt_write16bitoffsetreg>
   386c2:	2300      	movs	r3, #0
   386c4:	461a      	mov	r2, r3
   386c6:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   386ca:	4620      	mov	r0, r4
   386cc:	f7ff fa41 	bl	37b52 <dwt_write16bitoffsetreg>
   386d0:	2300      	movs	r3, #0
   386d2:	461a      	mov	r2, r3
   386d4:	4641      	mov	r1, r8
   386d6:	4620      	mov	r0, r4
   386d8:	f7ff fa3b 	bl	37b52 <dwt_write16bitoffsetreg>
   386dc:	464b      	mov	r3, r9
   386de:	2200      	movs	r2, #0
   386e0:	4631      	mov	r1, r6
   386e2:	4620      	mov	r0, r4
   386e4:	f7ff fb36 	bl	37d54 <dwt_write32bitoffsetreg>
   386e8:	b003      	add	sp, #12
   386ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   386ee:	bf00      	nop
   386f0:	00070044 	.word	0x00070044
   386f4:	000b0008 	.word	0x000b0008

000386f8 <ull_setgpiomode>:
   386f8:	b5f0      	push	{r4, r5, r6, r7, lr}
   386fa:	b083      	sub	sp, #12
   386fc:	2400      	movs	r4, #0
   386fe:	4623      	mov	r3, r4
   38700:	2601      	movs	r6, #1
   38702:	2707      	movs	r7, #7
   38704:	e002      	b.n	3870c <ull_setgpiomode+0x14>
   38706:	3401      	adds	r4, #1
   38708:	2c09      	cmp	r4, #9
   3870a:	d009      	beq.n	38720 <ull_setgpiomode+0x28>
   3870c:	fa06 f504 	lsl.w	r5, r6, r4
   38710:	420d      	tst	r5, r1
   38712:	d0f8      	beq.n	38706 <ull_setgpiomode+0xe>
   38714:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   38718:	fa07 f505 	lsl.w	r5, r7, r5
   3871c:	432b      	orrs	r3, r5
   3871e:	e7f2      	b.n	38706 <ull_setgpiomode+0xe>
   38720:	401a      	ands	r2, r3
   38722:	9200      	str	r2, [sp, #0]
   38724:	43db      	mvns	r3, r3
   38726:	2200      	movs	r2, #0
   38728:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3872c:	f7ff fea4 	bl	38478 <dwt_modify32bitoffsetreg>
   38730:	b003      	add	sp, #12
   38732:	bdf0      	pop	{r4, r5, r6, r7, pc}

00038734 <ull_setinterrupt>:
   38734:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   38738:	b082      	sub	sp, #8
   3873a:	4604      	mov	r4, r0
   3873c:	4688      	mov	r8, r1
   3873e:	4617      	mov	r7, r2
   38740:	461d      	mov	r5, r3
   38742:	f7f6 f831 	bl	2e7a8 <decamutexon>
   38746:	4606      	mov	r6, r0
   38748:	2d02      	cmp	r5, #2
   3874a:	d02d      	beq.n	387a8 <ull_setinterrupt+0x74>
   3874c:	2d01      	cmp	r5, #1
   3874e:	d038      	beq.n	387c2 <ull_setinterrupt+0x8e>
   38750:	2500      	movs	r5, #0
   38752:	9500      	str	r5, [sp, #0]
   38754:	ea6f 0308 	mvn.w	r3, r8
   38758:	462a      	mov	r2, r5
   3875a:	213c      	movs	r1, #60	; 0x3c
   3875c:	4620      	mov	r0, r4
   3875e:	f7ff fe8b 	bl	38478 <dwt_modify32bitoffsetreg>
   38762:	9500      	str	r5, [sp, #0]
   38764:	43fb      	mvns	r3, r7
   38766:	462a      	mov	r2, r5
   38768:	2140      	movs	r1, #64	; 0x40
   3876a:	4620      	mov	r0, r4
   3876c:	f7ff fe84 	bl	38478 <dwt_modify32bitoffsetreg>
   38770:	2200      	movs	r2, #0
   38772:	213c      	movs	r1, #60	; 0x3c
   38774:	4620      	mov	r0, r4
   38776:	f7fe fdab 	bl	372d0 <dwt_read32bitoffsetreg>
   3877a:	4603      	mov	r3, r0
   3877c:	2200      	movs	r2, #0
   3877e:	2144      	movs	r1, #68	; 0x44
   38780:	4620      	mov	r0, r4
   38782:	f7ff fae7 	bl	37d54 <dwt_write32bitoffsetreg>
   38786:	2200      	movs	r2, #0
   38788:	2140      	movs	r1, #64	; 0x40
   3878a:	4620      	mov	r0, r4
   3878c:	f7fe fda0 	bl	372d0 <dwt_read32bitoffsetreg>
   38790:	4603      	mov	r3, r0
   38792:	2200      	movs	r2, #0
   38794:	2148      	movs	r1, #72	; 0x48
   38796:	4620      	mov	r0, r4
   38798:	f7ff fadc 	bl	37d54 <dwt_write32bitoffsetreg>
   3879c:	4630      	mov	r0, r6
   3879e:	f7f6 f80a 	bl	2e7b6 <decamutexoff>
   387a2:	b002      	add	sp, #8
   387a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   387a8:	4643      	mov	r3, r8
   387aa:	2200      	movs	r2, #0
   387ac:	213c      	movs	r1, #60	; 0x3c
   387ae:	4620      	mov	r0, r4
   387b0:	f7ff fad0 	bl	37d54 <dwt_write32bitoffsetreg>
   387b4:	463b      	mov	r3, r7
   387b6:	2200      	movs	r2, #0
   387b8:	2140      	movs	r1, #64	; 0x40
   387ba:	4620      	mov	r0, r4
   387bc:	f7ff faca 	bl	37d54 <dwt_write32bitoffsetreg>
   387c0:	e7d6      	b.n	38770 <ull_setinterrupt+0x3c>
   387c2:	f8cd 8000 	str.w	r8, [sp]
   387c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   387ca:	2200      	movs	r2, #0
   387cc:	213c      	movs	r1, #60	; 0x3c
   387ce:	4620      	mov	r0, r4
   387d0:	f7ff fe52 	bl	38478 <dwt_modify32bitoffsetreg>
   387d4:	9700      	str	r7, [sp, #0]
   387d6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   387da:	2200      	movs	r2, #0
   387dc:	2140      	movs	r1, #64	; 0x40
   387de:	4620      	mov	r0, r4
   387e0:	f7ff fe4a 	bl	38478 <dwt_modify32bitoffsetreg>
   387e4:	e7c4      	b.n	38770 <ull_setinterrupt+0x3c>
	...

000387e8 <ull_writetxfctrl>:
   387e8:	b510      	push	{r4, lr}
   387ea:	b082      	sub	sp, #8
   387ec:	4604      	mov	r4, r0
   387ee:	2a7f      	cmp	r2, #127	; 0x7f
   387f0:	d912      	bls.n	38818 <ull_writetxfctrl+0x30>
   387f2:	3280      	adds	r2, #128	; 0x80
   387f4:	ea41 21c3 	orr.w	r1, r1, r3, lsl #11
   387f8:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   387fc:	9100      	str	r1, [sp, #0]
   387fe:	4b0c      	ldr	r3, [pc, #48]	; (38830 <ull_writetxfctrl+0x48>)
   38800:	2200      	movs	r2, #0
   38802:	2124      	movs	r1, #36	; 0x24
   38804:	f7ff fe38 	bl	38478 <dwt_modify32bitoffsetreg>
   38808:	2200      	movs	r2, #0
   3880a:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   3880e:	4620      	mov	r0, r4
   38810:	f7fe fd86 	bl	37320 <dwt_read8bitoffsetreg>
   38814:	b002      	add	sp, #8
   38816:	bd10      	pop	{r4, pc}
   38818:	ea41 21c3 	orr.w	r1, r1, r3, lsl #11
   3881c:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   38820:	9100      	str	r1, [sp, #0]
   38822:	4b03      	ldr	r3, [pc, #12]	; (38830 <ull_writetxfctrl+0x48>)
   38824:	2200      	movs	r2, #0
   38826:	2124      	movs	r1, #36	; 0x24
   38828:	f7ff fe26 	bl	38478 <dwt_modify32bitoffsetreg>
   3882c:	e7f2      	b.n	38814 <ull_writetxfctrl+0x2c>
   3882e:	bf00      	nop
   38830:	fc00f400 	.word	0xfc00f400

00038834 <prs_sys_status_and_or>:
   38834:	b500      	push	{lr}
   38836:	b083      	sub	sp, #12
   38838:	9200      	str	r2, [sp, #0]
   3883a:	460b      	mov	r3, r1
   3883c:	2200      	movs	r2, #0
   3883e:	2144      	movs	r1, #68	; 0x44
   38840:	f7ff fe1a 	bl	38478 <dwt_modify32bitoffsetreg>
   38844:	2000      	movs	r0, #0
   38846:	b003      	add	sp, #12
   38848:	f85d fb04 	ldr.w	pc, [sp], #4

0003884c <dwt_modify8bitoffsetreg>:
   3884c:	b500      	push	{lr}
   3884e:	b085      	sub	sp, #20
   38850:	f88d 300c 	strb.w	r3, [sp, #12]
   38854:	f89d 3018 	ldrb.w	r3, [sp, #24]
   38858:	f88d 300d 	strb.w	r3, [sp, #13]
   3885c:	f248 0301 	movw	r3, #32769	; 0x8001
   38860:	9301      	str	r3, [sp, #4]
   38862:	ab03      	add	r3, sp, #12
   38864:	9300      	str	r3, [sp, #0]
   38866:	2302      	movs	r3, #2
   38868:	b292      	uxth	r2, r2
   3886a:	f7fe fca4 	bl	371b6 <dwt_xfer3xxx>
   3886e:	b005      	add	sp, #20
   38870:	f85d fb04 	ldr.w	pc, [sp], #4

00038874 <ull_configciadiag>:
   38874:	b530      	push	{r4, r5, lr}
   38876:	b083      	sub	sp, #12
   38878:	4604      	mov	r4, r0
   3887a:	460d      	mov	r5, r1
   3887c:	f011 0f01 	tst.w	r1, #1
   38880:	d015      	beq.n	388ae <ull_configciadiag+0x3a>
   38882:	2300      	movs	r3, #0
   38884:	9300      	str	r3, [sp, #0]
   38886:	23ef      	movs	r3, #239	; 0xef
   38888:	2202      	movs	r2, #2
   3888a:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3888e:	f7ff ffdd 	bl	3884c <dwt_modify8bitoffsetreg>
   38892:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38894:	761d      	strb	r5, [r3, #24]
   38896:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38898:	7e1b      	ldrb	r3, [r3, #24]
   3889a:	085b      	lsrs	r3, r3, #1
   3889c:	d010      	beq.n	388c0 <ull_configciadiag+0x4c>
   3889e:	086b      	lsrs	r3, r5, #1
   388a0:	2200      	movs	r2, #0
   388a2:	490e      	ldr	r1, [pc, #56]	; (388dc <ull_configciadiag+0x68>)
   388a4:	4620      	mov	r0, r4
   388a6:	f7ff f902 	bl	37aae <dwt_write8bitoffsetreg>
   388aa:	b003      	add	sp, #12
   388ac:	bd30      	pop	{r4, r5, pc}
   388ae:	2310      	movs	r3, #16
   388b0:	9300      	str	r3, [sp, #0]
   388b2:	23ff      	movs	r3, #255	; 0xff
   388b4:	2202      	movs	r2, #2
   388b6:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   388ba:	f7ff ffc7 	bl	3884c <dwt_modify8bitoffsetreg>
   388be:	e7e8      	b.n	38892 <ull_configciadiag+0x1e>
   388c0:	2301      	movs	r3, #1
   388c2:	9300      	str	r3, [sp, #0]
   388c4:	23ff      	movs	r3, #255	; 0xff
   388c6:	2200      	movs	r2, #0
   388c8:	4904      	ldr	r1, [pc, #16]	; (388dc <ull_configciadiag+0x68>)
   388ca:	4620      	mov	r0, r4
   388cc:	f7ff ffbe 	bl	3884c <dwt_modify8bitoffsetreg>
   388d0:	6d22      	ldr	r2, [r4, #80]	; 0x50
   388d2:	7e13      	ldrb	r3, [r2, #24]
   388d4:	f043 0302 	orr.w	r3, r3, #2
   388d8:	7613      	strb	r3, [r2, #24]
   388da:	e7e6      	b.n	388aa <ull_configciadiag+0x36>
   388dc:	00010028 	.word	0x00010028

000388e0 <ull_calcbandwidthadj>:
   388e0:	b570      	push	{r4, r5, r6, lr}
   388e2:	b082      	sub	sp, #8
   388e4:	4604      	mov	r4, r0
   388e6:	460d      	mov	r5, r1
   388e8:	2101      	movs	r1, #1
   388ea:	f7ff f963 	bl	37bb4 <ull_force_clocks>
   388ee:	2100      	movs	r1, #0
   388f0:	4620      	mov	r0, r4
   388f2:	f7ff fe03 	bl	384fc <ull_enable_rf_tx>
   388f6:	4620      	mov	r0, r4
   388f8:	f7ff fe34 	bl	38564 <ull_enable_rftx_blocks>
   388fc:	f3c5 030b 	ubfx	r3, r5, #0, #12
   38900:	2200      	movs	r2, #0
   38902:	4915      	ldr	r1, [pc, #84]	; (38958 <ull_calcbandwidthadj+0x78>)
   38904:	4620      	mov	r0, r4
   38906:	f7ff f924 	bl	37b52 <dwt_write16bitoffsetreg>
   3890a:	2303      	movs	r3, #3
   3890c:	9300      	str	r3, [sp, #0]
   3890e:	23ff      	movs	r3, #255	; 0xff
   38910:	2200      	movs	r2, #0
   38912:	4912      	ldr	r1, [pc, #72]	; (3895c <ull_calcbandwidthadj+0x7c>)
   38914:	4620      	mov	r0, r4
   38916:	f7ff ff99 	bl	3884c <dwt_modify8bitoffsetreg>
   3891a:	4e10      	ldr	r6, [pc, #64]	; (3895c <ull_calcbandwidthadj+0x7c>)
   3891c:	2500      	movs	r5, #0
   3891e:	462a      	mov	r2, r5
   38920:	4631      	mov	r1, r6
   38922:	4620      	mov	r0, r4
   38924:	f7fe fcfc 	bl	37320 <dwt_read8bitoffsetreg>
   38928:	f010 0f01 	tst.w	r0, #1
   3892c:	d1f7      	bne.n	3891e <ull_calcbandwidthadj+0x3e>
   3892e:	4620      	mov	r0, r4
   38930:	f7ff fcae 	bl	38290 <ull_disable_rftx_blocks>
   38934:	2100      	movs	r1, #0
   38936:	4620      	mov	r0, r4
   38938:	f7ff fcb4 	bl	382a4 <ull_disable_rf_tx>
   3893c:	2105      	movs	r1, #5
   3893e:	4620      	mov	r0, r4
   38940:	f7ff f938 	bl	37bb4 <ull_force_clocks>
   38944:	2200      	movs	r2, #0
   38946:	4906      	ldr	r1, [pc, #24]	; (38960 <ull_calcbandwidthadj+0x80>)
   38948:	4620      	mov	r0, r4
   3894a:	f7fe fce9 	bl	37320 <dwt_read8bitoffsetreg>
   3894e:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   38952:	b002      	add	sp, #8
   38954:	bd70      	pop	{r4, r5, r6, pc}
   38956:	bf00      	nop
   38958:	0008001c 	.word	0x0008001c
   3895c:	00080010 	.word	0x00080010
   38960:	0007001c 	.word	0x0007001c

00038964 <ull_configuretxrf>:
   38964:	b538      	push	{r3, r4, r5, lr}
   38966:	4605      	mov	r5, r0
   38968:	460c      	mov	r4, r1
   3896a:	f8b1 1005 	ldrh.w	r1, [r1, #5]
   3896e:	b149      	cbz	r1, 38984 <ull_configuretxrf+0x20>
   38970:	f7ff ffb6 	bl	388e0 <ull_calcbandwidthadj>
   38974:	f8d4 3001 	ldr.w	r3, [r4, #1]
   38978:	2200      	movs	r2, #0
   3897a:	4905      	ldr	r1, [pc, #20]	; (38990 <ull_configuretxrf+0x2c>)
   3897c:	4628      	mov	r0, r5
   3897e:	f7ff f9e9 	bl	37d54 <dwt_write32bitoffsetreg>
   38982:	bd38      	pop	{r3, r4, r5, pc}
   38984:	7823      	ldrb	r3, [r4, #0]
   38986:	2200      	movs	r2, #0
   38988:	4902      	ldr	r1, [pc, #8]	; (38994 <ull_configuretxrf+0x30>)
   3898a:	f7ff f890 	bl	37aae <dwt_write8bitoffsetreg>
   3898e:	e7f1      	b.n	38974 <ull_configuretxrf+0x10>
   38990:	0001000c 	.word	0x0001000c
   38994:	0007001c 	.word	0x0007001c

00038998 <ull_repeated_frames>:
   38998:	b530      	push	{r4, r5, lr}
   3899a:	b083      	sub	sp, #12
   3899c:	4604      	mov	r4, r0
   3899e:	460d      	mov	r5, r1
   389a0:	2310      	movs	r3, #16
   389a2:	9300      	str	r3, [sp, #0]
   389a4:	23ff      	movs	r3, #255	; 0xff
   389a6:	2200      	movs	r2, #0
   389a8:	4906      	ldr	r1, [pc, #24]	; (389c4 <ull_repeated_frames+0x2c>)
   389aa:	f7ff ff4f 	bl	3884c <dwt_modify8bitoffsetreg>
   389ae:	462b      	mov	r3, r5
   389b0:	2d02      	cmp	r5, #2
   389b2:	bf38      	it	cc
   389b4:	2302      	movcc	r3, #2
   389b6:	2200      	movs	r2, #0
   389b8:	212c      	movs	r1, #44	; 0x2c
   389ba:	4620      	mov	r0, r4
   389bc:	f7ff f9ca 	bl	37d54 <dwt_write32bitoffsetreg>
   389c0:	b003      	add	sp, #12
   389c2:	bd30      	pop	{r4, r5, pc}
   389c4:	000f0024 	.word	0x000f0024

000389c8 <ull_setdwstate>:
   389c8:	b530      	push	{r4, r5, lr}
   389ca:	b083      	sub	sp, #12
   389cc:	4604      	mov	r4, r0
   389ce:	2901      	cmp	r1, #1
   389d0:	d01d      	beq.n	38a0e <ull_setdwstate+0x46>
   389d2:	2902      	cmp	r1, #2
   389d4:	d030      	beq.n	38a38 <ull_setdwstate+0x70>
   389d6:	2301      	movs	r3, #1
   389d8:	9300      	str	r3, [sp, #0]
   389da:	23ff      	movs	r3, #255	; 0xff
   389dc:	2200      	movs	r2, #0
   389de:	4926      	ldr	r1, [pc, #152]	; (38a78 <ull_setdwstate+0xb0>)
   389e0:	f7ff ff34 	bl	3884c <dwt_modify8bitoffsetreg>
   389e4:	4d25      	ldr	r5, [pc, #148]	; (38a7c <ull_setdwstate+0xb4>)
   389e6:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   389ea:	9300      	str	r3, [sp, #0]
   389ec:	f46f 7380 	mvn.w	r3, #256	; 0x100
   389f0:	2200      	movs	r2, #0
   389f2:	4629      	mov	r1, r5
   389f4:	4620      	mov	r0, r4
   389f6:	f7ff fd3f 	bl	38478 <dwt_modify32bitoffsetreg>
   389fa:	2300      	movs	r3, #0
   389fc:	9300      	str	r3, [sp, #0]
   389fe:	237f      	movs	r3, #127	; 0x7f
   38a00:	2202      	movs	r2, #2
   38a02:	4629      	mov	r1, r5
   38a04:	4620      	mov	r0, r4
   38a06:	f7ff ff21 	bl	3884c <dwt_modify8bitoffsetreg>
   38a0a:	b003      	add	sp, #12
   38a0c:	bd30      	pop	{r4, r5, pc}
   38a0e:	2105      	movs	r1, #5
   38a10:	f7ff f8d0 	bl	37bb4 <ull_force_clocks>
   38a14:	f44f 7381 	mov.w	r3, #258	; 0x102
   38a18:	9300      	str	r3, [sp, #0]
   38a1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38a1e:	2200      	movs	r2, #0
   38a20:	4917      	ldr	r1, [pc, #92]	; (38a80 <ull_setdwstate+0xb8>)
   38a22:	4620      	mov	r0, r4
   38a24:	f7ff fd28 	bl	38478 <dwt_modify32bitoffsetreg>
   38a28:	2201      	movs	r2, #1
   38a2a:	9200      	str	r2, [sp, #0]
   38a2c:	23ff      	movs	r3, #255	; 0xff
   38a2e:	4913      	ldr	r1, [pc, #76]	; (38a7c <ull_setdwstate+0xb4>)
   38a30:	4620      	mov	r0, r4
   38a32:	f7ff ff0b 	bl	3884c <dwt_modify8bitoffsetreg>
   38a36:	e7e8      	b.n	38a0a <ull_setdwstate+0x42>
   38a38:	2303      	movs	r3, #3
   38a3a:	9300      	str	r3, [sp, #0]
   38a3c:	23ff      	movs	r3, #255	; 0xff
   38a3e:	2200      	movs	r2, #0
   38a40:	490d      	ldr	r1, [pc, #52]	; (38a78 <ull_setdwstate+0xb0>)
   38a42:	f7ff ff03 	bl	3884c <dwt_modify8bitoffsetreg>
   38a46:	4d0d      	ldr	r5, [pc, #52]	; (38a7c <ull_setdwstate+0xb4>)
   38a48:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   38a4c:	9300      	str	r3, [sp, #0]
   38a4e:	f46f 7380 	mvn.w	r3, #256	; 0x100
   38a52:	2200      	movs	r2, #0
   38a54:	4629      	mov	r1, r5
   38a56:	4620      	mov	r0, r4
   38a58:	f7ff fd0e 	bl	38478 <dwt_modify32bitoffsetreg>
   38a5c:	2300      	movs	r3, #0
   38a5e:	9300      	str	r3, [sp, #0]
   38a60:	237f      	movs	r3, #127	; 0x7f
   38a62:	2202      	movs	r2, #2
   38a64:	4629      	mov	r1, r5
   38a66:	4620      	mov	r0, r4
   38a68:	f7ff fef0 	bl	3884c <dwt_modify8bitoffsetreg>
   38a6c:	2105      	movs	r1, #5
   38a6e:	4620      	mov	r0, r4
   38a70:	f7ff f8a0 	bl	37bb4 <ull_force_clocks>
   38a74:	e7c9      	b.n	38a0a <ull_setdwstate+0x42>
   38a76:	bf00      	nop
   38a78:	00110004 	.word	0x00110004
   38a7c:	00110008 	.word	0x00110008
   38a80:	00090008 	.word	0x00090008

00038a84 <ull_configureframefilter>:
   38a84:	b530      	push	{r4, r5, lr}
   38a86:	b083      	sub	sp, #12
   38a88:	4605      	mov	r5, r0
   38a8a:	2902      	cmp	r1, #2
   38a8c:	d00e      	beq.n	38aac <ull_configureframefilter+0x28>
   38a8e:	2400      	movs	r4, #0
   38a90:	9400      	str	r4, [sp, #0]
   38a92:	23fe      	movs	r3, #254	; 0xfe
   38a94:	4622      	mov	r2, r4
   38a96:	2110      	movs	r1, #16
   38a98:	f7ff fed8 	bl	3884c <dwt_modify8bitoffsetreg>
   38a9c:	4623      	mov	r3, r4
   38a9e:	4622      	mov	r2, r4
   38aa0:	2114      	movs	r1, #20
   38aa2:	4628      	mov	r0, r5
   38aa4:	f7ff f855 	bl	37b52 <dwt_write16bitoffsetreg>
   38aa8:	b003      	add	sp, #12
   38aaa:	bd30      	pop	{r4, r5, pc}
   38aac:	4614      	mov	r4, r2
   38aae:	2301      	movs	r3, #1
   38ab0:	9300      	str	r3, [sp, #0]
   38ab2:	23ff      	movs	r3, #255	; 0xff
   38ab4:	2200      	movs	r2, #0
   38ab6:	2110      	movs	r1, #16
   38ab8:	f7ff fec8 	bl	3884c <dwt_modify8bitoffsetreg>
   38abc:	4623      	mov	r3, r4
   38abe:	2200      	movs	r2, #0
   38ac0:	2114      	movs	r1, #20
   38ac2:	4628      	mov	r0, r5
   38ac4:	f7ff f845 	bl	37b52 <dwt_write16bitoffsetreg>
   38ac8:	e7ee      	b.n	38aa8 <ull_configureframefilter+0x24>
	...

00038acc <ull_run_pgfcal>:
   38acc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   38ad0:	b082      	sub	sp, #8
   38ad2:	4605      	mov	r5, r0
   38ad4:	4c29      	ldr	r4, [pc, #164]	; (38b7c <ull_run_pgfcal+0xb0>)
   38ad6:	4b2a      	ldr	r3, [pc, #168]	; (38b80 <ull_run_pgfcal+0xb4>)
   38ad8:	2200      	movs	r2, #0
   38ada:	4621      	mov	r1, r4
   38adc:	f7ff f93a 	bl	37d54 <dwt_write32bitoffsetreg>
   38ae0:	2310      	movs	r3, #16
   38ae2:	9300      	str	r3, [sp, #0]
   38ae4:	23ff      	movs	r3, #255	; 0xff
   38ae6:	2200      	movs	r2, #0
   38ae8:	4621      	mov	r1, r4
   38aea:	4628      	mov	r0, r5
   38aec:	f7ff feae 	bl	3884c <dwt_modify8bitoffsetreg>
   38af0:	2403      	movs	r4, #3
   38af2:	f04f 0814 	mov.w	r8, #20
   38af6:	4f23      	ldr	r7, [pc, #140]	; (38b84 <ull_run_pgfcal+0xb8>)
   38af8:	2600      	movs	r6, #0
   38afa:	4640      	mov	r0, r8
   38afc:	f7f5 fe77 	bl	2e7ee <deca_usleep>
   38b00:	4632      	mov	r2, r6
   38b02:	4639      	mov	r1, r7
   38b04:	4628      	mov	r0, r5
   38b06:	f7fe fc0b 	bl	37320 <dwt_read8bitoffsetreg>
   38b0a:	2801      	cmp	r0, #1
   38b0c:	d034      	beq.n	38b78 <ull_run_pgfcal+0xac>
   38b0e:	1e63      	subs	r3, r4, #1
   38b10:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   38b14:	d1f1      	bne.n	38afa <ull_run_pgfcal+0x2e>
   38b16:	f06f 0402 	mvn.w	r4, #2
   38b1a:	4e18      	ldr	r6, [pc, #96]	; (38b7c <ull_run_pgfcal+0xb0>)
   38b1c:	2300      	movs	r3, #0
   38b1e:	461a      	mov	r2, r3
   38b20:	4631      	mov	r1, r6
   38b22:	4628      	mov	r0, r5
   38b24:	f7fe ffc3 	bl	37aae <dwt_write8bitoffsetreg>
   38b28:	2301      	movs	r3, #1
   38b2a:	2200      	movs	r2, #0
   38b2c:	4915      	ldr	r1, [pc, #84]	; (38b84 <ull_run_pgfcal+0xb8>)
   38b2e:	4628      	mov	r0, r5
   38b30:	f7fe ffbd 	bl	37aae <dwt_write8bitoffsetreg>
   38b34:	2301      	movs	r3, #1
   38b36:	9300      	str	r3, [sp, #0]
   38b38:	23ff      	movs	r3, #255	; 0xff
   38b3a:	2202      	movs	r2, #2
   38b3c:	4631      	mov	r1, r6
   38b3e:	4628      	mov	r0, r5
   38b40:	f7ff fe84 	bl	3884c <dwt_modify8bitoffsetreg>
   38b44:	2200      	movs	r2, #0
   38b46:	4910      	ldr	r1, [pc, #64]	; (38b88 <ull_run_pgfcal+0xbc>)
   38b48:	4628      	mov	r0, r5
   38b4a:	f7fe fbc1 	bl	372d0 <dwt_read32bitoffsetreg>
   38b4e:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   38b52:	4298      	cmp	r0, r3
   38b54:	bf08      	it	eq
   38b56:	f06f 0403 	mvneq.w	r4, #3
   38b5a:	2200      	movs	r2, #0
   38b5c:	490b      	ldr	r1, [pc, #44]	; (38b8c <ull_run_pgfcal+0xc0>)
   38b5e:	4628      	mov	r0, r5
   38b60:	f7fe fbb6 	bl	372d0 <dwt_read32bitoffsetreg>
   38b64:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   38b68:	4298      	cmp	r0, r3
   38b6a:	bf14      	ite	ne
   38b6c:	4620      	movne	r0, r4
   38b6e:	f06f 0004 	mvneq.w	r0, #4
   38b72:	b002      	add	sp, #8
   38b74:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   38b78:	2400      	movs	r4, #0
   38b7a:	e7ce      	b.n	38b1a <ull_run_pgfcal+0x4e>
   38b7c:	0004000c 	.word	0x0004000c
   38b80:	00020001 	.word	0x00020001
   38b84:	00040020 	.word	0x00040020
   38b88:	00040014 	.word	0x00040014
   38b8c:	0004001c 	.word	0x0004001c

00038b90 <prs_ack_enable>:
   38b90:	b500      	push	{lr}
   38b92:	b083      	sub	sp, #12
   38b94:	2900      	cmp	r1, #0
   38b96:	bf0b      	itete	eq
   38b98:	23ff      	moveq	r3, #255	; 0xff
   38b9a:	23f7      	movne	r3, #247	; 0xf7
   38b9c:	2200      	moveq	r2, #0
   38b9e:	2208      	movne	r2, #8
   38ba0:	9200      	str	r2, [sp, #0]
   38ba2:	2201      	movs	r2, #1
   38ba4:	2110      	movs	r1, #16
   38ba6:	f7ff fe51 	bl	3884c <dwt_modify8bitoffsetreg>
   38baa:	b003      	add	sp, #12
   38bac:	f85d fb04 	ldr.w	pc, [sp], #4

00038bb0 <dwt_modify16bitoffsetreg>:
   38bb0:	b510      	push	{r4, lr}
   38bb2:	b084      	sub	sp, #16
   38bb4:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   38bb8:	f88d 300c 	strb.w	r3, [sp, #12]
   38bbc:	0a1b      	lsrs	r3, r3, #8
   38bbe:	f88d 300d 	strb.w	r3, [sp, #13]
   38bc2:	f88d 400e 	strb.w	r4, [sp, #14]
   38bc6:	0a24      	lsrs	r4, r4, #8
   38bc8:	f88d 400f 	strb.w	r4, [sp, #15]
   38bcc:	f248 0302 	movw	r3, #32770	; 0x8002
   38bd0:	9301      	str	r3, [sp, #4]
   38bd2:	ab03      	add	r3, sp, #12
   38bd4:	9300      	str	r3, [sp, #0]
   38bd6:	2304      	movs	r3, #4
   38bd8:	b292      	uxth	r2, r2
   38bda:	f7fe faec 	bl	371b6 <dwt_xfer3xxx>
   38bde:	b004      	add	sp, #16
   38be0:	bd10      	pop	{r4, pc}
	...

00038be4 <_dwt_prog_ldo_and_bias_tune>:
   38be4:	b510      	push	{r4, lr}
   38be6:	b082      	sub	sp, #8
   38be8:	4604      	mov	r4, r0
   38bea:	f44f 73c0 	mov.w	r3, #384	; 0x180
   38bee:	9300      	str	r3, [sp, #0]
   38bf0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   38bf4:	2200      	movs	r2, #0
   38bf6:	4907      	ldr	r1, [pc, #28]	; (38c14 <_dwt_prog_ldo_and_bias_tune+0x30>)
   38bf8:	f7ff ffda 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38bfc:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38bfe:	7a1b      	ldrb	r3, [r3, #8]
   38c00:	9300      	str	r3, [sp, #0]
   38c02:	f64f 73e0 	movw	r3, #65504	; 0xffe0
   38c06:	2200      	movs	r2, #0
   38c08:	4903      	ldr	r1, [pc, #12]	; (38c18 <_dwt_prog_ldo_and_bias_tune+0x34>)
   38c0a:	4620      	mov	r0, r4
   38c0c:	f7ff ffd0 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38c10:	b002      	add	sp, #8
   38c12:	bd10      	pop	{r4, pc}
   38c14:	000b0008 	.word	0x000b0008
   38c18:	0011001f 	.word	0x0011001f

00038c1c <ull_setleds>:
   38c1c:	b530      	push	{r4, r5, lr}
   38c1e:	b083      	sub	sp, #12
   38c20:	4604      	mov	r4, r0
   38c22:	f011 0f01 	tst.w	r1, #1
   38c26:	d01f      	beq.n	38c68 <ull_setleds+0x4c>
   38c28:	460d      	mov	r5, r1
   38c2a:	f44f 7310 	mov.w	r3, #576	; 0x240
   38c2e:	9300      	str	r3, [sp, #0]
   38c30:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   38c34:	2200      	movs	r2, #0
   38c36:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   38c3a:	f7ff fc1d 	bl	38478 <dwt_modify32bitoffsetreg>
   38c3e:	f44f 0304 	mov.w	r3, #8650752	; 0x840000
   38c42:	9300      	str	r3, [sp, #0]
   38c44:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   38c48:	2200      	movs	r2, #0
   38c4a:	4918      	ldr	r1, [pc, #96]	; (38cac <ull_setleds+0x90>)
   38c4c:	4620      	mov	r0, r4
   38c4e:	f7ff fc13 	bl	38478 <dwt_modify32bitoffsetreg>
   38c52:	f015 0f02 	tst.w	r5, #2
   38c56:	d11a      	bne.n	38c8e <ull_setleds+0x72>
   38c58:	f44f 7388 	mov.w	r3, #272	; 0x110
   38c5c:	2200      	movs	r2, #0
   38c5e:	4914      	ldr	r1, [pc, #80]	; (38cb0 <ull_setleds+0x94>)
   38c60:	4620      	mov	r0, r4
   38c62:	f7ff f877 	bl	37d54 <dwt_write32bitoffsetreg>
   38c66:	e010      	b.n	38c8a <ull_setleds+0x6e>
   38c68:	2500      	movs	r5, #0
   38c6a:	9500      	str	r5, [sp, #0]
   38c6c:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   38c70:	462a      	mov	r2, r5
   38c72:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   38c76:	f7ff fbff 	bl	38478 <dwt_modify32bitoffsetreg>
   38c7a:	9500      	str	r5, [sp, #0]
   38c7c:	f64f 63ff 	movw	r3, #65279	; 0xfeff
   38c80:	462a      	mov	r2, r5
   38c82:	490b      	ldr	r1, [pc, #44]	; (38cb0 <ull_setleds+0x94>)
   38c84:	4620      	mov	r0, r4
   38c86:	f7ff ff93 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38c8a:	b003      	add	sp, #12
   38c8c:	bd30      	pop	{r4, r5, pc}
   38c8e:	4d08      	ldr	r5, [pc, #32]	; (38cb0 <ull_setleds+0x94>)
   38c90:	4b08      	ldr	r3, [pc, #32]	; (38cb4 <ull_setleds+0x98>)
   38c92:	2200      	movs	r2, #0
   38c94:	4629      	mov	r1, r5
   38c96:	4620      	mov	r0, r4
   38c98:	f7ff f85c 	bl	37d54 <dwt_write32bitoffsetreg>
   38c9c:	f44f 7388 	mov.w	r3, #272	; 0x110
   38ca0:	2200      	movs	r2, #0
   38ca2:	4629      	mov	r1, r5
   38ca4:	4620      	mov	r0, r4
   38ca6:	f7ff f855 	bl	37d54 <dwt_write32bitoffsetreg>
   38caa:	e7ee      	b.n	38c8a <ull_setleds+0x6e>
   38cac:	00110004 	.word	0x00110004
   38cb0:	00110016 	.word	0x00110016
   38cb4:	000f0110 	.word	0x000f0110

00038cb8 <ull_pgf_cal>:
   38cb8:	b5f0      	push	{r4, r5, r6, r7, lr}
   38cba:	b083      	sub	sp, #12
   38cbc:	4604      	mov	r4, r0
   38cbe:	2901      	cmp	r1, #1
   38cc0:	d009      	beq.n	38cd6 <ull_pgf_cal+0x1e>
   38cc2:	2014      	movs	r0, #20
   38cc4:	f7f5 fd93 	bl	2e7ee <deca_usleep>
   38cc8:	4620      	mov	r0, r4
   38cca:	f7ff feff 	bl	38acc <ull_run_pgfcal>
   38cce:	4605      	mov	r5, r0
   38cd0:	4628      	mov	r0, r5
   38cd2:	b003      	add	sp, #12
   38cd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
   38cd6:	4e0f      	ldr	r6, [pc, #60]	; (38d14 <ull_pgf_cal+0x5c>)
   38cd8:	2200      	movs	r2, #0
   38cda:	4631      	mov	r1, r6
   38cdc:	f7fe fb0e 	bl	372fc <dwt_read16bitoffsetreg>
   38ce0:	4607      	mov	r7, r0
   38ce2:	f240 1305 	movw	r3, #261	; 0x105
   38ce6:	9300      	str	r3, [sp, #0]
   38ce8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   38cec:	2200      	movs	r2, #0
   38cee:	4631      	mov	r1, r6
   38cf0:	4620      	mov	r0, r4
   38cf2:	f7ff ff5d 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38cf6:	2014      	movs	r0, #20
   38cf8:	f7f5 fd79 	bl	2e7ee <deca_usleep>
   38cfc:	4620      	mov	r0, r4
   38cfe:	f7ff fee5 	bl	38acc <ull_run_pgfcal>
   38d02:	4605      	mov	r5, r0
   38d04:	2200      	movs	r2, #0
   38d06:	9200      	str	r2, [sp, #0]
   38d08:	463b      	mov	r3, r7
   38d0a:	4631      	mov	r1, r6
   38d0c:	4620      	mov	r0, r4
   38d0e:	f7ff ff4f 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38d12:	e7dd      	b.n	38cd0 <ull_pgf_cal+0x18>
   38d14:	00070048 	.word	0x00070048

00038d18 <ull_setgpiovalue>:
   38d18:	b500      	push	{lr}
   38d1a:	b083      	sub	sp, #12
   38d1c:	2a01      	cmp	r2, #1
   38d1e:	d009      	beq.n	38d34 <ull_setgpiovalue+0x1c>
   38d20:	43cb      	mvns	r3, r1
   38d22:	2200      	movs	r2, #0
   38d24:	9200      	str	r2, [sp, #0]
   38d26:	b29b      	uxth	r3, r3
   38d28:	4906      	ldr	r1, [pc, #24]	; (38d44 <ull_setgpiovalue+0x2c>)
   38d2a:	f7ff ff41 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38d2e:	b003      	add	sp, #12
   38d30:	f85d fb04 	ldr.w	pc, [sp], #4
   38d34:	9100      	str	r1, [sp, #0]
   38d36:	f64f 73ff 	movw	r3, #65535	; 0xffff
   38d3a:	2200      	movs	r2, #0
   38d3c:	4901      	ldr	r1, [pc, #4]	; (38d44 <ull_setgpiovalue+0x2c>)
   38d3e:	f7ff ff37 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38d42:	e7f4      	b.n	38d2e <ull_setgpiovalue+0x16>
   38d44:	0005000c 	.word	0x0005000c

00038d48 <ull_readaccdata>:
   38d48:	b5f0      	push	{r4, r5, r6, r7, lr}
   38d4a:	b083      	sub	sp, #12
   38d4c:	4604      	mov	r4, r0
   38d4e:	460f      	mov	r7, r1
   38d50:	4616      	mov	r6, r2
   38d52:	461d      	mov	r5, r3
   38d54:	f248 0340 	movw	r3, #32832	; 0x8040
   38d58:	9300      	str	r3, [sp, #0]
   38d5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   38d5e:	2200      	movs	r2, #0
   38d60:	4918      	ldr	r1, [pc, #96]	; (38dc4 <ull_readaccdata+0x7c>)
   38d62:	f7ff ff25 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38d66:	19aa      	adds	r2, r5, r6
   38d68:	f243 0301 	movw	r3, #12289	; 0x3001
   38d6c:	429a      	cmp	r2, r3
   38d6e:	dc15      	bgt.n	38d9c <ull_readaccdata+0x54>
   38d70:	2d7f      	cmp	r5, #127	; 0x7f
   38d72:	d91d      	bls.n	38db0 <ull_readaccdata+0x68>
   38d74:	2315      	movs	r3, #21
   38d76:	2200      	movs	r2, #0
   38d78:	4913      	ldr	r1, [pc, #76]	; (38dc8 <ull_readaccdata+0x80>)
   38d7a:	4620      	mov	r0, r4
   38d7c:	f7fe ffea 	bl	37d54 <dwt_write32bitoffsetreg>
   38d80:	462b      	mov	r3, r5
   38d82:	2200      	movs	r2, #0
   38d84:	4911      	ldr	r1, [pc, #68]	; (38dcc <ull_readaccdata+0x84>)
   38d86:	4620      	mov	r0, r4
   38d88:	f7fe ffe4 	bl	37d54 <dwt_write32bitoffsetreg>
   38d8c:	9700      	str	r7, [sp, #0]
   38d8e:	4633      	mov	r3, r6
   38d90:	2200      	movs	r2, #0
   38d92:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   38d96:	4620      	mov	r0, r4
   38d98:	f7fe fa90 	bl	372bc <dwt_readfromdevice>
   38d9c:	2200      	movs	r2, #0
   38d9e:	9200      	str	r2, [sp, #0]
   38da0:	f647 73bf 	movw	r3, #32703	; 0x7fbf
   38da4:	4907      	ldr	r1, [pc, #28]	; (38dc4 <ull_readaccdata+0x7c>)
   38da6:	4620      	mov	r0, r4
   38da8:	f7ff ff02 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38dac:	b003      	add	sp, #12
   38dae:	bdf0      	pop	{r4, r5, r6, r7, pc}
   38db0:	9700      	str	r7, [sp, #0]
   38db2:	4633      	mov	r3, r6
   38db4:	462a      	mov	r2, r5
   38db6:	f44f 11a8 	mov.w	r1, #1376256	; 0x150000
   38dba:	4620      	mov	r0, r4
   38dbc:	f7fe fa7e 	bl	372bc <dwt_readfromdevice>
   38dc0:	e7ec      	b.n	38d9c <ull_readaccdata+0x54>
   38dc2:	bf00      	nop
   38dc4:	00110004 	.word	0x00110004
   38dc8:	001f0004 	.word	0x001f0004
   38dcc:	001f0008 	.word	0x001f0008

00038dd0 <ull_repeated_cw>:
   38dd0:	b570      	push	{r4, r5, r6, lr}
   38dd2:	4606      	mov	r6, r0
   38dd4:	460c      	mov	r4, r1
   38dd6:	4615      	mov	r5, r2
   38dd8:	4b0e      	ldr	r3, [pc, #56]	; (38e14 <ull_repeated_cw+0x44>)
   38dda:	2202      	movs	r2, #2
   38ddc:	490e      	ldr	r1, [pc, #56]	; (38e18 <ull_repeated_cw+0x48>)
   38dde:	f7fe ffb9 	bl	37d54 <dwt_write32bitoffsetreg>
   38de2:	2d0f      	cmp	r5, #15
   38de4:	bfa8      	it	ge
   38de6:	250f      	movge	r5, #15
   38de8:	1e63      	subs	r3, r4, #1
   38dea:	2b03      	cmp	r3, #3
   38dec:	bf28      	it	cs
   38dee:	2404      	movcs	r4, #4
   38df0:	2310      	movs	r3, #16
   38df2:	4123      	asrs	r3, r4
   38df4:	2200      	movs	r2, #0
   38df6:	4909      	ldr	r1, [pc, #36]	; (38e1c <ull_repeated_cw+0x4c>)
   38df8:	4630      	mov	r0, r6
   38dfa:	f7fe ffab 	bl	37d54 <dwt_write32bitoffsetreg>
   38dfe:	1e63      	subs	r3, r4, #1
   38e00:	009b      	lsls	r3, r3, #2
   38e02:	fa05 f303 	lsl.w	r3, r5, r3
   38e06:	2200      	movs	r2, #0
   38e08:	4905      	ldr	r1, [pc, #20]	; (38e20 <ull_repeated_cw+0x50>)
   38e0a:	4630      	mov	r0, r6
   38e0c:	f7fe ffa2 	bl	37d54 <dwt_write32bitoffsetreg>
   38e10:	bd70      	pop	{r4, r5, r6, pc}
   38e12:	bf00      	nop
   38e14:	00d20874 	.word	0x00d20874
   38e18:	00110010 	.word	0x00110010
   38e1c:	00070028 	.word	0x00070028
   38e20:	00080018 	.word	0x00080018

00038e24 <ull_configure>:
   38e24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   38e28:	b083      	sub	sp, #12
   38e2a:	4604      	mov	r4, r0
   38e2c:	460d      	mov	r5, r1
   38e2e:	f891 9000 	ldrb.w	r9, [r1]
   38e32:	790b      	ldrb	r3, [r1, #4]
   38e34:	2b18      	cmp	r3, #24
   38e36:	d814      	bhi.n	38e62 <ull_configure+0x3e>
   38e38:	78cf      	ldrb	r7, [r1, #3]
   38e3a:	2f18      	cmp	r7, #24
   38e3c:	bf94      	ite	ls
   38e3e:	2700      	movls	r7, #0
   38e40:	2701      	movhi	r7, #1
   38e42:	b2ff      	uxtb	r7, r7
   38e44:	79eb      	ldrb	r3, [r5, #7]
   38e46:	2b01      	cmp	r3, #1
   38e48:	bf0c      	ite	eq
   38e4a:	2110      	moveq	r1, #16
   38e4c:	2100      	movne	r1, #0
   38e4e:	786b      	ldrb	r3, [r5, #1]
   38e50:	3b01      	subs	r3, #1
   38e52:	2b06      	cmp	r3, #6
   38e54:	d810      	bhi.n	38e78 <ull_configure+0x54>
   38e56:	e8df f003 	tbb	[pc, r3]
   38e5a:	0f06      	.short	0x0f06
   38e5c:	0f0c120f 	.word	0x0f0c120f
   38e60:	09          	.byte	0x09
   38e61:	00          	.byte	0x00
   38e62:	2701      	movs	r7, #1
   38e64:	e7ed      	b.n	38e42 <ull_configure+0x1e>
   38e66:	f04f 0a40 	mov.w	sl, #64	; 0x40
   38e6a:	e00a      	b.n	38e82 <ull_configure+0x5e>
   38e6c:	f04f 0a48 	mov.w	sl, #72	; 0x48
   38e70:	e007      	b.n	38e82 <ull_configure+0x5e>
   38e72:	f04f 0a80 	mov.w	sl, #128	; 0x80
   38e76:	e004      	b.n	38e82 <ull_configure+0x5e>
   38e78:	f44f 7a80 	mov.w	sl, #256	; 0x100
   38e7c:	e001      	b.n	38e82 <ull_configure+0x5e>
   38e7e:	f04f 0a20 	mov.w	sl, #32
   38e82:	6d22      	ldr	r2, [r4, #80]	; 0x50
   38e84:	8a53      	ldrh	r3, [r2, #18]
   38e86:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
   38e8a:	8253      	strh	r3, [r2, #18]
   38e8c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38e8e:	79ea      	ldrb	r2, [r5, #7]
   38e90:	731a      	strb	r2, [r3, #12]
   38e92:	7b2e      	ldrb	r6, [r5, #12]
   38e94:	1cb3      	adds	r3, r6, #2
   38e96:	2601      	movs	r6, #1
   38e98:	409e      	lsls	r6, r3
   38e9a:	fa1f f886 	uxth.w	r8, r6
   38e9e:	6d22      	ldr	r2, [r4, #80]	; 0x50
   38ea0:	4bc7      	ldr	r3, [pc, #796]	; (391c0 <ull_configure+0x39c>)
   38ea2:	fb03 f308 	mul.w	r3, r3, r8
   38ea6:	0bdb      	lsrs	r3, r3, #15
   38ea8:	8293      	strh	r3, [r2, #20]
   38eaa:	6d23      	ldr	r3, [r4, #80]	; 0x50
   38eac:	7aea      	ldrb	r2, [r5, #11]
   38eae:	75da      	strb	r2, [r3, #23]
   38eb0:	7a2b      	ldrb	r3, [r5, #8]
   38eb2:	015b      	lsls	r3, r3, #5
   38eb4:	f003 0320 	and.w	r3, r3, #32
   38eb8:	7b6a      	ldrb	r2, [r5, #13]
   38eba:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   38ebe:	7aea      	ldrb	r2, [r5, #11]
   38ec0:	0312      	lsls	r2, r2, #12
   38ec2:	f402 4230 	and.w	r2, r2, #45056	; 0xb000
   38ec6:	4313      	orrs	r3, r2
   38ec8:	430b      	orrs	r3, r1
   38eca:	9300      	str	r3, [sp, #0]
   38ecc:	4bbd      	ldr	r3, [pc, #756]	; (391c4 <ull_configure+0x3a0>)
   38ece:	2200      	movs	r2, #0
   38ed0:	2110      	movs	r1, #16
   38ed2:	4620      	mov	r0, r4
   38ed4:	f7ff fad0 	bl	38478 <dwt_modify32bitoffsetreg>
   38ed8:	2f00      	cmp	r7, #0
   38eda:	f040 80f6 	bne.w	390ca <ull_configure+0x2a6>
   38ede:	7aeb      	ldrb	r3, [r5, #11]
   38ee0:	b1f3      	cbz	r3, 38f20 <ull_configure+0xfc>
   38ee2:	7b6b      	ldrb	r3, [r5, #13]
   38ee4:	2b01      	cmp	r3, #1
   38ee6:	f240 811c 	bls.w	39122 <ull_configure+0x2fe>
   38eea:	7b2a      	ldrb	r2, [r5, #12]
   38eec:	4bb6      	ldr	r3, [pc, #728]	; (391c8 <ull_configure+0x3a4>)
   38eee:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
   38ef2:	0112      	lsls	r2, r2, #4
   38ef4:	0ad3      	lsrs	r3, r2, #11
   38ef6:	f3c2 020a 	ubfx	r2, r2, #0, #11
   38efa:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   38efe:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   38f02:	bf28      	it	cs
   38f04:	3301      	addcs	r3, #1
   38f06:	b29b      	uxth	r3, r3
   38f08:	eb0a 0ac8 	add.w	sl, sl, r8, lsl #3
   38f0c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   38f10:	9300      	str	r3, [sp, #0]
   38f12:	f64f 7380 	movw	r3, #65408	; 0xff80
   38f16:	2202      	movs	r2, #2
   38f18:	49ac      	ldr	r1, [pc, #688]	; (391cc <ull_configure+0x3a8>)
   38f1a:	4620      	mov	r0, r4
   38f1c:	f7ff fe48 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38f20:	2394      	movs	r3, #148	; 0x94
   38f22:	9300      	str	r3, [sp, #0]
   38f24:	4baa      	ldr	r3, [pc, #680]	; (391d0 <ull_configure+0x3ac>)
   38f26:	2200      	movs	r2, #0
   38f28:	49aa      	ldr	r1, [pc, #680]	; (391d4 <ull_configure+0x3b0>)
   38f2a:	4620      	mov	r0, r4
   38f2c:	f7ff faa4 	bl	38478 <dwt_modify32bitoffsetreg>
   38f30:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   38f34:	f340 8108 	ble.w	39148 <ull_configure+0x324>
   38f38:	6d22      	ldr	r2, [r4, #80]	; 0x50
   38f3a:	8a53      	ldrh	r3, [r2, #18]
   38f3c:	f043 0320 	orr.w	r3, r3, #32
   38f40:	8253      	strh	r3, [r2, #18]
   38f42:	f44f 6380 	mov.w	r3, #1024	; 0x400
   38f46:	9300      	str	r3, [sp, #0]
   38f48:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
   38f4c:	2200      	movs	r2, #0
   38f4e:	49a2      	ldr	r1, [pc, #648]	; (391d8 <ull_configure+0x3b4>)
   38f50:	4620      	mov	r0, r4
   38f52:	f7ff fe2d 	bl	38bb0 <dwt_modify16bitoffsetreg>
   38f56:	7b6b      	ldrb	r3, [r5, #13]
   38f58:	2b01      	cmp	r3, #1
   38f5a:	f000 8100 	beq.w	3915e <ull_configure+0x33a>
   38f5e:	78ab      	ldrb	r3, [r5, #2]
   38f60:	f043 0310 	orr.w	r3, r3, #16
   38f64:	9300      	str	r3, [sp, #0]
   38f66:	23fc      	movs	r3, #252	; 0xfc
   38f68:	2200      	movs	r2, #0
   38f6a:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   38f6e:	4620      	mov	r0, r4
   38f70:	f7ff fc6c 	bl	3884c <dwt_modify8bitoffsetreg>
   38f74:	1e73      	subs	r3, r6, #1
   38f76:	b2db      	uxtb	r3, r3
   38f78:	2200      	movs	r2, #0
   38f7a:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   38f7e:	4620      	mov	r0, r4
   38f80:	f7fe fd95 	bl	37aae <dwt_write8bitoffsetreg>
   38f84:	786b      	ldrb	r3, [r5, #1]
   38f86:	2b07      	cmp	r3, #7
   38f88:	bf0c      	ite	eq
   38f8a:	2308      	moveq	r3, #8
   38f8c:	2300      	movne	r3, #0
   38f8e:	2201      	movs	r2, #1
   38f90:	2128      	movs	r1, #40	; 0x28
   38f92:	4620      	mov	r0, r4
   38f94:	f7fe fd8b 	bl	37aae <dwt_write8bitoffsetreg>
   38f98:	4b90      	ldr	r3, [pc, #576]	; (391dc <ull_configure+0x3b8>)
   38f9a:	2200      	movs	r2, #0
   38f9c:	4990      	ldr	r1, [pc, #576]	; (391e0 <ull_configure+0x3bc>)
   38f9e:	4620      	mov	r0, r4
   38fa0:	f7fe fed8 	bl	37d54 <dwt_write32bitoffsetreg>
   38fa4:	2200      	movs	r2, #0
   38fa6:	498f      	ldr	r1, [pc, #572]	; (391e4 <ull_configure+0x3c0>)
   38fa8:	4620      	mov	r0, r4
   38faa:	f7fe f991 	bl	372d0 <dwt_read32bitoffsetreg>
   38fae:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
   38fb2:	f020 001f 	bic.w	r0, r0, #31
   38fb6:	f1b9 0f09 	cmp.w	r9, #9
   38fba:	bf08      	it	eq
   38fbc:	f040 0001 	orreq.w	r0, r0, #1
   38fc0:	792a      	ldrb	r2, [r5, #4]
   38fc2:	0212      	lsls	r2, r2, #8
   38fc4:	f402 52f8 	and.w	r2, r2, #7936	; 0x1f00
   38fc8:	78eb      	ldrb	r3, [r5, #3]
   38fca:	00db      	lsls	r3, r3, #3
   38fcc:	b2db      	uxtb	r3, r3
   38fce:	431a      	orrs	r2, r3
   38fd0:	796b      	ldrb	r3, [r5, #5]
   38fd2:	005b      	lsls	r3, r3, #1
   38fd4:	f003 0306 	and.w	r3, r3, #6
   38fd8:	4313      	orrs	r3, r2
   38fda:	4303      	orrs	r3, r0
   38fdc:	2200      	movs	r2, #0
   38fde:	4981      	ldr	r1, [pc, #516]	; (391e4 <ull_configure+0x3c0>)
   38fe0:	4620      	mov	r0, r4
   38fe2:	f7fe feb7 	bl	37d54 <dwt_write32bitoffsetreg>
   38fe6:	79aa      	ldrb	r2, [r5, #6]
   38fe8:	786b      	ldrb	r3, [r5, #1]
   38fea:	031b      	lsls	r3, r3, #12
   38fec:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   38ff0:	9300      	str	r3, [sp, #0]
   38ff2:	f46f 4374 	mvn.w	r3, #62464	; 0xf400
   38ff6:	2200      	movs	r2, #0
   38ff8:	2124      	movs	r1, #36	; 0x24
   38ffa:	4620      	mov	r0, r4
   38ffc:	f7ff fa3c 	bl	38478 <dwt_modify32bitoffsetreg>
   39000:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   39004:	b923      	cbnz	r3, 39010 <ull_configure+0x1ec>
   39006:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   3900a:	726b      	strb	r3, [r5, #9]
   3900c:	2300      	movs	r3, #0
   3900e:	72ab      	strb	r3, [r5, #10]
   39010:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   39014:	2202      	movs	r2, #2
   39016:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   3901a:	4620      	mov	r0, r4
   3901c:	f7fe fd99 	bl	37b52 <dwt_write16bitoffsetreg>
   39020:	2202      	movs	r2, #2
   39022:	4971      	ldr	r1, [pc, #452]	; (391e8 <ull_configure+0x3c4>)
   39024:	4620      	mov	r0, r4
   39026:	f7fe f97b 	bl	37320 <dwt_read8bitoffsetreg>
   3902a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3902c:	7c1b      	ldrb	r3, [r3, #16]
   3902e:	454b      	cmp	r3, r9
   39030:	f000 809f 	beq.w	39172 <ull_configure+0x34e>
   39034:	2803      	cmp	r0, #3
   39036:	f000 80a0 	beq.w	3917a <ull_configure+0x356>
   3903a:	f1b9 0f09 	cmp.w	r9, #9
   3903e:	f000 80a1 	beq.w	39184 <ull_configure+0x360>
   39042:	4b6a      	ldr	r3, [pc, #424]	; (391ec <ull_configure+0x3c8>)
   39044:	2200      	movs	r2, #0
   39046:	496a      	ldr	r1, [pc, #424]	; (391f0 <ull_configure+0x3cc>)
   39048:	4620      	mov	r0, r4
   3904a:	f7fe fe83 	bl	37d54 <dwt_write32bitoffsetreg>
   3904e:	f641 733c 	movw	r3, #7996	; 0x1f3c
   39052:	2200      	movs	r2, #0
   39054:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   39058:	4620      	mov	r0, r4
   3905a:	f7fe fd7a 	bl	37b52 <dwt_write16bitoffsetreg>
   3905e:	2314      	movs	r3, #20
   39060:	2201      	movs	r2, #1
   39062:	4964      	ldr	r1, [pc, #400]	; (391f4 <ull_configure+0x3d0>)
   39064:	4620      	mov	r0, r4
   39066:	f7fe fd22 	bl	37aae <dwt_write8bitoffsetreg>
   3906a:	230e      	movs	r3, #14
   3906c:	2202      	movs	r2, #2
   3906e:	4962      	ldr	r1, [pc, #392]	; (391f8 <ull_configure+0x3d4>)
   39070:	4620      	mov	r0, r4
   39072:	f7fe fd1c 	bl	37aae <dwt_write8bitoffsetreg>
   39076:	2381      	movs	r3, #129	; 0x81
   39078:	2200      	movs	r2, #0
   3907a:	4960      	ldr	r1, [pc, #384]	; (391fc <ull_configure+0x3d8>)
   3907c:	4620      	mov	r0, r4
   3907e:	f7fe fd16 	bl	37aae <dwt_write8bitoffsetreg>
   39082:	2302      	movs	r3, #2
   39084:	2200      	movs	r2, #0
   39086:	2144      	movs	r1, #68	; 0x44
   39088:	4620      	mov	r0, r4
   3908a:	f7fe fd10 	bl	37aae <dwt_write8bitoffsetreg>
   3908e:	2101      	movs	r1, #1
   39090:	4620      	mov	r0, r4
   39092:	f7ff fc99 	bl	389c8 <ull_setdwstate>
   39096:	f04f 0b32 	mov.w	fp, #50	; 0x32
   3909a:	f04f 0814 	mov.w	r8, #20
   3909e:	2700      	movs	r7, #0
   390a0:	2644      	movs	r6, #68	; 0x44
   390a2:	4640      	mov	r0, r8
   390a4:	f7f5 fba3 	bl	2e7ee <deca_usleep>
   390a8:	463a      	mov	r2, r7
   390aa:	4631      	mov	r1, r6
   390ac:	4620      	mov	r0, r4
   390ae:	f7fe f937 	bl	37320 <dwt_read8bitoffsetreg>
   390b2:	f010 0f02 	tst.w	r0, #2
   390b6:	f040 80ab 	bne.w	39210 <ull_configure+0x3ec>
   390ba:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   390be:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   390c2:	d1ee      	bne.n	390a2 <ull_configure+0x27e>
   390c4:	f06f 0001 	mvn.w	r0, #1
   390c8:	e0cf      	b.n	3926a <ull_configure+0x446>
   390ca:	6d22      	ldr	r2, [r4, #80]	; 0x50
   390cc:	8a53      	ldrh	r3, [r2, #18]
   390ce:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   390d2:	8253      	strh	r3, [r2, #18]
   390d4:	f44f 6340 	mov.w	r3, #3072	; 0xc00
   390d8:	9300      	str	r3, [sp, #0]
   390da:	f46f 53c0 	mvn.w	r3, #6144	; 0x1800
   390de:	2200      	movs	r2, #0
   390e0:	493d      	ldr	r1, [pc, #244]	; (391d8 <ull_configure+0x3b4>)
   390e2:	4620      	mov	r0, r4
   390e4:	f7ff f9c8 	bl	38478 <dwt_modify32bitoffsetreg>
   390e8:	f240 3306 	movw	r3, #774	; 0x306
   390ec:	2200      	movs	r2, #0
   390ee:	4944      	ldr	r1, [pc, #272]	; (39200 <ull_configure+0x3dc>)
   390f0:	4620      	mov	r0, r4
   390f2:	f7fe fe2f 	bl	37d54 <dwt_write32bitoffsetreg>
   390f6:	2300      	movs	r3, #0
   390f8:	461a      	mov	r2, r3
   390fa:	f04f 110e 	mov.w	r1, #917518	; 0xe000e
   390fe:	4620      	mov	r0, r4
   39100:	f7fe fe28 	bl	37d54 <dwt_write32bitoffsetreg>
   39104:	4b3f      	ldr	r3, [pc, #252]	; (39204 <ull_configure+0x3e0>)
   39106:	2200      	movs	r2, #0
   39108:	4930      	ldr	r1, [pc, #192]	; (391cc <ull_configure+0x3a8>)
   3910a:	4620      	mov	r0, r4
   3910c:	f7fe fe22 	bl	37d54 <dwt_write32bitoffsetreg>
   39110:	239d      	movs	r3, #157	; 0x9d
   39112:	9300      	str	r3, [sp, #0]
   39114:	4b2e      	ldr	r3, [pc, #184]	; (391d0 <ull_configure+0x3ac>)
   39116:	2200      	movs	r2, #0
   39118:	492e      	ldr	r1, [pc, #184]	; (391d4 <ull_configure+0x3b0>)
   3911a:	4620      	mov	r0, r4
   3911c:	f7ff f9ac 	bl	38478 <dwt_modify32bitoffsetreg>
   39120:	e719      	b.n	38f56 <ull_configure+0x132>
   39122:	7b2a      	ldrb	r2, [r5, #12]
   39124:	4b28      	ldr	r3, [pc, #160]	; (391c8 <ull_configure+0x3a4>)
   39126:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   3912a:	f44f 6235 	mov.w	r2, #2896	; 0xb50
   3912e:	fb02 f203 	mul.w	r2, r2, r3
   39132:	0c93      	lsrs	r3, r2, #18
   39134:	f3c2 12ca 	ubfx	r2, r2, #7, #11
   39138:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3913c:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   39140:	bf28      	it	cs
   39142:	3301      	addcs	r3, #1
   39144:	b29b      	uxth	r3, r3
   39146:	e6df      	b.n	38f08 <ull_configure+0xe4>
   39148:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
   3914c:	9300      	str	r3, [sp, #0]
   3914e:	f24e 73ff 	movw	r3, #59391	; 0xe7ff
   39152:	2200      	movs	r2, #0
   39154:	4920      	ldr	r1, [pc, #128]	; (391d8 <ull_configure+0x3b4>)
   39156:	4620      	mov	r0, r4
   39158:	f7ff fd2a 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3915c:	e6fb      	b.n	38f56 <ull_configure+0x132>
   3915e:	78ab      	ldrb	r3, [r5, #2]
   39160:	9300      	str	r3, [sp, #0]
   39162:	23ec      	movs	r3, #236	; 0xec
   39164:	2200      	movs	r2, #0
   39166:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   3916a:	4620      	mov	r0, r4
   3916c:	f7ff fb6e 	bl	3884c <dwt_modify8bitoffsetreg>
   39170:	e700      	b.n	38f74 <ull_configure+0x150>
   39172:	2803      	cmp	r0, #3
   39174:	f47f af61 	bne.w	3903a <ull_configure+0x216>
   39178:	e04d      	b.n	39216 <ull_configure+0x3f2>
   3917a:	2102      	movs	r1, #2
   3917c:	4620      	mov	r0, r4
   3917e:	f7ff fc23 	bl	389c8 <ull_setdwstate>
   39182:	e75a      	b.n	3903a <ull_configure+0x216>
   39184:	4b20      	ldr	r3, [pc, #128]	; (39208 <ull_configure+0x3e4>)
   39186:	2200      	movs	r2, #0
   39188:	4919      	ldr	r1, [pc, #100]	; (391f0 <ull_configure+0x3cc>)
   3918a:	4620      	mov	r0, r4
   3918c:	f7fe fde2 	bl	37d54 <dwt_write32bitoffsetreg>
   39190:	f640 733c 	movw	r3, #3900	; 0xf3c
   39194:	2200      	movs	r2, #0
   39196:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   3919a:	4620      	mov	r0, r4
   3919c:	f7fe fcd9 	bl	37b52 <dwt_write16bitoffsetreg>
   391a0:	e75d      	b.n	3905e <ull_configure+0x23a>
   391a2:	fa4f f189 	sxtb.w	r1, r9
   391a6:	4620      	mov	r0, r4
   391a8:	f7ff f98a 	bl	384c0 <_dwt_kick_dgc_on_wakeup>
   391ac:	e040      	b.n	39230 <ull_configure+0x40c>
   391ae:	2200      	movs	r2, #0
   391b0:	9200      	str	r2, [sp, #0]
   391b2:	23fe      	movs	r3, #254	; 0xfe
   391b4:	4915      	ldr	r1, [pc, #84]	; (3920c <ull_configure+0x3e8>)
   391b6:	4620      	mov	r0, r4
   391b8:	f7ff fb48 	bl	3884c <dwt_modify8bitoffsetreg>
   391bc:	e042      	b.n	39244 <ull_configure+0x420>
   391be:	bf00      	nop
   391c0:	00026668 	.word	0x00026668
   391c4:	fffc4fcf 	.word	0xfffc4fcf
   391c8:	00046e5c 	.word	0x00046e5c
   391cc:	000e0012 	.word	0x000e0012
   391d0:	bfffff00 	.word	0xbfffff00
   391d4:	000e0016 	.word	0x000e0016
   391d8:	000b0008 	.word	0x000b0008
   391dc:	af5f35cc 	.word	0xaf5f35cc
   391e0:	0006000c 	.word	0x0006000c
   391e4:	00010014 	.word	0x00010014
   391e8:	000f0030 	.word	0x000f0030
   391ec:	1c071134 	.word	0x1c071134
   391f0:	0007001c 	.word	0x0007001c
   391f4:	00070050 	.word	0x00070050
   391f8:	00070018 	.word	0x00070018
   391fc:	00090008 	.word	0x00090008
   39200:	000e000c 	.word	0x000e000c
   39204:	000c5a0a 	.word	0x000c5a0a
   39208:	1c010034 	.word	0x1c010034
   3920c:	00030018 	.word	0x00030018
   39210:	6d23      	ldr	r3, [r4, #80]	; 0x50
   39212:	f883 9010 	strb.w	r9, [r3, #16]
   39216:	792b      	ldrb	r3, [r5, #4]
   39218:	3b09      	subs	r3, #9
   3921a:	b2db      	uxtb	r3, r3
   3921c:	2b0f      	cmp	r3, #15
   3921e:	d8c6      	bhi.n	391ae <ull_configure+0x38a>
   39220:	6d23      	ldr	r3, [r4, #80]	; 0x50
   39222:	7a5b      	ldrb	r3, [r3, #9]
   39224:	2b01      	cmp	r3, #1
   39226:	d0bc      	beq.n	391a2 <ull_configure+0x37e>
   39228:	4649      	mov	r1, r9
   3922a:	4620      	mov	r0, r4
   3922c:	f7fe ffae 	bl	3818c <ull_configmrxlut>
   39230:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
   39234:	9300      	str	r3, [sp, #0]
   39236:	f248 13ff 	movw	r3, #33279	; 0x81ff
   3923a:	2200      	movs	r2, #0
   3923c:	490c      	ldr	r1, [pc, #48]	; (39270 <ull_configure+0x44c>)
   3923e:	4620      	mov	r0, r4
   39240:	f7ff fcb6 	bl	38bb0 <dwt_modify16bitoffsetreg>
   39244:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
   39248:	bfcc      	ite	gt
   3924a:	f04f 5300 	movgt.w	r3, #536870912	; 0x20000000
   3924e:	f04f 53a0 	movle.w	r3, #335544320	; 0x14000000
   39252:	9300      	str	r3, [sp, #0]
   39254:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   39258:	2200      	movs	r2, #0
   3925a:	4906      	ldr	r1, [pc, #24]	; (39274 <ull_configure+0x450>)
   3925c:	4620      	mov	r0, r4
   3925e:	f7ff f90b 	bl	38478 <dwt_modify32bitoffsetreg>
   39262:	2101      	movs	r1, #1
   39264:	4620      	mov	r0, r4
   39266:	f7ff fd27 	bl	38cb8 <ull_pgf_cal>
   3926a:	b003      	add	sp, #12
   3926c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   39270:	00030018 	.word	0x00030018
   39274:	00060010 	.word	0x00060010

00039278 <dwt_ioctl>:
   39278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3927c:	b091      	sub	sp, #68	; 0x44
   3927e:	4606      	mov	r6, r0
   39280:	4615      	mov	r5, r2
   39282:	461c      	mov	r4, r3
   39284:	299c      	cmp	r1, #156	; 0x9c
   39286:	f200 809f 	bhi.w	393c8 <dwt_ioctl+0x150>
   3928a:	e8df f011 	tbh	[pc, r1, lsl #1]
   3928e:	0a6d      	.short	0x0a6d
   39290:	00a30a78 	.word	0x00a30a78
   39294:	00be00a7 	.word	0x00be00a7
   39298:	018e0148 	.word	0x018e0148
   3929c:	0152016b 	.word	0x0152016b
   392a0:	01a9019e 	.word	0x01a9019e
   392a4:	01b901b1 	.word	0x01b901b1
   392a8:	01c901c1 	.word	0x01c901c1
   392ac:	01d501d1 	.word	0x01d501d1
   392b0:	026e01dd 	.word	0x026e01dd
   392b4:	0281027c 	.word	0x0281027c
   392b8:	0290028b 	.word	0x0290028b
   392bc:	029e0295 	.word	0x029e0295
   392c0:	030902a3 	.word	0x030902a3
   392c4:	0326031b 	.word	0x0326031b
   392c8:	033b0331 	.word	0x033b0331
   392cc:	03690373 	.word	0x03690373
   392d0:	0345035f 	.word	0x0345035f
   392d4:	03c10352 	.word	0x03c10352
   392d8:	022b01f8 	.word	0x022b01f8
   392dc:	02410239 	.word	0x02410239
   392e0:	09960255 	.word	0x09960255
   392e4:	0382099b 	.word	0x0382099b
   392e8:	03e303df 	.word	0x03e303df
   392ec:	03f103ec 	.word	0x03f103ec
   392f0:	040503fb 	.word	0x040503fb
   392f4:	0437040d 	.word	0x0437040d
   392f8:	044e0443 	.word	0x044e0443
   392fc:	04590378 	.word	0x04590378
   39300:	04740462 	.word	0x04740462
   39304:	049e048d 	.word	0x049e048d
   39308:	04ea04e0 	.word	0x04ea04e0
   3930c:	051a050b 	.word	0x051a050b
   39310:	05230535 	.word	0x05230535
   39314:	05970551 	.word	0x05970551
   39318:	05cf05af 	.word	0x05cf05af
   3931c:	05f805e4 	.word	0x05f805e4
   39320:	061d0601 	.word	0x061d0601
   39324:	0773060a 	.word	0x0773060a
   39328:	07ed079f 	.word	0x07ed079f
   3932c:	07fe07f3 	.word	0x07fe07f3
   39330:	08370817 	.word	0x08370817
   39334:	084b0841 	.word	0x084b0841
   39338:	08820879 	.word	0x08820879
   3933c:	08910888 	.word	0x08910888
   39340:	08ab089e 	.word	0x08ab089e
   39344:	08be08b5 	.word	0x08be08b5
   39348:	08d208c7 	.word	0x08d208c7
   3934c:	08e308dd 	.word	0x08e308dd
   39350:	09110906 	.word	0x09110906
   39354:	0945091c 	.word	0x0945091c
   39358:	09720967 	.word	0x09720967
   3935c:	09a1098b 	.word	0x09a1098b
   39360:	0a200a16 	.word	0x0a200a16
   39364:	0a800a2b 	.word	0x0a800a2b
   39368:	0a620a35 	.word	0x0a620a35
   3936c:	09df0791 	.word	0x09df0791
   39370:	0aee0a00 	.word	0x0aee0a00
   39374:	0a8d0ae3 	.word	0x0a8d0ae3
   39378:	0aa30a98 	.word	0x0aa30a98
   3937c:	0ab90aae 	.word	0x0ab90aae
   39380:	0acf0ac4 	.word	0x0acf0ac4
   39384:	0bd80ad8 	.word	0x0bd80ad8
   39388:	0c4d0c12 	.word	0x0c4d0c12
   3938c:	0d290c70 	.word	0x0d290c70
   39390:	0b190d3e 	.word	0x0b190d3e
   39394:	009d009d 	.word	0x009d009d
   39398:	009d009d 	.word	0x009d009d
   3939c:	009d009d 	.word	0x009d009d
   393a0:	009d009d 	.word	0x009d009d
   393a4:	009d009d 	.word	0x009d009d
   393a8:	009d009d 	.word	0x009d009d
   393ac:	009d009d 	.word	0x009d009d
   393b0:	009d009d 	.word	0x009d009d
   393b4:	009d009d 	.word	0x009d009d
   393b8:	0c87009d 	.word	0x0c87009d
   393bc:	0dce0ca5 	.word	0x0dce0ca5
   393c0:	0ce40cef 	.word	0x0ce40cef
   393c4:	0cfa0d03 	.word	0x0cfa0d03
   393c8:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   393cc:	4628      	mov	r0, r5
   393ce:	b011      	add	sp, #68	; 0x44
   393d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   393d4:	6843      	ldr	r3, [r0, #4]
   393d6:	4798      	blx	r3
   393d8:	2500      	movs	r5, #0
   393da:	e7f7      	b.n	393cc <dwt_ioctl+0x154>
   393dc:	2202      	movs	r2, #2
   393de:	49b7      	ldr	r1, [pc, #732]	; (396bc <dwt_ioctl+0x444>)
   393e0:	f7fd ff9e 	bl	37320 <dwt_read8bitoffsetreg>
   393e4:	2803      	cmp	r0, #3
   393e6:	d801      	bhi.n	393ec <dwt_ioctl+0x174>
   393e8:	2500      	movs	r5, #0
   393ea:	e7ef      	b.n	393cc <dwt_ioctl+0x154>
   393ec:	f7f5 f9dc 	bl	2e7a8 <decamutexon>
   393f0:	4604      	mov	r4, r0
   393f2:	2500      	movs	r5, #0
   393f4:	9500      	str	r5, [sp, #0]
   393f6:	462b      	mov	r3, r5
   393f8:	462a      	mov	r2, r5
   393fa:	4629      	mov	r1, r5
   393fc:	4630      	mov	r0, r6
   393fe:	f7fe fb4b 	bl	37a98 <dwt_writetodevice>
   39402:	4620      	mov	r0, r4
   39404:	f7f5 f9d7 	bl	2e7b6 <decamutexoff>
   39408:	e7e0      	b.n	393cc <dwt_ioctl+0x154>
   3940a:	2c00      	cmp	r4, #0
   3940c:	f001 8510 	beq.w	3ae30 <dwt_ioctl+0x1bb8>
   39410:	7824      	ldrb	r4, [r4, #0]
   39412:	f014 0f1d 	tst.w	r4, #29
   39416:	d065      	beq.n	394e4 <dwt_ioctl+0x26c>
   39418:	f014 0f01 	tst.w	r4, #1
   3941c:	d026      	beq.n	3946c <dwt_ioctl+0x1f4>
   3941e:	f014 0f02 	tst.w	r4, #2
   39422:	f04f 0200 	mov.w	r2, #0
   39426:	9200      	str	r2, [sp, #0]
   39428:	4613      	mov	r3, r2
   3942a:	bf14      	ite	ne
   3942c:	210d      	movne	r1, #13
   3942e:	2103      	moveq	r1, #3
   39430:	f7fe fb32 	bl	37a98 <dwt_writetodevice>
   39434:	2203      	movs	r2, #3
   39436:	2144      	movs	r1, #68	; 0x44
   39438:	4630      	mov	r0, r6
   3943a:	f7fd ff71 	bl	37320 <dwt_read8bitoffsetreg>
   3943e:	f010 0f08 	tst.w	r0, #8
   39442:	d145      	bne.n	394d0 <dwt_ioctl+0x258>
   39444:	2200      	movs	r2, #0
   39446:	499d      	ldr	r1, [pc, #628]	; (396bc <dwt_ioctl+0x444>)
   39448:	4630      	mov	r0, r6
   3944a:	f7fd ff41 	bl	372d0 <dwt_read32bitoffsetreg>
   3944e:	f5b0 2f50 	cmp.w	r0, #851968	; 0xd0000
   39452:	bf18      	it	ne
   39454:	2500      	movne	r5, #0
   39456:	d1b9      	bne.n	393cc <dwt_ioctl+0x154>
   39458:	2100      	movs	r1, #0
   3945a:	9100      	str	r1, [sp, #0]
   3945c:	460b      	mov	r3, r1
   3945e:	460a      	mov	r2, r1
   39460:	4630      	mov	r0, r6
   39462:	f7fe fb19 	bl	37a98 <dwt_writetodevice>
   39466:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   3946a:	e7af      	b.n	393cc <dwt_ioctl+0x154>
   3946c:	f014 0f08 	tst.w	r4, #8
   39470:	d10e      	bne.n	39490 <dwt_ioctl+0x218>
   39472:	f014 0f10 	tst.w	r4, #16
   39476:	d11b      	bne.n	394b0 <dwt_ioctl+0x238>
   39478:	f014 0f02 	tst.w	r4, #2
   3947c:	f04f 0200 	mov.w	r2, #0
   39480:	9200      	str	r2, [sp, #0]
   39482:	4613      	mov	r3, r2
   39484:	bf14      	ite	ne
   39486:	2110      	movne	r1, #16
   39488:	2109      	moveq	r1, #9
   3948a:	f7fe fb05 	bl	37a98 <dwt_writetodevice>
   3948e:	e7d1      	b.n	39434 <dwt_ioctl+0x1bc>
   39490:	2100      	movs	r1, #0
   39492:	f7fe fdd3 	bl	3803c <_dwt_adjust_delaytime>
   39496:	f014 0f02 	tst.w	r4, #2
   3949a:	f04f 0200 	mov.w	r2, #0
   3949e:	9200      	str	r2, [sp, #0]
   394a0:	4613      	mov	r3, r2
   394a2:	bf14      	ite	ne
   394a4:	210f      	movne	r1, #15
   394a6:	2107      	moveq	r1, #7
   394a8:	4630      	mov	r0, r6
   394aa:	f7fe faf5 	bl	37a98 <dwt_writetodevice>
   394ae:	e7c1      	b.n	39434 <dwt_ioctl+0x1bc>
   394b0:	2101      	movs	r1, #1
   394b2:	f7fe fdc3 	bl	3803c <_dwt_adjust_delaytime>
   394b6:	f014 0f02 	tst.w	r4, #2
   394ba:	f04f 0200 	mov.w	r2, #0
   394be:	9200      	str	r2, [sp, #0]
   394c0:	4613      	mov	r3, r2
   394c2:	bf14      	ite	ne
   394c4:	210e      	movne	r1, #14
   394c6:	2105      	moveq	r1, #5
   394c8:	4630      	mov	r0, r6
   394ca:	f7fe fae5 	bl	37a98 <dwt_writetodevice>
   394ce:	e7b1      	b.n	39434 <dwt_ioctl+0x1bc>
   394d0:	2100      	movs	r1, #0
   394d2:	9100      	str	r1, [sp, #0]
   394d4:	460b      	mov	r3, r1
   394d6:	460a      	mov	r2, r1
   394d8:	4630      	mov	r0, r6
   394da:	f7fe fadd 	bl	37a98 <dwt_writetodevice>
   394de:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   394e2:	e773      	b.n	393cc <dwt_ioctl+0x154>
   394e4:	f014 0f20 	tst.w	r4, #32
   394e8:	d00c      	beq.n	39504 <dwt_ioctl+0x28c>
   394ea:	f014 0f02 	tst.w	r4, #2
   394ee:	f04f 0500 	mov.w	r5, #0
   394f2:	9500      	str	r5, [sp, #0]
   394f4:	462b      	mov	r3, r5
   394f6:	462a      	mov	r2, r5
   394f8:	bf14      	ite	ne
   394fa:	2111      	movne	r1, #17
   394fc:	210b      	moveq	r1, #11
   394fe:	f7fe facb 	bl	37a98 <dwt_writetodevice>
   39502:	e763      	b.n	393cc <dwt_ioctl+0x154>
   39504:	f014 0f02 	tst.w	r4, #2
   39508:	f04f 0500 	mov.w	r5, #0
   3950c:	9500      	str	r5, [sp, #0]
   3950e:	462b      	mov	r3, r5
   39510:	462a      	mov	r2, r5
   39512:	bf14      	ite	ne
   39514:	210c      	movne	r1, #12
   39516:	2101      	moveq	r1, #1
   39518:	f7fe fabe 	bl	37a98 <dwt_writetodevice>
   3951c:	e756      	b.n	393cc <dwt_ioctl+0x154>
   3951e:	2c00      	cmp	r4, #0
   39520:	f001 8489 	beq.w	3ae36 <dwt_ioctl+0x1bbe>
   39524:	6823      	ldr	r3, [r4, #0]
   39526:	2200      	movs	r2, #0
   39528:	212c      	movs	r1, #44	; 0x2c
   3952a:	f7fe fc13 	bl	37d54 <dwt_write32bitoffsetreg>
   3952e:	2500      	movs	r5, #0
   39530:	e74c      	b.n	393cc <dwt_ioctl+0x154>
   39532:	6823      	ldr	r3, [r4, #0]
   39534:	2200      	movs	r2, #0
   39536:	4962      	ldr	r1, [pc, #392]	; (396c0 <dwt_ioctl+0x448>)
   39538:	f7fe fc0c 	bl	37d54 <dwt_write32bitoffsetreg>
   3953c:	6863      	ldr	r3, [r4, #4]
   3953e:	2200      	movs	r2, #0
   39540:	4960      	ldr	r1, [pc, #384]	; (396c4 <dwt_ioctl+0x44c>)
   39542:	4630      	mov	r0, r6
   39544:	f7fe fc06 	bl	37d54 <dwt_write32bitoffsetreg>
   39548:	68a3      	ldr	r3, [r4, #8]
   3954a:	2200      	movs	r2, #0
   3954c:	495e      	ldr	r1, [pc, #376]	; (396c8 <dwt_ioctl+0x450>)
   3954e:	4630      	mov	r0, r6
   39550:	f7fe fc00 	bl	37d54 <dwt_write32bitoffsetreg>
   39554:	68e3      	ldr	r3, [r4, #12]
   39556:	2200      	movs	r2, #0
   39558:	495c      	ldr	r1, [pc, #368]	; (396cc <dwt_ioctl+0x454>)
   3955a:	4630      	mov	r0, r6
   3955c:	f7fe fbfa 	bl	37d54 <dwt_write32bitoffsetreg>
   39560:	2500      	movs	r5, #0
   39562:	e733      	b.n	393cc <dwt_ioctl+0x154>
   39564:	2c00      	cmp	r4, #0
   39566:	f001 8469 	beq.w	3ae3c <dwt_ioctl+0x1bc4>
   3956a:	8823      	ldrh	r3, [r4, #0]
   3956c:	6865      	ldr	r5, [r4, #4]
   3956e:	2d03      	cmp	r5, #3
   39570:	f201 8467 	bhi.w	3ae42 <dwt_ioctl+0x1bca>
   39574:	e8df f005 	tbb	[pc, r5]
   39578:	130d0702 	.word	0x130d0702
   3957c:	2200      	movs	r2, #0
   3957e:	4954      	ldr	r1, [pc, #336]	; (396d0 <dwt_ioctl+0x458>)
   39580:	f7fe fae7 	bl	37b52 <dwt_write16bitoffsetreg>
   39584:	e722      	b.n	393cc <dwt_ioctl+0x154>
   39586:	2202      	movs	r2, #2
   39588:	4951      	ldr	r1, [pc, #324]	; (396d0 <dwt_ioctl+0x458>)
   3958a:	f7fe fae2 	bl	37b52 <dwt_write16bitoffsetreg>
   3958e:	2500      	movs	r5, #0
   39590:	e71c      	b.n	393cc <dwt_ioctl+0x154>
   39592:	2200      	movs	r2, #0
   39594:	494f      	ldr	r1, [pc, #316]	; (396d4 <dwt_ioctl+0x45c>)
   39596:	f7fe fadc 	bl	37b52 <dwt_write16bitoffsetreg>
   3959a:	2500      	movs	r5, #0
   3959c:	e716      	b.n	393cc <dwt_ioctl+0x154>
   3959e:	2202      	movs	r2, #2
   395a0:	494c      	ldr	r1, [pc, #304]	; (396d4 <dwt_ioctl+0x45c>)
   395a2:	f7fe fad6 	bl	37b52 <dwt_write16bitoffsetreg>
   395a6:	2500      	movs	r5, #0
   395a8:	e710      	b.n	393cc <dwt_ioctl+0x154>
   395aa:	2c00      	cmp	r4, #0
   395ac:	f001 844c 	beq.w	3ae48 <dwt_ioctl+0x1bd0>
   395b0:	7823      	ldrb	r3, [r4, #0]
   395b2:	005b      	lsls	r3, r3, #1
   395b4:	f003 0306 	and.w	r3, r3, #6
   395b8:	9300      	str	r3, [sp, #0]
   395ba:	f06f 0306 	mvn.w	r3, #6
   395be:	2200      	movs	r2, #0
   395c0:	4945      	ldr	r1, [pc, #276]	; (396d8 <dwt_ioctl+0x460>)
   395c2:	f7fe ff59 	bl	38478 <dwt_modify32bitoffsetreg>
   395c6:	2500      	movs	r5, #0
   395c8:	e700      	b.n	393cc <dwt_ioctl+0x154>
   395ca:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   395ce:	9300      	str	r3, [sp, #0]
   395d0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   395d4:	2200      	movs	r2, #0
   395d6:	4941      	ldr	r1, [pc, #260]	; (396dc <dwt_ioctl+0x464>)
   395d8:	f7fe ff4e 	bl	38478 <dwt_modify32bitoffsetreg>
   395dc:	2500      	movs	r5, #0
   395de:	e6f5      	b.n	393cc <dwt_ioctl+0x154>
   395e0:	2c00      	cmp	r4, #0
   395e2:	f001 8434 	beq.w	3ae4e <dwt_ioctl+0x1bd6>
   395e6:	6d03      	ldr	r3, [r0, #80]	; 0x50
   395e8:	7b5b      	ldrb	r3, [r3, #13]
   395ea:	7023      	strb	r3, [r4, #0]
   395ec:	2500      	movs	r5, #0
   395ee:	e6ed      	b.n	393cc <dwt_ioctl+0x154>
   395f0:	2c00      	cmp	r4, #0
   395f2:	f001 842f 	beq.w	3ae54 <dwt_ioctl+0x1bdc>
   395f6:	6d03      	ldr	r3, [r0, #80]	; 0x50
   395f8:	7a9b      	ldrb	r3, [r3, #10]
   395fa:	7023      	strb	r3, [r4, #0]
   395fc:	2500      	movs	r5, #0
   395fe:	e6e5      	b.n	393cc <dwt_ioctl+0x154>
   39600:	2c00      	cmp	r4, #0
   39602:	f001 842a 	beq.w	3ae5a <dwt_ioctl+0x1be2>
   39606:	6d03      	ldr	r3, [r0, #80]	; 0x50
   39608:	7adb      	ldrb	r3, [r3, #11]
   3960a:	7023      	strb	r3, [r4, #0]
   3960c:	2500      	movs	r5, #0
   3960e:	e6dd      	b.n	393cc <dwt_ioctl+0x154>
   39610:	2c00      	cmp	r4, #0
   39612:	f001 8425 	beq.w	3ae60 <dwt_ioctl+0x1be8>
   39616:	6d03      	ldr	r3, [r0, #80]	; 0x50
   39618:	681b      	ldr	r3, [r3, #0]
   3961a:	6023      	str	r3, [r4, #0]
   3961c:	2500      	movs	r5, #0
   3961e:	e6d5      	b.n	393cc <dwt_ioctl+0x154>
   39620:	2c00      	cmp	r4, #0
   39622:	f001 8420 	beq.w	3ae66 <dwt_ioctl+0x1bee>
   39626:	6d03      	ldr	r3, [r0, #80]	; 0x50
   39628:	685b      	ldr	r3, [r3, #4]
   3962a:	6023      	str	r3, [r4, #0]
   3962c:	2500      	movs	r5, #0
   3962e:	e6cd      	b.n	393cc <dwt_ioctl+0x154>
   39630:	f7fe fb7e 	bl	37d30 <ull_signal_rx_buff_free>
   39634:	2500      	movs	r5, #0
   39636:	e6c9      	b.n	393cc <dwt_ioctl+0x154>
   39638:	2c00      	cmp	r4, #0
   3963a:	f001 8417 	beq.w	3ae6c <dwt_ioctl+0x1bf4>
   3963e:	6821      	ldr	r1, [r4, #0]
   39640:	f7fe fd24 	bl	3808c <ull_setrxaftertxdelay>
   39644:	2500      	movs	r5, #0
   39646:	e6c1      	b.n	393cc <dwt_ioctl+0x154>
   39648:	2c00      	cmp	r4, #0
   3964a:	f001 8412 	beq.w	3ae72 <dwt_ioctl+0x1bfa>
   3964e:	7825      	ldrb	r5, [r4, #0]
   39650:	b15d      	cbz	r5, 3966a <dwt_ioctl+0x3f2>
   39652:	6864      	ldr	r4, [r4, #4]
   39654:	2340      	movs	r3, #64	; 0x40
   39656:	9300      	str	r3, [sp, #0]
   39658:	23ff      	movs	r3, #255	; 0xff
   3965a:	2200      	movs	r2, #0
   3965c:	2110      	movs	r1, #16
   3965e:	f7ff f8f5 	bl	3884c <dwt_modify8bitoffsetreg>
   39662:	2d02      	cmp	r5, #2
   39664:	d107      	bne.n	39676 <dwt_ioctl+0x3fe>
   39666:	60f4      	str	r4, [r6, #12]
   39668:	e005      	b.n	39676 <dwt_ioctl+0x3fe>
   3966a:	2200      	movs	r2, #0
   3966c:	9200      	str	r2, [sp, #0]
   3966e:	23bf      	movs	r3, #191	; 0xbf
   39670:	2110      	movs	r1, #16
   39672:	f7ff f8eb 	bl	3884c <dwt_modify8bitoffsetreg>
   39676:	6d33      	ldr	r3, [r6, #80]	; 0x50
   39678:	759d      	strb	r5, [r3, #22]
   3967a:	2500      	movs	r5, #0
   3967c:	e6a6      	b.n	393cc <dwt_ioctl+0x154>
   3967e:	2c00      	cmp	r4, #0
   39680:	f001 83fa 	beq.w	3ae78 <dwt_ioctl+0x1c00>
   39684:	6865      	ldr	r5, [r4, #4]
   39686:	7823      	ldrb	r3, [r4, #0]
   39688:	2203      	movs	r2, #3
   3968a:	4915      	ldr	r1, [pc, #84]	; (396e0 <dwt_ioctl+0x468>)
   3968c:	f7fe fa0f 	bl	37aae <dwt_write8bitoffsetreg>
   39690:	b945      	cbnz	r5, 396a4 <dwt_ioctl+0x42c>
   39692:	2200      	movs	r2, #0
   39694:	9200      	str	r2, [sp, #0]
   39696:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   3969a:	2110      	movs	r1, #16
   3969c:	4630      	mov	r0, r6
   3969e:	f7ff fa87 	bl	38bb0 <dwt_modify16bitoffsetreg>
   396a2:	e693      	b.n	393cc <dwt_ioctl+0x154>
   396a4:	f44f 2381 	mov.w	r3, #264192	; 0x40800
   396a8:	9300      	str	r3, [sp, #0]
   396aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   396ae:	2200      	movs	r2, #0
   396b0:	2110      	movs	r1, #16
   396b2:	4630      	mov	r0, r6
   396b4:	f7fe fee0 	bl	38478 <dwt_modify32bitoffsetreg>
   396b8:	2500      	movs	r5, #0
   396ba:	e687      	b.n	393cc <dwt_ioctl+0x154>
   396bc:	000f0030 	.word	0x000f0030
   396c0:	00010054 	.word	0x00010054
   396c4:	00010058 	.word	0x00010058
   396c8:	0001005c 	.word	0x0001005c
   396cc:	00010060 	.word	0x00010060
   396d0:	00010018 	.word	0x00010018
   396d4:	0001001c 	.word	0x0001001c
   396d8:	00010014 	.word	0x00010014
   396dc:	00110004 	.word	0x00110004
   396e0:	00010008 	.word	0x00010008
   396e4:	2200      	movs	r2, #0
   396e6:	4611      	mov	r1, r2
   396e8:	f7fd fdf2 	bl	372d0 <dwt_read32bitoffsetreg>
   396ec:	68b2      	ldr	r2, [r6, #8]
   396ee:	6813      	ldr	r3, [r2, #0]
   396f0:	4043      	eors	r3, r0
   396f2:	6852      	ldr	r2, [r2, #4]
   396f4:	4213      	tst	r3, r2
   396f6:	bf14      	ite	ne
   396f8:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   396fc:	2500      	moveq	r5, #0
   396fe:	e665      	b.n	393cc <dwt_ioctl+0x154>
   39700:	2c00      	cmp	r4, #0
   39702:	f001 83bc 	beq.w	3ae7e <dwt_ioctl+0x1c06>
   39706:	7821      	ldrb	r1, [r4, #0]
   39708:	f7ff f8b4 	bl	38874 <ull_configciadiag>
   3970c:	2500      	movs	r5, #0
   3970e:	e65d      	b.n	393cc <dwt_ioctl+0x154>
   39710:	b93a      	cbnz	r2, 39722 <dwt_ioctl+0x4aa>
   39712:	2200      	movs	r2, #0
   39714:	9200      	str	r2, [sp, #0]
   39716:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   3971a:	49ae      	ldr	r1, [pc, #696]	; (399d4 <dwt_ioctl+0x75c>)
   3971c:	f7ff fa48 	bl	38bb0 <dwt_modify16bitoffsetreg>
   39720:	e654      	b.n	393cc <dwt_ioctl+0x154>
   39722:	f44f 6300 	mov.w	r3, #2048	; 0x800
   39726:	9300      	str	r3, [sp, #0]
   39728:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3972c:	2200      	movs	r2, #0
   3972e:	49a9      	ldr	r1, [pc, #676]	; (399d4 <dwt_ioctl+0x75c>)
   39730:	f7ff fa3e 	bl	38bb0 <dwt_modify16bitoffsetreg>
   39734:	2500      	movs	r5, #0
   39736:	e649      	b.n	393cc <dwt_ioctl+0x154>
   39738:	f002 0201 	and.w	r2, r2, #1
   3973c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   39740:	f24f 71ff 	movw	r1, #63487	; 0xf7ff
   39744:	2a00      	cmp	r2, #0
   39746:	bf08      	it	eq
   39748:	460b      	moveq	r3, r1
   3974a:	02d2      	lsls	r2, r2, #11
   3974c:	f015 0f02 	tst.w	r5, #2
   39750:	bf12      	itee	ne
   39752:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
   39756:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   3975a:	b29b      	uxtheq	r3, r3
   3975c:	9200      	str	r2, [sp, #0]
   3975e:	2200      	movs	r2, #0
   39760:	499c      	ldr	r1, [pc, #624]	; (399d4 <dwt_ioctl+0x75c>)
   39762:	f7ff fa25 	bl	38bb0 <dwt_modify16bitoffsetreg>
   39766:	2500      	movs	r5, #0
   39768:	e630      	b.n	393cc <dwt_ioctl+0x154>
   3976a:	b92a      	cbnz	r2, 39778 <dwt_ioctl+0x500>
   3976c:	4b9a      	ldr	r3, [pc, #616]	; (399d8 <dwt_ioctl+0x760>)
   3976e:	2202      	movs	r2, #2
   39770:	499a      	ldr	r1, [pc, #616]	; (399dc <dwt_ioctl+0x764>)
   39772:	f7fe faef 	bl	37d54 <dwt_write32bitoffsetreg>
   39776:	e629      	b.n	393cc <dwt_ioctl+0x154>
   39778:	4b99      	ldr	r3, [pc, #612]	; (399e0 <dwt_ioctl+0x768>)
   3977a:	2202      	movs	r2, #2
   3977c:	4997      	ldr	r1, [pc, #604]	; (399dc <dwt_ioctl+0x764>)
   3977e:	f7fe fae9 	bl	37d54 <dwt_write32bitoffsetreg>
   39782:	2500      	movs	r5, #0
   39784:	e622      	b.n	393cc <dwt_ioctl+0x154>
   39786:	4611      	mov	r1, r2
   39788:	f7fe fc96 	bl	380b8 <ull_setlnapamode>
   3978c:	2500      	movs	r5, #0
   3978e:	e61d      	b.n	393cc <dwt_ioctl+0x154>
   39790:	2c00      	cmp	r4, #0
   39792:	f001 8377 	beq.w	3ae84 <dwt_ioctl+0x1c0c>
   39796:	2200      	movs	r2, #0
   39798:	4992      	ldr	r1, [pc, #584]	; (399e4 <dwt_ioctl+0x76c>)
   3979a:	f7fd fdc1 	bl	37320 <dwt_read8bitoffsetreg>
   3979e:	7020      	strb	r0, [r4, #0]
   397a0:	2500      	movs	r5, #0
   397a2:	e613      	b.n	393cc <dwt_ioctl+0x154>
   397a4:	4621      	mov	r1, r4
   397a6:	f7fe fca9 	bl	380fc <ull_configurestskey>
   397aa:	2500      	movs	r5, #0
   397ac:	e60e      	b.n	393cc <dwt_ioctl+0x154>
   397ae:	4621      	mov	r1, r4
   397b0:	f7fe fcc8 	bl	38144 <ull_configurestsiv>
   397b4:	2500      	movs	r5, #0
   397b6:	e609      	b.n	393cc <dwt_ioctl+0x154>
   397b8:	2301      	movs	r3, #1
   397ba:	9300      	str	r3, [sp, #0]
   397bc:	23ff      	movs	r3, #255	; 0xff
   397be:	2200      	movs	r2, #0
   397c0:	4989      	ldr	r1, [pc, #548]	; (399e8 <dwt_ioctl+0x770>)
   397c2:	f7ff f843 	bl	3884c <dwt_modify8bitoffsetreg>
   397c6:	2500      	movs	r5, #0
   397c8:	e600      	b.n	393cc <dwt_ioctl+0x154>
   397ca:	4611      	mov	r1, r2
   397cc:	f7fe fcde 	bl	3818c <ull_configmrxlut>
   397d0:	2500      	movs	r5, #0
   397d2:	e5fb      	b.n	393cc <dwt_ioctl+0x154>
   397d4:	6d03      	ldr	r3, [r0, #80]	; 0x50
   397d6:	7a1b      	ldrb	r3, [r3, #8]
   397d8:	2b00      	cmp	r3, #0
   397da:	d137      	bne.n	3984c <dwt_ioctl+0x5d4>
   397dc:	2314      	movs	r3, #20
   397de:	2201      	movs	r2, #1
   397e0:	4982      	ldr	r1, [pc, #520]	; (399ec <dwt_ioctl+0x774>)
   397e2:	4630      	mov	r0, r6
   397e4:	f7fe f963 	bl	37aae <dwt_write8bitoffsetreg>
   397e8:	2318      	movs	r3, #24
   397ea:	2200      	movs	r2, #0
   397ec:	4980      	ldr	r1, [pc, #512]	; (399f0 <dwt_ioctl+0x778>)
   397ee:	4630      	mov	r0, r6
   397f0:	f7fe fab0 	bl	37d54 <dwt_write32bitoffsetreg>
   397f4:	23e8      	movs	r3, #232	; 0xe8
   397f6:	2200      	movs	r2, #0
   397f8:	497e      	ldr	r1, [pc, #504]	; (399f4 <dwt_ioctl+0x77c>)
   397fa:	4630      	mov	r0, r6
   397fc:	f7fe faaa 	bl	37d54 <dwt_write32bitoffsetreg>
   39800:	6d33      	ldr	r3, [r6, #80]	; 0x50
   39802:	8a5b      	ldrh	r3, [r3, #18]
   39804:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
   39808:	2b20      	cmp	r3, #32
   3980a:	d022      	beq.n	39852 <dwt_ioctl+0x5da>
   3980c:	2b60      	cmp	r3, #96	; 0x60
   3980e:	d02b      	beq.n	39868 <dwt_ioctl+0x5f0>
   39810:	6d33      	ldr	r3, [r6, #80]	; 0x50
   39812:	7e1b      	ldrb	r3, [r3, #24]
   39814:	085b      	lsrs	r3, r3, #1
   39816:	d032      	beq.n	3987e <dwt_ioctl+0x606>
   39818:	2200      	movs	r2, #0
   3981a:	4977      	ldr	r1, [pc, #476]	; (399f8 <dwt_ioctl+0x780>)
   3981c:	4630      	mov	r0, r6
   3981e:	f7fd fd6d 	bl	372fc <dwt_read16bitoffsetreg>
   39822:	f3c0 03c4 	ubfx	r3, r0, #3, #5
   39826:	3b09      	subs	r3, #9
   39828:	2b0f      	cmp	r3, #15
   3982a:	f201 832e 	bhi.w	3ae8a <dwt_ioctl+0x1c12>
   3982e:	f000 0001 	and.w	r0, r0, #1
   39832:	2800      	cmp	r0, #0
   39834:	bf0c      	ite	eq
   39836:	2105      	moveq	r1, #5
   39838:	2109      	movne	r1, #9
   3983a:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3983c:	7a5b      	ldrb	r3, [r3, #9]
   3983e:	2b01      	cmp	r3, #1
   39840:	d029      	beq.n	39896 <dwt_ioctl+0x61e>
   39842:	4630      	mov	r0, r6
   39844:	f7fe fca2 	bl	3818c <ull_configmrxlut>
   39848:	2500      	movs	r5, #0
   3984a:	e5bf      	b.n	393cc <dwt_ioctl+0x154>
   3984c:	f7ff f9ca 	bl	38be4 <_dwt_prog_ldo_and_bias_tune>
   39850:	e7c4      	b.n	397dc <dwt_ioctl+0x564>
   39852:	f44f 6380 	mov.w	r3, #1024	; 0x400
   39856:	9300      	str	r3, [sp, #0]
   39858:	f46f 53c0 	mvn.w	r3, #6144	; 0x1800
   3985c:	2200      	movs	r2, #0
   3985e:	4967      	ldr	r1, [pc, #412]	; (399fc <dwt_ioctl+0x784>)
   39860:	4630      	mov	r0, r6
   39862:	f7fe fe09 	bl	38478 <dwt_modify32bitoffsetreg>
   39866:	e7d3      	b.n	39810 <dwt_ioctl+0x598>
   39868:	f44f 6340 	mov.w	r3, #3072	; 0xc00
   3986c:	9300      	str	r3, [sp, #0]
   3986e:	f46f 53c0 	mvn.w	r3, #6144	; 0x1800
   39872:	2200      	movs	r2, #0
   39874:	4961      	ldr	r1, [pc, #388]	; (399fc <dwt_ioctl+0x784>)
   39876:	4630      	mov	r0, r6
   39878:	f7fe fdfe 	bl	38478 <dwt_modify32bitoffsetreg>
   3987c:	e7c8      	b.n	39810 <dwt_ioctl+0x598>
   3987e:	2301      	movs	r3, #1
   39880:	2200      	movs	r2, #0
   39882:	495f      	ldr	r1, [pc, #380]	; (39a00 <dwt_ioctl+0x788>)
   39884:	4630      	mov	r0, r6
   39886:	f7fe f912 	bl	37aae <dwt_write8bitoffsetreg>
   3988a:	6d32      	ldr	r2, [r6, #80]	; 0x50
   3988c:	7e13      	ldrb	r3, [r2, #24]
   3988e:	f043 0302 	orr.w	r3, r3, #2
   39892:	7613      	strb	r3, [r2, #24]
   39894:	e7c0      	b.n	39818 <dwt_ioctl+0x5a0>
   39896:	4630      	mov	r0, r6
   39898:	f7fe fe12 	bl	384c0 <_dwt_kick_dgc_on_wakeup>
   3989c:	2500      	movs	r5, #0
   3989e:	e595      	b.n	393cc <dwt_ioctl+0x154>
   398a0:	2c00      	cmp	r4, #0
   398a2:	f001 82f5 	beq.w	3ae90 <dwt_ioctl+0x1c18>
   398a6:	7823      	ldrb	r3, [r4, #0]
   398a8:	6d02      	ldr	r2, [r0, #80]	; 0x50
   398aa:	75d3      	strb	r3, [r2, #23]
   398ac:	031b      	lsls	r3, r3, #12
   398ae:	f403 4330 	and.w	r3, r3, #45056	; 0xb000
   398b2:	9300      	str	r3, [sp, #0]
   398b4:	f644 73ff 	movw	r3, #20479	; 0x4fff
   398b8:	2200      	movs	r2, #0
   398ba:	2110      	movs	r1, #16
   398bc:	f7ff f978 	bl	38bb0 <dwt_modify16bitoffsetreg>
   398c0:	2500      	movs	r5, #0
   398c2:	e583      	b.n	393cc <dwt_ioctl+0x154>
   398c4:	2c00      	cmp	r4, #0
   398c6:	f001 82e6 	beq.w	3ae96 <dwt_ioctl+0x1c1e>
   398ca:	8823      	ldrh	r3, [r4, #0]
   398cc:	2200      	movs	r2, #0
   398ce:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   398d2:	f7fe f93e 	bl	37b52 <dwt_write16bitoffsetreg>
   398d6:	2500      	movs	r5, #0
   398d8:	e578      	b.n	393cc <dwt_ioctl+0x154>
   398da:	2c00      	cmp	r4, #0
   398dc:	f001 82de 	beq.w	3ae9c <dwt_ioctl+0x1c24>
   398e0:	2200      	movs	r2, #0
   398e2:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   398e6:	f7fd fd09 	bl	372fc <dwt_read16bitoffsetreg>
   398ea:	8020      	strh	r0, [r4, #0]
   398ec:	2500      	movs	r5, #0
   398ee:	e56d      	b.n	393cc <dwt_ioctl+0x154>
   398f0:	2c00      	cmp	r4, #0
   398f2:	f001 82d6 	beq.w	3aea2 <dwt_ioctl+0x1c2a>
   398f6:	8823      	ldrh	r3, [r4, #0]
   398f8:	2200      	movs	r2, #0
   398fa:	4942      	ldr	r1, [pc, #264]	; (39a04 <dwt_ioctl+0x78c>)
   398fc:	f7fe f929 	bl	37b52 <dwt_write16bitoffsetreg>
   39900:	2500      	movs	r5, #0
   39902:	e563      	b.n	393cc <dwt_ioctl+0x154>
   39904:	2c00      	cmp	r4, #0
   39906:	f001 82cf 	beq.w	3aea8 <dwt_ioctl+0x1c30>
   3990a:	2200      	movs	r2, #0
   3990c:	493d      	ldr	r1, [pc, #244]	; (39a04 <dwt_ioctl+0x78c>)
   3990e:	f7fd fcf5 	bl	372fc <dwt_read16bitoffsetreg>
   39912:	8020      	strh	r0, [r4, #0]
   39914:	2500      	movs	r5, #0
   39916:	e559      	b.n	393cc <dwt_ioctl+0x154>
   39918:	2c00      	cmp	r4, #0
   3991a:	f001 82c8 	beq.w	3aeae <dwt_ioctl+0x1c36>
   3991e:	88a3      	ldrh	r3, [r4, #4]
   39920:	88e2      	ldrh	r2, [r4, #6]
   39922:	6821      	ldr	r1, [r4, #0]
   39924:	9100      	str	r1, [sp, #0]
   39926:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   3992a:	f7fe f8b5 	bl	37a98 <dwt_writetodevice>
   3992e:	2500      	movs	r5, #0
   39930:	e54c      	b.n	393cc <dwt_ioctl+0x154>
   39932:	2c00      	cmp	r4, #0
   39934:	f001 82be 	beq.w	3aeb4 <dwt_ioctl+0x1c3c>
   39938:	88a3      	ldrh	r3, [r4, #4]
   3993a:	88e2      	ldrh	r2, [r4, #6]
   3993c:	6821      	ldr	r1, [r4, #0]
   3993e:	9100      	str	r1, [sp, #0]
   39940:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   39944:	f7fd fcba 	bl	372bc <dwt_readfromdevice>
   39948:	2500      	movs	r5, #0
   3994a:	e53f      	b.n	393cc <dwt_ioctl+0x154>
   3994c:	2c00      	cmp	r4, #0
   3994e:	f001 82b4 	beq.w	3aeba <dwt_ioctl+0x1c42>
   39952:	88e3      	ldrh	r3, [r4, #6]
   39954:	88a2      	ldrh	r2, [r4, #4]
   39956:	6821      	ldr	r1, [r4, #0]
   39958:	f7fe fcc2 	bl	382e0 <ull_readrxdata>
   3995c:	2500      	movs	r5, #0
   3995e:	e535      	b.n	393cc <dwt_ioctl+0x154>
   39960:	2c00      	cmp	r4, #0
   39962:	f001 82ad 	beq.w	3aec0 <dwt_ioctl+0x1c48>
   39966:	88e3      	ldrh	r3, [r4, #6]
   39968:	6822      	ldr	r2, [r4, #0]
   3996a:	88a1      	ldrh	r1, [r4, #4]
   3996c:	f7fe fd52 	bl	38414 <ull_writetxdata>
   39970:	2500      	movs	r5, #0
   39972:	e52b      	b.n	393cc <dwt_ioctl+0x154>
   39974:	4611      	mov	r1, r2
   39976:	f7fe fce9 	bl	3834c <ull_rxenable>
   3997a:	2500      	movs	r5, #0
   3997c:	e526      	b.n	393cc <dwt_ioctl+0x154>
   3997e:	2c00      	cmp	r4, #0
   39980:	f001 82a1 	beq.w	3aec6 <dwt_ioctl+0x1c4e>
   39984:	7923      	ldrb	r3, [r4, #4]
   39986:	8862      	ldrh	r2, [r4, #2]
   39988:	8821      	ldrh	r1, [r4, #0]
   3998a:	f7fe ff2d 	bl	387e8 <ull_writetxfctrl>
   3998e:	2500      	movs	r5, #0
   39990:	e51c      	b.n	393cc <dwt_ioctl+0x154>
   39992:	2c00      	cmp	r4, #0
   39994:	f001 829a 	beq.w	3aecc <dwt_ioctl+0x1c54>
   39998:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3999a:	7bdb      	ldrb	r3, [r3, #15]
   3999c:	2b01      	cmp	r3, #1
   3999e:	d00c      	beq.n	399ba <dwt_ioctl+0x742>
   399a0:	2b03      	cmp	r3, #3
   399a2:	d110      	bne.n	399c6 <dwt_ioctl+0x74e>
   399a4:	220c      	movs	r2, #12
   399a6:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   399aa:	f7fd fca7 	bl	372fc <dwt_read16bitoffsetreg>
   399ae:	b200      	sxth	r0, r0
   399b0:	f340 030c 	sbfx	r3, r0, #0, #13
   399b4:	8023      	strh	r3, [r4, #0]
   399b6:	2500      	movs	r5, #0
   399b8:	e508      	b.n	393cc <dwt_ioctl+0x154>
   399ba:	2200      	movs	r2, #0
   399bc:	4912      	ldr	r1, [pc, #72]	; (39a08 <dwt_ioctl+0x790>)
   399be:	f7fd fc9d 	bl	372fc <dwt_read16bitoffsetreg>
   399c2:	b200      	sxth	r0, r0
   399c4:	e7f4      	b.n	399b0 <dwt_ioctl+0x738>
   399c6:	2200      	movs	r2, #0
   399c8:	4910      	ldr	r1, [pc, #64]	; (39a0c <dwt_ioctl+0x794>)
   399ca:	f7fd fc97 	bl	372fc <dwt_read16bitoffsetreg>
   399ce:	b200      	sxth	r0, r0
   399d0:	e7ee      	b.n	399b0 <dwt_ioctl+0x738>
   399d2:	bf00      	nop
   399d4:	00110008 	.word	0x00110008
   399d8:	00d20874 	.word	0x00d20874
   399dc:	00110010 	.word	0x00110010
   399e0:	04d28874 	.word	0x04d28874
   399e4:	0007001c 	.word	0x0007001c
   399e8:	00020004 	.word	0x00020004
   399ec:	00070050 	.word	0x00070050
   399f0:	001f000c 	.word	0x001f000c
   399f4:	001f0010 	.word	0x001f0010
   399f8:	00010014 	.word	0x00010014
   399fc:	000b0008 	.word	0x000b0008
   39a00:	00010028 	.word	0x00010028
   39a04:	00010004 	.word	0x00010004
   39a08:	0018000c 	.word	0x0018000c
   39a0c:	000c0020 	.word	0x000c0020
   39a10:	2c00      	cmp	r4, #0
   39a12:	f001 825e 	beq.w	3aed2 <dwt_ioctl+0x1c5a>
   39a16:	ab0c      	add	r3, sp, #48	; 0x30
   39a18:	9300      	str	r3, [sp, #0]
   39a1a:	2303      	movs	r3, #3
   39a1c:	2200      	movs	r2, #0
   39a1e:	49bb      	ldr	r1, [pc, #748]	; (39d0c <dwt_ioctl+0xa94>)
   39a20:	f7fd fc4c 	bl	372bc <dwt_readfromdevice>
   39a24:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   39a28:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   39a2c:	eb03 2202 	add.w	r2, r3, r2, lsl #8
   39a30:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   39a34:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   39a38:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   39a3c:	bf1c      	itt	ne
   39a3e:	ea6f 3303 	mvnne.w	r3, r3, lsl #12
   39a42:	ea6f 3313 	mvnne.w	r3, r3, lsr #12
   39a46:	6023      	str	r3, [r4, #0]
   39a48:	2500      	movs	r5, #0
   39a4a:	e4bf      	b.n	393cc <dwt_ioctl+0x154>
   39a4c:	f7fe f892 	bl	37b74 <ull_clearaonconfig>
   39a50:	2500      	movs	r5, #0
   39a52:	e4bb      	b.n	393cc <dwt_ioctl+0x154>
   39a54:	2c00      	cmp	r4, #0
   39a56:	f001 823f 	beq.w	3aed8 <dwt_ioctl+0x1c60>
   39a5a:	8861      	ldrh	r1, [r4, #2]
   39a5c:	f7fe ff40 	bl	388e0 <ull_calcbandwidthadj>
   39a60:	7020      	strb	r0, [r4, #0]
   39a62:	2500      	movs	r5, #0
   39a64:	e4b2      	b.n	393cc <dwt_ioctl+0x154>
   39a66:	4621      	mov	r1, r4
   39a68:	f7fd fc68 	bl	3733c <ull_readdiagnostics>
   39a6c:	2500      	movs	r5, #0
   39a6e:	e4ad      	b.n	393cc <dwt_ioctl+0x154>
   39a70:	2c00      	cmp	r4, #0
   39a72:	f001 8234 	beq.w	3aede <dwt_ioctl+0x1c66>
   39a76:	2201      	movs	r2, #1
   39a78:	2174      	movs	r1, #116	; 0x74
   39a7a:	f7fd fc29 	bl	372d0 <dwt_read32bitoffsetreg>
   39a7e:	6020      	str	r0, [r4, #0]
   39a80:	2500      	movs	r5, #0
   39a82:	e4a3      	b.n	393cc <dwt_ioctl+0x154>
   39a84:	2c00      	cmp	r4, #0
   39a86:	f001 822d 	beq.w	3aee4 <dwt_ioctl+0x1c6c>
   39a8a:	2200      	movs	r2, #0
   39a8c:	2174      	movs	r1, #116	; 0x74
   39a8e:	f7fd fc1f 	bl	372d0 <dwt_read32bitoffsetreg>
   39a92:	6020      	str	r0, [r4, #0]
   39a94:	2500      	movs	r5, #0
   39a96:	e499      	b.n	393cc <dwt_ioctl+0x154>
   39a98:	9400      	str	r4, [sp, #0]
   39a9a:	2305      	movs	r3, #5
   39a9c:	2200      	movs	r2, #0
   39a9e:	2174      	movs	r1, #116	; 0x74
   39aa0:	f7fd fc0c 	bl	372bc <dwt_readfromdevice>
   39aa4:	2500      	movs	r5, #0
   39aa6:	e491      	b.n	393cc <dwt_ioctl+0x154>
   39aa8:	2c00      	cmp	r4, #0
   39aaa:	f001 821e 	beq.w	3aeea <dwt_ioctl+0x1c72>
   39aae:	6d03      	ldr	r3, [r0, #80]	; 0x50
   39ab0:	7bdb      	ldrb	r3, [r3, #15]
   39ab2:	2b01      	cmp	r3, #1
   39ab4:	d014      	beq.n	39ae0 <dwt_ioctl+0x868>
   39ab6:	2b03      	cmp	r3, #3
   39ab8:	d119      	bne.n	39aee <dwt_ioctl+0x876>
   39aba:	2216      	movs	r2, #22
   39abc:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   39ac0:	f7fd fc1c 	bl	372fc <dwt_read16bitoffsetreg>
   39ac4:	f3c0 000d 	ubfx	r0, r0, #0, #14
   39ac8:	b283      	uxth	r3, r0
   39aca:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   39ace:	d004      	beq.n	39ada <dwt_ioctl+0x862>
   39ad0:	ea6f 4383 	mvn.w	r3, r3, lsl #18
   39ad4:	ea6f 4393 	mvn.w	r3, r3, lsr #18
   39ad8:	b218      	sxth	r0, r3
   39ada:	8020      	strh	r0, [r4, #0]
   39adc:	2500      	movs	r5, #0
   39ade:	e475      	b.n	393cc <dwt_ioctl+0x154>
   39ae0:	2202      	movs	r2, #2
   39ae2:	498b      	ldr	r1, [pc, #556]	; (39d10 <dwt_ioctl+0xa98>)
   39ae4:	f7fd fc0a 	bl	372fc <dwt_read16bitoffsetreg>
   39ae8:	f3c0 000d 	ubfx	r0, r0, #0, #14
   39aec:	e7ec      	b.n	39ac8 <dwt_ioctl+0x850>
   39aee:	2202      	movs	r2, #2
   39af0:	4988      	ldr	r1, [pc, #544]	; (39d14 <dwt_ioctl+0xa9c>)
   39af2:	f7fd fc03 	bl	372fc <dwt_read16bitoffsetreg>
   39af6:	f3c0 000d 	ubfx	r0, r0, #0, #14
   39afa:	e7e5      	b.n	39ac8 <dwt_ioctl+0x850>
   39afc:	9400      	str	r4, [sp, #0]
   39afe:	2306      	movs	r3, #6
   39b00:	2200      	movs	r2, #0
   39b02:	4985      	ldr	r1, [pc, #532]	; (39d18 <dwt_ioctl+0xaa0>)
   39b04:	f7fd fbda 	bl	372bc <dwt_readfromdevice>
   39b08:	7963      	ldrb	r3, [r4, #5]
   39b0a:	f003 0301 	and.w	r3, r3, #1
   39b0e:	7163      	strb	r3, [r4, #5]
   39b10:	2500      	movs	r5, #0
   39b12:	e45b      	b.n	393cc <dwt_ioctl+0x154>
   39b14:	2c00      	cmp	r4, #0
   39b16:	f001 81eb 	beq.w	3aef0 <dwt_ioctl+0x1c78>
   39b1a:	2201      	movs	r2, #1
   39b1c:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   39b20:	f7fd fbfe 	bl	37320 <dwt_read8bitoffsetreg>
   39b24:	7020      	strb	r0, [r4, #0]
   39b26:	2500      	movs	r5, #0
   39b28:	e450      	b.n	393cc <dwt_ioctl+0x154>
   39b2a:	2c00      	cmp	r4, #0
   39b2c:	f001 81e3 	beq.w	3aef6 <dwt_ioctl+0x1c7e>
   39b30:	2200      	movs	r2, #0
   39b32:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   39b36:	f7fd fbf3 	bl	37320 <dwt_read8bitoffsetreg>
   39b3a:	7020      	strb	r0, [r4, #0]
   39b3c:	2500      	movs	r5, #0
   39b3e:	e445      	b.n	393cc <dwt_ioctl+0x154>
   39b40:	2c00      	cmp	r4, #0
   39b42:	f001 81db 	beq.w	3aefc <dwt_ioctl+0x1c84>
   39b46:	88a2      	ldrh	r2, [r4, #4]
   39b48:	6821      	ldr	r1, [r4, #0]
   39b4a:	f7fe fd1d 	bl	38588 <_dwt_otpprogword32>
   39b4e:	2500      	movs	r5, #0
   39b50:	e43c      	b.n	393cc <dwt_ioctl+0x154>
   39b52:	2c00      	cmp	r4, #0
   39b54:	f001 81d5 	beq.w	3af02 <dwt_ioctl+0x1c8a>
   39b58:	6825      	ldr	r5, [r4, #0]
   39b5a:	88a4      	ldrh	r4, [r4, #4]
   39b5c:	4622      	mov	r2, r4
   39b5e:	4629      	mov	r1, r5
   39b60:	f7fe fd12 	bl	38588 <_dwt_otpprogword32>
   39b64:	4621      	mov	r1, r4
   39b66:	4630      	mov	r0, r6
   39b68:	f7fe f84e 	bl	37c08 <_dwt_otpread>
   39b6c:	1a2d      	subs	r5, r5, r0
   39b6e:	bf18      	it	ne
   39b70:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   39b74:	e42a      	b.n	393cc <dwt_ioctl+0x154>
   39b76:	2a02      	cmp	r2, #2
   39b78:	d00e      	beq.n	39b98 <dwt_ioctl+0x920>
   39b7a:	4c68      	ldr	r4, [pc, #416]	; (39d1c <dwt_ioctl+0xaa4>)
   39b7c:	2300      	movs	r3, #0
   39b7e:	461a      	mov	r2, r3
   39b80:	4621      	mov	r1, r4
   39b82:	4630      	mov	r0, r6
   39b84:	f7fd ff93 	bl	37aae <dwt_write8bitoffsetreg>
   39b88:	2302      	movs	r3, #2
   39b8a:	2200      	movs	r2, #0
   39b8c:	4621      	mov	r1, r4
   39b8e:	4630      	mov	r0, r6
   39b90:	f7fd ff8d 	bl	37aae <dwt_write8bitoffsetreg>
   39b94:	2500      	movs	r5, #0
   39b96:	e419      	b.n	393cc <dwt_ioctl+0x154>
   39b98:	2300      	movs	r3, #0
   39b9a:	9300      	str	r3, [sp, #0]
   39b9c:	23fe      	movs	r3, #254	; 0xfe
   39b9e:	2201      	movs	r2, #1
   39ba0:	495f      	ldr	r1, [pc, #380]	; (39d20 <dwt_ioctl+0xaa8>)
   39ba2:	f7fe fe53 	bl	3884c <dwt_modify8bitoffsetreg>
   39ba6:	e7e8      	b.n	39b7a <dwt_ioctl+0x902>
   39ba8:	2c00      	cmp	r4, #0
   39baa:	f001 81ad 	beq.w	3af08 <dwt_ioctl+0x1c90>
   39bae:	8824      	ldrh	r4, [r4, #0]
   39bb0:	b2e2      	uxtb	r2, r4
   39bb2:	f44f 7181 	mov.w	r1, #258	; 0x102
   39bb6:	f7fe f869 	bl	37c8c <ull_aon_write>
   39bba:	0a22      	lsrs	r2, r4, #8
   39bbc:	f240 1103 	movw	r1, #259	; 0x103
   39bc0:	4630      	mov	r0, r6
   39bc2:	f7fe f863 	bl	37c8c <ull_aon_write>
   39bc6:	2500      	movs	r5, #0
   39bc8:	e400      	b.n	393cc <dwt_ioctl+0x154>
   39bca:	2c00      	cmp	r4, #0
   39bcc:	f001 819f 	beq.w	3af0e <dwt_ioctl+0x1c96>
   39bd0:	f8df 8158 	ldr.w	r8, [pc, #344]	; 39d2c <dwt_ioctl+0xab4>
   39bd4:	2310      	movs	r3, #16
   39bd6:	9300      	str	r3, [sp, #0]
   39bd8:	23ff      	movs	r3, #255	; 0xff
   39bda:	2200      	movs	r2, #0
   39bdc:	4641      	mov	r1, r8
   39bde:	f7fe fe35 	bl	3884c <dwt_modify8bitoffsetreg>
   39be2:	f44f 7182 	mov.w	r1, #260	; 0x104
   39be6:	4630      	mov	r0, r6
   39be8:	f7fe f830 	bl	37c4c <ull_aon_read>
   39bec:	f000 05e0 	and.w	r5, r0, #224	; 0xe0
   39bf0:	462a      	mov	r2, r5
   39bf2:	f44f 7182 	mov.w	r1, #260	; 0x104
   39bf6:	4630      	mov	r0, r6
   39bf8:	f7fe f848 	bl	37c8c <ull_aon_write>
   39bfc:	f045 0204 	orr.w	r2, r5, #4
   39c00:	f44f 7182 	mov.w	r1, #260	; 0x104
   39c04:	4630      	mov	r0, r6
   39c06:	f7fe f841 	bl	37c8c <ull_aon_write>
   39c0a:	2002      	movs	r0, #2
   39c0c:	f7f4 fddf 	bl	2e7ce <deca_sleep>
   39c10:	f44f 7187 	mov.w	r1, #270	; 0x10e
   39c14:	4630      	mov	r0, r6
   39c16:	f7fe f819 	bl	37c4c <ull_aon_read>
   39c1a:	4607      	mov	r7, r0
   39c1c:	f240 110f 	movw	r1, #271	; 0x10f
   39c20:	4630      	mov	r0, r6
   39c22:	f7fe f813 	bl	37c4c <ull_aon_read>
   39c26:	4681      	mov	r9, r0
   39c28:	462a      	mov	r2, r5
   39c2a:	f44f 7182 	mov.w	r1, #260	; 0x104
   39c2e:	4630      	mov	r0, r6
   39c30:	f7fe f82c 	bl	37c8c <ull_aon_write>
   39c34:	2500      	movs	r5, #0
   39c36:	9500      	str	r5, [sp, #0]
   39c38:	23ef      	movs	r3, #239	; 0xef
   39c3a:	462a      	mov	r2, r5
   39c3c:	4641      	mov	r1, r8
   39c3e:	4630      	mov	r0, r6
   39c40:	f7fe fe04 	bl	3884c <dwt_modify8bitoffsetreg>
   39c44:	ea47 2709 	orr.w	r7, r7, r9, lsl #8
   39c48:	8027      	strh	r7, [r4, #0]
   39c4a:	f7ff bbbf 	b.w	393cc <dwt_ioctl+0x154>
   39c4e:	2c00      	cmp	r4, #0
   39c50:	f001 8160 	beq.w	3af14 <dwt_ioctl+0x1c9c>
   39c54:	78a2      	ldrb	r2, [r4, #2]
   39c56:	8821      	ldrh	r1, [r4, #0]
   39c58:	f7fe f840 	bl	37cdc <ull_configuresleep>
   39c5c:	2500      	movs	r5, #0
   39c5e:	f7ff bbb5 	b.w	393cc <dwt_ioctl+0x154>
   39c62:	f7fd ff87 	bl	37b74 <ull_clearaonconfig>
   39c66:	2001      	movs	r0, #1
   39c68:	f7f4 fdb1 	bl	2e7ce <deca_sleep>
   39c6c:	2303      	movs	r3, #3
   39c6e:	9300      	str	r3, [sp, #0]
   39c70:	23ff      	movs	r3, #255	; 0xff
   39c72:	2200      	movs	r2, #0
   39c74:	492b      	ldr	r1, [pc, #172]	; (39d24 <dwt_ioctl+0xaac>)
   39c76:	4630      	mov	r0, r6
   39c78:	f7fe fde8 	bl	3884c <dwt_modify8bitoffsetreg>
   39c7c:	2300      	movs	r3, #0
   39c7e:	461a      	mov	r2, r3
   39c80:	f44f 1188 	mov.w	r1, #1114112	; 0x110000
   39c84:	4630      	mov	r0, r6
   39c86:	f7fd ff12 	bl	37aae <dwt_write8bitoffsetreg>
   39c8a:	2001      	movs	r0, #1
   39c8c:	f7f4 fd9f 	bl	2e7ce <deca_sleep>
   39c90:	6d33      	ldr	r3, [r6, #80]	; 0x50
   39c92:	2500      	movs	r5, #0
   39c94:	73dd      	strb	r5, [r3, #15]
   39c96:	2202      	movs	r2, #2
   39c98:	825a      	strh	r2, [r3, #18]
   39c9a:	759d      	strb	r5, [r3, #22]
   39c9c:	75dd      	strb	r5, [r3, #23]
   39c9e:	741d      	strb	r5, [r3, #16]
   39ca0:	f7ff bb94 	b.w	393cc <dwt_ioctl+0x154>
   39ca4:	2c00      	cmp	r4, #0
   39ca6:	f001 8138 	beq.w	3af1a <dwt_ioctl+0x1ca2>
   39caa:	7823      	ldrb	r3, [r4, #0]
   39cac:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   39cb0:	6d02      	ldr	r2, [r0, #80]	; 0x50
   39cb2:	7393      	strb	r3, [r2, #14]
   39cb4:	2200      	movs	r2, #0
   39cb6:	491c      	ldr	r1, [pc, #112]	; (39d28 <dwt_ioctl+0xab0>)
   39cb8:	f7fd fef9 	bl	37aae <dwt_write8bitoffsetreg>
   39cbc:	2500      	movs	r5, #0
   39cbe:	f7ff bb85 	b.w	393cc <dwt_ioctl+0x154>
   39cc2:	2c00      	cmp	r4, #0
   39cc4:	f001 812c 	beq.w	3af20 <dwt_ioctl+0x1ca8>
   39cc8:	6d03      	ldr	r3, [r0, #80]	; 0x50
   39cca:	7b9b      	ldrb	r3, [r3, #14]
   39ccc:	7023      	strb	r3, [r4, #0]
   39cce:	2500      	movs	r5, #0
   39cd0:	f7ff bb7c 	b.w	393cc <dwt_ioctl+0x154>
   39cd4:	2101      	movs	r1, #1
   39cd6:	f7fe fc11 	bl	384fc <ull_enable_rf_tx>
   39cda:	4630      	mov	r0, r6
   39cdc:	f7fe fc42 	bl	38564 <ull_enable_rftx_blocks>
   39ce0:	2101      	movs	r1, #1
   39ce2:	4630      	mov	r0, r6
   39ce4:	f7fd ff66 	bl	37bb4 <ull_force_clocks>
   39ce8:	220f      	movs	r2, #15
   39cea:	2101      	movs	r1, #1
   39cec:	4630      	mov	r0, r6
   39cee:	f7ff f86f 	bl	38dd0 <ull_repeated_cw>
   39cf2:	2500      	movs	r5, #0
   39cf4:	f7ff bb6a 	b.w	393cc <dwt_ioctl+0x154>
   39cf8:	2c00      	cmp	r4, #0
   39cfa:	f001 8114 	beq.w	3af26 <dwt_ioctl+0x1cae>
   39cfe:	6862      	ldr	r2, [r4, #4]
   39d00:	6821      	ldr	r1, [r4, #0]
   39d02:	f7ff f865 	bl	38dd0 <ull_repeated_cw>
   39d06:	2500      	movs	r5, #0
   39d08:	f7ff bb60 	b.w	393cc <dwt_ioctl+0x154>
   39d0c:	00060029 	.word	0x00060029
   39d10:	00180014 	.word	0x00180014
   39d14:	000c001c 	.word	0x000c001c
   39d18:	000c0018 	.word	0x000c0018
   39d1c:	000a0004 	.word	0x000a0004
   39d20:	00110008 	.word	0x00110008
   39d24:	00110004 	.word	0x00110004
   39d28:	00090014 	.word	0x00090014
   39d2c:	00070048 	.word	0x00070048
   39d30:	2c00      	cmp	r4, #0
   39d32:	f001 80fb 	beq.w	3af2c <dwt_ioctl+0x1cb4>
   39d36:	4dd6      	ldr	r5, [pc, #856]	; (3a090 <dwt_ioctl+0xe18>)
   39d38:	2200      	movs	r2, #0
   39d3a:	4629      	mov	r1, r5
   39d3c:	f7fd faf0 	bl	37320 <dwt_read8bitoffsetreg>
   39d40:	4680      	mov	r8, r0
   39d42:	2302      	movs	r3, #2
   39d44:	9300      	str	r3, [sp, #0]
   39d46:	23ff      	movs	r3, #255	; 0xff
   39d48:	2200      	movs	r2, #0
   39d4a:	4629      	mov	r1, r5
   39d4c:	4630      	mov	r0, r6
   39d4e:	f7fe fd7d 	bl	3884c <dwt_modify8bitoffsetreg>
   39d52:	2304      	movs	r3, #4
   39d54:	2200      	movs	r2, #0
   39d56:	49cf      	ldr	r1, [pc, #828]	; (3a094 <dwt_ioctl+0xe1c>)
   39d58:	4630      	mov	r0, r6
   39d5a:	f7fd fea8 	bl	37aae <dwt_write8bitoffsetreg>
   39d5e:	2301      	movs	r3, #1
   39d60:	2200      	movs	r2, #0
   39d62:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   39d66:	4630      	mov	r0, r6
   39d68:	f7fd fea1 	bl	37aae <dwt_write8bitoffsetreg>
   39d6c:	4fca      	ldr	r7, [pc, #808]	; (3a098 <dwt_ioctl+0xe20>)
   39d6e:	2500      	movs	r5, #0
   39d70:	462a      	mov	r2, r5
   39d72:	4639      	mov	r1, r7
   39d74:	4630      	mov	r0, r6
   39d76:	f7fd fad3 	bl	37320 <dwt_read8bitoffsetreg>
   39d7a:	f010 0f01 	tst.w	r0, #1
   39d7e:	d0f7      	beq.n	39d70 <dwt_ioctl+0xaf8>
   39d80:	2200      	movs	r2, #0
   39d82:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   39d86:	4630      	mov	r0, r6
   39d88:	f7fd fab8 	bl	372fc <dwt_read16bitoffsetreg>
   39d8c:	4605      	mov	r5, r0
   39d8e:	2300      	movs	r3, #0
   39d90:	461a      	mov	r2, r3
   39d92:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   39d96:	4630      	mov	r0, r6
   39d98:	f7fd fe89 	bl	37aae <dwt_write8bitoffsetreg>
   39d9c:	2300      	movs	r3, #0
   39d9e:	461a      	mov	r2, r3
   39da0:	49bc      	ldr	r1, [pc, #752]	; (3a094 <dwt_ioctl+0xe1c>)
   39da2:	4630      	mov	r0, r6
   39da4:	f7fd fe83 	bl	37aae <dwt_write8bitoffsetreg>
   39da8:	4643      	mov	r3, r8
   39daa:	2200      	movs	r2, #0
   39dac:	49b8      	ldr	r1, [pc, #736]	; (3a090 <dwt_ioctl+0xe18>)
   39dae:	4630      	mov	r0, r6
   39db0:	f7fd fe7d 	bl	37aae <dwt_write8bitoffsetreg>
   39db4:	8025      	strh	r5, [r4, #0]
   39db6:	2500      	movs	r5, #0
   39db8:	f7ff bb08 	b.w	393cc <dwt_ioctl+0x154>
   39dbc:	2c00      	cmp	r4, #0
   39dbe:	f001 80b8 	beq.w	3af32 <dwt_ioctl+0x1cba>
   39dc2:	7923      	ldrb	r3, [r4, #4]
   39dc4:	6d02      	ldr	r2, [r0, #80]	; 0x50
   39dc6:	7ad2      	ldrb	r2, [r2, #11]
   39dc8:	1a9b      	subs	r3, r3, r2
   39dca:	ee07 3a90 	vmov	s15, r3
   39dce:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   39dd2:	ed9f 7ab2 	vldr	s14, [pc, #712]	; 3a09c <dwt_ioctl+0xe24>
   39dd6:	ee67 7a87 	vmul.f32	s15, s15, s14
   39dda:	eeb3 7a06 	vmov.f32	s14, #54	; 0x41b00000  22.0
   39dde:	ee77 7a87 	vadd.f32	s15, s15, s14
   39de2:	edc4 7a00 	vstr	s15, [r4]
   39de6:	2500      	movs	r5, #0
   39de8:	f7ff baf0 	b.w	393cc <dwt_ioctl+0x154>
   39dec:	2c00      	cmp	r4, #0
   39dee:	f001 80a3 	beq.w	3af38 <dwt_ioctl+0x1cc0>
   39df2:	7923      	ldrb	r3, [r4, #4]
   39df4:	6d02      	ldr	r2, [r0, #80]	; 0x50
   39df6:	7a92      	ldrb	r2, [r2, #10]
   39df8:	1a9b      	subs	r3, r3, r2
   39dfa:	ee07 3a90 	vmov	s15, r3
   39dfe:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   39e02:	ed9f 7aa7 	vldr	s14, [pc, #668]	; 3a0a0 <dwt_ioctl+0xe28>
   39e06:	ee67 7a87 	vmul.f32	s15, s15, s14
   39e0a:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   39e0e:	ee67 7a87 	vmul.f32	s15, s15, s14
   39e12:	eddf 6aa4 	vldr	s13, [pc, #656]	; 3a0a4 <dwt_ioctl+0xe2c>
   39e16:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   39e1a:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   39e1e:	ee77 7a27 	vadd.f32	s15, s14, s15
   39e22:	edc4 7a00 	vstr	s15, [r4]
   39e26:	2500      	movs	r5, #0
   39e28:	f7ff bad0 	b.w	393cc <dwt_ioctl+0x154>
   39e2c:	2c00      	cmp	r4, #0
   39e2e:	f001 8086 	beq.w	3af3e <dwt_ioctl+0x1cc6>
   39e32:	6824      	ldr	r4, [r4, #0]
   39e34:	2101      	movs	r1, #1
   39e36:	f7fe fb61 	bl	384fc <ull_enable_rf_tx>
   39e3a:	4630      	mov	r0, r6
   39e3c:	f7fe fb92 	bl	38564 <ull_enable_rftx_blocks>
   39e40:	2101      	movs	r1, #1
   39e42:	4630      	mov	r0, r6
   39e44:	f7fd feb6 	bl	37bb4 <ull_force_clocks>
   39e48:	4621      	mov	r1, r4
   39e4a:	4630      	mov	r0, r6
   39e4c:	f7fe fda4 	bl	38998 <ull_repeated_frames>
   39e50:	2500      	movs	r5, #0
   39e52:	f7ff babb 	b.w	393cc <dwt_ioctl+0x154>
   39e56:	2500      	movs	r5, #0
   39e58:	9500      	str	r5, [sp, #0]
   39e5a:	23ef      	movs	r3, #239	; 0xef
   39e5c:	462a      	mov	r2, r5
   39e5e:	4992      	ldr	r1, [pc, #584]	; (3a0a8 <dwt_ioctl+0xe30>)
   39e60:	f7fe fcf4 	bl	3884c <dwt_modify8bitoffsetreg>
   39e64:	2105      	movs	r1, #5
   39e66:	4630      	mov	r0, r6
   39e68:	f7fd fea4 	bl	37bb4 <ull_force_clocks>
   39e6c:	2101      	movs	r1, #1
   39e6e:	4630      	mov	r0, r6
   39e70:	f7fe fa18 	bl	382a4 <ull_disable_rf_tx>
   39e74:	4630      	mov	r0, r6
   39e76:	f7fe fa0b 	bl	38290 <ull_disable_rftx_blocks>
   39e7a:	f7ff baa7 	b.w	393cc <dwt_ioctl+0x154>
   39e7e:	2500      	movs	r5, #0
   39e80:	9500      	str	r5, [sp, #0]
   39e82:	23ef      	movs	r3, #239	; 0xef
   39e84:	462a      	mov	r2, r5
   39e86:	4988      	ldr	r1, [pc, #544]	; (3a0a8 <dwt_ioctl+0xe30>)
   39e88:	f7fe fce0 	bl	3884c <dwt_modify8bitoffsetreg>
   39e8c:	f7ff ba9e 	b.w	393cc <dwt_ioctl+0x154>
   39e90:	2c00      	cmp	r4, #0
   39e92:	f001 8057 	beq.w	3af44 <dwt_ioctl+0x1ccc>
   39e96:	6821      	ldr	r1, [r4, #0]
   39e98:	f7fe fd7e 	bl	38998 <ull_repeated_frames>
   39e9c:	2500      	movs	r5, #0
   39e9e:	f7ff ba95 	b.w	393cc <dwt_ioctl+0x154>
   39ea2:	2200      	movs	r2, #0
   39ea4:	4981      	ldr	r1, [pc, #516]	; (3a0ac <dwt_ioctl+0xe34>)
   39ea6:	f7fd fa29 	bl	372fc <dwt_read16bitoffsetreg>
   39eaa:	f3c0 050b 	ubfx	r5, r0, #0, #12
   39eae:	f410 6f00 	tst.w	r0, #2048	; 0x800
   39eb2:	bf18      	it	ne
   39eb4:	f445 4570 	orrne.w	r5, r5, #61440	; 0xf000
   39eb8:	b22d      	sxth	r5, r5
   39eba:	8025      	strh	r5, [r4, #0]
   39ebc:	6d33      	ldr	r3, [r6, #80]	; 0x50
   39ebe:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
   39ec2:	1aed      	subs	r5, r5, r3
   39ec4:	f7ff ba82 	b.w	393cc <dwt_ioctl+0x154>
   39ec8:	2c00      	cmp	r4, #0
   39eca:	f001 806d 	beq.w	3afa8 <dwt_ioctl+0x1d30>
   39ece:	f8d4 9004 	ldr.w	r9, [r4, #4]
   39ed2:	7a23      	ldrb	r3, [r4, #8]
   39ed4:	f899 2013 	ldrb.w	r2, [r9, #19]
   39ed8:	2aff      	cmp	r2, #255	; 0xff
   39eda:	f000 813f 	beq.w	3a15c <dwt_ioctl+0xee4>
   39ede:	2b00      	cmp	r3, #0
   39ee0:	d136      	bne.n	39f50 <dwt_ioctl+0xcd8>
   39ee2:	f8d9 3000 	ldr.w	r3, [r9]
   39ee6:	9300      	str	r3, [sp, #0]
   39ee8:	230c      	movs	r3, #12
   39eea:	2200      	movs	r2, #0
   39eec:	4970      	ldr	r1, [pc, #448]	; (3a0b0 <dwt_ioctl+0xe38>)
   39eee:	f7fd fdd3 	bl	37a98 <dwt_writetodevice>
   39ef2:	f899 300c 	ldrb.w	r3, [r9, #12]
   39ef6:	f8b9 200e 	ldrh.w	r2, [r9, #14]
   39efa:	18d1      	adds	r1, r2, r3
   39efc:	f899 2012 	ldrb.w	r2, [r9, #18]
   39f00:	2a00      	cmp	r2, #0
   39f02:	d15f      	bne.n	39fc4 <dwt_ioctl+0xd4c>
   39f04:	f899 0010 	ldrb.w	r0, [r9, #16]
   39f08:	2800      	cmp	r0, #0
   39f0a:	bf0b      	itete	eq
   39f0c:	227f      	moveq	r2, #127	; 0x7f
   39f0e:	f44f 6280 	movne.w	r2, #1024	; 0x400
   39f12:	f44f 15b0 	moveq.w	r5, #1441792	; 0x160000
   39f16:	f44f 15a0 	movne.w	r5, #1310720	; 0x140000
   39f1a:	f899 0013 	ldrb.w	r0, [r9, #19]
   39f1e:	1a12      	subs	r2, r2, r0
   39f20:	3a02      	subs	r2, #2
   39f22:	4291      	cmp	r1, r2
   39f24:	f200 8120 	bhi.w	3a168 <dwt_ioctl+0xef0>
   39f28:	f8d9 2004 	ldr.w	r2, [r9, #4]
   39f2c:	9200      	str	r2, [sp, #0]
   39f2e:	2200      	movs	r2, #0
   39f30:	4629      	mov	r1, r5
   39f32:	4630      	mov	r0, r6
   39f34:	f7fd fdb0 	bl	37a98 <dwt_writetodevice>
   39f38:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   39f3c:	f899 200c 	ldrb.w	r2, [r9, #12]
   39f40:	f8d9 1008 	ldr.w	r1, [r9, #8]
   39f44:	9100      	str	r1, [sp, #0]
   39f46:	4629      	mov	r1, r5
   39f48:	4630      	mov	r0, r6
   39f4a:	f7fd fda5 	bl	37a98 <dwt_writetodevice>
   39f4e:	e04a      	b.n	39fe6 <dwt_ioctl+0xd6e>
   39f50:	f8d9 3000 	ldr.w	r3, [r9]
   39f54:	f8b9 100e 	ldrh.w	r1, [r9, #14]
   39f58:	7a9a      	ldrb	r2, [r3, #10]
   39f5a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
   39f5e:	7a5a      	ldrb	r2, [r3, #9]
   39f60:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   39f64:	7a1a      	ldrb	r2, [r3, #8]
   39f66:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
   39f6a:	79da      	ldrb	r2, [r3, #7]
   39f6c:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
   39f70:	799a      	ldrb	r2, [r3, #6]
   39f72:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
   39f76:	795a      	ldrb	r2, [r3, #5]
   39f78:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
   39f7c:	791a      	ldrb	r2, [r3, #4]
   39f7e:	f88d 2036 	strb.w	r2, [sp, #54]	; 0x36
   39f82:	78da      	ldrb	r2, [r3, #3]
   39f84:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
   39f88:	789a      	ldrb	r2, [r3, #2]
   39f8a:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
   39f8e:	785a      	ldrb	r2, [r3, #1]
   39f90:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
   39f94:	781a      	ldrb	r2, [r3, #0]
   39f96:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
   39f9a:	2200      	movs	r2, #0
   39f9c:	f88d 203b 	strb.w	r2, [sp, #59]	; 0x3b
   39fa0:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
   39fa4:	0a09      	lsrs	r1, r1, #8
   39fa6:	f88d 103d 	strb.w	r1, [sp, #61]	; 0x3d
   39faa:	7b19      	ldrb	r1, [r3, #12]
   39fac:	f88d 103e 	strb.w	r1, [sp, #62]	; 0x3e
   39fb0:	7adb      	ldrb	r3, [r3, #11]
   39fb2:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
   39fb6:	ab0c      	add	r3, sp, #48	; 0x30
   39fb8:	9300      	str	r3, [sp, #0]
   39fba:	2310      	movs	r3, #16
   39fbc:	493c      	ldr	r1, [pc, #240]	; (3a0b0 <dwt_ioctl+0xe38>)
   39fbe:	f7fd fd6b 	bl	37a98 <dwt_writetodevice>
   39fc2:	e796      	b.n	39ef2 <dwt_ioctl+0xc7a>
   39fc4:	2a01      	cmp	r2, #1
   39fc6:	f040 80cc 	bne.w	3a162 <dwt_ioctl+0xeea>
   39fca:	f899 3011 	ldrb.w	r3, [r9, #17]
   39fce:	2b00      	cmp	r3, #0
   39fd0:	f240 33ff 	movw	r3, #1023	; 0x3ff
   39fd4:	bf08      	it	eq
   39fd6:	237f      	moveq	r3, #127	; 0x7f
   39fd8:	f899 2013 	ldrb.w	r2, [r9, #19]
   39fdc:	1a9b      	subs	r3, r3, r2
   39fde:	3b02      	subs	r3, #2
   39fe0:	4299      	cmp	r1, r3
   39fe2:	f200 80c4 	bhi.w	3a16e <dwt_ioctl+0xef6>
   39fe6:	f899 2010 	ldrb.w	r2, [r9, #16]
   39fea:	1e53      	subs	r3, r2, #1
   39fec:	b2db      	uxtb	r3, r3
   39fee:	2b01      	cmp	r3, #1
   39ff0:	d940      	bls.n	3a074 <dwt_ioctl+0xdfc>
   39ff2:	f899 3011 	ldrb.w	r3, [r9, #17]
   39ff6:	1e59      	subs	r1, r3, #1
   39ff8:	b2c9      	uxtb	r1, r1
   39ffa:	2901      	cmp	r1, #1
   39ffc:	d964      	bls.n	3a0c8 <dwt_ioctl+0xe50>
   39ffe:	2b04      	cmp	r3, #4
   3a000:	d069      	beq.n	3a0d6 <dwt_ioctl+0xe5e>
   3a002:	ea42 3343 	orr.w	r3, r2, r3, lsl #13
   3a006:	2200      	movs	r2, #0
   3a008:	492a      	ldr	r1, [pc, #168]	; (3a0b4 <dwt_ioctl+0xe3c>)
   3a00a:	4630      	mov	r0, r6
   3a00c:	f7fd fea2 	bl	37d54 <dwt_write32bitoffsetreg>
   3a010:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   3a014:	4a28      	ldr	r2, [pc, #160]	; (3a0b8 <dwt_ioctl+0xe40>)
   3a016:	ea02 12c3 	and.w	r2, r2, r3, lsl #7
   3a01a:	f899 300c 	ldrb.w	r3, [r9, #12]
   3a01e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   3a022:	4313      	orrs	r3, r2
   3a024:	2200      	movs	r2, #0
   3a026:	4925      	ldr	r1, [pc, #148]	; (3a0bc <dwt_ioctl+0xe44>)
   3a028:	4630      	mov	r0, r6
   3a02a:	f7fd fe93 	bl	37d54 <dwt_write32bitoffsetreg>
   3a02e:	2301      	movs	r3, #1
   3a030:	2200      	movs	r2, #0
   3a032:	4923      	ldr	r1, [pc, #140]	; (3a0c0 <dwt_ioctl+0xe48>)
   3a034:	4630      	mov	r0, r6
   3a036:	f7fd fd3a 	bl	37aae <dwt_write8bitoffsetreg>
   3a03a:	f8df 8088 	ldr.w	r8, [pc, #136]	; 3a0c4 <dwt_ioctl+0xe4c>
   3a03e:	2700      	movs	r7, #0
   3a040:	463a      	mov	r2, r7
   3a042:	4641      	mov	r1, r8
   3a044:	4630      	mov	r0, r6
   3a046:	f7fd f96b 	bl	37320 <dwt_read8bitoffsetreg>
   3a04a:	f010 0f05 	tst.w	r0, #5
   3a04e:	d0f7      	beq.n	3a040 <dwt_ioctl+0xdc8>
   3a050:	4605      	mov	r5, r0
   3a052:	4603      	mov	r3, r0
   3a054:	2200      	movs	r2, #0
   3a056:	491b      	ldr	r1, [pc, #108]	; (3a0c4 <dwt_ioctl+0xe4c>)
   3a058:	4630      	mov	r0, r6
   3a05a:	f7fd fd28 	bl	37aae <dwt_write8bitoffsetreg>
   3a05e:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   3a062:	f025 0330 	bic.w	r3, r5, #48	; 0x30
   3a066:	2b01      	cmp	r3, #1
   3a068:	d042      	beq.n	3a0f0 <dwt_ioctl+0xe78>
   3a06a:	b26b      	sxtb	r3, r5
   3a06c:	7023      	strb	r3, [r4, #0]
   3a06e:	2500      	movs	r5, #0
   3a070:	f7ff b9ac 	b.w	393cc <dwt_ioctl+0x154>
   3a074:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3a076:	7bdb      	ldrb	r3, [r3, #15]
   3a078:	2b03      	cmp	r3, #3
   3a07a:	f001 802e 	beq.w	3b0da <dwt_ioctl+0x1e62>
   3a07e:	f899 3011 	ldrb.w	r3, [r9, #17]
   3a082:	1e5a      	subs	r2, r3, #1
   3a084:	b2d2      	uxtb	r2, r2
   3a086:	2a01      	cmp	r2, #1
   3a088:	d92c      	bls.n	3a0e4 <dwt_ioctl+0xe6c>
   3a08a:	2201      	movs	r2, #1
   3a08c:	e7b7      	b.n	39ffe <dwt_ioctl+0xd86>
   3a08e:	bf00      	nop
   3a090:	00070048 	.word	0x00070048
   3a094:	00070034 	.word	0x00070034
   3a098:	00080004 	.word	0x00080004
   3a09c:	3f866666 	.word	0x3f866666
   3a0a0:	3ecccccd 	.word	0x3ecccccd
   3a0a4:	437f0000 	.word	0x437f0000
   3a0a8:	000f0024 	.word	0x000f0024
   3a0ac:	00020008 	.word	0x00020008
   3a0b0:	00010034 	.word	0x00010034
   3a0b4:	00010044 	.word	0x00010044
   3a0b8:	0001ff80 	.word	0x0001ff80
   3a0bc:	00010048 	.word	0x00010048
   3a0c0:	0001004c 	.word	0x0001004c
   3a0c4:	00010050 	.word	0x00010050
   3a0c8:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3a0ca:	7bdb      	ldrb	r3, [r3, #15]
   3a0cc:	2b03      	cmp	r3, #3
   3a0ce:	bf0c      	ite	eq
   3a0d0:	2302      	moveq	r3, #2
   3a0d2:	2301      	movne	r3, #1
   3a0d4:	e795      	b.n	3a002 <dwt_ioctl+0xd8a>
   3a0d6:	f8b9 100e 	ldrh.w	r1, [r9, #14]
   3a0da:	2910      	cmp	r1, #16
   3a0dc:	d991      	bls.n	3a002 <dwt_ioctl+0xd8a>
   3a0de:	f06f 0303 	mvn.w	r3, #3
   3a0e2:	e7c3      	b.n	3a06c <dwt_ioctl+0xdf4>
   3a0e4:	2201      	movs	r2, #1
   3a0e6:	4613      	mov	r3, r2
   3a0e8:	e78b      	b.n	3a002 <dwt_ioctl+0xd8a>
   3a0ea:	2202      	movs	r2, #2
   3a0ec:	4613      	mov	r3, r2
   3a0ee:	e788      	b.n	3a002 <dwt_ioctl+0xd8a>
   3a0f0:	f899 3012 	ldrb.w	r3, [r9, #18]
   3a0f4:	2b01      	cmp	r3, #1
   3a0f6:	d1b8      	bne.n	3a06a <dwt_ioctl+0xdf2>
   3a0f8:	f899 2011 	ldrb.w	r2, [r9, #17]
   3a0fc:	1e53      	subs	r3, r2, #1
   3a0fe:	b2db      	uxtb	r3, r3
   3a100:	2b01      	cmp	r3, #1
   3a102:	d91b      	bls.n	3a13c <dwt_ioctl+0xec4>
   3a104:	2a03      	cmp	r2, #3
   3a106:	bf0c      	ite	eq
   3a108:	f44f 17a0 	moveq.w	r7, #1310720	; 0x140000
   3a10c:	f44f 17b0 	movne.w	r7, #1441792	; 0x160000
   3a110:	f8d9 2004 	ldr.w	r2, [r9, #4]
   3a114:	b112      	cbz	r2, 3a11c <dwt_ioctl+0xea4>
   3a116:	f899 300c 	ldrb.w	r3, [r9, #12]
   3a11a:	b9c3      	cbnz	r3, 3a14e <dwt_ioctl+0xed6>
   3a11c:	f8d9 1008 	ldr.w	r1, [r9, #8]
   3a120:	2900      	cmp	r1, #0
   3a122:	d0a2      	beq.n	3a06a <dwt_ioctl+0xdf2>
   3a124:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   3a128:	2b00      	cmp	r3, #0
   3a12a:	d09e      	beq.n	3a06a <dwt_ioctl+0xdf2>
   3a12c:	f899 200c 	ldrb.w	r2, [r9, #12]
   3a130:	9100      	str	r1, [sp, #0]
   3a132:	4639      	mov	r1, r7
   3a134:	4630      	mov	r0, r6
   3a136:	f7fd f8c1 	bl	372bc <dwt_readfromdevice>
   3a13a:	e796      	b.n	3a06a <dwt_ioctl+0xdf2>
   3a13c:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3a13e:	7bdb      	ldrb	r3, [r3, #15]
   3a140:	2b03      	cmp	r3, #3
   3a142:	bf0c      	ite	eq
   3a144:	f44f 1798 	moveq.w	r7, #1245184	; 0x130000
   3a148:	f44f 1790 	movne.w	r7, #1179648	; 0x120000
   3a14c:	e7e0      	b.n	3a110 <dwt_ioctl+0xe98>
   3a14e:	9200      	str	r2, [sp, #0]
   3a150:	2200      	movs	r2, #0
   3a152:	4639      	mov	r1, r7
   3a154:	4630      	mov	r0, r6
   3a156:	f7fd f8b1 	bl	372bc <dwt_readfromdevice>
   3a15a:	e7df      	b.n	3a11c <dwt_ioctl+0xea4>
   3a15c:	f06f 0302 	mvn.w	r3, #2
   3a160:	e784      	b.n	3a06c <dwt_ioctl+0xdf4>
   3a162:	f06f 0301 	mvn.w	r3, #1
   3a166:	e781      	b.n	3a06c <dwt_ioctl+0xdf4>
   3a168:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3a16c:	e77e      	b.n	3a06c <dwt_ioctl+0xdf4>
   3a16e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3a172:	e77b      	b.n	3a06c <dwt_ioctl+0xdf4>
   3a174:	7a23      	ldrb	r3, [r4, #8]
   3a176:	79e1      	ldrb	r1, [r4, #7]
   3a178:	79a2      	ldrb	r2, [r4, #6]
   3a17a:	00d2      	lsls	r2, r2, #3
   3a17c:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
   3a180:	4313      	orrs	r3, r2
   3a182:	7962      	ldrb	r2, [r4, #5]
   3a184:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
   3a188:	7922      	ldrb	r2, [r4, #4]
   3a18a:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   3a18e:	78e2      	ldrb	r2, [r4, #3]
   3a190:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3a194:	78a2      	ldrb	r2, [r4, #2]
   3a196:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
   3a19a:	7862      	ldrb	r2, [r4, #1]
   3a19c:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
   3a1a0:	b29b      	uxth	r3, r3
   3a1a2:	2200      	movs	r2, #0
   3a1a4:	49cd      	ldr	r1, [pc, #820]	; (3a4dc <dwt_ioctl+0x1264>)
   3a1a6:	f7fd fcd4 	bl	37b52 <dwt_write16bitoffsetreg>
   3a1aa:	2500      	movs	r5, #0
   3a1ac:	f7ff b90e 	b.w	393cc <dwt_ioctl+0x154>
   3a1b0:	2c00      	cmp	r4, #0
   3a1b2:	f000 86fc 	beq.w	3afae <dwt_ioctl+0x1d36>
   3a1b6:	7863      	ldrb	r3, [r4, #1]
   3a1b8:	b133      	cbz	r3, 3a1c8 <dwt_ioctl+0xf50>
   3a1ba:	085b      	lsrs	r3, r3, #1
   3a1bc:	3b01      	subs	r3, #1
   3a1be:	b2db      	uxtb	r3, r3
   3a1c0:	7023      	strb	r3, [r4, #0]
   3a1c2:	2500      	movs	r5, #0
   3a1c4:	f7ff b902 	b.w	393cc <dwt_ioctl+0x154>
   3a1c8:	2300      	movs	r3, #0
   3a1ca:	e7f9      	b.n	3a1c0 <dwt_ioctl+0xf48>
   3a1cc:	2200      	movs	r2, #0
   3a1ce:	49c4      	ldr	r1, [pc, #784]	; (3a4e0 <dwt_ioctl+0x1268>)
   3a1d0:	f7fd f87e 	bl	372d0 <dwt_read32bitoffsetreg>
   3a1d4:	f3c0 030b 	ubfx	r3, r0, #0, #12
   3a1d8:	8023      	strh	r3, [r4, #0]
   3a1da:	f3c0 400b 	ubfx	r0, r0, #16, #12
   3a1de:	8060      	strh	r0, [r4, #2]
   3a1e0:	2200      	movs	r2, #0
   3a1e2:	49c0      	ldr	r1, [pc, #768]	; (3a4e4 <dwt_ioctl+0x126c>)
   3a1e4:	4630      	mov	r0, r6
   3a1e6:	f7fd f873 	bl	372d0 <dwt_read32bitoffsetreg>
   3a1ea:	f3c0 030b 	ubfx	r3, r0, #0, #12
   3a1ee:	80a3      	strh	r3, [r4, #4]
   3a1f0:	f3c0 400b 	ubfx	r0, r0, #16, #12
   3a1f4:	80e0      	strh	r0, [r4, #6]
   3a1f6:	2200      	movs	r2, #0
   3a1f8:	49bb      	ldr	r1, [pc, #748]	; (3a4e8 <dwt_ioctl+0x1270>)
   3a1fa:	4630      	mov	r0, r6
   3a1fc:	f7fd f868 	bl	372d0 <dwt_read32bitoffsetreg>
   3a200:	7220      	strb	r0, [r4, #8]
   3a202:	0c00      	lsrs	r0, r0, #16
   3a204:	7260      	strb	r0, [r4, #9]
   3a206:	2200      	movs	r2, #0
   3a208:	49b8      	ldr	r1, [pc, #736]	; (3a4ec <dwt_ioctl+0x1274>)
   3a20a:	4630      	mov	r0, r6
   3a20c:	f7fd f860 	bl	372d0 <dwt_read32bitoffsetreg>
   3a210:	f3c0 430b 	ubfx	r3, r0, #16, #12
   3a214:	81a3      	strh	r3, [r4, #12]
   3a216:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3a21a:	8160      	strh	r0, [r4, #10]
   3a21c:	2200      	movs	r2, #0
   3a21e:	49b4      	ldr	r1, [pc, #720]	; (3a4f0 <dwt_ioctl+0x1278>)
   3a220:	4630      	mov	r0, r6
   3a222:	f7fd f855 	bl	372d0 <dwt_read32bitoffsetreg>
   3a226:	f3c0 430b 	ubfx	r3, r0, #16, #12
   3a22a:	f8a4 300f 	strh.w	r3, [r4, #15]
   3a22e:	73a0      	strb	r0, [r4, #14]
   3a230:	2200      	movs	r2, #0
   3a232:	49b0      	ldr	r1, [pc, #704]	; (3a4f4 <dwt_ioctl+0x127c>)
   3a234:	4630      	mov	r0, r6
   3a236:	f7fd f84b 	bl	372d0 <dwt_read32bitoffsetreg>
   3a23a:	7460      	strb	r0, [r4, #17]
   3a23c:	0c00      	lsrs	r0, r0, #16
   3a23e:	74a0      	strb	r0, [r4, #18]
   3a240:	2200      	movs	r2, #0
   3a242:	49ad      	ldr	r1, [pc, #692]	; (3a4f8 <dwt_ioctl+0x1280>)
   3a244:	4630      	mov	r0, r6
   3a246:	f7fd f843 	bl	372d0 <dwt_read32bitoffsetreg>
   3a24a:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3a24e:	f8a4 0013 	strh.w	r0, [r4, #19]
   3a252:	2500      	movs	r5, #0
   3a254:	7565      	strb	r5, [r4, #21]
   3a256:	75a5      	strb	r5, [r4, #22]
   3a258:	462a      	mov	r2, r5
   3a25a:	49a8      	ldr	r1, [pc, #672]	; (3a4fc <dwt_ioctl+0x1284>)
   3a25c:	4630      	mov	r0, r6
   3a25e:	f7fd f85f 	bl	37320 <dwt_read8bitoffsetreg>
   3a262:	75e0      	strb	r0, [r4, #23]
   3a264:	f7ff b8b2 	b.w	393cc <dwt_ioctl+0x154>
   3a268:	4611      	mov	r1, r2
   3a26a:	f7fd fc5f 	bl	37b2c <ull_configeventcounters>
   3a26e:	2500      	movs	r5, #0
   3a270:	f7ff b8ac 	b.w	393cc <dwt_ioctl+0x154>
   3a274:	2c00      	cmp	r4, #0
   3a276:	f000 869d 	beq.w	3afb4 <dwt_ioctl+0x1d3c>
   3a27a:	8823      	ldrh	r3, [r4, #0]
   3a27c:	2200      	movs	r2, #0
   3a27e:	49a0      	ldr	r1, [pc, #640]	; (3a500 <dwt_ioctl+0x1288>)
   3a280:	f7fd fc67 	bl	37b52 <dwt_write16bitoffsetreg>
   3a284:	2500      	movs	r5, #0
   3a286:	f7ff b8a1 	b.w	393cc <dwt_ioctl+0x154>
   3a28a:	2c00      	cmp	r4, #0
   3a28c:	f000 8695 	beq.w	3afba <dwt_ioctl+0x1d42>
   3a290:	6825      	ldr	r5, [r4, #0]
   3a292:	b935      	cbnz	r5, 3a2a2 <dwt_ioctl+0x102a>
   3a294:	2300      	movs	r3, #0
   3a296:	461a      	mov	r2, r3
   3a298:	499a      	ldr	r1, [pc, #616]	; (3a504 <dwt_ioctl+0x128c>)
   3a29a:	f7fd fc5a 	bl	37b52 <dwt_write16bitoffsetreg>
   3a29e:	f7ff b895 	b.w	393cc <dwt_ioctl+0x154>
   3a2a2:	7962      	ldrb	r2, [r4, #5]
   3a2a4:	7923      	ldrb	r3, [r4, #4]
   3a2a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3a2aa:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
   3a2ae:	2200      	movs	r2, #0
   3a2b0:	4994      	ldr	r1, [pc, #592]	; (3a504 <dwt_ioctl+0x128c>)
   3a2b2:	f7fd fc4e 	bl	37b52 <dwt_write16bitoffsetreg>
   3a2b6:	2500      	movs	r5, #0
   3a2b8:	f7ff b888 	b.w	393cc <dwt_ioctl+0x154>
   3a2bc:	2c00      	cmp	r4, #0
   3a2be:	f000 867f 	beq.w	3afc0 <dwt_ioctl+0x1d48>
   3a2c2:	6823      	ldr	r3, [r4, #0]
   3a2c4:	b94b      	cbnz	r3, 3a2da <dwt_ioctl+0x1062>
   3a2c6:	2500      	movs	r5, #0
   3a2c8:	9500      	str	r5, [sp, #0]
   3a2ca:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   3a2ce:	462a      	mov	r2, r5
   3a2d0:	2110      	movs	r1, #16
   3a2d2:	f7fe fc6d 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3a2d6:	f7ff b879 	b.w	393cc <dwt_ioctl+0x154>
   3a2da:	2200      	movs	r2, #0
   3a2dc:	2134      	movs	r1, #52	; 0x34
   3a2de:	f7fd fd39 	bl	37d54 <dwt_write32bitoffsetreg>
   3a2e2:	f44f 7300 	mov.w	r3, #512	; 0x200
   3a2e6:	9300      	str	r3, [sp, #0]
   3a2e8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3a2ec:	2200      	movs	r2, #0
   3a2ee:	2110      	movs	r1, #16
   3a2f0:	4630      	mov	r0, r6
   3a2f2:	f7fe fc5d 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3a2f6:	2500      	movs	r5, #0
   3a2f8:	f7ff b868 	b.w	393cc <dwt_ioctl+0x154>
   3a2fc:	2c00      	cmp	r4, #0
   3a2fe:	f000 8662 	beq.w	3afc6 <dwt_ioctl+0x1d4e>
   3a302:	8861      	ldrh	r1, [r4, #2]
   3a304:	f7fd fca2 	bl	37c4c <ull_aon_read>
   3a308:	7020      	strb	r0, [r4, #0]
   3a30a:	2500      	movs	r5, #0
   3a30c:	f7ff b85e 	b.w	393cc <dwt_ioctl+0x154>
   3a310:	2c00      	cmp	r4, #0
   3a312:	f000 865b 	beq.w	3afcc <dwt_ioctl+0x1d54>
   3a316:	78a2      	ldrb	r2, [r4, #2]
   3a318:	8821      	ldrh	r1, [r4, #0]
   3a31a:	f7fd fcb7 	bl	37c8c <ull_aon_write>
   3a31e:	2500      	movs	r5, #0
   3a320:	f7ff b854 	b.w	393cc <dwt_ioctl+0x154>
   3a324:	4b78      	ldr	r3, [pc, #480]	; (3a508 <dwt_ioctl+0x1290>)
   3a326:	4a79      	ldr	r2, [pc, #484]	; (3a50c <dwt_ioctl+0x1294>)
   3a328:	2d01      	cmp	r5, #1
   3a32a:	bf18      	it	ne
   3a32c:	4613      	movne	r3, r2
   3a32e:	2d01      	cmp	r5, #1
   3a330:	4977      	ldr	r1, [pc, #476]	; (3a510 <dwt_ioctl+0x1298>)
   3a332:	bf18      	it	ne
   3a334:	f04f 110c 	movne.w	r1, #786444	; 0xc000c
   3a338:	6d02      	ldr	r2, [r0, #80]	; 0x50
   3a33a:	7bd2      	ldrb	r2, [r2, #15]
   3a33c:	2a01      	cmp	r2, #1
   3a33e:	d012      	beq.n	3a366 <dwt_ioctl+0x10ee>
   3a340:	2a03      	cmp	r2, #3
   3a342:	d117      	bne.n	3a374 <dwt_ioctl+0x10fc>
   3a344:	f5a2 12c0 	sub.w	r2, r2, #1572864	; 0x180000
   3a348:	3a01      	subs	r2, #1
   3a34a:	441a      	add	r2, r3
   3a34c:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3a350:	f7fc ffd4 	bl	372fc <dwt_read16bitoffsetreg>
   3a354:	09c0      	lsrs	r0, r0, #7
   3a356:	8020      	strh	r0, [r4, #0]
   3a358:	8825      	ldrh	r5, [r4, #0]
   3a35a:	3500      	adds	r5, #0
   3a35c:	bf18      	it	ne
   3a35e:	2501      	movne	r5, #1
   3a360:	426d      	negs	r5, r5
   3a362:	f7ff b833 	b.w	393cc <dwt_ioctl+0x154>
   3a366:	2202      	movs	r2, #2
   3a368:	4619      	mov	r1, r3
   3a36a:	f7fc ffc7 	bl	372fc <dwt_read16bitoffsetreg>
   3a36e:	09c0      	lsrs	r0, r0, #7
   3a370:	8020      	strh	r0, [r4, #0]
   3a372:	e7f1      	b.n	3a358 <dwt_ioctl+0x10e0>
   3a374:	2202      	movs	r2, #2
   3a376:	f7fc ffc1 	bl	372fc <dwt_read16bitoffsetreg>
   3a37a:	09c0      	lsrs	r0, r0, #7
   3a37c:	8020      	strh	r0, [r4, #0]
   3a37e:	e7eb      	b.n	3a358 <dwt_ioctl+0x10e0>
   3a380:	2c00      	cmp	r4, #0
   3a382:	f000 8626 	beq.w	3afd2 <dwt_ioctl+0x1d5a>
   3a386:	7821      	ldrb	r1, [r4, #0]
   3a388:	f7fe fc48 	bl	38c1c <ull_setleds>
   3a38c:	2500      	movs	r5, #0
   3a38e:	f7ff b81d 	b.w	393cc <dwt_ioctl+0x154>
   3a392:	4611      	mov	r1, r2
   3a394:	f7fe fb18 	bl	389c8 <ull_setdwstate>
   3a398:	2500      	movs	r5, #0
   3a39a:	f7ff b817 	b.w	393cc <dwt_ioctl+0x154>
   3a39e:	9400      	str	r4, [sp, #0]
   3a3a0:	2304      	movs	r3, #4
   3a3a2:	2200      	movs	r2, #0
   3a3a4:	211c      	movs	r1, #28
   3a3a6:	f7fc ff89 	bl	372bc <dwt_readfromdevice>
   3a3aa:	2500      	movs	r5, #0
   3a3ac:	f7ff b80e 	b.w	393cc <dwt_ioctl+0x154>
   3a3b0:	2c00      	cmp	r4, #0
   3a3b2:	f000 8611 	beq.w	3afd8 <dwt_ioctl+0x1d60>
   3a3b6:	2202      	movs	r2, #2
   3a3b8:	2144      	movs	r1, #68	; 0x44
   3a3ba:	f7fc ff9f 	bl	372fc <dwt_read16bitoffsetreg>
   3a3be:	f3c0 2000 	ubfx	r0, r0, #8, #1
   3a3c2:	7020      	strb	r0, [r4, #0]
   3a3c4:	2500      	movs	r5, #0
   3a3c6:	f7ff b801 	b.w	393cc <dwt_ioctl+0x154>
   3a3ca:	2c00      	cmp	r4, #0
   3a3cc:	f000 8607 	beq.w	3afde <dwt_ioctl+0x1d66>
   3a3d0:	2200      	movs	r2, #0
   3a3d2:	2144      	movs	r1, #68	; 0x44
   3a3d4:	f7fc ffa4 	bl	37320 <dwt_read8bitoffsetreg>
   3a3d8:	f000 0001 	and.w	r0, r0, #1
   3a3dc:	7020      	strb	r0, [r4, #0]
   3a3de:	2500      	movs	r5, #0
   3a3e0:	f7fe bff4 	b.w	393cc <dwt_ioctl+0x154>
   3a3e4:	2c00      	cmp	r4, #0
   3a3e6:	f000 85fd 	beq.w	3afe4 <dwt_ioctl+0x1d6c>
   3a3ea:	8862      	ldrh	r2, [r4, #2]
   3a3ec:	8821      	ldrh	r1, [r4, #0]
   3a3ee:	f7fe fb49 	bl	38a84 <ull_configureframefilter>
   3a3f2:	2500      	movs	r5, #0
   3a3f4:	f7fe bfea 	b.w	393cc <dwt_ioctl+0x154>
   3a3f8:	9400      	str	r4, [sp, #0]
   3a3fa:	2308      	movs	r3, #8
   3a3fc:	2200      	movs	r2, #0
   3a3fe:	2104      	movs	r1, #4
   3a400:	f7fd fb4a 	bl	37a98 <dwt_writetodevice>
   3a404:	2500      	movs	r5, #0
   3a406:	f7fe bfe1 	b.w	393cc <dwt_ioctl+0x154>
   3a40a:	9400      	str	r4, [sp, #0]
   3a40c:	2308      	movs	r3, #8
   3a40e:	2200      	movs	r2, #0
   3a410:	2104      	movs	r1, #4
   3a412:	f7fc ff53 	bl	372bc <dwt_readfromdevice>
   3a416:	2500      	movs	r5, #0
   3a418:	f7fe bfd8 	b.w	393cc <dwt_ioctl+0x154>
   3a41c:	2c00      	cmp	r4, #0
   3a41e:	f000 85e4 	beq.w	3afea <dwt_ioctl+0x1d72>
   3a422:	8823      	ldrh	r3, [r4, #0]
   3a424:	2202      	movs	r2, #2
   3a426:	210c      	movs	r1, #12
   3a428:	f7fd fb93 	bl	37b52 <dwt_write16bitoffsetreg>
   3a42c:	2500      	movs	r5, #0
   3a42e:	f7fe bfcd 	b.w	393cc <dwt_ioctl+0x154>
   3a432:	2c00      	cmp	r4, #0
   3a434:	f000 85dc 	beq.w	3aff0 <dwt_ioctl+0x1d78>
   3a438:	8823      	ldrh	r3, [r4, #0]
   3a43a:	2200      	movs	r2, #0
   3a43c:	210c      	movs	r1, #12
   3a43e:	f7fd fb88 	bl	37b52 <dwt_write16bitoffsetreg>
   3a442:	2500      	movs	r5, #0
   3a444:	f7fe bfc2 	b.w	393cc <dwt_ioctl+0x154>
   3a448:	4621      	mov	r1, r4
   3a44a:	f7fd fb03 	bl	37a54 <ull_readrxtimestamp>
   3a44e:	2500      	movs	r5, #0
   3a450:	f7fe bfbc 	b.w	393cc <dwt_ioctl+0x154>
   3a454:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3a456:	7bdb      	ldrb	r3, [r3, #15]
   3a458:	2b01      	cmp	r3, #1
   3a45a:	d00b      	beq.n	3a474 <dwt_ioctl+0x11fc>
   3a45c:	2b03      	cmp	r3, #3
   3a45e:	d112      	bne.n	3a486 <dwt_ioctl+0x120e>
   3a460:	9400      	str	r4, [sp, #0]
   3a462:	2305      	movs	r3, #5
   3a464:	2220      	movs	r2, #32
   3a466:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3a46a:	f7fc ff27 	bl	372bc <dwt_readfromdevice>
   3a46e:	2500      	movs	r5, #0
   3a470:	f7fe bfac 	b.w	393cc <dwt_ioctl+0x154>
   3a474:	9400      	str	r4, [sp, #0]
   3a476:	2305      	movs	r3, #5
   3a478:	2200      	movs	r2, #0
   3a47a:	4926      	ldr	r1, [pc, #152]	; (3a514 <dwt_ioctl+0x129c>)
   3a47c:	f7fc ff1e 	bl	372bc <dwt_readfromdevice>
   3a480:	2500      	movs	r5, #0
   3a482:	f7fe bfa3 	b.w	393cc <dwt_ioctl+0x154>
   3a486:	9400      	str	r4, [sp, #0]
   3a488:	2305      	movs	r3, #5
   3a48a:	2200      	movs	r2, #0
   3a48c:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   3a490:	f7fc ff14 	bl	372bc <dwt_readfromdevice>
   3a494:	2500      	movs	r5, #0
   3a496:	f7fe bf99 	b.w	393cc <dwt_ioctl+0x154>
   3a49a:	2500      	movs	r5, #0
   3a49c:	f804 5b01 	strb.w	r5, [r4], #1
   3a4a0:	9400      	str	r4, [sp, #0]
   3a4a2:	2304      	movs	r3, #4
   3a4a4:	462a      	mov	r2, r5
   3a4a6:	2170      	movs	r1, #112	; 0x70
   3a4a8:	f7fc ff08 	bl	372bc <dwt_readfromdevice>
   3a4ac:	f7fe bf8e 	b.w	393cc <dwt_ioctl+0x154>
   3a4b0:	2c00      	cmp	r4, #0
   3a4b2:	f000 85a0 	beq.w	3aff6 <dwt_ioctl+0x1d7e>
   3a4b6:	2201      	movs	r2, #1
   3a4b8:	2164      	movs	r1, #100	; 0x64
   3a4ba:	f7fc ff09 	bl	372d0 <dwt_read32bitoffsetreg>
   3a4be:	6020      	str	r0, [r4, #0]
   3a4c0:	2500      	movs	r5, #0
   3a4c2:	f7fe bf83 	b.w	393cc <dwt_ioctl+0x154>
   3a4c6:	2c00      	cmp	r4, #0
   3a4c8:	f000 8598 	beq.w	3affc <dwt_ioctl+0x1d84>
   3a4cc:	2200      	movs	r2, #0
   3a4ce:	2164      	movs	r1, #100	; 0x64
   3a4d0:	f7fc fefe 	bl	372d0 <dwt_read32bitoffsetreg>
   3a4d4:	6020      	str	r0, [r4, #0]
   3a4d6:	2500      	movs	r5, #0
   3a4d8:	f7fe bf78 	b.w	393cc <dwt_ioctl+0x154>
   3a4dc:	00010030 	.word	0x00010030
   3a4e0:	000f0004 	.word	0x000f0004
   3a4e4:	000f0008 	.word	0x000f0008
   3a4e8:	000f000c 	.word	0x000f000c
   3a4ec:	000f0010 	.word	0x000f0010
   3a4f0:	000f0014 	.word	0x000f0014
   3a4f4:	000f0018 	.word	0x000f0018
   3a4f8:	000f001c 	.word	0x000f001c
   3a4fc:	000f0028 	.word	0x000f0028
   3a500:	00060004 	.word	0x00060004
   3a504:	0011001a 	.word	0x0011001a
   3a508:	00180034 	.word	0x00180034
   3a50c:	0018002c 	.word	0x0018002c
   3a510:	000c0014 	.word	0x000c0014
   3a514:	00180020 	.word	0x00180020
   3a518:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3a51a:	7bdb      	ldrb	r3, [r3, #15]
   3a51c:	2b01      	cmp	r3, #1
   3a51e:	d00b      	beq.n	3a538 <dwt_ioctl+0x12c0>
   3a520:	2b03      	cmp	r3, #3
   3a522:	d112      	bne.n	3a54a <dwt_ioctl+0x12d2>
   3a524:	9400      	str	r4, [sp, #0]
   3a526:	2305      	movs	r3, #5
   3a528:	2228      	movs	r2, #40	; 0x28
   3a52a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3a52e:	f7fc fec5 	bl	372bc <dwt_readfromdevice>
   3a532:	2500      	movs	r5, #0
   3a534:	f7fe bf4a 	b.w	393cc <dwt_ioctl+0x154>
   3a538:	9400      	str	r4, [sp, #0]
   3a53a:	2305      	movs	r3, #5
   3a53c:	2200      	movs	r2, #0
   3a53e:	49d3      	ldr	r1, [pc, #844]	; (3a88c <dwt_ioctl+0x1614>)
   3a540:	f7fc febc 	bl	372bc <dwt_readfromdevice>
   3a544:	2500      	movs	r5, #0
   3a546:	f7fe bf41 	b.w	393cc <dwt_ioctl+0x154>
   3a54a:	9400      	str	r4, [sp, #0]
   3a54c:	2305      	movs	r3, #5
   3a54e:	2200      	movs	r2, #0
   3a550:	49cf      	ldr	r1, [pc, #828]	; (3a890 <dwt_ioctl+0x1618>)
   3a552:	f7fc feb3 	bl	372bc <dwt_readfromdevice>
   3a556:	2500      	movs	r5, #0
   3a558:	f7fe bf38 	b.w	393cc <dwt_ioctl+0x154>
   3a55c:	2c00      	cmp	r4, #0
   3a55e:	f000 8550 	beq.w	3b002 <dwt_ioctl+0x1d8a>
   3a562:	2200      	movs	r2, #0
   3a564:	211c      	movs	r1, #28
   3a566:	f7fc feb3 	bl	372d0 <dwt_read32bitoffsetreg>
   3a56a:	6020      	str	r0, [r4, #0]
   3a56c:	2500      	movs	r5, #0
   3a56e:	f7fe bf2d 	b.w	393cc <dwt_ioctl+0x154>
   3a572:	2c00      	cmp	r4, #0
   3a574:	f000 8548 	beq.w	3b008 <dwt_ioctl+0x1d90>
   3a578:	8825      	ldrh	r5, [r4, #0]
   3a57a:	6867      	ldr	r7, [r4, #4]
   3a57c:	7a23      	ldrb	r3, [r4, #8]
   3a57e:	2b00      	cmp	r3, #0
   3a580:	f000 8545 	beq.w	3b00e <dwt_ioctl+0x1d96>
   3a584:	463c      	mov	r4, r7
   3a586:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   3a58a:	4629      	mov	r1, r5
   3a58c:	4630      	mov	r0, r6
   3a58e:	f7fd fb3b 	bl	37c08 <_dwt_otpread>
   3a592:	f844 0b04 	str.w	r0, [r4], #4
   3a596:	3501      	adds	r5, #1
   3a598:	b2ad      	uxth	r5, r5
   3a59a:	42bc      	cmp	r4, r7
   3a59c:	d1f5      	bne.n	3a58a <dwt_ioctl+0x1312>
   3a59e:	2500      	movs	r5, #0
   3a5a0:	f7fe bf14 	b.w	393cc <dwt_ioctl+0x154>
   3a5a4:	2c00      	cmp	r4, #0
   3a5a6:	f000 8535 	beq.w	3b014 <dwt_ioctl+0x1d9c>
   3a5aa:	7823      	ldrb	r3, [r4, #0]
   3a5ac:	2201      	movs	r2, #1
   3a5ae:	2128      	movs	r1, #40	; 0x28
   3a5b0:	f7fd fa7d 	bl	37aae <dwt_write8bitoffsetreg>
   3a5b4:	2500      	movs	r5, #0
   3a5b6:	f7fe bf09 	b.w	393cc <dwt_ioctl+0x154>
   3a5ba:	f7fe fa87 	bl	38acc <ull_run_pgfcal>
   3a5be:	4605      	mov	r5, r0
   3a5c0:	f7fe bf04 	b.w	393cc <dwt_ioctl+0x154>
   3a5c4:	4611      	mov	r1, r2
   3a5c6:	f7fe fb77 	bl	38cb8 <ull_pgf_cal>
   3a5ca:	4605      	mov	r5, r0
   3a5cc:	f7fe befe 	b.w	393cc <dwt_ioctl+0x154>
   3a5d0:	2c00      	cmp	r4, #0
   3a5d2:	f000 8522 	beq.w	3b01a <dwt_ioctl+0x1da2>
   3a5d6:	78a5      	ldrb	r5, [r4, #2]
   3a5d8:	2101      	movs	r1, #1
   3a5da:	f7fd faeb 	bl	37bb4 <ull_force_clocks>
   3a5de:	2100      	movs	r1, #0
   3a5e0:	4630      	mov	r0, r6
   3a5e2:	f7fd ff8b 	bl	384fc <ull_enable_rf_tx>
   3a5e6:	4630      	mov	r0, r6
   3a5e8:	f7fd ffbc 	bl	38564 <ull_enable_rftx_blocks>
   3a5ec:	f005 033f 	and.w	r3, r5, #63	; 0x3f
   3a5f0:	2200      	movs	r2, #0
   3a5f2:	49a8      	ldr	r1, [pc, #672]	; (3a894 <dwt_ioctl+0x161c>)
   3a5f4:	4630      	mov	r0, r6
   3a5f6:	f7fd fa5a 	bl	37aae <dwt_write8bitoffsetreg>
   3a5fa:	2301      	movs	r3, #1
   3a5fc:	9300      	str	r3, [sp, #0]
   3a5fe:	23ff      	movs	r3, #255	; 0xff
   3a600:	2200      	movs	r2, #0
   3a602:	49a5      	ldr	r1, [pc, #660]	; (3a898 <dwt_ioctl+0x1620>)
   3a604:	4630      	mov	r0, r6
   3a606:	f7fe f921 	bl	3884c <dwt_modify8bitoffsetreg>
   3a60a:	4fa3      	ldr	r7, [pc, #652]	; (3a898 <dwt_ioctl+0x1620>)
   3a60c:	2500      	movs	r5, #0
   3a60e:	462a      	mov	r2, r5
   3a610:	4639      	mov	r1, r7
   3a612:	4630      	mov	r0, r6
   3a614:	f7fc fe84 	bl	37320 <dwt_read8bitoffsetreg>
   3a618:	f010 0f01 	tst.w	r0, #1
   3a61c:	d1f7      	bne.n	3a60e <dwt_ioctl+0x1396>
   3a61e:	2200      	movs	r2, #0
   3a620:	499e      	ldr	r1, [pc, #632]	; (3a89c <dwt_ioctl+0x1624>)
   3a622:	4630      	mov	r0, r6
   3a624:	f7fc fe6a 	bl	372fc <dwt_read16bitoffsetreg>
   3a628:	4605      	mov	r5, r0
   3a62a:	4630      	mov	r0, r6
   3a62c:	f7fd fe30 	bl	38290 <ull_disable_rftx_blocks>
   3a630:	2100      	movs	r1, #0
   3a632:	4630      	mov	r0, r6
   3a634:	f7fd fe36 	bl	382a4 <ull_disable_rf_tx>
   3a638:	2105      	movs	r1, #5
   3a63a:	4630      	mov	r0, r6
   3a63c:	f7fd faba 	bl	37bb4 <ull_force_clocks>
   3a640:	f3c5 050b 	ubfx	r5, r5, #0, #12
   3a644:	8025      	strh	r5, [r4, #0]
   3a646:	2500      	movs	r5, #0
   3a648:	f7fe bec0 	b.w	393cc <dwt_ioctl+0x154>
   3a64c:	2102      	movs	r1, #2
   3a64e:	f7fe f9bb 	bl	389c8 <ull_setdwstate>
   3a652:	2101      	movs	r1, #1
   3a654:	4630      	mov	r0, r6
   3a656:	f7fe f9b7 	bl	389c8 <ull_setdwstate>
   3a65a:	2432      	movs	r4, #50	; 0x32
   3a65c:	f04f 0814 	mov.w	r8, #20
   3a660:	2700      	movs	r7, #0
   3a662:	2544      	movs	r5, #68	; 0x44
   3a664:	4640      	mov	r0, r8
   3a666:	f7f4 f8c2 	bl	2e7ee <deca_usleep>
   3a66a:	463a      	mov	r2, r7
   3a66c:	4629      	mov	r1, r5
   3a66e:	4630      	mov	r0, r6
   3a670:	f7fc fe56 	bl	37320 <dwt_read8bitoffsetreg>
   3a674:	f010 0f02 	tst.w	r0, #2
   3a678:	d105      	bne.n	3a686 <dwt_ioctl+0x140e>
   3a67a:	1e63      	subs	r3, r4, #1
   3a67c:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   3a680:	d1f0      	bne.n	3a664 <dwt_ioctl+0x13ec>
   3a682:	2501      	movs	r5, #1
   3a684:	e000      	b.n	3a688 <dwt_ioctl+0x1410>
   3a686:	2500      	movs	r5, #0
   3a688:	426d      	negs	r5, r5
   3a68a:	f7fe be9f 	b.w	393cc <dwt_ioctl+0x154>
   3a68e:	2c00      	cmp	r4, #0
   3a690:	f000 84c6 	beq.w	3b020 <dwt_ioctl+0x1da8>
   3a694:	7823      	ldrb	r3, [r4, #0]
   3a696:	031b      	lsls	r3, r3, #12
   3a698:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
   3a69c:	7862      	ldrb	r2, [r4, #1]
   3a69e:	2a01      	cmp	r2, #1
   3a6a0:	bf08      	it	eq
   3a6a2:	f443 7380 	orreq.w	r3, r3, #256	; 0x100
   3a6a6:	9300      	str	r3, [sp, #0]
   3a6a8:	f46f 43e2 	mvn.w	r3, #28928	; 0x7100
   3a6ac:	2200      	movs	r2, #0
   3a6ae:	497c      	ldr	r1, [pc, #496]	; (3a8a0 <dwt_ioctl+0x1628>)
   3a6b0:	f7fd fee2 	bl	38478 <dwt_modify32bitoffsetreg>
   3a6b4:	2500      	movs	r5, #0
   3a6b6:	f7fe be89 	b.w	393cc <dwt_ioctl+0x154>
   3a6ba:	2c00      	cmp	r4, #0
   3a6bc:	f000 84b3 	beq.w	3b026 <dwt_ioctl+0x1dae>
   3a6c0:	6862      	ldr	r2, [r4, #4]
   3a6c2:	6821      	ldr	r1, [r4, #0]
   3a6c4:	f7fe f818 	bl	386f8 <ull_setgpiomode>
   3a6c8:	2500      	movs	r5, #0
   3a6ca:	f7fe be7f 	b.w	393cc <dwt_ioctl+0x154>
   3a6ce:	2c00      	cmp	r4, #0
   3a6d0:	f000 84ac 	beq.w	3b02c <dwt_ioctl+0x1db4>
   3a6d4:	8823      	ldrh	r3, [r4, #0]
   3a6d6:	2200      	movs	r2, #0
   3a6d8:	4972      	ldr	r1, [pc, #456]	; (3a8a4 <dwt_ioctl+0x162c>)
   3a6da:	f7fd fa3a 	bl	37b52 <dwt_write16bitoffsetreg>
   3a6de:	2500      	movs	r5, #0
   3a6e0:	f7fe be74 	b.w	393cc <dwt_ioctl+0x154>
   3a6e4:	2c00      	cmp	r4, #0
   3a6e6:	f000 84a4 	beq.w	3b032 <dwt_ioctl+0x1dba>
   3a6ea:	6862      	ldr	r2, [r4, #4]
   3a6ec:	8821      	ldrh	r1, [r4, #0]
   3a6ee:	f7fe fb13 	bl	38d18 <ull_setgpiovalue>
   3a6f2:	2500      	movs	r5, #0
   3a6f4:	f7fe be6a 	b.w	393cc <dwt_ioctl+0x154>
   3a6f8:	2c00      	cmp	r4, #0
   3a6fa:	f000 849d 	beq.w	3b038 <dwt_ioctl+0x1dc0>
   3a6fe:	7865      	ldrb	r5, [r4, #1]
   3a700:	7823      	ldrb	r3, [r4, #0]
   3a702:	b18b      	cbz	r3, 3a728 <dwt_ioctl+0x14b0>
   3a704:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3a706:	2200      	movs	r2, #0
   3a708:	73da      	strb	r2, [r3, #15]
   3a70a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3a70e:	2208      	movs	r2, #8
   3a710:	b1e5      	cbz	r5, 3a74c <dwt_ioctl+0x14d4>
   3a712:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   3a716:	9200      	str	r2, [sp, #0]
   3a718:	2200      	movs	r2, #0
   3a71a:	2110      	movs	r1, #16
   3a71c:	4630      	mov	r0, r6
   3a71e:	f7fd feab 	bl	38478 <dwt_modify32bitoffsetreg>
   3a722:	2500      	movs	r5, #0
   3a724:	f7fe be52 	b.w	393cc <dwt_ioctl+0x154>
   3a728:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3a72a:	2201      	movs	r2, #1
   3a72c:	73da      	strb	r2, [r3, #15]
   3a72e:	2318      	movs	r3, #24
   3a730:	2200      	movs	r2, #0
   3a732:	495d      	ldr	r1, [pc, #372]	; (3a8a8 <dwt_ioctl+0x1630>)
   3a734:	f7fd fb0e 	bl	37d54 <dwt_write32bitoffsetreg>
   3a738:	23e8      	movs	r3, #232	; 0xe8
   3a73a:	2200      	movs	r2, #0
   3a73c:	495b      	ldr	r1, [pc, #364]	; (3a8ac <dwt_ioctl+0x1634>)
   3a73e:	4630      	mov	r0, r6
   3a740:	f7fd fb08 	bl	37d54 <dwt_write32bitoffsetreg>
   3a744:	f06f 0308 	mvn.w	r3, #8
   3a748:	2200      	movs	r2, #0
   3a74a:	e7e1      	b.n	3a710 <dwt_ioctl+0x1498>
   3a74c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   3a750:	e7e1      	b.n	3a716 <dwt_ioctl+0x149e>
   3a752:	2c00      	cmp	r4, #0
   3a754:	f000 8473 	beq.w	3b03e <dwt_ioctl+0x1dc6>
   3a758:	6823      	ldr	r3, [r4, #0]
   3a75a:	2200      	movs	r2, #0
   3a75c:	2130      	movs	r1, #48	; 0x30
   3a75e:	f7fd faf9 	bl	37d54 <dwt_write32bitoffsetreg>
   3a762:	2500      	movs	r5, #0
   3a764:	f7fe be32 	b.w	393cc <dwt_ioctl+0x154>
   3a768:	2c00      	cmp	r4, #0
   3a76a:	f000 846b 	beq.w	3b044 <dwt_ioctl+0x1dcc>
   3a76e:	2200      	movs	r2, #0
   3a770:	4629      	mov	r1, r5
   3a772:	f7fc fdad 	bl	372d0 <dwt_read32bitoffsetreg>
   3a776:	6020      	str	r0, [r4, #0]
   3a778:	2500      	movs	r5, #0
   3a77a:	f7fe be27 	b.w	393cc <dwt_ioctl+0x154>
   3a77e:	4623      	mov	r3, r4
   3a780:	2200      	movs	r2, #0
   3a782:	4629      	mov	r1, r5
   3a784:	f7fd fae6 	bl	37d54 <dwt_write32bitoffsetreg>
   3a788:	2500      	movs	r5, #0
   3a78a:	f7fe be1f 	b.w	393cc <dwt_ioctl+0x154>
   3a78e:	2c00      	cmp	r4, #0
   3a790:	f000 845b 	beq.w	3b04a <dwt_ioctl+0x1dd2>
   3a794:	2203      	movs	r2, #3
   3a796:	4946      	ldr	r1, [pc, #280]	; (3a8b0 <dwt_ioctl+0x1638>)
   3a798:	f7fc fdc2 	bl	37320 <dwt_read8bitoffsetreg>
   3a79c:	f3c0 1002 	ubfx	r0, r0, #4, #3
   3a7a0:	7020      	strb	r0, [r4, #0]
   3a7a2:	2500      	movs	r5, #0
   3a7a4:	f7fe be12 	b.w	393cc <dwt_ioctl+0x154>
   3a7a8:	2c00      	cmp	r4, #0
   3a7aa:	f000 8451 	beq.w	3b050 <dwt_ioctl+0x1dd8>
   3a7ae:	6823      	ldr	r3, [r4, #0]
   3a7b0:	2200      	movs	r2, #0
   3a7b2:	2144      	movs	r1, #68	; 0x44
   3a7b4:	f7fd face 	bl	37d54 <dwt_write32bitoffsetreg>
   3a7b8:	2500      	movs	r5, #0
   3a7ba:	f7fe be07 	b.w	393cc <dwt_ioctl+0x154>
   3a7be:	2c00      	cmp	r4, #0
   3a7c0:	f000 8449 	beq.w	3b056 <dwt_ioctl+0x1dde>
   3a7c4:	8823      	ldrh	r3, [r4, #0]
   3a7c6:	2200      	movs	r2, #0
   3a7c8:	2148      	movs	r1, #72	; 0x48
   3a7ca:	f7fd f9c2 	bl	37b52 <dwt_write16bitoffsetreg>
   3a7ce:	2500      	movs	r5, #0
   3a7d0:	f7fe bdfc 	b.w	393cc <dwt_ioctl+0x154>
   3a7d4:	2c00      	cmp	r4, #0
   3a7d6:	f000 8441 	beq.w	3b05c <dwt_ioctl+0x1de4>
   3a7da:	2200      	movs	r2, #0
   3a7dc:	2144      	movs	r1, #68	; 0x44
   3a7de:	f7fc fd77 	bl	372d0 <dwt_read32bitoffsetreg>
   3a7e2:	6020      	str	r0, [r4, #0]
   3a7e4:	2500      	movs	r5, #0
   3a7e6:	f7fe bdf1 	b.w	393cc <dwt_ioctl+0x154>
   3a7ea:	2c00      	cmp	r4, #0
   3a7ec:	f000 8439 	beq.w	3b062 <dwt_ioctl+0x1dea>
   3a7f0:	2200      	movs	r2, #0
   3a7f2:	2148      	movs	r1, #72	; 0x48
   3a7f4:	f7fc fd82 	bl	372fc <dwt_read16bitoffsetreg>
   3a7f8:	6020      	str	r0, [r4, #0]
   3a7fa:	2500      	movs	r5, #0
   3a7fc:	f7fe bde6 	b.w	393cc <dwt_ioctl+0x154>
   3a800:	2c00      	cmp	r4, #0
   3a802:	f000 8431 	beq.w	3b068 <dwt_ioctl+0x1df0>
   3a806:	7823      	ldrb	r3, [r4, #0]
   3a808:	2200      	movs	r2, #0
   3a80a:	492a      	ldr	r1, [pc, #168]	; (3a8b4 <dwt_ioctl+0x163c>)
   3a80c:	f7fd f94f 	bl	37aae <dwt_write8bitoffsetreg>
   3a810:	2500      	movs	r5, #0
   3a812:	f7fe bddb 	b.w	393cc <dwt_ioctl+0x154>
   3a816:	2c00      	cmp	r4, #0
   3a818:	f000 8429 	beq.w	3b06e <dwt_ioctl+0x1df6>
   3a81c:	2200      	movs	r2, #0
   3a81e:	2144      	movs	r1, #68	; 0x44
   3a820:	f7fc fd7e 	bl	37320 <dwt_read8bitoffsetreg>
   3a824:	7020      	strb	r0, [r4, #0]
   3a826:	2500      	movs	r5, #0
   3a828:	f7fe bdd0 	b.w	393cc <dwt_ioctl+0x154>
   3a82c:	2c00      	cmp	r4, #0
   3a82e:	f000 8421 	beq.w	3b074 <dwt_ioctl+0x1dfc>
   3a832:	f7fd f949 	bl	37ac8 <ull_getframelength>
   3a836:	6020      	str	r0, [r4, #0]
   3a838:	2500      	movs	r5, #0
   3a83a:	f7fe bdc7 	b.w	393cc <dwt_ioctl+0x154>
   3a83e:	2c00      	cmp	r4, #0
   3a840:	f000 841b 	beq.w	3b07a <dwt_ioctl+0x1e02>
   3a844:	2200      	movs	r2, #0
   3a846:	491c      	ldr	r1, [pc, #112]	; (3a8b8 <dwt_ioctl+0x1640>)
   3a848:	f7fc fd58 	bl	372fc <dwt_read16bitoffsetreg>
   3a84c:	8020      	strh	r0, [r4, #0]
   3a84e:	2500      	movs	r5, #0
   3a850:	f7fe bdbc 	b.w	393cc <dwt_ioctl+0x154>
   3a854:	2c00      	cmp	r4, #0
   3a856:	f000 8413 	beq.w	3b080 <dwt_ioctl+0x1e08>
   3a85a:	2200      	movs	r2, #0
   3a85c:	4917      	ldr	r1, [pc, #92]	; (3a8bc <dwt_ioctl+0x1644>)
   3a85e:	f7fc fd37 	bl	372d0 <dwt_read32bitoffsetreg>
   3a862:	6020      	str	r0, [r4, #0]
   3a864:	2500      	movs	r5, #0
   3a866:	f7fe bdb1 	b.w	393cc <dwt_ioctl+0x154>
   3a86a:	2c00      	cmp	r4, #0
   3a86c:	f000 840b 	beq.w	3b086 <dwt_ioctl+0x1e0e>
   3a870:	8823      	ldrh	r3, [r4, #0]
   3a872:	f3c3 030d 	ubfx	r3, r3, #0, #14
   3a876:	9300      	str	r3, [sp, #0]
   3a878:	f44f 4340 	mov.w	r3, #49152	; 0xc000
   3a87c:	2200      	movs	r2, #0
   3a87e:	490f      	ldr	r1, [pc, #60]	; (3a8bc <dwt_ioctl+0x1644>)
   3a880:	f7fe f996 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3a884:	2500      	movs	r5, #0
   3a886:	f7fe bda1 	b.w	393cc <dwt_ioctl+0x154>
   3a88a:	bf00      	nop
   3a88c:	00180028 	.word	0x00180028
   3a890:	000c0008 	.word	0x000c0008
   3a894:	0007001c 	.word	0x0007001c
   3a898:	00080010 	.word	0x00080010
   3a89c:	00080014 	.word	0x00080014
   3a8a0:	00070014 	.word	0x00070014
   3a8a4:	00050008 	.word	0x00050008
   3a8a8:	001f000c 	.word	0x001f000c
   3a8ac:	001f0010 	.word	0x001f0010
   3a8b0:	00030060 	.word	0x00030060
   3a8b4:	00010024 	.word	0x00010024
   3a8b8:	0005002c 	.word	0x0005002c
   3a8bc:	000e001a 	.word	0x000e001a
   3a8c0:	2c00      	cmp	r4, #0
   3a8c2:	f000 83e3 	beq.w	3b08c <dwt_ioctl+0x1e14>
   3a8c6:	88a7      	ldrh	r7, [r4, #4]
   3a8c8:	68a3      	ldr	r3, [r4, #8]
   3a8ca:	9309      	str	r3, [sp, #36]	; 0x24
   3a8cc:	7b21      	ldrb	r1, [r4, #12]
   3a8ce:	9106      	str	r1, [sp, #24]
   3a8d0:	6922      	ldr	r2, [r4, #16]
   3a8d2:	9204      	str	r2, [sp, #16]
   3a8d4:	6962      	ldr	r2, [r4, #20]
   3a8d6:	9205      	str	r2, [sp, #20]
   3a8d8:	f003 0203 	and.w	r2, r3, #3
   3a8dc:	f3c3 0085 	ubfx	r0, r3, #2, #6
   3a8e0:	2905      	cmp	r1, #5
   3a8e2:	d142      	bne.n	3a96a <dwt_ioctl+0x16f2>
   3a8e4:	f5b7 7fb1 	cmp.w	r7, #354	; 0x162
   3a8e8:	bf28      	it	cs
   3a8ea:	f44f 77b1 	movcs.w	r7, #354	; 0x162
   3a8ee:	f8df 92e0 	ldr.w	r9, [pc, #736]	; 3abd0 <dwt_ioctl+0x1958>
   3a8f2:	2f04      	cmp	r7, #4
   3a8f4:	d805      	bhi.n	3a902 <dwt_ioctl+0x168a>
   3a8f6:	eb09 0300 	add.w	r3, r9, r0
   3a8fa:	785b      	ldrb	r3, [r3, #1]
   3a8fc:	3b05      	subs	r3, #5
   3a8fe:	429f      	cmp	r7, r3
   3a900:	db3b      	blt.n	3a97a <dwt_ioctl+0x1702>
   3a902:	2a01      	cmp	r2, #1
   3a904:	d877      	bhi.n	3a9f6 <dwt_ioctl+0x177e>
   3a906:	4bae      	ldr	r3, [pc, #696]	; (3abc0 <dwt_ioctl+0x1948>)
   3a908:	5c99      	ldrb	r1, [r3, r2]
   3a90a:	463e      	mov	r6, r7
   3a90c:	42b9      	cmp	r1, r7
   3a90e:	da74      	bge.n	3a9fa <dwt_ioctl+0x1782>
   3a910:	1c55      	adds	r5, r2, #1
   3a912:	fa53 f585 	uxtab	r5, r3, r5
   3a916:	2300      	movs	r3, #0
   3a918:	440b      	add	r3, r1
   3a91a:	b29b      	uxth	r3, r3
   3a91c:	3201      	adds	r2, #1
   3a91e:	b2d2      	uxtb	r2, r2
   3a920:	2a02      	cmp	r2, #2
   3a922:	d005      	beq.n	3a930 <dwt_ioctl+0x16b8>
   3a924:	f815 1b01 	ldrb.w	r1, [r5], #1
   3a928:	eba6 0c03 	sub.w	ip, r6, r3
   3a92c:	4561      	cmp	r1, ip
   3a92e:	dbf3      	blt.n	3a918 <dwt_ioctl+0x16a0>
   3a930:	429f      	cmp	r7, r3
   3a932:	bf08      	it	eq
   3a934:	9003      	streq	r0, [sp, #12]
   3a936:	d064      	beq.n	3aa02 <dwt_ioctl+0x178a>
   3a938:	f107 0805 	add.w	r8, r7, #5
   3a93c:	fa1f f888 	uxth.w	r8, r8
   3a940:	2580      	movs	r5, #128	; 0x80
   3a942:	2100      	movs	r1, #0
   3a944:	9107      	str	r1, [sp, #28]
   3a946:	9103      	str	r1, [sp, #12]
   3a948:	9108      	str	r1, [sp, #32]
   3a94a:	460e      	mov	r6, r1
   3a94c:	f04f 0b05 	mov.w	fp, #5
   3a950:	46be      	mov	lr, r7
   3a952:	455f      	cmp	r7, fp
   3a954:	bf38      	it	cc
   3a956:	46de      	movcc	lr, fp
   3a958:	f1ae 0e05 	sub.w	lr, lr, #5
   3a95c:	fa1f fe8e 	uxth.w	lr, lr
   3a960:	f8df a25c 	ldr.w	sl, [pc, #604]	; 3abc0 <dwt_ioctl+0x1948>
   3a964:	46bc      	mov	ip, r7
   3a966:	460f      	mov	r7, r1
   3a968:	e3dd      	b.n	3b126 <dwt_ioctl+0x1eae>
   3a96a:	f240 1331 	movw	r3, #305	; 0x131
   3a96e:	429f      	cmp	r7, r3
   3a970:	bf28      	it	cs
   3a972:	461f      	movcs	r7, r3
   3a974:	f8df 925c 	ldr.w	r9, [pc, #604]	; 3abd4 <dwt_ioctl+0x195c>
   3a978:	e7bb      	b.n	3a8f2 <dwt_ioctl+0x167a>
   3a97a:	2300      	movs	r3, #0
   3a97c:	9a05      	ldr	r2, [sp, #20]
   3a97e:	8013      	strh	r3, [r2, #0]
   3a980:	9a04      	ldr	r2, [sp, #16]
   3a982:	4611      	mov	r1, r2
   3a984:	9a09      	ldr	r2, [sp, #36]	; 0x24
   3a986:	600a      	str	r2, [r1, #0]
   3a988:	e04a      	b.n	3aa20 <dwt_ioctl+0x17a8>
   3a98a:	2300      	movs	r3, #0
   3a98c:	9a05      	ldr	r2, [sp, #20]
   3a98e:	8013      	strh	r3, [r2, #0]
   3a990:	9b04      	ldr	r3, [sp, #16]
   3a992:	461a      	mov	r2, r3
   3a994:	9b09      	ldr	r3, [sp, #36]	; 0x24
   3a996:	6013      	str	r3, [r2, #0]
   3a998:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3a99c:	e040      	b.n	3aa20 <dwt_ioctl+0x17a8>
   3a99e:	fa1f fb81 	uxth.w	fp, r1
   3a9a2:	9207      	str	r2, [sp, #28]
   3a9a4:	9003      	str	r0, [sp, #12]
   3a9a6:	9308      	str	r3, [sp, #32]
   3a9a8:	2701      	movs	r7, #1
   3a9aa:	e3cd      	b.n	3b148 <dwt_ioctl+0x1ed0>
   3a9ac:	2f00      	cmp	r7, #0
   3a9ae:	f040 83a1 	bne.w	3b0f4 <dwt_ioctl+0x1e7c>
   3a9b2:	4598      	cmp	r8, r3
   3a9b4:	f200 83a3 	bhi.w	3b0fe <dwt_ioctl+0x1e86>
   3a9b8:	2e00      	cmp	r6, #0
   3a9ba:	d038      	beq.n	3aa2e <dwt_ioctl+0x17b6>
   3a9bc:	283f      	cmp	r0, #63	; 0x3f
   3a9be:	f000 83c8 	beq.w	3b152 <dwt_ioctl+0x1eda>
   3a9c2:	2700      	movs	r7, #0
   3a9c4:	f819 1000 	ldrb.w	r1, [r9, r0]
   3a9c8:	1a5b      	subs	r3, r3, r1
   3a9ca:	b29b      	uxth	r3, r3
   3a9cc:	1e46      	subs	r6, r0, #1
   3a9ce:	f006 003f 	and.w	r0, r6, #63	; 0x3f
   3a9d2:	f016 063f 	ands.w	r6, r6, #63	; 0x3f
   3a9d6:	bf18      	it	ne
   3a9d8:	2601      	movne	r6, #1
   3a9da:	e39c      	b.n	3b116 <dwt_ioctl+0x1e9e>
   3a9dc:	9906      	ldr	r1, [sp, #24]
   3a9de:	2909      	cmp	r1, #9
   3a9e0:	f040 83bd 	bne.w	3b15e <dwt_ioctl+0x1ee6>
   3a9e4:	213f      	movs	r1, #63	; 0x3f
   3a9e6:	9103      	str	r1, [sp, #12]
   3a9e8:	e00b      	b.n	3aa02 <dwt_ioctl+0x178a>
   3a9ea:	b2b3      	uxth	r3, r6
   3a9ec:	3201      	adds	r2, #1
   3a9ee:	b2d2      	uxtb	r2, r2
   3a9f0:	213f      	movs	r1, #63	; 0x3f
   3a9f2:	9103      	str	r1, [sp, #12]
   3a9f4:	e005      	b.n	3aa02 <dwt_ioctl+0x178a>
   3a9f6:	2300      	movs	r3, #0
   3a9f8:	e79a      	b.n	3a930 <dwt_ioctl+0x16b8>
   3a9fa:	2300      	movs	r3, #0
   3a9fc:	e798      	b.n	3a930 <dwt_ioctl+0x16b8>
   3a9fe:	9003      	str	r0, [sp, #12]
   3aa00:	4663      	mov	r3, ip
   3aa02:	9905      	ldr	r1, [sp, #20]
   3aa04:	800b      	strh	r3, [r1, #0]
   3aa06:	9b03      	ldr	r3, [sp, #12]
   3aa08:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
   3aa0c:	b2d2      	uxtb	r2, r2
   3aa0e:	0413      	lsls	r3, r2, #16
   3aa10:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3aa14:	4313      	orrs	r3, r2
   3aa16:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3aa1a:	9a04      	ldr	r2, [sp, #16]
   3aa1c:	6013      	str	r3, [r2, #0]
   3aa1e:	2300      	movs	r3, #0
   3aa20:	6023      	str	r3, [r4, #0]
   3aa22:	2500      	movs	r5, #0
   3aa24:	f7fe bcd2 	b.w	393cc <dwt_ioctl+0x154>
   3aa28:	9a07      	ldr	r2, [sp, #28]
   3aa2a:	9b08      	ldr	r3, [sp, #32]
   3aa2c:	e7e9      	b.n	3aa02 <dwt_ioctl+0x178a>
   3aa2e:	9003      	str	r0, [sp, #12]
   3aa30:	e7e7      	b.n	3aa02 <dwt_ioctl+0x178a>
   3aa32:	9a07      	ldr	r2, [sp, #28]
   3aa34:	9b08      	ldr	r3, [sp, #32]
   3aa36:	e7e4      	b.n	3aa02 <dwt_ioctl+0x178a>
   3aa38:	213f      	movs	r1, #63	; 0x3f
   3aa3a:	9103      	str	r1, [sp, #12]
   3aa3c:	e7e1      	b.n	3aa02 <dwt_ioctl+0x178a>
   3aa3e:	2c00      	cmp	r4, #0
   3aa40:	f000 8327 	beq.w	3b092 <dwt_ioctl+0x1e1a>
   3aa44:	7825      	ldrb	r5, [r4, #0]
   3aa46:	6862      	ldr	r2, [r4, #4]
   3aa48:	2a01      	cmp	r2, #1
   3aa4a:	bf15      	itete	ne
   3aa4c:	f46f 3360 	mvnne.w	r3, #229376	; 0x38000
   3aa50:	f46f 43e0 	mvneq.w	r3, #28672	; 0x7000
   3aa54:	27df      	movne	r7, #223	; 0xdf
   3aa56:	27ef      	moveq	r7, #239	; 0xef
   3aa58:	bf14      	ite	ne
   3aa5a:	f04f 0820 	movne.w	r8, #32
   3aa5e:	f04f 0810 	moveq.w	r8, #16
   3aa62:	2400      	movs	r4, #0
   3aa64:	9400      	str	r4, [sp, #0]
   3aa66:	4622      	mov	r2, r4
   3aa68:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3aa6c:	f7fd fd04 	bl	38478 <dwt_modify32bitoffsetreg>
   3aa70:	9400      	str	r4, [sp, #0]
   3aa72:	463b      	mov	r3, r7
   3aa74:	4622      	mov	r2, r4
   3aa76:	4953      	ldr	r1, [pc, #332]	; (3abc4 <dwt_ioctl+0x194c>)
   3aa78:	4630      	mov	r0, r6
   3aa7a:	f7fd fee7 	bl	3884c <dwt_modify8bitoffsetreg>
   3aa7e:	2d01      	cmp	r5, #1
   3aa80:	d003      	beq.n	3aa8a <dwt_ioctl+0x1812>
   3aa82:	b165      	cbz	r5, 3aa9e <dwt_ioctl+0x1826>
   3aa84:	2500      	movs	r5, #0
   3aa86:	f7fe bca1 	b.w	393cc <dwt_ioctl+0x154>
   3aa8a:	4625      	mov	r5, r4
   3aa8c:	9400      	str	r4, [sp, #0]
   3aa8e:	463b      	mov	r3, r7
   3aa90:	4622      	mov	r2, r4
   3aa92:	494d      	ldr	r1, [pc, #308]	; (3abc8 <dwt_ioctl+0x1950>)
   3aa94:	4630      	mov	r0, r6
   3aa96:	f7fd fed9 	bl	3884c <dwt_modify8bitoffsetreg>
   3aa9a:	f7fe bc97 	b.w	393cc <dwt_ioctl+0x154>
   3aa9e:	f8cd 8000 	str.w	r8, [sp]
   3aaa2:	23ff      	movs	r3, #255	; 0xff
   3aaa4:	2200      	movs	r2, #0
   3aaa6:	4948      	ldr	r1, [pc, #288]	; (3abc8 <dwt_ioctl+0x1950>)
   3aaa8:	4630      	mov	r0, r6
   3aaaa:	f7fd fecf 	bl	3884c <dwt_modify8bitoffsetreg>
   3aaae:	f7fe bc8d 	b.w	393cc <dwt_ioctl+0x154>
   3aab2:	2c00      	cmp	r4, #0
   3aab4:	f000 82f0 	beq.w	3b098 <dwt_ioctl+0x1e20>
   3aab8:	7822      	ldrb	r2, [r4, #0]
   3aaba:	f012 0f01 	tst.w	r2, #1
   3aabe:	d02d      	beq.n	3ab1c <dwt_ioctl+0x18a4>
   3aac0:	0157      	lsls	r7, r2, #5
   3aac2:	f007 0740 	and.w	r7, r7, #64	; 0x40
   3aac6:	2440      	movs	r4, #64	; 0x40
   3aac8:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
   3aacc:	f012 0f04 	tst.w	r2, #4
   3aad0:	d028      	beq.n	3ab24 <dwt_ioctl+0x18ac>
   3aad2:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
   3aad6:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   3aada:	0112      	lsls	r2, r2, #4
   3aadc:	f002 0280 	and.w	r2, r2, #128	; 0x80
   3aae0:	4317      	orrs	r7, r2
   3aae2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   3aae6:	9200      	str	r2, [sp, #0]
   3aae8:	43db      	mvns	r3, r3
   3aaea:	2200      	movs	r2, #0
   3aaec:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3aaf0:	4630      	mov	r0, r6
   3aaf2:	f7fd fcc1 	bl	38478 <dwt_modify32bitoffsetreg>
   3aaf6:	43e4      	mvns	r4, r4
   3aaf8:	b2a4      	uxth	r4, r4
   3aafa:	2500      	movs	r5, #0
   3aafc:	9500      	str	r5, [sp, #0]
   3aafe:	4623      	mov	r3, r4
   3ab00:	462a      	mov	r2, r5
   3ab02:	4930      	ldr	r1, [pc, #192]	; (3abc4 <dwt_ioctl+0x194c>)
   3ab04:	4630      	mov	r0, r6
   3ab06:	f7fe f853 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3ab0a:	9700      	str	r7, [sp, #0]
   3ab0c:	4623      	mov	r3, r4
   3ab0e:	462a      	mov	r2, r5
   3ab10:	492d      	ldr	r1, [pc, #180]	; (3abc8 <dwt_ioctl+0x1950>)
   3ab12:	4630      	mov	r0, r6
   3ab14:	f7fe f84c 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3ab18:	f7fe bc58 	b.w	393cc <dwt_ioctl+0x154>
   3ab1c:	2700      	movs	r7, #0
   3ab1e:	463c      	mov	r4, r7
   3ab20:	463b      	mov	r3, r7
   3ab22:	e7d3      	b.n	3aacc <dwt_ioctl+0x1854>
   3ab24:	2200      	movs	r2, #0
   3ab26:	e7de      	b.n	3aae6 <dwt_ioctl+0x186e>
   3ab28:	2308      	movs	r3, #8
   3ab2a:	9300      	str	r3, [sp, #0]
   3ab2c:	23ff      	movs	r3, #255	; 0xff
   3ab2e:	2201      	movs	r2, #1
   3ab30:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3ab34:	f7fd fe8a 	bl	3884c <dwt_modify8bitoffsetreg>
   3ab38:	4c24      	ldr	r4, [pc, #144]	; (3abcc <dwt_ioctl+0x1954>)
   3ab3a:	2302      	movs	r3, #2
   3ab3c:	9300      	str	r3, [sp, #0]
   3ab3e:	23ff      	movs	r3, #255	; 0xff
   3ab40:	2203      	movs	r2, #3
   3ab42:	4621      	mov	r1, r4
   3ab44:	4630      	mov	r0, r6
   3ab46:	f7fd fe81 	bl	3884c <dwt_modify8bitoffsetreg>
   3ab4a:	2500      	movs	r5, #0
   3ab4c:	9500      	str	r5, [sp, #0]
   3ab4e:	23f7      	movs	r3, #247	; 0xf7
   3ab50:	2201      	movs	r2, #1
   3ab52:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3ab56:	4630      	mov	r0, r6
   3ab58:	f7fd fe78 	bl	3884c <dwt_modify8bitoffsetreg>
   3ab5c:	9500      	str	r5, [sp, #0]
   3ab5e:	23fd      	movs	r3, #253	; 0xfd
   3ab60:	2203      	movs	r2, #3
   3ab62:	4621      	mov	r1, r4
   3ab64:	4630      	mov	r0, r6
   3ab66:	f7fd fe71 	bl	3884c <dwt_modify8bitoffsetreg>
   3ab6a:	f7fe bc2f 	b.w	393cc <dwt_ioctl+0x154>
   3ab6e:	2c00      	cmp	r4, #0
   3ab70:	f000 8295 	beq.w	3b09e <dwt_ioctl+0x1e26>
   3ab74:	8863      	ldrh	r3, [r4, #2]
   3ab76:	00db      	lsls	r3, r3, #3
   3ab78:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   3ab7c:	7822      	ldrb	r2, [r4, #0]
   3ab7e:	b10a      	cbz	r2, 3ab84 <dwt_ioctl+0x190c>
   3ab80:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   3ab84:	9300      	str	r3, [sp, #0]
   3ab86:	f24f 0307 	movw	r3, #61447	; 0xf007
   3ab8a:	2200      	movs	r2, #0
   3ab8c:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3ab90:	4630      	mov	r0, r6
   3ab92:	f7fe f80d 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3ab96:	2500      	movs	r5, #0
   3ab98:	f7fe bc18 	b.w	393cc <dwt_ioctl+0x154>
   3ab9c:	2c00      	cmp	r4, #0
   3ab9e:	f000 8281 	beq.w	3b0a4 <dwt_ioctl+0x1e2c>
   3aba2:	b2e3      	uxtb	r3, r4
   3aba4:	1c9a      	adds	r2, r3, #2
   3aba6:	2301      	movs	r3, #1
   3aba8:	4093      	lsls	r3, r2
   3abaa:	3b01      	subs	r3, #1
   3abac:	b2db      	uxtb	r3, r3
   3abae:	2200      	movs	r2, #0
   3abb0:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   3abb4:	f7fc ff7b 	bl	37aae <dwt_write8bitoffsetreg>
   3abb8:	2500      	movs	r5, #0
   3abba:	f7fe bc07 	b.w	393cc <dwt_ioctl+0x154>
   3abbe:	bf00      	nop
   3abc0:	00046e20 	.word	0x00046e20
   3abc4:	00050008 	.word	0x00050008
   3abc8:	0005000c 	.word	0x0005000c
   3abcc:	00110008 	.word	0x00110008
   3abd0:	00046da0 	.word	0x00046da0
   3abd4:	00046de0 	.word	0x00046de0
   3abd8:	2c00      	cmp	r4, #0
   3abda:	f000 8266 	beq.w	3b0aa <dwt_ioctl+0x1e32>
   3abde:	7ae3      	ldrb	r3, [r4, #11]
   3abe0:	2b00      	cmp	r3, #0
   3abe2:	f000 8265 	beq.w	3b0b0 <dwt_ioctl+0x1e38>
   3abe6:	7b63      	ldrb	r3, [r4, #13]
   3abe8:	2b01      	cmp	r3, #1
   3abea:	d921      	bls.n	3ac30 <dwt_ioctl+0x19b8>
   3abec:	7b22      	ldrb	r2, [r4, #12]
   3abee:	4bd7      	ldr	r3, [pc, #860]	; (3af4c <dwt_ioctl+0x1cd4>)
   3abf0:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
   3abf4:	0112      	lsls	r2, r2, #4
   3abf6:	0ad3      	lsrs	r3, r2, #11
   3abf8:	f3c2 020a 	ubfx	r2, r2, #0, #11
   3abfc:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3ac00:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3ac04:	bf28      	it	cs
   3ac06:	3301      	addcs	r3, #1
   3ac08:	b29b      	uxth	r3, r3
   3ac0a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   3ac0e:	9300      	str	r3, [sp, #0]
   3ac10:	f64f 7380 	movw	r3, #65408	; 0xff80
   3ac14:	2202      	movs	r2, #2
   3ac16:	49ce      	ldr	r1, [pc, #824]	; (3af50 <dwt_ioctl+0x1cd8>)
   3ac18:	4630      	mov	r0, r6
   3ac1a:	f7fd ffc9 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3ac1e:	2394      	movs	r3, #148	; 0x94
   3ac20:	2200      	movs	r2, #0
   3ac22:	49cc      	ldr	r1, [pc, #816]	; (3af54 <dwt_ioctl+0x1cdc>)
   3ac24:	4630      	mov	r0, r6
   3ac26:	f7fc ff42 	bl	37aae <dwt_write8bitoffsetreg>
   3ac2a:	2500      	movs	r5, #0
   3ac2c:	f7fe bbce 	b.w	393cc <dwt_ioctl+0x154>
   3ac30:	7b22      	ldrb	r2, [r4, #12]
   3ac32:	4bc6      	ldr	r3, [pc, #792]	; (3af4c <dwt_ioctl+0x1cd4>)
   3ac34:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   3ac38:	f44f 6235 	mov.w	r2, #2896	; 0xb50
   3ac3c:	fb02 f203 	mul.w	r2, r2, r3
   3ac40:	0c93      	lsrs	r3, r2, #18
   3ac42:	f3c2 12ca 	ubfx	r2, r2, #7, #11
   3ac46:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3ac4a:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3ac4e:	bf28      	it	cs
   3ac50:	3301      	addcs	r3, #1
   3ac52:	b29b      	uxth	r3, r3
   3ac54:	e7d9      	b.n	3ac0a <dwt_ioctl+0x1992>
   3ac56:	2c00      	cmp	r4, #0
   3ac58:	f000 822d 	beq.w	3b0b6 <dwt_ioctl+0x1e3e>
   3ac5c:	2200      	movs	r2, #0
   3ac5e:	49be      	ldr	r1, [pc, #760]	; (3af58 <dwt_ioctl+0x1ce0>)
   3ac60:	f7fc fb36 	bl	372d0 <dwt_read32bitoffsetreg>
   3ac64:	6020      	str	r0, [r4, #0]
   3ac66:	2500      	movs	r5, #0
   3ac68:	f7fe bbb0 	b.w	393cc <dwt_ioctl+0x154>
   3ac6c:	2c00      	cmp	r4, #0
   3ac6e:	f000 8225 	beq.w	3b0bc <dwt_ioctl+0x1e44>
   3ac72:	2200      	movs	r2, #0
   3ac74:	49b9      	ldr	r1, [pc, #740]	; (3af5c <dwt_ioctl+0x1ce4>)
   3ac76:	f7fc fb2b 	bl	372d0 <dwt_read32bitoffsetreg>
   3ac7a:	6020      	str	r0, [r4, #0]
   3ac7c:	2500      	movs	r5, #0
   3ac7e:	f7fe bba5 	b.w	393cc <dwt_ioctl+0x154>
   3ac82:	2c00      	cmp	r4, #0
   3ac84:	f000 821d 	beq.w	3b0c2 <dwt_ioctl+0x1e4a>
   3ac88:	f44f 13a8 	mov.w	r3, #1376256	; 0x150000
   3ac8c:	6023      	str	r3, [r4, #0]
   3ac8e:	2500      	movs	r5, #0
   3ac90:	f7fe bb9c 	b.w	393cc <dwt_ioctl+0x154>
   3ac94:	2c00      	cmp	r4, #0
   3ac96:	f000 8217 	beq.w	3b0c8 <dwt_ioctl+0x1e50>
   3ac9a:	2500      	movs	r5, #0
   3ac9c:	950b      	str	r5, [sp, #44]	; 0x2c
   3ac9e:	af10      	add	r7, sp, #64	; 0x40
   3aca0:	2319      	movs	r3, #25
   3aca2:	f847 3d10 	str.w	r3, [r7, #-16]!
   3aca6:	9700      	str	r7, [sp, #0]
   3aca8:	2304      	movs	r3, #4
   3acaa:	462a      	mov	r2, r5
   3acac:	49ac      	ldr	r1, [pc, #688]	; (3af60 <dwt_ioctl+0x1ce8>)
   3acae:	f7fc fef3 	bl	37a98 <dwt_writetodevice>
   3acb2:	f641 7348 	movw	r3, #8008	; 0x1f48
   3acb6:	930c      	str	r3, [sp, #48]	; 0x30
   3acb8:	9700      	str	r7, [sp, #0]
   3acba:	2304      	movs	r3, #4
   3acbc:	462a      	mov	r2, r5
   3acbe:	49a9      	ldr	r1, [pc, #676]	; (3af64 <dwt_ioctl+0x1cec>)
   3acc0:	4630      	mov	r0, r6
   3acc2:	f7fc fee9 	bl	37a98 <dwt_writetodevice>
   3acc6:	ab0b      	add	r3, sp, #44	; 0x2c
   3acc8:	9300      	str	r3, [sp, #0]
   3acca:	2304      	movs	r3, #4
   3accc:	462a      	mov	r2, r5
   3acce:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3acd2:	4630      	mov	r0, r6
   3acd4:	f7fc faf2 	bl	372bc <dwt_readfromdevice>
   3acd8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   3acda:	6023      	str	r3, [r4, #0]
   3acdc:	f7fe bb76 	b.w	393cc <dwt_ioctl+0x154>
   3ace0:	2c00      	cmp	r4, #0
   3ace2:	f000 81f4 	beq.w	3b0ce <dwt_ioctl+0x1e56>
   3ace6:	2200      	movs	r2, #0
   3ace8:	499f      	ldr	r1, [pc, #636]	; (3af68 <dwt_ioctl+0x1cf0>)
   3acea:	f7fc faf1 	bl	372d0 <dwt_read32bitoffsetreg>
   3acee:	b280      	uxth	r0, r0
   3acf0:	6020      	str	r0, [r4, #0]
   3acf2:	2200      	movs	r2, #0
   3acf4:	499d      	ldr	r1, [pc, #628]	; (3af6c <dwt_ioctl+0x1cf4>)
   3acf6:	4630      	mov	r0, r6
   3acf8:	f7fc faea 	bl	372d0 <dwt_read32bitoffsetreg>
   3acfc:	0d43      	lsrs	r3, r0, #21
   3acfe:	019b      	lsls	r3, r3, #6
   3ad00:	b29b      	uxth	r3, r3
   3ad02:	6063      	str	r3, [r4, #4]
   3ad04:	2500      	movs	r5, #0
   3ad06:	f7fe bb61 	b.w	393cc <dwt_ioctl+0x154>
   3ad0a:	2c00      	cmp	r4, #0
   3ad0c:	f000 81e2 	beq.w	3b0d4 <dwt_ioctl+0x1e5c>
   3ad10:	7d63      	ldrb	r3, [r4, #21]
   3ad12:	b12b      	cbz	r3, 3ad20 <dwt_ioctl+0x1aa8>
   3ad14:	2b01      	cmp	r3, #1
   3ad16:	d037      	beq.n	3ad88 <dwt_ioctl+0x1b10>
   3ad18:	2b02      	cmp	r3, #2
   3ad1a:	d05e      	beq.n	3adda <dwt_ioctl+0x1b62>
   3ad1c:	23ff      	movs	r3, #255	; 0xff
   3ad1e:	e02f      	b.n	3ad80 <dwt_ioctl+0x1b08>
   3ad20:	2200      	movs	r2, #0
   3ad22:	4993      	ldr	r1, [pc, #588]	; (3af70 <dwt_ioctl+0x1cf8>)
   3ad24:	f7fc fad4 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad28:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3ad2c:	6020      	str	r0, [r4, #0]
   3ad2e:	2200      	movs	r2, #0
   3ad30:	4990      	ldr	r1, [pc, #576]	; (3af74 <dwt_ioctl+0x1cfc>)
   3ad32:	4630      	mov	r0, r6
   3ad34:	f7fc facc 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad38:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ad3c:	6060      	str	r0, [r4, #4]
   3ad3e:	2200      	movs	r2, #0
   3ad40:	498d      	ldr	r1, [pc, #564]	; (3af78 <dwt_ioctl+0x1d00>)
   3ad42:	4630      	mov	r0, r6
   3ad44:	f7fc fac4 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad48:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ad4c:	60a0      	str	r0, [r4, #8]
   3ad4e:	2200      	movs	r2, #0
   3ad50:	498a      	ldr	r1, [pc, #552]	; (3af7c <dwt_ioctl+0x1d04>)
   3ad52:	4630      	mov	r0, r6
   3ad54:	f7fc fabc 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad58:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ad5c:	60e0      	str	r0, [r4, #12]
   3ad5e:	2200      	movs	r2, #0
   3ad60:	4987      	ldr	r1, [pc, #540]	; (3af80 <dwt_ioctl+0x1d08>)
   3ad62:	4630      	mov	r0, r6
   3ad64:	f7fc fab4 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad68:	f3c0 0010 	ubfx	r0, r0, #0, #17
   3ad6c:	6120      	str	r0, [r4, #16]
   3ad6e:	2203      	movs	r2, #3
   3ad70:	4979      	ldr	r1, [pc, #484]	; (3af58 <dwt_ioctl+0x1ce0>)
   3ad72:	4630      	mov	r0, r6
   3ad74:	f7fc fad4 	bl	37320 <dwt_read8bitoffsetreg>
   3ad78:	f3c0 1002 	ubfx	r0, r0, #4, #3
   3ad7c:	7520      	strb	r0, [r4, #20]
   3ad7e:	2300      	movs	r3, #0
   3ad80:	75a3      	strb	r3, [r4, #22]
   3ad82:	2500      	movs	r5, #0
   3ad84:	f7fe bb22 	b.w	393cc <dwt_ioctl+0x154>
   3ad88:	2200      	movs	r2, #0
   3ad8a:	497e      	ldr	r1, [pc, #504]	; (3af84 <dwt_ioctl+0x1d0c>)
   3ad8c:	f7fc faa0 	bl	372d0 <dwt_read32bitoffsetreg>
   3ad90:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3ad94:	6020      	str	r0, [r4, #0]
   3ad96:	2200      	movs	r2, #0
   3ad98:	497b      	ldr	r1, [pc, #492]	; (3af88 <dwt_ioctl+0x1d10>)
   3ad9a:	4630      	mov	r0, r6
   3ad9c:	f7fc fa98 	bl	372d0 <dwt_read32bitoffsetreg>
   3ada0:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ada4:	6060      	str	r0, [r4, #4]
   3ada6:	2200      	movs	r2, #0
   3ada8:	4978      	ldr	r1, [pc, #480]	; (3af8c <dwt_ioctl+0x1d14>)
   3adaa:	4630      	mov	r0, r6
   3adac:	f7fc fa90 	bl	372d0 <dwt_read32bitoffsetreg>
   3adb0:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3adb4:	60a0      	str	r0, [r4, #8]
   3adb6:	2200      	movs	r2, #0
   3adb8:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   3adbc:	4630      	mov	r0, r6
   3adbe:	f7fc fa87 	bl	372d0 <dwt_read32bitoffsetreg>
   3adc2:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3adc6:	60e0      	str	r0, [r4, #12]
   3adc8:	2200      	movs	r2, #0
   3adca:	4971      	ldr	r1, [pc, #452]	; (3af90 <dwt_ioctl+0x1d18>)
   3adcc:	4630      	mov	r0, r6
   3adce:	f7fc fa7f 	bl	372d0 <dwt_read32bitoffsetreg>
   3add2:	f3c0 0013 	ubfx	r0, r0, #0, #20
   3add6:	6120      	str	r0, [r4, #16]
   3add8:	e7c9      	b.n	3ad6e <dwt_ioctl+0x1af6>
   3adda:	2200      	movs	r2, #0
   3addc:	496d      	ldr	r1, [pc, #436]	; (3af94 <dwt_ioctl+0x1d1c>)
   3adde:	f7fc fa77 	bl	372d0 <dwt_read32bitoffsetreg>
   3ade2:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3ade6:	6020      	str	r0, [r4, #0]
   3ade8:	2200      	movs	r2, #0
   3adea:	496b      	ldr	r1, [pc, #428]	; (3af98 <dwt_ioctl+0x1d20>)
   3adec:	4630      	mov	r0, r6
   3adee:	f7fc fa6f 	bl	372d0 <dwt_read32bitoffsetreg>
   3adf2:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3adf6:	6060      	str	r0, [r4, #4]
   3adf8:	2200      	movs	r2, #0
   3adfa:	4968      	ldr	r1, [pc, #416]	; (3af9c <dwt_ioctl+0x1d24>)
   3adfc:	4630      	mov	r0, r6
   3adfe:	f7fc fa67 	bl	372d0 <dwt_read32bitoffsetreg>
   3ae02:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ae06:	60a0      	str	r0, [r4, #8]
   3ae08:	2200      	movs	r2, #0
   3ae0a:	4965      	ldr	r1, [pc, #404]	; (3afa0 <dwt_ioctl+0x1d28>)
   3ae0c:	4630      	mov	r0, r6
   3ae0e:	f7fc fa5f 	bl	372d0 <dwt_read32bitoffsetreg>
   3ae12:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3ae16:	60e0      	str	r0, [r4, #12]
   3ae18:	2200      	movs	r2, #0
   3ae1a:	4962      	ldr	r1, [pc, #392]	; (3afa4 <dwt_ioctl+0x1d2c>)
   3ae1c:	4630      	mov	r0, r6
   3ae1e:	f7fc fa57 	bl	372d0 <dwt_read32bitoffsetreg>
   3ae22:	f3c0 0013 	ubfx	r0, r0, #0, #20
   3ae26:	6120      	str	r0, [r4, #16]
   3ae28:	e7a1      	b.n	3ad6e <dwt_ioctl+0x1af6>
   3ae2a:	2500      	movs	r5, #0
   3ae2c:	f7fe bace 	b.w	393cc <dwt_ioctl+0x154>
   3ae30:	2500      	movs	r5, #0
   3ae32:	f7fe bacb 	b.w	393cc <dwt_ioctl+0x154>
   3ae36:	2500      	movs	r5, #0
   3ae38:	f7fe bac8 	b.w	393cc <dwt_ioctl+0x154>
   3ae3c:	2500      	movs	r5, #0
   3ae3e:	f7fe bac5 	b.w	393cc <dwt_ioctl+0x154>
   3ae42:	2500      	movs	r5, #0
   3ae44:	f7fe bac2 	b.w	393cc <dwt_ioctl+0x154>
   3ae48:	2500      	movs	r5, #0
   3ae4a:	f7fe babf 	b.w	393cc <dwt_ioctl+0x154>
   3ae4e:	2500      	movs	r5, #0
   3ae50:	f7fe babc 	b.w	393cc <dwt_ioctl+0x154>
   3ae54:	2500      	movs	r5, #0
   3ae56:	f7fe bab9 	b.w	393cc <dwt_ioctl+0x154>
   3ae5a:	2500      	movs	r5, #0
   3ae5c:	f7fe bab6 	b.w	393cc <dwt_ioctl+0x154>
   3ae60:	2500      	movs	r5, #0
   3ae62:	f7fe bab3 	b.w	393cc <dwt_ioctl+0x154>
   3ae66:	2500      	movs	r5, #0
   3ae68:	f7fe bab0 	b.w	393cc <dwt_ioctl+0x154>
   3ae6c:	2500      	movs	r5, #0
   3ae6e:	f7fe baad 	b.w	393cc <dwt_ioctl+0x154>
   3ae72:	2500      	movs	r5, #0
   3ae74:	f7fe baaa 	b.w	393cc <dwt_ioctl+0x154>
   3ae78:	2500      	movs	r5, #0
   3ae7a:	f7fe baa7 	b.w	393cc <dwt_ioctl+0x154>
   3ae7e:	2500      	movs	r5, #0
   3ae80:	f7fe baa4 	b.w	393cc <dwt_ioctl+0x154>
   3ae84:	2500      	movs	r5, #0
   3ae86:	f7fe baa1 	b.w	393cc <dwt_ioctl+0x154>
   3ae8a:	2500      	movs	r5, #0
   3ae8c:	f7fe ba9e 	b.w	393cc <dwt_ioctl+0x154>
   3ae90:	2500      	movs	r5, #0
   3ae92:	f7fe ba9b 	b.w	393cc <dwt_ioctl+0x154>
   3ae96:	2500      	movs	r5, #0
   3ae98:	f7fe ba98 	b.w	393cc <dwt_ioctl+0x154>
   3ae9c:	2500      	movs	r5, #0
   3ae9e:	f7fe ba95 	b.w	393cc <dwt_ioctl+0x154>
   3aea2:	2500      	movs	r5, #0
   3aea4:	f7fe ba92 	b.w	393cc <dwt_ioctl+0x154>
   3aea8:	2500      	movs	r5, #0
   3aeaa:	f7fe ba8f 	b.w	393cc <dwt_ioctl+0x154>
   3aeae:	2500      	movs	r5, #0
   3aeb0:	f7fe ba8c 	b.w	393cc <dwt_ioctl+0x154>
   3aeb4:	2500      	movs	r5, #0
   3aeb6:	f7fe ba89 	b.w	393cc <dwt_ioctl+0x154>
   3aeba:	2500      	movs	r5, #0
   3aebc:	f7fe ba86 	b.w	393cc <dwt_ioctl+0x154>
   3aec0:	2500      	movs	r5, #0
   3aec2:	f7fe ba83 	b.w	393cc <dwt_ioctl+0x154>
   3aec6:	2500      	movs	r5, #0
   3aec8:	f7fe ba80 	b.w	393cc <dwt_ioctl+0x154>
   3aecc:	2500      	movs	r5, #0
   3aece:	f7fe ba7d 	b.w	393cc <dwt_ioctl+0x154>
   3aed2:	2500      	movs	r5, #0
   3aed4:	f7fe ba7a 	b.w	393cc <dwt_ioctl+0x154>
   3aed8:	2500      	movs	r5, #0
   3aeda:	f7fe ba77 	b.w	393cc <dwt_ioctl+0x154>
   3aede:	2500      	movs	r5, #0
   3aee0:	f7fe ba74 	b.w	393cc <dwt_ioctl+0x154>
   3aee4:	2500      	movs	r5, #0
   3aee6:	f7fe ba71 	b.w	393cc <dwt_ioctl+0x154>
   3aeea:	2500      	movs	r5, #0
   3aeec:	f7fe ba6e 	b.w	393cc <dwt_ioctl+0x154>
   3aef0:	2500      	movs	r5, #0
   3aef2:	f7fe ba6b 	b.w	393cc <dwt_ioctl+0x154>
   3aef6:	2500      	movs	r5, #0
   3aef8:	f7fe ba68 	b.w	393cc <dwt_ioctl+0x154>
   3aefc:	2500      	movs	r5, #0
   3aefe:	f7fe ba65 	b.w	393cc <dwt_ioctl+0x154>
   3af02:	2500      	movs	r5, #0
   3af04:	f7fe ba62 	b.w	393cc <dwt_ioctl+0x154>
   3af08:	2500      	movs	r5, #0
   3af0a:	f7fe ba5f 	b.w	393cc <dwt_ioctl+0x154>
   3af0e:	2500      	movs	r5, #0
   3af10:	f7fe ba5c 	b.w	393cc <dwt_ioctl+0x154>
   3af14:	2500      	movs	r5, #0
   3af16:	f7fe ba59 	b.w	393cc <dwt_ioctl+0x154>
   3af1a:	2500      	movs	r5, #0
   3af1c:	f7fe ba56 	b.w	393cc <dwt_ioctl+0x154>
   3af20:	2500      	movs	r5, #0
   3af22:	f7fe ba53 	b.w	393cc <dwt_ioctl+0x154>
   3af26:	2500      	movs	r5, #0
   3af28:	f7fe ba50 	b.w	393cc <dwt_ioctl+0x154>
   3af2c:	2500      	movs	r5, #0
   3af2e:	f7fe ba4d 	b.w	393cc <dwt_ioctl+0x154>
   3af32:	2500      	movs	r5, #0
   3af34:	f7fe ba4a 	b.w	393cc <dwt_ioctl+0x154>
   3af38:	2500      	movs	r5, #0
   3af3a:	f7fe ba47 	b.w	393cc <dwt_ioctl+0x154>
   3af3e:	2500      	movs	r5, #0
   3af40:	f7fe ba44 	b.w	393cc <dwt_ioctl+0x154>
   3af44:	2500      	movs	r5, #0
   3af46:	f7fe ba41 	b.w	393cc <dwt_ioctl+0x154>
   3af4a:	bf00      	nop
   3af4c:	00046e5c 	.word	0x00046e5c
   3af50:	000e0012 	.word	0x000e0012
   3af54:	000e0016 	.word	0x000e0016
   3af58:	00030060 	.word	0x00030060
   3af5c:	000f0048 	.word	0x000f0048
   3af60:	001f0004 	.word	0x001f0004
   3af64:	001f0008 	.word	0x001f0008
   3af68:	000c0048 	.word	0x000c0048
   3af6c:	000c0028 	.word	0x000c0028
   3af70:	000c0058 	.word	0x000c0058
   3af74:	000c0030 	.word	0x000c0030
   3af78:	000c0034 	.word	0x000c0034
   3af7c:	000c0038 	.word	0x000c0038
   3af80:	000c002c 	.word	0x000c002c
   3af84:	000d0020 	.word	0x000d0020
   3af88:	000c0064 	.word	0x000c0064
   3af8c:	000c0068 	.word	0x000c0068
   3af90:	000c0060 	.word	0x000c0060
   3af94:	000d0068 	.word	0x000d0068
   3af98:	000d0040 	.word	0x000d0040
   3af9c:	000d0044 	.word	0x000d0044
   3afa0:	000d0048 	.word	0x000d0048
   3afa4:	000d003c 	.word	0x000d003c
   3afa8:	2500      	movs	r5, #0
   3afaa:	f7fe ba0f 	b.w	393cc <dwt_ioctl+0x154>
   3afae:	2500      	movs	r5, #0
   3afb0:	f7fe ba0c 	b.w	393cc <dwt_ioctl+0x154>
   3afb4:	2500      	movs	r5, #0
   3afb6:	f7fe ba09 	b.w	393cc <dwt_ioctl+0x154>
   3afba:	2500      	movs	r5, #0
   3afbc:	f7fe ba06 	b.w	393cc <dwt_ioctl+0x154>
   3afc0:	2500      	movs	r5, #0
   3afc2:	f7fe ba03 	b.w	393cc <dwt_ioctl+0x154>
   3afc6:	2500      	movs	r5, #0
   3afc8:	f7fe ba00 	b.w	393cc <dwt_ioctl+0x154>
   3afcc:	2500      	movs	r5, #0
   3afce:	f7fe b9fd 	b.w	393cc <dwt_ioctl+0x154>
   3afd2:	2500      	movs	r5, #0
   3afd4:	f7fe b9fa 	b.w	393cc <dwt_ioctl+0x154>
   3afd8:	2500      	movs	r5, #0
   3afda:	f7fe b9f7 	b.w	393cc <dwt_ioctl+0x154>
   3afde:	2500      	movs	r5, #0
   3afe0:	f7fe b9f4 	b.w	393cc <dwt_ioctl+0x154>
   3afe4:	2500      	movs	r5, #0
   3afe6:	f7fe b9f1 	b.w	393cc <dwt_ioctl+0x154>
   3afea:	2500      	movs	r5, #0
   3afec:	f7fe b9ee 	b.w	393cc <dwt_ioctl+0x154>
   3aff0:	2500      	movs	r5, #0
   3aff2:	f7fe b9eb 	b.w	393cc <dwt_ioctl+0x154>
   3aff6:	2500      	movs	r5, #0
   3aff8:	f7fe b9e8 	b.w	393cc <dwt_ioctl+0x154>
   3affc:	2500      	movs	r5, #0
   3affe:	f7fe b9e5 	b.w	393cc <dwt_ioctl+0x154>
   3b002:	2500      	movs	r5, #0
   3b004:	f7fe b9e2 	b.w	393cc <dwt_ioctl+0x154>
   3b008:	2500      	movs	r5, #0
   3b00a:	f7fe b9df 	b.w	393cc <dwt_ioctl+0x154>
   3b00e:	2500      	movs	r5, #0
   3b010:	f7fe b9dc 	b.w	393cc <dwt_ioctl+0x154>
   3b014:	2500      	movs	r5, #0
   3b016:	f7fe b9d9 	b.w	393cc <dwt_ioctl+0x154>
   3b01a:	2500      	movs	r5, #0
   3b01c:	f7fe b9d6 	b.w	393cc <dwt_ioctl+0x154>
   3b020:	2500      	movs	r5, #0
   3b022:	f7fe b9d3 	b.w	393cc <dwt_ioctl+0x154>
   3b026:	2500      	movs	r5, #0
   3b028:	f7fe b9d0 	b.w	393cc <dwt_ioctl+0x154>
   3b02c:	2500      	movs	r5, #0
   3b02e:	f7fe b9cd 	b.w	393cc <dwt_ioctl+0x154>
   3b032:	2500      	movs	r5, #0
   3b034:	f7fe b9ca 	b.w	393cc <dwt_ioctl+0x154>
   3b038:	2500      	movs	r5, #0
   3b03a:	f7fe b9c7 	b.w	393cc <dwt_ioctl+0x154>
   3b03e:	2500      	movs	r5, #0
   3b040:	f7fe b9c4 	b.w	393cc <dwt_ioctl+0x154>
   3b044:	2500      	movs	r5, #0
   3b046:	f7fe b9c1 	b.w	393cc <dwt_ioctl+0x154>
   3b04a:	2500      	movs	r5, #0
   3b04c:	f7fe b9be 	b.w	393cc <dwt_ioctl+0x154>
   3b050:	2500      	movs	r5, #0
   3b052:	f7fe b9bb 	b.w	393cc <dwt_ioctl+0x154>
   3b056:	2500      	movs	r5, #0
   3b058:	f7fe b9b8 	b.w	393cc <dwt_ioctl+0x154>
   3b05c:	2500      	movs	r5, #0
   3b05e:	f7fe b9b5 	b.w	393cc <dwt_ioctl+0x154>
   3b062:	2500      	movs	r5, #0
   3b064:	f7fe b9b2 	b.w	393cc <dwt_ioctl+0x154>
   3b068:	2500      	movs	r5, #0
   3b06a:	f7fe b9af 	b.w	393cc <dwt_ioctl+0x154>
   3b06e:	2500      	movs	r5, #0
   3b070:	f7fe b9ac 	b.w	393cc <dwt_ioctl+0x154>
   3b074:	2500      	movs	r5, #0
   3b076:	f7fe b9a9 	b.w	393cc <dwt_ioctl+0x154>
   3b07a:	2500      	movs	r5, #0
   3b07c:	f7fe b9a6 	b.w	393cc <dwt_ioctl+0x154>
   3b080:	2500      	movs	r5, #0
   3b082:	f7fe b9a3 	b.w	393cc <dwt_ioctl+0x154>
   3b086:	2500      	movs	r5, #0
   3b088:	f7fe b9a0 	b.w	393cc <dwt_ioctl+0x154>
   3b08c:	2500      	movs	r5, #0
   3b08e:	f7fe b99d 	b.w	393cc <dwt_ioctl+0x154>
   3b092:	2500      	movs	r5, #0
   3b094:	f7fe b99a 	b.w	393cc <dwt_ioctl+0x154>
   3b098:	2500      	movs	r5, #0
   3b09a:	f7fe b997 	b.w	393cc <dwt_ioctl+0x154>
   3b09e:	2500      	movs	r5, #0
   3b0a0:	f7fe b994 	b.w	393cc <dwt_ioctl+0x154>
   3b0a4:	2500      	movs	r5, #0
   3b0a6:	f7fe b991 	b.w	393cc <dwt_ioctl+0x154>
   3b0aa:	2500      	movs	r5, #0
   3b0ac:	f7fe b98e 	b.w	393cc <dwt_ioctl+0x154>
   3b0b0:	2500      	movs	r5, #0
   3b0b2:	f7fe b98b 	b.w	393cc <dwt_ioctl+0x154>
   3b0b6:	2500      	movs	r5, #0
   3b0b8:	f7fe b988 	b.w	393cc <dwt_ioctl+0x154>
   3b0bc:	2500      	movs	r5, #0
   3b0be:	f7fe b985 	b.w	393cc <dwt_ioctl+0x154>
   3b0c2:	2500      	movs	r5, #0
   3b0c4:	f7fe b982 	b.w	393cc <dwt_ioctl+0x154>
   3b0c8:	2500      	movs	r5, #0
   3b0ca:	f7fe b97f 	b.w	393cc <dwt_ioctl+0x154>
   3b0ce:	2500      	movs	r5, #0
   3b0d0:	f7fe b97c 	b.w	393cc <dwt_ioctl+0x154>
   3b0d4:	2500      	movs	r5, #0
   3b0d6:	f7fe b979 	b.w	393cc <dwt_ioctl+0x154>
   3b0da:	f899 3011 	ldrb.w	r3, [r9, #17]
   3b0de:	1e5a      	subs	r2, r3, #1
   3b0e0:	b2d2      	uxtb	r2, r2
   3b0e2:	2a01      	cmp	r2, #1
   3b0e4:	f67f a801 	bls.w	3a0ea <dwt_ioctl+0xe72>
   3b0e8:	2202      	movs	r2, #2
   3b0ea:	f7fe bf88 	b.w	39ffe <dwt_ioctl+0xd86>
   3b0ee:	2f00      	cmp	r7, #0
   3b0f0:	f43f ac62 	beq.w	3a9b8 <dwt_ioctl+0x1740>
   3b0f4:	f819 1000 	ldrb.w	r1, [r9, r0]
   3b0f8:	1a5b      	subs	r3, r3, r1
   3b0fa:	b29b      	uxth	r3, r3
   3b0fc:	e481      	b.n	3aa02 <dwt_ioctl+0x178a>
   3b0fe:	283f      	cmp	r0, #63	; 0x3f
   3b100:	d027      	beq.n	3b152 <dwt_ioctl+0x1eda>
   3b102:	2e00      	cmp	r6, #0
   3b104:	f47f ac5e 	bne.w	3a9c4 <dwt_ioctl+0x174c>
   3b108:	3001      	adds	r0, #1
   3b10a:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   3b10e:	f819 1000 	ldrb.w	r1, [r9, r0]
   3b112:	440b      	add	r3, r1
   3b114:	b29b      	uxth	r3, r3
   3b116:	459c      	cmp	ip, r3
   3b118:	f43f ac71 	beq.w	3a9fe <dwt_ioctl+0x1786>
   3b11c:	3d01      	subs	r5, #1
   3b11e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   3b122:	f43f ac32 	beq.w	3a98a <dwt_ioctl+0x1712>
   3b126:	459e      	cmp	lr, r3
   3b128:	f4bf ac40 	bcs.w	3a9ac <dwt_ioctl+0x1734>
   3b12c:	4598      	cmp	r8, r3
   3b12e:	d9de      	bls.n	3b0ee <dwt_ioctl+0x1e76>
   3b130:	ebac 0103 	sub.w	r1, ip, r3
   3b134:	b209      	sxth	r1, r1
   3b136:	2900      	cmp	r1, #0
   3b138:	bfb8      	it	lt
   3b13a:	4249      	neglt	r1, r1
   3b13c:	4559      	cmp	r1, fp
   3b13e:	f77f ac2e 	ble.w	3a99e <dwt_ioctl+0x1726>
   3b142:	2f00      	cmp	r7, #0
   3b144:	f47f ac70 	bne.w	3aa28 <dwt_ioctl+0x17b0>
   3b148:	283f      	cmp	r0, #63	; 0x3f
   3b14a:	d1da      	bne.n	3b102 <dwt_ioctl+0x1e8a>
   3b14c:	2f00      	cmp	r7, #0
   3b14e:	f47f ac70 	bne.w	3aa32 <dwt_ioctl+0x17ba>
   3b152:	2a03      	cmp	r2, #3
   3b154:	f43f ac70 	beq.w	3aa38 <dwt_ioctl+0x17c0>
   3b158:	2a02      	cmp	r2, #2
   3b15a:	f43f ac3f 	beq.w	3a9dc <dwt_ioctl+0x1764>
   3b15e:	f81a 1002 	ldrb.w	r1, [sl, r2]
   3b162:	185e      	adds	r6, r3, r1
   3b164:	4566      	cmp	r6, ip
   3b166:	f77f ac40 	ble.w	3a9ea <dwt_ioctl+0x1772>
   3b16a:	440b      	add	r3, r1
   3b16c:	b29b      	uxth	r3, r3
   3b16e:	3201      	adds	r2, #1
   3b170:	b2d2      	uxtb	r2, r2
   3b172:	2700      	movs	r7, #0
   3b174:	e426      	b.n	3a9c4 <dwt_ioctl+0x174c>
   3b176:	bf00      	nop

0003b178 <ull_initialise>:
   3b178:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3b17c:	4605      	mov	r5, r0
   3b17e:	460e      	mov	r6, r1
   3b180:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3b182:	2b00      	cmp	r3, #0
   3b184:	d05c      	beq.n	3b240 <ull_initialise+0xc8>
   3b186:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   3b188:	2300      	movs	r3, #0
   3b18a:	73e3      	strb	r3, [r4, #15]
   3b18c:	2202      	movs	r2, #2
   3b18e:	8262      	strh	r2, [r4, #18]
   3b190:	75a3      	strb	r3, [r4, #22]
   3b192:	75e3      	strb	r3, [r4, #23]
   3b194:	7423      	strb	r3, [r4, #16]
   3b196:	72a3      	strb	r3, [r4, #10]
   3b198:	72e3      	strb	r3, [r4, #11]
   3b19a:	2104      	movs	r1, #4
   3b19c:	4628      	mov	r0, r5
   3b19e:	f7fc fd33 	bl	37c08 <_dwt_otpread>
   3b1a2:	4607      	mov	r7, r0
   3b1a4:	2105      	movs	r1, #5
   3b1a6:	4628      	mov	r0, r5
   3b1a8:	f7fc fd2e 	bl	37c08 <_dwt_otpread>
   3b1ac:	4680      	mov	r8, r0
   3b1ae:	210a      	movs	r1, #10
   3b1b0:	4628      	mov	r0, r5
   3b1b2:	f7fc fd29 	bl	37c08 <_dwt_otpread>
   3b1b6:	f3c0 4004 	ubfx	r0, r0, #16, #5
   3b1ba:	7220      	strb	r0, [r4, #8]
   3b1bc:	b127      	cbz	r7, 3b1c8 <ull_initialise+0x50>
   3b1be:	f1b8 0f00 	cmp.w	r8, #0
   3b1c2:	d001      	beq.n	3b1c8 <ull_initialise+0x50>
   3b1c4:	2800      	cmp	r0, #0
   3b1c6:	d140      	bne.n	3b24a <ull_initialise+0xd2>
   3b1c8:	2120      	movs	r1, #32
   3b1ca:	4628      	mov	r0, r5
   3b1cc:	f7fc fd1c 	bl	37c08 <_dwt_otpread>
   3b1d0:	4b2f      	ldr	r3, [pc, #188]	; (3b290 <ull_initialise+0x118>)
   3b1d2:	4298      	cmp	r0, r3
   3b1d4:	bf0c      	ite	eq
   3b1d6:	2301      	moveq	r3, #1
   3b1d8:	2300      	movne	r3, #0
   3b1da:	7263      	strb	r3, [r4, #9]
   3b1dc:	f016 0f10 	tst.w	r6, #16
   3b1e0:	d137      	bne.n	3b252 <ull_initialise+0xda>
   3b1e2:	f016 0f20 	tst.w	r6, #32
   3b1e6:	d13a      	bne.n	3b25e <ull_initialise+0xe6>
   3b1e8:	f016 0f40 	tst.w	r6, #64	; 0x40
   3b1ec:	d13d      	bne.n	3b26a <ull_initialise+0xf2>
   3b1ee:	f016 0f80 	tst.w	r6, #128	; 0x80
   3b1f2:	d141      	bne.n	3b278 <ull_initialise+0x100>
   3b1f4:	7ae3      	ldrb	r3, [r4, #11]
   3b1f6:	b90b      	cbnz	r3, 3b1fc <ull_initialise+0x84>
   3b1f8:	2385      	movs	r3, #133	; 0x85
   3b1fa:	72e3      	strb	r3, [r4, #11]
   3b1fc:	7aa3      	ldrb	r3, [r4, #10]
   3b1fe:	b90b      	cbnz	r3, 3b204 <ull_initialise+0x8c>
   3b200:	2374      	movs	r3, #116	; 0x74
   3b202:	72a3      	strb	r3, [r4, #10]
   3b204:	211f      	movs	r1, #31
   3b206:	4628      	mov	r0, r5
   3b208:	f7fc fcfe 	bl	37c08 <_dwt_otpread>
   3b20c:	7360      	strb	r0, [r4, #13]
   3b20e:	211e      	movs	r1, #30
   3b210:	4628      	mov	r0, r5
   3b212:	f7fc fcf9 	bl	37c08 <_dwt_otpread>
   3b216:	f010 003f 	ands.w	r0, r0, #63	; 0x3f
   3b21a:	bf12      	itee	ne
   3b21c:	73a0      	strbne	r0, [r4, #14]
   3b21e:	232e      	moveq	r3, #46	; 0x2e
   3b220:	73a3      	strbeq	r3, [r4, #14]
   3b222:	7ba3      	ldrb	r3, [r4, #14]
   3b224:	2200      	movs	r2, #0
   3b226:	491b      	ldr	r1, [pc, #108]	; (3b294 <ull_initialise+0x11c>)
   3b228:	4628      	mov	r0, r5
   3b22a:	f7fc fc40 	bl	37aae <dwt_write8bitoffsetreg>
   3b22e:	2135      	movs	r1, #53	; 0x35
   3b230:	4628      	mov	r0, r5
   3b232:	f7fc fce9 	bl	37c08 <_dwt_otpread>
   3b236:	4603      	mov	r3, r0
   3b238:	bb20      	cbnz	r0, 3b284 <ull_initialise+0x10c>
   3b23a:	2000      	movs	r0, #0
   3b23c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3b240:	202c      	movs	r0, #44	; 0x2c
   3b242:	f7f5 fd71 	bl	30d28 <malloc>
   3b246:	6528      	str	r0, [r5, #80]	; 0x50
   3b248:	e79d      	b.n	3b186 <ull_initialise+0xe>
   3b24a:	4628      	mov	r0, r5
   3b24c:	f7fd fcca 	bl	38be4 <_dwt_prog_ldo_and_bias_tune>
   3b250:	e7ba      	b.n	3b1c8 <ull_initialise+0x50>
   3b252:	2106      	movs	r1, #6
   3b254:	4628      	mov	r0, r5
   3b256:	f7fc fcd7 	bl	37c08 <_dwt_otpread>
   3b25a:	6020      	str	r0, [r4, #0]
   3b25c:	e7c1      	b.n	3b1e2 <ull_initialise+0x6a>
   3b25e:	2107      	movs	r1, #7
   3b260:	4628      	mov	r0, r5
   3b262:	f7fc fcd1 	bl	37c08 <_dwt_otpread>
   3b266:	6060      	str	r0, [r4, #4]
   3b268:	e7be      	b.n	3b1e8 <ull_initialise+0x70>
   3b26a:	2108      	movs	r1, #8
   3b26c:	4628      	mov	r0, r5
   3b26e:	f7fc fccb 	bl	37c08 <_dwt_otpread>
   3b272:	0c00      	lsrs	r0, r0, #16
   3b274:	72a0      	strb	r0, [r4, #10]
   3b276:	e7ba      	b.n	3b1ee <ull_initialise+0x76>
   3b278:	2109      	movs	r1, #9
   3b27a:	4628      	mov	r0, r5
   3b27c:	f7fc fcc4 	bl	37c08 <_dwt_otpread>
   3b280:	72e0      	strb	r0, [r4, #11]
   3b282:	e7b7      	b.n	3b1f4 <ull_initialise+0x7c>
   3b284:	2200      	movs	r2, #0
   3b286:	4904      	ldr	r1, [pc, #16]	; (3b298 <ull_initialise+0x120>)
   3b288:	4628      	mov	r0, r5
   3b28a:	f7fc fd63 	bl	37d54 <dwt_write32bitoffsetreg>
   3b28e:	e7d4      	b.n	3b23a <ull_initialise+0xc2>
   3b290:	10000240 	.word	0x10000240
   3b294:	00090014 	.word	0x00090014
   3b298:	00090004 	.word	0x00090004

0003b29c <_init>:
   3b29c:	b5f0      	push	{r4, r5, r6, r7, lr}
   3b29e:	b085      	sub	sp, #20
   3b2a0:	4604      	mov	r4, r0
   3b2a2:	6b43      	ldr	r3, [r0, #52]	; 0x34
   3b2a4:	6819      	ldr	r1, [r3, #0]
   3b2a6:	f7ff ff67 	bl	3b178 <ull_initialise>
   3b2aa:	4606      	mov	r6, r0
   3b2ac:	6823      	ldr	r3, [r4, #0]
   3b2ae:	691b      	ldr	r3, [r3, #16]
   3b2b0:	4798      	blx	r3
   3b2b2:	ab03      	add	r3, sp, #12
   3b2b4:	2200      	movs	r2, #0
   3b2b6:	4611      	mov	r1, r2
   3b2b8:	4620      	mov	r0, r4
   3b2ba:	f7fd ffdd 	bl	39278 <dwt_ioctl>
   3b2be:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b2c0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b2c2:	6819      	ldr	r1, [r3, #0]
   3b2c4:	4620      	mov	r0, r4
   3b2c6:	f7fd fdad 	bl	38e24 <ull_configure>
   3b2ca:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b2cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b2ce:	6859      	ldr	r1, [r3, #4]
   3b2d0:	4620      	mov	r0, r4
   3b2d2:	f7fd fb47 	bl	38964 <ull_configuretxrf>
   3b2d6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b2d8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b2da:	89db      	ldrh	r3, [r3, #14]
   3b2dc:	2200      	movs	r2, #0
   3b2de:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3b2e2:	4620      	mov	r0, r4
   3b2e4:	f7fc fc35 	bl	37b52 <dwt_write16bitoffsetreg>
   3b2e8:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b2ea:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b2ec:	899b      	ldrh	r3, [r3, #12]
   3b2ee:	2200      	movs	r2, #0
   3b2f0:	4952      	ldr	r1, [pc, #328]	; (3b43c <_init+0x1a0>)
   3b2f2:	4620      	mov	r0, r4
   3b2f4:	f7fc fc2d 	bl	37b52 <dwt_write16bitoffsetreg>
   3b2f8:	2100      	movs	r1, #0
   3b2fa:	4620      	mov	r0, r4
   3b2fc:	f7fc fec6 	bl	3808c <ull_setrxaftertxdelay>
   3b300:	2500      	movs	r5, #0
   3b302:	9500      	str	r5, [sp, #0]
   3b304:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   3b308:	462a      	mov	r2, r5
   3b30a:	2110      	movs	r1, #16
   3b30c:	4620      	mov	r0, r4
   3b30e:	f7fd fc4f 	bl	38bb0 <dwt_modify16bitoffsetreg>
   3b312:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b314:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b316:	895a      	ldrh	r2, [r3, #10]
   3b318:	8919      	ldrh	r1, [r3, #8]
   3b31a:	4620      	mov	r0, r4
   3b31c:	f7fd fbb2 	bl	38a84 <ull_configureframefilter>
   3b320:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b322:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b324:	8a1b      	ldrh	r3, [r3, #16]
   3b326:	2202      	movs	r2, #2
   3b328:	210c      	movs	r1, #12
   3b32a:	4620      	mov	r0, r4
   3b32c:	f7fc fc11 	bl	37b52 <dwt_write16bitoffsetreg>
   3b330:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b332:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3b334:	8a5b      	ldrh	r3, [r3, #18]
   3b336:	462a      	mov	r2, r5
   3b338:	210c      	movs	r1, #12
   3b33a:	4620      	mov	r0, r4
   3b33c:	f7fc fc09 	bl	37b52 <dwt_write16bitoffsetreg>
   3b340:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b342:	7a19      	ldrb	r1, [r3, #8]
   3b344:	4620      	mov	r0, r4
   3b346:	f7fd fc69 	bl	38c1c <ull_setleds>
   3b34a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b34c:	68d9      	ldr	r1, [r3, #12]
   3b34e:	4620      	mov	r0, r4
   3b350:	f7fc feb2 	bl	380b8 <ull_setlnapamode>
   3b354:	6b61      	ldr	r1, [r4, #52]	; 0x34
   3b356:	7e0b      	ldrb	r3, [r1, #24]
   3b358:	694a      	ldr	r2, [r1, #20]
   3b35a:	6909      	ldr	r1, [r1, #16]
   3b35c:	4620      	mov	r0, r4
   3b35e:	f7fd f9e9 	bl	38734 <ull_setinterrupt>
   3b362:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b364:	7f9a      	ldrb	r2, [r3, #30]
   3b366:	8b99      	ldrh	r1, [r3, #28]
   3b368:	4620      	mov	r0, r4
   3b36a:	f7fc fcb7 	bl	37cdc <ull_configuresleep>
   3b36e:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3b370:	7b93      	ldrb	r3, [r2, #14]
   3b372:	2b2e      	cmp	r3, #46	; 0x2e
   3b374:	d005      	beq.n	3b382 <_init+0xe6>
   3b376:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b378:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   3b37c:	f033 033f 	bics.w	r3, r3, #63	; 0x3f
   3b380:	d00a      	beq.n	3b398 <_init+0xfc>
   3b382:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b384:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   3b388:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   3b38c:	7393      	strb	r3, [r2, #14]
   3b38e:	2200      	movs	r2, #0
   3b390:	492b      	ldr	r1, [pc, #172]	; (3b440 <_init+0x1a4>)
   3b392:	4620      	mov	r0, r4
   3b394:	f7fc fb8b 	bl	37aae <dwt_write8bitoffsetreg>
   3b398:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b39a:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
   3b39e:	4620      	mov	r0, r4
   3b3a0:	f7fd fa68 	bl	38874 <ull_configciadiag>
   3b3a4:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b3a6:	6a19      	ldr	r1, [r3, #32]
   3b3a8:	4620      	mov	r0, r4
   3b3aa:	f7fc fea7 	bl	380fc <ull_configurestskey>
   3b3ae:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b3b0:	6a59      	ldr	r1, [r3, #36]	; 0x24
   3b3b2:	4620      	mov	r0, r4
   3b3b4:	f7fc fec6 	bl	38144 <ull_configurestsiv>
   3b3b8:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b3ba:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
   3b3be:	bba3      	cbnz	r3, 3b42a <_init+0x18e>
   3b3c0:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3b3c2:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
   3b3c6:	4620      	mov	r0, r4
   3b3c8:	f7fc fbb0 	bl	37b2c <ull_configeventcounters>
   3b3cc:	f994 504c 	ldrsb.w	r5, [r4, #76]	; 0x4c
   3b3d0:	2d00      	cmp	r5, #0
   3b3d2:	db27      	blt.n	3b424 <_init+0x188>
   3b3d4:	2301      	movs	r3, #1
   3b3d6:	fa03 f505 	lsl.w	r5, r3, r5
   3b3da:	b2af      	uxth	r7, r5
   3b3dc:	f04f 7290 	mov.w	r2, #18874368	; 0x1200000
   3b3e0:	4639      	mov	r1, r7
   3b3e2:	4620      	mov	r0, r4
   3b3e4:	f7fd f988 	bl	386f8 <ull_setgpiomode>
   3b3e8:	f10d 030a 	add.w	r3, sp, #10
   3b3ec:	9300      	str	r3, [sp, #0]
   3b3ee:	2302      	movs	r3, #2
   3b3f0:	2200      	movs	r2, #0
   3b3f2:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3b3f6:	4620      	mov	r0, r4
   3b3f8:	f7fb ff60 	bl	372bc <dwt_readfromdevice>
   3b3fc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   3b400:	ea23 0305 	bic.w	r3, r3, r5
   3b404:	f8ad 300a 	strh.w	r3, [sp, #10]
   3b408:	2200      	movs	r2, #0
   3b40a:	490e      	ldr	r1, [pc, #56]	; (3b444 <_init+0x1a8>)
   3b40c:	4620      	mov	r0, r4
   3b40e:	f7fc fba0 	bl	37b52 <dwt_write16bitoffsetreg>
   3b412:	f994 204d 	ldrsb.w	r2, [r4, #77]	; 0x4d
   3b416:	fab2 f282 	clz	r2, r2
   3b41a:	0952      	lsrs	r2, r2, #5
   3b41c:	4639      	mov	r1, r7
   3b41e:	4620      	mov	r0, r4
   3b420:	f7fd fc7a 	bl	38d18 <ull_setgpiovalue>
   3b424:	4630      	mov	r0, r6
   3b426:	b005      	add	sp, #20
   3b428:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3b42a:	2301      	movs	r3, #1
   3b42c:	9300      	str	r3, [sp, #0]
   3b42e:	23ff      	movs	r3, #255	; 0xff
   3b430:	2200      	movs	r2, #0
   3b432:	4905      	ldr	r1, [pc, #20]	; (3b448 <_init+0x1ac>)
   3b434:	4620      	mov	r0, r4
   3b436:	f7fd fa09 	bl	3884c <dwt_modify8bitoffsetreg>
   3b43a:	e7c1      	b.n	3b3c0 <_init+0x124>
   3b43c:	00010004 	.word	0x00010004
   3b440:	00090014 	.word	0x00090014
   3b444:	00050008 	.word	0x00050008
   3b448:	00020004 	.word	0x00020004

0003b44c <dwt_dbg_fn>:
   3b44c:	2998      	cmp	r1, #152	; 0x98
   3b44e:	4802      	ldr	r0, [pc, #8]	; (3b458 <dwt_dbg_fn+0xc>)
   3b450:	bf18      	it	ne
   3b452:	2000      	movne	r0, #0
   3b454:	4770      	bx	lr
   3b456:	bf00      	nop
   3b458:	00046f64 	.word	0x00046f64

0003b45c <_deinit>:
   3b45c:	4770      	bx	lr

0003b45e <dwt_xfer3xxx>:
   3b45e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3b462:	b084      	sub	sp, #16
   3b464:	4605      	mov	r5, r0
   3b466:	460f      	mov	r7, r1
   3b468:	461e      	mov	r6, r3
   3b46a:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   3b46e:	1e59      	subs	r1, r3, #1
   3b470:	b289      	uxth	r1, r1
   3b472:	2901      	cmp	r1, #1
   3b474:	d91c      	bls.n	3b4b0 <dwt_xfer3xxx+0x52>
   3b476:	19d0      	adds	r0, r2, r7
   3b478:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   3b47c:	443a      	add	r2, r7
   3b47e:	f3c2 4104 	ubfx	r1, r2, #16, #5
   3b482:	0082      	lsls	r2, r0, #2
   3b484:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
   3b488:	ea43 0102 	orr.w	r1, r3, r2
   3b48c:	0a09      	lsrs	r1, r1, #8
   3b48e:	f88d 100c 	strb.w	r1, [sp, #12]
   3b492:	b920      	cbnz	r0, 3b49e <dwt_xfer3xxx+0x40>
   3b494:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   3b498:	d018      	beq.n	3b4cc <dwt_xfer3xxx+0x6e>
   3b49a:	2b00      	cmp	r3, #0
   3b49c:	d037      	beq.n	3b50e <dwt_xfer3xxx+0xb0>
   3b49e:	f041 0140 	orr.w	r1, r1, #64	; 0x40
   3b4a2:	f88d 100c 	strb.w	r1, [sp, #12]
   3b4a6:	431a      	orrs	r2, r3
   3b4a8:	f88d 200d 	strb.w	r2, [sp, #13]
   3b4ac:	2402      	movs	r4, #2
   3b4ae:	e005      	b.n	3b4bc <dwt_xfer3xxx+0x5e>
   3b4b0:	007a      	lsls	r2, r7, #1
   3b4b2:	f062 027e 	orn	r2, r2, #126	; 0x7e
   3b4b6:	f88d 200c 	strb.w	r2, [sp, #12]
   3b4ba:	2401      	movs	r4, #1
   3b4bc:	2b02      	cmp	r3, #2
   3b4be:	d006      	beq.n	3b4ce <dwt_xfer3xxx+0x70>
   3b4c0:	d326      	bcc.n	3b510 <dwt_xfer3xxx+0xb2>
   3b4c2:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
   3b4c6:	2b03      	cmp	r3, #3
   3b4c8:	d901      	bls.n	3b4ce <dwt_xfer3xxx+0x70>
   3b4ca:	e7fe      	b.n	3b4ca <dwt_xfer3xxx+0x6c>
   3b4cc:	2401      	movs	r4, #1
   3b4ce:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3b4d0:	7d1b      	ldrb	r3, [r3, #20]
   3b4d2:	b94b      	cbnz	r3, 3b4e8 <dwt_xfer3xxx+0x8a>
   3b4d4:	682b      	ldr	r3, [r5, #0]
   3b4d6:	685d      	ldr	r5, [r3, #4]
   3b4d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3b4da:	4632      	mov	r2, r6
   3b4dc:	a903      	add	r1, sp, #12
   3b4de:	4620      	mov	r0, r4
   3b4e0:	47a8      	blx	r5
   3b4e2:	b004      	add	sp, #16
   3b4e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3b4e8:	2200      	movs	r2, #0
   3b4ea:	4621      	mov	r1, r4
   3b4ec:	a803      	add	r0, sp, #12
   3b4ee:	f7fb fe45 	bl	3717c <dwt_generatecrc8>
   3b4f2:	4602      	mov	r2, r0
   3b4f4:	4631      	mov	r1, r6
   3b4f6:	980a      	ldr	r0, [sp, #40]	; 0x28
   3b4f8:	f7fb fe40 	bl	3717c <dwt_generatecrc8>
   3b4fc:	682b      	ldr	r3, [r5, #0]
   3b4fe:	9000      	str	r0, [sp, #0]
   3b500:	689d      	ldr	r5, [r3, #8]
   3b502:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3b504:	4632      	mov	r2, r6
   3b506:	a903      	add	r1, sp, #12
   3b508:	4620      	mov	r0, r4
   3b50a:	47a8      	blx	r5
   3b50c:	e7e9      	b.n	3b4e2 <dwt_xfer3xxx+0x84>
   3b50e:	2401      	movs	r4, #1
   3b510:	682b      	ldr	r3, [r5, #0]
   3b512:	f8d3 8000 	ldr.w	r8, [r3]
   3b516:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3b518:	4632      	mov	r2, r6
   3b51a:	a903      	add	r1, sp, #12
   3b51c:	4620      	mov	r0, r4
   3b51e:	47c0      	blx	r8
   3b520:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3b522:	7d1b      	ldrb	r3, [r3, #20]
   3b524:	2b02      	cmp	r3, #2
   3b526:	d1dc      	bne.n	3b4e2 <dwt_xfer3xxx+0x84>
   3b528:	2f18      	cmp	r7, #24
   3b52a:	d0da      	beq.n	3b4e2 <dwt_xfer3xxx+0x84>
   3b52c:	2200      	movs	r2, #0
   3b52e:	4621      	mov	r1, r4
   3b530:	a803      	add	r0, sp, #12
   3b532:	f7fb fe23 	bl	3717c <dwt_generatecrc8>
   3b536:	4602      	mov	r2, r0
   3b538:	4631      	mov	r1, r6
   3b53a:	980a      	ldr	r0, [sp, #40]	; 0x28
   3b53c:	f7fb fe1e 	bl	3717c <dwt_generatecrc8>
   3b540:	4604      	mov	r4, r0
   3b542:	2200      	movs	r2, #0
   3b544:	2118      	movs	r1, #24
   3b546:	4628      	mov	r0, r5
   3b548:	f000 f839 	bl	3b5be <dwt_read8bitoffsetreg>
   3b54c:	4284      	cmp	r4, r0
   3b54e:	d0c8      	beq.n	3b4e2 <dwt_xfer3xxx+0x84>
   3b550:	68eb      	ldr	r3, [r5, #12]
   3b552:	2b00      	cmp	r3, #0
   3b554:	d0c5      	beq.n	3b4e2 <dwt_xfer3xxx+0x84>
   3b556:	4798      	blx	r3
   3b558:	e7c3      	b.n	3b4e2 <dwt_xfer3xxx+0x84>

0003b55a <dwt_readfromdevice>:
   3b55a:	b510      	push	{r4, lr}
   3b55c:	b082      	sub	sp, #8
   3b55e:	2400      	movs	r4, #0
   3b560:	9401      	str	r4, [sp, #4]
   3b562:	9c04      	ldr	r4, [sp, #16]
   3b564:	9400      	str	r4, [sp, #0]
   3b566:	f7ff ff7a 	bl	3b45e <dwt_xfer3xxx>
   3b56a:	b002      	add	sp, #8
   3b56c:	bd10      	pop	{r4, pc}

0003b56e <dwt_read32bitoffsetreg>:
   3b56e:	b500      	push	{lr}
   3b570:	b085      	sub	sp, #20
   3b572:	ab03      	add	r3, sp, #12
   3b574:	9300      	str	r3, [sp, #0]
   3b576:	2304      	movs	r3, #4
   3b578:	b292      	uxth	r2, r2
   3b57a:	f7ff ffee 	bl	3b55a <dwt_readfromdevice>
   3b57e:	f10d 030f 	add.w	r3, sp, #15
   3b582:	f10d 010b 	add.w	r1, sp, #11
   3b586:	2000      	movs	r0, #0
   3b588:	f813 2901 	ldrb.w	r2, [r3], #-1
   3b58c:	eb02 2000 	add.w	r0, r2, r0, lsl #8
   3b590:	428b      	cmp	r3, r1
   3b592:	d1f9      	bne.n	3b588 <dwt_read32bitoffsetreg+0x1a>
   3b594:	b005      	add	sp, #20
   3b596:	f85d fb04 	ldr.w	pc, [sp], #4

0003b59a <dwt_read16bitoffsetreg>:
   3b59a:	b500      	push	{lr}
   3b59c:	b085      	sub	sp, #20
   3b59e:	ab03      	add	r3, sp, #12
   3b5a0:	9300      	str	r3, [sp, #0]
   3b5a2:	2302      	movs	r3, #2
   3b5a4:	b292      	uxth	r2, r2
   3b5a6:	f7ff ffd8 	bl	3b55a <dwt_readfromdevice>
   3b5aa:	f89d 300d 	ldrb.w	r3, [sp, #13]
   3b5ae:	f89d 000c 	ldrb.w	r0, [sp, #12]
   3b5b2:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   3b5b6:	b280      	uxth	r0, r0
   3b5b8:	b005      	add	sp, #20
   3b5ba:	f85d fb04 	ldr.w	pc, [sp], #4

0003b5be <dwt_read8bitoffsetreg>:
   3b5be:	b500      	push	{lr}
   3b5c0:	b085      	sub	sp, #20
   3b5c2:	f10d 030f 	add.w	r3, sp, #15
   3b5c6:	9300      	str	r3, [sp, #0]
   3b5c8:	2301      	movs	r3, #1
   3b5ca:	b292      	uxth	r2, r2
   3b5cc:	f7ff ffc5 	bl	3b55a <dwt_readfromdevice>
   3b5d0:	f89d 000f 	ldrb.w	r0, [sp, #15]
   3b5d4:	b005      	add	sp, #20
   3b5d6:	f85d fb04 	ldr.w	pc, [sp], #4

0003b5da <ull_readdiagnostics>:
   3b5da:	b530      	push	{r4, r5, lr}
   3b5dc:	b0bd      	sub	sp, #244	; 0xf4
   3b5de:	4605      	mov	r5, r0
   3b5e0:	460c      	mov	r4, r1
   3b5e2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3b5e4:	7b9a      	ldrb	r2, [r3, #14]
   3b5e6:	2a01      	cmp	r2, #1
   3b5e8:	d01c      	beq.n	3b624 <ull_readdiagnostics+0x4a>
   3b5ea:	2a03      	cmp	r2, #3
   3b5ec:	f040 81e8 	bne.w	3b9c0 <ull_readdiagnostics+0x3e6>
   3b5f0:	7d9b      	ldrb	r3, [r3, #22]
   3b5f2:	f013 0f08 	tst.w	r3, #8
   3b5f6:	d10c      	bne.n	3b612 <ull_readdiagnostics+0x38>
   3b5f8:	f013 0f04 	tst.w	r3, #4
   3b5fc:	ab02      	add	r3, sp, #8
   3b5fe:	9300      	str	r3, [sp, #0]
   3b600:	bf14      	ite	ne
   3b602:	2338      	movne	r3, #56	; 0x38
   3b604:	2320      	moveq	r3, #32
   3b606:	2200      	movs	r2, #0
   3b608:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3b60c:	f7ff ffa5 	bl	3b55a <dwt_readfromdevice>
   3b610:	e019      	b.n	3b646 <ull_readdiagnostics+0x6c>
   3b612:	ab02      	add	r3, sp, #8
   3b614:	9300      	str	r3, [sp, #0]
   3b616:	23e8      	movs	r3, #232	; 0xe8
   3b618:	2200      	movs	r2, #0
   3b61a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3b61e:	f7ff ff9c 	bl	3b55a <dwt_readfromdevice>
   3b622:	e010      	b.n	3b646 <ull_readdiagnostics+0x6c>
   3b624:	7d9b      	ldrb	r3, [r3, #22]
   3b626:	f013 0f08 	tst.w	r3, #8
   3b62a:	f040 81c0 	bne.w	3b9ae <ull_readdiagnostics+0x3d4>
   3b62e:	f013 0f04 	tst.w	r3, #4
   3b632:	ab02      	add	r3, sp, #8
   3b634:	9300      	str	r3, [sp, #0]
   3b636:	bf14      	ite	ne
   3b638:	2338      	movne	r3, #56	; 0x38
   3b63a:	2320      	moveq	r3, #32
   3b63c:	2200      	movs	r2, #0
   3b63e:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   3b642:	f7ff ff8a 	bl	3b55a <dwt_readfromdevice>
   3b646:	f10d 0217 	add.w	r2, sp, #23
   3b64a:	f104 031a 	add.w	r3, r4, #26
   3b64e:	f104 0020 	add.w	r0, r4, #32
   3b652:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   3b656:	f803 1b01 	strb.w	r1, [r3], #1
   3b65a:	4283      	cmp	r3, r0
   3b65c:	d1f9      	bne.n	3b652 <ull_readdiagnostics+0x78>
   3b65e:	f89d 2015 	ldrb.w	r2, [sp, #21]
   3b662:	f89d 3014 	ldrb.w	r3, [sp, #20]
   3b666:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b66a:	f3c3 030c 	ubfx	r3, r3, #0, #13
   3b66e:	8463      	strh	r3, [r4, #34]	; 0x22
   3b670:	f89d 201f 	ldrb.w	r2, [sp, #31]
   3b674:	f89d 301e 	ldrb.w	r3, [sp, #30]
   3b678:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b67c:	f3c3 030d 	ubfx	r3, r3, #0, #14
   3b680:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   3b684:	bf1c      	itt	ne
   3b686:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   3b68a:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   3b68e:	8423      	strh	r3, [r4, #32]
   3b690:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
   3b694:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   3b698:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b69c:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3b6a0:	87e3      	strh	r3, [r4, #62]	; 0x3e
   3b6a2:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3b6a4:	7d9b      	ldrb	r3, [r3, #22]
   3b6a6:	f013 0f02 	tst.w	r3, #2
   3b6aa:	f040 817e 	bne.w	3b9aa <ull_readdiagnostics+0x3d0>
   3b6ae:	aa0a      	add	r2, sp, #40	; 0x28
   3b6b0:	1e63      	subs	r3, r4, #1
   3b6b2:	1d20      	adds	r0, r4, #4
   3b6b4:	f812 1b01 	ldrb.w	r1, [r2], #1
   3b6b8:	f803 1f01 	strb.w	r1, [r3, #1]!
   3b6bc:	79d1      	ldrb	r1, [r2, #7]
   3b6be:	7219      	strb	r1, [r3, #8]
   3b6c0:	7bd1      	ldrb	r1, [r2, #15]
   3b6c2:	7459      	strb	r1, [r3, #17]
   3b6c4:	4283      	cmp	r3, r0
   3b6c6:	d1f5      	bne.n	3b6b4 <ull_readdiagnostics+0xda>
   3b6c8:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   3b6cc:	7163      	strb	r3, [r4, #5]
   3b6ce:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
   3b6d2:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
   3b6d6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b6da:	80e3      	strh	r3, [r4, #6]
   3b6dc:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   3b6e0:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   3b6e4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3b6e8:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3b6ec:	f8a4 300d 	strh.w	r3, [r4, #13]
   3b6f0:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   3b6f4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   3b6f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b6fc:	f8a4 300f 	strh.w	r3, [r4, #15]
   3b700:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   3b704:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   3b708:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3b70c:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3b710:	82e3      	strh	r3, [r4, #22]
   3b712:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
   3b716:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
   3b71a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b71e:	8323      	strh	r3, [r4, #24]
   3b720:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3b722:	7d9b      	ldrb	r3, [r3, #22]
   3b724:	f013 0f04 	tst.w	r3, #4
   3b728:	f040 813f 	bne.w	3b9aa <ull_readdiagnostics+0x3d0>
   3b72c:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   3b730:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   3b734:	041b      	lsls	r3, r3, #16
   3b736:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b73a:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   3b73e:	4313      	orrs	r3, r2
   3b740:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   3b744:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b748:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   3b74c:	6263      	str	r3, [r4, #36]	; 0x24
   3b74e:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
   3b752:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
   3b756:	041b      	lsls	r3, r3, #16
   3b758:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b75c:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
   3b760:	4313      	orrs	r3, r2
   3b762:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
   3b766:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b76a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3b76e:	62a3      	str	r3, [r4, #40]	; 0x28
   3b770:	f89d 204b 	ldrb.w	r2, [sp, #75]	; 0x4b
   3b774:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   3b778:	041b      	lsls	r3, r3, #16
   3b77a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b77e:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
   3b782:	4313      	orrs	r3, r2
   3b784:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
   3b788:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b78c:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3b790:	62e3      	str	r3, [r4, #44]	; 0x2c
   3b792:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
   3b796:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
   3b79a:	041b      	lsls	r3, r3, #16
   3b79c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b7a0:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   3b7a4:	4313      	orrs	r3, r2
   3b7a6:	f89d 204d 	ldrb.w	r2, [sp, #77]	; 0x4d
   3b7aa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b7ae:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b7b2:	6323      	str	r3, [r4, #48]	; 0x30
   3b7b4:	f89d 2053 	ldrb.w	r2, [sp, #83]	; 0x53
   3b7b8:	f89d 3052 	ldrb.w	r3, [sp, #82]	; 0x52
   3b7bc:	041b      	lsls	r3, r3, #16
   3b7be:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b7c2:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
   3b7c6:	4313      	orrs	r3, r2
   3b7c8:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   3b7cc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b7d0:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b7d4:	6363      	str	r3, [r4, #52]	; 0x34
   3b7d6:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   3b7da:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
   3b7de:	041b      	lsls	r3, r3, #16
   3b7e0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b7e4:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
   3b7e8:	4313      	orrs	r3, r2
   3b7ea:	f89d 2055 	ldrb.w	r2, [sp, #85]	; 0x55
   3b7ee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b7f2:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b7f6:	63a3      	str	r3, [r4, #56]	; 0x38
   3b7f8:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   3b7fc:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
   3b800:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b804:	87a3      	strh	r3, [r4, #60]	; 0x3c
   3b806:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   3b80a:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   3b80e:	041b      	lsls	r3, r3, #16
   3b810:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b814:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   3b818:	4313      	orrs	r3, r2
   3b81a:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   3b81e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b822:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3b826:	6423      	str	r3, [r4, #64]	; 0x40
   3b828:	f89d 207b 	ldrb.w	r2, [sp, #123]	; 0x7b
   3b82c:	f89d 307a 	ldrb.w	r3, [sp, #122]	; 0x7a
   3b830:	041b      	lsls	r3, r3, #16
   3b832:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b836:	f89d 2078 	ldrb.w	r2, [sp, #120]	; 0x78
   3b83a:	4313      	orrs	r3, r2
   3b83c:	f89d 2079 	ldrb.w	r2, [sp, #121]	; 0x79
   3b840:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b844:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3b848:	6463      	str	r3, [r4, #68]	; 0x44
   3b84a:	f89d 207f 	ldrb.w	r2, [sp, #127]	; 0x7f
   3b84e:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
   3b852:	041b      	lsls	r3, r3, #16
   3b854:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b858:	f89d 207c 	ldrb.w	r2, [sp, #124]	; 0x7c
   3b85c:	4313      	orrs	r3, r2
   3b85e:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   3b862:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b866:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b86a:	64a3      	str	r3, [r4, #72]	; 0x48
   3b86c:	f89d 2083 	ldrb.w	r2, [sp, #131]	; 0x83
   3b870:	f89d 3082 	ldrb.w	r3, [sp, #130]	; 0x82
   3b874:	041b      	lsls	r3, r3, #16
   3b876:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b87a:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
   3b87e:	4313      	orrs	r3, r2
   3b880:	f89d 2081 	ldrb.w	r2, [sp, #129]	; 0x81
   3b884:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b888:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b88c:	64e3      	str	r3, [r4, #76]	; 0x4c
   3b88e:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
   3b892:	f89d 3086 	ldrb.w	r3, [sp, #134]	; 0x86
   3b896:	041b      	lsls	r3, r3, #16
   3b898:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b89c:	f89d 2084 	ldrb.w	r2, [sp, #132]	; 0x84
   3b8a0:	4313      	orrs	r3, r2
   3b8a2:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   3b8a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b8aa:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b8ae:	6523      	str	r3, [r4, #80]	; 0x50
   3b8b0:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   3b8b4:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   3b8b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b8bc:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3b8c0:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   3b8c4:	f89d 20a5 	ldrb.w	r2, [sp, #165]	; 0xa5
   3b8c8:	f89d 30a4 	ldrb.w	r3, [sp, #164]	; 0xa4
   3b8cc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b8d0:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3b8d4:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   3b8d8:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   3b8dc:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   3b8e0:	041b      	lsls	r3, r3, #16
   3b8e2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b8e6:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   3b8ea:	4313      	orrs	r3, r2
   3b8ec:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   3b8f0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b8f4:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3b8f8:	65a3      	str	r3, [r4, #88]	; 0x58
   3b8fa:	f89d 20c3 	ldrb.w	r2, [sp, #195]	; 0xc3
   3b8fe:	f89d 30c2 	ldrb.w	r3, [sp, #194]	; 0xc2
   3b902:	041b      	lsls	r3, r3, #16
   3b904:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b908:	f89d 20c0 	ldrb.w	r2, [sp, #192]	; 0xc0
   3b90c:	4313      	orrs	r3, r2
   3b90e:	f89d 20c1 	ldrb.w	r2, [sp, #193]	; 0xc1
   3b912:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b916:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3b91a:	65e3      	str	r3, [r4, #92]	; 0x5c
   3b91c:	f89d 20c7 	ldrb.w	r2, [sp, #199]	; 0xc7
   3b920:	f89d 30c6 	ldrb.w	r3, [sp, #198]	; 0xc6
   3b924:	041b      	lsls	r3, r3, #16
   3b926:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b92a:	f89d 20c4 	ldrb.w	r2, [sp, #196]	; 0xc4
   3b92e:	4313      	orrs	r3, r2
   3b930:	f89d 20c5 	ldrb.w	r2, [sp, #197]	; 0xc5
   3b934:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b938:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b93c:	6623      	str	r3, [r4, #96]	; 0x60
   3b93e:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   3b942:	f89d 30ca 	ldrb.w	r3, [sp, #202]	; 0xca
   3b946:	041b      	lsls	r3, r3, #16
   3b948:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b94c:	f89d 20c8 	ldrb.w	r2, [sp, #200]	; 0xc8
   3b950:	4313      	orrs	r3, r2
   3b952:	f89d 20c9 	ldrb.w	r2, [sp, #201]	; 0xc9
   3b956:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b95a:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b95e:	6663      	str	r3, [r4, #100]	; 0x64
   3b960:	f89d 20cf 	ldrb.w	r2, [sp, #207]	; 0xcf
   3b964:	f89d 30ce 	ldrb.w	r3, [sp, #206]	; 0xce
   3b968:	041b      	lsls	r3, r3, #16
   3b96a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3b96e:	f89d 20cc 	ldrb.w	r2, [sp, #204]	; 0xcc
   3b972:	4313      	orrs	r3, r2
   3b974:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   3b978:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b97c:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3b980:	66a3      	str	r3, [r4, #104]	; 0x68
   3b982:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   3b986:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   3b98a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b98e:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3b992:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   3b996:	f89d 20ed 	ldrb.w	r2, [sp, #237]	; 0xed
   3b99a:	f89d 30ec 	ldrb.w	r3, [sp, #236]	; 0xec
   3b99e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3b9a2:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3b9a6:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   3b9aa:	b03d      	add	sp, #244	; 0xf4
   3b9ac:	bd30      	pop	{r4, r5, pc}
   3b9ae:	ab02      	add	r3, sp, #8
   3b9b0:	9300      	str	r3, [sp, #0]
   3b9b2:	23e8      	movs	r3, #232	; 0xe8
   3b9b4:	2200      	movs	r2, #0
   3b9b6:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   3b9ba:	f7ff fdce 	bl	3b55a <dwt_readfromdevice>
   3b9be:	e642      	b.n	3b646 <ull_readdiagnostics+0x6c>
   3b9c0:	7d9b      	ldrb	r3, [r3, #22]
   3b9c2:	f013 0f01 	tst.w	r3, #1
   3b9c6:	f000 81b3 	beq.w	3bd30 <ull_readdiagnostics+0x756>
   3b9ca:	ab02      	add	r3, sp, #8
   3b9cc:	9300      	str	r3, [sp, #0]
   3b9ce:	236c      	movs	r3, #108	; 0x6c
   3b9d0:	2200      	movs	r2, #0
   3b9d2:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   3b9d6:	f7ff fdc0 	bl	3b55a <dwt_readfromdevice>
   3b9da:	ab1d      	add	r3, sp, #116	; 0x74
   3b9dc:	9300      	str	r3, [sp, #0]
   3b9de:	236c      	movs	r3, #108	; 0x6c
   3b9e0:	2200      	movs	r2, #0
   3b9e2:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   3b9e6:	4628      	mov	r0, r5
   3b9e8:	f7ff fdb7 	bl	3b55a <dwt_readfromdevice>
   3b9ec:	aa02      	add	r2, sp, #8
   3b9ee:	1e63      	subs	r3, r4, #1
   3b9f0:	1d20      	adds	r0, r4, #4
   3b9f2:	f812 1b01 	ldrb.w	r1, [r2], #1
   3b9f6:	f803 1f01 	strb.w	r1, [r3, #1]!
   3b9fa:	79d1      	ldrb	r1, [r2, #7]
   3b9fc:	7219      	strb	r1, [r3, #8]
   3b9fe:	7bd1      	ldrb	r1, [r2, #15]
   3ba00:	7459      	strb	r1, [r3, #17]
   3ba02:	7dd1      	ldrb	r1, [r2, #23]
   3ba04:	7699      	strb	r1, [r3, #26]
   3ba06:	4283      	cmp	r3, r0
   3ba08:	d1f3      	bne.n	3b9f2 <ull_readdiagnostics+0x418>
   3ba0a:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   3ba0e:	77e3      	strb	r3, [r4, #31]
   3ba10:	f89d 300f 	ldrb.w	r3, [sp, #15]
   3ba14:	7163      	strb	r3, [r4, #5]
   3ba16:	f89d 200e 	ldrb.w	r2, [sp, #14]
   3ba1a:	f89d 300d 	ldrb.w	r3, [sp, #13]
   3ba1e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ba22:	80e3      	strh	r3, [r4, #6]
   3ba24:	f89d 3016 	ldrb.w	r3, [sp, #22]
   3ba28:	f89d 2017 	ldrb.w	r2, [sp, #23]
   3ba2c:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
   3ba30:	f3c2 12cf 	ubfx	r2, r2, #7, #16
   3ba34:	f8a4 200d 	strh.w	r2, [r4, #13]
   3ba38:	f89d 2015 	ldrb.w	r2, [sp, #21]
   3ba3c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   3ba40:	f8a4 200f 	strh.w	r2, [r4, #15]
   3ba44:	f89d 201f 	ldrb.w	r2, [sp, #31]
   3ba48:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ba4c:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3ba50:	82e3      	strh	r3, [r4, #22]
   3ba52:	f89d 201e 	ldrb.w	r2, [sp, #30]
   3ba56:	f89d 301d 	ldrb.w	r3, [sp, #29]
   3ba5a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ba5e:	8323      	strh	r3, [r4, #24]
   3ba60:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   3ba64:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   3ba68:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ba6c:	f3c3 030d 	ubfx	r3, r3, #0, #14
   3ba70:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   3ba74:	bf1c      	itt	ne
   3ba76:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   3ba7a:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   3ba7e:	8423      	strh	r3, [r4, #32]
   3ba80:	f89d 2029 	ldrb.w	r2, [sp, #41]	; 0x29
   3ba84:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   3ba88:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ba8c:	f3c3 030c 	ubfx	r3, r3, #0, #13
   3ba90:	8463      	strh	r3, [r4, #34]	; 0x22
   3ba92:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   3ba96:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
   3ba9a:	041b      	lsls	r3, r3, #16
   3ba9c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3baa0:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   3baa4:	4313      	orrs	r3, r2
   3baa6:	f89d 202d 	ldrb.w	r2, [sp, #45]	; 0x2d
   3baaa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3baae:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   3bab2:	6263      	str	r3, [r4, #36]	; 0x24
   3bab4:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3bab6:	7d9b      	ldrb	r3, [r3, #22]
   3bab8:	f013 0f01 	tst.w	r3, #1
   3babc:	f43f af75 	beq.w	3b9aa <ull_readdiagnostics+0x3d0>
   3bac0:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
   3bac4:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   3bac8:	041b      	lsls	r3, r3, #16
   3baca:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bace:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   3bad2:	4313      	orrs	r3, r2
   3bad4:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   3bad8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3badc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3bae0:	62a3      	str	r3, [r4, #40]	; 0x28
   3bae2:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   3bae6:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   3baea:	041b      	lsls	r3, r3, #16
   3baec:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3baf0:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
   3baf4:	4313      	orrs	r3, r2
   3baf6:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
   3bafa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bafe:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3bb02:	62e3      	str	r3, [r4, #44]	; 0x2c
   3bb04:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   3bb08:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
   3bb0c:	041b      	lsls	r3, r3, #16
   3bb0e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bb12:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
   3bb16:	4313      	orrs	r3, r2
   3bb18:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
   3bb1c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bb20:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bb24:	6323      	str	r3, [r4, #48]	; 0x30
   3bb26:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   3bb2a:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   3bb2e:	041b      	lsls	r3, r3, #16
   3bb30:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bb34:	f89d 203c 	ldrb.w	r2, [sp, #60]	; 0x3c
   3bb38:	4313      	orrs	r3, r2
   3bb3a:	f89d 203d 	ldrb.w	r2, [sp, #61]	; 0x3d
   3bb3e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bb42:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bb46:	6363      	str	r3, [r4, #52]	; 0x34
   3bb48:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   3bb4c:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   3bb50:	041b      	lsls	r3, r3, #16
   3bb52:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bb56:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   3bb5a:	4313      	orrs	r3, r2
   3bb5c:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   3bb60:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bb64:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bb68:	63a3      	str	r3, [r4, #56]	; 0x38
   3bb6a:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   3bb6e:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
   3bb72:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bb76:	87a3      	strh	r3, [r4, #60]	; 0x3c
   3bb78:	f89d 2061 	ldrb.w	r2, [sp, #97]	; 0x61
   3bb7c:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
   3bb80:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bb84:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3bb88:	87e3      	strh	r3, [r4, #62]	; 0x3e
   3bb8a:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
   3bb8e:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
   3bb92:	041b      	lsls	r3, r3, #16
   3bb94:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bb98:	f89d 2064 	ldrb.w	r2, [sp, #100]	; 0x64
   3bb9c:	4313      	orrs	r3, r2
   3bb9e:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   3bba2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bba6:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3bbaa:	6423      	str	r3, [r4, #64]	; 0x40
   3bbac:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   3bbb0:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   3bbb4:	041b      	lsls	r3, r3, #16
   3bbb6:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bbba:	f89d 2068 	ldrb.w	r2, [sp, #104]	; 0x68
   3bbbe:	4313      	orrs	r3, r2
   3bbc0:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
   3bbc4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bbc8:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3bbcc:	6463      	str	r3, [r4, #68]	; 0x44
   3bbce:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
   3bbd2:	f89d 306e 	ldrb.w	r3, [sp, #110]	; 0x6e
   3bbd6:	041b      	lsls	r3, r3, #16
   3bbd8:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bbdc:	f89d 206c 	ldrb.w	r2, [sp, #108]	; 0x6c
   3bbe0:	4313      	orrs	r3, r2
   3bbe2:	f89d 206d 	ldrb.w	r2, [sp, #109]	; 0x6d
   3bbe6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bbea:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bbee:	64a3      	str	r3, [r4, #72]	; 0x48
   3bbf0:	f89d 2073 	ldrb.w	r2, [sp, #115]	; 0x73
   3bbf4:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
   3bbf8:	041b      	lsls	r3, r3, #16
   3bbfa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bbfe:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   3bc02:	4313      	orrs	r3, r2
   3bc04:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   3bc08:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc0c:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bc10:	64e3      	str	r3, [r4, #76]	; 0x4c
   3bc12:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   3bc16:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   3bc1a:	041b      	lsls	r3, r3, #16
   3bc1c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bc20:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   3bc24:	4313      	orrs	r3, r2
   3bc26:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   3bc2a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc2e:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bc32:	6523      	str	r3, [r4, #80]	; 0x50
   3bc34:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   3bc38:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
   3bc3c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc40:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3bc44:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   3bc48:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   3bc4c:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   3bc50:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc54:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3bc58:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   3bc5c:	f89d 20af 	ldrb.w	r2, [sp, #175]	; 0xaf
   3bc60:	f89d 30ae 	ldrb.w	r3, [sp, #174]	; 0xae
   3bc64:	041b      	lsls	r3, r3, #16
   3bc66:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bc6a:	f89d 20ac 	ldrb.w	r2, [sp, #172]	; 0xac
   3bc6e:	4313      	orrs	r3, r2
   3bc70:	f89d 20ad 	ldrb.w	r2, [sp, #173]	; 0xad
   3bc74:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc78:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3bc7c:	65a3      	str	r3, [r4, #88]	; 0x58
   3bc7e:	f89d 20b3 	ldrb.w	r2, [sp, #179]	; 0xb3
   3bc82:	f89d 30b2 	ldrb.w	r3, [sp, #178]	; 0xb2
   3bc86:	041b      	lsls	r3, r3, #16
   3bc88:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bc8c:	f89d 20b0 	ldrb.w	r2, [sp, #176]	; 0xb0
   3bc90:	4313      	orrs	r3, r2
   3bc92:	f89d 20b1 	ldrb.w	r2, [sp, #177]	; 0xb1
   3bc96:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bc9a:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3bc9e:	65e3      	str	r3, [r4, #92]	; 0x5c
   3bca0:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   3bca4:	f89d 30b6 	ldrb.w	r3, [sp, #182]	; 0xb6
   3bca8:	041b      	lsls	r3, r3, #16
   3bcaa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bcae:	f89d 20b4 	ldrb.w	r2, [sp, #180]	; 0xb4
   3bcb2:	4313      	orrs	r3, r2
   3bcb4:	f89d 20b5 	ldrb.w	r2, [sp, #181]	; 0xb5
   3bcb8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bcbc:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bcc0:	6623      	str	r3, [r4, #96]	; 0x60
   3bcc2:	f89d 20bb 	ldrb.w	r2, [sp, #187]	; 0xbb
   3bcc6:	f89d 30ba 	ldrb.w	r3, [sp, #186]	; 0xba
   3bcca:	041b      	lsls	r3, r3, #16
   3bccc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bcd0:	f89d 20b8 	ldrb.w	r2, [sp, #184]	; 0xb8
   3bcd4:	4313      	orrs	r3, r2
   3bcd6:	f89d 20b9 	ldrb.w	r2, [sp, #185]	; 0xb9
   3bcda:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bcde:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bce2:	6663      	str	r3, [r4, #100]	; 0x64
   3bce4:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   3bce8:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   3bcec:	041b      	lsls	r3, r3, #16
   3bcee:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3bcf2:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   3bcf6:	4313      	orrs	r3, r2
   3bcf8:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   3bcfc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bd00:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3bd04:	66a3      	str	r3, [r4, #104]	; 0x68
   3bd06:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   3bd0a:	f89d 30cc 	ldrb.w	r3, [sp, #204]	; 0xcc
   3bd0e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bd12:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3bd16:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   3bd1a:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   3bd1e:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   3bd22:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3bd26:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3bd2a:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   3bd2e:	e63c      	b.n	3b9aa <ull_readdiagnostics+0x3d0>
   3bd30:	ab02      	add	r3, sp, #8
   3bd32:	9300      	str	r3, [sp, #0]
   3bd34:	2328      	movs	r3, #40	; 0x28
   3bd36:	2200      	movs	r2, #0
   3bd38:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   3bd3c:	f7ff fc0d 	bl	3b55a <dwt_readfromdevice>
   3bd40:	e654      	b.n	3b9ec <ull_readdiagnostics+0x412>
	...

0003bd44 <ull_readrxtimestamp>:
   3bd44:	b500      	push	{lr}
   3bd46:	b083      	sub	sp, #12
   3bd48:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3bd4a:	7b9b      	ldrb	r3, [r3, #14]
   3bd4c:	2b01      	cmp	r3, #1
   3bd4e:	d00b      	beq.n	3bd68 <ull_readrxtimestamp+0x24>
   3bd50:	2b03      	cmp	r3, #3
   3bd52:	d110      	bne.n	3bd76 <ull_readrxtimestamp+0x32>
   3bd54:	9100      	str	r1, [sp, #0]
   3bd56:	2305      	movs	r3, #5
   3bd58:	2204      	movs	r2, #4
   3bd5a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3bd5e:	f7ff fbfc 	bl	3b55a <dwt_readfromdevice>
   3bd62:	b003      	add	sp, #12
   3bd64:	f85d fb04 	ldr.w	pc, [sp], #4
   3bd68:	9100      	str	r1, [sp, #0]
   3bd6a:	2305      	movs	r3, #5
   3bd6c:	2200      	movs	r2, #0
   3bd6e:	4905      	ldr	r1, [pc, #20]	; (3bd84 <ull_readrxtimestamp+0x40>)
   3bd70:	f7ff fbf3 	bl	3b55a <dwt_readfromdevice>
   3bd74:	e7f5      	b.n	3bd62 <ull_readrxtimestamp+0x1e>
   3bd76:	9100      	str	r1, [sp, #0]
   3bd78:	2305      	movs	r3, #5
   3bd7a:	2200      	movs	r2, #0
   3bd7c:	2160      	movs	r1, #96	; 0x60
   3bd7e:	f7ff fbec 	bl	3b55a <dwt_readfromdevice>
   3bd82:	e7ee      	b.n	3bd62 <ull_readrxtimestamp+0x1e>
   3bd84:	00180004 	.word	0x00180004

0003bd88 <dwt_writetodevice>:
   3bd88:	b510      	push	{r4, lr}
   3bd8a:	b082      	sub	sp, #8
   3bd8c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
   3bd90:	9401      	str	r4, [sp, #4]
   3bd92:	9c04      	ldr	r4, [sp, #16]
   3bd94:	9400      	str	r4, [sp, #0]
   3bd96:	f7ff fb62 	bl	3b45e <dwt_xfer3xxx>
   3bd9a:	b002      	add	sp, #8
   3bd9c:	bd10      	pop	{r4, pc}

0003bd9e <dwt_write16bitoffsetreg>:
   3bd9e:	b500      	push	{lr}
   3bda0:	b085      	sub	sp, #20
   3bda2:	f88d 300c 	strb.w	r3, [sp, #12]
   3bda6:	0a1b      	lsrs	r3, r3, #8
   3bda8:	f88d 300d 	strb.w	r3, [sp, #13]
   3bdac:	ab03      	add	r3, sp, #12
   3bdae:	9300      	str	r3, [sp, #0]
   3bdb0:	2302      	movs	r3, #2
   3bdb2:	b292      	uxth	r2, r2
   3bdb4:	f7ff ffe8 	bl	3bd88 <dwt_writetodevice>
   3bdb8:	b005      	add	sp, #20
   3bdba:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0003bdc0 <ull_force_clocks>:
   3bdc0:	b508      	push	{r3, lr}
   3bdc2:	2901      	cmp	r1, #1
   3bdc4:	d002      	beq.n	3bdcc <ull_force_clocks+0xc>
   3bdc6:	2905      	cmp	r1, #5
   3bdc8:	d007      	beq.n	3bdda <ull_force_clocks+0x1a>
   3bdca:	bd08      	pop	{r3, pc}
   3bdcc:	f641 0322 	movw	r3, #6178	; 0x1822
   3bdd0:	2200      	movs	r2, #0
   3bdd2:	4905      	ldr	r1, [pc, #20]	; (3bde8 <ull_force_clocks+0x28>)
   3bdd4:	f7ff ffe3 	bl	3bd9e <dwt_write16bitoffsetreg>
   3bdd8:	e7f7      	b.n	3bdca <ull_force_clocks+0xa>
   3bdda:	f44f 7300 	mov.w	r3, #512	; 0x200
   3bdde:	2200      	movs	r2, #0
   3bde0:	4901      	ldr	r1, [pc, #4]	; (3bde8 <ull_force_clocks+0x28>)
   3bde2:	f7ff ffdc 	bl	3bd9e <dwt_write16bitoffsetreg>
   3bde6:	e7f0      	b.n	3bdca <ull_force_clocks+0xa>
   3bde8:	00110004 	.word	0x00110004

0003bdec <__dwt_otp_write_wdata_id_reg>:
   3bdec:	b538      	push	{r3, r4, r5, lr}
   3bdee:	4605      	mov	r5, r0
   3bdf0:	460c      	mov	r4, r1
   3bdf2:	f441 7300 	orr.w	r3, r1, #512	; 0x200
   3bdf6:	b29b      	uxth	r3, r3
   3bdf8:	2200      	movs	r2, #0
   3bdfa:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3bdfe:	f7ff ffce 	bl	3bd9e <dwt_write16bitoffsetreg>
   3be02:	b2a3      	uxth	r3, r4
   3be04:	2200      	movs	r2, #0
   3be06:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3be0a:	4628      	mov	r0, r5
   3be0c:	f7ff ffc7 	bl	3bd9e <dwt_write16bitoffsetreg>
   3be10:	bd38      	pop	{r3, r4, r5, pc}
	...

0003be14 <_dwt_otpread>:
   3be14:	b570      	push	{r4, r5, r6, lr}
   3be16:	4604      	mov	r4, r0
   3be18:	460e      	mov	r6, r1
   3be1a:	4d0c      	ldr	r5, [pc, #48]	; (3be4c <_dwt_otpread+0x38>)
   3be1c:	2301      	movs	r3, #1
   3be1e:	2200      	movs	r2, #0
   3be20:	4629      	mov	r1, r5
   3be22:	f7ff ffbc 	bl	3bd9e <dwt_write16bitoffsetreg>
   3be26:	4633      	mov	r3, r6
   3be28:	2200      	movs	r2, #0
   3be2a:	4909      	ldr	r1, [pc, #36]	; (3be50 <_dwt_otpread+0x3c>)
   3be2c:	4620      	mov	r0, r4
   3be2e:	f7ff ffb6 	bl	3bd9e <dwt_write16bitoffsetreg>
   3be32:	2302      	movs	r3, #2
   3be34:	2200      	movs	r2, #0
   3be36:	4629      	mov	r1, r5
   3be38:	4620      	mov	r0, r4
   3be3a:	f7ff ffb0 	bl	3bd9e <dwt_write16bitoffsetreg>
   3be3e:	2200      	movs	r2, #0
   3be40:	4904      	ldr	r1, [pc, #16]	; (3be54 <_dwt_otpread+0x40>)
   3be42:	4620      	mov	r0, r4
   3be44:	f7ff fb93 	bl	3b56e <dwt_read32bitoffsetreg>
   3be48:	bd70      	pop	{r4, r5, r6, pc}
   3be4a:	bf00      	nop
   3be4c:	000b0008 	.word	0x000b0008
   3be50:	000b0004 	.word	0x000b0004
   3be54:	000b0010 	.word	0x000b0010

0003be58 <dwt_write32bitoffsetreg>:
   3be58:	b510      	push	{r4, lr}
   3be5a:	b084      	sub	sp, #16
   3be5c:	f88d 300c 	strb.w	r3, [sp, #12]
   3be60:	0a1c      	lsrs	r4, r3, #8
   3be62:	f88d 400d 	strb.w	r4, [sp, #13]
   3be66:	0c1c      	lsrs	r4, r3, #16
   3be68:	f88d 400e 	strb.w	r4, [sp, #14]
   3be6c:	0e1b      	lsrs	r3, r3, #24
   3be6e:	f88d 300f 	strb.w	r3, [sp, #15]
   3be72:	ab03      	add	r3, sp, #12
   3be74:	9300      	str	r3, [sp, #0]
   3be76:	2304      	movs	r3, #4
   3be78:	b292      	uxth	r2, r2
   3be7a:	f7ff ff85 	bl	3bd88 <dwt_writetodevice>
   3be7e:	b004      	add	sp, #16
   3be80:	bd10      	pop	{r4, pc}

0003be82 <_dwt_adjust_delaytime>:
   3be82:	b538      	push	{r3, r4, r5, lr}
   3be84:	4604      	mov	r4, r0
   3be86:	b989      	cbnz	r1, 3beac <_dwt_adjust_delaytime+0x2a>
   3be88:	2200      	movs	r2, #0
   3be8a:	2128      	movs	r1, #40	; 0x28
   3be8c:	f7ff fb6f 	bl	3b56e <dwt_read32bitoffsetreg>
   3be90:	4605      	mov	r5, r0
   3be92:	2201      	movs	r2, #1
   3be94:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3be98:	4620      	mov	r0, r4
   3be9a:	f7ff fb90 	bl	3b5be <dwt_read8bitoffsetreg>
   3be9e:	1a2b      	subs	r3, r5, r0
   3bea0:	2200      	movs	r2, #0
   3bea2:	2128      	movs	r1, #40	; 0x28
   3bea4:	4620      	mov	r0, r4
   3bea6:	f7ff ffd7 	bl	3be58 <dwt_write32bitoffsetreg>
   3beaa:	bd38      	pop	{r3, r4, r5, pc}
   3beac:	2200      	movs	r2, #0
   3beae:	2128      	movs	r1, #40	; 0x28
   3beb0:	f7ff fb5d 	bl	3b56e <dwt_read32bitoffsetreg>
   3beb4:	4605      	mov	r5, r0
   3beb6:	2201      	movs	r2, #1
   3beb8:	217c      	movs	r1, #124	; 0x7c
   3beba:	4620      	mov	r0, r4
   3bebc:	f7ff fb7f 	bl	3b5be <dwt_read8bitoffsetreg>
   3bec0:	1a2b      	subs	r3, r5, r0
   3bec2:	2200      	movs	r2, #0
   3bec4:	2128      	movs	r1, #40	; 0x28
   3bec6:	4620      	mov	r0, r4
   3bec8:	f7ff ffc6 	bl	3be58 <dwt_write32bitoffsetreg>
   3becc:	e7ed      	b.n	3beaa <_dwt_adjust_delaytime+0x28>

0003bece <ull_setrxaftertxdelay>:
   3bece:	b538      	push	{r3, r4, r5, lr}
   3bed0:	4605      	mov	r5, r0
   3bed2:	460c      	mov	r4, r1
   3bed4:	2200      	movs	r2, #0
   3bed6:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   3beda:	f7ff fb48 	bl	3b56e <dwt_read32bitoffsetreg>
   3bede:	0d00      	lsrs	r0, r0, #20
   3bee0:	0500      	lsls	r0, r0, #20
   3bee2:	f3c4 0313 	ubfx	r3, r4, #0, #20
   3bee6:	4303      	orrs	r3, r0
   3bee8:	2200      	movs	r2, #0
   3beea:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   3beee:	4628      	mov	r0, r5
   3bef0:	f7ff ffb2 	bl	3be58 <dwt_write32bitoffsetreg>
   3bef4:	bd38      	pop	{r3, r4, r5, pc}

0003bef6 <ull_setlnapamode>:
   3bef6:	b538      	push	{r3, r4, r5, lr}
   3bef8:	4605      	mov	r5, r0
   3befa:	460c      	mov	r4, r1
   3befc:	2200      	movs	r2, #0
   3befe:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3bf02:	f7ff fb34 	bl	3b56e <dwt_read32bitoffsetreg>
   3bf06:	f420 337c 	bic.w	r3, r0, #258048	; 0x3f000
   3bf0a:	f014 0f01 	tst.w	r4, #1
   3bf0e:	bf18      	it	ne
   3bf10:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
   3bf14:	f014 0f02 	tst.w	r4, #2
   3bf18:	bf18      	it	ne
   3bf1a:	f443 5300 	orrne.w	r3, r3, #8192	; 0x2000
   3bf1e:	f014 0f04 	tst.w	r4, #4
   3bf22:	bf18      	it	ne
   3bf24:	f443 3390 	orrne.w	r3, r3, #73728	; 0x12000
   3bf28:	2200      	movs	r2, #0
   3bf2a:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3bf2e:	4628      	mov	r0, r5
   3bf30:	f7ff ff92 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf34:	bd38      	pop	{r3, r4, r5, pc}
	...

0003bf38 <ull_configurestskey>:
   3bf38:	b538      	push	{r3, r4, r5, lr}
   3bf3a:	4605      	mov	r5, r0
   3bf3c:	460c      	mov	r4, r1
   3bf3e:	680b      	ldr	r3, [r1, #0]
   3bf40:	2200      	movs	r2, #0
   3bf42:	490b      	ldr	r1, [pc, #44]	; (3bf70 <ull_configurestskey+0x38>)
   3bf44:	f7ff ff88 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf48:	6863      	ldr	r3, [r4, #4]
   3bf4a:	2200      	movs	r2, #0
   3bf4c:	4909      	ldr	r1, [pc, #36]	; (3bf74 <ull_configurestskey+0x3c>)
   3bf4e:	4628      	mov	r0, r5
   3bf50:	f7ff ff82 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf54:	68a3      	ldr	r3, [r4, #8]
   3bf56:	2200      	movs	r2, #0
   3bf58:	4907      	ldr	r1, [pc, #28]	; (3bf78 <ull_configurestskey+0x40>)
   3bf5a:	4628      	mov	r0, r5
   3bf5c:	f7ff ff7c 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf60:	68e3      	ldr	r3, [r4, #12]
   3bf62:	2200      	movs	r2, #0
   3bf64:	4905      	ldr	r1, [pc, #20]	; (3bf7c <ull_configurestskey+0x44>)
   3bf66:	4628      	mov	r0, r5
   3bf68:	f7ff ff76 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf6c:	bd38      	pop	{r3, r4, r5, pc}
   3bf6e:	bf00      	nop
   3bf70:	0002000c 	.word	0x0002000c
   3bf74:	00020010 	.word	0x00020010
   3bf78:	00020014 	.word	0x00020014
   3bf7c:	00020018 	.word	0x00020018

0003bf80 <ull_configurestsiv>:
   3bf80:	b538      	push	{r3, r4, r5, lr}
   3bf82:	4605      	mov	r5, r0
   3bf84:	460c      	mov	r4, r1
   3bf86:	680b      	ldr	r3, [r1, #0]
   3bf88:	2200      	movs	r2, #0
   3bf8a:	490b      	ldr	r1, [pc, #44]	; (3bfb8 <ull_configurestsiv+0x38>)
   3bf8c:	f7ff ff64 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf90:	6863      	ldr	r3, [r4, #4]
   3bf92:	2200      	movs	r2, #0
   3bf94:	4909      	ldr	r1, [pc, #36]	; (3bfbc <ull_configurestsiv+0x3c>)
   3bf96:	4628      	mov	r0, r5
   3bf98:	f7ff ff5e 	bl	3be58 <dwt_write32bitoffsetreg>
   3bf9c:	68a3      	ldr	r3, [r4, #8]
   3bf9e:	2200      	movs	r2, #0
   3bfa0:	4907      	ldr	r1, [pc, #28]	; (3bfc0 <ull_configurestsiv+0x40>)
   3bfa2:	4628      	mov	r0, r5
   3bfa4:	f7ff ff58 	bl	3be58 <dwt_write32bitoffsetreg>
   3bfa8:	68e3      	ldr	r3, [r4, #12]
   3bfaa:	2200      	movs	r2, #0
   3bfac:	4905      	ldr	r1, [pc, #20]	; (3bfc4 <ull_configurestsiv+0x44>)
   3bfae:	4628      	mov	r0, r5
   3bfb0:	f7ff ff52 	bl	3be58 <dwt_write32bitoffsetreg>
   3bfb4:	bd38      	pop	{r3, r4, r5, pc}
   3bfb6:	bf00      	nop
   3bfb8:	0002001c 	.word	0x0002001c
   3bfbc:	00020020 	.word	0x00020020
   3bfc0:	00020024 	.word	0x00020024
   3bfc4:	00020028 	.word	0x00020028

0003bfc8 <ull_configmrxlut>:
   3bfc8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   3bfcc:	4604      	mov	r4, r0
   3bfce:	2905      	cmp	r1, #5
   3bfd0:	d03a      	beq.n	3c048 <ull_configmrxlut+0x80>
   3bfd2:	4d23      	ldr	r5, [pc, #140]	; (3c060 <ull_configmrxlut+0x98>)
   3bfd4:	462e      	mov	r6, r5
   3bfd6:	4f23      	ldr	r7, [pc, #140]	; (3c064 <ull_configmrxlut+0x9c>)
   3bfd8:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 3c0a0 <ull_configmrxlut+0xd8>
   3bfdc:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 3c0a4 <ull_configmrxlut+0xdc>
   3bfe0:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 3c0a8 <ull_configmrxlut+0xe0>
   3bfe4:	4b20      	ldr	r3, [pc, #128]	; (3c068 <ull_configmrxlut+0xa0>)
   3bfe6:	2200      	movs	r2, #0
   3bfe8:	4920      	ldr	r1, [pc, #128]	; (3c06c <ull_configmrxlut+0xa4>)
   3bfea:	4620      	mov	r0, r4
   3bfec:	f7ff ff34 	bl	3be58 <dwt_write32bitoffsetreg>
   3bff0:	4653      	mov	r3, sl
   3bff2:	2200      	movs	r2, #0
   3bff4:	491e      	ldr	r1, [pc, #120]	; (3c070 <ull_configmrxlut+0xa8>)
   3bff6:	4620      	mov	r0, r4
   3bff8:	f7ff ff2e 	bl	3be58 <dwt_write32bitoffsetreg>
   3bffc:	464b      	mov	r3, r9
   3bffe:	2200      	movs	r2, #0
   3c000:	491c      	ldr	r1, [pc, #112]	; (3c074 <ull_configmrxlut+0xac>)
   3c002:	4620      	mov	r0, r4
   3c004:	f7ff ff28 	bl	3be58 <dwt_write32bitoffsetreg>
   3c008:	4643      	mov	r3, r8
   3c00a:	2200      	movs	r2, #0
   3c00c:	491a      	ldr	r1, [pc, #104]	; (3c078 <ull_configmrxlut+0xb0>)
   3c00e:	4620      	mov	r0, r4
   3c010:	f7ff ff22 	bl	3be58 <dwt_write32bitoffsetreg>
   3c014:	463b      	mov	r3, r7
   3c016:	2200      	movs	r2, #0
   3c018:	4918      	ldr	r1, [pc, #96]	; (3c07c <ull_configmrxlut+0xb4>)
   3c01a:	4620      	mov	r0, r4
   3c01c:	f7ff ff1c 	bl	3be58 <dwt_write32bitoffsetreg>
   3c020:	4633      	mov	r3, r6
   3c022:	2200      	movs	r2, #0
   3c024:	4916      	ldr	r1, [pc, #88]	; (3c080 <ull_configmrxlut+0xb8>)
   3c026:	4620      	mov	r0, r4
   3c028:	f7ff ff16 	bl	3be58 <dwt_write32bitoffsetreg>
   3c02c:	462b      	mov	r3, r5
   3c02e:	2200      	movs	r2, #0
   3c030:	4914      	ldr	r1, [pc, #80]	; (3c084 <ull_configmrxlut+0xbc>)
   3c032:	4620      	mov	r0, r4
   3c034:	f7ff ff10 	bl	3be58 <dwt_write32bitoffsetreg>
   3c038:	4b13      	ldr	r3, [pc, #76]	; (3c088 <ull_configmrxlut+0xc0>)
   3c03a:	2200      	movs	r2, #0
   3c03c:	4913      	ldr	r1, [pc, #76]	; (3c08c <ull_configmrxlut+0xc4>)
   3c03e:	4620      	mov	r0, r4
   3c040:	f7ff ff0a 	bl	3be58 <dwt_write32bitoffsetreg>
   3c044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   3c048:	4d11      	ldr	r5, [pc, #68]	; (3c090 <ull_configmrxlut+0xc8>)
   3c04a:	4e12      	ldr	r6, [pc, #72]	; (3c094 <ull_configmrxlut+0xcc>)
   3c04c:	4f12      	ldr	r7, [pc, #72]	; (3c098 <ull_configmrxlut+0xd0>)
   3c04e:	f8df 805c 	ldr.w	r8, [pc, #92]	; 3c0ac <ull_configmrxlut+0xe4>
   3c052:	f8df 905c 	ldr.w	r9, [pc, #92]	; 3c0b0 <ull_configmrxlut+0xe8>
   3c056:	f8df a05c 	ldr.w	sl, [pc, #92]	; 3c0b4 <ull_configmrxlut+0xec>
   3c05a:	4b10      	ldr	r3, [pc, #64]	; (3c09c <ull_configmrxlut+0xd4>)
   3c05c:	e7c3      	b.n	3bfe6 <ull_configmrxlut+0x1e>
   3c05e:	bf00      	nop
   3c060:	0002afb5 	.word	0x0002afb5
   3c064:	0002af7d 	.word	0x0002af7d
   3c068:	0002a8fe 	.word	0x0002a8fe
   3c06c:	00030038 	.word	0x00030038
   3c070:	0003003c 	.word	0x0003003c
   3c074:	00030040 	.word	0x00030040
   3c078:	00030044 	.word	0x00030044
   3c07c:	00030048 	.word	0x00030048
   3c080:	0003004c 	.word	0x0003004c
   3c084:	00030050 	.word	0x00030050
   3c088:	10000240 	.word	0x10000240
   3c08c:	0003001c 	.word	0x0003001c
   3c090:	0001cff5 	.word	0x0001cff5
   3c094:	0001cfb5 	.word	0x0001cfb5
   3c098:	0001cf36 	.word	0x0001cf36
   3c09c:	0001c0fd 	.word	0x0001c0fd
   3c0a0:	0002af3e 	.word	0x0002af3e
   3c0a4:	0002a5fe 	.word	0x0002a5fe
   3c0a8:	0002ac36 	.word	0x0002ac36
   3c0ac:	0001c77e 	.word	0x0001c77e
   3c0b0:	0001c6be 	.word	0x0001c6be
   3c0b4:	0001c43e 	.word	0x0001c43e

0003c0b8 <ull_disable_rftx_blocks>:
   3c0b8:	b508      	push	{r3, lr}
   3c0ba:	2300      	movs	r3, #0
   3c0bc:	461a      	mov	r2, r3
   3c0be:	4902      	ldr	r1, [pc, #8]	; (3c0c8 <ull_disable_rftx_blocks+0x10>)
   3c0c0:	f7ff feca 	bl	3be58 <dwt_write32bitoffsetreg>
   3c0c4:	bd08      	pop	{r3, pc}
   3c0c6:	bf00      	nop
   3c0c8:	00070004 	.word	0x00070004

0003c0cc <ull_disable_rf_tx>:
   3c0cc:	b538      	push	{r3, r4, r5, lr}
   3c0ce:	4604      	mov	r4, r0
   3c0d0:	460d      	mov	r5, r1
   3c0d2:	2300      	movs	r3, #0
   3c0d4:	461a      	mov	r2, r3
   3c0d6:	490a      	ldr	r1, [pc, #40]	; (3c100 <ull_disable_rf_tx+0x34>)
   3c0d8:	f7ff febe 	bl	3be58 <dwt_write32bitoffsetreg>
   3c0dc:	2300      	movs	r3, #0
   3c0de:	461a      	mov	r2, r3
   3c0e0:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   3c0e4:	4620      	mov	r0, r4
   3c0e6:	f7ff feb7 	bl	3be58 <dwt_write32bitoffsetreg>
   3c0ea:	b905      	cbnz	r5, 3c0ee <ull_disable_rf_tx+0x22>
   3c0ec:	bd38      	pop	{r3, r4, r5, pc}
   3c0ee:	f04f 53e0 	mov.w	r3, #469762048	; 0x1c000000
   3c0f2:	2200      	movs	r2, #0
   3c0f4:	4903      	ldr	r1, [pc, #12]	; (3c104 <ull_disable_rf_tx+0x38>)
   3c0f6:	4620      	mov	r0, r4
   3c0f8:	f7ff feae 	bl	3be58 <dwt_write32bitoffsetreg>
   3c0fc:	e7f6      	b.n	3c0ec <ull_disable_rf_tx+0x20>
   3c0fe:	bf00      	nop
   3c100:	00070048 	.word	0x00070048
   3c104:	00070014 	.word	0x00070014

0003c108 <ull_readrxdata>:
   3c108:	b5f0      	push	{r4, r5, r6, r7, lr}
   3c10a:	b083      	sub	sp, #12
   3c10c:	6d04      	ldr	r4, [r0, #80]	; 0x50
   3c10e:	7ba4      	ldrb	r4, [r4, #14]
   3c110:	2c03      	cmp	r4, #3
   3c112:	bf0c      	ite	eq
   3c114:	f44f 1c98 	moveq.w	ip, #1245184	; 0x130000
   3c118:	f44f 1c90 	movne.w	ip, #1179648	; 0x120000
   3c11c:	189c      	adds	r4, r3, r2
   3c11e:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   3c122:	da19      	bge.n	3c158 <ull_readrxdata+0x50>
   3c124:	461d      	mov	r5, r3
   3c126:	4616      	mov	r6, r2
   3c128:	460f      	mov	r7, r1
   3c12a:	4604      	mov	r4, r0
   3c12c:	2b7f      	cmp	r3, #127	; 0x7f
   3c12e:	d915      	bls.n	3c15c <ull_readrxdata+0x54>
   3c130:	ea4f 431c 	mov.w	r3, ip, lsr #16
   3c134:	2200      	movs	r2, #0
   3c136:	490d      	ldr	r1, [pc, #52]	; (3c16c <ull_readrxdata+0x64>)
   3c138:	f7ff fe8e 	bl	3be58 <dwt_write32bitoffsetreg>
   3c13c:	462b      	mov	r3, r5
   3c13e:	2200      	movs	r2, #0
   3c140:	490b      	ldr	r1, [pc, #44]	; (3c170 <ull_readrxdata+0x68>)
   3c142:	4620      	mov	r0, r4
   3c144:	f7ff fe88 	bl	3be58 <dwt_write32bitoffsetreg>
   3c148:	9700      	str	r7, [sp, #0]
   3c14a:	4633      	mov	r3, r6
   3c14c:	2200      	movs	r2, #0
   3c14e:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3c152:	4620      	mov	r0, r4
   3c154:	f7ff fa01 	bl	3b55a <dwt_readfromdevice>
   3c158:	b003      	add	sp, #12
   3c15a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3c15c:	9100      	str	r1, [sp, #0]
   3c15e:	4613      	mov	r3, r2
   3c160:	462a      	mov	r2, r5
   3c162:	4661      	mov	r1, ip
   3c164:	f7ff f9f9 	bl	3b55a <dwt_readfromdevice>
   3c168:	e7f6      	b.n	3c158 <ull_readrxdata+0x50>
   3c16a:	bf00      	nop
   3c16c:	001f0004 	.word	0x001f0004
   3c170:	001f0008 	.word	0x001f0008

0003c174 <dwt_write8bitoffsetreg>:
   3c174:	b510      	push	{r4, lr}
   3c176:	b084      	sub	sp, #16
   3c178:	ac04      	add	r4, sp, #16
   3c17a:	f804 3d01 	strb.w	r3, [r4, #-1]!
   3c17e:	9400      	str	r4, [sp, #0]
   3c180:	2301      	movs	r3, #1
   3c182:	b292      	uxth	r2, r2
   3c184:	f7ff fe00 	bl	3bd88 <dwt_writetodevice>
   3c188:	b004      	add	sp, #16
   3c18a:	bd10      	pop	{r4, pc}

0003c18c <ull_getframelength>:
   3c18c:	b510      	push	{r4, lr}
   3c18e:	4604      	mov	r4, r0
   3c190:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3c192:	7b9b      	ldrb	r3, [r3, #14]
   3c194:	2b01      	cmp	r3, #1
   3c196:	d013      	beq.n	3c1c0 <ull_getframelength+0x34>
   3c198:	2b03      	cmp	r3, #3
   3c19a:	d11d      	bne.n	3c1d8 <ull_getframelength+0x4c>
   3c19c:	23f0      	movs	r3, #240	; 0xf0
   3c19e:	2200      	movs	r2, #0
   3c1a0:	4912      	ldr	r1, [pc, #72]	; (3c1ec <ull_getframelength+0x60>)
   3c1a2:	f7ff ffe7 	bl	3c174 <dwt_write8bitoffsetreg>
   3c1a6:	2200      	movs	r2, #0
   3c1a8:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3c1ac:	4620      	mov	r0, r4
   3c1ae:	f7ff f9f4 	bl	3b59a <dwt_read16bitoffsetreg>
   3c1b2:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c1b4:	7ada      	ldrb	r2, [r3, #11]
   3c1b6:	b1a2      	cbz	r2, 3c1e2 <ull_getframelength+0x56>
   3c1b8:	f3c0 0009 	ubfx	r0, r0, #0, #10
   3c1bc:	83d8      	strh	r0, [r3, #30]
   3c1be:	bd10      	pop	{r4, pc}
   3c1c0:	230f      	movs	r3, #15
   3c1c2:	2200      	movs	r2, #0
   3c1c4:	4909      	ldr	r1, [pc, #36]	; (3c1ec <ull_getframelength+0x60>)
   3c1c6:	f7ff ffd5 	bl	3c174 <dwt_write8bitoffsetreg>
   3c1ca:	2200      	movs	r2, #0
   3c1cc:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   3c1d0:	4620      	mov	r0, r4
   3c1d2:	f7ff f9e2 	bl	3b59a <dwt_read16bitoffsetreg>
   3c1d6:	e7ec      	b.n	3c1b2 <ull_getframelength+0x26>
   3c1d8:	2200      	movs	r2, #0
   3c1da:	214c      	movs	r1, #76	; 0x4c
   3c1dc:	f7ff f9dd 	bl	3b59a <dwt_read16bitoffsetreg>
   3c1e0:	e7e7      	b.n	3c1b2 <ull_getframelength+0x26>
   3c1e2:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   3c1e6:	83d8      	strh	r0, [r3, #30]
   3c1e8:	e7e9      	b.n	3c1be <ull_getframelength+0x32>
   3c1ea:	bf00      	nop
   3c1ec:	00010018 	.word	0x00010018

0003c1f0 <_dwt_clear_db_events>:
   3c1f0:	b510      	push	{r4, lr}
   3c1f2:	4604      	mov	r4, r0
   3c1f4:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3c1f6:	7b9b      	ldrb	r3, [r3, #14]
   3c1f8:	2b01      	cmp	r3, #1
   3c1fa:	d004      	beq.n	3c206 <_dwt_clear_db_events+0x16>
   3c1fc:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c1fe:	7b9b      	ldrb	r3, [r3, #14]
   3c200:	2b03      	cmp	r3, #3
   3c202:	d006      	beq.n	3c212 <_dwt_clear_db_events+0x22>
   3c204:	bd10      	pop	{r4, pc}
   3c206:	230f      	movs	r3, #15
   3c208:	2200      	movs	r2, #0
   3c20a:	4905      	ldr	r1, [pc, #20]	; (3c220 <_dwt_clear_db_events+0x30>)
   3c20c:	f7ff ffb2 	bl	3c174 <dwt_write8bitoffsetreg>
   3c210:	e7f4      	b.n	3c1fc <_dwt_clear_db_events+0xc>
   3c212:	23f0      	movs	r3, #240	; 0xf0
   3c214:	2200      	movs	r2, #0
   3c216:	4902      	ldr	r1, [pc, #8]	; (3c220 <_dwt_clear_db_events+0x30>)
   3c218:	4620      	mov	r0, r4
   3c21a:	f7ff ffab 	bl	3c174 <dwt_write8bitoffsetreg>
   3c21e:	e7f1      	b.n	3c204 <_dwt_clear_db_events+0x14>
   3c220:	00010018 	.word	0x00010018

0003c224 <ull_clearaonconfig>:
   3c224:	b538      	push	{r3, r4, r5, lr}
   3c226:	4604      	mov	r4, r0
   3c228:	2300      	movs	r3, #0
   3c22a:	461a      	mov	r2, r3
   3c22c:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   3c230:	f7ff fdb5 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c234:	2300      	movs	r3, #0
   3c236:	461a      	mov	r2, r3
   3c238:	4908      	ldr	r1, [pc, #32]	; (3c25c <ull_clearaonconfig+0x38>)
   3c23a:	4620      	mov	r0, r4
   3c23c:	f7ff ff9a 	bl	3c174 <dwt_write8bitoffsetreg>
   3c240:	4d07      	ldr	r5, [pc, #28]	; (3c260 <ull_clearaonconfig+0x3c>)
   3c242:	2300      	movs	r3, #0
   3c244:	461a      	mov	r2, r3
   3c246:	4629      	mov	r1, r5
   3c248:	4620      	mov	r0, r4
   3c24a:	f7ff ff93 	bl	3c174 <dwt_write8bitoffsetreg>
   3c24e:	2302      	movs	r3, #2
   3c250:	2200      	movs	r2, #0
   3c252:	4629      	mov	r1, r5
   3c254:	4620      	mov	r0, r4
   3c256:	f7ff ff8d 	bl	3c174 <dwt_write8bitoffsetreg>
   3c25a:	bd38      	pop	{r3, r4, r5, pc}
   3c25c:	000a0014 	.word	0x000a0014
   3c260:	000a0004 	.word	0x000a0004

0003c264 <ull_configeventcounters>:
   3c264:	b538      	push	{r3, r4, r5, lr}
   3c266:	4605      	mov	r5, r0
   3c268:	460c      	mov	r4, r1
   3c26a:	2302      	movs	r3, #2
   3c26c:	2200      	movs	r2, #0
   3c26e:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   3c272:	f7ff ff7f 	bl	3c174 <dwt_write8bitoffsetreg>
   3c276:	b904      	cbnz	r4, 3c27a <ull_configeventcounters+0x16>
   3c278:	bd38      	pop	{r3, r4, r5, pc}
   3c27a:	2301      	movs	r3, #1
   3c27c:	2200      	movs	r2, #0
   3c27e:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   3c282:	4628      	mov	r0, r5
   3c284:	f7ff ff76 	bl	3c174 <dwt_write8bitoffsetreg>
   3c288:	e7f6      	b.n	3c278 <ull_configeventcounters+0x14>
	...

0003c28c <ull_aon_read>:
   3c28c:	b538      	push	{r3, r4, r5, lr}
   3c28e:	4604      	mov	r4, r0
   3c290:	460b      	mov	r3, r1
   3c292:	2200      	movs	r2, #0
   3c294:	490a      	ldr	r1, [pc, #40]	; (3c2c0 <ull_aon_read+0x34>)
   3c296:	f7ff fd82 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c29a:	4d0a      	ldr	r5, [pc, #40]	; (3c2c4 <ull_aon_read+0x38>)
   3c29c:	2388      	movs	r3, #136	; 0x88
   3c29e:	2200      	movs	r2, #0
   3c2a0:	4629      	mov	r1, r5
   3c2a2:	4620      	mov	r0, r4
   3c2a4:	f7ff ff66 	bl	3c174 <dwt_write8bitoffsetreg>
   3c2a8:	2300      	movs	r3, #0
   3c2aa:	461a      	mov	r2, r3
   3c2ac:	4629      	mov	r1, r5
   3c2ae:	4620      	mov	r0, r4
   3c2b0:	f7ff ff60 	bl	3c174 <dwt_write8bitoffsetreg>
   3c2b4:	2200      	movs	r2, #0
   3c2b6:	4904      	ldr	r1, [pc, #16]	; (3c2c8 <ull_aon_read+0x3c>)
   3c2b8:	4620      	mov	r0, r4
   3c2ba:	f7ff f980 	bl	3b5be <dwt_read8bitoffsetreg>
   3c2be:	bd38      	pop	{r3, r4, r5, pc}
   3c2c0:	000a000c 	.word	0x000a000c
   3c2c4:	000a0004 	.word	0x000a0004
   3c2c8:	000a0008 	.word	0x000a0008

0003c2cc <ull_aon_write>:
   3c2cc:	b570      	push	{r4, r5, r6, lr}
   3c2ce:	4604      	mov	r4, r0
   3c2d0:	460b      	mov	r3, r1
   3c2d2:	4615      	mov	r5, r2
   3c2d4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   3c2d8:	bf34      	ite	cc
   3c2da:	2600      	movcc	r6, #0
   3c2dc:	2620      	movcs	r6, #32
   3c2de:	2200      	movs	r2, #0
   3c2e0:	490b      	ldr	r1, [pc, #44]	; (3c310 <ull_aon_write+0x44>)
   3c2e2:	f7ff fd5c 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c2e6:	462b      	mov	r3, r5
   3c2e8:	2200      	movs	r2, #0
   3c2ea:	490a      	ldr	r1, [pc, #40]	; (3c314 <ull_aon_write+0x48>)
   3c2ec:	4620      	mov	r0, r4
   3c2ee:	f7ff ff41 	bl	3c174 <dwt_write8bitoffsetreg>
   3c2f2:	4d09      	ldr	r5, [pc, #36]	; (3c318 <ull_aon_write+0x4c>)
   3c2f4:	f046 0390 	orr.w	r3, r6, #144	; 0x90
   3c2f8:	2200      	movs	r2, #0
   3c2fa:	4629      	mov	r1, r5
   3c2fc:	4620      	mov	r0, r4
   3c2fe:	f7ff ff39 	bl	3c174 <dwt_write8bitoffsetreg>
   3c302:	2300      	movs	r3, #0
   3c304:	461a      	mov	r2, r3
   3c306:	4629      	mov	r1, r5
   3c308:	4620      	mov	r0, r4
   3c30a:	f7ff ff33 	bl	3c174 <dwt_write8bitoffsetreg>
   3c30e:	bd70      	pop	{r4, r5, r6, pc}
   3c310:	000a000c 	.word	0x000a000c
   3c314:	000a0010 	.word	0x000a0010
   3c318:	000a0004 	.word	0x000a0004

0003c31c <ull_configuresleep>:
   3c31c:	b570      	push	{r4, r5, r6, lr}
   3c31e:	4604      	mov	r4, r0
   3c320:	460d      	mov	r5, r1
   3c322:	4616      	mov	r6, r2
   3c324:	2200      	movs	r2, #0
   3c326:	f240 110b 	movw	r1, #267	; 0x10b
   3c32a:	f7ff ffcf 	bl	3c2cc <ull_aon_write>
   3c32e:	f44f 7182 	mov.w	r1, #260	; 0x104
   3c332:	4620      	mov	r0, r4
   3c334:	f7ff ffaa 	bl	3c28c <ull_aon_read>
   3c338:	f000 021f 	and.w	r2, r0, #31
   3c33c:	f44f 7182 	mov.w	r1, #260	; 0x104
   3c340:	4620      	mov	r0, r4
   3c342:	f7ff ffc3 	bl	3c2cc <ull_aon_write>
   3c346:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c348:	8a1a      	ldrh	r2, [r3, #16]
   3c34a:	4315      	orrs	r5, r2
   3c34c:	821d      	strh	r5, [r3, #16]
   3c34e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c350:	8a1b      	ldrh	r3, [r3, #16]
   3c352:	2200      	movs	r2, #0
   3c354:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   3c358:	4620      	mov	r0, r4
   3c35a:	f7ff fd20 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c35e:	4633      	mov	r3, r6
   3c360:	2200      	movs	r2, #0
   3c362:	4902      	ldr	r1, [pc, #8]	; (3c36c <ull_configuresleep+0x50>)
   3c364:	4620      	mov	r0, r4
   3c366:	f7ff ff05 	bl	3c174 <dwt_write8bitoffsetreg>
   3c36a:	bd70      	pop	{r4, r5, r6, pc}
   3c36c:	000a0014 	.word	0x000a0014

0003c370 <ull_writetxdata>:
   3c370:	b5f0      	push	{r4, r5, r6, r7, lr}
   3c372:	b083      	sub	sp, #12
   3c374:	185c      	adds	r4, r3, r1
   3c376:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   3c37a:	da24      	bge.n	3c3c6 <ull_writetxdata+0x56>
   3c37c:	461c      	mov	r4, r3
   3c37e:	4617      	mov	r7, r2
   3c380:	460e      	mov	r6, r1
   3c382:	4605      	mov	r5, r0
   3c384:	2b7f      	cmp	r3, #127	; 0x7f
   3c386:	d915      	bls.n	3c3b4 <ull_writetxdata+0x44>
   3c388:	2314      	movs	r3, #20
   3c38a:	2200      	movs	r2, #0
   3c38c:	490f      	ldr	r1, [pc, #60]	; (3c3cc <ull_writetxdata+0x5c>)
   3c38e:	f7ff fd63 	bl	3be58 <dwt_write32bitoffsetreg>
   3c392:	4623      	mov	r3, r4
   3c394:	2200      	movs	r2, #0
   3c396:	490e      	ldr	r1, [pc, #56]	; (3c3d0 <ull_writetxdata+0x60>)
   3c398:	4628      	mov	r0, r5
   3c39a:	f7ff fd5d 	bl	3be58 <dwt_write32bitoffsetreg>
   3c39e:	9700      	str	r7, [sp, #0]
   3c3a0:	4633      	mov	r3, r6
   3c3a2:	2200      	movs	r2, #0
   3c3a4:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3c3a8:	4628      	mov	r0, r5
   3c3aa:	f7ff fced 	bl	3bd88 <dwt_writetodevice>
   3c3ae:	2000      	movs	r0, #0
   3c3b0:	b003      	add	sp, #12
   3c3b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3c3b4:	9200      	str	r2, [sp, #0]
   3c3b6:	460b      	mov	r3, r1
   3c3b8:	4622      	mov	r2, r4
   3c3ba:	f44f 11a0 	mov.w	r1, #1310720	; 0x140000
   3c3be:	f7ff fce3 	bl	3bd88 <dwt_writetodevice>
   3c3c2:	2000      	movs	r0, #0
   3c3c4:	e7f4      	b.n	3c3b0 <ull_writetxdata+0x40>
   3c3c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3c3ca:	e7f1      	b.n	3c3b0 <ull_writetxdata+0x40>
   3c3cc:	001f0004 	.word	0x001f0004
   3c3d0:	001f0008 	.word	0x001f0008

0003c3d4 <ull_signal_rx_buff_free>:
   3c3d4:	b510      	push	{r4, lr}
   3c3d6:	b082      	sub	sp, #8
   3c3d8:	4604      	mov	r4, r0
   3c3da:	2302      	movs	r3, #2
   3c3dc:	9301      	str	r3, [sp, #4]
   3c3de:	2200      	movs	r2, #0
   3c3e0:	9200      	str	r2, [sp, #0]
   3c3e2:	4613      	mov	r3, r2
   3c3e4:	2113      	movs	r1, #19
   3c3e6:	f7ff f83a 	bl	3b45e <dwt_xfer3xxx>
   3c3ea:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c3ec:	7b9a      	ldrb	r2, [r3, #14]
   3c3ee:	2a03      	cmp	r2, #3
   3c3f0:	bf0c      	ite	eq
   3c3f2:	2201      	moveq	r2, #1
   3c3f4:	2203      	movne	r2, #3
   3c3f6:	739a      	strb	r2, [r3, #14]
   3c3f8:	b002      	add	sp, #8
   3c3fa:	bd10      	pop	{r4, pc}

0003c3fc <ull_isr>:
   3c3fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3c400:	4604      	mov	r4, r0
   3c402:	2200      	movs	r2, #0
   3c404:	f44f 11f8 	mov.w	r1, #2031616	; 0x1f0000
   3c408:	f7ff f8d9 	bl	3b5be <dwt_read8bitoffsetreg>
   3c40c:	4605      	mov	r5, r0
   3c40e:	2200      	movs	r2, #0
   3c410:	2144      	movs	r1, #68	; 0x44
   3c412:	4620      	mov	r0, r4
   3c414:	f7ff f8ab 	bl	3b56e <dwt_read32bitoffsetreg>
   3c418:	4606      	mov	r6, r0
   3c41a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c41c:	2200      	movs	r2, #0
   3c41e:	83da      	strh	r2, [r3, #30]
   3c420:	f883 2020 	strb.w	r2, [r3, #32]
   3c424:	619a      	str	r2, [r3, #24]
   3c426:	839a      	strh	r2, [r3, #28]
   3c428:	625a      	str	r2, [r3, #36]	; 0x24
   3c42a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c42c:	625c      	str	r4, [r3, #36]	; 0x24
   3c42e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c430:	7b9f      	ldrb	r7, [r3, #14]
   3c432:	2f00      	cmp	r7, #0
   3c434:	d17f      	bne.n	3c536 <ull_isr+0x13a>
   3c436:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c438:	619e      	str	r6, [r3, #24]
   3c43a:	f8d4 8050 	ldr.w	r8, [r4, #80]	; 0x50
   3c43e:	f898 3015 	ldrb.w	r3, [r8, #21]
   3c442:	f003 0303 	and.w	r3, r3, #3
   3c446:	2b03      	cmp	r3, #3
   3c448:	f000 8090 	beq.w	3c56c <ull_isr+0x170>
   3c44c:	f015 0f80 	tst.w	r5, #128	; 0x80
   3c450:	f040 8093 	bne.w	3c57a <ull_isr+0x17e>
   3c454:	f015 0f01 	tst.w	r5, #1
   3c458:	f040 80c1 	bne.w	3c5de <ull_isr+0x1e2>
   3c45c:	f015 0f40 	tst.w	r5, #64	; 0x40
   3c460:	d00b      	beq.n	3c47a <ull_isr+0x7e>
   3c462:	6a63      	ldr	r3, [r4, #36]	; 0x24
   3c464:	b113      	cbz	r3, 3c46c <ull_isr+0x70>
   3c466:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c468:	3018      	adds	r0, #24
   3c46a:	4798      	blx	r3
   3c46c:	f44f 73c0 	mov.w	r3, #384	; 0x180
   3c470:	2202      	movs	r2, #2
   3c472:	2144      	movs	r1, #68	; 0x44
   3c474:	4620      	mov	r0, r4
   3c476:	f7ff fc92 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c47a:	f015 0f08 	tst.w	r5, #8
   3c47e:	d107      	bne.n	3c490 <ull_isr+0x94>
   3c480:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c482:	7b9b      	ldrb	r3, [r3, #14]
   3c484:	2b00      	cmp	r3, #0
   3c486:	f000 80ea 	beq.w	3c65e <ull_isr+0x262>
   3c48a:	2f00      	cmp	r7, #0
   3c48c:	f000 80e7 	beq.w	3c65e <ull_isr+0x262>
   3c490:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c492:	2200      	movs	r2, #0
   3c494:	f883 2020 	strb.w	r2, [r3, #32]
   3c498:	f416 2f80 	tst.w	r6, #262144	; 0x40000
   3c49c:	f000 80ad 	beq.w	3c5fa <ull_isr+0x1fe>
   3c4a0:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3c4a2:	f892 3020 	ldrb.w	r3, [r2, #32]
   3c4a6:	f043 0308 	orr.w	r3, r3, #8
   3c4aa:	f882 3020 	strb.w	r3, [r2, #32]
   3c4ae:	f44f 2780 	mov.w	r7, #262144	; 0x40000
   3c4b2:	f016 5f80 	tst.w	r6, #268435456	; 0x10000000
   3c4b6:	d008      	beq.n	3c4ca <ull_isr+0xce>
   3c4b8:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3c4ba:	f892 3020 	ldrb.w	r3, [r2, #32]
   3c4be:	f043 0310 	orr.w	r3, r3, #16
   3c4c2:	f882 3020 	strb.w	r3, [r2, #32]
   3c4c6:	f047 5780 	orr.w	r7, r7, #268435456	; 0x10000000
   3c4ca:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   3c4ce:	d006      	beq.n	3c4de <ull_isr+0xe2>
   3c4d0:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3c4d2:	7d53      	ldrb	r3, [r2, #21]
   3c4d4:	f003 0303 	and.w	r3, r3, #3
   3c4d8:	2b03      	cmp	r3, #3
   3c4da:	f000 809a 	beq.w	3c612 <ull_isr+0x216>
   3c4de:	f416 4f80 	tst.w	r6, #16384	; 0x4000
   3c4e2:	f040 80a2 	bne.w	3c62a <ull_isr+0x22e>
   3c4e6:	f447 43de 	orr.w	r3, r7, #28416	; 0x6f00
   3c4ea:	2200      	movs	r2, #0
   3c4ec:	2144      	movs	r1, #68	; 0x44
   3c4ee:	4620      	mov	r0, r4
   3c4f0:	f7ff fcb2 	bl	3be58 <dwt_write32bitoffsetreg>
   3c4f4:	4620      	mov	r0, r4
   3c4f6:	f7ff fe7b 	bl	3c1f0 <_dwt_clear_db_events>
   3c4fa:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c4fc:	8bc3      	ldrh	r3, [r0, #30]
   3c4fe:	2b00      	cmp	r3, #0
   3c500:	f040 80a2 	bne.w	3c648 <ull_isr+0x24c>
   3c504:	7d43      	ldrb	r3, [r0, #21]
   3c506:	f003 0303 	and.w	r3, r3, #3
   3c50a:	2b03      	cmp	r3, #3
   3c50c:	f000 809c 	beq.w	3c648 <ull_isr+0x24c>
   3c510:	6983      	ldr	r3, [r0, #24]
   3c512:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
   3c516:	6183      	str	r3, [r0, #24]
   3c518:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3c51a:	6993      	ldr	r3, [r2, #24]
   3c51c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   3c520:	6193      	str	r3, [r2, #24]
   3c522:	69e3      	ldr	r3, [r4, #28]
   3c524:	b113      	cbz	r3, 3c52c <ull_isr+0x130>
   3c526:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c528:	3018      	adds	r0, #24
   3c52a:	4798      	blx	r3
   3c52c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c52e:	2200      	movs	r2, #0
   3c530:	f883 2020 	strb.w	r2, [r3, #32]
   3c534:	e08c      	b.n	3c650 <ull_isr+0x254>
   3c536:	496d      	ldr	r1, [pc, #436]	; (3c6ec <ull_isr+0x2f0>)
   3c538:	4620      	mov	r0, r4
   3c53a:	f7ff f840 	bl	3b5be <dwt_read8bitoffsetreg>
   3c53e:	4607      	mov	r7, r0
   3c540:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c542:	7b9b      	ldrb	r3, [r3, #14]
   3c544:	2b03      	cmp	r3, #3
   3c546:	bf08      	it	eq
   3c548:	f3c0 1707 	ubfxeq	r7, r0, #4, #8
   3c54c:	f017 0f01 	tst.w	r7, #1
   3c550:	bf18      	it	ne
   3c552:	f446 4680 	orrne.w	r6, r6, #16384	; 0x4000
   3c556:	f017 0f02 	tst.w	r7, #2
   3c55a:	bf18      	it	ne
   3c55c:	f446 5600 	orrne.w	r6, r6, #8192	; 0x2000
   3c560:	f017 0f04 	tst.w	r7, #4
   3c564:	bf18      	it	ne
   3c566:	f446 6680 	orrne.w	r6, r6, #1024	; 0x400
   3c56a:	e764      	b.n	3c436 <ull_isr+0x3a>
   3c56c:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   3c570:	bf1c      	itt	ne
   3c572:	f045 0508 	orrne.w	r5, r5, #8
   3c576:	b2ed      	uxtbne	r5, r5
   3c578:	e768      	b.n	3c44c <ull_isr+0x50>
   3c57a:	2200      	movs	r2, #0
   3c57c:	2148      	movs	r1, #72	; 0x48
   3c57e:	4620      	mov	r0, r4
   3c580:	f7ff f80b 	bl	3b59a <dwt_read16bitoffsetreg>
   3c584:	f8a8 001c 	strh.w	r0, [r8, #28]
   3c588:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c58a:	7d1a      	ldrb	r2, [r3, #20]
   3c58c:	b11a      	cbz	r2, 3c596 <ull_isr+0x19a>
   3c58e:	699a      	ldr	r2, [r3, #24]
   3c590:	f012 0f04 	tst.w	r2, #4
   3c594:	d103      	bne.n	3c59e <ull_isr+0x1a2>
   3c596:	8b9b      	ldrh	r3, [r3, #28]
   3c598:	f403 6360 	and.w	r3, r3, #3584	; 0xe00
   3c59c:	b18b      	cbz	r3, 3c5c2 <ull_isr+0x1c6>
   3c59e:	2304      	movs	r3, #4
   3c5a0:	2200      	movs	r2, #0
   3c5a2:	2144      	movs	r1, #68	; 0x44
   3c5a4:	4620      	mov	r0, r4
   3c5a6:	f7ff fde5 	bl	3c174 <dwt_write8bitoffsetreg>
   3c5aa:	f44f 6360 	mov.w	r3, #3584	; 0xe00
   3c5ae:	2200      	movs	r2, #0
   3c5b0:	2148      	movs	r1, #72	; 0x48
   3c5b2:	4620      	mov	r0, r4
   3c5b4:	f7ff fbf3 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c5b8:	6a23      	ldr	r3, [r4, #32]
   3c5ba:	b113      	cbz	r3, 3c5c2 <ull_isr+0x1c6>
   3c5bc:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c5be:	3018      	adds	r0, #24
   3c5c0:	4798      	blx	r3
   3c5c2:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c5c4:	8b9b      	ldrh	r3, [r3, #28]
   3c5c6:	f413 7f80 	tst.w	r3, #256	; 0x100
   3c5ca:	f43f af43 	beq.w	3c454 <ull_isr+0x58>
   3c5ce:	f44f 7380 	mov.w	r3, #256	; 0x100
   3c5d2:	2200      	movs	r2, #0
   3c5d4:	2148      	movs	r1, #72	; 0x48
   3c5d6:	4620      	mov	r0, r4
   3c5d8:	f7ff fbe1 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c5dc:	e73a      	b.n	3c454 <ull_isr+0x58>
   3c5de:	23f8      	movs	r3, #248	; 0xf8
   3c5e0:	2200      	movs	r2, #0
   3c5e2:	2144      	movs	r1, #68	; 0x44
   3c5e4:	4620      	mov	r0, r4
   3c5e6:	f7ff fdc5 	bl	3c174 <dwt_write8bitoffsetreg>
   3c5ea:	6923      	ldr	r3, [r4, #16]
   3c5ec:	2b00      	cmp	r3, #0
   3c5ee:	f43f af35 	beq.w	3c45c <ull_isr+0x60>
   3c5f2:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c5f4:	3018      	adds	r0, #24
   3c5f6:	4798      	blx	r3
   3c5f8:	e730      	b.n	3c45c <ull_isr+0x60>
   3c5fa:	f416 6f80 	tst.w	r6, #1024	; 0x400
   3c5fe:	bf1f      	itttt	ne
   3c600:	6d22      	ldrne	r2, [r4, #80]	; 0x50
   3c602:	f892 3020 	ldrbne.w	r3, [r2, #32]
   3c606:	f043 0304 	orrne.w	r3, r3, #4
   3c60a:	f882 3020 	strbne.w	r3, [r2, #32]
   3c60e:	2700      	movs	r7, #0
   3c610:	e74f      	b.n	3c4b2 <ull_isr+0xb6>
   3c612:	f892 3020 	ldrb.w	r3, [r2, #32]
   3c616:	f043 0302 	orr.w	r3, r3, #2
   3c61a:	f882 3020 	strb.w	r3, [r2, #32]
   3c61e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c620:	2200      	movs	r2, #0
   3c622:	83da      	strh	r2, [r3, #30]
   3c624:	f447 4700 	orr.w	r7, r7, #32768	; 0x8000
   3c628:	e75d      	b.n	3c4e6 <ull_isr+0xea>
   3c62a:	4620      	mov	r0, r4
   3c62c:	f7ff fdae 	bl	3c18c <ull_getframelength>
   3c630:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   3c634:	f43f af57 	beq.w	3c4e6 <ull_isr+0xea>
   3c638:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3c63a:	f892 3020 	ldrb.w	r3, [r2, #32]
   3c63e:	f043 0301 	orr.w	r3, r3, #1
   3c642:	f882 3020 	strb.w	r3, [r2, #32]
   3c646:	e74e      	b.n	3c4e6 <ull_isr+0xea>
   3c648:	6963      	ldr	r3, [r4, #20]
   3c64a:	b10b      	cbz	r3, 3c650 <ull_isr+0x254>
   3c64c:	3018      	adds	r0, #24
   3c64e:	4798      	blx	r3
   3c650:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c652:	7b9b      	ldrb	r3, [r3, #14]
   3c654:	bb03      	cbnz	r3, 3c698 <ull_isr+0x29c>
   3c656:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c658:	2200      	movs	r2, #0
   3c65a:	f883 2020 	strb.w	r2, [r3, #32]
   3c65e:	f015 0f10 	tst.w	r5, #16
   3c662:	d11d      	bne.n	3c6a0 <ull_isr+0x2a4>
   3c664:	f015 0f20 	tst.w	r5, #32
   3c668:	d12d      	bne.n	3c6c6 <ull_isr+0x2ca>
   3c66a:	2200      	movs	r2, #0
   3c66c:	4920      	ldr	r1, [pc, #128]	; (3c6f0 <ull_isr+0x2f4>)
   3c66e:	4620      	mov	r0, r4
   3c670:	f7fe ffa5 	bl	3b5be <dwt_read8bitoffsetreg>
   3c674:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c676:	f883 0021 	strb.w	r0, [r3, #33]	; 0x21
   3c67a:	f010 0303 	ands.w	r3, r0, #3
   3c67e:	d009      	beq.n	3c694 <ull_isr+0x298>
   3c680:	2200      	movs	r2, #0
   3c682:	491b      	ldr	r1, [pc, #108]	; (3c6f0 <ull_isr+0x2f4>)
   3c684:	4620      	mov	r0, r4
   3c686:	f7ff fd75 	bl	3c174 <dwt_write8bitoffsetreg>
   3c68a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   3c68c:	b113      	cbz	r3, 3c694 <ull_isr+0x298>
   3c68e:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c690:	3018      	adds	r0, #24
   3c692:	4798      	blx	r3
   3c694:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3c698:	4620      	mov	r0, r4
   3c69a:	f7ff fe9b 	bl	3c3d4 <ull_signal_rx_buff_free>
   3c69e:	e7da      	b.n	3c656 <ull_isr+0x25a>
   3c6a0:	4b14      	ldr	r3, [pc, #80]	; (3c6f4 <ull_isr+0x2f8>)
   3c6a2:	2200      	movs	r2, #0
   3c6a4:	2144      	movs	r1, #68	; 0x44
   3c6a6:	4620      	mov	r0, r4
   3c6a8:	f7ff fbd6 	bl	3be58 <dwt_write32bitoffsetreg>
   3c6ac:	4620      	mov	r0, r4
   3c6ae:	f7ff fd9f 	bl	3c1f0 <_dwt_clear_db_events>
   3c6b2:	69e3      	ldr	r3, [r4, #28]
   3c6b4:	b113      	cbz	r3, 3c6bc <ull_isr+0x2c0>
   3c6b6:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c6b8:	3018      	adds	r0, #24
   3c6ba:	4798      	blx	r3
   3c6bc:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c6be:	2200      	movs	r2, #0
   3c6c0:	f883 2020 	strb.w	r2, [r3, #32]
   3c6c4:	e7ce      	b.n	3c664 <ull_isr+0x268>
   3c6c6:	4b0c      	ldr	r3, [pc, #48]	; (3c6f8 <ull_isr+0x2fc>)
   3c6c8:	2200      	movs	r2, #0
   3c6ca:	2144      	movs	r1, #68	; 0x44
   3c6cc:	4620      	mov	r0, r4
   3c6ce:	f7ff fbc3 	bl	3be58 <dwt_write32bitoffsetreg>
   3c6d2:	4620      	mov	r0, r4
   3c6d4:	f7ff fd8c 	bl	3c1f0 <_dwt_clear_db_events>
   3c6d8:	69a3      	ldr	r3, [r4, #24]
   3c6da:	b113      	cbz	r3, 3c6e2 <ull_isr+0x2e6>
   3c6dc:	6d20      	ldr	r0, [r4, #80]	; 0x50
   3c6de:	3018      	adds	r0, #24
   3c6e0:	4798      	blx	r3
   3c6e2:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3c6e4:	2200      	movs	r2, #0
   3c6e6:	f883 2020 	strb.w	r2, [r3, #32]
   3c6ea:	e7be      	b.n	3c66a <ull_isr+0x26e>
   3c6ec:	00010018 	.word	0x00010018
   3c6f0:	00110038 	.word	0x00110038
   3c6f4:	34059400 	.word	0x34059400
   3c6f8:	10220400 	.word	0x10220400

0003c6fc <dwt_modify32bitoffsetreg>:
   3c6fc:	b530      	push	{r4, r5, lr}
   3c6fe:	b085      	sub	sp, #20
   3c700:	9c08      	ldr	r4, [sp, #32]
   3c702:	f88d 3008 	strb.w	r3, [sp, #8]
   3c706:	0a1d      	lsrs	r5, r3, #8
   3c708:	f88d 5009 	strb.w	r5, [sp, #9]
   3c70c:	0c1d      	lsrs	r5, r3, #16
   3c70e:	f88d 500a 	strb.w	r5, [sp, #10]
   3c712:	0e1b      	lsrs	r3, r3, #24
   3c714:	f88d 300b 	strb.w	r3, [sp, #11]
   3c718:	f88d 400c 	strb.w	r4, [sp, #12]
   3c71c:	0a23      	lsrs	r3, r4, #8
   3c71e:	f88d 300d 	strb.w	r3, [sp, #13]
   3c722:	0c23      	lsrs	r3, r4, #16
   3c724:	f88d 300e 	strb.w	r3, [sp, #14]
   3c728:	0e24      	lsrs	r4, r4, #24
   3c72a:	f88d 400f 	strb.w	r4, [sp, #15]
   3c72e:	f248 0303 	movw	r3, #32771	; 0x8003
   3c732:	9301      	str	r3, [sp, #4]
   3c734:	ab02      	add	r3, sp, #8
   3c736:	9300      	str	r3, [sp, #0]
   3c738:	2308      	movs	r3, #8
   3c73a:	b292      	uxth	r2, r2
   3c73c:	f7fe fe8f 	bl	3b45e <dwt_xfer3xxx>
   3c740:	b005      	add	sp, #20
   3c742:	bd30      	pop	{r4, r5, pc}

0003c744 <ull_enable_rf_tx>:
   3c744:	b570      	push	{r4, r5, r6, lr}
   3c746:	b082      	sub	sp, #8
   3c748:	4604      	mov	r4, r0
   3c74a:	460e      	mov	r6, r1
   3c74c:	4d13      	ldr	r5, [pc, #76]	; (3c79c <ull_enable_rf_tx+0x58>)
   3c74e:	f04f 2308 	mov.w	r3, #134219776	; 0x8000800
   3c752:	9300      	str	r3, [sp, #0]
   3c754:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3c758:	2200      	movs	r2, #0
   3c75a:	4629      	mov	r1, r5
   3c75c:	f7ff ffce 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c760:	f04f 1360 	mov.w	r3, #6291552	; 0x600060
   3c764:	9300      	str	r3, [sp, #0]
   3c766:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3c76a:	2200      	movs	r2, #0
   3c76c:	4629      	mov	r1, r5
   3c76e:	4620      	mov	r0, r4
   3c770:	f7ff ffc4 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c774:	4b0a      	ldr	r3, [pc, #40]	; (3c7a0 <ull_enable_rf_tx+0x5c>)
   3c776:	9300      	str	r3, [sp, #0]
   3c778:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3c77c:	2200      	movs	r2, #0
   3c77e:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   3c782:	4620      	mov	r0, r4
   3c784:	f7ff ffba 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c788:	b90e      	cbnz	r6, 3c78e <ull_enable_rf_tx+0x4a>
   3c78a:	b002      	add	sp, #8
   3c78c:	bd70      	pop	{r4, r5, r6, pc}
   3c78e:	4b05      	ldr	r3, [pc, #20]	; (3c7a4 <ull_enable_rf_tx+0x60>)
   3c790:	2200      	movs	r2, #0
   3c792:	4905      	ldr	r1, [pc, #20]	; (3c7a8 <ull_enable_rf_tx+0x64>)
   3c794:	4620      	mov	r0, r4
   3c796:	f7ff fb5f 	bl	3be58 <dwt_write32bitoffsetreg>
   3c79a:	e7f6      	b.n	3c78a <ull_enable_rf_tx+0x46>
   3c79c:	00070048 	.word	0x00070048
   3c7a0:	02003c00 	.word	0x02003c00
   3c7a4:	01011100 	.word	0x01011100
   3c7a8:	00070014 	.word	0x00070014

0003c7ac <ull_enable_rftx_blocks>:
   3c7ac:	b500      	push	{lr}
   3c7ae:	b083      	sub	sp, #12
   3c7b0:	4b05      	ldr	r3, [pc, #20]	; (3c7c8 <ull_enable_rftx_blocks+0x1c>)
   3c7b2:	9300      	str	r3, [sp, #0]
   3c7b4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3c7b8:	2200      	movs	r2, #0
   3c7ba:	4904      	ldr	r1, [pc, #16]	; (3c7cc <ull_enable_rftx_blocks+0x20>)
   3c7bc:	f7ff ff9e 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c7c0:	b003      	add	sp, #12
   3c7c2:	f85d fb04 	ldr.w	pc, [sp], #4
   3c7c6:	bf00      	nop
   3c7c8:	02003c00 	.word	0x02003c00
   3c7cc:	00070004 	.word	0x00070004

0003c7d0 <_dwt_otpprogword32>:
   3c7d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3c7d4:	b083      	sub	sp, #12
   3c7d6:	4604      	mov	r4, r0
   3c7d8:	460d      	mov	r5, r1
   3c7da:	4617      	mov	r7, r2
   3c7dc:	4e56      	ldr	r6, [pc, #344]	; (3c938 <_dwt_otpprogword32+0x168>)
   3c7de:	2200      	movs	r2, #0
   3c7e0:	4631      	mov	r1, r6
   3c7e2:	f7fe fec4 	bl	3b56e <dwt_read32bitoffsetreg>
   3c7e6:	4681      	mov	r9, r0
   3c7e8:	f44f 4370 	mov.w	r3, #61440	; 0xf000
   3c7ec:	9300      	str	r3, [sp, #0]
   3c7ee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3c7f2:	2200      	movs	r2, #0
   3c7f4:	4631      	mov	r1, r6
   3c7f6:	4620      	mov	r0, r4
   3c7f8:	f7ff ff80 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c7fc:	f8df 813c 	ldr.w	r8, [pc, #316]	; 3c93c <_dwt_otpprogword32+0x16c>
   3c800:	2318      	movs	r3, #24
   3c802:	2200      	movs	r2, #0
   3c804:	4641      	mov	r1, r8
   3c806:	4620      	mov	r0, r4
   3c808:	f7ff fac9 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c80c:	2125      	movs	r1, #37	; 0x25
   3c80e:	4620      	mov	r0, r4
   3c810:	f7ff faec 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c814:	2102      	movs	r1, #2
   3c816:	4620      	mov	r0, r4
   3c818:	f7ff fae8 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c81c:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
   3c820:	4620      	mov	r0, r4
   3c822:	f7ff fae3 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c826:	b2f9      	uxtb	r1, r7
   3c828:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3c82c:	4620      	mov	r0, r4
   3c82e:	f7ff fadd 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c832:	f44f 7180 	mov.w	r1, #256	; 0x100
   3c836:	4620      	mov	r0, r4
   3c838:	f7ff fad8 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c83c:	2100      	movs	r1, #0
   3c83e:	4620      	mov	r0, r4
   3c840:	f7ff fad4 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c844:	2102      	movs	r1, #2
   3c846:	4620      	mov	r0, r4
   3c848:	f7ff fad0 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c84c:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
   3c850:	4620      	mov	r0, r4
   3c852:	f7ff facb 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c856:	b2e9      	uxtb	r1, r5
   3c858:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3c85c:	4620      	mov	r0, r4
   3c85e:	f7ff fac5 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c862:	f3c5 2107 	ubfx	r1, r5, #8, #8
   3c866:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3c86a:	4620      	mov	r0, r4
   3c86c:	f7ff fabe 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c870:	f3c5 4107 	ubfx	r1, r5, #16, #8
   3c874:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3c878:	4620      	mov	r0, r4
   3c87a:	f7ff fab7 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c87e:	0e29      	lsrs	r1, r5, #24
   3c880:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   3c884:	4620      	mov	r0, r4
   3c886:	f7ff fab1 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c88a:	2100      	movs	r1, #0
   3c88c:	4620      	mov	r0, r4
   3c88e:	f7ff faad 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c892:	213a      	movs	r1, #58	; 0x3a
   3c894:	4620      	mov	r0, r4
   3c896:	f7ff faa9 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c89a:	f240 11ff 	movw	r1, #511	; 0x1ff
   3c89e:	4620      	mov	r0, r4
   3c8a0:	f7ff faa4 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8a4:	f44f 7185 	mov.w	r1, #266	; 0x10a
   3c8a8:	4620      	mov	r0, r4
   3c8aa:	f7ff fa9f 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8ae:	2100      	movs	r1, #0
   3c8b0:	4620      	mov	r0, r4
   3c8b2:	f7ff fa9b 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8b6:	213a      	movs	r1, #58	; 0x3a
   3c8b8:	4620      	mov	r0, r4
   3c8ba:	f7ff fa97 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8be:	f240 1101 	movw	r1, #257	; 0x101
   3c8c2:	4620      	mov	r0, r4
   3c8c4:	f7ff fa92 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8c8:	2302      	movs	r3, #2
   3c8ca:	2200      	movs	r2, #0
   3c8cc:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3c8d0:	4620      	mov	r0, r4
   3c8d2:	f7ff fa64 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c8d6:	2300      	movs	r3, #0
   3c8d8:	461a      	mov	r2, r3
   3c8da:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3c8de:	4620      	mov	r0, r4
   3c8e0:	f7ff fa5d 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c8e4:	2002      	movs	r0, #2
   3c8e6:	f7f1 ff72 	bl	2e7ce <deca_sleep>
   3c8ea:	213a      	movs	r1, #58	; 0x3a
   3c8ec:	4620      	mov	r0, r4
   3c8ee:	f7ff fa7d 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8f2:	f44f 7181 	mov.w	r1, #258	; 0x102
   3c8f6:	4620      	mov	r0, r4
   3c8f8:	f7ff fa78 	bl	3bdec <__dwt_otp_write_wdata_id_reg>
   3c8fc:	2302      	movs	r3, #2
   3c8fe:	2200      	movs	r2, #0
   3c900:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3c904:	4620      	mov	r0, r4
   3c906:	f7ff fa4a 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c90a:	2300      	movs	r3, #0
   3c90c:	461a      	mov	r2, r3
   3c90e:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   3c912:	4620      	mov	r0, r4
   3c914:	f7ff fa43 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c918:	2300      	movs	r3, #0
   3c91a:	461a      	mov	r2, r3
   3c91c:	4641      	mov	r1, r8
   3c91e:	4620      	mov	r0, r4
   3c920:	f7ff fa3d 	bl	3bd9e <dwt_write16bitoffsetreg>
   3c924:	464b      	mov	r3, r9
   3c926:	2200      	movs	r2, #0
   3c928:	4631      	mov	r1, r6
   3c92a:	4620      	mov	r0, r4
   3c92c:	f7ff fa94 	bl	3be58 <dwt_write32bitoffsetreg>
   3c930:	b003      	add	sp, #12
   3c932:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3c936:	bf00      	nop
   3c938:	00070044 	.word	0x00070044
   3c93c:	000b0008 	.word	0x000b0008

0003c940 <ull_setgpiomode>:
   3c940:	b5f0      	push	{r4, r5, r6, r7, lr}
   3c942:	b083      	sub	sp, #12
   3c944:	2400      	movs	r4, #0
   3c946:	4623      	mov	r3, r4
   3c948:	2601      	movs	r6, #1
   3c94a:	2707      	movs	r7, #7
   3c94c:	e002      	b.n	3c954 <ull_setgpiomode+0x14>
   3c94e:	3401      	adds	r4, #1
   3c950:	2c09      	cmp	r4, #9
   3c952:	d009      	beq.n	3c968 <ull_setgpiomode+0x28>
   3c954:	fa06 f504 	lsl.w	r5, r6, r4
   3c958:	420d      	tst	r5, r1
   3c95a:	d0f8      	beq.n	3c94e <ull_setgpiomode+0xe>
   3c95c:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   3c960:	fa07 f505 	lsl.w	r5, r7, r5
   3c964:	432b      	orrs	r3, r5
   3c966:	e7f2      	b.n	3c94e <ull_setgpiomode+0xe>
   3c968:	401a      	ands	r2, r3
   3c96a:	9200      	str	r2, [sp, #0]
   3c96c:	43db      	mvns	r3, r3
   3c96e:	2200      	movs	r2, #0
   3c970:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3c974:	f7ff fec2 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c978:	b003      	add	sp, #12
   3c97a:	bdf0      	pop	{r4, r5, r6, r7, pc}

0003c97c <ull_writetxfctrl>:
   3c97c:	b510      	push	{r4, lr}
   3c97e:	b082      	sub	sp, #8
   3c980:	4604      	mov	r4, r0
   3c982:	2a7f      	cmp	r2, #127	; 0x7f
   3c984:	d912      	bls.n	3c9ac <ull_writetxfctrl+0x30>
   3c986:	3280      	adds	r2, #128	; 0x80
   3c988:	ea41 21c3 	orr.w	r1, r1, r3, lsl #11
   3c98c:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   3c990:	9100      	str	r1, [sp, #0]
   3c992:	4b0c      	ldr	r3, [pc, #48]	; (3c9c4 <ull_writetxfctrl+0x48>)
   3c994:	2200      	movs	r2, #0
   3c996:	2120      	movs	r1, #32
   3c998:	f7ff feb0 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c99c:	2200      	movs	r2, #0
   3c99e:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   3c9a2:	4620      	mov	r0, r4
   3c9a4:	f7fe fe0b 	bl	3b5be <dwt_read8bitoffsetreg>
   3c9a8:	b002      	add	sp, #8
   3c9aa:	bd10      	pop	{r4, pc}
   3c9ac:	ea41 21c3 	orr.w	r1, r1, r3, lsl #11
   3c9b0:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   3c9b4:	9100      	str	r1, [sp, #0]
   3c9b6:	4b03      	ldr	r3, [pc, #12]	; (3c9c4 <ull_writetxfctrl+0x48>)
   3c9b8:	2200      	movs	r2, #0
   3c9ba:	2120      	movs	r1, #32
   3c9bc:	f7ff fe9e 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c9c0:	e7f2      	b.n	3c9a8 <ull_writetxfctrl+0x2c>
   3c9c2:	bf00      	nop
   3c9c4:	fc00f400 	.word	0xfc00f400

0003c9c8 <prs_sys_status_and_or>:
   3c9c8:	b500      	push	{lr}
   3c9ca:	b083      	sub	sp, #12
   3c9cc:	9200      	str	r2, [sp, #0]
   3c9ce:	460b      	mov	r3, r1
   3c9d0:	2200      	movs	r2, #0
   3c9d2:	2144      	movs	r1, #68	; 0x44
   3c9d4:	f7ff fe92 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3c9d8:	2000      	movs	r0, #0
   3c9da:	b003      	add	sp, #12
   3c9dc:	f85d fb04 	ldr.w	pc, [sp], #4

0003c9e0 <dwt_modify8bitoffsetreg>:
   3c9e0:	b500      	push	{lr}
   3c9e2:	b085      	sub	sp, #20
   3c9e4:	f88d 300c 	strb.w	r3, [sp, #12]
   3c9e8:	f89d 3018 	ldrb.w	r3, [sp, #24]
   3c9ec:	f88d 300d 	strb.w	r3, [sp, #13]
   3c9f0:	f248 0301 	movw	r3, #32769	; 0x8001
   3c9f4:	9301      	str	r3, [sp, #4]
   3c9f6:	ab03      	add	r3, sp, #12
   3c9f8:	9300      	str	r3, [sp, #0]
   3c9fa:	2302      	movs	r3, #2
   3c9fc:	b292      	uxth	r2, r2
   3c9fe:	f7fe fd2e 	bl	3b45e <dwt_xfer3xxx>
   3ca02:	b005      	add	sp, #20
   3ca04:	f85d fb04 	ldr.w	pc, [sp], #4

0003ca08 <ull_configciadiag>:
   3ca08:	b530      	push	{r4, r5, lr}
   3ca0a:	b083      	sub	sp, #12
   3ca0c:	4604      	mov	r4, r0
   3ca0e:	460d      	mov	r5, r1
   3ca10:	f011 0f01 	tst.w	r1, #1
   3ca14:	d015      	beq.n	3ca42 <ull_configciadiag+0x3a>
   3ca16:	2300      	movs	r3, #0
   3ca18:	9300      	str	r3, [sp, #0]
   3ca1a:	23ef      	movs	r3, #239	; 0xef
   3ca1c:	2202      	movs	r2, #2
   3ca1e:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3ca22:	f7ff ffdd 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ca26:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3ca28:	759d      	strb	r5, [r3, #22]
   3ca2a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3ca2c:	7d9b      	ldrb	r3, [r3, #22]
   3ca2e:	085b      	lsrs	r3, r3, #1
   3ca30:	d010      	beq.n	3ca54 <ull_configciadiag+0x4c>
   3ca32:	086b      	lsrs	r3, r5, #1
   3ca34:	2200      	movs	r2, #0
   3ca36:	490e      	ldr	r1, [pc, #56]	; (3ca70 <ull_configciadiag+0x68>)
   3ca38:	4620      	mov	r0, r4
   3ca3a:	f7ff fb9b 	bl	3c174 <dwt_write8bitoffsetreg>
   3ca3e:	b003      	add	sp, #12
   3ca40:	bd30      	pop	{r4, r5, pc}
   3ca42:	2310      	movs	r3, #16
   3ca44:	9300      	str	r3, [sp, #0]
   3ca46:	23ff      	movs	r3, #255	; 0xff
   3ca48:	2202      	movs	r2, #2
   3ca4a:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3ca4e:	f7ff ffc7 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ca52:	e7e8      	b.n	3ca26 <ull_configciadiag+0x1e>
   3ca54:	2301      	movs	r3, #1
   3ca56:	9300      	str	r3, [sp, #0]
   3ca58:	23ff      	movs	r3, #255	; 0xff
   3ca5a:	2200      	movs	r2, #0
   3ca5c:	4904      	ldr	r1, [pc, #16]	; (3ca70 <ull_configciadiag+0x68>)
   3ca5e:	4620      	mov	r0, r4
   3ca60:	f7ff ffbe 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ca64:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3ca66:	7d93      	ldrb	r3, [r2, #22]
   3ca68:	f043 0302 	orr.w	r3, r3, #2
   3ca6c:	7593      	strb	r3, [r2, #22]
   3ca6e:	e7e6      	b.n	3ca3e <ull_configciadiag+0x36>
   3ca70:	00010020 	.word	0x00010020

0003ca74 <ull_calcbandwidthadj>:
   3ca74:	b570      	push	{r4, r5, r6, lr}
   3ca76:	b082      	sub	sp, #8
   3ca78:	4604      	mov	r4, r0
   3ca7a:	460d      	mov	r5, r1
   3ca7c:	2101      	movs	r1, #1
   3ca7e:	f7ff f99f 	bl	3bdc0 <ull_force_clocks>
   3ca82:	2100      	movs	r1, #0
   3ca84:	4620      	mov	r0, r4
   3ca86:	f7ff fe5d 	bl	3c744 <ull_enable_rf_tx>
   3ca8a:	4620      	mov	r0, r4
   3ca8c:	f7ff fe8e 	bl	3c7ac <ull_enable_rftx_blocks>
   3ca90:	f3c5 030b 	ubfx	r3, r5, #0, #12
   3ca94:	2200      	movs	r2, #0
   3ca96:	4915      	ldr	r1, [pc, #84]	; (3caec <ull_calcbandwidthadj+0x78>)
   3ca98:	4620      	mov	r0, r4
   3ca9a:	f7ff f980 	bl	3bd9e <dwt_write16bitoffsetreg>
   3ca9e:	2303      	movs	r3, #3
   3caa0:	9300      	str	r3, [sp, #0]
   3caa2:	23ff      	movs	r3, #255	; 0xff
   3caa4:	2200      	movs	r2, #0
   3caa6:	4912      	ldr	r1, [pc, #72]	; (3caf0 <ull_calcbandwidthadj+0x7c>)
   3caa8:	4620      	mov	r0, r4
   3caaa:	f7ff ff99 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3caae:	4e10      	ldr	r6, [pc, #64]	; (3caf0 <ull_calcbandwidthadj+0x7c>)
   3cab0:	2500      	movs	r5, #0
   3cab2:	462a      	mov	r2, r5
   3cab4:	4631      	mov	r1, r6
   3cab6:	4620      	mov	r0, r4
   3cab8:	f7fe fd81 	bl	3b5be <dwt_read8bitoffsetreg>
   3cabc:	f010 0f01 	tst.w	r0, #1
   3cac0:	d1f7      	bne.n	3cab2 <ull_calcbandwidthadj+0x3e>
   3cac2:	4620      	mov	r0, r4
   3cac4:	f7ff faf8 	bl	3c0b8 <ull_disable_rftx_blocks>
   3cac8:	2100      	movs	r1, #0
   3caca:	4620      	mov	r0, r4
   3cacc:	f7ff fafe 	bl	3c0cc <ull_disable_rf_tx>
   3cad0:	2105      	movs	r1, #5
   3cad2:	4620      	mov	r0, r4
   3cad4:	f7ff f974 	bl	3bdc0 <ull_force_clocks>
   3cad8:	2200      	movs	r2, #0
   3cada:	4906      	ldr	r1, [pc, #24]	; (3caf4 <ull_calcbandwidthadj+0x80>)
   3cadc:	4620      	mov	r0, r4
   3cade:	f7fe fd6e 	bl	3b5be <dwt_read8bitoffsetreg>
   3cae2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   3cae6:	b002      	add	sp, #8
   3cae8:	bd70      	pop	{r4, r5, r6, pc}
   3caea:	bf00      	nop
   3caec:	0008001c 	.word	0x0008001c
   3caf0:	00080010 	.word	0x00080010
   3caf4:	0007001c 	.word	0x0007001c

0003caf8 <ull_configuretxrf>:
   3caf8:	b538      	push	{r3, r4, r5, lr}
   3cafa:	4605      	mov	r5, r0
   3cafc:	460c      	mov	r4, r1
   3cafe:	f8b1 1005 	ldrh.w	r1, [r1, #5]
   3cb02:	b149      	cbz	r1, 3cb18 <ull_configuretxrf+0x20>
   3cb04:	f7ff ffb6 	bl	3ca74 <ull_calcbandwidthadj>
   3cb08:	f8d4 3001 	ldr.w	r3, [r4, #1]
   3cb0c:	2200      	movs	r2, #0
   3cb0e:	4905      	ldr	r1, [pc, #20]	; (3cb24 <ull_configuretxrf+0x2c>)
   3cb10:	4628      	mov	r0, r5
   3cb12:	f7ff f9a1 	bl	3be58 <dwt_write32bitoffsetreg>
   3cb16:	bd38      	pop	{r3, r4, r5, pc}
   3cb18:	7823      	ldrb	r3, [r4, #0]
   3cb1a:	2200      	movs	r2, #0
   3cb1c:	4902      	ldr	r1, [pc, #8]	; (3cb28 <ull_configuretxrf+0x30>)
   3cb1e:	f7ff fb29 	bl	3c174 <dwt_write8bitoffsetreg>
   3cb22:	e7f1      	b.n	3cb08 <ull_configuretxrf+0x10>
   3cb24:	00010004 	.word	0x00010004
   3cb28:	0007001c 	.word	0x0007001c

0003cb2c <ull_repeated_frames>:
   3cb2c:	b530      	push	{r4, r5, lr}
   3cb2e:	b083      	sub	sp, #12
   3cb30:	4604      	mov	r4, r0
   3cb32:	460d      	mov	r5, r1
   3cb34:	2310      	movs	r3, #16
   3cb36:	9300      	str	r3, [sp, #0]
   3cb38:	23ff      	movs	r3, #255	; 0xff
   3cb3a:	2200      	movs	r2, #0
   3cb3c:	4906      	ldr	r1, [pc, #24]	; (3cb58 <ull_repeated_frames+0x2c>)
   3cb3e:	f7ff ff4f 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cb42:	462b      	mov	r3, r5
   3cb44:	2d02      	cmp	r5, #2
   3cb46:	bf38      	it	cc
   3cb48:	2302      	movcc	r3, #2
   3cb4a:	2200      	movs	r2, #0
   3cb4c:	2128      	movs	r1, #40	; 0x28
   3cb4e:	4620      	mov	r0, r4
   3cb50:	f7ff f982 	bl	3be58 <dwt_write32bitoffsetreg>
   3cb54:	b003      	add	sp, #12
   3cb56:	bd30      	pop	{r4, r5, pc}
   3cb58:	000f0028 	.word	0x000f0028

0003cb5c <ull_setdwstate>:
   3cb5c:	b530      	push	{r4, r5, lr}
   3cb5e:	b083      	sub	sp, #12
   3cb60:	4604      	mov	r4, r0
   3cb62:	2901      	cmp	r1, #1
   3cb64:	d01d      	beq.n	3cba2 <ull_setdwstate+0x46>
   3cb66:	2902      	cmp	r1, #2
   3cb68:	d02f      	beq.n	3cbca <ull_setdwstate+0x6e>
   3cb6a:	2301      	movs	r3, #1
   3cb6c:	9300      	str	r3, [sp, #0]
   3cb6e:	23ff      	movs	r3, #255	; 0xff
   3cb70:	2200      	movs	r2, #0
   3cb72:	4925      	ldr	r1, [pc, #148]	; (3cc08 <ull_setdwstate+0xac>)
   3cb74:	f7ff ff34 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cb78:	4d24      	ldr	r5, [pc, #144]	; (3cc0c <ull_setdwstate+0xb0>)
   3cb7a:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   3cb7e:	9300      	str	r3, [sp, #0]
   3cb80:	f46f 7380 	mvn.w	r3, #256	; 0x100
   3cb84:	2200      	movs	r2, #0
   3cb86:	4629      	mov	r1, r5
   3cb88:	4620      	mov	r0, r4
   3cb8a:	f7ff fdb7 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cb8e:	2300      	movs	r3, #0
   3cb90:	9300      	str	r3, [sp, #0]
   3cb92:	237f      	movs	r3, #127	; 0x7f
   3cb94:	2202      	movs	r2, #2
   3cb96:	4629      	mov	r1, r5
   3cb98:	4620      	mov	r0, r4
   3cb9a:	f7ff ff21 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cb9e:	b003      	add	sp, #12
   3cba0:	bd30      	pop	{r4, r5, pc}
   3cba2:	2105      	movs	r1, #5
   3cba4:	f7ff f90c 	bl	3bdc0 <ull_force_clocks>
   3cba8:	2302      	movs	r3, #2
   3cbaa:	9300      	str	r3, [sp, #0]
   3cbac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3cbb0:	2200      	movs	r2, #0
   3cbb2:	4917      	ldr	r1, [pc, #92]	; (3cc10 <ull_setdwstate+0xb4>)
   3cbb4:	4620      	mov	r0, r4
   3cbb6:	f7ff fda1 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cbba:	2201      	movs	r2, #1
   3cbbc:	9200      	str	r2, [sp, #0]
   3cbbe:	23ff      	movs	r3, #255	; 0xff
   3cbc0:	4912      	ldr	r1, [pc, #72]	; (3cc0c <ull_setdwstate+0xb0>)
   3cbc2:	4620      	mov	r0, r4
   3cbc4:	f7ff ff0c 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cbc8:	e7e9      	b.n	3cb9e <ull_setdwstate+0x42>
   3cbca:	2303      	movs	r3, #3
   3cbcc:	9300      	str	r3, [sp, #0]
   3cbce:	23ff      	movs	r3, #255	; 0xff
   3cbd0:	2200      	movs	r2, #0
   3cbd2:	490d      	ldr	r1, [pc, #52]	; (3cc08 <ull_setdwstate+0xac>)
   3cbd4:	f7ff ff04 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cbd8:	4d0c      	ldr	r5, [pc, #48]	; (3cc0c <ull_setdwstate+0xb0>)
   3cbda:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   3cbde:	9300      	str	r3, [sp, #0]
   3cbe0:	f46f 7380 	mvn.w	r3, #256	; 0x100
   3cbe4:	2200      	movs	r2, #0
   3cbe6:	4629      	mov	r1, r5
   3cbe8:	4620      	mov	r0, r4
   3cbea:	f7ff fd87 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cbee:	2300      	movs	r3, #0
   3cbf0:	9300      	str	r3, [sp, #0]
   3cbf2:	237f      	movs	r3, #127	; 0x7f
   3cbf4:	2202      	movs	r2, #2
   3cbf6:	4629      	mov	r1, r5
   3cbf8:	4620      	mov	r0, r4
   3cbfa:	f7ff fef1 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cbfe:	2105      	movs	r1, #5
   3cc00:	4620      	mov	r0, r4
   3cc02:	f7ff f8dd 	bl	3bdc0 <ull_force_clocks>
   3cc06:	e7ca      	b.n	3cb9e <ull_setdwstate+0x42>
   3cc08:	00110004 	.word	0x00110004
   3cc0c:	00110008 	.word	0x00110008
   3cc10:	00090008 	.word	0x00090008

0003cc14 <ull_configureframefilter>:
   3cc14:	b530      	push	{r4, r5, lr}
   3cc16:	b083      	sub	sp, #12
   3cc18:	4605      	mov	r5, r0
   3cc1a:	2902      	cmp	r1, #2
   3cc1c:	d00e      	beq.n	3cc3c <ull_configureframefilter+0x28>
   3cc1e:	2400      	movs	r4, #0
   3cc20:	9400      	str	r4, [sp, #0]
   3cc22:	23fe      	movs	r3, #254	; 0xfe
   3cc24:	4622      	mov	r2, r4
   3cc26:	2110      	movs	r1, #16
   3cc28:	f7ff feda 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cc2c:	4623      	mov	r3, r4
   3cc2e:	4622      	mov	r2, r4
   3cc30:	2114      	movs	r1, #20
   3cc32:	4628      	mov	r0, r5
   3cc34:	f7ff f8b3 	bl	3bd9e <dwt_write16bitoffsetreg>
   3cc38:	b003      	add	sp, #12
   3cc3a:	bd30      	pop	{r4, r5, pc}
   3cc3c:	4614      	mov	r4, r2
   3cc3e:	2301      	movs	r3, #1
   3cc40:	9300      	str	r3, [sp, #0]
   3cc42:	23ff      	movs	r3, #255	; 0xff
   3cc44:	2200      	movs	r2, #0
   3cc46:	2110      	movs	r1, #16
   3cc48:	f7ff feca 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cc4c:	4623      	mov	r3, r4
   3cc4e:	2200      	movs	r2, #0
   3cc50:	2114      	movs	r1, #20
   3cc52:	4628      	mov	r0, r5
   3cc54:	f7ff f8a3 	bl	3bd9e <dwt_write16bitoffsetreg>
   3cc58:	e7ee      	b.n	3cc38 <ull_configureframefilter+0x24>
	...

0003cc5c <ull_run_pgfcal>:
   3cc5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3cc60:	b082      	sub	sp, #8
   3cc62:	4605      	mov	r5, r0
   3cc64:	4c29      	ldr	r4, [pc, #164]	; (3cd0c <ull_run_pgfcal+0xb0>)
   3cc66:	4b2a      	ldr	r3, [pc, #168]	; (3cd10 <ull_run_pgfcal+0xb4>)
   3cc68:	2200      	movs	r2, #0
   3cc6a:	4621      	mov	r1, r4
   3cc6c:	f7ff f8f4 	bl	3be58 <dwt_write32bitoffsetreg>
   3cc70:	2310      	movs	r3, #16
   3cc72:	9300      	str	r3, [sp, #0]
   3cc74:	23ff      	movs	r3, #255	; 0xff
   3cc76:	2200      	movs	r2, #0
   3cc78:	4621      	mov	r1, r4
   3cc7a:	4628      	mov	r0, r5
   3cc7c:	f7ff feb0 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cc80:	2403      	movs	r4, #3
   3cc82:	f04f 0814 	mov.w	r8, #20
   3cc86:	4f23      	ldr	r7, [pc, #140]	; (3cd14 <ull_run_pgfcal+0xb8>)
   3cc88:	2600      	movs	r6, #0
   3cc8a:	4640      	mov	r0, r8
   3cc8c:	f7f1 fdaf 	bl	2e7ee <deca_usleep>
   3cc90:	4632      	mov	r2, r6
   3cc92:	4639      	mov	r1, r7
   3cc94:	4628      	mov	r0, r5
   3cc96:	f7fe fc92 	bl	3b5be <dwt_read8bitoffsetreg>
   3cc9a:	2801      	cmp	r0, #1
   3cc9c:	d034      	beq.n	3cd08 <ull_run_pgfcal+0xac>
   3cc9e:	1e63      	subs	r3, r4, #1
   3cca0:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   3cca4:	d1f1      	bne.n	3cc8a <ull_run_pgfcal+0x2e>
   3cca6:	f06f 0402 	mvn.w	r4, #2
   3ccaa:	4e18      	ldr	r6, [pc, #96]	; (3cd0c <ull_run_pgfcal+0xb0>)
   3ccac:	2300      	movs	r3, #0
   3ccae:	461a      	mov	r2, r3
   3ccb0:	4631      	mov	r1, r6
   3ccb2:	4628      	mov	r0, r5
   3ccb4:	f7ff fa5e 	bl	3c174 <dwt_write8bitoffsetreg>
   3ccb8:	2301      	movs	r3, #1
   3ccba:	2200      	movs	r2, #0
   3ccbc:	4915      	ldr	r1, [pc, #84]	; (3cd14 <ull_run_pgfcal+0xb8>)
   3ccbe:	4628      	mov	r0, r5
   3ccc0:	f7ff fa58 	bl	3c174 <dwt_write8bitoffsetreg>
   3ccc4:	2301      	movs	r3, #1
   3ccc6:	9300      	str	r3, [sp, #0]
   3ccc8:	23ff      	movs	r3, #255	; 0xff
   3ccca:	2202      	movs	r2, #2
   3cccc:	4631      	mov	r1, r6
   3ccce:	4628      	mov	r0, r5
   3ccd0:	f7ff fe86 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ccd4:	2200      	movs	r2, #0
   3ccd6:	4910      	ldr	r1, [pc, #64]	; (3cd18 <ull_run_pgfcal+0xbc>)
   3ccd8:	4628      	mov	r0, r5
   3ccda:	f7fe fc48 	bl	3b56e <dwt_read32bitoffsetreg>
   3ccde:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   3cce2:	4298      	cmp	r0, r3
   3cce4:	bf08      	it	eq
   3cce6:	f06f 0403 	mvneq.w	r4, #3
   3ccea:	2200      	movs	r2, #0
   3ccec:	490b      	ldr	r1, [pc, #44]	; (3cd1c <ull_run_pgfcal+0xc0>)
   3ccee:	4628      	mov	r0, r5
   3ccf0:	f7fe fc3d 	bl	3b56e <dwt_read32bitoffsetreg>
   3ccf4:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   3ccf8:	4298      	cmp	r0, r3
   3ccfa:	bf14      	ite	ne
   3ccfc:	4620      	movne	r0, r4
   3ccfe:	f06f 0004 	mvneq.w	r0, #4
   3cd02:	b002      	add	sp, #8
   3cd04:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3cd08:	2400      	movs	r4, #0
   3cd0a:	e7ce      	b.n	3ccaa <ull_run_pgfcal+0x4e>
   3cd0c:	0004000c 	.word	0x0004000c
   3cd10:	00020001 	.word	0x00020001
   3cd14:	00040020 	.word	0x00040020
   3cd18:	00040014 	.word	0x00040014
   3cd1c:	0004001c 	.word	0x0004001c

0003cd20 <ull_setinterrupt>:
   3cd20:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   3cd24:	b083      	sub	sp, #12
   3cd26:	4605      	mov	r5, r0
   3cd28:	4688      	mov	r8, r1
   3cd2a:	4617      	mov	r7, r2
   3cd2c:	461c      	mov	r4, r3
   3cd2e:	f7f1 fd3b 	bl	2e7a8 <decamutexon>
   3cd32:	4606      	mov	r6, r0
   3cd34:	2c02      	cmp	r4, #2
   3cd36:	d019      	beq.n	3cd6c <ull_setinterrupt+0x4c>
   3cd38:	2c04      	cmp	r4, #4
   3cd3a:	d017      	beq.n	3cd6c <ull_setinterrupt+0x4c>
   3cd3c:	f004 03fd 	and.w	r3, r4, #253	; 0xfd
   3cd40:	2b01      	cmp	r3, #1
   3cd42:	d03f      	beq.n	3cdc4 <ull_setinterrupt+0xa4>
   3cd44:	f04f 0900 	mov.w	r9, #0
   3cd48:	f8cd 9000 	str.w	r9, [sp]
   3cd4c:	ea6f 0308 	mvn.w	r3, r8
   3cd50:	464a      	mov	r2, r9
   3cd52:	213c      	movs	r1, #60	; 0x3c
   3cd54:	4628      	mov	r0, r5
   3cd56:	f7ff fcd1 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cd5a:	f8cd 9000 	str.w	r9, [sp]
   3cd5e:	43fb      	mvns	r3, r7
   3cd60:	464a      	mov	r2, r9
   3cd62:	2140      	movs	r1, #64	; 0x40
   3cd64:	4628      	mov	r0, r5
   3cd66:	f7ff fcc9 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cd6a:	e00b      	b.n	3cd84 <ull_setinterrupt+0x64>
   3cd6c:	4643      	mov	r3, r8
   3cd6e:	2200      	movs	r2, #0
   3cd70:	213c      	movs	r1, #60	; 0x3c
   3cd72:	4628      	mov	r0, r5
   3cd74:	f7ff f870 	bl	3be58 <dwt_write32bitoffsetreg>
   3cd78:	463b      	mov	r3, r7
   3cd7a:	2200      	movs	r2, #0
   3cd7c:	2140      	movs	r1, #64	; 0x40
   3cd7e:	4628      	mov	r0, r5
   3cd80:	f7ff f86a 	bl	3be58 <dwt_write32bitoffsetreg>
   3cd84:	3c03      	subs	r4, #3
   3cd86:	b2e4      	uxtb	r4, r4
   3cd88:	2c01      	cmp	r4, #1
   3cd8a:	d92d      	bls.n	3cde8 <ull_setinterrupt+0xc8>
   3cd8c:	2200      	movs	r2, #0
   3cd8e:	213c      	movs	r1, #60	; 0x3c
   3cd90:	4628      	mov	r0, r5
   3cd92:	f7fe fbec 	bl	3b56e <dwt_read32bitoffsetreg>
   3cd96:	4603      	mov	r3, r0
   3cd98:	2200      	movs	r2, #0
   3cd9a:	2144      	movs	r1, #68	; 0x44
   3cd9c:	4628      	mov	r0, r5
   3cd9e:	f7ff f85b 	bl	3be58 <dwt_write32bitoffsetreg>
   3cda2:	2200      	movs	r2, #0
   3cda4:	2140      	movs	r1, #64	; 0x40
   3cda6:	4628      	mov	r0, r5
   3cda8:	f7fe fbe1 	bl	3b56e <dwt_read32bitoffsetreg>
   3cdac:	4603      	mov	r3, r0
   3cdae:	2200      	movs	r2, #0
   3cdb0:	2148      	movs	r1, #72	; 0x48
   3cdb2:	4628      	mov	r0, r5
   3cdb4:	f7ff f850 	bl	3be58 <dwt_write32bitoffsetreg>
   3cdb8:	4630      	mov	r0, r6
   3cdba:	f7f1 fcfc 	bl	2e7b6 <decamutexoff>
   3cdbe:	b003      	add	sp, #12
   3cdc0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   3cdc4:	f8cd 8000 	str.w	r8, [sp]
   3cdc8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3cdcc:	2200      	movs	r2, #0
   3cdce:	213c      	movs	r1, #60	; 0x3c
   3cdd0:	4628      	mov	r0, r5
   3cdd2:	f7ff fc93 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cdd6:	9700      	str	r7, [sp, #0]
   3cdd8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3cddc:	2200      	movs	r2, #0
   3cdde:	2140      	movs	r1, #64	; 0x40
   3cde0:	4628      	mov	r0, r5
   3cde2:	f7ff fc8b 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3cde6:	e7cd      	b.n	3cd84 <ull_setinterrupt+0x64>
   3cde8:	2110      	movs	r1, #16
   3cdea:	9100      	str	r1, [sp, #0]
   3cdec:	23ff      	movs	r3, #255	; 0xff
   3cdee:	2202      	movs	r2, #2
   3cdf0:	4628      	mov	r0, r5
   3cdf2:	f7ff fdf5 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3cdf6:	e7c9      	b.n	3cd8c <ull_setinterrupt+0x6c>

0003cdf8 <prs_ack_enable>:
   3cdf8:	b500      	push	{lr}
   3cdfa:	b083      	sub	sp, #12
   3cdfc:	2900      	cmp	r1, #0
   3cdfe:	bf0b      	itete	eq
   3ce00:	23ff      	moveq	r3, #255	; 0xff
   3ce02:	23f7      	movne	r3, #247	; 0xf7
   3ce04:	2200      	moveq	r2, #0
   3ce06:	2208      	movne	r2, #8
   3ce08:	9200      	str	r2, [sp, #0]
   3ce0a:	2201      	movs	r2, #1
   3ce0c:	2110      	movs	r1, #16
   3ce0e:	f7ff fde7 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ce12:	b003      	add	sp, #12
   3ce14:	f85d fb04 	ldr.w	pc, [sp], #4

0003ce18 <dwt_modify16bitoffsetreg>:
   3ce18:	b510      	push	{r4, lr}
   3ce1a:	b084      	sub	sp, #16
   3ce1c:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   3ce20:	f88d 300c 	strb.w	r3, [sp, #12]
   3ce24:	0a1b      	lsrs	r3, r3, #8
   3ce26:	f88d 300d 	strb.w	r3, [sp, #13]
   3ce2a:	f88d 400e 	strb.w	r4, [sp, #14]
   3ce2e:	0a24      	lsrs	r4, r4, #8
   3ce30:	f88d 400f 	strb.w	r4, [sp, #15]
   3ce34:	f248 0302 	movw	r3, #32770	; 0x8002
   3ce38:	9301      	str	r3, [sp, #4]
   3ce3a:	ab03      	add	r3, sp, #12
   3ce3c:	9300      	str	r3, [sp, #0]
   3ce3e:	2304      	movs	r3, #4
   3ce40:	b292      	uxth	r2, r2
   3ce42:	f7fe fb0c 	bl	3b45e <dwt_xfer3xxx>
   3ce46:	b004      	add	sp, #16
   3ce48:	bd10      	pop	{r4, pc}
	...

0003ce4c <ull_setleds>:
   3ce4c:	b530      	push	{r4, r5, lr}
   3ce4e:	b083      	sub	sp, #12
   3ce50:	4604      	mov	r4, r0
   3ce52:	f011 0f01 	tst.w	r1, #1
   3ce56:	d01f      	beq.n	3ce98 <ull_setleds+0x4c>
   3ce58:	460d      	mov	r5, r1
   3ce5a:	f44f 7310 	mov.w	r3, #576	; 0x240
   3ce5e:	9300      	str	r3, [sp, #0]
   3ce60:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   3ce64:	2200      	movs	r2, #0
   3ce66:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3ce6a:	f7ff fc47 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3ce6e:	f44f 0304 	mov.w	r3, #8650752	; 0x840000
   3ce72:	9300      	str	r3, [sp, #0]
   3ce74:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3ce78:	2200      	movs	r2, #0
   3ce7a:	4918      	ldr	r1, [pc, #96]	; (3cedc <ull_setleds+0x90>)
   3ce7c:	4620      	mov	r0, r4
   3ce7e:	f7ff fc3d 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3ce82:	f015 0f02 	tst.w	r5, #2
   3ce86:	d11a      	bne.n	3cebe <ull_setleds+0x72>
   3ce88:	f44f 7388 	mov.w	r3, #272	; 0x110
   3ce8c:	2200      	movs	r2, #0
   3ce8e:	4914      	ldr	r1, [pc, #80]	; (3cee0 <ull_setleds+0x94>)
   3ce90:	4620      	mov	r0, r4
   3ce92:	f7fe ffe1 	bl	3be58 <dwt_write32bitoffsetreg>
   3ce96:	e010      	b.n	3ceba <ull_setleds+0x6e>
   3ce98:	2500      	movs	r5, #0
   3ce9a:	9500      	str	r5, [sp, #0]
   3ce9c:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   3cea0:	462a      	mov	r2, r5
   3cea2:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3cea6:	f7ff fc29 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3ceaa:	9500      	str	r5, [sp, #0]
   3ceac:	f64f 63ff 	movw	r3, #65279	; 0xfeff
   3ceb0:	462a      	mov	r2, r5
   3ceb2:	490b      	ldr	r1, [pc, #44]	; (3cee0 <ull_setleds+0x94>)
   3ceb4:	4620      	mov	r0, r4
   3ceb6:	f7ff ffaf 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3ceba:	b003      	add	sp, #12
   3cebc:	bd30      	pop	{r4, r5, pc}
   3cebe:	4d08      	ldr	r5, [pc, #32]	; (3cee0 <ull_setleds+0x94>)
   3cec0:	4b08      	ldr	r3, [pc, #32]	; (3cee4 <ull_setleds+0x98>)
   3cec2:	2200      	movs	r2, #0
   3cec4:	4629      	mov	r1, r5
   3cec6:	4620      	mov	r0, r4
   3cec8:	f7fe ffc6 	bl	3be58 <dwt_write32bitoffsetreg>
   3cecc:	f44f 7388 	mov.w	r3, #272	; 0x110
   3ced0:	2200      	movs	r2, #0
   3ced2:	4629      	mov	r1, r5
   3ced4:	4620      	mov	r0, r4
   3ced6:	f7fe ffbf 	bl	3be58 <dwt_write32bitoffsetreg>
   3ceda:	e7ee      	b.n	3ceba <ull_setleds+0x6e>
   3cedc:	00110004 	.word	0x00110004
   3cee0:	00110018 	.word	0x00110018
   3cee4:	000f0110 	.word	0x000f0110

0003cee8 <ull_pgf_cal>:
   3cee8:	b5f0      	push	{r4, r5, r6, r7, lr}
   3ceea:	b083      	sub	sp, #12
   3ceec:	4604      	mov	r4, r0
   3ceee:	2901      	cmp	r1, #1
   3cef0:	d009      	beq.n	3cf06 <ull_pgf_cal+0x1e>
   3cef2:	2014      	movs	r0, #20
   3cef4:	f7f1 fc7b 	bl	2e7ee <deca_usleep>
   3cef8:	4620      	mov	r0, r4
   3cefa:	f7ff feaf 	bl	3cc5c <ull_run_pgfcal>
   3cefe:	4605      	mov	r5, r0
   3cf00:	4628      	mov	r0, r5
   3cf02:	b003      	add	sp, #12
   3cf04:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3cf06:	4e0f      	ldr	r6, [pc, #60]	; (3cf44 <ull_pgf_cal+0x5c>)
   3cf08:	2200      	movs	r2, #0
   3cf0a:	4631      	mov	r1, r6
   3cf0c:	f7fe fb45 	bl	3b59a <dwt_read16bitoffsetreg>
   3cf10:	4607      	mov	r7, r0
   3cf12:	f240 1307 	movw	r3, #263	; 0x107
   3cf16:	9300      	str	r3, [sp, #0]
   3cf18:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3cf1c:	2200      	movs	r2, #0
   3cf1e:	4631      	mov	r1, r6
   3cf20:	4620      	mov	r0, r4
   3cf22:	f7ff ff79 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cf26:	2014      	movs	r0, #20
   3cf28:	f7f1 fc61 	bl	2e7ee <deca_usleep>
   3cf2c:	4620      	mov	r0, r4
   3cf2e:	f7ff fe95 	bl	3cc5c <ull_run_pgfcal>
   3cf32:	4605      	mov	r5, r0
   3cf34:	2200      	movs	r2, #0
   3cf36:	9200      	str	r2, [sp, #0]
   3cf38:	463b      	mov	r3, r7
   3cf3a:	4631      	mov	r1, r6
   3cf3c:	4620      	mov	r0, r4
   3cf3e:	f7ff ff6b 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cf42:	e7dd      	b.n	3cf00 <ull_pgf_cal+0x18>
   3cf44:	00070048 	.word	0x00070048

0003cf48 <ull_setgpiovalue>:
   3cf48:	b500      	push	{lr}
   3cf4a:	b083      	sub	sp, #12
   3cf4c:	2a01      	cmp	r2, #1
   3cf4e:	d009      	beq.n	3cf64 <ull_setgpiovalue+0x1c>
   3cf50:	43cb      	mvns	r3, r1
   3cf52:	2200      	movs	r2, #0
   3cf54:	9200      	str	r2, [sp, #0]
   3cf56:	b29b      	uxth	r3, r3
   3cf58:	4906      	ldr	r1, [pc, #24]	; (3cf74 <ull_setgpiovalue+0x2c>)
   3cf5a:	f7ff ff5d 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cf5e:	b003      	add	sp, #12
   3cf60:	f85d fb04 	ldr.w	pc, [sp], #4
   3cf64:	9100      	str	r1, [sp, #0]
   3cf66:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3cf6a:	2200      	movs	r2, #0
   3cf6c:	4901      	ldr	r1, [pc, #4]	; (3cf74 <ull_setgpiovalue+0x2c>)
   3cf6e:	f7ff ff53 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cf72:	e7f4      	b.n	3cf5e <ull_setgpiovalue+0x16>
   3cf74:	0005000c 	.word	0x0005000c

0003cf78 <ull_readaccdata>:
   3cf78:	b5f0      	push	{r4, r5, r6, r7, lr}
   3cf7a:	b083      	sub	sp, #12
   3cf7c:	4604      	mov	r4, r0
   3cf7e:	460f      	mov	r7, r1
   3cf80:	4616      	mov	r6, r2
   3cf82:	461d      	mov	r5, r3
   3cf84:	f248 0340 	movw	r3, #32832	; 0x8040
   3cf88:	9300      	str	r3, [sp, #0]
   3cf8a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3cf8e:	2200      	movs	r2, #0
   3cf90:	4918      	ldr	r1, [pc, #96]	; (3cff4 <ull_readaccdata+0x7c>)
   3cf92:	f7ff ff41 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cf96:	19aa      	adds	r2, r5, r6
   3cf98:	f243 0301 	movw	r3, #12289	; 0x3001
   3cf9c:	429a      	cmp	r2, r3
   3cf9e:	dc15      	bgt.n	3cfcc <ull_readaccdata+0x54>
   3cfa0:	2d7f      	cmp	r5, #127	; 0x7f
   3cfa2:	d91d      	bls.n	3cfe0 <ull_readaccdata+0x68>
   3cfa4:	2315      	movs	r3, #21
   3cfa6:	2200      	movs	r2, #0
   3cfa8:	4913      	ldr	r1, [pc, #76]	; (3cff8 <ull_readaccdata+0x80>)
   3cfaa:	4620      	mov	r0, r4
   3cfac:	f7fe ff54 	bl	3be58 <dwt_write32bitoffsetreg>
   3cfb0:	462b      	mov	r3, r5
   3cfb2:	2200      	movs	r2, #0
   3cfb4:	4911      	ldr	r1, [pc, #68]	; (3cffc <ull_readaccdata+0x84>)
   3cfb6:	4620      	mov	r0, r4
   3cfb8:	f7fe ff4e 	bl	3be58 <dwt_write32bitoffsetreg>
   3cfbc:	9700      	str	r7, [sp, #0]
   3cfbe:	4633      	mov	r3, r6
   3cfc0:	2200      	movs	r2, #0
   3cfc2:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3cfc6:	4620      	mov	r0, r4
   3cfc8:	f7fe fac7 	bl	3b55a <dwt_readfromdevice>
   3cfcc:	2200      	movs	r2, #0
   3cfce:	9200      	str	r2, [sp, #0]
   3cfd0:	f647 73bf 	movw	r3, #32703	; 0x7fbf
   3cfd4:	4907      	ldr	r1, [pc, #28]	; (3cff4 <ull_readaccdata+0x7c>)
   3cfd6:	4620      	mov	r0, r4
   3cfd8:	f7ff ff1e 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3cfdc:	b003      	add	sp, #12
   3cfde:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3cfe0:	9700      	str	r7, [sp, #0]
   3cfe2:	4633      	mov	r3, r6
   3cfe4:	462a      	mov	r2, r5
   3cfe6:	f44f 11a8 	mov.w	r1, #1376256	; 0x150000
   3cfea:	4620      	mov	r0, r4
   3cfec:	f7fe fab5 	bl	3b55a <dwt_readfromdevice>
   3cff0:	e7ec      	b.n	3cfcc <ull_readaccdata+0x54>
   3cff2:	bf00      	nop
   3cff4:	00110004 	.word	0x00110004
   3cff8:	001f0004 	.word	0x001f0004
   3cffc:	001f0008 	.word	0x001f0008

0003d000 <ull_repeated_cw>:
   3d000:	b570      	push	{r4, r5, r6, lr}
   3d002:	4606      	mov	r6, r0
   3d004:	460c      	mov	r4, r1
   3d006:	4615      	mov	r5, r2
   3d008:	4b0e      	ldr	r3, [pc, #56]	; (3d044 <ull_repeated_cw+0x44>)
   3d00a:	2202      	movs	r2, #2
   3d00c:	490e      	ldr	r1, [pc, #56]	; (3d048 <ull_repeated_cw+0x48>)
   3d00e:	f7fe ff23 	bl	3be58 <dwt_write32bitoffsetreg>
   3d012:	2d0f      	cmp	r5, #15
   3d014:	bfa8      	it	ge
   3d016:	250f      	movge	r5, #15
   3d018:	1e63      	subs	r3, r4, #1
   3d01a:	2b03      	cmp	r3, #3
   3d01c:	bf28      	it	cs
   3d01e:	2404      	movcs	r4, #4
   3d020:	2310      	movs	r3, #16
   3d022:	4123      	asrs	r3, r4
   3d024:	2200      	movs	r2, #0
   3d026:	4909      	ldr	r1, [pc, #36]	; (3d04c <ull_repeated_cw+0x4c>)
   3d028:	4630      	mov	r0, r6
   3d02a:	f7fe ff15 	bl	3be58 <dwt_write32bitoffsetreg>
   3d02e:	1e63      	subs	r3, r4, #1
   3d030:	009b      	lsls	r3, r3, #2
   3d032:	fa05 f303 	lsl.w	r3, r5, r3
   3d036:	2200      	movs	r2, #0
   3d038:	4905      	ldr	r1, [pc, #20]	; (3d050 <ull_repeated_cw+0x50>)
   3d03a:	4630      	mov	r0, r6
   3d03c:	f7fe ff0c 	bl	3be58 <dwt_write32bitoffsetreg>
   3d040:	bd70      	pop	{r4, r5, r6, pc}
   3d042:	bf00      	nop
   3d044:	00d20874 	.word	0x00d20874
   3d048:	00110010 	.word	0x00110010
   3d04c:	00070028 	.word	0x00070028
   3d050:	00080018 	.word	0x00080018

0003d054 <ull_configure>:
   3d054:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3d058:	b083      	sub	sp, #12
   3d05a:	4604      	mov	r4, r0
   3d05c:	460d      	mov	r5, r1
   3d05e:	f891 9000 	ldrb.w	r9, [r1]
   3d062:	790b      	ldrb	r3, [r1, #4]
   3d064:	2b18      	cmp	r3, #24
   3d066:	d814      	bhi.n	3d092 <ull_configure+0x3e>
   3d068:	78cf      	ldrb	r7, [r1, #3]
   3d06a:	2f18      	cmp	r7, #24
   3d06c:	bf94      	ite	ls
   3d06e:	2700      	movls	r7, #0
   3d070:	2701      	movhi	r7, #1
   3d072:	b2ff      	uxtb	r7, r7
   3d074:	79eb      	ldrb	r3, [r5, #7]
   3d076:	2b01      	cmp	r3, #1
   3d078:	bf0c      	ite	eq
   3d07a:	2110      	moveq	r1, #16
   3d07c:	2100      	movne	r1, #0
   3d07e:	786b      	ldrb	r3, [r5, #1]
   3d080:	3b01      	subs	r3, #1
   3d082:	2b06      	cmp	r3, #6
   3d084:	d810      	bhi.n	3d0a8 <ull_configure+0x54>
   3d086:	e8df f003 	tbb	[pc, r3]
   3d08a:	0f06      	.short	0x0f06
   3d08c:	0f0c120f 	.word	0x0f0c120f
   3d090:	09          	.byte	0x09
   3d091:	00          	.byte	0x00
   3d092:	2701      	movs	r7, #1
   3d094:	e7ed      	b.n	3d072 <ull_configure+0x1e>
   3d096:	f04f 0a40 	mov.w	sl, #64	; 0x40
   3d09a:	e00a      	b.n	3d0b2 <ull_configure+0x5e>
   3d09c:	f04f 0a48 	mov.w	sl, #72	; 0x48
   3d0a0:	e007      	b.n	3d0b2 <ull_configure+0x5e>
   3d0a2:	f04f 0a80 	mov.w	sl, #128	; 0x80
   3d0a6:	e004      	b.n	3d0b2 <ull_configure+0x5e>
   3d0a8:	f44f 7a80 	mov.w	sl, #256	; 0x100
   3d0ac:	e001      	b.n	3d0b2 <ull_configure+0x5e>
   3d0ae:	f04f 0a20 	mov.w	sl, #32
   3d0b2:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d0b4:	8a13      	ldrh	r3, [r2, #16]
   3d0b6:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
   3d0ba:	8213      	strh	r3, [r2, #16]
   3d0bc:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3d0be:	79ea      	ldrb	r2, [r5, #7]
   3d0c0:	72da      	strb	r2, [r3, #11]
   3d0c2:	7b2e      	ldrb	r6, [r5, #12]
   3d0c4:	1cb3      	adds	r3, r6, #2
   3d0c6:	2601      	movs	r6, #1
   3d0c8:	409e      	lsls	r6, r3
   3d0ca:	fa1f f886 	uxth.w	r8, r6
   3d0ce:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d0d0:	4bca      	ldr	r3, [pc, #808]	; (3d3fc <ull_configure+0x3a8>)
   3d0d2:	fb03 f308 	mul.w	r3, r3, r8
   3d0d6:	0bdb      	lsrs	r3, r3, #15
   3d0d8:	8253      	strh	r3, [r2, #18]
   3d0da:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3d0dc:	7aea      	ldrb	r2, [r5, #11]
   3d0de:	755a      	strb	r2, [r3, #21]
   3d0e0:	7a2b      	ldrb	r3, [r5, #8]
   3d0e2:	015b      	lsls	r3, r3, #5
   3d0e4:	f003 0320 	and.w	r3, r3, #32
   3d0e8:	7b6a      	ldrb	r2, [r5, #13]
   3d0ea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   3d0ee:	7aea      	ldrb	r2, [r5, #11]
   3d0f0:	0312      	lsls	r2, r2, #12
   3d0f2:	f402 4230 	and.w	r2, r2, #45056	; 0xb000
   3d0f6:	4313      	orrs	r3, r2
   3d0f8:	430b      	orrs	r3, r1
   3d0fa:	9300      	str	r3, [sp, #0]
   3d0fc:	4bc0      	ldr	r3, [pc, #768]	; (3d400 <ull_configure+0x3ac>)
   3d0fe:	2200      	movs	r2, #0
   3d100:	2110      	movs	r1, #16
   3d102:	4620      	mov	r0, r4
   3d104:	f7ff fafa 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d108:	2f00      	cmp	r7, #0
   3d10a:	f040 80fc 	bne.w	3d306 <ull_configure+0x2b2>
   3d10e:	7aeb      	ldrb	r3, [r5, #11]
   3d110:	b1f3      	cbz	r3, 3d150 <ull_configure+0xfc>
   3d112:	7b6b      	ldrb	r3, [r5, #13]
   3d114:	2b01      	cmp	r3, #1
   3d116:	f240 8121 	bls.w	3d35c <ull_configure+0x308>
   3d11a:	7b2a      	ldrb	r2, [r5, #12]
   3d11c:	4bb9      	ldr	r3, [pc, #740]	; (3d404 <ull_configure+0x3b0>)
   3d11e:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
   3d122:	0112      	lsls	r2, r2, #4
   3d124:	0ad3      	lsrs	r3, r2, #11
   3d126:	f3c2 020a 	ubfx	r2, r2, #0, #11
   3d12a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3d12e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3d132:	bf28      	it	cs
   3d134:	3301      	addcs	r3, #1
   3d136:	b29b      	uxth	r3, r3
   3d138:	eb0a 0ac8 	add.w	sl, sl, r8, lsl #3
   3d13c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   3d140:	9300      	str	r3, [sp, #0]
   3d142:	f64f 7380 	movw	r3, #65408	; 0xff80
   3d146:	2202      	movs	r2, #2
   3d148:	49af      	ldr	r1, [pc, #700]	; (3d408 <ull_configure+0x3b4>)
   3d14a:	4620      	mov	r0, r4
   3d14c:	f7ff fe64 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d150:	2394      	movs	r3, #148	; 0x94
   3d152:	9300      	str	r3, [sp, #0]
   3d154:	4bad      	ldr	r3, [pc, #692]	; (3d40c <ull_configure+0x3b8>)
   3d156:	2200      	movs	r2, #0
   3d158:	49ad      	ldr	r1, [pc, #692]	; (3d410 <ull_configure+0x3bc>)
   3d15a:	4620      	mov	r0, r4
   3d15c:	f7ff face 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d160:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   3d164:	f340 810d 	ble.w	3d382 <ull_configure+0x32e>
   3d168:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d16a:	8a13      	ldrh	r3, [r2, #16]
   3d16c:	f043 0320 	orr.w	r3, r3, #32
   3d170:	8213      	strh	r3, [r2, #16]
   3d172:	f44f 6300 	mov.w	r3, #2048	; 0x800
   3d176:	9300      	str	r3, [sp, #0]
   3d178:	f64c 73ff 	movw	r3, #53247	; 0xcfff
   3d17c:	2200      	movs	r2, #0
   3d17e:	49a5      	ldr	r1, [pc, #660]	; (3d414 <ull_configure+0x3c0>)
   3d180:	4620      	mov	r0, r4
   3d182:	f7ff fe49 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d186:	7b6b      	ldrb	r3, [r5, #13]
   3d188:	2b01      	cmp	r3, #1
   3d18a:	f000 8105 	beq.w	3d398 <ull_configure+0x344>
   3d18e:	78ab      	ldrb	r3, [r5, #2]
   3d190:	f043 0310 	orr.w	r3, r3, #16
   3d194:	9300      	str	r3, [sp, #0]
   3d196:	23fc      	movs	r3, #252	; 0xfc
   3d198:	2200      	movs	r2, #0
   3d19a:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   3d19e:	4620      	mov	r0, r4
   3d1a0:	f7ff fc1e 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3d1a4:	1e73      	subs	r3, r6, #1
   3d1a6:	b2db      	uxtb	r3, r3
   3d1a8:	2200      	movs	r2, #0
   3d1aa:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   3d1ae:	4620      	mov	r0, r4
   3d1b0:	f7fe ffe0 	bl	3c174 <dwt_write8bitoffsetreg>
   3d1b4:	786b      	ldrb	r3, [r5, #1]
   3d1b6:	2b07      	cmp	r3, #7
   3d1b8:	bf0c      	ite	eq
   3d1ba:	2308      	moveq	r3, #8
   3d1bc:	2300      	movne	r3, #0
   3d1be:	2201      	movs	r2, #1
   3d1c0:	2124      	movs	r1, #36	; 0x24
   3d1c2:	4620      	mov	r0, r4
   3d1c4:	f7fe ffd6 	bl	3c174 <dwt_write8bitoffsetreg>
   3d1c8:	7aeb      	ldrb	r3, [r5, #11]
   3d1ca:	f003 0303 	and.w	r3, r3, #3
   3d1ce:	2b03      	cmp	r3, #3
   3d1d0:	bf0c      	ite	eq
   3d1d2:	4b91      	ldreq	r3, [pc, #580]	; (3d418 <ull_configure+0x3c4>)
   3d1d4:	4b91      	ldrne	r3, [pc, #580]	; (3d41c <ull_configure+0x3c8>)
   3d1d6:	2200      	movs	r2, #0
   3d1d8:	4991      	ldr	r1, [pc, #580]	; (3d420 <ull_configure+0x3cc>)
   3d1da:	4620      	mov	r0, r4
   3d1dc:	f7fe fe3c 	bl	3be58 <dwt_write32bitoffsetreg>
   3d1e0:	2200      	movs	r2, #0
   3d1e2:	4990      	ldr	r1, [pc, #576]	; (3d424 <ull_configure+0x3d0>)
   3d1e4:	4620      	mov	r0, r4
   3d1e6:	f7fe f9c2 	bl	3b56e <dwt_read32bitoffsetreg>
   3d1ea:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
   3d1ee:	f020 001f 	bic.w	r0, r0, #31
   3d1f2:	f1b9 0f09 	cmp.w	r9, #9
   3d1f6:	bf08      	it	eq
   3d1f8:	f040 0001 	orreq.w	r0, r0, #1
   3d1fc:	792a      	ldrb	r2, [r5, #4]
   3d1fe:	0212      	lsls	r2, r2, #8
   3d200:	f402 52f8 	and.w	r2, r2, #7936	; 0x1f00
   3d204:	78eb      	ldrb	r3, [r5, #3]
   3d206:	00db      	lsls	r3, r3, #3
   3d208:	b2db      	uxtb	r3, r3
   3d20a:	431a      	orrs	r2, r3
   3d20c:	796b      	ldrb	r3, [r5, #5]
   3d20e:	005b      	lsls	r3, r3, #1
   3d210:	f003 0306 	and.w	r3, r3, #6
   3d214:	4313      	orrs	r3, r2
   3d216:	4303      	orrs	r3, r0
   3d218:	2200      	movs	r2, #0
   3d21a:	4982      	ldr	r1, [pc, #520]	; (3d424 <ull_configure+0x3d0>)
   3d21c:	4620      	mov	r0, r4
   3d21e:	f7fe fe1b 	bl	3be58 <dwt_write32bitoffsetreg>
   3d222:	79aa      	ldrb	r2, [r5, #6]
   3d224:	786b      	ldrb	r3, [r5, #1]
   3d226:	031b      	lsls	r3, r3, #12
   3d228:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   3d22c:	9300      	str	r3, [sp, #0]
   3d22e:	f46f 4374 	mvn.w	r3, #62464	; 0xf400
   3d232:	2200      	movs	r2, #0
   3d234:	2120      	movs	r1, #32
   3d236:	4620      	mov	r0, r4
   3d238:	f7ff fa60 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d23c:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   3d240:	b923      	cbnz	r3, 3d24c <ull_configure+0x1f8>
   3d242:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   3d246:	726b      	strb	r3, [r5, #9]
   3d248:	2300      	movs	r3, #0
   3d24a:	72ab      	strb	r3, [r5, #10]
   3d24c:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   3d250:	2202      	movs	r2, #2
   3d252:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   3d256:	4620      	mov	r0, r4
   3d258:	f7fe fda1 	bl	3bd9e <dwt_write16bitoffsetreg>
   3d25c:	2202      	movs	r2, #2
   3d25e:	4972      	ldr	r1, [pc, #456]	; (3d428 <ull_configure+0x3d4>)
   3d260:	4620      	mov	r0, r4
   3d262:	f7fe f9ac 	bl	3b5be <dwt_read8bitoffsetreg>
   3d266:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3d268:	7bdb      	ldrb	r3, [r3, #15]
   3d26a:	454b      	cmp	r3, r9
   3d26c:	f000 809e 	beq.w	3d3ac <ull_configure+0x358>
   3d270:	2803      	cmp	r0, #3
   3d272:	f000 809f 	beq.w	3d3b4 <ull_configure+0x360>
   3d276:	f1b9 0f09 	cmp.w	r9, #9
   3d27a:	f000 80a0 	beq.w	3d3be <ull_configure+0x36a>
   3d27e:	4b6b      	ldr	r3, [pc, #428]	; (3d42c <ull_configure+0x3d8>)
   3d280:	2200      	movs	r2, #0
   3d282:	496b      	ldr	r1, [pc, #428]	; (3d430 <ull_configure+0x3dc>)
   3d284:	4620      	mov	r0, r4
   3d286:	f7fe fde7 	bl	3be58 <dwt_write32bitoffsetreg>
   3d28a:	f641 733c 	movw	r3, #7996	; 0x1f3c
   3d28e:	2200      	movs	r2, #0
   3d290:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   3d294:	4620      	mov	r0, r4
   3d296:	f7fe fd82 	bl	3bd9e <dwt_write16bitoffsetreg>
   3d29a:	2314      	movs	r3, #20
   3d29c:	2201      	movs	r2, #1
   3d29e:	4965      	ldr	r1, [pc, #404]	; (3d434 <ull_configure+0x3e0>)
   3d2a0:	4620      	mov	r0, r4
   3d2a2:	f7fe ff67 	bl	3c174 <dwt_write8bitoffsetreg>
   3d2a6:	230e      	movs	r3, #14
   3d2a8:	2202      	movs	r2, #2
   3d2aa:	4963      	ldr	r1, [pc, #396]	; (3d438 <ull_configure+0x3e4>)
   3d2ac:	4620      	mov	r0, r4
   3d2ae:	f7fe ff61 	bl	3c174 <dwt_write8bitoffsetreg>
   3d2b2:	2381      	movs	r3, #129	; 0x81
   3d2b4:	2200      	movs	r2, #0
   3d2b6:	4961      	ldr	r1, [pc, #388]	; (3d43c <ull_configure+0x3e8>)
   3d2b8:	4620      	mov	r0, r4
   3d2ba:	f7fe ff5b 	bl	3c174 <dwt_write8bitoffsetreg>
   3d2be:	2302      	movs	r3, #2
   3d2c0:	2200      	movs	r2, #0
   3d2c2:	2144      	movs	r1, #68	; 0x44
   3d2c4:	4620      	mov	r0, r4
   3d2c6:	f7fe ff55 	bl	3c174 <dwt_write8bitoffsetreg>
   3d2ca:	2101      	movs	r1, #1
   3d2cc:	4620      	mov	r0, r4
   3d2ce:	f7ff fc45 	bl	3cb5c <ull_setdwstate>
   3d2d2:	f04f 0b32 	mov.w	fp, #50	; 0x32
   3d2d6:	f04f 0814 	mov.w	r8, #20
   3d2da:	2700      	movs	r7, #0
   3d2dc:	2644      	movs	r6, #68	; 0x44
   3d2de:	4640      	mov	r0, r8
   3d2e0:	f7f1 fa85 	bl	2e7ee <deca_usleep>
   3d2e4:	463a      	mov	r2, r7
   3d2e6:	4631      	mov	r1, r6
   3d2e8:	4620      	mov	r0, r4
   3d2ea:	f7fe f968 	bl	3b5be <dwt_read8bitoffsetreg>
   3d2ee:	f010 0f02 	tst.w	r0, #2
   3d2f2:	f040 80b5 	bne.w	3d460 <ull_configure+0x40c>
   3d2f6:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   3d2fa:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   3d2fe:	d1ee      	bne.n	3d2de <ull_configure+0x28a>
   3d300:	f06f 0001 	mvn.w	r0, #1
   3d304:	e0de      	b.n	3d4c4 <ull_configure+0x470>
   3d306:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d308:	8a13      	ldrh	r3, [r2, #16]
   3d30a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   3d30e:	8213      	strh	r3, [r2, #16]
   3d310:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   3d314:	9300      	str	r3, [sp, #0]
   3d316:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
   3d31a:	2200      	movs	r2, #0
   3d31c:	493d      	ldr	r1, [pc, #244]	; (3d414 <ull_configure+0x3c0>)
   3d31e:	4620      	mov	r0, r4
   3d320:	f7ff f9ec 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d324:	f240 3306 	movw	r3, #774	; 0x306
   3d328:	2200      	movs	r2, #0
   3d32a:	4945      	ldr	r1, [pc, #276]	; (3d440 <ull_configure+0x3ec>)
   3d32c:	4620      	mov	r0, r4
   3d32e:	f7fe fd93 	bl	3be58 <dwt_write32bitoffsetreg>
   3d332:	2300      	movs	r3, #0
   3d334:	461a      	mov	r2, r3
   3d336:	4943      	ldr	r1, [pc, #268]	; (3d444 <ull_configure+0x3f0>)
   3d338:	4620      	mov	r0, r4
   3d33a:	f7fe fd8d 	bl	3be58 <dwt_write32bitoffsetreg>
   3d33e:	4b42      	ldr	r3, [pc, #264]	; (3d448 <ull_configure+0x3f4>)
   3d340:	2200      	movs	r2, #0
   3d342:	4931      	ldr	r1, [pc, #196]	; (3d408 <ull_configure+0x3b4>)
   3d344:	4620      	mov	r0, r4
   3d346:	f7fe fd87 	bl	3be58 <dwt_write32bitoffsetreg>
   3d34a:	239d      	movs	r3, #157	; 0x9d
   3d34c:	9300      	str	r3, [sp, #0]
   3d34e:	4b2f      	ldr	r3, [pc, #188]	; (3d40c <ull_configure+0x3b8>)
   3d350:	2200      	movs	r2, #0
   3d352:	492f      	ldr	r1, [pc, #188]	; (3d410 <ull_configure+0x3bc>)
   3d354:	4620      	mov	r0, r4
   3d356:	f7ff f9d1 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d35a:	e714      	b.n	3d186 <ull_configure+0x132>
   3d35c:	7b2a      	ldrb	r2, [r5, #12]
   3d35e:	4b29      	ldr	r3, [pc, #164]	; (3d404 <ull_configure+0x3b0>)
   3d360:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   3d364:	f44f 6235 	mov.w	r2, #2896	; 0xb50
   3d368:	fb02 f203 	mul.w	r2, r2, r3
   3d36c:	0c93      	lsrs	r3, r2, #18
   3d36e:	f3c2 12ca 	ubfx	r2, r2, #7, #11
   3d372:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3d376:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3d37a:	bf28      	it	cs
   3d37c:	3301      	addcs	r3, #1
   3d37e:	b29b      	uxth	r3, r3
   3d380:	e6da      	b.n	3d138 <ull_configure+0xe4>
   3d382:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   3d386:	9300      	str	r3, [sp, #0]
   3d388:	f64c 73ff 	movw	r3, #53247	; 0xcfff
   3d38c:	2200      	movs	r2, #0
   3d38e:	4921      	ldr	r1, [pc, #132]	; (3d414 <ull_configure+0x3c0>)
   3d390:	4620      	mov	r0, r4
   3d392:	f7ff fd41 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d396:	e6f6      	b.n	3d186 <ull_configure+0x132>
   3d398:	78ab      	ldrb	r3, [r5, #2]
   3d39a:	9300      	str	r3, [sp, #0]
   3d39c:	23ec      	movs	r3, #236	; 0xec
   3d39e:	2200      	movs	r2, #0
   3d3a0:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   3d3a4:	4620      	mov	r0, r4
   3d3a6:	f7ff fb1b 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3d3aa:	e6fb      	b.n	3d1a4 <ull_configure+0x150>
   3d3ac:	2803      	cmp	r0, #3
   3d3ae:	f47f af62 	bne.w	3d276 <ull_configure+0x222>
   3d3b2:	e058      	b.n	3d466 <ull_configure+0x412>
   3d3b4:	2102      	movs	r1, #2
   3d3b6:	4620      	mov	r0, r4
   3d3b8:	f7ff fbd0 	bl	3cb5c <ull_setdwstate>
   3d3bc:	e75b      	b.n	3d276 <ull_configure+0x222>
   3d3be:	4b23      	ldr	r3, [pc, #140]	; (3d44c <ull_configure+0x3f8>)
   3d3c0:	2200      	movs	r2, #0
   3d3c2:	491b      	ldr	r1, [pc, #108]	; (3d430 <ull_configure+0x3dc>)
   3d3c4:	4620      	mov	r0, r4
   3d3c6:	f7fe fd47 	bl	3be58 <dwt_write32bitoffsetreg>
   3d3ca:	f640 733c 	movw	r3, #3900	; 0xf3c
   3d3ce:	2200      	movs	r2, #0
   3d3d0:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   3d3d4:	4620      	mov	r0, r4
   3d3d6:	f7fe fce2 	bl	3bd9e <dwt_write16bitoffsetreg>
   3d3da:	e75e      	b.n	3d29a <ull_configure+0x246>
   3d3dc:	f44f 7380 	mov.w	r3, #256	; 0x100
   3d3e0:	9300      	str	r3, [sp, #0]
   3d3e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3d3e6:	2200      	movs	r2, #0
   3d3e8:	490a      	ldr	r1, [pc, #40]	; (3d414 <ull_configure+0x3c0>)
   3d3ea:	4620      	mov	r0, r4
   3d3ec:	f7ff fd14 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d3f0:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d3f2:	8a13      	ldrh	r3, [r2, #16]
   3d3f4:	f043 0308 	orr.w	r3, r3, #8
   3d3f8:	8213      	strh	r3, [r2, #16]
   3d3fa:	e046      	b.n	3d48a <ull_configure+0x436>
   3d3fc:	00026668 	.word	0x00026668
   3d400:	fffc4fcf 	.word	0xfffc4fcf
   3d404:	00046f6c 	.word	0x00046f6c
   3d408:	000e0014 	.word	0x000e0014
   3d40c:	bfffff00 	.word	0xbfffff00
   3d410:	000e0018 	.word	0x000e0018
   3d414:	000b0008 	.word	0x000b0008
   3d418:	af5f35cc 	.word	0xaf5f35cc
   3d41c:	af5f584c 	.word	0xaf5f584c
   3d420:	0006000c 	.word	0x0006000c
   3d424:	00010008 	.word	0x00010008
   3d428:	000f0030 	.word	0x000f0030
   3d42c:	1c071134 	.word	0x1c071134
   3d430:	0007001c 	.word	0x0007001c
   3d434:	00070050 	.word	0x00070050
   3d438:	00070018 	.word	0x00070018
   3d43c:	00090008 	.word	0x00090008
   3d440:	000e000c 	.word	0x000e000c
   3d444:	000e0010 	.word	0x000e0010
   3d448:	000c5a0a 	.word	0x000c5a0a
   3d44c:	1c010034 	.word	0x1c010034
   3d450:	2200      	movs	r2, #0
   3d452:	9200      	str	r2, [sp, #0]
   3d454:	23fe      	movs	r3, #254	; 0xfe
   3d456:	491d      	ldr	r1, [pc, #116]	; (3d4cc <ull_configure+0x478>)
   3d458:	4620      	mov	r0, r4
   3d45a:	f7ff fac1 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3d45e:	e01e      	b.n	3d49e <ull_configure+0x44a>
   3d460:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3d462:	f883 900f 	strb.w	r9, [r3, #15]
   3d466:	792b      	ldrb	r3, [r5, #4]
   3d468:	3b09      	subs	r3, #9
   3d46a:	b2db      	uxtb	r3, r3
   3d46c:	2b0f      	cmp	r3, #15
   3d46e:	d8ef      	bhi.n	3d450 <ull_configure+0x3fc>
   3d470:	6d23      	ldr	r3, [r4, #80]	; 0x50
   3d472:	7a1b      	ldrb	r3, [r3, #8]
   3d474:	2b01      	cmp	r3, #1
   3d476:	d0b1      	beq.n	3d3dc <ull_configure+0x388>
   3d478:	4649      	mov	r1, r9
   3d47a:	4620      	mov	r0, r4
   3d47c:	f7fe fda4 	bl	3bfc8 <ull_configmrxlut>
   3d480:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3d482:	8a13      	ldrh	r3, [r2, #16]
   3d484:	f023 0308 	bic.w	r3, r3, #8
   3d488:	8213      	strh	r3, [r2, #16]
   3d48a:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
   3d48e:	9300      	str	r3, [sp, #0]
   3d490:	f248 13ff 	movw	r3, #33279	; 0x81ff
   3d494:	2200      	movs	r2, #0
   3d496:	490d      	ldr	r1, [pc, #52]	; (3d4cc <ull_configure+0x478>)
   3d498:	4620      	mov	r0, r4
   3d49a:	f7ff fcbd 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d49e:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
   3d4a2:	bfcc      	ite	gt
   3d4a4:	f04f 5300 	movgt.w	r3, #536870912	; 0x20000000
   3d4a8:	f04f 53a0 	movle.w	r3, #335544320	; 0x14000000
   3d4ac:	9300      	str	r3, [sp, #0]
   3d4ae:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   3d4b2:	2200      	movs	r2, #0
   3d4b4:	4906      	ldr	r1, [pc, #24]	; (3d4d0 <ull_configure+0x47c>)
   3d4b6:	4620      	mov	r0, r4
   3d4b8:	f7ff f920 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3d4bc:	2101      	movs	r1, #1
   3d4be:	4620      	mov	r0, r4
   3d4c0:	f7ff fd12 	bl	3cee8 <ull_pgf_cal>
   3d4c4:	b003      	add	sp, #12
   3d4c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3d4ca:	bf00      	nop
   3d4cc:	00030018 	.word	0x00030018
   3d4d0:	00060010 	.word	0x00060010

0003d4d4 <ull_initialise>:
   3d4d4:	b5f0      	push	{r4, r5, r6, r7, lr}
   3d4d6:	b083      	sub	sp, #12
   3d4d8:	4605      	mov	r5, r0
   3d4da:	460e      	mov	r6, r1
   3d4dc:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3d4de:	2b00      	cmp	r3, #0
   3d4e0:	d051      	beq.n	3d586 <ull_initialise+0xb2>
   3d4e2:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   3d4e4:	2300      	movs	r3, #0
   3d4e6:	73a3      	strb	r3, [r4, #14]
   3d4e8:	2202      	movs	r2, #2
   3d4ea:	8222      	strh	r2, [r4, #16]
   3d4ec:	7523      	strb	r3, [r4, #20]
   3d4ee:	7563      	strb	r3, [r4, #21]
   3d4f0:	73e3      	strb	r3, [r4, #15]
   3d4f2:	7263      	strb	r3, [r4, #9]
   3d4f4:	72a3      	strb	r3, [r4, #10]
   3d4f6:	2104      	movs	r1, #4
   3d4f8:	4628      	mov	r0, r5
   3d4fa:	f7fe fc8b 	bl	3be14 <_dwt_otpread>
   3d4fe:	4607      	mov	r7, r0
   3d500:	2105      	movs	r1, #5
   3d502:	4628      	mov	r0, r5
   3d504:	f7fe fc86 	bl	3be14 <_dwt_otpread>
   3d508:	b10f      	cbz	r7, 3d50e <ull_initialise+0x3a>
   3d50a:	2800      	cmp	r0, #0
   3d50c:	d140      	bne.n	3d590 <ull_initialise+0xbc>
   3d50e:	2120      	movs	r1, #32
   3d510:	4628      	mov	r0, r5
   3d512:	f7fe fc7f 	bl	3be14 <_dwt_otpread>
   3d516:	4b35      	ldr	r3, [pc, #212]	; (3d5ec <ull_initialise+0x118>)
   3d518:	4298      	cmp	r0, r3
   3d51a:	bf0c      	ite	eq
   3d51c:	2301      	moveq	r3, #1
   3d51e:	2300      	movne	r3, #0
   3d520:	7223      	strb	r3, [r4, #8]
   3d522:	f016 0f10 	tst.w	r6, #16
   3d526:	d142      	bne.n	3d5ae <ull_initialise+0xda>
   3d528:	f016 0f20 	tst.w	r6, #32
   3d52c:	d145      	bne.n	3d5ba <ull_initialise+0xe6>
   3d52e:	f016 0f40 	tst.w	r6, #64	; 0x40
   3d532:	d148      	bne.n	3d5c6 <ull_initialise+0xf2>
   3d534:	f016 0f80 	tst.w	r6, #128	; 0x80
   3d538:	d14c      	bne.n	3d5d4 <ull_initialise+0x100>
   3d53a:	7aa3      	ldrb	r3, [r4, #10]
   3d53c:	b90b      	cbnz	r3, 3d542 <ull_initialise+0x6e>
   3d53e:	2385      	movs	r3, #133	; 0x85
   3d540:	72a3      	strb	r3, [r4, #10]
   3d542:	7a63      	ldrb	r3, [r4, #9]
   3d544:	b90b      	cbnz	r3, 3d54a <ull_initialise+0x76>
   3d546:	2374      	movs	r3, #116	; 0x74
   3d548:	7263      	strb	r3, [r4, #9]
   3d54a:	211f      	movs	r1, #31
   3d54c:	4628      	mov	r0, r5
   3d54e:	f7fe fc61 	bl	3be14 <_dwt_otpread>
   3d552:	7320      	strb	r0, [r4, #12]
   3d554:	211e      	movs	r1, #30
   3d556:	4628      	mov	r0, r5
   3d558:	f7fe fc5c 	bl	3be14 <_dwt_otpread>
   3d55c:	f010 003f 	ands.w	r0, r0, #63	; 0x3f
   3d560:	bf12      	itee	ne
   3d562:	7360      	strbne	r0, [r4, #13]
   3d564:	232e      	moveq	r3, #46	; 0x2e
   3d566:	7363      	strbeq	r3, [r4, #13]
   3d568:	7b63      	ldrb	r3, [r4, #13]
   3d56a:	2200      	movs	r2, #0
   3d56c:	4920      	ldr	r1, [pc, #128]	; (3d5f0 <ull_initialise+0x11c>)
   3d56e:	4628      	mov	r0, r5
   3d570:	f7fe fe00 	bl	3c174 <dwt_write8bitoffsetreg>
   3d574:	2135      	movs	r1, #53	; 0x35
   3d576:	4628      	mov	r0, r5
   3d578:	f7fe fc4c 	bl	3be14 <_dwt_otpread>
   3d57c:	4603      	mov	r3, r0
   3d57e:	bb78      	cbnz	r0, 3d5e0 <ull_initialise+0x10c>
   3d580:	2000      	movs	r0, #0
   3d582:	b003      	add	sp, #12
   3d584:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3d586:	2028      	movs	r0, #40	; 0x28
   3d588:	f7f3 fbce 	bl	30d28 <malloc>
   3d58c:	6528      	str	r0, [r5, #80]	; 0x50
   3d58e:	e7a8      	b.n	3d4e2 <ull_initialise+0xe>
   3d590:	f44f 7300 	mov.w	r3, #512	; 0x200
   3d594:	9300      	str	r3, [sp, #0]
   3d596:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3d59a:	2200      	movs	r2, #0
   3d59c:	4915      	ldr	r1, [pc, #84]	; (3d5f4 <ull_initialise+0x120>)
   3d59e:	4628      	mov	r0, r5
   3d5a0:	f7ff fc3a 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3d5a4:	8a23      	ldrh	r3, [r4, #16]
   3d5a6:	f043 0310 	orr.w	r3, r3, #16
   3d5aa:	8223      	strh	r3, [r4, #16]
   3d5ac:	e7af      	b.n	3d50e <ull_initialise+0x3a>
   3d5ae:	2106      	movs	r1, #6
   3d5b0:	4628      	mov	r0, r5
   3d5b2:	f7fe fc2f 	bl	3be14 <_dwt_otpread>
   3d5b6:	6020      	str	r0, [r4, #0]
   3d5b8:	e7b6      	b.n	3d528 <ull_initialise+0x54>
   3d5ba:	2107      	movs	r1, #7
   3d5bc:	4628      	mov	r0, r5
   3d5be:	f7fe fc29 	bl	3be14 <_dwt_otpread>
   3d5c2:	6060      	str	r0, [r4, #4]
   3d5c4:	e7b3      	b.n	3d52e <ull_initialise+0x5a>
   3d5c6:	2108      	movs	r1, #8
   3d5c8:	4628      	mov	r0, r5
   3d5ca:	f7fe fc23 	bl	3be14 <_dwt_otpread>
   3d5ce:	0c00      	lsrs	r0, r0, #16
   3d5d0:	7260      	strb	r0, [r4, #9]
   3d5d2:	e7af      	b.n	3d534 <ull_initialise+0x60>
   3d5d4:	2109      	movs	r1, #9
   3d5d6:	4628      	mov	r0, r5
   3d5d8:	f7fe fc1c 	bl	3be14 <_dwt_otpread>
   3d5dc:	72a0      	strb	r0, [r4, #10]
   3d5de:	e7ac      	b.n	3d53a <ull_initialise+0x66>
   3d5e0:	2200      	movs	r2, #0
   3d5e2:	4905      	ldr	r1, [pc, #20]	; (3d5f8 <ull_initialise+0x124>)
   3d5e4:	4628      	mov	r0, r5
   3d5e6:	f7fe fc37 	bl	3be58 <dwt_write32bitoffsetreg>
   3d5ea:	e7c9      	b.n	3d580 <ull_initialise+0xac>
   3d5ec:	10000240 	.word	0x10000240
   3d5f0:	00090014 	.word	0x00090014
   3d5f4:	000b0008 	.word	0x000b0008
   3d5f8:	00090004 	.word	0x00090004

0003d5fc <ull_rxenable>:
   3d5fc:	b530      	push	{r4, r5, lr}
   3d5fe:	b083      	sub	sp, #12
   3d600:	4605      	mov	r5, r0
   3d602:	460c      	mov	r4, r1
   3d604:	b171      	cbz	r1, 3d624 <ull_rxenable+0x28>
   3d606:	f021 0302 	bic.w	r3, r1, #2
   3d60a:	3b01      	subs	r3, #1
   3d60c:	2b0f      	cmp	r3, #15
   3d60e:	d862      	bhi.n	3d6d6 <ull_rxenable+0xda>
   3d610:	e8df f003 	tbb	[pc, r3]
   3d614:	24616111 	.word	0x24616111
   3d618:	2d616161 	.word	0x2d616161
   3d61c:	61616161 	.word	0x61616161
   3d620:	3a616161 	.word	0x3a616161
   3d624:	2102      	movs	r1, #2
   3d626:	9101      	str	r1, [sp, #4]
   3d628:	2200      	movs	r2, #0
   3d62a:	9200      	str	r2, [sp, #0]
   3d62c:	4613      	mov	r3, r2
   3d62e:	f7fd ff16 	bl	3b45e <dwt_xfer3xxx>
   3d632:	4620      	mov	r0, r4
   3d634:	e010      	b.n	3d658 <ull_rxenable+0x5c>
   3d636:	2302      	movs	r3, #2
   3d638:	9301      	str	r3, [sp, #4]
   3d63a:	2200      	movs	r2, #0
   3d63c:	9200      	str	r2, [sp, #0]
   3d63e:	4613      	mov	r3, r2
   3d640:	2104      	movs	r1, #4
   3d642:	f7fd ff0c 	bl	3b45e <dwt_xfer3xxx>
   3d646:	2203      	movs	r2, #3
   3d648:	2144      	movs	r1, #68	; 0x44
   3d64a:	4628      	mov	r0, r5
   3d64c:	f7fd ffb7 	bl	3b5be <dwt_read8bitoffsetreg>
   3d650:	f010 0f08 	tst.w	r0, #8
   3d654:	d125      	bne.n	3d6a2 <ull_rxenable+0xa6>
   3d656:	2000      	movs	r0, #0
   3d658:	b003      	add	sp, #12
   3d65a:	bd30      	pop	{r4, r5, pc}
   3d65c:	2302      	movs	r3, #2
   3d65e:	9301      	str	r3, [sp, #4]
   3d660:	2200      	movs	r2, #0
   3d662:	9200      	str	r2, [sp, #0]
   3d664:	4613      	mov	r3, r2
   3d666:	210a      	movs	r1, #10
   3d668:	f7fd fef9 	bl	3b45e <dwt_xfer3xxx>
   3d66c:	e7eb      	b.n	3d646 <ull_rxenable+0x4a>
   3d66e:	2100      	movs	r1, #0
   3d670:	f7fe fc07 	bl	3be82 <_dwt_adjust_delaytime>
   3d674:	2302      	movs	r3, #2
   3d676:	9301      	str	r3, [sp, #4]
   3d678:	2200      	movs	r2, #0
   3d67a:	9200      	str	r2, [sp, #0]
   3d67c:	4613      	mov	r3, r2
   3d67e:	2108      	movs	r1, #8
   3d680:	4628      	mov	r0, r5
   3d682:	f7fd feec 	bl	3b45e <dwt_xfer3xxx>
   3d686:	e7de      	b.n	3d646 <ull_rxenable+0x4a>
   3d688:	2101      	movs	r1, #1
   3d68a:	f7fe fbfa 	bl	3be82 <_dwt_adjust_delaytime>
   3d68e:	2302      	movs	r3, #2
   3d690:	9301      	str	r3, [sp, #4]
   3d692:	2200      	movs	r2, #0
   3d694:	9200      	str	r2, [sp, #0]
   3d696:	4613      	mov	r3, r2
   3d698:	2106      	movs	r1, #6
   3d69a:	4628      	mov	r0, r5
   3d69c:	f7fd fedf 	bl	3b45e <dwt_xfer3xxx>
   3d6a0:	e7d1      	b.n	3d646 <ull_rxenable+0x4a>
   3d6a2:	2302      	movs	r3, #2
   3d6a4:	9301      	str	r3, [sp, #4]
   3d6a6:	2100      	movs	r1, #0
   3d6a8:	9100      	str	r1, [sp, #0]
   3d6aa:	460b      	mov	r3, r1
   3d6ac:	460a      	mov	r2, r1
   3d6ae:	4628      	mov	r0, r5
   3d6b0:	f7fd fed5 	bl	3b45e <dwt_xfer3xxx>
   3d6b4:	f014 0f02 	tst.w	r4, #2
   3d6b8:	d002      	beq.n	3d6c0 <ull_rxenable+0xc4>
   3d6ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3d6be:	e7cb      	b.n	3d658 <ull_rxenable+0x5c>
   3d6c0:	2102      	movs	r1, #2
   3d6c2:	9101      	str	r1, [sp, #4]
   3d6c4:	2200      	movs	r2, #0
   3d6c6:	9200      	str	r2, [sp, #0]
   3d6c8:	4613      	mov	r3, r2
   3d6ca:	4628      	mov	r0, r5
   3d6cc:	f7fd fec7 	bl	3b45e <dwt_xfer3xxx>
   3d6d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3d6d4:	e7c0      	b.n	3d658 <ull_rxenable+0x5c>
   3d6d6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   3d6da:	e7bd      	b.n	3d658 <ull_rxenable+0x5c>

0003d6dc <ull_softreset_no_sema_fcmd>:
   3d6dc:	b570      	push	{r4, r5, r6, lr}
   3d6de:	b082      	sub	sp, #8
   3d6e0:	4606      	mov	r6, r0
   3d6e2:	2502      	movs	r5, #2
   3d6e4:	9501      	str	r5, [sp, #4]
   3d6e6:	2400      	movs	r4, #0
   3d6e8:	9400      	str	r4, [sp, #0]
   3d6ea:	4623      	mov	r3, r4
   3d6ec:	4622      	mov	r2, r4
   3d6ee:	2119      	movs	r1, #25
   3d6f0:	f7fd feb5 	bl	3b45e <dwt_xfer3xxx>
   3d6f4:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3d6f6:	739c      	strb	r4, [r3, #14]
   3d6f8:	821d      	strh	r5, [r3, #16]
   3d6fa:	751c      	strb	r4, [r3, #20]
   3d6fc:	755c      	strb	r4, [r3, #21]
   3d6fe:	73dc      	strb	r4, [r3, #15]
   3d700:	b002      	add	sp, #8
   3d702:	bd70      	pop	{r4, r5, r6, pc}

0003d704 <ull_softreset_fcmd>:
   3d704:	b570      	push	{r4, r5, r6, lr}
   3d706:	b082      	sub	sp, #8
   3d708:	4606      	mov	r6, r0
   3d70a:	2502      	movs	r5, #2
   3d70c:	9501      	str	r5, [sp, #4]
   3d70e:	2400      	movs	r4, #0
   3d710:	9400      	str	r4, [sp, #0]
   3d712:	4623      	mov	r3, r4
   3d714:	4622      	mov	r2, r4
   3d716:	2118      	movs	r1, #24
   3d718:	f7fd fea1 	bl	3b45e <dwt_xfer3xxx>
   3d71c:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3d71e:	739c      	strb	r4, [r3, #14]
   3d720:	821d      	strh	r5, [r3, #16]
   3d722:	751c      	strb	r4, [r3, #20]
   3d724:	755c      	strb	r4, [r3, #21]
   3d726:	73dc      	strb	r4, [r3, #15]
   3d728:	b002      	add	sp, #8
   3d72a:	bd70      	pop	{r4, r5, r6, pc}

0003d72c <dwt_ioctl>:
   3d72c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   3d730:	b091      	sub	sp, #68	; 0x44
   3d732:	4606      	mov	r6, r0
   3d734:	4615      	mov	r5, r2
   3d736:	461c      	mov	r4, r3
   3d738:	299c      	cmp	r1, #156	; 0x9c
   3d73a:	f200 809f 	bhi.w	3d87c <dwt_ioctl+0x150>
   3d73e:	e8df f011 	tbh	[pc, r1, lsl #1]
   3d742:	0a54      	.short	0x0a54
   3d744:	00a30a5f 	.word	0x00a30a5f
   3d748:	00c000a7 	.word	0x00c000a7
   3d74c:	0192014c 	.word	0x0192014c
   3d750:	0156016f 	.word	0x0156016f
   3d754:	01ad01a2 	.word	0x01ad01a2
   3d758:	01bd01b5 	.word	0x01bd01b5
   3d75c:	01cd01c5 	.word	0x01cd01c5
   3d760:	01d901d5 	.word	0x01d901d5
   3d764:	027201e1 	.word	0x027201e1
   3d768:	02850280 	.word	0x02850280
   3d76c:	0294028f 	.word	0x0294028f
   3d770:	02a20299 	.word	0x02a20299
   3d774:	02dd02a7 	.word	0x02dd02a7
   3d778:	030502fa 	.word	0x030502fa
   3d77c:	031a0310 	.word	0x031a0310
   3d780:	03480352 	.word	0x03480352
   3d784:	0324033e 	.word	0x0324033e
   3d788:	03810331 	.word	0x03810331
   3d78c:	022f01fc 	.word	0x022f01fc
   3d790:	0245023d 	.word	0x0245023d
   3d794:	097d0259 	.word	0x097d0259
   3d798:	03610982 	.word	0x03610982
   3d79c:	03a3039f 	.word	0x03a3039f
   3d7a0:	03b103ac 	.word	0x03b103ac
   3d7a4:	03e503db 	.word	0x03e503db
   3d7a8:	041703ed 	.word	0x041703ed
   3d7ac:	042e0423 	.word	0x042e0423
   3d7b0:	04390357 	.word	0x04390357
   3d7b4:	04540442 	.word	0x04540442
   3d7b8:	047e046d 	.word	0x047e046d
   3d7bc:	04ca04c0 	.word	0x04ca04c0
   3d7c0:	04ff04f0 	.word	0x04ff04f0
   3d7c4:	0508051a 	.word	0x0508051a
   3d7c8:	056a0524 	.word	0x056a0524
   3d7cc:	05a20582 	.word	0x05a20582
   3d7d0:	05e505d1 	.word	0x05e505d1
   3d7d4:	060a05ee 	.word	0x060a05ee
   3d7d8:	074305f7 	.word	0x074305f7
   3d7dc:	07d30785 	.word	0x07d30785
   3d7e0:	07e407d9 	.word	0x07e407d9
   3d7e4:	081d07fd 	.word	0x081d07fd
   3d7e8:	08310827 	.word	0x08310827
   3d7ec:	0868085f 	.word	0x0868085f
   3d7f0:	0877086e 	.word	0x0877086e
   3d7f4:	08910884 	.word	0x08910884
   3d7f8:	08a4089b 	.word	0x08a4089b
   3d7fc:	08b808ad 	.word	0x08b808ad
   3d800:	08c908c3 	.word	0x08c908c3
   3d804:	08f708ec 	.word	0x08f708ec
   3d808:	090d0902 	.word	0x090d0902
   3d80c:	0959094e 	.word	0x0959094e
   3d810:	09880972 	.word	0x09880972
   3d814:	0a0709fd 	.word	0x0a0709fd
   3d818:	0a670a12 	.word	0x0a670a12
   3d81c:	0a490a1c 	.word	0x0a490a1c
   3d820:	09c60777 	.word	0x09c60777
   3d824:	0ad509e7 	.word	0x0ad509e7
   3d828:	0a740aca 	.word	0x0a740aca
   3d82c:	0a8a0a7f 	.word	0x0a8a0a7f
   3d830:	0aa00a95 	.word	0x0aa00a95
   3d834:	0ab60aab 	.word	0x0ab60aab
   3d838:	0cb50abf 	.word	0x0cb50abf
   3d83c:	0d2a0cef 	.word	0x0d2a0cef
   3d840:	0df90d4d 	.word	0x0df90d4d
   3d844:	0afd0e0e 	.word	0x0afd0e0e
   3d848:	0bf40bc1 	.word	0x0bf40bc1
   3d84c:	0c040bff 	.word	0x0c040bff
   3d850:	0c140c09 	.word	0x0c140c09
   3d854:	0c320c27 	.word	0x0c320c27
   3d858:	0c5c0c47 	.word	0x0c5c0c47
   3d85c:	009d0c98 	.word	0x009d0c98
   3d860:	009d009d 	.word	0x009d009d
   3d864:	009d009d 	.word	0x009d009d
   3d868:	009d009d 	.word	0x009d009d
   3d86c:	0d64009d 	.word	0x0d64009d
   3d870:	0ec20d75 	.word	0x0ec20d75
   3d874:	0db40dbf 	.word	0x0db40dbf
   3d878:	0dca0dd3 	.word	0x0dca0dd3
   3d87c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   3d880:	4628      	mov	r0, r5
   3d882:	b011      	add	sp, #68	; 0x44
   3d884:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   3d888:	6843      	ldr	r3, [r0, #4]
   3d88a:	4798      	blx	r3
   3d88c:	2500      	movs	r5, #0
   3d88e:	e7f7      	b.n	3d880 <dwt_ioctl+0x154>
   3d890:	2202      	movs	r2, #2
   3d892:	49b4      	ldr	r1, [pc, #720]	; (3db64 <dwt_ioctl+0x438>)
   3d894:	f7fd fe93 	bl	3b5be <dwt_read8bitoffsetreg>
   3d898:	2803      	cmp	r0, #3
   3d89a:	d801      	bhi.n	3d8a0 <dwt_ioctl+0x174>
   3d89c:	2500      	movs	r5, #0
   3d89e:	e7ef      	b.n	3d880 <dwt_ioctl+0x154>
   3d8a0:	f7f0 ff82 	bl	2e7a8 <decamutexon>
   3d8a4:	4604      	mov	r4, r0
   3d8a6:	2302      	movs	r3, #2
   3d8a8:	9301      	str	r3, [sp, #4]
   3d8aa:	2500      	movs	r5, #0
   3d8ac:	9500      	str	r5, [sp, #0]
   3d8ae:	462b      	mov	r3, r5
   3d8b0:	462a      	mov	r2, r5
   3d8b2:	4629      	mov	r1, r5
   3d8b4:	4630      	mov	r0, r6
   3d8b6:	f7fd fdd2 	bl	3b45e <dwt_xfer3xxx>
   3d8ba:	4620      	mov	r0, r4
   3d8bc:	f7f0 ff7b 	bl	2e7b6 <decamutexoff>
   3d8c0:	e7de      	b.n	3d880 <dwt_ioctl+0x154>
   3d8c2:	2c00      	cmp	r4, #0
   3d8c4:	f001 8602 	beq.w	3f4cc <dwt_ioctl+0x1da0>
   3d8c8:	7824      	ldrb	r4, [r4, #0]
   3d8ca:	f014 0f1d 	tst.w	r4, #29
   3d8ce:	d061      	beq.n	3d994 <dwt_ioctl+0x268>
   3d8d0:	f014 0f01 	tst.w	r4, #1
   3d8d4:	d023      	beq.n	3d91e <dwt_ioctl+0x1f2>
   3d8d6:	f014 0f02 	tst.w	r4, #2
   3d8da:	f04f 0302 	mov.w	r3, #2
   3d8de:	9301      	str	r3, [sp, #4]
   3d8e0:	f04f 0200 	mov.w	r2, #0
   3d8e4:	9200      	str	r2, [sp, #0]
   3d8e6:	4613      	mov	r3, r2
   3d8e8:	bf14      	ite	ne
   3d8ea:	210d      	movne	r1, #13
   3d8ec:	2103      	moveq	r1, #3
   3d8ee:	f7fd fdb6 	bl	3b45e <dwt_xfer3xxx>
   3d8f2:	2203      	movs	r2, #3
   3d8f4:	2144      	movs	r1, #68	; 0x44
   3d8f6:	4630      	mov	r0, r6
   3d8f8:	f7fd fe61 	bl	3b5be <dwt_read8bitoffsetreg>
   3d8fc:	f010 0f08 	tst.w	r0, #8
   3d900:	bf08      	it	eq
   3d902:	2500      	moveq	r5, #0
   3d904:	d0bc      	beq.n	3d880 <dwt_ioctl+0x154>
   3d906:	2302      	movs	r3, #2
   3d908:	9301      	str	r3, [sp, #4]
   3d90a:	2100      	movs	r1, #0
   3d90c:	9100      	str	r1, [sp, #0]
   3d90e:	460b      	mov	r3, r1
   3d910:	460a      	mov	r2, r1
   3d912:	4630      	mov	r0, r6
   3d914:	f7fd fda3 	bl	3b45e <dwt_xfer3xxx>
   3d918:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   3d91c:	e7b0      	b.n	3d880 <dwt_ioctl+0x154>
   3d91e:	f014 0f08 	tst.w	r4, #8
   3d922:	d111      	bne.n	3d948 <dwt_ioctl+0x21c>
   3d924:	f014 0f10 	tst.w	r4, #16
   3d928:	d121      	bne.n	3d96e <dwt_ioctl+0x242>
   3d92a:	f014 0f02 	tst.w	r4, #2
   3d92e:	f04f 0302 	mov.w	r3, #2
   3d932:	9301      	str	r3, [sp, #4]
   3d934:	f04f 0200 	mov.w	r2, #0
   3d938:	9200      	str	r2, [sp, #0]
   3d93a:	4613      	mov	r3, r2
   3d93c:	bf14      	ite	ne
   3d93e:	2110      	movne	r1, #16
   3d940:	2109      	moveq	r1, #9
   3d942:	f7fd fd8c 	bl	3b45e <dwt_xfer3xxx>
   3d946:	e7d4      	b.n	3d8f2 <dwt_ioctl+0x1c6>
   3d948:	2100      	movs	r1, #0
   3d94a:	f7fe fa9a 	bl	3be82 <_dwt_adjust_delaytime>
   3d94e:	f014 0f02 	tst.w	r4, #2
   3d952:	f04f 0302 	mov.w	r3, #2
   3d956:	9301      	str	r3, [sp, #4]
   3d958:	f04f 0200 	mov.w	r2, #0
   3d95c:	9200      	str	r2, [sp, #0]
   3d95e:	4613      	mov	r3, r2
   3d960:	bf14      	ite	ne
   3d962:	210f      	movne	r1, #15
   3d964:	2107      	moveq	r1, #7
   3d966:	4630      	mov	r0, r6
   3d968:	f7fd fd79 	bl	3b45e <dwt_xfer3xxx>
   3d96c:	e7c1      	b.n	3d8f2 <dwt_ioctl+0x1c6>
   3d96e:	2101      	movs	r1, #1
   3d970:	f7fe fa87 	bl	3be82 <_dwt_adjust_delaytime>
   3d974:	f014 0f02 	tst.w	r4, #2
   3d978:	f04f 0302 	mov.w	r3, #2
   3d97c:	9301      	str	r3, [sp, #4]
   3d97e:	f04f 0200 	mov.w	r2, #0
   3d982:	9200      	str	r2, [sp, #0]
   3d984:	4613      	mov	r3, r2
   3d986:	bf14      	ite	ne
   3d988:	210e      	movne	r1, #14
   3d98a:	2105      	moveq	r1, #5
   3d98c:	4630      	mov	r0, r6
   3d98e:	f7fd fd66 	bl	3b45e <dwt_xfer3xxx>
   3d992:	e7ae      	b.n	3d8f2 <dwt_ioctl+0x1c6>
   3d994:	f014 0f20 	tst.w	r4, #32
   3d998:	d00f      	beq.n	3d9ba <dwt_ioctl+0x28e>
   3d99a:	f014 0f02 	tst.w	r4, #2
   3d99e:	f04f 0302 	mov.w	r3, #2
   3d9a2:	9301      	str	r3, [sp, #4]
   3d9a4:	f04f 0500 	mov.w	r5, #0
   3d9a8:	9500      	str	r5, [sp, #0]
   3d9aa:	462b      	mov	r3, r5
   3d9ac:	462a      	mov	r2, r5
   3d9ae:	bf14      	ite	ne
   3d9b0:	2111      	movne	r1, #17
   3d9b2:	210b      	moveq	r1, #11
   3d9b4:	f7fd fd53 	bl	3b45e <dwt_xfer3xxx>
   3d9b8:	e762      	b.n	3d880 <dwt_ioctl+0x154>
   3d9ba:	f014 0f02 	tst.w	r4, #2
   3d9be:	f04f 0302 	mov.w	r3, #2
   3d9c2:	9301      	str	r3, [sp, #4]
   3d9c4:	f04f 0500 	mov.w	r5, #0
   3d9c8:	9500      	str	r5, [sp, #0]
   3d9ca:	462b      	mov	r3, r5
   3d9cc:	462a      	mov	r2, r5
   3d9ce:	bf14      	ite	ne
   3d9d0:	210c      	movne	r1, #12
   3d9d2:	2101      	moveq	r1, #1
   3d9d4:	f7fd fd43 	bl	3b45e <dwt_xfer3xxx>
   3d9d8:	e752      	b.n	3d880 <dwt_ioctl+0x154>
   3d9da:	2c00      	cmp	r4, #0
   3d9dc:	f001 8579 	beq.w	3f4d2 <dwt_ioctl+0x1da6>
   3d9e0:	6823      	ldr	r3, [r4, #0]
   3d9e2:	2200      	movs	r2, #0
   3d9e4:	2128      	movs	r1, #40	; 0x28
   3d9e6:	f7fe fa37 	bl	3be58 <dwt_write32bitoffsetreg>
   3d9ea:	2500      	movs	r5, #0
   3d9ec:	e748      	b.n	3d880 <dwt_ioctl+0x154>
   3d9ee:	6823      	ldr	r3, [r4, #0]
   3d9f0:	2200      	movs	r2, #0
   3d9f2:	495d      	ldr	r1, [pc, #372]	; (3db68 <dwt_ioctl+0x43c>)
   3d9f4:	f7fe fa30 	bl	3be58 <dwt_write32bitoffsetreg>
   3d9f8:	6863      	ldr	r3, [r4, #4]
   3d9fa:	2200      	movs	r2, #0
   3d9fc:	495b      	ldr	r1, [pc, #364]	; (3db6c <dwt_ioctl+0x440>)
   3d9fe:	4630      	mov	r0, r6
   3da00:	f7fe fa2a 	bl	3be58 <dwt_write32bitoffsetreg>
   3da04:	68a3      	ldr	r3, [r4, #8]
   3da06:	2200      	movs	r2, #0
   3da08:	4959      	ldr	r1, [pc, #356]	; (3db70 <dwt_ioctl+0x444>)
   3da0a:	4630      	mov	r0, r6
   3da0c:	f7fe fa24 	bl	3be58 <dwt_write32bitoffsetreg>
   3da10:	68e3      	ldr	r3, [r4, #12]
   3da12:	2200      	movs	r2, #0
   3da14:	4957      	ldr	r1, [pc, #348]	; (3db74 <dwt_ioctl+0x448>)
   3da16:	4630      	mov	r0, r6
   3da18:	f7fe fa1e 	bl	3be58 <dwt_write32bitoffsetreg>
   3da1c:	2500      	movs	r5, #0
   3da1e:	e72f      	b.n	3d880 <dwt_ioctl+0x154>
   3da20:	2c00      	cmp	r4, #0
   3da22:	f001 8559 	beq.w	3f4d8 <dwt_ioctl+0x1dac>
   3da26:	8823      	ldrh	r3, [r4, #0]
   3da28:	6865      	ldr	r5, [r4, #4]
   3da2a:	2d03      	cmp	r5, #3
   3da2c:	f201 8557 	bhi.w	3f4de <dwt_ioctl+0x1db2>
   3da30:	e8df f005 	tbb	[pc, r5]
   3da34:	130d0702 	.word	0x130d0702
   3da38:	2200      	movs	r2, #0
   3da3a:	494f      	ldr	r1, [pc, #316]	; (3db78 <dwt_ioctl+0x44c>)
   3da3c:	f7fe f9af 	bl	3bd9e <dwt_write16bitoffsetreg>
   3da40:	e71e      	b.n	3d880 <dwt_ioctl+0x154>
   3da42:	2202      	movs	r2, #2
   3da44:	494c      	ldr	r1, [pc, #304]	; (3db78 <dwt_ioctl+0x44c>)
   3da46:	f7fe f9aa 	bl	3bd9e <dwt_write16bitoffsetreg>
   3da4a:	2500      	movs	r5, #0
   3da4c:	e718      	b.n	3d880 <dwt_ioctl+0x154>
   3da4e:	2200      	movs	r2, #0
   3da50:	494a      	ldr	r1, [pc, #296]	; (3db7c <dwt_ioctl+0x450>)
   3da52:	f7fe f9a4 	bl	3bd9e <dwt_write16bitoffsetreg>
   3da56:	2500      	movs	r5, #0
   3da58:	e712      	b.n	3d880 <dwt_ioctl+0x154>
   3da5a:	2202      	movs	r2, #2
   3da5c:	4947      	ldr	r1, [pc, #284]	; (3db7c <dwt_ioctl+0x450>)
   3da5e:	f7fe f99e 	bl	3bd9e <dwt_write16bitoffsetreg>
   3da62:	2500      	movs	r5, #0
   3da64:	e70c      	b.n	3d880 <dwt_ioctl+0x154>
   3da66:	2c00      	cmp	r4, #0
   3da68:	f001 853c 	beq.w	3f4e4 <dwt_ioctl+0x1db8>
   3da6c:	7823      	ldrb	r3, [r4, #0]
   3da6e:	005b      	lsls	r3, r3, #1
   3da70:	f003 0306 	and.w	r3, r3, #6
   3da74:	9300      	str	r3, [sp, #0]
   3da76:	f06f 0306 	mvn.w	r3, #6
   3da7a:	2200      	movs	r2, #0
   3da7c:	4940      	ldr	r1, [pc, #256]	; (3db80 <dwt_ioctl+0x454>)
   3da7e:	f7fe fe3d 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3da82:	2500      	movs	r5, #0
   3da84:	e6fc      	b.n	3d880 <dwt_ioctl+0x154>
   3da86:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   3da8a:	9300      	str	r3, [sp, #0]
   3da8c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3da90:	2200      	movs	r2, #0
   3da92:	493c      	ldr	r1, [pc, #240]	; (3db84 <dwt_ioctl+0x458>)
   3da94:	f7fe fe32 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3da98:	2500      	movs	r5, #0
   3da9a:	e6f1      	b.n	3d880 <dwt_ioctl+0x154>
   3da9c:	2c00      	cmp	r4, #0
   3da9e:	f001 8524 	beq.w	3f4ea <dwt_ioctl+0x1dbe>
   3daa2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3daa4:	7b1b      	ldrb	r3, [r3, #12]
   3daa6:	7023      	strb	r3, [r4, #0]
   3daa8:	2500      	movs	r5, #0
   3daaa:	e6e9      	b.n	3d880 <dwt_ioctl+0x154>
   3daac:	2c00      	cmp	r4, #0
   3daae:	f001 851f 	beq.w	3f4f0 <dwt_ioctl+0x1dc4>
   3dab2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3dab4:	7a5b      	ldrb	r3, [r3, #9]
   3dab6:	7023      	strb	r3, [r4, #0]
   3dab8:	2500      	movs	r5, #0
   3daba:	e6e1      	b.n	3d880 <dwt_ioctl+0x154>
   3dabc:	2c00      	cmp	r4, #0
   3dabe:	f001 851a 	beq.w	3f4f6 <dwt_ioctl+0x1dca>
   3dac2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3dac4:	7a9b      	ldrb	r3, [r3, #10]
   3dac6:	7023      	strb	r3, [r4, #0]
   3dac8:	2500      	movs	r5, #0
   3daca:	e6d9      	b.n	3d880 <dwt_ioctl+0x154>
   3dacc:	2c00      	cmp	r4, #0
   3dace:	f001 8515 	beq.w	3f4fc <dwt_ioctl+0x1dd0>
   3dad2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3dad4:	681b      	ldr	r3, [r3, #0]
   3dad6:	6023      	str	r3, [r4, #0]
   3dad8:	2500      	movs	r5, #0
   3dada:	e6d1      	b.n	3d880 <dwt_ioctl+0x154>
   3dadc:	2c00      	cmp	r4, #0
   3dade:	f001 8510 	beq.w	3f502 <dwt_ioctl+0x1dd6>
   3dae2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3dae4:	685b      	ldr	r3, [r3, #4]
   3dae6:	6023      	str	r3, [r4, #0]
   3dae8:	2500      	movs	r5, #0
   3daea:	e6c9      	b.n	3d880 <dwt_ioctl+0x154>
   3daec:	f7fe fc72 	bl	3c3d4 <ull_signal_rx_buff_free>
   3daf0:	2500      	movs	r5, #0
   3daf2:	e6c5      	b.n	3d880 <dwt_ioctl+0x154>
   3daf4:	2c00      	cmp	r4, #0
   3daf6:	f001 8507 	beq.w	3f508 <dwt_ioctl+0x1ddc>
   3dafa:	6821      	ldr	r1, [r4, #0]
   3dafc:	f7fe f9e7 	bl	3bece <ull_setrxaftertxdelay>
   3db00:	2500      	movs	r5, #0
   3db02:	e6bd      	b.n	3d880 <dwt_ioctl+0x154>
   3db04:	2c00      	cmp	r4, #0
   3db06:	f001 8502 	beq.w	3f50e <dwt_ioctl+0x1de2>
   3db0a:	7825      	ldrb	r5, [r4, #0]
   3db0c:	b15d      	cbz	r5, 3db26 <dwt_ioctl+0x3fa>
   3db0e:	6864      	ldr	r4, [r4, #4]
   3db10:	2340      	movs	r3, #64	; 0x40
   3db12:	9300      	str	r3, [sp, #0]
   3db14:	23ff      	movs	r3, #255	; 0xff
   3db16:	2200      	movs	r2, #0
   3db18:	2110      	movs	r1, #16
   3db1a:	f7fe ff61 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3db1e:	2d02      	cmp	r5, #2
   3db20:	d107      	bne.n	3db32 <dwt_ioctl+0x406>
   3db22:	60f4      	str	r4, [r6, #12]
   3db24:	e005      	b.n	3db32 <dwt_ioctl+0x406>
   3db26:	2200      	movs	r2, #0
   3db28:	9200      	str	r2, [sp, #0]
   3db2a:	23bf      	movs	r3, #191	; 0xbf
   3db2c:	2110      	movs	r1, #16
   3db2e:	f7fe ff57 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3db32:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3db34:	751d      	strb	r5, [r3, #20]
   3db36:	2500      	movs	r5, #0
   3db38:	e6a2      	b.n	3d880 <dwt_ioctl+0x154>
   3db3a:	2c00      	cmp	r4, #0
   3db3c:	f001 84ea 	beq.w	3f514 <dwt_ioctl+0x1de8>
   3db40:	6865      	ldr	r5, [r4, #4]
   3db42:	7823      	ldrb	r3, [r4, #0]
   3db44:	2203      	movs	r2, #3
   3db46:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   3db4a:	f7fe fb13 	bl	3c174 <dwt_write8bitoffsetreg>
   3db4e:	b9dd      	cbnz	r5, 3db88 <dwt_ioctl+0x45c>
   3db50:	2200      	movs	r2, #0
   3db52:	9200      	str	r2, [sp, #0]
   3db54:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   3db58:	2110      	movs	r1, #16
   3db5a:	4630      	mov	r0, r6
   3db5c:	f7ff f95c 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3db60:	e68e      	b.n	3d880 <dwt_ioctl+0x154>
   3db62:	bf00      	nop
   3db64:	000f0030 	.word	0x000f0030
   3db68:	00010054 	.word	0x00010054
   3db6c:	00010058 	.word	0x00010058
   3db70:	0001005c 	.word	0x0001005c
   3db74:	00010060 	.word	0x00010060
   3db78:	0001000c 	.word	0x0001000c
   3db7c:	00010010 	.word	0x00010010
   3db80:	00010008 	.word	0x00010008
   3db84:	00110004 	.word	0x00110004
   3db88:	f44f 2381 	mov.w	r3, #264192	; 0x40800
   3db8c:	9300      	str	r3, [sp, #0]
   3db8e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3db92:	2200      	movs	r2, #0
   3db94:	2110      	movs	r1, #16
   3db96:	4630      	mov	r0, r6
   3db98:	f7fe fdb0 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3db9c:	2500      	movs	r5, #0
   3db9e:	e66f      	b.n	3d880 <dwt_ioctl+0x154>
   3dba0:	2200      	movs	r2, #0
   3dba2:	4611      	mov	r1, r2
   3dba4:	f7fd fce3 	bl	3b56e <dwt_read32bitoffsetreg>
   3dba8:	68b2      	ldr	r2, [r6, #8]
   3dbaa:	6813      	ldr	r3, [r2, #0]
   3dbac:	4043      	eors	r3, r0
   3dbae:	6852      	ldr	r2, [r2, #4]
   3dbb0:	4213      	tst	r3, r2
   3dbb2:	bf14      	ite	ne
   3dbb4:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   3dbb8:	2500      	moveq	r5, #0
   3dbba:	e661      	b.n	3d880 <dwt_ioctl+0x154>
   3dbbc:	2c00      	cmp	r4, #0
   3dbbe:	f001 84ac 	beq.w	3f51a <dwt_ioctl+0x1dee>
   3dbc2:	7821      	ldrb	r1, [r4, #0]
   3dbc4:	f7fe ff20 	bl	3ca08 <ull_configciadiag>
   3dbc8:	2500      	movs	r5, #0
   3dbca:	e659      	b.n	3d880 <dwt_ioctl+0x154>
   3dbcc:	b93a      	cbnz	r2, 3dbde <dwt_ioctl+0x4b2>
   3dbce:	2200      	movs	r2, #0
   3dbd0:	9200      	str	r2, [sp, #0]
   3dbd2:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   3dbd6:	49b8      	ldr	r1, [pc, #736]	; (3deb8 <dwt_ioctl+0x78c>)
   3dbd8:	f7ff f91e 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3dbdc:	e650      	b.n	3d880 <dwt_ioctl+0x154>
   3dbde:	f44f 6300 	mov.w	r3, #2048	; 0x800
   3dbe2:	9300      	str	r3, [sp, #0]
   3dbe4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3dbe8:	2200      	movs	r2, #0
   3dbea:	49b3      	ldr	r1, [pc, #716]	; (3deb8 <dwt_ioctl+0x78c>)
   3dbec:	f7ff f914 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3dbf0:	2500      	movs	r5, #0
   3dbf2:	e645      	b.n	3d880 <dwt_ioctl+0x154>
   3dbf4:	f002 0201 	and.w	r2, r2, #1
   3dbf8:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3dbfc:	f24f 71ff 	movw	r1, #63487	; 0xf7ff
   3dc00:	2a00      	cmp	r2, #0
   3dc02:	bf08      	it	eq
   3dc04:	460b      	moveq	r3, r1
   3dc06:	02d2      	lsls	r2, r2, #11
   3dc08:	f015 0f02 	tst.w	r5, #2
   3dc0c:	bf12      	itee	ne
   3dc0e:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
   3dc12:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   3dc16:	b29b      	uxtheq	r3, r3
   3dc18:	9200      	str	r2, [sp, #0]
   3dc1a:	2200      	movs	r2, #0
   3dc1c:	49a6      	ldr	r1, [pc, #664]	; (3deb8 <dwt_ioctl+0x78c>)
   3dc1e:	f7ff f8fb 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3dc22:	2500      	movs	r5, #0
   3dc24:	e62c      	b.n	3d880 <dwt_ioctl+0x154>
   3dc26:	b92a      	cbnz	r2, 3dc34 <dwt_ioctl+0x508>
   3dc28:	4ba4      	ldr	r3, [pc, #656]	; (3debc <dwt_ioctl+0x790>)
   3dc2a:	2202      	movs	r2, #2
   3dc2c:	49a4      	ldr	r1, [pc, #656]	; (3dec0 <dwt_ioctl+0x794>)
   3dc2e:	f7fe f913 	bl	3be58 <dwt_write32bitoffsetreg>
   3dc32:	e625      	b.n	3d880 <dwt_ioctl+0x154>
   3dc34:	4ba3      	ldr	r3, [pc, #652]	; (3dec4 <dwt_ioctl+0x798>)
   3dc36:	2202      	movs	r2, #2
   3dc38:	49a1      	ldr	r1, [pc, #644]	; (3dec0 <dwt_ioctl+0x794>)
   3dc3a:	f7fe f90d 	bl	3be58 <dwt_write32bitoffsetreg>
   3dc3e:	2500      	movs	r5, #0
   3dc40:	e61e      	b.n	3d880 <dwt_ioctl+0x154>
   3dc42:	4611      	mov	r1, r2
   3dc44:	f7fe f957 	bl	3bef6 <ull_setlnapamode>
   3dc48:	2500      	movs	r5, #0
   3dc4a:	e619      	b.n	3d880 <dwt_ioctl+0x154>
   3dc4c:	2c00      	cmp	r4, #0
   3dc4e:	f001 8467 	beq.w	3f520 <dwt_ioctl+0x1df4>
   3dc52:	2200      	movs	r2, #0
   3dc54:	499c      	ldr	r1, [pc, #624]	; (3dec8 <dwt_ioctl+0x79c>)
   3dc56:	f7fd fcb2 	bl	3b5be <dwt_read8bitoffsetreg>
   3dc5a:	7020      	strb	r0, [r4, #0]
   3dc5c:	2500      	movs	r5, #0
   3dc5e:	e60f      	b.n	3d880 <dwt_ioctl+0x154>
   3dc60:	4621      	mov	r1, r4
   3dc62:	f7fe f969 	bl	3bf38 <ull_configurestskey>
   3dc66:	2500      	movs	r5, #0
   3dc68:	e60a      	b.n	3d880 <dwt_ioctl+0x154>
   3dc6a:	4621      	mov	r1, r4
   3dc6c:	f7fe f988 	bl	3bf80 <ull_configurestsiv>
   3dc70:	2500      	movs	r5, #0
   3dc72:	e605      	b.n	3d880 <dwt_ioctl+0x154>
   3dc74:	2301      	movs	r3, #1
   3dc76:	9300      	str	r3, [sp, #0]
   3dc78:	23ff      	movs	r3, #255	; 0xff
   3dc7a:	2200      	movs	r2, #0
   3dc7c:	4993      	ldr	r1, [pc, #588]	; (3decc <dwt_ioctl+0x7a0>)
   3dc7e:	f7fe feaf 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3dc82:	2500      	movs	r5, #0
   3dc84:	e5fc      	b.n	3d880 <dwt_ioctl+0x154>
   3dc86:	4611      	mov	r1, r2
   3dc88:	f7fe f99e 	bl	3bfc8 <ull_configmrxlut>
   3dc8c:	2500      	movs	r5, #0
   3dc8e:	e5f7      	b.n	3d880 <dwt_ioctl+0x154>
   3dc90:	2318      	movs	r3, #24
   3dc92:	2200      	movs	r2, #0
   3dc94:	498e      	ldr	r1, [pc, #568]	; (3ded0 <dwt_ioctl+0x7a4>)
   3dc96:	f7fe f8df 	bl	3be58 <dwt_write32bitoffsetreg>
   3dc9a:	23e8      	movs	r3, #232	; 0xe8
   3dc9c:	2200      	movs	r2, #0
   3dc9e:	498d      	ldr	r1, [pc, #564]	; (3ded4 <dwt_ioctl+0x7a8>)
   3dca0:	4630      	mov	r0, r6
   3dca2:	f7fe f8d9 	bl	3be58 <dwt_write32bitoffsetreg>
   3dca6:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3dca8:	7d9b      	ldrb	r3, [r3, #22]
   3dcaa:	085b      	lsrs	r3, r3, #1
   3dcac:	d01a      	beq.n	3dce4 <dwt_ioctl+0x5b8>
   3dcae:	2200      	movs	r2, #0
   3dcb0:	4989      	ldr	r1, [pc, #548]	; (3ded8 <dwt_ioctl+0x7ac>)
   3dcb2:	4630      	mov	r0, r6
   3dcb4:	f7fd fc71 	bl	3b59a <dwt_read16bitoffsetreg>
   3dcb8:	f3c0 03c4 	ubfx	r3, r0, #3, #5
   3dcbc:	3b09      	subs	r3, #9
   3dcbe:	2b0f      	cmp	r3, #15
   3dcc0:	f201 8431 	bhi.w	3f526 <dwt_ioctl+0x1dfa>
   3dcc4:	f000 0001 	and.w	r0, r0, #1
   3dcc8:	2800      	cmp	r0, #0
   3dcca:	bf0c      	ite	eq
   3dccc:	2105      	moveq	r1, #5
   3dcce:	2109      	movne	r1, #9
   3dcd0:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3dcd2:	7a1b      	ldrb	r3, [r3, #8]
   3dcd4:	2b01      	cmp	r3, #1
   3dcd6:	f001 8429 	beq.w	3f52c <dwt_ioctl+0x1e00>
   3dcda:	4630      	mov	r0, r6
   3dcdc:	f7fe f974 	bl	3bfc8 <ull_configmrxlut>
   3dce0:	2500      	movs	r5, #0
   3dce2:	e5cd      	b.n	3d880 <dwt_ioctl+0x154>
   3dce4:	2301      	movs	r3, #1
   3dce6:	2200      	movs	r2, #0
   3dce8:	497c      	ldr	r1, [pc, #496]	; (3dedc <dwt_ioctl+0x7b0>)
   3dcea:	4630      	mov	r0, r6
   3dcec:	f7fe fa42 	bl	3c174 <dwt_write8bitoffsetreg>
   3dcf0:	6d32      	ldr	r2, [r6, #80]	; 0x50
   3dcf2:	7d93      	ldrb	r3, [r2, #22]
   3dcf4:	f043 0302 	orr.w	r3, r3, #2
   3dcf8:	7593      	strb	r3, [r2, #22]
   3dcfa:	e7d8      	b.n	3dcae <dwt_ioctl+0x582>
   3dcfc:	2c00      	cmp	r4, #0
   3dcfe:	f001 8418 	beq.w	3f532 <dwt_ioctl+0x1e06>
   3dd02:	7824      	ldrb	r4, [r4, #0]
   3dd04:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3dd06:	755c      	strb	r4, [r3, #21]
   3dd08:	0323      	lsls	r3, r4, #12
   3dd0a:	f403 4330 	and.w	r3, r3, #45056	; 0xb000
   3dd0e:	9300      	str	r3, [sp, #0]
   3dd10:	f644 73ff 	movw	r3, #20479	; 0x4fff
   3dd14:	2200      	movs	r2, #0
   3dd16:	2110      	movs	r1, #16
   3dd18:	f7ff f87e 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3dd1c:	f004 0403 	and.w	r4, r4, #3
   3dd20:	2c03      	cmp	r4, #3
   3dd22:	bf0c      	ite	eq
   3dd24:	4b6e      	ldreq	r3, [pc, #440]	; (3dee0 <dwt_ioctl+0x7b4>)
   3dd26:	4b6f      	ldrne	r3, [pc, #444]	; (3dee4 <dwt_ioctl+0x7b8>)
   3dd28:	2200      	movs	r2, #0
   3dd2a:	496f      	ldr	r1, [pc, #444]	; (3dee8 <dwt_ioctl+0x7bc>)
   3dd2c:	4630      	mov	r0, r6
   3dd2e:	f7fe f893 	bl	3be58 <dwt_write32bitoffsetreg>
   3dd32:	2500      	movs	r5, #0
   3dd34:	e5a4      	b.n	3d880 <dwt_ioctl+0x154>
   3dd36:	2c00      	cmp	r4, #0
   3dd38:	f001 83fe 	beq.w	3f538 <dwt_ioctl+0x1e0c>
   3dd3c:	8823      	ldrh	r3, [r4, #0]
   3dd3e:	2200      	movs	r2, #0
   3dd40:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3dd44:	f7fe f82b 	bl	3bd9e <dwt_write16bitoffsetreg>
   3dd48:	2500      	movs	r5, #0
   3dd4a:	e599      	b.n	3d880 <dwt_ioctl+0x154>
   3dd4c:	2c00      	cmp	r4, #0
   3dd4e:	f001 83f6 	beq.w	3f53e <dwt_ioctl+0x1e12>
   3dd52:	2200      	movs	r2, #0
   3dd54:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3dd58:	f7fd fc1f 	bl	3b59a <dwt_read16bitoffsetreg>
   3dd5c:	8020      	strh	r0, [r4, #0]
   3dd5e:	2500      	movs	r5, #0
   3dd60:	e58e      	b.n	3d880 <dwt_ioctl+0x154>
   3dd62:	2c00      	cmp	r4, #0
   3dd64:	f001 83ee 	beq.w	3f544 <dwt_ioctl+0x1e18>
   3dd68:	8823      	ldrh	r3, [r4, #0]
   3dd6a:	2200      	movs	r2, #0
   3dd6c:	217c      	movs	r1, #124	; 0x7c
   3dd6e:	f7fe f816 	bl	3bd9e <dwt_write16bitoffsetreg>
   3dd72:	2500      	movs	r5, #0
   3dd74:	e584      	b.n	3d880 <dwt_ioctl+0x154>
   3dd76:	2c00      	cmp	r4, #0
   3dd78:	f001 83e7 	beq.w	3f54a <dwt_ioctl+0x1e1e>
   3dd7c:	2200      	movs	r2, #0
   3dd7e:	217c      	movs	r1, #124	; 0x7c
   3dd80:	f7fd fc0b 	bl	3b59a <dwt_read16bitoffsetreg>
   3dd84:	8020      	strh	r0, [r4, #0]
   3dd86:	2500      	movs	r5, #0
   3dd88:	e57a      	b.n	3d880 <dwt_ioctl+0x154>
   3dd8a:	2c00      	cmp	r4, #0
   3dd8c:	f001 83e0 	beq.w	3f550 <dwt_ioctl+0x1e24>
   3dd90:	88a3      	ldrh	r3, [r4, #4]
   3dd92:	88e2      	ldrh	r2, [r4, #6]
   3dd94:	6821      	ldr	r1, [r4, #0]
   3dd96:	9100      	str	r1, [sp, #0]
   3dd98:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   3dd9c:	f7fd fff4 	bl	3bd88 <dwt_writetodevice>
   3dda0:	2500      	movs	r5, #0
   3dda2:	e56d      	b.n	3d880 <dwt_ioctl+0x154>
   3dda4:	2c00      	cmp	r4, #0
   3dda6:	f001 83d6 	beq.w	3f556 <dwt_ioctl+0x1e2a>
   3ddaa:	88a3      	ldrh	r3, [r4, #4]
   3ddac:	88e2      	ldrh	r2, [r4, #6]
   3ddae:	6821      	ldr	r1, [r4, #0]
   3ddb0:	9100      	str	r1, [sp, #0]
   3ddb2:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   3ddb6:	f7fd fbd0 	bl	3b55a <dwt_readfromdevice>
   3ddba:	2500      	movs	r5, #0
   3ddbc:	e560      	b.n	3d880 <dwt_ioctl+0x154>
   3ddbe:	2c00      	cmp	r4, #0
   3ddc0:	f001 83cc 	beq.w	3f55c <dwt_ioctl+0x1e30>
   3ddc4:	88e3      	ldrh	r3, [r4, #6]
   3ddc6:	88a2      	ldrh	r2, [r4, #4]
   3ddc8:	6821      	ldr	r1, [r4, #0]
   3ddca:	f7fe f99d 	bl	3c108 <ull_readrxdata>
   3ddce:	2500      	movs	r5, #0
   3ddd0:	e556      	b.n	3d880 <dwt_ioctl+0x154>
   3ddd2:	2c00      	cmp	r4, #0
   3ddd4:	f001 83c5 	beq.w	3f562 <dwt_ioctl+0x1e36>
   3ddd8:	88e3      	ldrh	r3, [r4, #6]
   3ddda:	6822      	ldr	r2, [r4, #0]
   3dddc:	88a1      	ldrh	r1, [r4, #4]
   3ddde:	f7fe fac7 	bl	3c370 <ull_writetxdata>
   3dde2:	2500      	movs	r5, #0
   3dde4:	e54c      	b.n	3d880 <dwt_ioctl+0x154>
   3dde6:	4611      	mov	r1, r2
   3dde8:	f7ff fc08 	bl	3d5fc <ull_rxenable>
   3ddec:	2500      	movs	r5, #0
   3ddee:	e547      	b.n	3d880 <dwt_ioctl+0x154>
   3ddf0:	2c00      	cmp	r4, #0
   3ddf2:	f001 83b9 	beq.w	3f568 <dwt_ioctl+0x1e3c>
   3ddf6:	7923      	ldrb	r3, [r4, #4]
   3ddf8:	8862      	ldrh	r2, [r4, #2]
   3ddfa:	8821      	ldrh	r1, [r4, #0]
   3ddfc:	f7fe fdbe 	bl	3c97c <ull_writetxfctrl>
   3de00:	2500      	movs	r5, #0
   3de02:	e53d      	b.n	3d880 <dwt_ioctl+0x154>
   3de04:	2c00      	cmp	r4, #0
   3de06:	f001 83b2 	beq.w	3f56e <dwt_ioctl+0x1e42>
   3de0a:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3de0c:	7b9b      	ldrb	r3, [r3, #14]
   3de0e:	2b01      	cmp	r3, #1
   3de10:	d00c      	beq.n	3de2c <dwt_ioctl+0x700>
   3de12:	2b03      	cmp	r3, #3
   3de14:	d110      	bne.n	3de38 <dwt_ioctl+0x70c>
   3de16:	220c      	movs	r2, #12
   3de18:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3de1c:	f7fd fbbd 	bl	3b59a <dwt_read16bitoffsetreg>
   3de20:	b200      	sxth	r0, r0
   3de22:	f340 030c 	sbfx	r3, r0, #0, #13
   3de26:	8023      	strh	r3, [r4, #0]
   3de28:	2500      	movs	r5, #0
   3de2a:	e529      	b.n	3d880 <dwt_ioctl+0x154>
   3de2c:	2200      	movs	r2, #0
   3de2e:	492f      	ldr	r1, [pc, #188]	; (3deec <dwt_ioctl+0x7c0>)
   3de30:	f7fd fbb3 	bl	3b59a <dwt_read16bitoffsetreg>
   3de34:	b200      	sxth	r0, r0
   3de36:	e7f4      	b.n	3de22 <dwt_ioctl+0x6f6>
   3de38:	2200      	movs	r2, #0
   3de3a:	492d      	ldr	r1, [pc, #180]	; (3def0 <dwt_ioctl+0x7c4>)
   3de3c:	f7fd fbad 	bl	3b59a <dwt_read16bitoffsetreg>
   3de40:	b200      	sxth	r0, r0
   3de42:	e7ee      	b.n	3de22 <dwt_ioctl+0x6f6>
   3de44:	2c00      	cmp	r4, #0
   3de46:	f001 8395 	beq.w	3f574 <dwt_ioctl+0x1e48>
   3de4a:	ab0c      	add	r3, sp, #48	; 0x30
   3de4c:	9300      	str	r3, [sp, #0]
   3de4e:	2303      	movs	r3, #3
   3de50:	2200      	movs	r2, #0
   3de52:	4928      	ldr	r1, [pc, #160]	; (3def4 <dwt_ioctl+0x7c8>)
   3de54:	f7fd fb81 	bl	3b55a <dwt_readfromdevice>
   3de58:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   3de5c:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   3de60:	eb03 2202 	add.w	r2, r3, r2, lsl #8
   3de64:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
   3de68:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3de6c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   3de70:	bf1c      	itt	ne
   3de72:	ea6f 3303 	mvnne.w	r3, r3, lsl #12
   3de76:	ea6f 3313 	mvnne.w	r3, r3, lsr #12
   3de7a:	6023      	str	r3, [r4, #0]
   3de7c:	2500      	movs	r5, #0
   3de7e:	e4ff      	b.n	3d880 <dwt_ioctl+0x154>
   3de80:	f7fe f9d0 	bl	3c224 <ull_clearaonconfig>
   3de84:	2500      	movs	r5, #0
   3de86:	e4fb      	b.n	3d880 <dwt_ioctl+0x154>
   3de88:	2c00      	cmp	r4, #0
   3de8a:	f001 8376 	beq.w	3f57a <dwt_ioctl+0x1e4e>
   3de8e:	8861      	ldrh	r1, [r4, #2]
   3de90:	f7fe fdf0 	bl	3ca74 <ull_calcbandwidthadj>
   3de94:	7020      	strb	r0, [r4, #0]
   3de96:	2500      	movs	r5, #0
   3de98:	e4f2      	b.n	3d880 <dwt_ioctl+0x154>
   3de9a:	4621      	mov	r1, r4
   3de9c:	f7fd fb9d 	bl	3b5da <ull_readdiagnostics>
   3dea0:	2500      	movs	r5, #0
   3dea2:	e4ed      	b.n	3d880 <dwt_ioctl+0x154>
   3dea4:	2c00      	cmp	r4, #0
   3dea6:	f001 836b 	beq.w	3f580 <dwt_ioctl+0x1e54>
   3deaa:	2201      	movs	r2, #1
   3deac:	2170      	movs	r1, #112	; 0x70
   3deae:	f7fd fb5e 	bl	3b56e <dwt_read32bitoffsetreg>
   3deb2:	6020      	str	r0, [r4, #0]
   3deb4:	2500      	movs	r5, #0
   3deb6:	e4e3      	b.n	3d880 <dwt_ioctl+0x154>
   3deb8:	00110008 	.word	0x00110008
   3debc:	00d20874 	.word	0x00d20874
   3dec0:	00110010 	.word	0x00110010
   3dec4:	04d28874 	.word	0x04d28874
   3dec8:	0007001c 	.word	0x0007001c
   3decc:	00020004 	.word	0x00020004
   3ded0:	001f000c 	.word	0x001f000c
   3ded4:	001f0010 	.word	0x001f0010
   3ded8:	00010008 	.word	0x00010008
   3dedc:	00010020 	.word	0x00010020
   3dee0:	af5f35cc 	.word	0xaf5f35cc
   3dee4:	af5f584c 	.word	0xaf5f584c
   3dee8:	0006000c 	.word	0x0006000c
   3deec:	0018000c 	.word	0x0018000c
   3def0:	000c0020 	.word	0x000c0020
   3def4:	00060029 	.word	0x00060029
   3def8:	2c00      	cmp	r4, #0
   3defa:	f001 8344 	beq.w	3f586 <dwt_ioctl+0x1e5a>
   3defe:	2200      	movs	r2, #0
   3df00:	2170      	movs	r1, #112	; 0x70
   3df02:	f7fd fb34 	bl	3b56e <dwt_read32bitoffsetreg>
   3df06:	6020      	str	r0, [r4, #0]
   3df08:	2500      	movs	r5, #0
   3df0a:	e4b9      	b.n	3d880 <dwt_ioctl+0x154>
   3df0c:	9400      	str	r4, [sp, #0]
   3df0e:	2305      	movs	r3, #5
   3df10:	2200      	movs	r2, #0
   3df12:	2170      	movs	r1, #112	; 0x70
   3df14:	f7fd fb21 	bl	3b55a <dwt_readfromdevice>
   3df18:	2500      	movs	r5, #0
   3df1a:	e4b1      	b.n	3d880 <dwt_ioctl+0x154>
   3df1c:	2c00      	cmp	r4, #0
   3df1e:	f001 8335 	beq.w	3f58c <dwt_ioctl+0x1e60>
   3df22:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3df24:	7b9b      	ldrb	r3, [r3, #14]
   3df26:	2b01      	cmp	r3, #1
   3df28:	d014      	beq.n	3df54 <dwt_ioctl+0x828>
   3df2a:	2b03      	cmp	r3, #3
   3df2c:	d119      	bne.n	3df62 <dwt_ioctl+0x836>
   3df2e:	2216      	movs	r2, #22
   3df30:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3df34:	f7fd fb31 	bl	3b59a <dwt_read16bitoffsetreg>
   3df38:	f3c0 000d 	ubfx	r0, r0, #0, #14
   3df3c:	b283      	uxth	r3, r0
   3df3e:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   3df42:	d004      	beq.n	3df4e <dwt_ioctl+0x822>
   3df44:	ea6f 4383 	mvn.w	r3, r3, lsl #18
   3df48:	ea6f 4393 	mvn.w	r3, r3, lsr #18
   3df4c:	b218      	sxth	r0, r3
   3df4e:	8020      	strh	r0, [r4, #0]
   3df50:	2500      	movs	r5, #0
   3df52:	e495      	b.n	3d880 <dwt_ioctl+0x154>
   3df54:	2202      	movs	r2, #2
   3df56:	49d6      	ldr	r1, [pc, #856]	; (3e2b0 <dwt_ioctl+0xb84>)
   3df58:	f7fd fb1f 	bl	3b59a <dwt_read16bitoffsetreg>
   3df5c:	f3c0 000d 	ubfx	r0, r0, #0, #14
   3df60:	e7ec      	b.n	3df3c <dwt_ioctl+0x810>
   3df62:	2202      	movs	r2, #2
   3df64:	49d3      	ldr	r1, [pc, #844]	; (3e2b4 <dwt_ioctl+0xb88>)
   3df66:	f7fd fb18 	bl	3b59a <dwt_read16bitoffsetreg>
   3df6a:	f3c0 000d 	ubfx	r0, r0, #0, #14
   3df6e:	e7e5      	b.n	3df3c <dwt_ioctl+0x810>
   3df70:	9400      	str	r4, [sp, #0]
   3df72:	2306      	movs	r3, #6
   3df74:	2200      	movs	r2, #0
   3df76:	49d0      	ldr	r1, [pc, #832]	; (3e2b8 <dwt_ioctl+0xb8c>)
   3df78:	f7fd faef 	bl	3b55a <dwt_readfromdevice>
   3df7c:	7963      	ldrb	r3, [r4, #5]
   3df7e:	f003 0301 	and.w	r3, r3, #1
   3df82:	7163      	strb	r3, [r4, #5]
   3df84:	2500      	movs	r5, #0
   3df86:	e47b      	b.n	3d880 <dwt_ioctl+0x154>
   3df88:	2c00      	cmp	r4, #0
   3df8a:	f001 8302 	beq.w	3f592 <dwt_ioctl+0x1e66>
   3df8e:	2201      	movs	r2, #1
   3df90:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   3df94:	f7fd fb13 	bl	3b5be <dwt_read8bitoffsetreg>
   3df98:	7020      	strb	r0, [r4, #0]
   3df9a:	2500      	movs	r5, #0
   3df9c:	e470      	b.n	3d880 <dwt_ioctl+0x154>
   3df9e:	2c00      	cmp	r4, #0
   3dfa0:	f001 82fa 	beq.w	3f598 <dwt_ioctl+0x1e6c>
   3dfa4:	2200      	movs	r2, #0
   3dfa6:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   3dfaa:	f7fd fb08 	bl	3b5be <dwt_read8bitoffsetreg>
   3dfae:	7020      	strb	r0, [r4, #0]
   3dfb0:	2500      	movs	r5, #0
   3dfb2:	e465      	b.n	3d880 <dwt_ioctl+0x154>
   3dfb4:	2c00      	cmp	r4, #0
   3dfb6:	f001 82f2 	beq.w	3f59e <dwt_ioctl+0x1e72>
   3dfba:	88a2      	ldrh	r2, [r4, #4]
   3dfbc:	6821      	ldr	r1, [r4, #0]
   3dfbe:	f7fe fc07 	bl	3c7d0 <_dwt_otpprogword32>
   3dfc2:	2500      	movs	r5, #0
   3dfc4:	e45c      	b.n	3d880 <dwt_ioctl+0x154>
   3dfc6:	2c00      	cmp	r4, #0
   3dfc8:	f001 82ec 	beq.w	3f5a4 <dwt_ioctl+0x1e78>
   3dfcc:	6825      	ldr	r5, [r4, #0]
   3dfce:	88a4      	ldrh	r4, [r4, #4]
   3dfd0:	4622      	mov	r2, r4
   3dfd2:	4629      	mov	r1, r5
   3dfd4:	f7fe fbfc 	bl	3c7d0 <_dwt_otpprogword32>
   3dfd8:	4621      	mov	r1, r4
   3dfda:	4630      	mov	r0, r6
   3dfdc:	f7fd ff1a 	bl	3be14 <_dwt_otpread>
   3dfe0:	1a2d      	subs	r5, r5, r0
   3dfe2:	bf18      	it	ne
   3dfe4:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   3dfe8:	e44a      	b.n	3d880 <dwt_ioctl+0x154>
   3dfea:	2a02      	cmp	r2, #2
   3dfec:	d00e      	beq.n	3e00c <dwt_ioctl+0x8e0>
   3dfee:	4cb3      	ldr	r4, [pc, #716]	; (3e2bc <dwt_ioctl+0xb90>)
   3dff0:	2300      	movs	r3, #0
   3dff2:	461a      	mov	r2, r3
   3dff4:	4621      	mov	r1, r4
   3dff6:	4630      	mov	r0, r6
   3dff8:	f7fe f8bc 	bl	3c174 <dwt_write8bitoffsetreg>
   3dffc:	2302      	movs	r3, #2
   3dffe:	2200      	movs	r2, #0
   3e000:	4621      	mov	r1, r4
   3e002:	4630      	mov	r0, r6
   3e004:	f7fe f8b6 	bl	3c174 <dwt_write8bitoffsetreg>
   3e008:	2500      	movs	r5, #0
   3e00a:	e439      	b.n	3d880 <dwt_ioctl+0x154>
   3e00c:	2300      	movs	r3, #0
   3e00e:	9300      	str	r3, [sp, #0]
   3e010:	23fe      	movs	r3, #254	; 0xfe
   3e012:	2201      	movs	r2, #1
   3e014:	49aa      	ldr	r1, [pc, #680]	; (3e2c0 <dwt_ioctl+0xb94>)
   3e016:	f7fe fce3 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e01a:	e7e8      	b.n	3dfee <dwt_ioctl+0x8c2>
   3e01c:	2c00      	cmp	r4, #0
   3e01e:	f001 82c4 	beq.w	3f5aa <dwt_ioctl+0x1e7e>
   3e022:	8824      	ldrh	r4, [r4, #0]
   3e024:	b2e2      	uxtb	r2, r4
   3e026:	f44f 7181 	mov.w	r1, #258	; 0x102
   3e02a:	f7fe f94f 	bl	3c2cc <ull_aon_write>
   3e02e:	0a22      	lsrs	r2, r4, #8
   3e030:	f240 1103 	movw	r1, #259	; 0x103
   3e034:	4630      	mov	r0, r6
   3e036:	f7fe f949 	bl	3c2cc <ull_aon_write>
   3e03a:	2500      	movs	r5, #0
   3e03c:	e420      	b.n	3d880 <dwt_ioctl+0x154>
   3e03e:	2c00      	cmp	r4, #0
   3e040:	f001 82b6 	beq.w	3f5b0 <dwt_ioctl+0x1e84>
   3e044:	f8df 8284 	ldr.w	r8, [pc, #644]	; 3e2cc <dwt_ioctl+0xba0>
   3e048:	2310      	movs	r3, #16
   3e04a:	9300      	str	r3, [sp, #0]
   3e04c:	23ff      	movs	r3, #255	; 0xff
   3e04e:	2200      	movs	r2, #0
   3e050:	4641      	mov	r1, r8
   3e052:	f7fe fcc5 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e056:	f44f 7182 	mov.w	r1, #260	; 0x104
   3e05a:	4630      	mov	r0, r6
   3e05c:	f7fe f916 	bl	3c28c <ull_aon_read>
   3e060:	f000 05e0 	and.w	r5, r0, #224	; 0xe0
   3e064:	462a      	mov	r2, r5
   3e066:	f44f 7182 	mov.w	r1, #260	; 0x104
   3e06a:	4630      	mov	r0, r6
   3e06c:	f7fe f92e 	bl	3c2cc <ull_aon_write>
   3e070:	f045 0204 	orr.w	r2, r5, #4
   3e074:	f44f 7182 	mov.w	r1, #260	; 0x104
   3e078:	4630      	mov	r0, r6
   3e07a:	f7fe f927 	bl	3c2cc <ull_aon_write>
   3e07e:	2002      	movs	r0, #2
   3e080:	f7f0 fba5 	bl	2e7ce <deca_sleep>
   3e084:	f44f 7187 	mov.w	r1, #270	; 0x10e
   3e088:	4630      	mov	r0, r6
   3e08a:	f7fe f8ff 	bl	3c28c <ull_aon_read>
   3e08e:	4607      	mov	r7, r0
   3e090:	f240 110f 	movw	r1, #271	; 0x10f
   3e094:	4630      	mov	r0, r6
   3e096:	f7fe f8f9 	bl	3c28c <ull_aon_read>
   3e09a:	4681      	mov	r9, r0
   3e09c:	462a      	mov	r2, r5
   3e09e:	f44f 7182 	mov.w	r1, #260	; 0x104
   3e0a2:	4630      	mov	r0, r6
   3e0a4:	f7fe f912 	bl	3c2cc <ull_aon_write>
   3e0a8:	2500      	movs	r5, #0
   3e0aa:	9500      	str	r5, [sp, #0]
   3e0ac:	23ef      	movs	r3, #239	; 0xef
   3e0ae:	462a      	mov	r2, r5
   3e0b0:	4641      	mov	r1, r8
   3e0b2:	4630      	mov	r0, r6
   3e0b4:	f7fe fc94 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e0b8:	ea47 2709 	orr.w	r7, r7, r9, lsl #8
   3e0bc:	8027      	strh	r7, [r4, #0]
   3e0be:	f7ff bbdf 	b.w	3d880 <dwt_ioctl+0x154>
   3e0c2:	2c00      	cmp	r4, #0
   3e0c4:	f001 8277 	beq.w	3f5b6 <dwt_ioctl+0x1e8a>
   3e0c8:	78a2      	ldrb	r2, [r4, #2]
   3e0ca:	8821      	ldrh	r1, [r4, #0]
   3e0cc:	f7fe f926 	bl	3c31c <ull_configuresleep>
   3e0d0:	2500      	movs	r5, #0
   3e0d2:	f7ff bbd5 	b.w	3d880 <dwt_ioctl+0x154>
   3e0d6:	2c00      	cmp	r4, #0
   3e0d8:	f001 8270 	beq.w	3f5bc <dwt_ioctl+0x1e90>
   3e0dc:	6824      	ldr	r4, [r4, #0]
   3e0de:	f7fe f8a1 	bl	3c224 <ull_clearaonconfig>
   3e0e2:	2001      	movs	r0, #1
   3e0e4:	f7f0 fb73 	bl	2e7ce <deca_sleep>
   3e0e8:	2303      	movs	r3, #3
   3e0ea:	9300      	str	r3, [sp, #0]
   3e0ec:	23ff      	movs	r3, #255	; 0xff
   3e0ee:	2200      	movs	r2, #0
   3e0f0:	4974      	ldr	r1, [pc, #464]	; (3e2c4 <dwt_ioctl+0xb98>)
   3e0f2:	4630      	mov	r0, r6
   3e0f4:	f7fe fc74 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e0f8:	b97c      	cbnz	r4, 3e11a <dwt_ioctl+0x9ee>
   3e0fa:	4630      	mov	r0, r6
   3e0fc:	f7ff faee 	bl	3d6dc <ull_softreset_no_sema_fcmd>
   3e100:	2001      	movs	r0, #1
   3e102:	f7f0 fb64 	bl	2e7ce <deca_sleep>
   3e106:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3e108:	2500      	movs	r5, #0
   3e10a:	739d      	strb	r5, [r3, #14]
   3e10c:	2202      	movs	r2, #2
   3e10e:	821a      	strh	r2, [r3, #16]
   3e110:	751d      	strb	r5, [r3, #20]
   3e112:	755d      	strb	r5, [r3, #21]
   3e114:	73dd      	strb	r5, [r3, #15]
   3e116:	f7ff bbb3 	b.w	3d880 <dwt_ioctl+0x154>
   3e11a:	4630      	mov	r0, r6
   3e11c:	f7ff faf2 	bl	3d704 <ull_softreset_fcmd>
   3e120:	e7ee      	b.n	3e100 <dwt_ioctl+0x9d4>
   3e122:	2c00      	cmp	r4, #0
   3e124:	f001 824d 	beq.w	3f5c2 <dwt_ioctl+0x1e96>
   3e128:	7823      	ldrb	r3, [r4, #0]
   3e12a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   3e12e:	6d02      	ldr	r2, [r0, #80]	; 0x50
   3e130:	7353      	strb	r3, [r2, #13]
   3e132:	2200      	movs	r2, #0
   3e134:	4964      	ldr	r1, [pc, #400]	; (3e2c8 <dwt_ioctl+0xb9c>)
   3e136:	f7fe f81d 	bl	3c174 <dwt_write8bitoffsetreg>
   3e13a:	2500      	movs	r5, #0
   3e13c:	f7ff bba0 	b.w	3d880 <dwt_ioctl+0x154>
   3e140:	2c00      	cmp	r4, #0
   3e142:	f001 8241 	beq.w	3f5c8 <dwt_ioctl+0x1e9c>
   3e146:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3e148:	7b5b      	ldrb	r3, [r3, #13]
   3e14a:	7023      	strb	r3, [r4, #0]
   3e14c:	2500      	movs	r5, #0
   3e14e:	f7ff bb97 	b.w	3d880 <dwt_ioctl+0x154>
   3e152:	2101      	movs	r1, #1
   3e154:	f7fe faf6 	bl	3c744 <ull_enable_rf_tx>
   3e158:	4630      	mov	r0, r6
   3e15a:	f7fe fb27 	bl	3c7ac <ull_enable_rftx_blocks>
   3e15e:	2101      	movs	r1, #1
   3e160:	4630      	mov	r0, r6
   3e162:	f7fd fe2d 	bl	3bdc0 <ull_force_clocks>
   3e166:	220f      	movs	r2, #15
   3e168:	2101      	movs	r1, #1
   3e16a:	4630      	mov	r0, r6
   3e16c:	f7fe ff48 	bl	3d000 <ull_repeated_cw>
   3e170:	2500      	movs	r5, #0
   3e172:	f7ff bb85 	b.w	3d880 <dwt_ioctl+0x154>
   3e176:	2c00      	cmp	r4, #0
   3e178:	f001 8229 	beq.w	3f5ce <dwt_ioctl+0x1ea2>
   3e17c:	6862      	ldr	r2, [r4, #4]
   3e17e:	6821      	ldr	r1, [r4, #0]
   3e180:	f7fe ff3e 	bl	3d000 <ull_repeated_cw>
   3e184:	2500      	movs	r5, #0
   3e186:	f7ff bb7b 	b.w	3d880 <dwt_ioctl+0x154>
   3e18a:	2c00      	cmp	r4, #0
   3e18c:	f001 8222 	beq.w	3f5d4 <dwt_ioctl+0x1ea8>
   3e190:	4d4e      	ldr	r5, [pc, #312]	; (3e2cc <dwt_ioctl+0xba0>)
   3e192:	2200      	movs	r2, #0
   3e194:	4629      	mov	r1, r5
   3e196:	f7fd fa12 	bl	3b5be <dwt_read8bitoffsetreg>
   3e19a:	4680      	mov	r8, r0
   3e19c:	2302      	movs	r3, #2
   3e19e:	9300      	str	r3, [sp, #0]
   3e1a0:	23ff      	movs	r3, #255	; 0xff
   3e1a2:	2200      	movs	r2, #0
   3e1a4:	4629      	mov	r1, r5
   3e1a6:	4630      	mov	r0, r6
   3e1a8:	f7fe fc1a 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e1ac:	2304      	movs	r3, #4
   3e1ae:	2200      	movs	r2, #0
   3e1b0:	4947      	ldr	r1, [pc, #284]	; (3e2d0 <dwt_ioctl+0xba4>)
   3e1b2:	4630      	mov	r0, r6
   3e1b4:	f7fd ffde 	bl	3c174 <dwt_write8bitoffsetreg>
   3e1b8:	2301      	movs	r3, #1
   3e1ba:	2200      	movs	r2, #0
   3e1bc:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   3e1c0:	4630      	mov	r0, r6
   3e1c2:	f7fd ffd7 	bl	3c174 <dwt_write8bitoffsetreg>
   3e1c6:	4f43      	ldr	r7, [pc, #268]	; (3e2d4 <dwt_ioctl+0xba8>)
   3e1c8:	2500      	movs	r5, #0
   3e1ca:	462a      	mov	r2, r5
   3e1cc:	4639      	mov	r1, r7
   3e1ce:	4630      	mov	r0, r6
   3e1d0:	f7fd f9f5 	bl	3b5be <dwt_read8bitoffsetreg>
   3e1d4:	f010 0f01 	tst.w	r0, #1
   3e1d8:	d0f7      	beq.n	3e1ca <dwt_ioctl+0xa9e>
   3e1da:	2200      	movs	r2, #0
   3e1dc:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   3e1e0:	4630      	mov	r0, r6
   3e1e2:	f7fd f9da 	bl	3b59a <dwt_read16bitoffsetreg>
   3e1e6:	4605      	mov	r5, r0
   3e1e8:	2300      	movs	r3, #0
   3e1ea:	461a      	mov	r2, r3
   3e1ec:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   3e1f0:	4630      	mov	r0, r6
   3e1f2:	f7fd ffbf 	bl	3c174 <dwt_write8bitoffsetreg>
   3e1f6:	2300      	movs	r3, #0
   3e1f8:	461a      	mov	r2, r3
   3e1fa:	4935      	ldr	r1, [pc, #212]	; (3e2d0 <dwt_ioctl+0xba4>)
   3e1fc:	4630      	mov	r0, r6
   3e1fe:	f7fd ffb9 	bl	3c174 <dwt_write8bitoffsetreg>
   3e202:	4643      	mov	r3, r8
   3e204:	2200      	movs	r2, #0
   3e206:	4931      	ldr	r1, [pc, #196]	; (3e2cc <dwt_ioctl+0xba0>)
   3e208:	4630      	mov	r0, r6
   3e20a:	f7fd ffb3 	bl	3c174 <dwt_write8bitoffsetreg>
   3e20e:	8025      	strh	r5, [r4, #0]
   3e210:	2500      	movs	r5, #0
   3e212:	f7ff bb35 	b.w	3d880 <dwt_ioctl+0x154>
   3e216:	2c00      	cmp	r4, #0
   3e218:	f001 81df 	beq.w	3f5da <dwt_ioctl+0x1eae>
   3e21c:	7923      	ldrb	r3, [r4, #4]
   3e21e:	6d02      	ldr	r2, [r0, #80]	; 0x50
   3e220:	7a92      	ldrb	r2, [r2, #10]
   3e222:	1a9b      	subs	r3, r3, r2
   3e224:	ee07 3a90 	vmov	s15, r3
   3e228:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3e22c:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 3e2d8 <dwt_ioctl+0xbac>
   3e230:	ee67 7a87 	vmul.f32	s15, s15, s14
   3e234:	eeb3 7a06 	vmov.f32	s14, #54	; 0x41b00000  22.0
   3e238:	ee77 7a87 	vadd.f32	s15, s15, s14
   3e23c:	edc4 7a00 	vstr	s15, [r4]
   3e240:	2500      	movs	r5, #0
   3e242:	f7ff bb1d 	b.w	3d880 <dwt_ioctl+0x154>
   3e246:	2c00      	cmp	r4, #0
   3e248:	f001 81ca 	beq.w	3f5e0 <dwt_ioctl+0x1eb4>
   3e24c:	7923      	ldrb	r3, [r4, #4]
   3e24e:	6d02      	ldr	r2, [r0, #80]	; 0x50
   3e250:	7a52      	ldrb	r2, [r2, #9]
   3e252:	1a9b      	subs	r3, r3, r2
   3e254:	ee07 3a90 	vmov	s15, r3
   3e258:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   3e25c:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 3e2dc <dwt_ioctl+0xbb0>
   3e260:	ee67 7a87 	vmul.f32	s15, s15, s14
   3e264:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   3e268:	ee67 7a87 	vmul.f32	s15, s15, s14
   3e26c:	eddf 6a1c 	vldr	s13, [pc, #112]	; 3e2e0 <dwt_ioctl+0xbb4>
   3e270:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   3e274:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   3e278:	ee77 7a27 	vadd.f32	s15, s14, s15
   3e27c:	edc4 7a00 	vstr	s15, [r4]
   3e280:	2500      	movs	r5, #0
   3e282:	f7ff bafd 	b.w	3d880 <dwt_ioctl+0x154>
   3e286:	2c00      	cmp	r4, #0
   3e288:	f001 81ad 	beq.w	3f5e6 <dwt_ioctl+0x1eba>
   3e28c:	6824      	ldr	r4, [r4, #0]
   3e28e:	2101      	movs	r1, #1
   3e290:	f7fe fa58 	bl	3c744 <ull_enable_rf_tx>
   3e294:	4630      	mov	r0, r6
   3e296:	f7fe fa89 	bl	3c7ac <ull_enable_rftx_blocks>
   3e29a:	2101      	movs	r1, #1
   3e29c:	4630      	mov	r0, r6
   3e29e:	f7fd fd8f 	bl	3bdc0 <ull_force_clocks>
   3e2a2:	4621      	mov	r1, r4
   3e2a4:	4630      	mov	r0, r6
   3e2a6:	f7fe fc41 	bl	3cb2c <ull_repeated_frames>
   3e2aa:	2500      	movs	r5, #0
   3e2ac:	f7ff bae8 	b.w	3d880 <dwt_ioctl+0x154>
   3e2b0:	00180014 	.word	0x00180014
   3e2b4:	000c001c 	.word	0x000c001c
   3e2b8:	000c0018 	.word	0x000c0018
   3e2bc:	000a0004 	.word	0x000a0004
   3e2c0:	00110008 	.word	0x00110008
   3e2c4:	00110004 	.word	0x00110004
   3e2c8:	00090014 	.word	0x00090014
   3e2cc:	00070048 	.word	0x00070048
   3e2d0:	00070034 	.word	0x00070034
   3e2d4:	00080004 	.word	0x00080004
   3e2d8:	3f866666 	.word	0x3f866666
   3e2dc:	3ecccccd 	.word	0x3ecccccd
   3e2e0:	437f0000 	.word	0x437f0000
   3e2e4:	2500      	movs	r5, #0
   3e2e6:	9500      	str	r5, [sp, #0]
   3e2e8:	23ef      	movs	r3, #239	; 0xef
   3e2ea:	462a      	mov	r2, r5
   3e2ec:	49c7      	ldr	r1, [pc, #796]	; (3e60c <dwt_ioctl+0xee0>)
   3e2ee:	f7fe fb77 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e2f2:	2105      	movs	r1, #5
   3e2f4:	4630      	mov	r0, r6
   3e2f6:	f7fd fd63 	bl	3bdc0 <ull_force_clocks>
   3e2fa:	2101      	movs	r1, #1
   3e2fc:	4630      	mov	r0, r6
   3e2fe:	f7fd fee5 	bl	3c0cc <ull_disable_rf_tx>
   3e302:	4630      	mov	r0, r6
   3e304:	f7fd fed8 	bl	3c0b8 <ull_disable_rftx_blocks>
   3e308:	f7ff baba 	b.w	3d880 <dwt_ioctl+0x154>
   3e30c:	2500      	movs	r5, #0
   3e30e:	9500      	str	r5, [sp, #0]
   3e310:	23ef      	movs	r3, #239	; 0xef
   3e312:	462a      	mov	r2, r5
   3e314:	49bd      	ldr	r1, [pc, #756]	; (3e60c <dwt_ioctl+0xee0>)
   3e316:	f7fe fb63 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3e31a:	f7ff bab1 	b.w	3d880 <dwt_ioctl+0x154>
   3e31e:	2c00      	cmp	r4, #0
   3e320:	f001 8164 	beq.w	3f5ec <dwt_ioctl+0x1ec0>
   3e324:	6821      	ldr	r1, [r4, #0]
   3e326:	f7fe fc01 	bl	3cb2c <ull_repeated_frames>
   3e32a:	2500      	movs	r5, #0
   3e32c:	f7ff baa8 	b.w	3d880 <dwt_ioctl+0x154>
   3e330:	2200      	movs	r2, #0
   3e332:	49b7      	ldr	r1, [pc, #732]	; (3e610 <dwt_ioctl+0xee4>)
   3e334:	f7fd f931 	bl	3b59a <dwt_read16bitoffsetreg>
   3e338:	f3c0 050b 	ubfx	r5, r0, #0, #12
   3e33c:	f410 6f00 	tst.w	r0, #2048	; 0x800
   3e340:	bf18      	it	ne
   3e342:	f445 4570 	orrne.w	r5, r5, #61440	; 0xf000
   3e346:	b22d      	sxth	r5, r5
   3e348:	8025      	strh	r5, [r4, #0]
   3e34a:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3e34c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
   3e350:	1aed      	subs	r5, r5, r3
   3e352:	f7ff ba95 	b.w	3d880 <dwt_ioctl+0x154>
   3e356:	2c00      	cmp	r4, #0
   3e358:	f001 814b 	beq.w	3f5f2 <dwt_ioctl+0x1ec6>
   3e35c:	f8d4 9004 	ldr.w	r9, [r4, #4]
   3e360:	7a23      	ldrb	r3, [r4, #8]
   3e362:	f899 2013 	ldrb.w	r2, [r9, #19]
   3e366:	2aff      	cmp	r2, #255	; 0xff
   3e368:	f000 8122 	beq.w	3e5b0 <dwt_ioctl+0xe84>
   3e36c:	2b00      	cmp	r3, #0
   3e36e:	d136      	bne.n	3e3de <dwt_ioctl+0xcb2>
   3e370:	f8d9 3000 	ldr.w	r3, [r9]
   3e374:	9300      	str	r3, [sp, #0]
   3e376:	230c      	movs	r3, #12
   3e378:	2200      	movs	r2, #0
   3e37a:	49a6      	ldr	r1, [pc, #664]	; (3e614 <dwt_ioctl+0xee8>)
   3e37c:	f7fd fd04 	bl	3bd88 <dwt_writetodevice>
   3e380:	f899 300c 	ldrb.w	r3, [r9, #12]
   3e384:	f8b9 200e 	ldrh.w	r2, [r9, #14]
   3e388:	18d1      	adds	r1, r2, r3
   3e38a:	f899 2012 	ldrb.w	r2, [r9, #18]
   3e38e:	2a00      	cmp	r2, #0
   3e390:	d15f      	bne.n	3e452 <dwt_ioctl+0xd26>
   3e392:	f899 0010 	ldrb.w	r0, [r9, #16]
   3e396:	2800      	cmp	r0, #0
   3e398:	bf0b      	itete	eq
   3e39a:	227f      	moveq	r2, #127	; 0x7f
   3e39c:	f44f 6280 	movne.w	r2, #1024	; 0x400
   3e3a0:	f44f 15b0 	moveq.w	r5, #1441792	; 0x160000
   3e3a4:	f44f 15a0 	movne.w	r5, #1310720	; 0x140000
   3e3a8:	f899 0013 	ldrb.w	r0, [r9, #19]
   3e3ac:	1a12      	subs	r2, r2, r0
   3e3ae:	3a02      	subs	r2, #2
   3e3b0:	4291      	cmp	r1, r2
   3e3b2:	f200 8103 	bhi.w	3e5bc <dwt_ioctl+0xe90>
   3e3b6:	f8d9 2004 	ldr.w	r2, [r9, #4]
   3e3ba:	9200      	str	r2, [sp, #0]
   3e3bc:	2200      	movs	r2, #0
   3e3be:	4629      	mov	r1, r5
   3e3c0:	4630      	mov	r0, r6
   3e3c2:	f7fd fce1 	bl	3bd88 <dwt_writetodevice>
   3e3c6:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   3e3ca:	f899 200c 	ldrb.w	r2, [r9, #12]
   3e3ce:	f8d9 1008 	ldr.w	r1, [r9, #8]
   3e3d2:	9100      	str	r1, [sp, #0]
   3e3d4:	4629      	mov	r1, r5
   3e3d6:	4630      	mov	r0, r6
   3e3d8:	f7fd fcd6 	bl	3bd88 <dwt_writetodevice>
   3e3dc:	e04a      	b.n	3e474 <dwt_ioctl+0xd48>
   3e3de:	f8d9 3000 	ldr.w	r3, [r9]
   3e3e2:	f8b9 100e 	ldrh.w	r1, [r9, #14]
   3e3e6:	7a9a      	ldrb	r2, [r3, #10]
   3e3e8:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
   3e3ec:	7a5a      	ldrb	r2, [r3, #9]
   3e3ee:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   3e3f2:	7a1a      	ldrb	r2, [r3, #8]
   3e3f4:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
   3e3f8:	79da      	ldrb	r2, [r3, #7]
   3e3fa:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
   3e3fe:	799a      	ldrb	r2, [r3, #6]
   3e400:	f88d 2034 	strb.w	r2, [sp, #52]	; 0x34
   3e404:	795a      	ldrb	r2, [r3, #5]
   3e406:	f88d 2035 	strb.w	r2, [sp, #53]	; 0x35
   3e40a:	791a      	ldrb	r2, [r3, #4]
   3e40c:	f88d 2036 	strb.w	r2, [sp, #54]	; 0x36
   3e410:	78da      	ldrb	r2, [r3, #3]
   3e412:	f88d 2037 	strb.w	r2, [sp, #55]	; 0x37
   3e416:	789a      	ldrb	r2, [r3, #2]
   3e418:	f88d 2038 	strb.w	r2, [sp, #56]	; 0x38
   3e41c:	785a      	ldrb	r2, [r3, #1]
   3e41e:	f88d 2039 	strb.w	r2, [sp, #57]	; 0x39
   3e422:	781a      	ldrb	r2, [r3, #0]
   3e424:	f88d 203a 	strb.w	r2, [sp, #58]	; 0x3a
   3e428:	2200      	movs	r2, #0
   3e42a:	f88d 203b 	strb.w	r2, [sp, #59]	; 0x3b
   3e42e:	f88d 103c 	strb.w	r1, [sp, #60]	; 0x3c
   3e432:	0a09      	lsrs	r1, r1, #8
   3e434:	f88d 103d 	strb.w	r1, [sp, #61]	; 0x3d
   3e438:	7b19      	ldrb	r1, [r3, #12]
   3e43a:	f88d 103e 	strb.w	r1, [sp, #62]	; 0x3e
   3e43e:	7adb      	ldrb	r3, [r3, #11]
   3e440:	f88d 303f 	strb.w	r3, [sp, #63]	; 0x3f
   3e444:	ab0c      	add	r3, sp, #48	; 0x30
   3e446:	9300      	str	r3, [sp, #0]
   3e448:	2310      	movs	r3, #16
   3e44a:	4972      	ldr	r1, [pc, #456]	; (3e614 <dwt_ioctl+0xee8>)
   3e44c:	f7fd fc9c 	bl	3bd88 <dwt_writetodevice>
   3e450:	e796      	b.n	3e380 <dwt_ioctl+0xc54>
   3e452:	2a01      	cmp	r2, #1
   3e454:	f040 80af 	bne.w	3e5b6 <dwt_ioctl+0xe8a>
   3e458:	f899 3011 	ldrb.w	r3, [r9, #17]
   3e45c:	2b00      	cmp	r3, #0
   3e45e:	f240 33ff 	movw	r3, #1023	; 0x3ff
   3e462:	bf08      	it	eq
   3e464:	237f      	moveq	r3, #127	; 0x7f
   3e466:	f899 2013 	ldrb.w	r2, [r9, #19]
   3e46a:	1a9b      	subs	r3, r3, r2
   3e46c:	3b02      	subs	r3, #2
   3e46e:	4299      	cmp	r1, r3
   3e470:	f200 80a7 	bhi.w	3e5c2 <dwt_ioctl+0xe96>
   3e474:	f899 2010 	ldrb.w	r2, [r9, #16]
   3e478:	1e53      	subs	r3, r2, #1
   3e47a:	b2db      	uxtb	r3, r3
   3e47c:	2b01      	cmp	r3, #1
   3e47e:	d940      	bls.n	3e502 <dwt_ioctl+0xdd6>
   3e480:	f899 3011 	ldrb.w	r3, [r9, #17]
   3e484:	1e59      	subs	r1, r3, #1
   3e486:	b2c9      	uxtb	r1, r1
   3e488:	2901      	cmp	r1, #1
   3e48a:	d947      	bls.n	3e51c <dwt_ioctl+0xdf0>
   3e48c:	2b04      	cmp	r3, #4
   3e48e:	d04c      	beq.n	3e52a <dwt_ioctl+0xdfe>
   3e490:	ea42 3343 	orr.w	r3, r2, r3, lsl #13
   3e494:	2200      	movs	r2, #0
   3e496:	4960      	ldr	r1, [pc, #384]	; (3e618 <dwt_ioctl+0xeec>)
   3e498:	4630      	mov	r0, r6
   3e49a:	f7fd fcdd 	bl	3be58 <dwt_write32bitoffsetreg>
   3e49e:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   3e4a2:	4a5e      	ldr	r2, [pc, #376]	; (3e61c <dwt_ioctl+0xef0>)
   3e4a4:	ea02 12c3 	and.w	r2, r2, r3, lsl #7
   3e4a8:	f899 300c 	ldrb.w	r3, [r9, #12]
   3e4ac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   3e4b0:	4313      	orrs	r3, r2
   3e4b2:	2200      	movs	r2, #0
   3e4b4:	495a      	ldr	r1, [pc, #360]	; (3e620 <dwt_ioctl+0xef4>)
   3e4b6:	4630      	mov	r0, r6
   3e4b8:	f7fd fcce 	bl	3be58 <dwt_write32bitoffsetreg>
   3e4bc:	2301      	movs	r3, #1
   3e4be:	2200      	movs	r2, #0
   3e4c0:	4958      	ldr	r1, [pc, #352]	; (3e624 <dwt_ioctl+0xef8>)
   3e4c2:	4630      	mov	r0, r6
   3e4c4:	f7fd fe56 	bl	3c174 <dwt_write8bitoffsetreg>
   3e4c8:	f8df 815c 	ldr.w	r8, [pc, #348]	; 3e628 <dwt_ioctl+0xefc>
   3e4cc:	2700      	movs	r7, #0
   3e4ce:	463a      	mov	r2, r7
   3e4d0:	4641      	mov	r1, r8
   3e4d2:	4630      	mov	r0, r6
   3e4d4:	f7fd f873 	bl	3b5be <dwt_read8bitoffsetreg>
   3e4d8:	f010 0f05 	tst.w	r0, #5
   3e4dc:	d0f7      	beq.n	3e4ce <dwt_ioctl+0xda2>
   3e4de:	4605      	mov	r5, r0
   3e4e0:	4603      	mov	r3, r0
   3e4e2:	2200      	movs	r2, #0
   3e4e4:	4950      	ldr	r1, [pc, #320]	; (3e628 <dwt_ioctl+0xefc>)
   3e4e6:	4630      	mov	r0, r6
   3e4e8:	f7fd fe44 	bl	3c174 <dwt_write8bitoffsetreg>
   3e4ec:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   3e4f0:	f025 0330 	bic.w	r3, r5, #48	; 0x30
   3e4f4:	2b01      	cmp	r3, #1
   3e4f6:	d025      	beq.n	3e544 <dwt_ioctl+0xe18>
   3e4f8:	b26b      	sxtb	r3, r5
   3e4fa:	7023      	strb	r3, [r4, #0]
   3e4fc:	2500      	movs	r5, #0
   3e4fe:	f7ff b9bf 	b.w	3d880 <dwt_ioctl+0x154>
   3e502:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3e504:	7b9b      	ldrb	r3, [r3, #14]
   3e506:	2b03      	cmp	r3, #3
   3e508:	f001 8123 	beq.w	3f752 <dwt_ioctl+0x2026>
   3e50c:	f899 3011 	ldrb.w	r3, [r9, #17]
   3e510:	1e5a      	subs	r2, r3, #1
   3e512:	b2d2      	uxtb	r2, r2
   3e514:	2a01      	cmp	r2, #1
   3e516:	d912      	bls.n	3e53e <dwt_ioctl+0xe12>
   3e518:	2201      	movs	r2, #1
   3e51a:	e7b7      	b.n	3e48c <dwt_ioctl+0xd60>
   3e51c:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3e51e:	7b9b      	ldrb	r3, [r3, #14]
   3e520:	2b03      	cmp	r3, #3
   3e522:	bf0c      	ite	eq
   3e524:	2302      	moveq	r3, #2
   3e526:	2301      	movne	r3, #1
   3e528:	e7b2      	b.n	3e490 <dwt_ioctl+0xd64>
   3e52a:	f8b9 100e 	ldrh.w	r1, [r9, #14]
   3e52e:	2910      	cmp	r1, #16
   3e530:	d9ae      	bls.n	3e490 <dwt_ioctl+0xd64>
   3e532:	f06f 0303 	mvn.w	r3, #3
   3e536:	e7e0      	b.n	3e4fa <dwt_ioctl+0xdce>
   3e538:	2202      	movs	r2, #2
   3e53a:	4613      	mov	r3, r2
   3e53c:	e7a8      	b.n	3e490 <dwt_ioctl+0xd64>
   3e53e:	2201      	movs	r2, #1
   3e540:	4613      	mov	r3, r2
   3e542:	e7a5      	b.n	3e490 <dwt_ioctl+0xd64>
   3e544:	f899 3012 	ldrb.w	r3, [r9, #18]
   3e548:	2b01      	cmp	r3, #1
   3e54a:	d1d5      	bne.n	3e4f8 <dwt_ioctl+0xdcc>
   3e54c:	f899 2011 	ldrb.w	r2, [r9, #17]
   3e550:	1e53      	subs	r3, r2, #1
   3e552:	b2db      	uxtb	r3, r3
   3e554:	2b01      	cmp	r3, #1
   3e556:	d91b      	bls.n	3e590 <dwt_ioctl+0xe64>
   3e558:	2a03      	cmp	r2, #3
   3e55a:	bf0c      	ite	eq
   3e55c:	f44f 17a0 	moveq.w	r7, #1310720	; 0x140000
   3e560:	f44f 17b0 	movne.w	r7, #1441792	; 0x160000
   3e564:	f8d9 2004 	ldr.w	r2, [r9, #4]
   3e568:	b112      	cbz	r2, 3e570 <dwt_ioctl+0xe44>
   3e56a:	f899 300c 	ldrb.w	r3, [r9, #12]
   3e56e:	b9c3      	cbnz	r3, 3e5a2 <dwt_ioctl+0xe76>
   3e570:	f8d9 1008 	ldr.w	r1, [r9, #8]
   3e574:	2900      	cmp	r1, #0
   3e576:	d0bf      	beq.n	3e4f8 <dwt_ioctl+0xdcc>
   3e578:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   3e57c:	2b00      	cmp	r3, #0
   3e57e:	d0bb      	beq.n	3e4f8 <dwt_ioctl+0xdcc>
   3e580:	f899 200c 	ldrb.w	r2, [r9, #12]
   3e584:	9100      	str	r1, [sp, #0]
   3e586:	4639      	mov	r1, r7
   3e588:	4630      	mov	r0, r6
   3e58a:	f7fc ffe6 	bl	3b55a <dwt_readfromdevice>
   3e58e:	e7b3      	b.n	3e4f8 <dwt_ioctl+0xdcc>
   3e590:	6d33      	ldr	r3, [r6, #80]	; 0x50
   3e592:	7b9b      	ldrb	r3, [r3, #14]
   3e594:	2b03      	cmp	r3, #3
   3e596:	bf0c      	ite	eq
   3e598:	f44f 1798 	moveq.w	r7, #1245184	; 0x130000
   3e59c:	f44f 1790 	movne.w	r7, #1179648	; 0x120000
   3e5a0:	e7e0      	b.n	3e564 <dwt_ioctl+0xe38>
   3e5a2:	9200      	str	r2, [sp, #0]
   3e5a4:	2200      	movs	r2, #0
   3e5a6:	4639      	mov	r1, r7
   3e5a8:	4630      	mov	r0, r6
   3e5aa:	f7fc ffd6 	bl	3b55a <dwt_readfromdevice>
   3e5ae:	e7df      	b.n	3e570 <dwt_ioctl+0xe44>
   3e5b0:	f06f 0302 	mvn.w	r3, #2
   3e5b4:	e7a1      	b.n	3e4fa <dwt_ioctl+0xdce>
   3e5b6:	f06f 0301 	mvn.w	r3, #1
   3e5ba:	e79e      	b.n	3e4fa <dwt_ioctl+0xdce>
   3e5bc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3e5c0:	e79b      	b.n	3e4fa <dwt_ioctl+0xdce>
   3e5c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3e5c6:	e798      	b.n	3e4fa <dwt_ioctl+0xdce>
   3e5c8:	7a23      	ldrb	r3, [r4, #8]
   3e5ca:	79e1      	ldrb	r1, [r4, #7]
   3e5cc:	79a2      	ldrb	r2, [r4, #6]
   3e5ce:	00d2      	lsls	r2, r2, #3
   3e5d0:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
   3e5d4:	4313      	orrs	r3, r2
   3e5d6:	7962      	ldrb	r2, [r4, #5]
   3e5d8:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
   3e5dc:	7922      	ldrb	r2, [r4, #4]
   3e5de:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   3e5e2:	78e2      	ldrb	r2, [r4, #3]
   3e5e4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3e5e8:	78a2      	ldrb	r2, [r4, #2]
   3e5ea:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
   3e5ee:	7862      	ldrb	r2, [r4, #1]
   3e5f0:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
   3e5f4:	7822      	ldrb	r2, [r4, #0]
   3e5f6:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
   3e5fa:	b29b      	uxth	r3, r3
   3e5fc:	2200      	movs	r2, #0
   3e5fe:	490b      	ldr	r1, [pc, #44]	; (3e62c <dwt_ioctl+0xf00>)
   3e600:	f7fd fbcd 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e604:	2500      	movs	r5, #0
   3e606:	f7ff b93b 	b.w	3d880 <dwt_ioctl+0x154>
   3e60a:	bf00      	nop
   3e60c:	000f0028 	.word	0x000f0028
   3e610:	00020008 	.word	0x00020008
   3e614:	00010034 	.word	0x00010034
   3e618:	00010044 	.word	0x00010044
   3e61c:	0001ff80 	.word	0x0001ff80
   3e620:	00010048 	.word	0x00010048
   3e624:	0001004c 	.word	0x0001004c
   3e628:	00010050 	.word	0x00010050
   3e62c:	00010030 	.word	0x00010030
   3e630:	2c00      	cmp	r4, #0
   3e632:	f000 87e1 	beq.w	3f5f8 <dwt_ioctl+0x1ecc>
   3e636:	7863      	ldrb	r3, [r4, #1]
   3e638:	b133      	cbz	r3, 3e648 <dwt_ioctl+0xf1c>
   3e63a:	085b      	lsrs	r3, r3, #1
   3e63c:	3b01      	subs	r3, #1
   3e63e:	b2db      	uxtb	r3, r3
   3e640:	7023      	strb	r3, [r4, #0]
   3e642:	2500      	movs	r5, #0
   3e644:	f7ff b91c 	b.w	3d880 <dwt_ioctl+0x154>
   3e648:	2300      	movs	r3, #0
   3e64a:	e7f9      	b.n	3e640 <dwt_ioctl+0xf14>
   3e64c:	2200      	movs	r2, #0
   3e64e:	49d0      	ldr	r1, [pc, #832]	; (3e990 <dwt_ioctl+0x1264>)
   3e650:	f7fc ff8d 	bl	3b56e <dwt_read32bitoffsetreg>
   3e654:	f3c0 030b 	ubfx	r3, r0, #0, #12
   3e658:	8023      	strh	r3, [r4, #0]
   3e65a:	f3c0 400b 	ubfx	r0, r0, #16, #12
   3e65e:	8060      	strh	r0, [r4, #2]
   3e660:	2200      	movs	r2, #0
   3e662:	49cc      	ldr	r1, [pc, #816]	; (3e994 <dwt_ioctl+0x1268>)
   3e664:	4630      	mov	r0, r6
   3e666:	f7fc ff82 	bl	3b56e <dwt_read32bitoffsetreg>
   3e66a:	f3c0 030b 	ubfx	r3, r0, #0, #12
   3e66e:	80a3      	strh	r3, [r4, #4]
   3e670:	f3c0 400b 	ubfx	r0, r0, #16, #12
   3e674:	80e0      	strh	r0, [r4, #6]
   3e676:	2200      	movs	r2, #0
   3e678:	49c7      	ldr	r1, [pc, #796]	; (3e998 <dwt_ioctl+0x126c>)
   3e67a:	4630      	mov	r0, r6
   3e67c:	f7fc ff77 	bl	3b56e <dwt_read32bitoffsetreg>
   3e680:	7220      	strb	r0, [r4, #8]
   3e682:	0c00      	lsrs	r0, r0, #16
   3e684:	7260      	strb	r0, [r4, #9]
   3e686:	2200      	movs	r2, #0
   3e688:	49c4      	ldr	r1, [pc, #784]	; (3e99c <dwt_ioctl+0x1270>)
   3e68a:	4630      	mov	r0, r6
   3e68c:	f7fc ff6f 	bl	3b56e <dwt_read32bitoffsetreg>
   3e690:	f3c0 430b 	ubfx	r3, r0, #16, #12
   3e694:	81a3      	strh	r3, [r4, #12]
   3e696:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3e69a:	8160      	strh	r0, [r4, #10]
   3e69c:	2200      	movs	r2, #0
   3e69e:	49c0      	ldr	r1, [pc, #768]	; (3e9a0 <dwt_ioctl+0x1274>)
   3e6a0:	4630      	mov	r0, r6
   3e6a2:	f7fc ff64 	bl	3b56e <dwt_read32bitoffsetreg>
   3e6a6:	f3c0 430b 	ubfx	r3, r0, #16, #12
   3e6aa:	f8a4 300f 	strh.w	r3, [r4, #15]
   3e6ae:	73a0      	strb	r0, [r4, #14]
   3e6b0:	2200      	movs	r2, #0
   3e6b2:	49bc      	ldr	r1, [pc, #752]	; (3e9a4 <dwt_ioctl+0x1278>)
   3e6b4:	4630      	mov	r0, r6
   3e6b6:	f7fc ff5a 	bl	3b56e <dwt_read32bitoffsetreg>
   3e6ba:	7460      	strb	r0, [r4, #17]
   3e6bc:	0c00      	lsrs	r0, r0, #16
   3e6be:	74a0      	strb	r0, [r4, #18]
   3e6c0:	2200      	movs	r2, #0
   3e6c2:	49b9      	ldr	r1, [pc, #740]	; (3e9a8 <dwt_ioctl+0x127c>)
   3e6c4:	4630      	mov	r0, r6
   3e6c6:	f7fc ff52 	bl	3b56e <dwt_read32bitoffsetreg>
   3e6ca:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3e6ce:	f8a4 0013 	strh.w	r0, [r4, #19]
   3e6d2:	2500      	movs	r5, #0
   3e6d4:	7565      	strb	r5, [r4, #21]
   3e6d6:	75a5      	strb	r5, [r4, #22]
   3e6d8:	462a      	mov	r2, r5
   3e6da:	49b4      	ldr	r1, [pc, #720]	; (3e9ac <dwt_ioctl+0x1280>)
   3e6dc:	4630      	mov	r0, r6
   3e6de:	f7fc ff6e 	bl	3b5be <dwt_read8bitoffsetreg>
   3e6e2:	75e0      	strb	r0, [r4, #23]
   3e6e4:	f7ff b8cc 	b.w	3d880 <dwt_ioctl+0x154>
   3e6e8:	4611      	mov	r1, r2
   3e6ea:	f7fd fdbb 	bl	3c264 <ull_configeventcounters>
   3e6ee:	2500      	movs	r5, #0
   3e6f0:	f7ff b8c6 	b.w	3d880 <dwt_ioctl+0x154>
   3e6f4:	2c00      	cmp	r4, #0
   3e6f6:	f000 8782 	beq.w	3f5fe <dwt_ioctl+0x1ed2>
   3e6fa:	8823      	ldrh	r3, [r4, #0]
   3e6fc:	2200      	movs	r2, #0
   3e6fe:	49ac      	ldr	r1, [pc, #688]	; (3e9b0 <dwt_ioctl+0x1284>)
   3e700:	f7fd fb4d 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e704:	2500      	movs	r5, #0
   3e706:	f7ff b8bb 	b.w	3d880 <dwt_ioctl+0x154>
   3e70a:	2c00      	cmp	r4, #0
   3e70c:	f000 877a 	beq.w	3f604 <dwt_ioctl+0x1ed8>
   3e710:	6825      	ldr	r5, [r4, #0]
   3e712:	b935      	cbnz	r5, 3e722 <dwt_ioctl+0xff6>
   3e714:	2300      	movs	r3, #0
   3e716:	461a      	mov	r2, r3
   3e718:	49a6      	ldr	r1, [pc, #664]	; (3e9b4 <dwt_ioctl+0x1288>)
   3e71a:	f7fd fb40 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e71e:	f7ff b8af 	b.w	3d880 <dwt_ioctl+0x154>
   3e722:	7962      	ldrb	r2, [r4, #5]
   3e724:	7923      	ldrb	r3, [r4, #4]
   3e726:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3e72a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
   3e72e:	2200      	movs	r2, #0
   3e730:	49a0      	ldr	r1, [pc, #640]	; (3e9b4 <dwt_ioctl+0x1288>)
   3e732:	f7fd fb34 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e736:	2500      	movs	r5, #0
   3e738:	f7ff b8a2 	b.w	3d880 <dwt_ioctl+0x154>
   3e73c:	2c00      	cmp	r4, #0
   3e73e:	f000 8764 	beq.w	3f60a <dwt_ioctl+0x1ede>
   3e742:	6823      	ldr	r3, [r4, #0]
   3e744:	b94b      	cbnz	r3, 3e75a <dwt_ioctl+0x102e>
   3e746:	2500      	movs	r5, #0
   3e748:	9500      	str	r5, [sp, #0]
   3e74a:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   3e74e:	462a      	mov	r2, r5
   3e750:	2110      	movs	r1, #16
   3e752:	f7fe fb61 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3e756:	f7ff b893 	b.w	3d880 <dwt_ioctl+0x154>
   3e75a:	2200      	movs	r2, #0
   3e75c:	2134      	movs	r1, #52	; 0x34
   3e75e:	f7fd fb7b 	bl	3be58 <dwt_write32bitoffsetreg>
   3e762:	f44f 7300 	mov.w	r3, #512	; 0x200
   3e766:	9300      	str	r3, [sp, #0]
   3e768:	f64f 73ff 	movw	r3, #65535	; 0xffff
   3e76c:	2200      	movs	r2, #0
   3e76e:	2110      	movs	r1, #16
   3e770:	4630      	mov	r0, r6
   3e772:	f7fe fb51 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3e776:	2500      	movs	r5, #0
   3e778:	f7ff b882 	b.w	3d880 <dwt_ioctl+0x154>
   3e77c:	2c00      	cmp	r4, #0
   3e77e:	f000 8747 	beq.w	3f610 <dwt_ioctl+0x1ee4>
   3e782:	8861      	ldrh	r1, [r4, #2]
   3e784:	f7fd fd82 	bl	3c28c <ull_aon_read>
   3e788:	7020      	strb	r0, [r4, #0]
   3e78a:	2500      	movs	r5, #0
   3e78c:	f7ff b878 	b.w	3d880 <dwt_ioctl+0x154>
   3e790:	2c00      	cmp	r4, #0
   3e792:	f000 8740 	beq.w	3f616 <dwt_ioctl+0x1eea>
   3e796:	78a2      	ldrb	r2, [r4, #2]
   3e798:	8821      	ldrh	r1, [r4, #0]
   3e79a:	f7fd fd97 	bl	3c2cc <ull_aon_write>
   3e79e:	2500      	movs	r5, #0
   3e7a0:	f7ff b86e 	b.w	3d880 <dwt_ioctl+0x154>
   3e7a4:	4b84      	ldr	r3, [pc, #528]	; (3e9b8 <dwt_ioctl+0x128c>)
   3e7a6:	4a85      	ldr	r2, [pc, #532]	; (3e9bc <dwt_ioctl+0x1290>)
   3e7a8:	2d01      	cmp	r5, #1
   3e7aa:	bf18      	it	ne
   3e7ac:	4613      	movne	r3, r2
   3e7ae:	2d01      	cmp	r5, #1
   3e7b0:	4983      	ldr	r1, [pc, #524]	; (3e9c0 <dwt_ioctl+0x1294>)
   3e7b2:	bf18      	it	ne
   3e7b4:	f04f 110c 	movne.w	r1, #786444	; 0xc000c
   3e7b8:	6d02      	ldr	r2, [r0, #80]	; 0x50
   3e7ba:	7b92      	ldrb	r2, [r2, #14]
   3e7bc:	2a01      	cmp	r2, #1
   3e7be:	d012      	beq.n	3e7e6 <dwt_ioctl+0x10ba>
   3e7c0:	2a03      	cmp	r2, #3
   3e7c2:	d117      	bne.n	3e7f4 <dwt_ioctl+0x10c8>
   3e7c4:	f5a2 12c0 	sub.w	r2, r2, #1572864	; 0x180000
   3e7c8:	3a01      	subs	r2, #1
   3e7ca:	441a      	add	r2, r3
   3e7cc:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3e7d0:	f7fc fee3 	bl	3b59a <dwt_read16bitoffsetreg>
   3e7d4:	09c0      	lsrs	r0, r0, #7
   3e7d6:	8020      	strh	r0, [r4, #0]
   3e7d8:	8825      	ldrh	r5, [r4, #0]
   3e7da:	3500      	adds	r5, #0
   3e7dc:	bf18      	it	ne
   3e7de:	2501      	movne	r5, #1
   3e7e0:	426d      	negs	r5, r5
   3e7e2:	f7ff b84d 	b.w	3d880 <dwt_ioctl+0x154>
   3e7e6:	2202      	movs	r2, #2
   3e7e8:	4619      	mov	r1, r3
   3e7ea:	f7fc fed6 	bl	3b59a <dwt_read16bitoffsetreg>
   3e7ee:	09c0      	lsrs	r0, r0, #7
   3e7f0:	8020      	strh	r0, [r4, #0]
   3e7f2:	e7f1      	b.n	3e7d8 <dwt_ioctl+0x10ac>
   3e7f4:	2202      	movs	r2, #2
   3e7f6:	f7fc fed0 	bl	3b59a <dwt_read16bitoffsetreg>
   3e7fa:	09c0      	lsrs	r0, r0, #7
   3e7fc:	8020      	strh	r0, [r4, #0]
   3e7fe:	e7eb      	b.n	3e7d8 <dwt_ioctl+0x10ac>
   3e800:	2c00      	cmp	r4, #0
   3e802:	f000 870b 	beq.w	3f61c <dwt_ioctl+0x1ef0>
   3e806:	7821      	ldrb	r1, [r4, #0]
   3e808:	f7fe fb20 	bl	3ce4c <ull_setleds>
   3e80c:	2500      	movs	r5, #0
   3e80e:	f7ff b837 	b.w	3d880 <dwt_ioctl+0x154>
   3e812:	4611      	mov	r1, r2
   3e814:	f7fe f9a2 	bl	3cb5c <ull_setdwstate>
   3e818:	2500      	movs	r5, #0
   3e81a:	f7ff b831 	b.w	3d880 <dwt_ioctl+0x154>
   3e81e:	9400      	str	r4, [sp, #0]
   3e820:	2304      	movs	r3, #4
   3e822:	2200      	movs	r2, #0
   3e824:	211c      	movs	r1, #28
   3e826:	f7fc fe98 	bl	3b55a <dwt_readfromdevice>
   3e82a:	2500      	movs	r5, #0
   3e82c:	f7ff b828 	b.w	3d880 <dwt_ioctl+0x154>
   3e830:	2c00      	cmp	r4, #0
   3e832:	f000 86f6 	beq.w	3f622 <dwt_ioctl+0x1ef6>
   3e836:	2202      	movs	r2, #2
   3e838:	2144      	movs	r1, #68	; 0x44
   3e83a:	f7fc feae 	bl	3b59a <dwt_read16bitoffsetreg>
   3e83e:	f3c0 2000 	ubfx	r0, r0, #8, #1
   3e842:	7020      	strb	r0, [r4, #0]
   3e844:	2500      	movs	r5, #0
   3e846:	f7ff b81b 	b.w	3d880 <dwt_ioctl+0x154>
   3e84a:	2c00      	cmp	r4, #0
   3e84c:	f000 86ec 	beq.w	3f628 <dwt_ioctl+0x1efc>
   3e850:	2200      	movs	r2, #0
   3e852:	2144      	movs	r1, #68	; 0x44
   3e854:	f7fc feb3 	bl	3b5be <dwt_read8bitoffsetreg>
   3e858:	f000 0001 	and.w	r0, r0, #1
   3e85c:	7020      	strb	r0, [r4, #0]
   3e85e:	2500      	movs	r5, #0
   3e860:	f7ff b80e 	b.w	3d880 <dwt_ioctl+0x154>
   3e864:	2c00      	cmp	r4, #0
   3e866:	f000 86e2 	beq.w	3f62e <dwt_ioctl+0x1f02>
   3e86a:	8862      	ldrh	r2, [r4, #2]
   3e86c:	8821      	ldrh	r1, [r4, #0]
   3e86e:	f7fe f9d1 	bl	3cc14 <ull_configureframefilter>
   3e872:	2500      	movs	r5, #0
   3e874:	f7ff b804 	b.w	3d880 <dwt_ioctl+0x154>
   3e878:	9400      	str	r4, [sp, #0]
   3e87a:	2308      	movs	r3, #8
   3e87c:	2200      	movs	r2, #0
   3e87e:	2104      	movs	r1, #4
   3e880:	f7fd fa82 	bl	3bd88 <dwt_writetodevice>
   3e884:	2500      	movs	r5, #0
   3e886:	f7fe bffb 	b.w	3d880 <dwt_ioctl+0x154>
   3e88a:	9400      	str	r4, [sp, #0]
   3e88c:	2308      	movs	r3, #8
   3e88e:	2200      	movs	r2, #0
   3e890:	2104      	movs	r1, #4
   3e892:	f7fc fe62 	bl	3b55a <dwt_readfromdevice>
   3e896:	2500      	movs	r5, #0
   3e898:	f7fe bff2 	b.w	3d880 <dwt_ioctl+0x154>
   3e89c:	2c00      	cmp	r4, #0
   3e89e:	f000 86c9 	beq.w	3f634 <dwt_ioctl+0x1f08>
   3e8a2:	8823      	ldrh	r3, [r4, #0]
   3e8a4:	2202      	movs	r2, #2
   3e8a6:	210c      	movs	r1, #12
   3e8a8:	f7fd fa79 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e8ac:	2500      	movs	r5, #0
   3e8ae:	f7fe bfe7 	b.w	3d880 <dwt_ioctl+0x154>
   3e8b2:	2c00      	cmp	r4, #0
   3e8b4:	f000 86c1 	beq.w	3f63a <dwt_ioctl+0x1f0e>
   3e8b8:	8823      	ldrh	r3, [r4, #0]
   3e8ba:	2200      	movs	r2, #0
   3e8bc:	210c      	movs	r1, #12
   3e8be:	f7fd fa6e 	bl	3bd9e <dwt_write16bitoffsetreg>
   3e8c2:	2500      	movs	r5, #0
   3e8c4:	f7fe bfdc 	b.w	3d880 <dwt_ioctl+0x154>
   3e8c8:	4621      	mov	r1, r4
   3e8ca:	f7fd fa3b 	bl	3bd44 <ull_readrxtimestamp>
   3e8ce:	2500      	movs	r5, #0
   3e8d0:	f7fe bfd6 	b.w	3d880 <dwt_ioctl+0x154>
   3e8d4:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3e8d6:	7b9b      	ldrb	r3, [r3, #14]
   3e8d8:	2b01      	cmp	r3, #1
   3e8da:	d00b      	beq.n	3e8f4 <dwt_ioctl+0x11c8>
   3e8dc:	2b03      	cmp	r3, #3
   3e8de:	d112      	bne.n	3e906 <dwt_ioctl+0x11da>
   3e8e0:	9400      	str	r4, [sp, #0]
   3e8e2:	2305      	movs	r3, #5
   3e8e4:	2220      	movs	r2, #32
   3e8e6:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3e8ea:	f7fc fe36 	bl	3b55a <dwt_readfromdevice>
   3e8ee:	2500      	movs	r5, #0
   3e8f0:	f7fe bfc6 	b.w	3d880 <dwt_ioctl+0x154>
   3e8f4:	9400      	str	r4, [sp, #0]
   3e8f6:	2305      	movs	r3, #5
   3e8f8:	2200      	movs	r2, #0
   3e8fa:	4932      	ldr	r1, [pc, #200]	; (3e9c4 <dwt_ioctl+0x1298>)
   3e8fc:	f7fc fe2d 	bl	3b55a <dwt_readfromdevice>
   3e900:	2500      	movs	r5, #0
   3e902:	f7fe bfbd 	b.w	3d880 <dwt_ioctl+0x154>
   3e906:	9400      	str	r4, [sp, #0]
   3e908:	2305      	movs	r3, #5
   3e90a:	2200      	movs	r2, #0
   3e90c:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   3e910:	f7fc fe23 	bl	3b55a <dwt_readfromdevice>
   3e914:	2500      	movs	r5, #0
   3e916:	f7fe bfb3 	b.w	3d880 <dwt_ioctl+0x154>
   3e91a:	2500      	movs	r5, #0
   3e91c:	f804 5b01 	strb.w	r5, [r4], #1
   3e920:	9400      	str	r4, [sp, #0]
   3e922:	2304      	movs	r3, #4
   3e924:	462a      	mov	r2, r5
   3e926:	216c      	movs	r1, #108	; 0x6c
   3e928:	f7fc fe17 	bl	3b55a <dwt_readfromdevice>
   3e92c:	f7fe bfa8 	b.w	3d880 <dwt_ioctl+0x154>
   3e930:	2c00      	cmp	r4, #0
   3e932:	f000 8685 	beq.w	3f640 <dwt_ioctl+0x1f14>
   3e936:	2201      	movs	r2, #1
   3e938:	2160      	movs	r1, #96	; 0x60
   3e93a:	f7fc fe18 	bl	3b56e <dwt_read32bitoffsetreg>
   3e93e:	6020      	str	r0, [r4, #0]
   3e940:	2500      	movs	r5, #0
   3e942:	f7fe bf9d 	b.w	3d880 <dwt_ioctl+0x154>
   3e946:	2c00      	cmp	r4, #0
   3e948:	f000 867d 	beq.w	3f646 <dwt_ioctl+0x1f1a>
   3e94c:	2200      	movs	r2, #0
   3e94e:	2160      	movs	r1, #96	; 0x60
   3e950:	f7fc fe0d 	bl	3b56e <dwt_read32bitoffsetreg>
   3e954:	6020      	str	r0, [r4, #0]
   3e956:	2500      	movs	r5, #0
   3e958:	f7fe bf92 	b.w	3d880 <dwt_ioctl+0x154>
   3e95c:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3e95e:	7b9b      	ldrb	r3, [r3, #14]
   3e960:	2b01      	cmp	r3, #1
   3e962:	d00b      	beq.n	3e97c <dwt_ioctl+0x1250>
   3e964:	2b03      	cmp	r3, #3
   3e966:	d131      	bne.n	3e9cc <dwt_ioctl+0x12a0>
   3e968:	9400      	str	r4, [sp, #0]
   3e96a:	2305      	movs	r3, #5
   3e96c:	2228      	movs	r2, #40	; 0x28
   3e96e:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3e972:	f7fc fdf2 	bl	3b55a <dwt_readfromdevice>
   3e976:	2500      	movs	r5, #0
   3e978:	f7fe bf82 	b.w	3d880 <dwt_ioctl+0x154>
   3e97c:	9400      	str	r4, [sp, #0]
   3e97e:	2305      	movs	r3, #5
   3e980:	2200      	movs	r2, #0
   3e982:	4911      	ldr	r1, [pc, #68]	; (3e9c8 <dwt_ioctl+0x129c>)
   3e984:	f7fc fde9 	bl	3b55a <dwt_readfromdevice>
   3e988:	2500      	movs	r5, #0
   3e98a:	f7fe bf79 	b.w	3d880 <dwt_ioctl+0x154>
   3e98e:	bf00      	nop
   3e990:	000f0004 	.word	0x000f0004
   3e994:	000f0008 	.word	0x000f0008
   3e998:	000f000c 	.word	0x000f000c
   3e99c:	000f0010 	.word	0x000f0010
   3e9a0:	000f0014 	.word	0x000f0014
   3e9a4:	000f0018 	.word	0x000f0018
   3e9a8:	000f001c 	.word	0x000f001c
   3e9ac:	000f0020 	.word	0x000f0020
   3e9b0:	00060004 	.word	0x00060004
   3e9b4:	0011001c 	.word	0x0011001c
   3e9b8:	00180034 	.word	0x00180034
   3e9bc:	0018002c 	.word	0x0018002c
   3e9c0:	000c0014 	.word	0x000c0014
   3e9c4:	00180020 	.word	0x00180020
   3e9c8:	00180028 	.word	0x00180028
   3e9cc:	9400      	str	r4, [sp, #0]
   3e9ce:	2305      	movs	r3, #5
   3e9d0:	2200      	movs	r2, #0
   3e9d2:	49ce      	ldr	r1, [pc, #824]	; (3ed0c <dwt_ioctl+0x15e0>)
   3e9d4:	f7fc fdc1 	bl	3b55a <dwt_readfromdevice>
   3e9d8:	2500      	movs	r5, #0
   3e9da:	f7fe bf51 	b.w	3d880 <dwt_ioctl+0x154>
   3e9de:	2c00      	cmp	r4, #0
   3e9e0:	f000 8634 	beq.w	3f64c <dwt_ioctl+0x1f20>
   3e9e4:	2200      	movs	r2, #0
   3e9e6:	211c      	movs	r1, #28
   3e9e8:	f7fc fdc1 	bl	3b56e <dwt_read32bitoffsetreg>
   3e9ec:	6020      	str	r0, [r4, #0]
   3e9ee:	2500      	movs	r5, #0
   3e9f0:	f7fe bf46 	b.w	3d880 <dwt_ioctl+0x154>
   3e9f4:	2c00      	cmp	r4, #0
   3e9f6:	f000 862c 	beq.w	3f652 <dwt_ioctl+0x1f26>
   3e9fa:	8825      	ldrh	r5, [r4, #0]
   3e9fc:	6867      	ldr	r7, [r4, #4]
   3e9fe:	7a23      	ldrb	r3, [r4, #8]
   3ea00:	2b00      	cmp	r3, #0
   3ea02:	f000 8629 	beq.w	3f658 <dwt_ioctl+0x1f2c>
   3ea06:	463c      	mov	r4, r7
   3ea08:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   3ea0c:	4629      	mov	r1, r5
   3ea0e:	4630      	mov	r0, r6
   3ea10:	f7fd fa00 	bl	3be14 <_dwt_otpread>
   3ea14:	f844 0b04 	str.w	r0, [r4], #4
   3ea18:	3501      	adds	r5, #1
   3ea1a:	b2ad      	uxth	r5, r5
   3ea1c:	42bc      	cmp	r4, r7
   3ea1e:	d1f5      	bne.n	3ea0c <dwt_ioctl+0x12e0>
   3ea20:	2500      	movs	r5, #0
   3ea22:	f7fe bf2d 	b.w	3d880 <dwt_ioctl+0x154>
   3ea26:	2c00      	cmp	r4, #0
   3ea28:	f000 8619 	beq.w	3f65e <dwt_ioctl+0x1f32>
   3ea2c:	7823      	ldrb	r3, [r4, #0]
   3ea2e:	2201      	movs	r2, #1
   3ea30:	2124      	movs	r1, #36	; 0x24
   3ea32:	f7fd fb9f 	bl	3c174 <dwt_write8bitoffsetreg>
   3ea36:	2500      	movs	r5, #0
   3ea38:	f7fe bf22 	b.w	3d880 <dwt_ioctl+0x154>
   3ea3c:	f7fe f90e 	bl	3cc5c <ull_run_pgfcal>
   3ea40:	4605      	mov	r5, r0
   3ea42:	f7fe bf1d 	b.w	3d880 <dwt_ioctl+0x154>
   3ea46:	4611      	mov	r1, r2
   3ea48:	f7fe fa4e 	bl	3cee8 <ull_pgf_cal>
   3ea4c:	4605      	mov	r5, r0
   3ea4e:	f7fe bf17 	b.w	3d880 <dwt_ioctl+0x154>
   3ea52:	2c00      	cmp	r4, #0
   3ea54:	f000 8606 	beq.w	3f664 <dwt_ioctl+0x1f38>
   3ea58:	78a5      	ldrb	r5, [r4, #2]
   3ea5a:	2101      	movs	r1, #1
   3ea5c:	f7fd f9b0 	bl	3bdc0 <ull_force_clocks>
   3ea60:	2100      	movs	r1, #0
   3ea62:	4630      	mov	r0, r6
   3ea64:	f7fd fe6e 	bl	3c744 <ull_enable_rf_tx>
   3ea68:	4630      	mov	r0, r6
   3ea6a:	f7fd fe9f 	bl	3c7ac <ull_enable_rftx_blocks>
   3ea6e:	f005 033f 	and.w	r3, r5, #63	; 0x3f
   3ea72:	2200      	movs	r2, #0
   3ea74:	49a6      	ldr	r1, [pc, #664]	; (3ed10 <dwt_ioctl+0x15e4>)
   3ea76:	4630      	mov	r0, r6
   3ea78:	f7fd fb7c 	bl	3c174 <dwt_write8bitoffsetreg>
   3ea7c:	2301      	movs	r3, #1
   3ea7e:	9300      	str	r3, [sp, #0]
   3ea80:	23ff      	movs	r3, #255	; 0xff
   3ea82:	2200      	movs	r2, #0
   3ea84:	49a3      	ldr	r1, [pc, #652]	; (3ed14 <dwt_ioctl+0x15e8>)
   3ea86:	4630      	mov	r0, r6
   3ea88:	f7fd ffaa 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ea8c:	4fa1      	ldr	r7, [pc, #644]	; (3ed14 <dwt_ioctl+0x15e8>)
   3ea8e:	2500      	movs	r5, #0
   3ea90:	462a      	mov	r2, r5
   3ea92:	4639      	mov	r1, r7
   3ea94:	4630      	mov	r0, r6
   3ea96:	f7fc fd92 	bl	3b5be <dwt_read8bitoffsetreg>
   3ea9a:	f010 0f01 	tst.w	r0, #1
   3ea9e:	d1f7      	bne.n	3ea90 <dwt_ioctl+0x1364>
   3eaa0:	2200      	movs	r2, #0
   3eaa2:	499d      	ldr	r1, [pc, #628]	; (3ed18 <dwt_ioctl+0x15ec>)
   3eaa4:	4630      	mov	r0, r6
   3eaa6:	f7fc fd78 	bl	3b59a <dwt_read16bitoffsetreg>
   3eaaa:	4605      	mov	r5, r0
   3eaac:	4630      	mov	r0, r6
   3eaae:	f7fd fb03 	bl	3c0b8 <ull_disable_rftx_blocks>
   3eab2:	2100      	movs	r1, #0
   3eab4:	4630      	mov	r0, r6
   3eab6:	f7fd fb09 	bl	3c0cc <ull_disable_rf_tx>
   3eaba:	2105      	movs	r1, #5
   3eabc:	4630      	mov	r0, r6
   3eabe:	f7fd f97f 	bl	3bdc0 <ull_force_clocks>
   3eac2:	f3c5 050b 	ubfx	r5, r5, #0, #12
   3eac6:	8025      	strh	r5, [r4, #0]
   3eac8:	2500      	movs	r5, #0
   3eaca:	f7fe bed9 	b.w	3d880 <dwt_ioctl+0x154>
   3eace:	2102      	movs	r1, #2
   3ead0:	f7fe f844 	bl	3cb5c <ull_setdwstate>
   3ead4:	2101      	movs	r1, #1
   3ead6:	4630      	mov	r0, r6
   3ead8:	f7fe f840 	bl	3cb5c <ull_setdwstate>
   3eadc:	2432      	movs	r4, #50	; 0x32
   3eade:	f04f 0814 	mov.w	r8, #20
   3eae2:	2700      	movs	r7, #0
   3eae4:	2544      	movs	r5, #68	; 0x44
   3eae6:	4640      	mov	r0, r8
   3eae8:	f7ef fe81 	bl	2e7ee <deca_usleep>
   3eaec:	463a      	mov	r2, r7
   3eaee:	4629      	mov	r1, r5
   3eaf0:	4630      	mov	r0, r6
   3eaf2:	f7fc fd64 	bl	3b5be <dwt_read8bitoffsetreg>
   3eaf6:	f010 0f02 	tst.w	r0, #2
   3eafa:	d105      	bne.n	3eb08 <dwt_ioctl+0x13dc>
   3eafc:	1e63      	subs	r3, r4, #1
   3eafe:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   3eb02:	d1f0      	bne.n	3eae6 <dwt_ioctl+0x13ba>
   3eb04:	2501      	movs	r5, #1
   3eb06:	e000      	b.n	3eb0a <dwt_ioctl+0x13de>
   3eb08:	2500      	movs	r5, #0
   3eb0a:	426d      	negs	r5, r5
   3eb0c:	f7fe beb8 	b.w	3d880 <dwt_ioctl+0x154>
   3eb10:	2c00      	cmp	r4, #0
   3eb12:	f000 85aa 	beq.w	3f66a <dwt_ioctl+0x1f3e>
   3eb16:	7823      	ldrb	r3, [r4, #0]
   3eb18:	031b      	lsls	r3, r3, #12
   3eb1a:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
   3eb1e:	7862      	ldrb	r2, [r4, #1]
   3eb20:	2a01      	cmp	r2, #1
   3eb22:	bf08      	it	eq
   3eb24:	f443 7380 	orreq.w	r3, r3, #256	; 0x100
   3eb28:	9300      	str	r3, [sp, #0]
   3eb2a:	f46f 43e2 	mvn.w	r3, #28928	; 0x7100
   3eb2e:	2200      	movs	r2, #0
   3eb30:	497a      	ldr	r1, [pc, #488]	; (3ed1c <dwt_ioctl+0x15f0>)
   3eb32:	f7fd fde3 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3eb36:	2500      	movs	r5, #0
   3eb38:	f7fe bea2 	b.w	3d880 <dwt_ioctl+0x154>
   3eb3c:	2c00      	cmp	r4, #0
   3eb3e:	f000 8597 	beq.w	3f670 <dwt_ioctl+0x1f44>
   3eb42:	6862      	ldr	r2, [r4, #4]
   3eb44:	6821      	ldr	r1, [r4, #0]
   3eb46:	f7fd fefb 	bl	3c940 <ull_setgpiomode>
   3eb4a:	2500      	movs	r5, #0
   3eb4c:	f7fe be98 	b.w	3d880 <dwt_ioctl+0x154>
   3eb50:	2c00      	cmp	r4, #0
   3eb52:	f000 8590 	beq.w	3f676 <dwt_ioctl+0x1f4a>
   3eb56:	8823      	ldrh	r3, [r4, #0]
   3eb58:	2200      	movs	r2, #0
   3eb5a:	4971      	ldr	r1, [pc, #452]	; (3ed20 <dwt_ioctl+0x15f4>)
   3eb5c:	f7fd f91f 	bl	3bd9e <dwt_write16bitoffsetreg>
   3eb60:	2500      	movs	r5, #0
   3eb62:	f7fe be8d 	b.w	3d880 <dwt_ioctl+0x154>
   3eb66:	2c00      	cmp	r4, #0
   3eb68:	f000 8588 	beq.w	3f67c <dwt_ioctl+0x1f50>
   3eb6c:	6862      	ldr	r2, [r4, #4]
   3eb6e:	8821      	ldrh	r1, [r4, #0]
   3eb70:	f7fe f9ea 	bl	3cf48 <ull_setgpiovalue>
   3eb74:	2500      	movs	r5, #0
   3eb76:	f7fe be83 	b.w	3d880 <dwt_ioctl+0x154>
   3eb7a:	2c00      	cmp	r4, #0
   3eb7c:	f000 8581 	beq.w	3f682 <dwt_ioctl+0x1f56>
   3eb80:	7865      	ldrb	r5, [r4, #1]
   3eb82:	7823      	ldrb	r3, [r4, #0]
   3eb84:	b18b      	cbz	r3, 3ebaa <dwt_ioctl+0x147e>
   3eb86:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3eb88:	2200      	movs	r2, #0
   3eb8a:	739a      	strb	r2, [r3, #14]
   3eb8c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3eb90:	2208      	movs	r2, #8
   3eb92:	b1e5      	cbz	r5, 3ebce <dwt_ioctl+0x14a2>
   3eb94:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   3eb98:	9200      	str	r2, [sp, #0]
   3eb9a:	2200      	movs	r2, #0
   3eb9c:	2110      	movs	r1, #16
   3eb9e:	4630      	mov	r0, r6
   3eba0:	f7fd fdac 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3eba4:	2500      	movs	r5, #0
   3eba6:	f7fe be6b 	b.w	3d880 <dwt_ioctl+0x154>
   3ebaa:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3ebac:	2201      	movs	r2, #1
   3ebae:	739a      	strb	r2, [r3, #14]
   3ebb0:	2318      	movs	r3, #24
   3ebb2:	2200      	movs	r2, #0
   3ebb4:	495b      	ldr	r1, [pc, #364]	; (3ed24 <dwt_ioctl+0x15f8>)
   3ebb6:	f7fd f94f 	bl	3be58 <dwt_write32bitoffsetreg>
   3ebba:	23e8      	movs	r3, #232	; 0xe8
   3ebbc:	2200      	movs	r2, #0
   3ebbe:	495a      	ldr	r1, [pc, #360]	; (3ed28 <dwt_ioctl+0x15fc>)
   3ebc0:	4630      	mov	r0, r6
   3ebc2:	f7fd f949 	bl	3be58 <dwt_write32bitoffsetreg>
   3ebc6:	f06f 0308 	mvn.w	r3, #8
   3ebca:	2200      	movs	r2, #0
   3ebcc:	e7e1      	b.n	3eb92 <dwt_ioctl+0x1466>
   3ebce:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   3ebd2:	e7e1      	b.n	3eb98 <dwt_ioctl+0x146c>
   3ebd4:	2c00      	cmp	r4, #0
   3ebd6:	f000 8557 	beq.w	3f688 <dwt_ioctl+0x1f5c>
   3ebda:	6823      	ldr	r3, [r4, #0]
   3ebdc:	2200      	movs	r2, #0
   3ebde:	2130      	movs	r1, #48	; 0x30
   3ebe0:	f7fd f93a 	bl	3be58 <dwt_write32bitoffsetreg>
   3ebe4:	2500      	movs	r5, #0
   3ebe6:	f7fe be4b 	b.w	3d880 <dwt_ioctl+0x154>
   3ebea:	2c00      	cmp	r4, #0
   3ebec:	f000 854f 	beq.w	3f68e <dwt_ioctl+0x1f62>
   3ebf0:	2200      	movs	r2, #0
   3ebf2:	4629      	mov	r1, r5
   3ebf4:	f7fc fcbb 	bl	3b56e <dwt_read32bitoffsetreg>
   3ebf8:	6020      	str	r0, [r4, #0]
   3ebfa:	2500      	movs	r5, #0
   3ebfc:	f7fe be40 	b.w	3d880 <dwt_ioctl+0x154>
   3ec00:	4623      	mov	r3, r4
   3ec02:	2200      	movs	r2, #0
   3ec04:	4629      	mov	r1, r5
   3ec06:	f7fd f927 	bl	3be58 <dwt_write32bitoffsetreg>
   3ec0a:	2500      	movs	r5, #0
   3ec0c:	f7fe be38 	b.w	3d880 <dwt_ioctl+0x154>
   3ec10:	2c00      	cmp	r4, #0
   3ec12:	f000 853f 	beq.w	3f694 <dwt_ioctl+0x1f68>
   3ec16:	2203      	movs	r2, #3
   3ec18:	4944      	ldr	r1, [pc, #272]	; (3ed2c <dwt_ioctl+0x1600>)
   3ec1a:	f7fc fcd0 	bl	3b5be <dwt_read8bitoffsetreg>
   3ec1e:	f3c0 1002 	ubfx	r0, r0, #4, #3
   3ec22:	7020      	strb	r0, [r4, #0]
   3ec24:	2500      	movs	r5, #0
   3ec26:	f7fe be2b 	b.w	3d880 <dwt_ioctl+0x154>
   3ec2a:	2c00      	cmp	r4, #0
   3ec2c:	f000 8535 	beq.w	3f69a <dwt_ioctl+0x1f6e>
   3ec30:	6823      	ldr	r3, [r4, #0]
   3ec32:	2200      	movs	r2, #0
   3ec34:	2144      	movs	r1, #68	; 0x44
   3ec36:	f7fd f90f 	bl	3be58 <dwt_write32bitoffsetreg>
   3ec3a:	2500      	movs	r5, #0
   3ec3c:	f7fe be20 	b.w	3d880 <dwt_ioctl+0x154>
   3ec40:	2c00      	cmp	r4, #0
   3ec42:	f000 852d 	beq.w	3f6a0 <dwt_ioctl+0x1f74>
   3ec46:	8823      	ldrh	r3, [r4, #0]
   3ec48:	2200      	movs	r2, #0
   3ec4a:	2148      	movs	r1, #72	; 0x48
   3ec4c:	f7fd f8a7 	bl	3bd9e <dwt_write16bitoffsetreg>
   3ec50:	2500      	movs	r5, #0
   3ec52:	f7fe be15 	b.w	3d880 <dwt_ioctl+0x154>
   3ec56:	2c00      	cmp	r4, #0
   3ec58:	f000 8525 	beq.w	3f6a6 <dwt_ioctl+0x1f7a>
   3ec5c:	2200      	movs	r2, #0
   3ec5e:	2144      	movs	r1, #68	; 0x44
   3ec60:	f7fc fc85 	bl	3b56e <dwt_read32bitoffsetreg>
   3ec64:	6020      	str	r0, [r4, #0]
   3ec66:	2500      	movs	r5, #0
   3ec68:	f7fe be0a 	b.w	3d880 <dwt_ioctl+0x154>
   3ec6c:	2c00      	cmp	r4, #0
   3ec6e:	f000 851d 	beq.w	3f6ac <dwt_ioctl+0x1f80>
   3ec72:	2200      	movs	r2, #0
   3ec74:	2148      	movs	r1, #72	; 0x48
   3ec76:	f7fc fc90 	bl	3b59a <dwt_read16bitoffsetreg>
   3ec7a:	6020      	str	r0, [r4, #0]
   3ec7c:	2500      	movs	r5, #0
   3ec7e:	f7fe bdff 	b.w	3d880 <dwt_ioctl+0x154>
   3ec82:	2c00      	cmp	r4, #0
   3ec84:	f000 8515 	beq.w	3f6b2 <dwt_ioctl+0x1f86>
   3ec88:	7823      	ldrb	r3, [r4, #0]
   3ec8a:	2200      	movs	r2, #0
   3ec8c:	4928      	ldr	r1, [pc, #160]	; (3ed30 <dwt_ioctl+0x1604>)
   3ec8e:	f7fd fa71 	bl	3c174 <dwt_write8bitoffsetreg>
   3ec92:	2500      	movs	r5, #0
   3ec94:	f7fe bdf4 	b.w	3d880 <dwt_ioctl+0x154>
   3ec98:	2c00      	cmp	r4, #0
   3ec9a:	f000 850d 	beq.w	3f6b8 <dwt_ioctl+0x1f8c>
   3ec9e:	2200      	movs	r2, #0
   3eca0:	2144      	movs	r1, #68	; 0x44
   3eca2:	f7fc fc8c 	bl	3b5be <dwt_read8bitoffsetreg>
   3eca6:	7020      	strb	r0, [r4, #0]
   3eca8:	2500      	movs	r5, #0
   3ecaa:	f7fe bde9 	b.w	3d880 <dwt_ioctl+0x154>
   3ecae:	2c00      	cmp	r4, #0
   3ecb0:	f000 8505 	beq.w	3f6be <dwt_ioctl+0x1f92>
   3ecb4:	f7fd fa6a 	bl	3c18c <ull_getframelength>
   3ecb8:	6020      	str	r0, [r4, #0]
   3ecba:	2500      	movs	r5, #0
   3ecbc:	f7fe bde0 	b.w	3d880 <dwt_ioctl+0x154>
   3ecc0:	2c00      	cmp	r4, #0
   3ecc2:	f000 84ff 	beq.w	3f6c4 <dwt_ioctl+0x1f98>
   3ecc6:	2200      	movs	r2, #0
   3ecc8:	491a      	ldr	r1, [pc, #104]	; (3ed34 <dwt_ioctl+0x1608>)
   3ecca:	f7fc fc66 	bl	3b59a <dwt_read16bitoffsetreg>
   3ecce:	8020      	strh	r0, [r4, #0]
   3ecd0:	2500      	movs	r5, #0
   3ecd2:	f7fe bdd5 	b.w	3d880 <dwt_ioctl+0x154>
   3ecd6:	2c00      	cmp	r4, #0
   3ecd8:	f000 84f7 	beq.w	3f6ca <dwt_ioctl+0x1f9e>
   3ecdc:	2200      	movs	r2, #0
   3ecde:	4916      	ldr	r1, [pc, #88]	; (3ed38 <dwt_ioctl+0x160c>)
   3ece0:	f7fc fc45 	bl	3b56e <dwt_read32bitoffsetreg>
   3ece4:	6020      	str	r0, [r4, #0]
   3ece6:	2500      	movs	r5, #0
   3ece8:	f7fe bdca 	b.w	3d880 <dwt_ioctl+0x154>
   3ecec:	2c00      	cmp	r4, #0
   3ecee:	f000 84ef 	beq.w	3f6d0 <dwt_ioctl+0x1fa4>
   3ecf2:	8823      	ldrh	r3, [r4, #0]
   3ecf4:	f3c3 030d 	ubfx	r3, r3, #0, #14
   3ecf8:	9300      	str	r3, [sp, #0]
   3ecfa:	f44f 4340 	mov.w	r3, #49152	; 0xc000
   3ecfe:	2200      	movs	r2, #0
   3ed00:	490d      	ldr	r1, [pc, #52]	; (3ed38 <dwt_ioctl+0x160c>)
   3ed02:	f7fe f889 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3ed06:	2500      	movs	r5, #0
   3ed08:	f7fe bdba 	b.w	3d880 <dwt_ioctl+0x154>
   3ed0c:	000c0008 	.word	0x000c0008
   3ed10:	0007001c 	.word	0x0007001c
   3ed14:	00080010 	.word	0x00080010
   3ed18:	00080014 	.word	0x00080014
   3ed1c:	00070014 	.word	0x00070014
   3ed20:	00050008 	.word	0x00050008
   3ed24:	001f000c 	.word	0x001f000c
   3ed28:	001f0010 	.word	0x001f0010
   3ed2c:	00030060 	.word	0x00030060
   3ed30:	00010018 	.word	0x00010018
   3ed34:	0005002c 	.word	0x0005002c
   3ed38:	000e001c 	.word	0x000e001c
   3ed3c:	2c00      	cmp	r4, #0
   3ed3e:	f000 84ca 	beq.w	3f6d6 <dwt_ioctl+0x1faa>
   3ed42:	88a7      	ldrh	r7, [r4, #4]
   3ed44:	f8d4 b008 	ldr.w	fp, [r4, #8]
   3ed48:	7b23      	ldrb	r3, [r4, #12]
   3ed4a:	9306      	str	r3, [sp, #24]
   3ed4c:	6922      	ldr	r2, [r4, #16]
   3ed4e:	9204      	str	r2, [sp, #16]
   3ed50:	6962      	ldr	r2, [r4, #20]
   3ed52:	9205      	str	r2, [sp, #20]
   3ed54:	f00b 0203 	and.w	r2, fp, #3
   3ed58:	f3cb 0085 	ubfx	r0, fp, #2, #6
   3ed5c:	2b05      	cmp	r3, #5
   3ed5e:	d145      	bne.n	3edec <dwt_ioctl+0x16c0>
   3ed60:	f5b7 7fb1 	cmp.w	r7, #354	; 0x162
   3ed64:	bf28      	it	cs
   3ed66:	f44f 77b1 	movcs.w	r7, #354	; 0x162
   3ed6a:	f8df 9338 	ldr.w	r9, [pc, #824]	; 3f0a4 <dwt_ioctl+0x1978>
   3ed6e:	2f04      	cmp	r7, #4
   3ed70:	d805      	bhi.n	3ed7e <dwt_ioctl+0x1652>
   3ed72:	eb09 0300 	add.w	r3, r9, r0
   3ed76:	785b      	ldrb	r3, [r3, #1]
   3ed78:	3b05      	subs	r3, #5
   3ed7a:	429f      	cmp	r7, r3
   3ed7c:	db3e      	blt.n	3edfc <dwt_ioctl+0x16d0>
   3ed7e:	2a01      	cmp	r2, #1
   3ed80:	d87c      	bhi.n	3ee7c <dwt_ioctl+0x1750>
   3ed82:	4bc4      	ldr	r3, [pc, #784]	; (3f094 <dwt_ioctl+0x1968>)
   3ed84:	5c99      	ldrb	r1, [r3, r2]
   3ed86:	463e      	mov	r6, r7
   3ed88:	42b9      	cmp	r1, r7
   3ed8a:	da79      	bge.n	3ee80 <dwt_ioctl+0x1754>
   3ed8c:	1c55      	adds	r5, r2, #1
   3ed8e:	fa53 f585 	uxtab	r5, r3, r5
   3ed92:	2300      	movs	r3, #0
   3ed94:	440b      	add	r3, r1
   3ed96:	b29b      	uxth	r3, r3
   3ed98:	3201      	adds	r2, #1
   3ed9a:	b2d2      	uxtb	r2, r2
   3ed9c:	2a02      	cmp	r2, #2
   3ed9e:	d005      	beq.n	3edac <dwt_ioctl+0x1680>
   3eda0:	f815 1b01 	ldrb.w	r1, [r5], #1
   3eda4:	eba6 0c03 	sub.w	ip, r6, r3
   3eda8:	4561      	cmp	r1, ip
   3edaa:	dbf3      	blt.n	3ed94 <dwt_ioctl+0x1668>
   3edac:	429f      	cmp	r7, r3
   3edae:	bf08      	it	eq
   3edb0:	9003      	streq	r0, [sp, #12]
   3edb2:	d069      	beq.n	3ee88 <dwt_ioctl+0x175c>
   3edb4:	f107 0805 	add.w	r8, r7, #5
   3edb8:	fa1f f888 	uxth.w	r8, r8
   3edbc:	2580      	movs	r5, #128	; 0x80
   3edbe:	2100      	movs	r1, #0
   3edc0:	9107      	str	r1, [sp, #28]
   3edc2:	9103      	str	r1, [sp, #12]
   3edc4:	9108      	str	r1, [sp, #32]
   3edc6:	460e      	mov	r6, r1
   3edc8:	2105      	movs	r1, #5
   3edca:	46be      	mov	lr, r7
   3edcc:	428f      	cmp	r7, r1
   3edce:	bf38      	it	cc
   3edd0:	468e      	movcc	lr, r1
   3edd2:	f1ae 0e05 	sub.w	lr, lr, #5
   3edd6:	fa1f fe8e 	uxth.w	lr, lr
   3edda:	f8df a2b8 	ldr.w	sl, [pc, #696]	; 3f094 <dwt_ioctl+0x1968>
   3edde:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
   3ede2:	468b      	mov	fp, r1
   3ede4:	46bc      	mov	ip, r7
   3ede6:	4637      	mov	r7, r6
   3ede8:	f000 bcec 	b.w	3f7c4 <dwt_ioctl+0x2098>
   3edec:	f240 1331 	movw	r3, #305	; 0x131
   3edf0:	429f      	cmp	r7, r3
   3edf2:	bf28      	it	cs
   3edf4:	461f      	movcs	r7, r3
   3edf6:	f8df 92b0 	ldr.w	r9, [pc, #688]	; 3f0a8 <dwt_ioctl+0x197c>
   3edfa:	e7b8      	b.n	3ed6e <dwt_ioctl+0x1642>
   3edfc:	2300      	movs	r3, #0
   3edfe:	9a05      	ldr	r2, [sp, #20]
   3ee00:	8013      	strh	r3, [r2, #0]
   3ee02:	9a04      	ldr	r2, [sp, #16]
   3ee04:	f8c2 b000 	str.w	fp, [r2]
   3ee08:	e04d      	b.n	3eea6 <dwt_ioctl+0x177a>
   3ee0a:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   3ee0e:	2300      	movs	r3, #0
   3ee10:	9a05      	ldr	r2, [sp, #20]
   3ee12:	8013      	strh	r3, [r2, #0]
   3ee14:	9b04      	ldr	r3, [sp, #16]
   3ee16:	f8c3 b000 	str.w	fp, [r3]
   3ee1a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3ee1e:	e042      	b.n	3eea6 <dwt_ioctl+0x177a>
   3ee20:	fa1f fb81 	uxth.w	fp, r1
   3ee24:	9207      	str	r2, [sp, #28]
   3ee26:	9003      	str	r0, [sp, #12]
   3ee28:	9308      	str	r3, [sp, #32]
   3ee2a:	2701      	movs	r7, #1
   3ee2c:	f000 bcdb 	b.w	3f7e6 <dwt_ioctl+0x20ba>
   3ee30:	2f00      	cmp	r7, #0
   3ee32:	f040 849b 	bne.w	3f76c <dwt_ioctl+0x2040>
   3ee36:	4598      	cmp	r8, r3
   3ee38:	f200 84b0 	bhi.w	3f79c <dwt_ioctl+0x2070>
   3ee3c:	2e00      	cmp	r6, #0
   3ee3e:	d039      	beq.n	3eeb4 <dwt_ioctl+0x1788>
   3ee40:	283f      	cmp	r0, #63	; 0x3f
   3ee42:	f000 84d5 	beq.w	3f7f0 <dwt_ioctl+0x20c4>
   3ee46:	2700      	movs	r7, #0
   3ee48:	f819 1000 	ldrb.w	r1, [r9, r0]
   3ee4c:	1a5b      	subs	r3, r3, r1
   3ee4e:	b29b      	uxth	r3, r3
   3ee50:	1e46      	subs	r6, r0, #1
   3ee52:	f006 003f 	and.w	r0, r6, #63	; 0x3f
   3ee56:	f016 063f 	ands.w	r6, r6, #63	; 0x3f
   3ee5a:	bf18      	it	ne
   3ee5c:	2601      	movne	r6, #1
   3ee5e:	f000 bca9 	b.w	3f7b4 <dwt_ioctl+0x2088>
   3ee62:	9906      	ldr	r1, [sp, #24]
   3ee64:	2909      	cmp	r1, #9
   3ee66:	f040 84c9 	bne.w	3f7fc <dwt_ioctl+0x20d0>
   3ee6a:	213f      	movs	r1, #63	; 0x3f
   3ee6c:	9103      	str	r1, [sp, #12]
   3ee6e:	e00b      	b.n	3ee88 <dwt_ioctl+0x175c>
   3ee70:	b2b3      	uxth	r3, r6
   3ee72:	3201      	adds	r2, #1
   3ee74:	b2d2      	uxtb	r2, r2
   3ee76:	213f      	movs	r1, #63	; 0x3f
   3ee78:	9103      	str	r1, [sp, #12]
   3ee7a:	e005      	b.n	3ee88 <dwt_ioctl+0x175c>
   3ee7c:	2300      	movs	r3, #0
   3ee7e:	e795      	b.n	3edac <dwt_ioctl+0x1680>
   3ee80:	2300      	movs	r3, #0
   3ee82:	e793      	b.n	3edac <dwt_ioctl+0x1680>
   3ee84:	9003      	str	r0, [sp, #12]
   3ee86:	4663      	mov	r3, ip
   3ee88:	9905      	ldr	r1, [sp, #20]
   3ee8a:	800b      	strh	r3, [r1, #0]
   3ee8c:	9b03      	ldr	r3, [sp, #12]
   3ee8e:	ea42 0283 	orr.w	r2, r2, r3, lsl #2
   3ee92:	b2d2      	uxtb	r2, r2
   3ee94:	0413      	lsls	r3, r2, #16
   3ee96:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ee9a:	4313      	orrs	r3, r2
   3ee9c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3eea0:	9a04      	ldr	r2, [sp, #16]
   3eea2:	6013      	str	r3, [r2, #0]
   3eea4:	2300      	movs	r3, #0
   3eea6:	6023      	str	r3, [r4, #0]
   3eea8:	2500      	movs	r5, #0
   3eeaa:	f7fe bce9 	b.w	3d880 <dwt_ioctl+0x154>
   3eeae:	9a07      	ldr	r2, [sp, #28]
   3eeb0:	9b08      	ldr	r3, [sp, #32]
   3eeb2:	e7e9      	b.n	3ee88 <dwt_ioctl+0x175c>
   3eeb4:	9003      	str	r0, [sp, #12]
   3eeb6:	e7e7      	b.n	3ee88 <dwt_ioctl+0x175c>
   3eeb8:	9a07      	ldr	r2, [sp, #28]
   3eeba:	9b08      	ldr	r3, [sp, #32]
   3eebc:	e7e4      	b.n	3ee88 <dwt_ioctl+0x175c>
   3eebe:	213f      	movs	r1, #63	; 0x3f
   3eec0:	9103      	str	r1, [sp, #12]
   3eec2:	e7e1      	b.n	3ee88 <dwt_ioctl+0x175c>
   3eec4:	2c00      	cmp	r4, #0
   3eec6:	f000 8409 	beq.w	3f6dc <dwt_ioctl+0x1fb0>
   3eeca:	7827      	ldrb	r7, [r4, #0]
   3eecc:	7864      	ldrb	r4, [r4, #1]
   3eece:	f7ef fc6b 	bl	2e7a8 <decamutexon>
   3eed2:	4605      	mov	r5, r0
   3eed4:	2c02      	cmp	r4, #2
   3eed6:	d00e      	beq.n	3eef6 <dwt_ioctl+0x17ca>
   3eed8:	2c04      	cmp	r4, #4
   3eeda:	d00c      	beq.n	3eef6 <dwt_ioctl+0x17ca>
   3eedc:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
   3eee0:	2c01      	cmp	r4, #1
   3eee2:	d01a      	beq.n	3ef1a <dwt_ioctl+0x17ee>
   3eee4:	43fb      	mvns	r3, r7
   3eee6:	2200      	movs	r2, #0
   3eee8:	9200      	str	r2, [sp, #0]
   3eeea:	b2db      	uxtb	r3, r3
   3eeec:	496a      	ldr	r1, [pc, #424]	; (3f098 <dwt_ioctl+0x196c>)
   3eeee:	4630      	mov	r0, r6
   3eef0:	f7fd fd76 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3eef4:	e005      	b.n	3ef02 <dwt_ioctl+0x17d6>
   3eef6:	463b      	mov	r3, r7
   3eef8:	2200      	movs	r2, #0
   3eefa:	4967      	ldr	r1, [pc, #412]	; (3f098 <dwt_ioctl+0x196c>)
   3eefc:	4630      	mov	r0, r6
   3eefe:	f7fd f939 	bl	3c174 <dwt_write8bitoffsetreg>
   3ef02:	463b      	mov	r3, r7
   3ef04:	2200      	movs	r2, #0
   3ef06:	4965      	ldr	r1, [pc, #404]	; (3f09c <dwt_ioctl+0x1970>)
   3ef08:	4630      	mov	r0, r6
   3ef0a:	f7fc ffa5 	bl	3be58 <dwt_write32bitoffsetreg>
   3ef0e:	4628      	mov	r0, r5
   3ef10:	f7ef fc51 	bl	2e7b6 <decamutexoff>
   3ef14:	2500      	movs	r5, #0
   3ef16:	f7fe bcb3 	b.w	3d880 <dwt_ioctl+0x154>
   3ef1a:	9700      	str	r7, [sp, #0]
   3ef1c:	23ff      	movs	r3, #255	; 0xff
   3ef1e:	2200      	movs	r2, #0
   3ef20:	495d      	ldr	r1, [pc, #372]	; (3f098 <dwt_ioctl+0x196c>)
   3ef22:	4630      	mov	r0, r6
   3ef24:	f7fd fd5c 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3ef28:	e7eb      	b.n	3ef02 <dwt_ioctl+0x17d6>
   3ef2a:	2302      	movs	r3, #2
   3ef2c:	9301      	str	r3, [sp, #4]
   3ef2e:	2500      	movs	r5, #0
   3ef30:	9500      	str	r5, [sp, #0]
   3ef32:	462b      	mov	r3, r5
   3ef34:	462a      	mov	r2, r5
   3ef36:	211a      	movs	r1, #26
   3ef38:	f7fc fa91 	bl	3b45e <dwt_xfer3xxx>
   3ef3c:	f7fe bca0 	b.w	3d880 <dwt_ioctl+0x154>
   3ef40:	f7fe fbe0 	bl	3d704 <ull_softreset_fcmd>
   3ef44:	2500      	movs	r5, #0
   3ef46:	f7fe bc9b 	b.w	3d880 <dwt_ioctl+0x154>
   3ef4a:	f7fe fbc7 	bl	3d6dc <ull_softreset_no_sema_fcmd>
   3ef4e:	2500      	movs	r5, #0
   3ef50:	f7fe bc96 	b.w	3d880 <dwt_ioctl+0x154>
   3ef54:	2302      	movs	r3, #2
   3ef56:	9301      	str	r3, [sp, #4]
   3ef58:	2500      	movs	r5, #0
   3ef5a:	9500      	str	r5, [sp, #0]
   3ef5c:	462b      	mov	r3, r5
   3ef5e:	462a      	mov	r2, r5
   3ef60:	2114      	movs	r1, #20
   3ef62:	f7fc fa7c 	bl	3b45e <dwt_xfer3xxx>
   3ef66:	f7fe bc8b 	b.w	3d880 <dwt_ioctl+0x154>
   3ef6a:	2402      	movs	r4, #2
   3ef6c:	9401      	str	r4, [sp, #4]
   3ef6e:	2500      	movs	r5, #0
   3ef70:	9500      	str	r5, [sp, #0]
   3ef72:	462b      	mov	r3, r5
   3ef74:	462a      	mov	r2, r5
   3ef76:	2115      	movs	r1, #21
   3ef78:	f7fc fa71 	bl	3b45e <dwt_xfer3xxx>
   3ef7c:	9401      	str	r4, [sp, #4]
   3ef7e:	9500      	str	r5, [sp, #0]
   3ef80:	462b      	mov	r3, r5
   3ef82:	462a      	mov	r2, r5
   3ef84:	2115      	movs	r1, #21
   3ef86:	4630      	mov	r0, r6
   3ef88:	f7fc fa69 	bl	3b45e <dwt_xfer3xxx>
   3ef8c:	f7fe bc78 	b.w	3d880 <dwt_ioctl+0x154>
   3ef90:	2302      	movs	r3, #2
   3ef92:	9301      	str	r3, [sp, #4]
   3ef94:	2500      	movs	r5, #0
   3ef96:	9500      	str	r5, [sp, #0]
   3ef98:	462b      	mov	r3, r5
   3ef9a:	462a      	mov	r2, r5
   3ef9c:	2116      	movs	r1, #22
   3ef9e:	f7fc fa5e 	bl	3b45e <dwt_xfer3xxx>
   3efa2:	f7fe bc6d 	b.w	3d880 <dwt_ioctl+0x154>
   3efa6:	2c00      	cmp	r4, #0
   3efa8:	f000 839b 	beq.w	3f6e2 <dwt_ioctl+0x1fb6>
   3efac:	b93a      	cbnz	r2, 3efbe <dwt_ioctl+0x1892>
   3efae:	2200      	movs	r2, #0
   3efb0:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3efb4:	f7fc fb03 	bl	3b5be <dwt_read8bitoffsetreg>
   3efb8:	7020      	strb	r0, [r4, #0]
   3efba:	f7fe bc61 	b.w	3d880 <dwt_ioctl+0x154>
   3efbe:	2201      	movs	r2, #1
   3efc0:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3efc4:	f7fc fafb 	bl	3b5be <dwt_read8bitoffsetreg>
   3efc8:	7020      	strb	r0, [r4, #0]
   3efca:	2500      	movs	r5, #0
   3efcc:	f7fe bc58 	b.w	3d880 <dwt_ioctl+0x154>
   3efd0:	2c00      	cmp	r4, #0
   3efd2:	f000 8389 	beq.w	3f6e8 <dwt_ioctl+0x1fbc>
   3efd6:	7824      	ldrb	r4, [r4, #0]
   3efd8:	2200      	movs	r2, #0
   3efda:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3efde:	f7fc faee 	bl	3b5be <dwt_read8bitoffsetreg>
   3efe2:	f000 039f 	and.w	r3, r0, #159	; 0x9f
   3efe6:	4323      	orrs	r3, r4
   3efe8:	2200      	movs	r2, #0
   3efea:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3efee:	4630      	mov	r0, r6
   3eff0:	f7fd f8c0 	bl	3c174 <dwt_write8bitoffsetreg>
   3eff4:	2500      	movs	r5, #0
   3eff6:	f7fe bc43 	b.w	3d880 <dwt_ioctl+0x154>
   3effa:	2c00      	cmp	r4, #0
   3effc:	f000 8377 	beq.w	3f6ee <dwt_ioctl+0x1fc2>
   3f000:	7824      	ldrb	r4, [r4, #0]
   3f002:	f012 05ff 	ands.w	r5, r2, #255	; 0xff
   3f006:	d01e      	beq.n	3f046 <dwt_ioctl+0x191a>
   3f008:	2d01      	cmp	r5, #1
   3f00a:	f040 8373 	bne.w	3f6f4 <dwt_ioctl+0x1fc8>
   3f00e:	2502      	movs	r5, #2
   3f010:	2201      	movs	r2, #1
   3f012:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3f016:	4630      	mov	r0, r6
   3f018:	f7fc fad1 	bl	3b5be <dwt_read8bitoffsetreg>
   3f01c:	b9ac      	cbnz	r4, 3f04a <dwt_ioctl+0x191e>
   3f01e:	ea20 0305 	bic.w	r3, r0, r5
   3f022:	b2db      	uxtb	r3, r3
   3f024:	2201      	movs	r2, #1
   3f026:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   3f02a:	4630      	mov	r0, r6
   3f02c:	f7fd f8a2 	bl	3c174 <dwt_write8bitoffsetreg>
   3f030:	2200      	movs	r2, #0
   3f032:	2110      	movs	r1, #16
   3f034:	4630      	mov	r0, r6
   3f036:	f7fc fa9a 	bl	3b56e <dwt_read32bitoffsetreg>
   3f03a:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
   3f03e:	d00b      	beq.n	3f058 <dwt_ioctl+0x192c>
   3f040:	2500      	movs	r5, #0
   3f042:	f7fe bc1d 	b.w	3d880 <dwt_ioctl+0x154>
   3f046:	2504      	movs	r5, #4
   3f048:	e7e2      	b.n	3f010 <dwt_ioctl+0x18e4>
   3f04a:	2c01      	cmp	r4, #1
   3f04c:	f040 8356 	bne.w	3f6fc <dwt_ioctl+0x1fd0>
   3f050:	ea40 0305 	orr.w	r3, r0, r5
   3f054:	b2db      	uxtb	r3, r3
   3f056:	e7e5      	b.n	3f024 <dwt_ioctl+0x18f8>
   3f058:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   3f05c:	9300      	str	r3, [sp, #0]
   3f05e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   3f062:	2200      	movs	r2, #0
   3f064:	2110      	movs	r1, #16
   3f066:	4630      	mov	r0, r6
   3f068:	f7fd fb48 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3f06c:	2500      	movs	r5, #0
   3f06e:	f7fe bc07 	b.w	3d880 <dwt_ioctl+0x154>
   3f072:	2c00      	cmp	r4, #0
   3f074:	f000 8346 	beq.w	3f704 <dwt_ioctl+0x1fd8>
   3f078:	7823      	ldrb	r3, [r4, #0]
   3f07a:	035b      	lsls	r3, r3, #13
   3f07c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
   3f080:	9300      	str	r3, [sp, #0]
   3f082:	f64d 73ff 	movw	r3, #57343	; 0xdfff
   3f086:	2200      	movs	r2, #0
   3f088:	4905      	ldr	r1, [pc, #20]	; (3f0a0 <dwt_ioctl+0x1974>)
   3f08a:	f7fd fec5 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f08e:	2500      	movs	r5, #0
   3f090:	f7fe bbf6 	b.w	3d880 <dwt_ioctl+0x154>
   3f094:	00046f60 	.word	0x00046f60
   3f098:	0001001c 	.word	0x0001001c
   3f09c:	00010018 	.word	0x00010018
   3f0a0:	000e000c 	.word	0x000e000c
   3f0a4:	00046ee0 	.word	0x00046ee0
   3f0a8:	00046f20 	.word	0x00046f20
   3f0ac:	2c00      	cmp	r4, #0
   3f0ae:	f000 832c 	beq.w	3f70a <dwt_ioctl+0x1fde>
   3f0b2:	7825      	ldrb	r5, [r4, #0]
   3f0b4:	6862      	ldr	r2, [r4, #4]
   3f0b6:	2a01      	cmp	r2, #1
   3f0b8:	bf15      	itete	ne
   3f0ba:	f46f 3360 	mvnne.w	r3, #229376	; 0x38000
   3f0be:	f46f 43e0 	mvneq.w	r3, #28672	; 0x7000
   3f0c2:	27df      	movne	r7, #223	; 0xdf
   3f0c4:	27ef      	moveq	r7, #239	; 0xef
   3f0c6:	bf14      	ite	ne
   3f0c8:	f04f 0820 	movne.w	r8, #32
   3f0cc:	f04f 0810 	moveq.w	r8, #16
   3f0d0:	2400      	movs	r4, #0
   3f0d2:	9400      	str	r4, [sp, #0]
   3f0d4:	4622      	mov	r2, r4
   3f0d6:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3f0da:	f7fd fb0f 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3f0de:	9400      	str	r4, [sp, #0]
   3f0e0:	463b      	mov	r3, r7
   3f0e2:	4622      	mov	r2, r4
   3f0e4:	49be      	ldr	r1, [pc, #760]	; (3f3e0 <dwt_ioctl+0x1cb4>)
   3f0e6:	4630      	mov	r0, r6
   3f0e8:	f7fd fc7a 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f0ec:	2d01      	cmp	r5, #1
   3f0ee:	d003      	beq.n	3f0f8 <dwt_ioctl+0x19cc>
   3f0f0:	b165      	cbz	r5, 3f10c <dwt_ioctl+0x19e0>
   3f0f2:	2500      	movs	r5, #0
   3f0f4:	f7fe bbc4 	b.w	3d880 <dwt_ioctl+0x154>
   3f0f8:	4625      	mov	r5, r4
   3f0fa:	9400      	str	r4, [sp, #0]
   3f0fc:	463b      	mov	r3, r7
   3f0fe:	4622      	mov	r2, r4
   3f100:	49b8      	ldr	r1, [pc, #736]	; (3f3e4 <dwt_ioctl+0x1cb8>)
   3f102:	4630      	mov	r0, r6
   3f104:	f7fd fc6c 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f108:	f7fe bbba 	b.w	3d880 <dwt_ioctl+0x154>
   3f10c:	f8cd 8000 	str.w	r8, [sp]
   3f110:	23ff      	movs	r3, #255	; 0xff
   3f112:	2200      	movs	r2, #0
   3f114:	49b3      	ldr	r1, [pc, #716]	; (3f3e4 <dwt_ioctl+0x1cb8>)
   3f116:	4630      	mov	r0, r6
   3f118:	f7fd fc62 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f11c:	f7fe bbb0 	b.w	3d880 <dwt_ioctl+0x154>
   3f120:	2c00      	cmp	r4, #0
   3f122:	f000 82f5 	beq.w	3f710 <dwt_ioctl+0x1fe4>
   3f126:	7822      	ldrb	r2, [r4, #0]
   3f128:	f012 0f01 	tst.w	r2, #1
   3f12c:	d02d      	beq.n	3f18a <dwt_ioctl+0x1a5e>
   3f12e:	0157      	lsls	r7, r2, #5
   3f130:	f007 0740 	and.w	r7, r7, #64	; 0x40
   3f134:	2440      	movs	r4, #64	; 0x40
   3f136:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
   3f13a:	f012 0f04 	tst.w	r2, #4
   3f13e:	d028      	beq.n	3f192 <dwt_ioctl+0x1a66>
   3f140:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
   3f144:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   3f148:	0112      	lsls	r2, r2, #4
   3f14a:	f002 0280 	and.w	r2, r2, #128	; 0x80
   3f14e:	4317      	orrs	r7, r2
   3f150:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   3f154:	9200      	str	r2, [sp, #0]
   3f156:	43db      	mvns	r3, r3
   3f158:	2200      	movs	r2, #0
   3f15a:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3f15e:	4630      	mov	r0, r6
   3f160:	f7fd facc 	bl	3c6fc <dwt_modify32bitoffsetreg>
   3f164:	43e4      	mvns	r4, r4
   3f166:	b2a4      	uxth	r4, r4
   3f168:	2500      	movs	r5, #0
   3f16a:	9500      	str	r5, [sp, #0]
   3f16c:	4623      	mov	r3, r4
   3f16e:	462a      	mov	r2, r5
   3f170:	499b      	ldr	r1, [pc, #620]	; (3f3e0 <dwt_ioctl+0x1cb4>)
   3f172:	4630      	mov	r0, r6
   3f174:	f7fd fe50 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f178:	9700      	str	r7, [sp, #0]
   3f17a:	4623      	mov	r3, r4
   3f17c:	462a      	mov	r2, r5
   3f17e:	4999      	ldr	r1, [pc, #612]	; (3f3e4 <dwt_ioctl+0x1cb8>)
   3f180:	4630      	mov	r0, r6
   3f182:	f7fd fe49 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f186:	f7fe bb7b 	b.w	3d880 <dwt_ioctl+0x154>
   3f18a:	2700      	movs	r7, #0
   3f18c:	463c      	mov	r4, r7
   3f18e:	463b      	mov	r3, r7
   3f190:	e7d3      	b.n	3f13a <dwt_ioctl+0x1a0e>
   3f192:	2200      	movs	r2, #0
   3f194:	e7de      	b.n	3f154 <dwt_ioctl+0x1a28>
   3f196:	2308      	movs	r3, #8
   3f198:	9300      	str	r3, [sp, #0]
   3f19a:	23ff      	movs	r3, #255	; 0xff
   3f19c:	2201      	movs	r2, #1
   3f19e:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3f1a2:	f7fd fc1d 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f1a6:	4c90      	ldr	r4, [pc, #576]	; (3f3e8 <dwt_ioctl+0x1cbc>)
   3f1a8:	2302      	movs	r3, #2
   3f1aa:	9300      	str	r3, [sp, #0]
   3f1ac:	23ff      	movs	r3, #255	; 0xff
   3f1ae:	2203      	movs	r2, #3
   3f1b0:	4621      	mov	r1, r4
   3f1b2:	4630      	mov	r0, r6
   3f1b4:	f7fd fc14 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f1b8:	2500      	movs	r5, #0
   3f1ba:	9500      	str	r5, [sp, #0]
   3f1bc:	23f7      	movs	r3, #247	; 0xf7
   3f1be:	2201      	movs	r2, #1
   3f1c0:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3f1c4:	4630      	mov	r0, r6
   3f1c6:	f7fd fc0b 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f1ca:	9500      	str	r5, [sp, #0]
   3f1cc:	23fd      	movs	r3, #253	; 0xfd
   3f1ce:	2203      	movs	r2, #3
   3f1d0:	4621      	mov	r1, r4
   3f1d2:	4630      	mov	r0, r6
   3f1d4:	f7fd fc04 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f1d8:	f7fe bb52 	b.w	3d880 <dwt_ioctl+0x154>
   3f1dc:	2c00      	cmp	r4, #0
   3f1de:	f000 829a 	beq.w	3f716 <dwt_ioctl+0x1fea>
   3f1e2:	8863      	ldrh	r3, [r4, #2]
   3f1e4:	00db      	lsls	r3, r3, #3
   3f1e6:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   3f1ea:	7822      	ldrb	r2, [r4, #0]
   3f1ec:	b10a      	cbz	r2, 3f1f2 <dwt_ioctl+0x1ac6>
   3f1ee:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   3f1f2:	9300      	str	r3, [sp, #0]
   3f1f4:	f24f 0307 	movw	r3, #61447	; 0xf007
   3f1f8:	2200      	movs	r2, #0
   3f1fa:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   3f1fe:	4630      	mov	r0, r6
   3f200:	f7fd fe0a 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f204:	2500      	movs	r5, #0
   3f206:	f7fe bb3b 	b.w	3d880 <dwt_ioctl+0x154>
   3f20a:	2c00      	cmp	r4, #0
   3f20c:	f000 8286 	beq.w	3f71c <dwt_ioctl+0x1ff0>
   3f210:	b2e3      	uxtb	r3, r4
   3f212:	1c9a      	adds	r2, r3, #2
   3f214:	2301      	movs	r3, #1
   3f216:	4093      	lsls	r3, r2
   3f218:	3b01      	subs	r3, #1
   3f21a:	b2db      	uxtb	r3, r3
   3f21c:	2200      	movs	r2, #0
   3f21e:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   3f222:	f7fc ffa7 	bl	3c174 <dwt_write8bitoffsetreg>
   3f226:	2500      	movs	r5, #0
   3f228:	f7fe bb2a 	b.w	3d880 <dwt_ioctl+0x154>
   3f22c:	2c00      	cmp	r4, #0
   3f22e:	f000 8278 	beq.w	3f722 <dwt_ioctl+0x1ff6>
   3f232:	7ae3      	ldrb	r3, [r4, #11]
   3f234:	2b00      	cmp	r3, #0
   3f236:	f000 8277 	beq.w	3f728 <dwt_ioctl+0x1ffc>
   3f23a:	7b63      	ldrb	r3, [r4, #13]
   3f23c:	2b01      	cmp	r3, #1
   3f23e:	d921      	bls.n	3f284 <dwt_ioctl+0x1b58>
   3f240:	7b22      	ldrb	r2, [r4, #12]
   3f242:	4b6a      	ldr	r3, [pc, #424]	; (3f3ec <dwt_ioctl+0x1cc0>)
   3f244:	f833 2012 	ldrh.w	r2, [r3, r2, lsl #1]
   3f248:	0112      	lsls	r2, r2, #4
   3f24a:	0ad3      	lsrs	r3, r2, #11
   3f24c:	f3c2 020a 	ubfx	r2, r2, #0, #11
   3f250:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3f254:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3f258:	bf28      	it	cs
   3f25a:	3301      	addcs	r3, #1
   3f25c:	b29b      	uxth	r3, r3
   3f25e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   3f262:	9300      	str	r3, [sp, #0]
   3f264:	f64f 7380 	movw	r3, #65408	; 0xff80
   3f268:	2202      	movs	r2, #2
   3f26a:	4961      	ldr	r1, [pc, #388]	; (3f3f0 <dwt_ioctl+0x1cc4>)
   3f26c:	4630      	mov	r0, r6
   3f26e:	f7fd fdd3 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f272:	2394      	movs	r3, #148	; 0x94
   3f274:	2200      	movs	r2, #0
   3f276:	495f      	ldr	r1, [pc, #380]	; (3f3f4 <dwt_ioctl+0x1cc8>)
   3f278:	4630      	mov	r0, r6
   3f27a:	f7fc ff7b 	bl	3c174 <dwt_write8bitoffsetreg>
   3f27e:	2500      	movs	r5, #0
   3f280:	f7fe bafe 	b.w	3d880 <dwt_ioctl+0x154>
   3f284:	7b22      	ldrb	r2, [r4, #12]
   3f286:	4b59      	ldr	r3, [pc, #356]	; (3f3ec <dwt_ioctl+0x1cc0>)
   3f288:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
   3f28c:	f44f 6235 	mov.w	r2, #2896	; 0xb50
   3f290:	fb02 f203 	mul.w	r2, r2, r3
   3f294:	0c93      	lsrs	r3, r2, #18
   3f296:	f3c2 12ca 	ubfx	r2, r2, #7, #11
   3f29a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
   3f29e:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
   3f2a2:	bf28      	it	cs
   3f2a4:	3301      	addcs	r3, #1
   3f2a6:	b29b      	uxth	r3, r3
   3f2a8:	e7d9      	b.n	3f25e <dwt_ioctl+0x1b32>
   3f2aa:	2c00      	cmp	r4, #0
   3f2ac:	f000 823f 	beq.w	3f72e <dwt_ioctl+0x2002>
   3f2b0:	2200      	movs	r2, #0
   3f2b2:	4951      	ldr	r1, [pc, #324]	; (3f3f8 <dwt_ioctl+0x1ccc>)
   3f2b4:	f7fc f95b 	bl	3b56e <dwt_read32bitoffsetreg>
   3f2b8:	6020      	str	r0, [r4, #0]
   3f2ba:	2500      	movs	r5, #0
   3f2bc:	f7fe bae0 	b.w	3d880 <dwt_ioctl+0x154>
   3f2c0:	2c00      	cmp	r4, #0
   3f2c2:	f000 8237 	beq.w	3f734 <dwt_ioctl+0x2008>
   3f2c6:	2200      	movs	r2, #0
   3f2c8:	494c      	ldr	r1, [pc, #304]	; (3f3fc <dwt_ioctl+0x1cd0>)
   3f2ca:	f7fc f950 	bl	3b56e <dwt_read32bitoffsetreg>
   3f2ce:	6020      	str	r0, [r4, #0]
   3f2d0:	2500      	movs	r5, #0
   3f2d2:	f7fe bad5 	b.w	3d880 <dwt_ioctl+0x154>
   3f2d6:	2c00      	cmp	r4, #0
   3f2d8:	f000 822f 	beq.w	3f73a <dwt_ioctl+0x200e>
   3f2dc:	f44f 13a8 	mov.w	r3, #1376256	; 0x150000
   3f2e0:	6023      	str	r3, [r4, #0]
   3f2e2:	2500      	movs	r5, #0
   3f2e4:	f7fe bacc 	b.w	3d880 <dwt_ioctl+0x154>
   3f2e8:	2c00      	cmp	r4, #0
   3f2ea:	f000 8229 	beq.w	3f740 <dwt_ioctl+0x2014>
   3f2ee:	2500      	movs	r5, #0
   3f2f0:	950b      	str	r5, [sp, #44]	; 0x2c
   3f2f2:	af10      	add	r7, sp, #64	; 0x40
   3f2f4:	2319      	movs	r3, #25
   3f2f6:	f847 3d10 	str.w	r3, [r7, #-16]!
   3f2fa:	9700      	str	r7, [sp, #0]
   3f2fc:	2304      	movs	r3, #4
   3f2fe:	462a      	mov	r2, r5
   3f300:	493f      	ldr	r1, [pc, #252]	; (3f400 <dwt_ioctl+0x1cd4>)
   3f302:	f7fc fd41 	bl	3bd88 <dwt_writetodevice>
   3f306:	f641 7348 	movw	r3, #8008	; 0x1f48
   3f30a:	930c      	str	r3, [sp, #48]	; 0x30
   3f30c:	9700      	str	r7, [sp, #0]
   3f30e:	2304      	movs	r3, #4
   3f310:	462a      	mov	r2, r5
   3f312:	493c      	ldr	r1, [pc, #240]	; (3f404 <dwt_ioctl+0x1cd8>)
   3f314:	4630      	mov	r0, r6
   3f316:	f7fc fd37 	bl	3bd88 <dwt_writetodevice>
   3f31a:	ab0b      	add	r3, sp, #44	; 0x2c
   3f31c:	9300      	str	r3, [sp, #0]
   3f31e:	2304      	movs	r3, #4
   3f320:	462a      	mov	r2, r5
   3f322:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   3f326:	4630      	mov	r0, r6
   3f328:	f7fc f917 	bl	3b55a <dwt_readfromdevice>
   3f32c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   3f32e:	6023      	str	r3, [r4, #0]
   3f330:	f7fe baa6 	b.w	3d880 <dwt_ioctl+0x154>
   3f334:	2c00      	cmp	r4, #0
   3f336:	f000 8206 	beq.w	3f746 <dwt_ioctl+0x201a>
   3f33a:	2200      	movs	r2, #0
   3f33c:	4932      	ldr	r1, [pc, #200]	; (3f408 <dwt_ioctl+0x1cdc>)
   3f33e:	f7fc f916 	bl	3b56e <dwt_read32bitoffsetreg>
   3f342:	b280      	uxth	r0, r0
   3f344:	6020      	str	r0, [r4, #0]
   3f346:	2200      	movs	r2, #0
   3f348:	4930      	ldr	r1, [pc, #192]	; (3f40c <dwt_ioctl+0x1ce0>)
   3f34a:	4630      	mov	r0, r6
   3f34c:	f7fc f90f 	bl	3b56e <dwt_read32bitoffsetreg>
   3f350:	0d43      	lsrs	r3, r0, #21
   3f352:	019b      	lsls	r3, r3, #6
   3f354:	b29b      	uxth	r3, r3
   3f356:	6063      	str	r3, [r4, #4]
   3f358:	2500      	movs	r5, #0
   3f35a:	f7fe ba91 	b.w	3d880 <dwt_ioctl+0x154>
   3f35e:	2c00      	cmp	r4, #0
   3f360:	f000 81f4 	beq.w	3f74c <dwt_ioctl+0x2020>
   3f364:	7d63      	ldrb	r3, [r4, #21]
   3f366:	b133      	cbz	r3, 3f376 <dwt_ioctl+0x1c4a>
   3f368:	2b01      	cmp	r3, #1
   3f36a:	d05b      	beq.n	3f424 <dwt_ioctl+0x1cf8>
   3f36c:	2b02      	cmp	r3, #2
   3f36e:	f000 8082 	beq.w	3f476 <dwt_ioctl+0x1d4a>
   3f372:	23ff      	movs	r3, #255	; 0xff
   3f374:	e02f      	b.n	3f3d6 <dwt_ioctl+0x1caa>
   3f376:	2200      	movs	r2, #0
   3f378:	4925      	ldr	r1, [pc, #148]	; (3f410 <dwt_ioctl+0x1ce4>)
   3f37a:	f7fc f8f8 	bl	3b56e <dwt_read32bitoffsetreg>
   3f37e:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3f382:	6020      	str	r0, [r4, #0]
   3f384:	2200      	movs	r2, #0
   3f386:	4923      	ldr	r1, [pc, #140]	; (3f414 <dwt_ioctl+0x1ce8>)
   3f388:	4630      	mov	r0, r6
   3f38a:	f7fc f8f0 	bl	3b56e <dwt_read32bitoffsetreg>
   3f38e:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f392:	6060      	str	r0, [r4, #4]
   3f394:	2200      	movs	r2, #0
   3f396:	4920      	ldr	r1, [pc, #128]	; (3f418 <dwt_ioctl+0x1cec>)
   3f398:	4630      	mov	r0, r6
   3f39a:	f7fc f8e8 	bl	3b56e <dwt_read32bitoffsetreg>
   3f39e:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f3a2:	60a0      	str	r0, [r4, #8]
   3f3a4:	2200      	movs	r2, #0
   3f3a6:	491d      	ldr	r1, [pc, #116]	; (3f41c <dwt_ioctl+0x1cf0>)
   3f3a8:	4630      	mov	r0, r6
   3f3aa:	f7fc f8e0 	bl	3b56e <dwt_read32bitoffsetreg>
   3f3ae:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f3b2:	60e0      	str	r0, [r4, #12]
   3f3b4:	2200      	movs	r2, #0
   3f3b6:	491a      	ldr	r1, [pc, #104]	; (3f420 <dwt_ioctl+0x1cf4>)
   3f3b8:	4630      	mov	r0, r6
   3f3ba:	f7fc f8d8 	bl	3b56e <dwt_read32bitoffsetreg>
   3f3be:	f3c0 0013 	ubfx	r0, r0, #0, #20
   3f3c2:	6120      	str	r0, [r4, #16]
   3f3c4:	2203      	movs	r2, #3
   3f3c6:	490c      	ldr	r1, [pc, #48]	; (3f3f8 <dwt_ioctl+0x1ccc>)
   3f3c8:	4630      	mov	r0, r6
   3f3ca:	f7fc f8f8 	bl	3b5be <dwt_read8bitoffsetreg>
   3f3ce:	f3c0 1002 	ubfx	r0, r0, #4, #3
   3f3d2:	7520      	strb	r0, [r4, #20]
   3f3d4:	2300      	movs	r3, #0
   3f3d6:	75a3      	strb	r3, [r4, #22]
   3f3d8:	2500      	movs	r5, #0
   3f3da:	f7fe ba51 	b.w	3d880 <dwt_ioctl+0x154>
   3f3de:	bf00      	nop
   3f3e0:	00050008 	.word	0x00050008
   3f3e4:	0005000c 	.word	0x0005000c
   3f3e8:	00110008 	.word	0x00110008
   3f3ec:	00046f6c 	.word	0x00046f6c
   3f3f0:	000e0014 	.word	0x000e0014
   3f3f4:	000e0018 	.word	0x000e0018
   3f3f8:	00030060 	.word	0x00030060
   3f3fc:	000f004c 	.word	0x000f004c
   3f400:	001f0004 	.word	0x001f0004
   3f404:	001f0008 	.word	0x001f0008
   3f408:	000c0048 	.word	0x000c0048
   3f40c:	000c0028 	.word	0x000c0028
   3f410:	000c0058 	.word	0x000c0058
   3f414:	000c0030 	.word	0x000c0030
   3f418:	000c0034 	.word	0x000c0034
   3f41c:	000c0038 	.word	0x000c0038
   3f420:	000c002c 	.word	0x000c002c
   3f424:	2200      	movs	r2, #0
   3f426:	49d4      	ldr	r1, [pc, #848]	; (3f778 <dwt_ioctl+0x204c>)
   3f428:	f7fc f8a1 	bl	3b56e <dwt_read32bitoffsetreg>
   3f42c:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3f430:	6020      	str	r0, [r4, #0]
   3f432:	2200      	movs	r2, #0
   3f434:	49d1      	ldr	r1, [pc, #836]	; (3f77c <dwt_ioctl+0x2050>)
   3f436:	4630      	mov	r0, r6
   3f438:	f7fc f899 	bl	3b56e <dwt_read32bitoffsetreg>
   3f43c:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f440:	6060      	str	r0, [r4, #4]
   3f442:	2200      	movs	r2, #0
   3f444:	49ce      	ldr	r1, [pc, #824]	; (3f780 <dwt_ioctl+0x2054>)
   3f446:	4630      	mov	r0, r6
   3f448:	f7fc f891 	bl	3b56e <dwt_read32bitoffsetreg>
   3f44c:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f450:	60a0      	str	r0, [r4, #8]
   3f452:	2200      	movs	r2, #0
   3f454:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   3f458:	4630      	mov	r0, r6
   3f45a:	f7fc f888 	bl	3b56e <dwt_read32bitoffsetreg>
   3f45e:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f462:	60e0      	str	r0, [r4, #12]
   3f464:	2200      	movs	r2, #0
   3f466:	49c7      	ldr	r1, [pc, #796]	; (3f784 <dwt_ioctl+0x2058>)
   3f468:	4630      	mov	r0, r6
   3f46a:	f7fc f880 	bl	3b56e <dwt_read32bitoffsetreg>
   3f46e:	f3c0 0013 	ubfx	r0, r0, #0, #20
   3f472:	6120      	str	r0, [r4, #16]
   3f474:	e7a6      	b.n	3f3c4 <dwt_ioctl+0x1c98>
   3f476:	2200      	movs	r2, #0
   3f478:	49c3      	ldr	r1, [pc, #780]	; (3f788 <dwt_ioctl+0x205c>)
   3f47a:	f7fc f878 	bl	3b56e <dwt_read32bitoffsetreg>
   3f47e:	f3c0 000b 	ubfx	r0, r0, #0, #12
   3f482:	6020      	str	r0, [r4, #0]
   3f484:	2200      	movs	r2, #0
   3f486:	49c1      	ldr	r1, [pc, #772]	; (3f78c <dwt_ioctl+0x2060>)
   3f488:	4630      	mov	r0, r6
   3f48a:	f7fc f870 	bl	3b56e <dwt_read32bitoffsetreg>
   3f48e:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f492:	6060      	str	r0, [r4, #4]
   3f494:	2200      	movs	r2, #0
   3f496:	49be      	ldr	r1, [pc, #760]	; (3f790 <dwt_ioctl+0x2064>)
   3f498:	4630      	mov	r0, r6
   3f49a:	f7fc f868 	bl	3b56e <dwt_read32bitoffsetreg>
   3f49e:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f4a2:	60a0      	str	r0, [r4, #8]
   3f4a4:	2200      	movs	r2, #0
   3f4a6:	49bb      	ldr	r1, [pc, #748]	; (3f794 <dwt_ioctl+0x2068>)
   3f4a8:	4630      	mov	r0, r6
   3f4aa:	f7fc f860 	bl	3b56e <dwt_read32bitoffsetreg>
   3f4ae:	f3c0 0015 	ubfx	r0, r0, #0, #22
   3f4b2:	60e0      	str	r0, [r4, #12]
   3f4b4:	2200      	movs	r2, #0
   3f4b6:	49b8      	ldr	r1, [pc, #736]	; (3f798 <dwt_ioctl+0x206c>)
   3f4b8:	4630      	mov	r0, r6
   3f4ba:	f7fc f858 	bl	3b56e <dwt_read32bitoffsetreg>
   3f4be:	f3c0 0013 	ubfx	r0, r0, #0, #20
   3f4c2:	6120      	str	r0, [r4, #16]
   3f4c4:	e77e      	b.n	3f3c4 <dwt_ioctl+0x1c98>
   3f4c6:	2500      	movs	r5, #0
   3f4c8:	f7fe b9da 	b.w	3d880 <dwt_ioctl+0x154>
   3f4cc:	2500      	movs	r5, #0
   3f4ce:	f7fe b9d7 	b.w	3d880 <dwt_ioctl+0x154>
   3f4d2:	2500      	movs	r5, #0
   3f4d4:	f7fe b9d4 	b.w	3d880 <dwt_ioctl+0x154>
   3f4d8:	2500      	movs	r5, #0
   3f4da:	f7fe b9d1 	b.w	3d880 <dwt_ioctl+0x154>
   3f4de:	2500      	movs	r5, #0
   3f4e0:	f7fe b9ce 	b.w	3d880 <dwt_ioctl+0x154>
   3f4e4:	2500      	movs	r5, #0
   3f4e6:	f7fe b9cb 	b.w	3d880 <dwt_ioctl+0x154>
   3f4ea:	2500      	movs	r5, #0
   3f4ec:	f7fe b9c8 	b.w	3d880 <dwt_ioctl+0x154>
   3f4f0:	2500      	movs	r5, #0
   3f4f2:	f7fe b9c5 	b.w	3d880 <dwt_ioctl+0x154>
   3f4f6:	2500      	movs	r5, #0
   3f4f8:	f7fe b9c2 	b.w	3d880 <dwt_ioctl+0x154>
   3f4fc:	2500      	movs	r5, #0
   3f4fe:	f7fe b9bf 	b.w	3d880 <dwt_ioctl+0x154>
   3f502:	2500      	movs	r5, #0
   3f504:	f7fe b9bc 	b.w	3d880 <dwt_ioctl+0x154>
   3f508:	2500      	movs	r5, #0
   3f50a:	f7fe b9b9 	b.w	3d880 <dwt_ioctl+0x154>
   3f50e:	2500      	movs	r5, #0
   3f510:	f7fe b9b6 	b.w	3d880 <dwt_ioctl+0x154>
   3f514:	2500      	movs	r5, #0
   3f516:	f7fe b9b3 	b.w	3d880 <dwt_ioctl+0x154>
   3f51a:	2500      	movs	r5, #0
   3f51c:	f7fe b9b0 	b.w	3d880 <dwt_ioctl+0x154>
   3f520:	2500      	movs	r5, #0
   3f522:	f7fe b9ad 	b.w	3d880 <dwt_ioctl+0x154>
   3f526:	2500      	movs	r5, #0
   3f528:	f7fe b9aa 	b.w	3d880 <dwt_ioctl+0x154>
   3f52c:	2500      	movs	r5, #0
   3f52e:	f7fe b9a7 	b.w	3d880 <dwt_ioctl+0x154>
   3f532:	2500      	movs	r5, #0
   3f534:	f7fe b9a4 	b.w	3d880 <dwt_ioctl+0x154>
   3f538:	2500      	movs	r5, #0
   3f53a:	f7fe b9a1 	b.w	3d880 <dwt_ioctl+0x154>
   3f53e:	2500      	movs	r5, #0
   3f540:	f7fe b99e 	b.w	3d880 <dwt_ioctl+0x154>
   3f544:	2500      	movs	r5, #0
   3f546:	f7fe b99b 	b.w	3d880 <dwt_ioctl+0x154>
   3f54a:	2500      	movs	r5, #0
   3f54c:	f7fe b998 	b.w	3d880 <dwt_ioctl+0x154>
   3f550:	2500      	movs	r5, #0
   3f552:	f7fe b995 	b.w	3d880 <dwt_ioctl+0x154>
   3f556:	2500      	movs	r5, #0
   3f558:	f7fe b992 	b.w	3d880 <dwt_ioctl+0x154>
   3f55c:	2500      	movs	r5, #0
   3f55e:	f7fe b98f 	b.w	3d880 <dwt_ioctl+0x154>
   3f562:	2500      	movs	r5, #0
   3f564:	f7fe b98c 	b.w	3d880 <dwt_ioctl+0x154>
   3f568:	2500      	movs	r5, #0
   3f56a:	f7fe b989 	b.w	3d880 <dwt_ioctl+0x154>
   3f56e:	2500      	movs	r5, #0
   3f570:	f7fe b986 	b.w	3d880 <dwt_ioctl+0x154>
   3f574:	2500      	movs	r5, #0
   3f576:	f7fe b983 	b.w	3d880 <dwt_ioctl+0x154>
   3f57a:	2500      	movs	r5, #0
   3f57c:	f7fe b980 	b.w	3d880 <dwt_ioctl+0x154>
   3f580:	2500      	movs	r5, #0
   3f582:	f7fe b97d 	b.w	3d880 <dwt_ioctl+0x154>
   3f586:	2500      	movs	r5, #0
   3f588:	f7fe b97a 	b.w	3d880 <dwt_ioctl+0x154>
   3f58c:	2500      	movs	r5, #0
   3f58e:	f7fe b977 	b.w	3d880 <dwt_ioctl+0x154>
   3f592:	2500      	movs	r5, #0
   3f594:	f7fe b974 	b.w	3d880 <dwt_ioctl+0x154>
   3f598:	2500      	movs	r5, #0
   3f59a:	f7fe b971 	b.w	3d880 <dwt_ioctl+0x154>
   3f59e:	2500      	movs	r5, #0
   3f5a0:	f7fe b96e 	b.w	3d880 <dwt_ioctl+0x154>
   3f5a4:	2500      	movs	r5, #0
   3f5a6:	f7fe b96b 	b.w	3d880 <dwt_ioctl+0x154>
   3f5aa:	2500      	movs	r5, #0
   3f5ac:	f7fe b968 	b.w	3d880 <dwt_ioctl+0x154>
   3f5b0:	2500      	movs	r5, #0
   3f5b2:	f7fe b965 	b.w	3d880 <dwt_ioctl+0x154>
   3f5b6:	2500      	movs	r5, #0
   3f5b8:	f7fe b962 	b.w	3d880 <dwt_ioctl+0x154>
   3f5bc:	2500      	movs	r5, #0
   3f5be:	f7fe b95f 	b.w	3d880 <dwt_ioctl+0x154>
   3f5c2:	2500      	movs	r5, #0
   3f5c4:	f7fe b95c 	b.w	3d880 <dwt_ioctl+0x154>
   3f5c8:	2500      	movs	r5, #0
   3f5ca:	f7fe b959 	b.w	3d880 <dwt_ioctl+0x154>
   3f5ce:	2500      	movs	r5, #0
   3f5d0:	f7fe b956 	b.w	3d880 <dwt_ioctl+0x154>
   3f5d4:	2500      	movs	r5, #0
   3f5d6:	f7fe b953 	b.w	3d880 <dwt_ioctl+0x154>
   3f5da:	2500      	movs	r5, #0
   3f5dc:	f7fe b950 	b.w	3d880 <dwt_ioctl+0x154>
   3f5e0:	2500      	movs	r5, #0
   3f5e2:	f7fe b94d 	b.w	3d880 <dwt_ioctl+0x154>
   3f5e6:	2500      	movs	r5, #0
   3f5e8:	f7fe b94a 	b.w	3d880 <dwt_ioctl+0x154>
   3f5ec:	2500      	movs	r5, #0
   3f5ee:	f7fe b947 	b.w	3d880 <dwt_ioctl+0x154>
   3f5f2:	2500      	movs	r5, #0
   3f5f4:	f7fe b944 	b.w	3d880 <dwt_ioctl+0x154>
   3f5f8:	2500      	movs	r5, #0
   3f5fa:	f7fe b941 	b.w	3d880 <dwt_ioctl+0x154>
   3f5fe:	2500      	movs	r5, #0
   3f600:	f7fe b93e 	b.w	3d880 <dwt_ioctl+0x154>
   3f604:	2500      	movs	r5, #0
   3f606:	f7fe b93b 	b.w	3d880 <dwt_ioctl+0x154>
   3f60a:	2500      	movs	r5, #0
   3f60c:	f7fe b938 	b.w	3d880 <dwt_ioctl+0x154>
   3f610:	2500      	movs	r5, #0
   3f612:	f7fe b935 	b.w	3d880 <dwt_ioctl+0x154>
   3f616:	2500      	movs	r5, #0
   3f618:	f7fe b932 	b.w	3d880 <dwt_ioctl+0x154>
   3f61c:	2500      	movs	r5, #0
   3f61e:	f7fe b92f 	b.w	3d880 <dwt_ioctl+0x154>
   3f622:	2500      	movs	r5, #0
   3f624:	f7fe b92c 	b.w	3d880 <dwt_ioctl+0x154>
   3f628:	2500      	movs	r5, #0
   3f62a:	f7fe b929 	b.w	3d880 <dwt_ioctl+0x154>
   3f62e:	2500      	movs	r5, #0
   3f630:	f7fe b926 	b.w	3d880 <dwt_ioctl+0x154>
   3f634:	2500      	movs	r5, #0
   3f636:	f7fe b923 	b.w	3d880 <dwt_ioctl+0x154>
   3f63a:	2500      	movs	r5, #0
   3f63c:	f7fe b920 	b.w	3d880 <dwt_ioctl+0x154>
   3f640:	2500      	movs	r5, #0
   3f642:	f7fe b91d 	b.w	3d880 <dwt_ioctl+0x154>
   3f646:	2500      	movs	r5, #0
   3f648:	f7fe b91a 	b.w	3d880 <dwt_ioctl+0x154>
   3f64c:	2500      	movs	r5, #0
   3f64e:	f7fe b917 	b.w	3d880 <dwt_ioctl+0x154>
   3f652:	2500      	movs	r5, #0
   3f654:	f7fe b914 	b.w	3d880 <dwt_ioctl+0x154>
   3f658:	2500      	movs	r5, #0
   3f65a:	f7fe b911 	b.w	3d880 <dwt_ioctl+0x154>
   3f65e:	2500      	movs	r5, #0
   3f660:	f7fe b90e 	b.w	3d880 <dwt_ioctl+0x154>
   3f664:	2500      	movs	r5, #0
   3f666:	f7fe b90b 	b.w	3d880 <dwt_ioctl+0x154>
   3f66a:	2500      	movs	r5, #0
   3f66c:	f7fe b908 	b.w	3d880 <dwt_ioctl+0x154>
   3f670:	2500      	movs	r5, #0
   3f672:	f7fe b905 	b.w	3d880 <dwt_ioctl+0x154>
   3f676:	2500      	movs	r5, #0
   3f678:	f7fe b902 	b.w	3d880 <dwt_ioctl+0x154>
   3f67c:	2500      	movs	r5, #0
   3f67e:	f7fe b8ff 	b.w	3d880 <dwt_ioctl+0x154>
   3f682:	2500      	movs	r5, #0
   3f684:	f7fe b8fc 	b.w	3d880 <dwt_ioctl+0x154>
   3f688:	2500      	movs	r5, #0
   3f68a:	f7fe b8f9 	b.w	3d880 <dwt_ioctl+0x154>
   3f68e:	2500      	movs	r5, #0
   3f690:	f7fe b8f6 	b.w	3d880 <dwt_ioctl+0x154>
   3f694:	2500      	movs	r5, #0
   3f696:	f7fe b8f3 	b.w	3d880 <dwt_ioctl+0x154>
   3f69a:	2500      	movs	r5, #0
   3f69c:	f7fe b8f0 	b.w	3d880 <dwt_ioctl+0x154>
   3f6a0:	2500      	movs	r5, #0
   3f6a2:	f7fe b8ed 	b.w	3d880 <dwt_ioctl+0x154>
   3f6a6:	2500      	movs	r5, #0
   3f6a8:	f7fe b8ea 	b.w	3d880 <dwt_ioctl+0x154>
   3f6ac:	2500      	movs	r5, #0
   3f6ae:	f7fe b8e7 	b.w	3d880 <dwt_ioctl+0x154>
   3f6b2:	2500      	movs	r5, #0
   3f6b4:	f7fe b8e4 	b.w	3d880 <dwt_ioctl+0x154>
   3f6b8:	2500      	movs	r5, #0
   3f6ba:	f7fe b8e1 	b.w	3d880 <dwt_ioctl+0x154>
   3f6be:	2500      	movs	r5, #0
   3f6c0:	f7fe b8de 	b.w	3d880 <dwt_ioctl+0x154>
   3f6c4:	2500      	movs	r5, #0
   3f6c6:	f7fe b8db 	b.w	3d880 <dwt_ioctl+0x154>
   3f6ca:	2500      	movs	r5, #0
   3f6cc:	f7fe b8d8 	b.w	3d880 <dwt_ioctl+0x154>
   3f6d0:	2500      	movs	r5, #0
   3f6d2:	f7fe b8d5 	b.w	3d880 <dwt_ioctl+0x154>
   3f6d6:	2500      	movs	r5, #0
   3f6d8:	f7fe b8d2 	b.w	3d880 <dwt_ioctl+0x154>
   3f6dc:	2500      	movs	r5, #0
   3f6de:	f7fe b8cf 	b.w	3d880 <dwt_ioctl+0x154>
   3f6e2:	2500      	movs	r5, #0
   3f6e4:	f7fe b8cc 	b.w	3d880 <dwt_ioctl+0x154>
   3f6e8:	2500      	movs	r5, #0
   3f6ea:	f7fe b8c9 	b.w	3d880 <dwt_ioctl+0x154>
   3f6ee:	2500      	movs	r5, #0
   3f6f0:	f7fe b8c6 	b.w	3d880 <dwt_ioctl+0x154>
   3f6f4:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   3f6f8:	f7fe b8c2 	b.w	3d880 <dwt_ioctl+0x154>
   3f6fc:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   3f700:	f7fe b8be 	b.w	3d880 <dwt_ioctl+0x154>
   3f704:	2500      	movs	r5, #0
   3f706:	f7fe b8bb 	b.w	3d880 <dwt_ioctl+0x154>
   3f70a:	2500      	movs	r5, #0
   3f70c:	f7fe b8b8 	b.w	3d880 <dwt_ioctl+0x154>
   3f710:	2500      	movs	r5, #0
   3f712:	f7fe b8b5 	b.w	3d880 <dwt_ioctl+0x154>
   3f716:	2500      	movs	r5, #0
   3f718:	f7fe b8b2 	b.w	3d880 <dwt_ioctl+0x154>
   3f71c:	2500      	movs	r5, #0
   3f71e:	f7fe b8af 	b.w	3d880 <dwt_ioctl+0x154>
   3f722:	2500      	movs	r5, #0
   3f724:	f7fe b8ac 	b.w	3d880 <dwt_ioctl+0x154>
   3f728:	2500      	movs	r5, #0
   3f72a:	f7fe b8a9 	b.w	3d880 <dwt_ioctl+0x154>
   3f72e:	2500      	movs	r5, #0
   3f730:	f7fe b8a6 	b.w	3d880 <dwt_ioctl+0x154>
   3f734:	2500      	movs	r5, #0
   3f736:	f7fe b8a3 	b.w	3d880 <dwt_ioctl+0x154>
   3f73a:	2500      	movs	r5, #0
   3f73c:	f7fe b8a0 	b.w	3d880 <dwt_ioctl+0x154>
   3f740:	2500      	movs	r5, #0
   3f742:	f7fe b89d 	b.w	3d880 <dwt_ioctl+0x154>
   3f746:	2500      	movs	r5, #0
   3f748:	f7fe b89a 	b.w	3d880 <dwt_ioctl+0x154>
   3f74c:	2500      	movs	r5, #0
   3f74e:	f7fe b897 	b.w	3d880 <dwt_ioctl+0x154>
   3f752:	f899 3011 	ldrb.w	r3, [r9, #17]
   3f756:	1e5a      	subs	r2, r3, #1
   3f758:	b2d2      	uxtb	r2, r2
   3f75a:	2a01      	cmp	r2, #1
   3f75c:	f67e aeec 	bls.w	3e538 <dwt_ioctl+0xe0c>
   3f760:	2202      	movs	r2, #2
   3f762:	f7fe be93 	b.w	3e48c <dwt_ioctl+0xd60>
   3f766:	2f00      	cmp	r7, #0
   3f768:	f43f ab68 	beq.w	3ee3c <dwt_ioctl+0x1710>
   3f76c:	f819 1000 	ldrb.w	r1, [r9, r0]
   3f770:	1a5b      	subs	r3, r3, r1
   3f772:	b29b      	uxth	r3, r3
   3f774:	f7ff bb88 	b.w	3ee88 <dwt_ioctl+0x175c>
   3f778:	000d0020 	.word	0x000d0020
   3f77c:	000c0064 	.word	0x000c0064
   3f780:	000c0068 	.word	0x000c0068
   3f784:	000c0060 	.word	0x000c0060
   3f788:	000d0068 	.word	0x000d0068
   3f78c:	000d0040 	.word	0x000d0040
   3f790:	000d0044 	.word	0x000d0044
   3f794:	000d0048 	.word	0x000d0048
   3f798:	000d003c 	.word	0x000d003c
   3f79c:	283f      	cmp	r0, #63	; 0x3f
   3f79e:	d027      	beq.n	3f7f0 <dwt_ioctl+0x20c4>
   3f7a0:	2e00      	cmp	r6, #0
   3f7a2:	f47f ab51 	bne.w	3ee48 <dwt_ioctl+0x171c>
   3f7a6:	3001      	adds	r0, #1
   3f7a8:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   3f7ac:	f819 1000 	ldrb.w	r1, [r9, r0]
   3f7b0:	440b      	add	r3, r1
   3f7b2:	b29b      	uxth	r3, r3
   3f7b4:	459c      	cmp	ip, r3
   3f7b6:	f43f ab65 	beq.w	3ee84 <dwt_ioctl+0x1758>
   3f7ba:	3d01      	subs	r5, #1
   3f7bc:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
   3f7c0:	f43f ab23 	beq.w	3ee0a <dwt_ioctl+0x16de>
   3f7c4:	459e      	cmp	lr, r3
   3f7c6:	f4bf ab33 	bcs.w	3ee30 <dwt_ioctl+0x1704>
   3f7ca:	4598      	cmp	r8, r3
   3f7cc:	d9cb      	bls.n	3f766 <dwt_ioctl+0x203a>
   3f7ce:	ebac 0103 	sub.w	r1, ip, r3
   3f7d2:	b209      	sxth	r1, r1
   3f7d4:	2900      	cmp	r1, #0
   3f7d6:	bfb8      	it	lt
   3f7d8:	4249      	neglt	r1, r1
   3f7da:	4559      	cmp	r1, fp
   3f7dc:	f77f ab20 	ble.w	3ee20 <dwt_ioctl+0x16f4>
   3f7e0:	2f00      	cmp	r7, #0
   3f7e2:	f47f ab64 	bne.w	3eeae <dwt_ioctl+0x1782>
   3f7e6:	283f      	cmp	r0, #63	; 0x3f
   3f7e8:	d1da      	bne.n	3f7a0 <dwt_ioctl+0x2074>
   3f7ea:	2f00      	cmp	r7, #0
   3f7ec:	f47f ab64 	bne.w	3eeb8 <dwt_ioctl+0x178c>
   3f7f0:	2a03      	cmp	r2, #3
   3f7f2:	f43f ab64 	beq.w	3eebe <dwt_ioctl+0x1792>
   3f7f6:	2a02      	cmp	r2, #2
   3f7f8:	f43f ab33 	beq.w	3ee62 <dwt_ioctl+0x1736>
   3f7fc:	f81a 1002 	ldrb.w	r1, [sl, r2]
   3f800:	185e      	adds	r6, r3, r1
   3f802:	4566      	cmp	r6, ip
   3f804:	f77f ab34 	ble.w	3ee70 <dwt_ioctl+0x1744>
   3f808:	440b      	add	r3, r1
   3f80a:	b29b      	uxth	r3, r3
   3f80c:	3201      	adds	r2, #1
   3f80e:	b2d2      	uxtb	r2, r2
   3f810:	2700      	movs	r7, #0
   3f812:	f7ff bb19 	b.w	3ee48 <dwt_ioctl+0x171c>
   3f816:	bf00      	nop

0003f818 <_init>:
   3f818:	b5f0      	push	{r4, r5, r6, r7, lr}
   3f81a:	b085      	sub	sp, #20
   3f81c:	4604      	mov	r4, r0
   3f81e:	6b43      	ldr	r3, [r0, #52]	; 0x34
   3f820:	6819      	ldr	r1, [r3, #0]
   3f822:	f7fd fe57 	bl	3d4d4 <ull_initialise>
   3f826:	4606      	mov	r6, r0
   3f828:	6823      	ldr	r3, [r4, #0]
   3f82a:	691b      	ldr	r3, [r3, #16]
   3f82c:	4798      	blx	r3
   3f82e:	ab03      	add	r3, sp, #12
   3f830:	2200      	movs	r2, #0
   3f832:	4611      	mov	r1, r2
   3f834:	4620      	mov	r0, r4
   3f836:	f7fd ff79 	bl	3d72c <dwt_ioctl>
   3f83a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f83c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f83e:	6819      	ldr	r1, [r3, #0]
   3f840:	4620      	mov	r0, r4
   3f842:	f7fd fc07 	bl	3d054 <ull_configure>
   3f846:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f848:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f84a:	6859      	ldr	r1, [r3, #4]
   3f84c:	4620      	mov	r0, r4
   3f84e:	f7fd f953 	bl	3caf8 <ull_configuretxrf>
   3f852:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f854:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f856:	89db      	ldrh	r3, [r3, #14]
   3f858:	2200      	movs	r2, #0
   3f85a:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3f85e:	4620      	mov	r0, r4
   3f860:	f7fc fa9d 	bl	3bd9e <dwt_write16bitoffsetreg>
   3f864:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f866:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f868:	899b      	ldrh	r3, [r3, #12]
   3f86a:	2200      	movs	r2, #0
   3f86c:	217c      	movs	r1, #124	; 0x7c
   3f86e:	4620      	mov	r0, r4
   3f870:	f7fc fa95 	bl	3bd9e <dwt_write16bitoffsetreg>
   3f874:	2100      	movs	r1, #0
   3f876:	4620      	mov	r0, r4
   3f878:	f7fc fb29 	bl	3bece <ull_setrxaftertxdelay>
   3f87c:	2500      	movs	r5, #0
   3f87e:	9500      	str	r5, [sp, #0]
   3f880:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   3f884:	462a      	mov	r2, r5
   3f886:	2110      	movs	r1, #16
   3f888:	4620      	mov	r0, r4
   3f88a:	f7fd fac5 	bl	3ce18 <dwt_modify16bitoffsetreg>
   3f88e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f890:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f892:	895a      	ldrh	r2, [r3, #10]
   3f894:	8919      	ldrh	r1, [r3, #8]
   3f896:	4620      	mov	r0, r4
   3f898:	f7fd f9bc 	bl	3cc14 <ull_configureframefilter>
   3f89c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f89e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f8a0:	8a1b      	ldrh	r3, [r3, #16]
   3f8a2:	2202      	movs	r2, #2
   3f8a4:	210c      	movs	r1, #12
   3f8a6:	4620      	mov	r0, r4
   3f8a8:	f7fc fa79 	bl	3bd9e <dwt_write16bitoffsetreg>
   3f8ac:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f8ae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   3f8b0:	8a5b      	ldrh	r3, [r3, #18]
   3f8b2:	462a      	mov	r2, r5
   3f8b4:	210c      	movs	r1, #12
   3f8b6:	4620      	mov	r0, r4
   3f8b8:	f7fc fa71 	bl	3bd9e <dwt_write16bitoffsetreg>
   3f8bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f8be:	7a19      	ldrb	r1, [r3, #8]
   3f8c0:	4620      	mov	r0, r4
   3f8c2:	f7fd fac3 	bl	3ce4c <ull_setleds>
   3f8c6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f8c8:	68d9      	ldr	r1, [r3, #12]
   3f8ca:	4620      	mov	r0, r4
   3f8cc:	f7fc fb13 	bl	3bef6 <ull_setlnapamode>
   3f8d0:	6b61      	ldr	r1, [r4, #52]	; 0x34
   3f8d2:	7e0b      	ldrb	r3, [r1, #24]
   3f8d4:	694a      	ldr	r2, [r1, #20]
   3f8d6:	6909      	ldr	r1, [r1, #16]
   3f8d8:	4620      	mov	r0, r4
   3f8da:	f7fd fa21 	bl	3cd20 <ull_setinterrupt>
   3f8de:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f8e0:	7f9a      	ldrb	r2, [r3, #30]
   3f8e2:	8b99      	ldrh	r1, [r3, #28]
   3f8e4:	4620      	mov	r0, r4
   3f8e6:	f7fc fd19 	bl	3c31c <ull_configuresleep>
   3f8ea:	6d22      	ldr	r2, [r4, #80]	; 0x50
   3f8ec:	7b53      	ldrb	r3, [r2, #13]
   3f8ee:	2b2e      	cmp	r3, #46	; 0x2e
   3f8f0:	d005      	beq.n	3f8fe <_init+0xe6>
   3f8f2:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f8f4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   3f8f8:	f033 033f 	bics.w	r3, r3, #63	; 0x3f
   3f8fc:	d00a      	beq.n	3f914 <_init+0xfc>
   3f8fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f900:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   3f904:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   3f908:	7353      	strb	r3, [r2, #13]
   3f90a:	2200      	movs	r2, #0
   3f90c:	492a      	ldr	r1, [pc, #168]	; (3f9b8 <_init+0x1a0>)
   3f90e:	4620      	mov	r0, r4
   3f910:	f7fc fc30 	bl	3c174 <dwt_write8bitoffsetreg>
   3f914:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f916:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
   3f91a:	4620      	mov	r0, r4
   3f91c:	f7fd f874 	bl	3ca08 <ull_configciadiag>
   3f920:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f922:	6a19      	ldr	r1, [r3, #32]
   3f924:	4620      	mov	r0, r4
   3f926:	f7fc fb07 	bl	3bf38 <ull_configurestskey>
   3f92a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f92c:	6a59      	ldr	r1, [r3, #36]	; 0x24
   3f92e:	4620      	mov	r0, r4
   3f930:	f7fc fb26 	bl	3bf80 <ull_configurestsiv>
   3f934:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f936:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
   3f93a:	bb9b      	cbnz	r3, 3f9a4 <_init+0x18c>
   3f93c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   3f93e:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
   3f942:	4620      	mov	r0, r4
   3f944:	f7fc fc8e 	bl	3c264 <ull_configeventcounters>
   3f948:	f994 504c 	ldrsb.w	r5, [r4, #76]	; 0x4c
   3f94c:	2d00      	cmp	r5, #0
   3f94e:	db26      	blt.n	3f99e <_init+0x186>
   3f950:	2301      	movs	r3, #1
   3f952:	fa03 f505 	lsl.w	r5, r3, r5
   3f956:	b2af      	uxth	r7, r5
   3f958:	4a18      	ldr	r2, [pc, #96]	; (3f9bc <_init+0x1a4>)
   3f95a:	4639      	mov	r1, r7
   3f95c:	4620      	mov	r0, r4
   3f95e:	f7fc ffef 	bl	3c940 <ull_setgpiomode>
   3f962:	f10d 030a 	add.w	r3, sp, #10
   3f966:	9300      	str	r3, [sp, #0]
   3f968:	2302      	movs	r3, #2
   3f96a:	2200      	movs	r2, #0
   3f96c:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   3f970:	4620      	mov	r0, r4
   3f972:	f7fb fdf2 	bl	3b55a <dwt_readfromdevice>
   3f976:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   3f97a:	ea23 0305 	bic.w	r3, r3, r5
   3f97e:	f8ad 300a 	strh.w	r3, [sp, #10]
   3f982:	2200      	movs	r2, #0
   3f984:	490e      	ldr	r1, [pc, #56]	; (3f9c0 <_init+0x1a8>)
   3f986:	4620      	mov	r0, r4
   3f988:	f7fc fa09 	bl	3bd9e <dwt_write16bitoffsetreg>
   3f98c:	f994 204d 	ldrsb.w	r2, [r4, #77]	; 0x4d
   3f990:	fab2 f282 	clz	r2, r2
   3f994:	0952      	lsrs	r2, r2, #5
   3f996:	4639      	mov	r1, r7
   3f998:	4620      	mov	r0, r4
   3f99a:	f7fd fad5 	bl	3cf48 <ull_setgpiovalue>
   3f99e:	4630      	mov	r0, r6
   3f9a0:	b005      	add	sp, #20
   3f9a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   3f9a4:	2301      	movs	r3, #1
   3f9a6:	9300      	str	r3, [sp, #0]
   3f9a8:	23ff      	movs	r3, #255	; 0xff
   3f9aa:	2200      	movs	r2, #0
   3f9ac:	4905      	ldr	r1, [pc, #20]	; (3f9c4 <_init+0x1ac>)
   3f9ae:	4620      	mov	r0, r4
   3f9b0:	f7fd f816 	bl	3c9e0 <dwt_modify8bitoffsetreg>
   3f9b4:	e7c2      	b.n	3f93c <_init+0x124>
   3f9b6:	bf00      	nop
   3f9b8:	00090014 	.word	0x00090014
   3f9bc:	01200492 	.word	0x01200492
   3f9c0:	00050008 	.word	0x00050008
   3f9c4:	00020004 	.word	0x00020004

0003f9c8 <ull_wakeup_ic>:
   3f9c8:	b508      	push	{r3, lr}
   3f9ca:	6843      	ldr	r3, [r0, #4]
   3f9cc:	4798      	blx	r3
   3f9ce:	bd08      	pop	{r3, pc}

0003f9d0 <get_sts_mnth>:
   3f9d0:	fb01 f100 	mul.w	r1, r1, r0
   3f9d4:	2a03      	cmp	r2, #3
   3f9d6:	d00a      	beq.n	3f9ee <get_sts_mnth+0x1e>
   3f9d8:	0ac8      	lsrs	r0, r1, #11
   3f9da:	f3c1 010a 	ubfx	r1, r1, #0, #11
   3f9de:	f501 6180 	add.w	r1, r1, #1024	; 0x400
   3f9e2:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
   3f9e6:	bf28      	it	cs
   3f9e8:	3001      	addcs	r0, #1
   3f9ea:	b280      	uxth	r0, r0
   3f9ec:	4770      	bx	lr
   3f9ee:	20b5      	movs	r0, #181	; 0xb5
   3f9f0:	fb00 f101 	mul.w	r1, r0, r1
   3f9f4:	09c9      	lsrs	r1, r1, #7
   3f9f6:	e7ef      	b.n	3f9d8 <get_sts_mnth+0x8>

0003f9f8 <dwt_dbg_fn>:
   3f9f8:	2998      	cmp	r1, #152	; 0x98
   3f9fa:	4802      	ldr	r0, [pc, #8]	; (3fa04 <dwt_dbg_fn+0xc>)
   3f9fc:	bf18      	it	ne
   3f9fe:	2000      	movne	r0, #0
   3fa00:	4770      	bx	lr
   3fa02:	bf00      	nop
   3fa04:	00047074 	.word	0x00047074

0003fa08 <_deinit>:
   3fa08:	4770      	bx	lr

0003fa0a <dwt_xfer3xxx>:
   3fa0a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   3fa0e:	b084      	sub	sp, #16
   3fa10:	4605      	mov	r5, r0
   3fa12:	460f      	mov	r7, r1
   3fa14:	461e      	mov	r6, r3
   3fa16:	f8bd 302c 	ldrh.w	r3, [sp, #44]	; 0x2c
   3fa1a:	1e59      	subs	r1, r3, #1
   3fa1c:	b289      	uxth	r1, r1
   3fa1e:	2901      	cmp	r1, #1
   3fa20:	d91c      	bls.n	3fa5c <dwt_xfer3xxx+0x52>
   3fa22:	19d0      	adds	r0, r2, r7
   3fa24:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   3fa28:	443a      	add	r2, r7
   3fa2a:	f3c2 4104 	ubfx	r1, r2, #16, #5
   3fa2e:	0082      	lsls	r2, r0, #2
   3fa30:	ea42 2241 	orr.w	r2, r2, r1, lsl #9
   3fa34:	ea43 0102 	orr.w	r1, r3, r2
   3fa38:	0a09      	lsrs	r1, r1, #8
   3fa3a:	f88d 100c 	strb.w	r1, [sp, #12]
   3fa3e:	b920      	cbnz	r0, 3fa4a <dwt_xfer3xxx+0x40>
   3fa40:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   3fa44:	d018      	beq.n	3fa78 <dwt_xfer3xxx+0x6e>
   3fa46:	2b00      	cmp	r3, #0
   3fa48:	d037      	beq.n	3faba <dwt_xfer3xxx+0xb0>
   3fa4a:	f041 0140 	orr.w	r1, r1, #64	; 0x40
   3fa4e:	f88d 100c 	strb.w	r1, [sp, #12]
   3fa52:	431a      	orrs	r2, r3
   3fa54:	f88d 200d 	strb.w	r2, [sp, #13]
   3fa58:	2402      	movs	r4, #2
   3fa5a:	e005      	b.n	3fa68 <dwt_xfer3xxx+0x5e>
   3fa5c:	007a      	lsls	r2, r7, #1
   3fa5e:	f062 027e 	orn	r2, r2, #126	; 0x7e
   3fa62:	f88d 200c 	strb.w	r2, [sp, #12]
   3fa66:	2401      	movs	r4, #1
   3fa68:	2b02      	cmp	r3, #2
   3fa6a:	d006      	beq.n	3fa7a <dwt_xfer3xxx+0x70>
   3fa6c:	d326      	bcc.n	3fabc <dwt_xfer3xxx+0xb2>
   3fa6e:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
   3fa72:	2b03      	cmp	r3, #3
   3fa74:	d901      	bls.n	3fa7a <dwt_xfer3xxx+0x70>
   3fa76:	e7fe      	b.n	3fa76 <dwt_xfer3xxx+0x6c>
   3fa78:	2401      	movs	r4, #1
   3fa7a:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3fa7c:	7d1b      	ldrb	r3, [r3, #20]
   3fa7e:	b94b      	cbnz	r3, 3fa94 <dwt_xfer3xxx+0x8a>
   3fa80:	682b      	ldr	r3, [r5, #0]
   3fa82:	685d      	ldr	r5, [r3, #4]
   3fa84:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3fa86:	4632      	mov	r2, r6
   3fa88:	a903      	add	r1, sp, #12
   3fa8a:	4620      	mov	r0, r4
   3fa8c:	47a8      	blx	r5
   3fa8e:	b004      	add	sp, #16
   3fa90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   3fa94:	2200      	movs	r2, #0
   3fa96:	4621      	mov	r1, r4
   3fa98:	a803      	add	r0, sp, #12
   3fa9a:	f7f7 fb6f 	bl	3717c <dwt_generatecrc8>
   3fa9e:	4602      	mov	r2, r0
   3faa0:	4631      	mov	r1, r6
   3faa2:	980a      	ldr	r0, [sp, #40]	; 0x28
   3faa4:	f7f7 fb6a 	bl	3717c <dwt_generatecrc8>
   3faa8:	682b      	ldr	r3, [r5, #0]
   3faaa:	9000      	str	r0, [sp, #0]
   3faac:	689d      	ldr	r5, [r3, #8]
   3faae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3fab0:	4632      	mov	r2, r6
   3fab2:	a903      	add	r1, sp, #12
   3fab4:	4620      	mov	r0, r4
   3fab6:	47a8      	blx	r5
   3fab8:	e7e9      	b.n	3fa8e <dwt_xfer3xxx+0x84>
   3faba:	2401      	movs	r4, #1
   3fabc:	682b      	ldr	r3, [r5, #0]
   3fabe:	f8d3 8000 	ldr.w	r8, [r3]
   3fac2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   3fac4:	4632      	mov	r2, r6
   3fac6:	a903      	add	r1, sp, #12
   3fac8:	4620      	mov	r0, r4
   3faca:	47c0      	blx	r8
   3facc:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3face:	7d1b      	ldrb	r3, [r3, #20]
   3fad0:	2b02      	cmp	r3, #2
   3fad2:	d1dc      	bne.n	3fa8e <dwt_xfer3xxx+0x84>
   3fad4:	2f18      	cmp	r7, #24
   3fad6:	d0da      	beq.n	3fa8e <dwt_xfer3xxx+0x84>
   3fad8:	2200      	movs	r2, #0
   3fada:	4621      	mov	r1, r4
   3fadc:	a803      	add	r0, sp, #12
   3fade:	f7f7 fb4d 	bl	3717c <dwt_generatecrc8>
   3fae2:	4602      	mov	r2, r0
   3fae4:	4631      	mov	r1, r6
   3fae6:	980a      	ldr	r0, [sp, #40]	; 0x28
   3fae8:	f7f7 fb48 	bl	3717c <dwt_generatecrc8>
   3faec:	4604      	mov	r4, r0
   3faee:	2200      	movs	r2, #0
   3faf0:	2118      	movs	r1, #24
   3faf2:	4628      	mov	r0, r5
   3faf4:	f000 f866 	bl	3fbc4 <dwt_read8bitoffsetreg>
   3faf8:	4284      	cmp	r4, r0
   3fafa:	d0c8      	beq.n	3fa8e <dwt_xfer3xxx+0x84>
   3fafc:	68eb      	ldr	r3, [r5, #12]
   3fafe:	2b00      	cmp	r3, #0
   3fb00:	d0c5      	beq.n	3fa8e <dwt_xfer3xxx+0x84>
   3fb02:	4798      	blx	r3
   3fb04:	e7c3      	b.n	3fa8e <dwt_xfer3xxx+0x84>

0003fb06 <dwt_readfromdevice>:
   3fb06:	b510      	push	{r4, lr}
   3fb08:	b082      	sub	sp, #8
   3fb0a:	2400      	movs	r4, #0
   3fb0c:	9401      	str	r4, [sp, #4]
   3fb0e:	9c04      	ldr	r4, [sp, #16]
   3fb10:	9400      	str	r4, [sp, #0]
   3fb12:	f7ff ff7a 	bl	3fa0a <dwt_xfer3xxx>
   3fb16:	b002      	add	sp, #8
   3fb18:	bd10      	pop	{r4, pc}

0003fb1a <dwt_read32bitoffsetreg>:
   3fb1a:	b500      	push	{lr}
   3fb1c:	b085      	sub	sp, #20
   3fb1e:	ab03      	add	r3, sp, #12
   3fb20:	9300      	str	r3, [sp, #0]
   3fb22:	2304      	movs	r3, #4
   3fb24:	b292      	uxth	r2, r2
   3fb26:	f7ff ffee 	bl	3fb06 <dwt_readfromdevice>
   3fb2a:	f10d 030f 	add.w	r3, sp, #15
   3fb2e:	f10d 010b 	add.w	r1, sp, #11
   3fb32:	2000      	movs	r0, #0
   3fb34:	f813 2901 	ldrb.w	r2, [r3], #-1
   3fb38:	eb02 2000 	add.w	r0, r2, r0, lsl #8
   3fb3c:	428b      	cmp	r3, r1
   3fb3e:	d1f9      	bne.n	3fb34 <dwt_read32bitoffsetreg+0x1a>
   3fb40:	b005      	add	sp, #20
   3fb42:	f85d fb04 	ldr.w	pc, [sp], #4

0003fb46 <dwt_read16bitoffsetreg>:
   3fb46:	b500      	push	{lr}
   3fb48:	b085      	sub	sp, #20
   3fb4a:	ab03      	add	r3, sp, #12
   3fb4c:	9300      	str	r3, [sp, #0]
   3fb4e:	2302      	movs	r3, #2
   3fb50:	b292      	uxth	r2, r2
   3fb52:	f7ff ffd8 	bl	3fb06 <dwt_readfromdevice>
   3fb56:	f89d 300d 	ldrb.w	r3, [sp, #13]
   3fb5a:	f89d 000c 	ldrb.w	r0, [sp, #12]
   3fb5e:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   3fb62:	b280      	uxth	r0, r0
   3fb64:	b005      	add	sp, #20
   3fb66:	f85d fb04 	ldr.w	pc, [sp], #4

0003fb6a <ull_getrxantennadelay>:
   3fb6a:	b508      	push	{r3, lr}
   3fb6c:	2200      	movs	r2, #0
   3fb6e:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   3fb72:	f7ff ffe8 	bl	3fb46 <dwt_read16bitoffsetreg>
   3fb76:	bd08      	pop	{r3, pc}

0003fb78 <ull_gettxantennadelay>:
   3fb78:	b508      	push	{r3, lr}
   3fb7a:	2200      	movs	r2, #0
   3fb7c:	217c      	movs	r1, #124	; 0x7c
   3fb7e:	f7ff ffe2 	bl	3fb46 <dwt_read16bitoffsetreg>
   3fb82:	bd08      	pop	{r3, pc}

0003fb84 <ull_readclockoffset>:
   3fb84:	b508      	push	{r3, lr}
   3fb86:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3fb88:	7b9b      	ldrb	r3, [r3, #14]
   3fb8a:	2b01      	cmp	r3, #1
   3fb8c:	d00a      	beq.n	3fba4 <ull_readclockoffset+0x20>
   3fb8e:	2b03      	cmp	r3, #3
   3fb90:	d10e      	bne.n	3fbb0 <ull_readclockoffset+0x2c>
   3fb92:	220c      	movs	r2, #12
   3fb94:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3fb98:	f7ff ffd5 	bl	3fb46 <dwt_read16bitoffsetreg>
   3fb9c:	b200      	sxth	r0, r0
   3fb9e:	f340 000c 	sbfx	r0, r0, #0, #13
   3fba2:	bd08      	pop	{r3, pc}
   3fba4:	2200      	movs	r2, #0
   3fba6:	4905      	ldr	r1, [pc, #20]	; (3fbbc <ull_readclockoffset+0x38>)
   3fba8:	f7ff ffcd 	bl	3fb46 <dwt_read16bitoffsetreg>
   3fbac:	b200      	sxth	r0, r0
   3fbae:	e7f6      	b.n	3fb9e <ull_readclockoffset+0x1a>
   3fbb0:	2200      	movs	r2, #0
   3fbb2:	4903      	ldr	r1, [pc, #12]	; (3fbc0 <ull_readclockoffset+0x3c>)
   3fbb4:	f7ff ffc7 	bl	3fb46 <dwt_read16bitoffsetreg>
   3fbb8:	b200      	sxth	r0, r0
   3fbba:	e7f0      	b.n	3fb9e <ull_readclockoffset+0x1a>
   3fbbc:	0018000c 	.word	0x0018000c
   3fbc0:	000c0020 	.word	0x000c0020

0003fbc4 <dwt_read8bitoffsetreg>:
   3fbc4:	b500      	push	{lr}
   3fbc6:	b085      	sub	sp, #20
   3fbc8:	f10d 030f 	add.w	r3, sp, #15
   3fbcc:	9300      	str	r3, [sp, #0]
   3fbce:	2301      	movs	r3, #1
   3fbd0:	b292      	uxth	r2, r2
   3fbd2:	f7ff ff98 	bl	3fb06 <dwt_readfromdevice>
   3fbd6:	f89d 000f 	ldrb.w	r0, [sp, #15]
   3fbda:	b005      	add	sp, #20
   3fbdc:	f85d fb04 	ldr.w	pc, [sp], #4

0003fbe0 <ull_readcarrierintegrator>:
   3fbe0:	b500      	push	{lr}
   3fbe2:	b085      	sub	sp, #20
   3fbe4:	ab03      	add	r3, sp, #12
   3fbe6:	9300      	str	r3, [sp, #0]
   3fbe8:	2303      	movs	r3, #3
   3fbea:	2200      	movs	r2, #0
   3fbec:	490b      	ldr	r1, [pc, #44]	; (3fc1c <ull_readcarrierintegrator+0x3c>)
   3fbee:	f7ff ff8a 	bl	3fb06 <dwt_readfromdevice>
   3fbf2:	f89d 300e 	ldrb.w	r3, [sp, #14]
   3fbf6:	f89d 000d 	ldrb.w	r0, [sp, #13]
   3fbfa:	eb00 2303 	add.w	r3, r0, r3, lsl #8
   3fbfe:	f89d 000c 	ldrb.w	r0, [sp, #12]
   3fc02:	eb00 2003 	add.w	r0, r0, r3, lsl #8
   3fc06:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
   3fc0a:	bf1c      	itt	ne
   3fc0c:	ea6f 3000 	mvnne.w	r0, r0, lsl #12
   3fc10:	ea6f 3010 	mvnne.w	r0, r0, lsr #12
   3fc14:	b005      	add	sp, #20
   3fc16:	f85d fb04 	ldr.w	pc, [sp], #4
   3fc1a:	bf00      	nop
   3fc1c:	00060029 	.word	0x00060029

0003fc20 <ull_readdiagnostics>:
   3fc20:	b530      	push	{r4, r5, lr}
   3fc22:	b0bd      	sub	sp, #244	; 0xf4
   3fc24:	4605      	mov	r5, r0
   3fc26:	460c      	mov	r4, r1
   3fc28:	6d03      	ldr	r3, [r0, #80]	; 0x50
   3fc2a:	7b9a      	ldrb	r2, [r3, #14]
   3fc2c:	2a01      	cmp	r2, #1
   3fc2e:	d01c      	beq.n	3fc6a <ull_readdiagnostics+0x4a>
   3fc30:	2a03      	cmp	r2, #3
   3fc32:	f040 81f1 	bne.w	40018 <ull_readdiagnostics+0x3f8>
   3fc36:	7d9b      	ldrb	r3, [r3, #22]
   3fc38:	f013 0f08 	tst.w	r3, #8
   3fc3c:	d10c      	bne.n	3fc58 <ull_readdiagnostics+0x38>
   3fc3e:	f013 0f04 	tst.w	r3, #4
   3fc42:	ab02      	add	r3, sp, #8
   3fc44:	9300      	str	r3, [sp, #0]
   3fc46:	bf14      	ite	ne
   3fc48:	2338      	movne	r3, #56	; 0x38
   3fc4a:	2320      	moveq	r3, #32
   3fc4c:	2200      	movs	r2, #0
   3fc4e:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3fc52:	f7ff ff58 	bl	3fb06 <dwt_readfromdevice>
   3fc56:	e019      	b.n	3fc8c <ull_readdiagnostics+0x6c>
   3fc58:	ab02      	add	r3, sp, #8
   3fc5a:	9300      	str	r3, [sp, #0]
   3fc5c:	23e8      	movs	r3, #232	; 0xe8
   3fc5e:	2200      	movs	r2, #0
   3fc60:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   3fc64:	f7ff ff4f 	bl	3fb06 <dwt_readfromdevice>
   3fc68:	e010      	b.n	3fc8c <ull_readdiagnostics+0x6c>
   3fc6a:	7d9b      	ldrb	r3, [r3, #22]
   3fc6c:	f013 0f08 	tst.w	r3, #8
   3fc70:	f040 81c9 	bne.w	40006 <ull_readdiagnostics+0x3e6>
   3fc74:	f013 0f04 	tst.w	r3, #4
   3fc78:	ab02      	add	r3, sp, #8
   3fc7a:	9300      	str	r3, [sp, #0]
   3fc7c:	bf14      	ite	ne
   3fc7e:	2338      	movne	r3, #56	; 0x38
   3fc80:	2320      	moveq	r3, #32
   3fc82:	2200      	movs	r2, #0
   3fc84:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   3fc88:	f7ff ff3d 	bl	3fb06 <dwt_readfromdevice>
   3fc8c:	f10d 0217 	add.w	r2, sp, #23
   3fc90:	f104 031a 	add.w	r3, r4, #26
   3fc94:	f104 0020 	add.w	r0, r4, #32
   3fc98:	f812 1f01 	ldrb.w	r1, [r2, #1]!
   3fc9c:	f803 1b01 	strb.w	r1, [r3], #1
   3fca0:	4283      	cmp	r3, r0
   3fca2:	d1f9      	bne.n	3fc98 <ull_readdiagnostics+0x78>
   3fca4:	f89d 2015 	ldrb.w	r2, [sp, #21]
   3fca8:	f89d 3014 	ldrb.w	r3, [sp, #20]
   3fcac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fcb0:	f3c3 030c 	ubfx	r3, r3, #0, #13
   3fcb4:	8463      	strh	r3, [r4, #34]	; 0x22
   3fcb6:	f89d 201f 	ldrb.w	r2, [sp, #31]
   3fcba:	f89d 301e 	ldrb.w	r3, [sp, #30]
   3fcbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fcc2:	f3c3 030d 	ubfx	r3, r3, #0, #14
   3fcc6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   3fcca:	bf1c      	itt	ne
   3fccc:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   3fcd0:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   3fcd4:	8423      	strh	r3, [r4, #32]
   3fcd6:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
   3fcda:	f89d 3024 	ldrb.w	r3, [sp, #36]	; 0x24
   3fcde:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fce2:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3fce6:	87e3      	strh	r3, [r4, #62]	; 0x3e
   3fce8:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3fcea:	7d9b      	ldrb	r3, [r3, #22]
   3fcec:	f013 0f02 	tst.w	r3, #2
   3fcf0:	f040 817e 	bne.w	3fff0 <ull_readdiagnostics+0x3d0>
   3fcf4:	aa0a      	add	r2, sp, #40	; 0x28
   3fcf6:	1e63      	subs	r3, r4, #1
   3fcf8:	1d20      	adds	r0, r4, #4
   3fcfa:	f812 1b01 	ldrb.w	r1, [r2], #1
   3fcfe:	f803 1f01 	strb.w	r1, [r3, #1]!
   3fd02:	79d1      	ldrb	r1, [r2, #7]
   3fd04:	7219      	strb	r1, [r3, #8]
   3fd06:	7bd1      	ldrb	r1, [r2, #15]
   3fd08:	7459      	strb	r1, [r3, #17]
   3fd0a:	4283      	cmp	r3, r0
   3fd0c:	d1f5      	bne.n	3fcfa <ull_readdiagnostics+0xda>
   3fd0e:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
   3fd12:	7163      	strb	r3, [r4, #5]
   3fd14:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
   3fd18:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
   3fd1c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fd20:	80e3      	strh	r3, [r4, #6]
   3fd22:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   3fd26:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   3fd2a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3fd2e:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3fd32:	f8a4 300d 	strh.w	r3, [r4, #13]
   3fd36:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
   3fd3a:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
   3fd3e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fd42:	f8a4 300f 	strh.w	r3, [r4, #15]
   3fd46:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   3fd4a:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   3fd4e:	eb03 2302 	add.w	r3, r3, r2, lsl #8
   3fd52:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   3fd56:	82e3      	strh	r3, [r4, #22]
   3fd58:	f89d 203a 	ldrb.w	r2, [sp, #58]	; 0x3a
   3fd5c:	f89d 3039 	ldrb.w	r3, [sp, #57]	; 0x39
   3fd60:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fd64:	8323      	strh	r3, [r4, #24]
   3fd66:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   3fd68:	7d9b      	ldrb	r3, [r3, #22]
   3fd6a:	f013 0f04 	tst.w	r3, #4
   3fd6e:	f040 813f 	bne.w	3fff0 <ull_readdiagnostics+0x3d0>
   3fd72:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   3fd76:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   3fd7a:	041b      	lsls	r3, r3, #16
   3fd7c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fd80:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   3fd84:	4313      	orrs	r3, r2
   3fd86:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   3fd8a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fd8e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   3fd92:	6263      	str	r3, [r4, #36]	; 0x24
   3fd94:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
   3fd98:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
   3fd9c:	041b      	lsls	r3, r3, #16
   3fd9e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fda2:	f89d 2044 	ldrb.w	r2, [sp, #68]	; 0x44
   3fda6:	4313      	orrs	r3, r2
   3fda8:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
   3fdac:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fdb0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   3fdb4:	62a3      	str	r3, [r4, #40]	; 0x28
   3fdb6:	f89d 204b 	ldrb.w	r2, [sp, #75]	; 0x4b
   3fdba:	f89d 304a 	ldrb.w	r3, [sp, #74]	; 0x4a
   3fdbe:	041b      	lsls	r3, r3, #16
   3fdc0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fdc4:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
   3fdc8:	4313      	orrs	r3, r2
   3fdca:	f89d 2049 	ldrb.w	r2, [sp, #73]	; 0x49
   3fdce:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fdd2:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3fdd6:	62e3      	str	r3, [r4, #44]	; 0x2c
   3fdd8:	f89d 204f 	ldrb.w	r2, [sp, #79]	; 0x4f
   3fddc:	f89d 304e 	ldrb.w	r3, [sp, #78]	; 0x4e
   3fde0:	041b      	lsls	r3, r3, #16
   3fde2:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fde6:	f89d 204c 	ldrb.w	r2, [sp, #76]	; 0x4c
   3fdea:	4313      	orrs	r3, r2
   3fdec:	f89d 204d 	ldrb.w	r2, [sp, #77]	; 0x4d
   3fdf0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fdf4:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3fdf8:	6323      	str	r3, [r4, #48]	; 0x30
   3fdfa:	f89d 2053 	ldrb.w	r2, [sp, #83]	; 0x53
   3fdfe:	f89d 3052 	ldrb.w	r3, [sp, #82]	; 0x52
   3fe02:	041b      	lsls	r3, r3, #16
   3fe04:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fe08:	f89d 2050 	ldrb.w	r2, [sp, #80]	; 0x50
   3fe0c:	4313      	orrs	r3, r2
   3fe0e:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   3fe12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fe16:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3fe1a:	6363      	str	r3, [r4, #52]	; 0x34
   3fe1c:	f89d 2057 	ldrb.w	r2, [sp, #87]	; 0x57
   3fe20:	f89d 3056 	ldrb.w	r3, [sp, #86]	; 0x56
   3fe24:	041b      	lsls	r3, r3, #16
   3fe26:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fe2a:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
   3fe2e:	4313      	orrs	r3, r2
   3fe30:	f89d 2055 	ldrb.w	r2, [sp, #85]	; 0x55
   3fe34:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fe38:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3fe3c:	63a3      	str	r3, [r4, #56]	; 0x38
   3fe3e:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   3fe42:	f89d 3064 	ldrb.w	r3, [sp, #100]	; 0x64
   3fe46:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fe4a:	87a3      	strh	r3, [r4, #60]	; 0x3c
   3fe4c:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   3fe50:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   3fe54:	041b      	lsls	r3, r3, #16
   3fe56:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fe5a:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   3fe5e:	4313      	orrs	r3, r2
   3fe60:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   3fe64:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fe68:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3fe6c:	6423      	str	r3, [r4, #64]	; 0x40
   3fe6e:	f89d 207b 	ldrb.w	r2, [sp, #123]	; 0x7b
   3fe72:	f89d 307a 	ldrb.w	r3, [sp, #122]	; 0x7a
   3fe76:	041b      	lsls	r3, r3, #16
   3fe78:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fe7c:	f89d 2078 	ldrb.w	r2, [sp, #120]	; 0x78
   3fe80:	4313      	orrs	r3, r2
   3fe82:	f89d 2079 	ldrb.w	r2, [sp, #121]	; 0x79
   3fe86:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fe8a:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3fe8e:	6463      	str	r3, [r4, #68]	; 0x44
   3fe90:	f89d 207f 	ldrb.w	r2, [sp, #127]	; 0x7f
   3fe94:	f89d 307e 	ldrb.w	r3, [sp, #126]	; 0x7e
   3fe98:	041b      	lsls	r3, r3, #16
   3fe9a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fe9e:	f89d 207c 	ldrb.w	r2, [sp, #124]	; 0x7c
   3fea2:	4313      	orrs	r3, r2
   3fea4:	f89d 207d 	ldrb.w	r2, [sp, #125]	; 0x7d
   3fea8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3feac:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3feb0:	64a3      	str	r3, [r4, #72]	; 0x48
   3feb2:	f89d 2083 	ldrb.w	r2, [sp, #131]	; 0x83
   3feb6:	f89d 3082 	ldrb.w	r3, [sp, #130]	; 0x82
   3feba:	041b      	lsls	r3, r3, #16
   3febc:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fec0:	f89d 2080 	ldrb.w	r2, [sp, #128]	; 0x80
   3fec4:	4313      	orrs	r3, r2
   3fec6:	f89d 2081 	ldrb.w	r2, [sp, #129]	; 0x81
   3feca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fece:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3fed2:	64e3      	str	r3, [r4, #76]	; 0x4c
   3fed4:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
   3fed8:	f89d 3086 	ldrb.w	r3, [sp, #134]	; 0x86
   3fedc:	041b      	lsls	r3, r3, #16
   3fede:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3fee2:	f89d 2084 	ldrb.w	r2, [sp, #132]	; 0x84
   3fee6:	4313      	orrs	r3, r2
   3fee8:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   3feec:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3fef0:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3fef4:	6523      	str	r3, [r4, #80]	; 0x50
   3fef6:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   3fefa:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   3fefe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ff02:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3ff06:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   3ff0a:	f89d 20a5 	ldrb.w	r2, [sp, #165]	; 0xa5
   3ff0e:	f89d 30a4 	ldrb.w	r3, [sp, #164]	; 0xa4
   3ff12:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ff16:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3ff1a:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   3ff1e:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   3ff22:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   3ff26:	041b      	lsls	r3, r3, #16
   3ff28:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ff2c:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   3ff30:	4313      	orrs	r3, r2
   3ff32:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   3ff36:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ff3a:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   3ff3e:	65a3      	str	r3, [r4, #88]	; 0x58
   3ff40:	f89d 20c3 	ldrb.w	r2, [sp, #195]	; 0xc3
   3ff44:	f89d 30c2 	ldrb.w	r3, [sp, #194]	; 0xc2
   3ff48:	041b      	lsls	r3, r3, #16
   3ff4a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ff4e:	f89d 20c0 	ldrb.w	r2, [sp, #192]	; 0xc0
   3ff52:	4313      	orrs	r3, r2
   3ff54:	f89d 20c1 	ldrb.w	r2, [sp, #193]	; 0xc1
   3ff58:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ff5c:	f3c3 0313 	ubfx	r3, r3, #0, #20
   3ff60:	65e3      	str	r3, [r4, #92]	; 0x5c
   3ff62:	f89d 20c7 	ldrb.w	r2, [sp, #199]	; 0xc7
   3ff66:	f89d 30c6 	ldrb.w	r3, [sp, #198]	; 0xc6
   3ff6a:	041b      	lsls	r3, r3, #16
   3ff6c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ff70:	f89d 20c4 	ldrb.w	r2, [sp, #196]	; 0xc4
   3ff74:	4313      	orrs	r3, r2
   3ff76:	f89d 20c5 	ldrb.w	r2, [sp, #197]	; 0xc5
   3ff7a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ff7e:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3ff82:	6623      	str	r3, [r4, #96]	; 0x60
   3ff84:	f89d 20cb 	ldrb.w	r2, [sp, #203]	; 0xcb
   3ff88:	f89d 30ca 	ldrb.w	r3, [sp, #202]	; 0xca
   3ff8c:	041b      	lsls	r3, r3, #16
   3ff8e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ff92:	f89d 20c8 	ldrb.w	r2, [sp, #200]	; 0xc8
   3ff96:	4313      	orrs	r3, r2
   3ff98:	f89d 20c9 	ldrb.w	r2, [sp, #201]	; 0xc9
   3ff9c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ffa0:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3ffa4:	6663      	str	r3, [r4, #100]	; 0x64
   3ffa6:	f89d 20cf 	ldrb.w	r2, [sp, #207]	; 0xcf
   3ffaa:	f89d 30ce 	ldrb.w	r3, [sp, #206]	; 0xce
   3ffae:	041b      	lsls	r3, r3, #16
   3ffb0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   3ffb4:	f89d 20cc 	ldrb.w	r2, [sp, #204]	; 0xcc
   3ffb8:	4313      	orrs	r3, r2
   3ffba:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   3ffbe:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ffc2:	f3c3 0315 	ubfx	r3, r3, #0, #22
   3ffc6:	66a3      	str	r3, [r4, #104]	; 0x68
   3ffc8:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   3ffcc:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   3ffd0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ffd4:	f3c3 030e 	ubfx	r3, r3, #0, #15
   3ffd8:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   3ffdc:	f89d 20ed 	ldrb.w	r2, [sp, #237]	; 0xed
   3ffe0:	f89d 30ec 	ldrb.w	r3, [sp, #236]	; 0xec
   3ffe4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   3ffe8:	f3c3 030b 	ubfx	r3, r3, #0, #12
   3ffec:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   3fff0:	f994 301b 	ldrsb.w	r3, [r4, #27]
   3fff4:	2b00      	cmp	r3, #0
   3fff6:	f2c0 81d0 	blt.w	4039a <ull_readdiagnostics+0x77a>
   3fffa:	7fe3      	ldrb	r3, [r4, #31]
   3fffc:	f003 0301 	and.w	r3, r3, #1
   40000:	77e3      	strb	r3, [r4, #31]
   40002:	b03d      	add	sp, #244	; 0xf4
   40004:	bd30      	pop	{r4, r5, pc}
   40006:	ab02      	add	r3, sp, #8
   40008:	9300      	str	r3, [sp, #0]
   4000a:	23e8      	movs	r3, #232	; 0xe8
   4000c:	2200      	movs	r2, #0
   4000e:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   40012:	f7ff fd78 	bl	3fb06 <dwt_readfromdevice>
   40016:	e639      	b.n	3fc8c <ull_readdiagnostics+0x6c>
   40018:	7d9b      	ldrb	r3, [r3, #22]
   4001a:	f013 0f01 	tst.w	r3, #1
   4001e:	f000 81b3 	beq.w	40388 <ull_readdiagnostics+0x768>
   40022:	ab02      	add	r3, sp, #8
   40024:	9300      	str	r3, [sp, #0]
   40026:	236c      	movs	r3, #108	; 0x6c
   40028:	2200      	movs	r2, #0
   4002a:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   4002e:	f7ff fd6a 	bl	3fb06 <dwt_readfromdevice>
   40032:	ab1d      	add	r3, sp, #116	; 0x74
   40034:	9300      	str	r3, [sp, #0]
   40036:	236c      	movs	r3, #108	; 0x6c
   40038:	2200      	movs	r2, #0
   4003a:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   4003e:	4628      	mov	r0, r5
   40040:	f7ff fd61 	bl	3fb06 <dwt_readfromdevice>
   40044:	aa02      	add	r2, sp, #8
   40046:	1e63      	subs	r3, r4, #1
   40048:	1d20      	adds	r0, r4, #4
   4004a:	f812 1b01 	ldrb.w	r1, [r2], #1
   4004e:	f803 1f01 	strb.w	r1, [r3, #1]!
   40052:	79d1      	ldrb	r1, [r2, #7]
   40054:	7219      	strb	r1, [r3, #8]
   40056:	7bd1      	ldrb	r1, [r2, #15]
   40058:	7459      	strb	r1, [r3, #17]
   4005a:	7dd1      	ldrb	r1, [r2, #23]
   4005c:	7699      	strb	r1, [r3, #26]
   4005e:	4283      	cmp	r3, r0
   40060:	d1f3      	bne.n	4004a <ull_readdiagnostics+0x42a>
   40062:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
   40066:	77e3      	strb	r3, [r4, #31]
   40068:	f89d 300f 	ldrb.w	r3, [sp, #15]
   4006c:	7163      	strb	r3, [r4, #5]
   4006e:	f89d 200e 	ldrb.w	r2, [sp, #14]
   40072:	f89d 300d 	ldrb.w	r3, [sp, #13]
   40076:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4007a:	80e3      	strh	r3, [r4, #6]
   4007c:	f89d 3016 	ldrb.w	r3, [sp, #22]
   40080:	f89d 2017 	ldrb.w	r2, [sp, #23]
   40084:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
   40088:	f3c2 12cf 	ubfx	r2, r2, #7, #16
   4008c:	f8a4 200d 	strh.w	r2, [r4, #13]
   40090:	f89d 2015 	ldrb.w	r2, [sp, #21]
   40094:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
   40098:	f8a4 200f 	strh.w	r2, [r4, #15]
   4009c:	f89d 201f 	ldrb.w	r2, [sp, #31]
   400a0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   400a4:	f3c3 13cf 	ubfx	r3, r3, #7, #16
   400a8:	82e3      	strh	r3, [r4, #22]
   400aa:	f89d 201e 	ldrb.w	r2, [sp, #30]
   400ae:	f89d 301d 	ldrb.w	r3, [sp, #29]
   400b2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   400b6:	8323      	strh	r3, [r4, #24]
   400b8:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
   400bc:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
   400c0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   400c4:	f3c3 030d 	ubfx	r3, r3, #0, #14
   400c8:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   400cc:	bf1c      	itt	ne
   400ce:	ea6f 4383 	mvnne.w	r3, r3, lsl #18
   400d2:	ea6f 4393 	mvnne.w	r3, r3, lsr #18
   400d6:	8423      	strh	r3, [r4, #32]
   400d8:	f89d 2029 	ldrb.w	r2, [sp, #41]	; 0x29
   400dc:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
   400e0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   400e4:	f3c3 030c 	ubfx	r3, r3, #0, #13
   400e8:	8463      	strh	r3, [r4, #34]	; 0x22
   400ea:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
   400ee:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
   400f2:	041b      	lsls	r3, r3, #16
   400f4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   400f8:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
   400fc:	4313      	orrs	r3, r2
   400fe:	f89d 202d 	ldrb.w	r2, [sp, #45]	; 0x2d
   40102:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40106:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   4010a:	6263      	str	r3, [r4, #36]	; 0x24
   4010c:	6d2b      	ldr	r3, [r5, #80]	; 0x50
   4010e:	7d9b      	ldrb	r3, [r3, #22]
   40110:	f013 0f01 	tst.w	r3, #1
   40114:	f43f af6c 	beq.w	3fff0 <ull_readdiagnostics+0x3d0>
   40118:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
   4011c:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
   40120:	041b      	lsls	r3, r3, #16
   40122:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40126:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
   4012a:	4313      	orrs	r3, r2
   4012c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
   40130:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40134:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
   40138:	62a3      	str	r3, [r4, #40]	; 0x28
   4013a:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
   4013e:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
   40142:	041b      	lsls	r3, r3, #16
   40144:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40148:	f89d 2034 	ldrb.w	r2, [sp, #52]	; 0x34
   4014c:	4313      	orrs	r3, r2
   4014e:	f89d 2035 	ldrb.w	r2, [sp, #53]	; 0x35
   40152:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40156:	f3c3 0313 	ubfx	r3, r3, #0, #20
   4015a:	62e3      	str	r3, [r4, #44]	; 0x2c
   4015c:	f89d 203b 	ldrb.w	r2, [sp, #59]	; 0x3b
   40160:	f89d 303a 	ldrb.w	r3, [sp, #58]	; 0x3a
   40164:	041b      	lsls	r3, r3, #16
   40166:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   4016a:	f89d 2038 	ldrb.w	r2, [sp, #56]	; 0x38
   4016e:	4313      	orrs	r3, r2
   40170:	f89d 2039 	ldrb.w	r2, [sp, #57]	; 0x39
   40174:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40178:	f3c3 0315 	ubfx	r3, r3, #0, #22
   4017c:	6323      	str	r3, [r4, #48]	; 0x30
   4017e:	f89d 203f 	ldrb.w	r2, [sp, #63]	; 0x3f
   40182:	f89d 303e 	ldrb.w	r3, [sp, #62]	; 0x3e
   40186:	041b      	lsls	r3, r3, #16
   40188:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   4018c:	f89d 203c 	ldrb.w	r2, [sp, #60]	; 0x3c
   40190:	4313      	orrs	r3, r2
   40192:	f89d 203d 	ldrb.w	r2, [sp, #61]	; 0x3d
   40196:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4019a:	f3c3 0315 	ubfx	r3, r3, #0, #22
   4019e:	6363      	str	r3, [r4, #52]	; 0x34
   401a0:	f89d 2043 	ldrb.w	r2, [sp, #67]	; 0x43
   401a4:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
   401a8:	041b      	lsls	r3, r3, #16
   401aa:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   401ae:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
   401b2:	4313      	orrs	r3, r2
   401b4:	f89d 2041 	ldrb.w	r2, [sp, #65]	; 0x41
   401b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   401bc:	f3c3 0315 	ubfx	r3, r3, #0, #22
   401c0:	63a3      	str	r3, [r4, #56]	; 0x38
   401c2:	f89d 2051 	ldrb.w	r2, [sp, #81]	; 0x51
   401c6:	f89d 3050 	ldrb.w	r3, [sp, #80]	; 0x50
   401ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   401ce:	87a3      	strh	r3, [r4, #60]	; 0x3c
   401d0:	f89d 2061 	ldrb.w	r2, [sp, #97]	; 0x61
   401d4:	f89d 3060 	ldrb.w	r3, [sp, #96]	; 0x60
   401d8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   401dc:	f3c3 030b 	ubfx	r3, r3, #0, #12
   401e0:	87e3      	strh	r3, [r4, #62]	; 0x3e
   401e2:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
   401e6:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
   401ea:	041b      	lsls	r3, r3, #16
   401ec:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   401f0:	f89d 2064 	ldrb.w	r2, [sp, #100]	; 0x64
   401f4:	4313      	orrs	r3, r2
   401f6:	f89d 2065 	ldrb.w	r2, [sp, #101]	; 0x65
   401fa:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   401fe:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   40202:	6423      	str	r3, [r4, #64]	; 0x40
   40204:	f89d 206b 	ldrb.w	r2, [sp, #107]	; 0x6b
   40208:	f89d 306a 	ldrb.w	r3, [sp, #106]	; 0x6a
   4020c:	041b      	lsls	r3, r3, #16
   4020e:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40212:	f89d 2068 	ldrb.w	r2, [sp, #104]	; 0x68
   40216:	4313      	orrs	r3, r2
   40218:	f89d 2069 	ldrb.w	r2, [sp, #105]	; 0x69
   4021c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40220:	f3c3 0313 	ubfx	r3, r3, #0, #20
   40224:	6463      	str	r3, [r4, #68]	; 0x44
   40226:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
   4022a:	f89d 306e 	ldrb.w	r3, [sp, #110]	; 0x6e
   4022e:	041b      	lsls	r3, r3, #16
   40230:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40234:	f89d 206c 	ldrb.w	r2, [sp, #108]	; 0x6c
   40238:	4313      	orrs	r3, r2
   4023a:	f89d 206d 	ldrb.w	r2, [sp, #109]	; 0x6d
   4023e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40242:	f3c3 0315 	ubfx	r3, r3, #0, #22
   40246:	64a3      	str	r3, [r4, #72]	; 0x48
   40248:	f89d 2073 	ldrb.w	r2, [sp, #115]	; 0x73
   4024c:	f89d 3072 	ldrb.w	r3, [sp, #114]	; 0x72
   40250:	041b      	lsls	r3, r3, #16
   40252:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40256:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70
   4025a:	4313      	orrs	r3, r2
   4025c:	f89d 2071 	ldrb.w	r2, [sp, #113]	; 0x71
   40260:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40264:	f3c3 0315 	ubfx	r3, r3, #0, #22
   40268:	64e3      	str	r3, [r4, #76]	; 0x4c
   4026a:	f89d 2077 	ldrb.w	r2, [sp, #119]	; 0x77
   4026e:	f89d 3076 	ldrb.w	r3, [sp, #118]	; 0x76
   40272:	041b      	lsls	r3, r3, #16
   40274:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40278:	f89d 2074 	ldrb.w	r2, [sp, #116]	; 0x74
   4027c:	4313      	orrs	r3, r2
   4027e:	f89d 2075 	ldrb.w	r2, [sp, #117]	; 0x75
   40282:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40286:	f3c3 0315 	ubfx	r3, r3, #0, #22
   4028a:	6523      	str	r3, [r4, #80]	; 0x50
   4028c:	f89d 2085 	ldrb.w	r2, [sp, #133]	; 0x85
   40290:	f89d 3084 	ldrb.w	r3, [sp, #132]	; 0x84
   40294:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40298:	f3c3 030e 	ubfx	r3, r3, #0, #15
   4029c:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
   402a0:	f89d 2095 	ldrb.w	r2, [sp, #149]	; 0x95
   402a4:	f89d 3094 	ldrb.w	r3, [sp, #148]	; 0x94
   402a8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   402ac:	f3c3 030b 	ubfx	r3, r3, #0, #12
   402b0:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
   402b4:	f89d 20af 	ldrb.w	r2, [sp, #175]	; 0xaf
   402b8:	f89d 30ae 	ldrb.w	r3, [sp, #174]	; 0xae
   402bc:	041b      	lsls	r3, r3, #16
   402be:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   402c2:	f89d 20ac 	ldrb.w	r2, [sp, #172]	; 0xac
   402c6:	4313      	orrs	r3, r2
   402c8:	f89d 20ad 	ldrb.w	r2, [sp, #173]	; 0xad
   402cc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   402d0:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
   402d4:	65a3      	str	r3, [r4, #88]	; 0x58
   402d6:	f89d 20b3 	ldrb.w	r2, [sp, #179]	; 0xb3
   402da:	f89d 30b2 	ldrb.w	r3, [sp, #178]	; 0xb2
   402de:	041b      	lsls	r3, r3, #16
   402e0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   402e4:	f89d 20b0 	ldrb.w	r2, [sp, #176]	; 0xb0
   402e8:	4313      	orrs	r3, r2
   402ea:	f89d 20b1 	ldrb.w	r2, [sp, #177]	; 0xb1
   402ee:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   402f2:	f3c3 0313 	ubfx	r3, r3, #0, #20
   402f6:	65e3      	str	r3, [r4, #92]	; 0x5c
   402f8:	f89d 20b7 	ldrb.w	r2, [sp, #183]	; 0xb7
   402fc:	f89d 30b6 	ldrb.w	r3, [sp, #182]	; 0xb6
   40300:	041b      	lsls	r3, r3, #16
   40302:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40306:	f89d 20b4 	ldrb.w	r2, [sp, #180]	; 0xb4
   4030a:	4313      	orrs	r3, r2
   4030c:	f89d 20b5 	ldrb.w	r2, [sp, #181]	; 0xb5
   40310:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40314:	f3c3 0315 	ubfx	r3, r3, #0, #22
   40318:	6623      	str	r3, [r4, #96]	; 0x60
   4031a:	f89d 20bb 	ldrb.w	r2, [sp, #187]	; 0xbb
   4031e:	f89d 30ba 	ldrb.w	r3, [sp, #186]	; 0xba
   40322:	041b      	lsls	r3, r3, #16
   40324:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   40328:	f89d 20b8 	ldrb.w	r2, [sp, #184]	; 0xb8
   4032c:	4313      	orrs	r3, r2
   4032e:	f89d 20b9 	ldrb.w	r2, [sp, #185]	; 0xb9
   40332:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40336:	f3c3 0315 	ubfx	r3, r3, #0, #22
   4033a:	6663      	str	r3, [r4, #100]	; 0x64
   4033c:	f89d 20bf 	ldrb.w	r2, [sp, #191]	; 0xbf
   40340:	f89d 30be 	ldrb.w	r3, [sp, #190]	; 0xbe
   40344:	041b      	lsls	r3, r3, #16
   40346:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
   4034a:	f89d 20bc 	ldrb.w	r2, [sp, #188]	; 0xbc
   4034e:	4313      	orrs	r3, r2
   40350:	f89d 20bd 	ldrb.w	r2, [sp, #189]	; 0xbd
   40354:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   40358:	f3c3 0315 	ubfx	r3, r3, #0, #22
   4035c:	66a3      	str	r3, [r4, #104]	; 0x68
   4035e:	f89d 20cd 	ldrb.w	r2, [sp, #205]	; 0xcd
   40362:	f89d 30cc 	ldrb.w	r3, [sp, #204]	; 0xcc
   40366:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4036a:	f3c3 030e 	ubfx	r3, r3, #0, #15
   4036e:	f8a4 306c 	strh.w	r3, [r4, #108]	; 0x6c
   40372:	f89d 20dd 	ldrb.w	r2, [sp, #221]	; 0xdd
   40376:	f89d 30dc 	ldrb.w	r3, [sp, #220]	; 0xdc
   4037a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   4037e:	f3c3 030b 	ubfx	r3, r3, #0, #12
   40382:	f8a4 306e 	strh.w	r3, [r4, #110]	; 0x6e
   40386:	e633      	b.n	3fff0 <ull_readdiagnostics+0x3d0>
   40388:	ab02      	add	r3, sp, #8
   4038a:	9300      	str	r3, [sp, #0]
   4038c:	2328      	movs	r3, #40	; 0x28
   4038e:	2200      	movs	r2, #0
   40390:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   40394:	f7ff fbb7 	bl	3fb06 <dwt_readfromdevice>
   40398:	e654      	b.n	40044 <ull_readdiagnostics+0x424>
   4039a:	23ff      	movs	r3, #255	; 0xff
   4039c:	7723      	strb	r3, [r4, #28]
   4039e:	7763      	strb	r3, [r4, #29]
   403a0:	77a3      	strb	r3, [r4, #30]
   403a2:	77e3      	strb	r3, [r4, #31]
   403a4:	e629      	b.n	3fffa <ull_readdiagnostics+0x3da>
	...

000403a8 <ull_readrxtimestamp>:
   403a8:	b500      	push	{lr}
   403aa:	b083      	sub	sp, #12
   403ac:	6d03      	ldr	r3, [r0, #80]	; 0x50
   403ae:	7b9b      	ldrb	r3, [r3, #14]
   403b0:	2b01      	cmp	r3, #1
   403b2:	d00b      	beq.n	403cc <ull_readrxtimestamp+0x24>
   403b4:	2b03      	cmp	r3, #3
   403b6:	d110      	bne.n	403da <ull_readrxtimestamp+0x32>
   403b8:	9100      	str	r1, [sp, #0]
   403ba:	2305      	movs	r3, #5
   403bc:	2204      	movs	r2, #4
   403be:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   403c2:	f7ff fba0 	bl	3fb06 <dwt_readfromdevice>
   403c6:	b003      	add	sp, #12
   403c8:	f85d fb04 	ldr.w	pc, [sp], #4
   403cc:	9100      	str	r1, [sp, #0]
   403ce:	2305      	movs	r3, #5
   403d0:	2200      	movs	r2, #0
   403d2:	4905      	ldr	r1, [pc, #20]	; (403e8 <ull_readrxtimestamp+0x40>)
   403d4:	f7ff fb97 	bl	3fb06 <dwt_readfromdevice>
   403d8:	e7f5      	b.n	403c6 <ull_readrxtimestamp+0x1e>
   403da:	9100      	str	r1, [sp, #0]
   403dc:	2305      	movs	r3, #5
   403de:	2200      	movs	r2, #0
   403e0:	2160      	movs	r1, #96	; 0x60
   403e2:	f7ff fb90 	bl	3fb06 <dwt_readfromdevice>
   403e6:	e7ee      	b.n	403c6 <ull_readrxtimestamp+0x1e>
   403e8:	00180004 	.word	0x00180004

000403ec <dwt_writetodevice>:
   403ec:	b510      	push	{r4, lr}
   403ee:	b082      	sub	sp, #8
   403f0:	f44f 4400 	mov.w	r4, #32768	; 0x8000
   403f4:	9401      	str	r4, [sp, #4]
   403f6:	9c04      	ldr	r4, [sp, #16]
   403f8:	9400      	str	r4, [sp, #0]
   403fa:	f7ff fb06 	bl	3fa0a <dwt_xfer3xxx>
   403fe:	b002      	add	sp, #8
   40400:	bd10      	pop	{r4, pc}

00040402 <dwt_write16bitoffsetreg>:
   40402:	b500      	push	{lr}
   40404:	b085      	sub	sp, #20
   40406:	f88d 300c 	strb.w	r3, [sp, #12]
   4040a:	0a1b      	lsrs	r3, r3, #8
   4040c:	f88d 300d 	strb.w	r3, [sp, #13]
   40410:	ab03      	add	r3, sp, #12
   40412:	9300      	str	r3, [sp, #0]
   40414:	2302      	movs	r3, #2
   40416:	b292      	uxth	r2, r2
   40418:	f7ff ffe8 	bl	403ec <dwt_writetodevice>
   4041c:	b005      	add	sp, #20
   4041e:	f85d fb04 	ldr.w	pc, [sp], #4

00040422 <ull_setrxantennadelay>:
   40422:	b508      	push	{r3, lr}
   40424:	460b      	mov	r3, r1
   40426:	2200      	movs	r2, #0
   40428:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   4042c:	f7ff ffe9 	bl	40402 <dwt_write16bitoffsetreg>
   40430:	bd08      	pop	{r3, pc}

00040432 <ull_settxantennadelay>:
   40432:	b508      	push	{r3, lr}
   40434:	460b      	mov	r3, r1
   40436:	2200      	movs	r2, #0
   40438:	217c      	movs	r1, #124	; 0x7c
   4043a:	f7ff ffe2 	bl	40402 <dwt_write16bitoffsetreg>
   4043e:	bd08      	pop	{r3, pc}

00040440 <ull_force_clocks>:
   40440:	b508      	push	{r3, lr}
   40442:	2901      	cmp	r1, #1
   40444:	d002      	beq.n	4044c <ull_force_clocks+0xc>
   40446:	2905      	cmp	r1, #5
   40448:	d007      	beq.n	4045a <ull_force_clocks+0x1a>
   4044a:	bd08      	pop	{r3, pc}
   4044c:	f641 0322 	movw	r3, #6178	; 0x1822
   40450:	2200      	movs	r2, #0
   40452:	4905      	ldr	r1, [pc, #20]	; (40468 <ull_force_clocks+0x28>)
   40454:	f7ff ffd5 	bl	40402 <dwt_write16bitoffsetreg>
   40458:	e7f7      	b.n	4044a <ull_force_clocks+0xa>
   4045a:	f44f 7300 	mov.w	r3, #512	; 0x200
   4045e:	2200      	movs	r2, #0
   40460:	4901      	ldr	r1, [pc, #4]	; (40468 <ull_force_clocks+0x28>)
   40462:	f7ff ffce 	bl	40402 <dwt_write16bitoffsetreg>
   40466:	e7f0      	b.n	4044a <ull_force_clocks+0xa>
   40468:	00110004 	.word	0x00110004

0004046c <__dwt_otp_write_wdata_id_reg>:
   4046c:	b538      	push	{r3, r4, r5, lr}
   4046e:	4605      	mov	r5, r0
   40470:	460c      	mov	r4, r1
   40472:	f441 7300 	orr.w	r3, r1, #512	; 0x200
   40476:	b29b      	uxth	r3, r3
   40478:	2200      	movs	r2, #0
   4047a:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   4047e:	f7ff ffc0 	bl	40402 <dwt_write16bitoffsetreg>
   40482:	b2a3      	uxth	r3, r4
   40484:	2200      	movs	r2, #0
   40486:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   4048a:	4628      	mov	r0, r5
   4048c:	f7ff ffb9 	bl	40402 <dwt_write16bitoffsetreg>
   40490:	bd38      	pop	{r3, r4, r5, pc}
	...

00040494 <_dwt_otpread>:
   40494:	b570      	push	{r4, r5, r6, lr}
   40496:	4604      	mov	r4, r0
   40498:	460e      	mov	r6, r1
   4049a:	4d0c      	ldr	r5, [pc, #48]	; (404cc <_dwt_otpread+0x38>)
   4049c:	2301      	movs	r3, #1
   4049e:	2200      	movs	r2, #0
   404a0:	4629      	mov	r1, r5
   404a2:	f7ff ffae 	bl	40402 <dwt_write16bitoffsetreg>
   404a6:	4633      	mov	r3, r6
   404a8:	2200      	movs	r2, #0
   404aa:	4909      	ldr	r1, [pc, #36]	; (404d0 <_dwt_otpread+0x3c>)
   404ac:	4620      	mov	r0, r4
   404ae:	f7ff ffa8 	bl	40402 <dwt_write16bitoffsetreg>
   404b2:	2302      	movs	r3, #2
   404b4:	2200      	movs	r2, #0
   404b6:	4629      	mov	r1, r5
   404b8:	4620      	mov	r0, r4
   404ba:	f7ff ffa2 	bl	40402 <dwt_write16bitoffsetreg>
   404be:	2200      	movs	r2, #0
   404c0:	4904      	ldr	r1, [pc, #16]	; (404d4 <_dwt_otpread+0x40>)
   404c2:	4620      	mov	r0, r4
   404c4:	f7ff fb29 	bl	3fb1a <dwt_read32bitoffsetreg>
   404c8:	bd70      	pop	{r4, r5, r6, pc}
   404ca:	bf00      	nop
   404cc:	000b0008 	.word	0x000b0008
   404d0:	000b0004 	.word	0x000b0004
   404d4:	000b0010 	.word	0x000b0010

000404d8 <dwt_write32bitoffsetreg>:
   404d8:	b510      	push	{r4, lr}
   404da:	b084      	sub	sp, #16
   404dc:	f88d 300c 	strb.w	r3, [sp, #12]
   404e0:	0a1c      	lsrs	r4, r3, #8
   404e2:	f88d 400d 	strb.w	r4, [sp, #13]
   404e6:	0c1c      	lsrs	r4, r3, #16
   404e8:	f88d 400e 	strb.w	r4, [sp, #14]
   404ec:	0e1b      	lsrs	r3, r3, #24
   404ee:	f88d 300f 	strb.w	r3, [sp, #15]
   404f2:	ab03      	add	r3, sp, #12
   404f4:	9300      	str	r3, [sp, #0]
   404f6:	2304      	movs	r3, #4
   404f8:	b292      	uxth	r2, r2
   404fa:	f7ff ff77 	bl	403ec <dwt_writetodevice>
   404fe:	b004      	add	sp, #16
   40500:	bd10      	pop	{r4, pc}

00040502 <_dwt_adjust_delaytime>:
   40502:	b538      	push	{r3, r4, r5, lr}
   40504:	4604      	mov	r4, r0
   40506:	b989      	cbnz	r1, 4052c <_dwt_adjust_delaytime+0x2a>
   40508:	2200      	movs	r2, #0
   4050a:	2128      	movs	r1, #40	; 0x28
   4050c:	f7ff fb05 	bl	3fb1a <dwt_read32bitoffsetreg>
   40510:	4605      	mov	r5, r0
   40512:	2201      	movs	r2, #1
   40514:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   40518:	4620      	mov	r0, r4
   4051a:	f7ff fb53 	bl	3fbc4 <dwt_read8bitoffsetreg>
   4051e:	1a2b      	subs	r3, r5, r0
   40520:	2200      	movs	r2, #0
   40522:	2128      	movs	r1, #40	; 0x28
   40524:	4620      	mov	r0, r4
   40526:	f7ff ffd7 	bl	404d8 <dwt_write32bitoffsetreg>
   4052a:	bd38      	pop	{r3, r4, r5, pc}
   4052c:	2200      	movs	r2, #0
   4052e:	2128      	movs	r1, #40	; 0x28
   40530:	f7ff faf3 	bl	3fb1a <dwt_read32bitoffsetreg>
   40534:	4605      	mov	r5, r0
   40536:	2201      	movs	r2, #1
   40538:	217c      	movs	r1, #124	; 0x7c
   4053a:	4620      	mov	r0, r4
   4053c:	f7ff fb42 	bl	3fbc4 <dwt_read8bitoffsetreg>
   40540:	1a2b      	subs	r3, r5, r0
   40542:	2200      	movs	r2, #0
   40544:	2128      	movs	r1, #40	; 0x28
   40546:	4620      	mov	r0, r4
   40548:	f7ff ffc6 	bl	404d8 <dwt_write32bitoffsetreg>
   4054c:	e7ed      	b.n	4052a <_dwt_adjust_delaytime+0x28>

0004054e <ull_setrxaftertxdelay>:
   4054e:	b538      	push	{r3, r4, r5, lr}
   40550:	4605      	mov	r5, r0
   40552:	460c      	mov	r4, r1
   40554:	2200      	movs	r2, #0
   40556:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   4055a:	f7ff fade 	bl	3fb1a <dwt_read32bitoffsetreg>
   4055e:	0d00      	lsrs	r0, r0, #20
   40560:	0500      	lsls	r0, r0, #20
   40562:	f3c4 0313 	ubfx	r3, r4, #0, #20
   40566:	4303      	orrs	r3, r0
   40568:	2200      	movs	r2, #0
   4056a:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   4056e:	4628      	mov	r0, r5
   40570:	f7ff ffb2 	bl	404d8 <dwt_write32bitoffsetreg>
   40574:	bd38      	pop	{r3, r4, r5, pc}
	...

00040578 <ull_setfinegraintxseq>:
   40578:	b508      	push	{r3, lr}
   4057a:	b929      	cbnz	r1, 40588 <ull_setfinegraintxseq+0x10>
   4057c:	4b05      	ldr	r3, [pc, #20]	; (40594 <ull_setfinegraintxseq+0x1c>)
   4057e:	2202      	movs	r2, #2
   40580:	4905      	ldr	r1, [pc, #20]	; (40598 <ull_setfinegraintxseq+0x20>)
   40582:	f7ff ffa9 	bl	404d8 <dwt_write32bitoffsetreg>
   40586:	bd08      	pop	{r3, pc}
   40588:	4b04      	ldr	r3, [pc, #16]	; (4059c <ull_setfinegraintxseq+0x24>)
   4058a:	2202      	movs	r2, #2
   4058c:	4902      	ldr	r1, [pc, #8]	; (40598 <ull_setfinegraintxseq+0x20>)
   4058e:	f7ff ffa3 	bl	404d8 <dwt_write32bitoffsetreg>
   40592:	e7f8      	b.n	40586 <ull_setfinegraintxseq+0xe>
   40594:	00d20874 	.word	0x00d20874
   40598:	00110010 	.word	0x00110010
   4059c:	04d28874 	.word	0x04d28874

000405a0 <ull_setlnapamode>:
   405a0:	b538      	push	{r3, r4, r5, lr}
   405a2:	4605      	mov	r5, r0
   405a4:	460c      	mov	r4, r1
   405a6:	2200      	movs	r2, #0
   405a8:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   405ac:	f7ff fab5 	bl	3fb1a <dwt_read32bitoffsetreg>
   405b0:	f420 337c 	bic.w	r3, r0, #258048	; 0x3f000
   405b4:	f014 0f01 	tst.w	r4, #1
   405b8:	bf18      	it	ne
   405ba:	f443 3380 	orrne.w	r3, r3, #65536	; 0x10000
   405be:	f014 0f02 	tst.w	r4, #2
   405c2:	bf18      	it	ne
   405c4:	f443 5300 	orrne.w	r3, r3, #8192	; 0x2000
   405c8:	f014 0f04 	tst.w	r4, #4
   405cc:	bf18      	it	ne
   405ce:	f443 3390 	orrne.w	r3, r3, #73728	; 0x12000
   405d2:	2200      	movs	r2, #0
   405d4:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   405d8:	4628      	mov	r0, r5
   405da:	f7ff ff7d 	bl	404d8 <dwt_write32bitoffsetreg>
   405de:	bd38      	pop	{r3, r4, r5, pc}

000405e0 <ull_configurestskey>:
   405e0:	b538      	push	{r3, r4, r5, lr}
   405e2:	4605      	mov	r5, r0
   405e4:	460c      	mov	r4, r1
   405e6:	680b      	ldr	r3, [r1, #0]
   405e8:	2200      	movs	r2, #0
   405ea:	490b      	ldr	r1, [pc, #44]	; (40618 <ull_configurestskey+0x38>)
   405ec:	f7ff ff74 	bl	404d8 <dwt_write32bitoffsetreg>
   405f0:	6863      	ldr	r3, [r4, #4]
   405f2:	2200      	movs	r2, #0
   405f4:	4909      	ldr	r1, [pc, #36]	; (4061c <ull_configurestskey+0x3c>)
   405f6:	4628      	mov	r0, r5
   405f8:	f7ff ff6e 	bl	404d8 <dwt_write32bitoffsetreg>
   405fc:	68a3      	ldr	r3, [r4, #8]
   405fe:	2200      	movs	r2, #0
   40600:	4907      	ldr	r1, [pc, #28]	; (40620 <ull_configurestskey+0x40>)
   40602:	4628      	mov	r0, r5
   40604:	f7ff ff68 	bl	404d8 <dwt_write32bitoffsetreg>
   40608:	68e3      	ldr	r3, [r4, #12]
   4060a:	2200      	movs	r2, #0
   4060c:	4905      	ldr	r1, [pc, #20]	; (40624 <ull_configurestskey+0x44>)
   4060e:	4628      	mov	r0, r5
   40610:	f7ff ff62 	bl	404d8 <dwt_write32bitoffsetreg>
   40614:	bd38      	pop	{r3, r4, r5, pc}
   40616:	bf00      	nop
   40618:	0002000c 	.word	0x0002000c
   4061c:	00020010 	.word	0x00020010
   40620:	00020014 	.word	0x00020014
   40624:	00020018 	.word	0x00020018

00040628 <ull_configurestsiv>:
   40628:	b538      	push	{r3, r4, r5, lr}
   4062a:	4605      	mov	r5, r0
   4062c:	460c      	mov	r4, r1
   4062e:	680b      	ldr	r3, [r1, #0]
   40630:	2200      	movs	r2, #0
   40632:	490b      	ldr	r1, [pc, #44]	; (40660 <ull_configurestsiv+0x38>)
   40634:	f7ff ff50 	bl	404d8 <dwt_write32bitoffsetreg>
   40638:	6863      	ldr	r3, [r4, #4]
   4063a:	2200      	movs	r2, #0
   4063c:	4909      	ldr	r1, [pc, #36]	; (40664 <ull_configurestsiv+0x3c>)
   4063e:	4628      	mov	r0, r5
   40640:	f7ff ff4a 	bl	404d8 <dwt_write32bitoffsetreg>
   40644:	68a3      	ldr	r3, [r4, #8]
   40646:	2200      	movs	r2, #0
   40648:	4907      	ldr	r1, [pc, #28]	; (40668 <ull_configurestsiv+0x40>)
   4064a:	4628      	mov	r0, r5
   4064c:	f7ff ff44 	bl	404d8 <dwt_write32bitoffsetreg>
   40650:	68e3      	ldr	r3, [r4, #12]
   40652:	2200      	movs	r2, #0
   40654:	4905      	ldr	r1, [pc, #20]	; (4066c <ull_configurestsiv+0x44>)
   40656:	4628      	mov	r0, r5
   40658:	f7ff ff3e 	bl	404d8 <dwt_write32bitoffsetreg>
   4065c:	bd38      	pop	{r3, r4, r5, pc}
   4065e:	bf00      	nop
   40660:	0002001c 	.word	0x0002001c
   40664:	00020020 	.word	0x00020020
   40668:	00020024 	.word	0x00020024
   4066c:	00020028 	.word	0x00020028

00040670 <ull_configmrxlut>:
   40670:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   40674:	4604      	mov	r4, r0
   40676:	4d35      	ldr	r5, [pc, #212]	; (4074c <ull_configmrxlut+0xdc>)
   40678:	4b35      	ldr	r3, [pc, #212]	; (40750 <ull_configmrxlut+0xe0>)
   4067a:	2905      	cmp	r1, #5
   4067c:	bf18      	it	ne
   4067e:	461d      	movne	r5, r3
   40680:	4e34      	ldr	r6, [pc, #208]	; (40754 <ull_configmrxlut+0xe4>)
   40682:	f5a3 7302 	sub.w	r3, r3, #520	; 0x208
   40686:	2905      	cmp	r1, #5
   40688:	bf18      	it	ne
   4068a:	461e      	movne	r6, r3
   4068c:	4f32      	ldr	r7, [pc, #200]	; (40758 <ull_configmrxlut+0xe8>)
   4068e:	f503 73a0 	add.w	r3, r3, #320	; 0x140
   40692:	2905      	cmp	r1, #5
   40694:	bf18      	it	ne
   40696:	461f      	movne	r7, r3
   40698:	4a30      	ldr	r2, [pc, #192]	; (4075c <ull_configmrxlut+0xec>)
   4069a:	f5a3 7380 	sub.w	r3, r3, #256	; 0x100
   4069e:	2905      	cmp	r1, #5
   406a0:	bf0c      	ite	eq
   406a2:	4690      	moveq	r8, r2
   406a4:	4698      	movne	r8, r3
   406a6:	f502 6210 	add.w	r2, r2, #2304	; 0x900
   406aa:	f5a3 5388 	sub.w	r3, r3, #4352	; 0x1100
   406ae:	2905      	cmp	r1, #5
   406b0:	bf0c      	ite	eq
   406b2:	4691      	moveq	r9, r2
   406b4:	4699      	movne	r9, r3
   406b6:	4a2a      	ldr	r2, [pc, #168]	; (40760 <ull_configmrxlut+0xf0>)
   406b8:	f5a3 63af 	sub.w	r3, r3, #1400	; 0x578
   406bc:	2905      	cmp	r1, #5
   406be:	bf0c      	ite	eq
   406c0:	4692      	moveq	sl, r2
   406c2:	469a      	movne	sl, r3
   406c4:	4b27      	ldr	r3, [pc, #156]	; (40764 <ull_configmrxlut+0xf4>)
   406c6:	4a28      	ldr	r2, [pc, #160]	; (40768 <ull_configmrxlut+0xf8>)
   406c8:	2905      	cmp	r1, #5
   406ca:	bf0c      	ite	eq
   406cc:	469b      	moveq	fp, r3
   406ce:	4693      	movne	fp, r2
   406d0:	f44f 7310 	mov.w	r3, #576	; 0x240
   406d4:	2200      	movs	r2, #0
   406d6:	4925      	ldr	r1, [pc, #148]	; (4076c <ull_configmrxlut+0xfc>)
   406d8:	f7ff fefe 	bl	404d8 <dwt_write32bitoffsetreg>
   406dc:	4b24      	ldr	r3, [pc, #144]	; (40770 <ull_configmrxlut+0x100>)
   406de:	2200      	movs	r2, #0
   406e0:	4924      	ldr	r1, [pc, #144]	; (40774 <ull_configmrxlut+0x104>)
   406e2:	4620      	mov	r0, r4
   406e4:	f7ff fef8 	bl	404d8 <dwt_write32bitoffsetreg>
   406e8:	4b23      	ldr	r3, [pc, #140]	; (40778 <ull_configmrxlut+0x108>)
   406ea:	2200      	movs	r2, #0
   406ec:	4923      	ldr	r1, [pc, #140]	; (4077c <ull_configmrxlut+0x10c>)
   406ee:	4620      	mov	r0, r4
   406f0:	f7ff fef2 	bl	404d8 <dwt_write32bitoffsetreg>
   406f4:	465b      	mov	r3, fp
   406f6:	2200      	movs	r2, #0
   406f8:	4921      	ldr	r1, [pc, #132]	; (40780 <ull_configmrxlut+0x110>)
   406fa:	4620      	mov	r0, r4
   406fc:	f7ff feec 	bl	404d8 <dwt_write32bitoffsetreg>
   40700:	4653      	mov	r3, sl
   40702:	2200      	movs	r2, #0
   40704:	491f      	ldr	r1, [pc, #124]	; (40784 <ull_configmrxlut+0x114>)
   40706:	4620      	mov	r0, r4
   40708:	f7ff fee6 	bl	404d8 <dwt_write32bitoffsetreg>
   4070c:	464b      	mov	r3, r9
   4070e:	2200      	movs	r2, #0
   40710:	491d      	ldr	r1, [pc, #116]	; (40788 <ull_configmrxlut+0x118>)
   40712:	4620      	mov	r0, r4
   40714:	f7ff fee0 	bl	404d8 <dwt_write32bitoffsetreg>
   40718:	4643      	mov	r3, r8
   4071a:	2200      	movs	r2, #0
   4071c:	491b      	ldr	r1, [pc, #108]	; (4078c <ull_configmrxlut+0x11c>)
   4071e:	4620      	mov	r0, r4
   40720:	f7ff feda 	bl	404d8 <dwt_write32bitoffsetreg>
   40724:	463b      	mov	r3, r7
   40726:	2200      	movs	r2, #0
   40728:	4919      	ldr	r1, [pc, #100]	; (40790 <ull_configmrxlut+0x120>)
   4072a:	4620      	mov	r0, r4
   4072c:	f7ff fed4 	bl	404d8 <dwt_write32bitoffsetreg>
   40730:	4633      	mov	r3, r6
   40732:	2200      	movs	r2, #0
   40734:	4917      	ldr	r1, [pc, #92]	; (40794 <ull_configmrxlut+0x124>)
   40736:	4620      	mov	r0, r4
   40738:	f7ff fece 	bl	404d8 <dwt_write32bitoffsetreg>
   4073c:	462b      	mov	r3, r5
   4073e:	2200      	movs	r2, #0
   40740:	4915      	ldr	r1, [pc, #84]	; (40798 <ull_configmrxlut+0x128>)
   40742:	4620      	mov	r0, r4
   40744:	f7ff fec8 	bl	404d8 <dwt_write32bitoffsetreg>
   40748:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   4074c:	00039ff6 	.word	0x00039ff6
   40750:	00055ffe 	.word	0x00055ffe
   40754:	00039dfe 	.word	0x00039dfe
   40758:	00039c7e 	.word	0x00039c7e
   4075c:	00038efe 	.word	0x00038efe
   40760:	0003876e 	.word	0x0003876e
   40764:	0003803e 	.word	0x0003803e
   40768:	0005407e 	.word	0x0005407e
   4076c:	0003001c 	.word	0x0003001c
   40770:	1a491248 	.word	0x1a491248
   40774:	00030020 	.word	0x00030020
   40778:	2db248db 	.word	0x2db248db
   4077c:	00030024 	.word	0x00030024
   40780:	0003002c 	.word	0x0003002c
   40784:	00030030 	.word	0x00030030
   40788:	00030034 	.word	0x00030034
   4078c:	00030038 	.word	0x00030038
   40790:	0003003c 	.word	0x0003003c
   40794:	00030040 	.word	0x00030040
   40798:	00030044 	.word	0x00030044

0004079c <ull_disable_rftx_blocks>:
   4079c:	b508      	push	{r3, lr}
   4079e:	2300      	movs	r3, #0
   407a0:	461a      	mov	r2, r3
   407a2:	4902      	ldr	r1, [pc, #8]	; (407ac <ull_disable_rftx_blocks+0x10>)
   407a4:	f7ff fe98 	bl	404d8 <dwt_write32bitoffsetreg>
   407a8:	bd08      	pop	{r3, pc}
   407aa:	bf00      	nop
   407ac:	00070004 	.word	0x00070004

000407b0 <ull_disable_rf_tx>:
   407b0:	b538      	push	{r3, r4, r5, lr}
   407b2:	4604      	mov	r4, r0
   407b4:	460d      	mov	r5, r1
   407b6:	2300      	movs	r3, #0
   407b8:	461a      	mov	r2, r3
   407ba:	490a      	ldr	r1, [pc, #40]	; (407e4 <ull_disable_rf_tx+0x34>)
   407bc:	f7ff fe8c 	bl	404d8 <dwt_write32bitoffsetreg>
   407c0:	2300      	movs	r3, #0
   407c2:	461a      	mov	r2, r3
   407c4:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   407c8:	4620      	mov	r0, r4
   407ca:	f7ff fe85 	bl	404d8 <dwt_write32bitoffsetreg>
   407ce:	b905      	cbnz	r5, 407d2 <ull_disable_rf_tx+0x22>
   407d0:	bd38      	pop	{r3, r4, r5, pc}
   407d2:	f04f 53e0 	mov.w	r3, #469762048	; 0x1c000000
   407d6:	2200      	movs	r2, #0
   407d8:	4903      	ldr	r1, [pc, #12]	; (407e8 <ull_disable_rf_tx+0x38>)
   407da:	4620      	mov	r0, r4
   407dc:	f7ff fe7c 	bl	404d8 <dwt_write32bitoffsetreg>
   407e0:	e7f6      	b.n	407d0 <ull_disable_rf_tx+0x20>
   407e2:	bf00      	nop
   407e4:	00070048 	.word	0x00070048
   407e8:	00070014 	.word	0x00070014

000407ec <ull_repeated_cw>:
   407ec:	b570      	push	{r4, r5, r6, lr}
   407ee:	4606      	mov	r6, r0
   407f0:	460c      	mov	r4, r1
   407f2:	4615      	mov	r5, r2
   407f4:	2100      	movs	r1, #0
   407f6:	f7ff febf 	bl	40578 <ull_setfinegraintxseq>
   407fa:	2d0f      	cmp	r5, #15
   407fc:	bfa8      	it	ge
   407fe:	250f      	movge	r5, #15
   40800:	1e63      	subs	r3, r4, #1
   40802:	2b03      	cmp	r3, #3
   40804:	bf28      	it	cs
   40806:	2404      	movcs	r4, #4
   40808:	2310      	movs	r3, #16
   4080a:	4123      	asrs	r3, r4
   4080c:	2200      	movs	r2, #0
   4080e:	4907      	ldr	r1, [pc, #28]	; (4082c <ull_repeated_cw+0x40>)
   40810:	4630      	mov	r0, r6
   40812:	f7ff fe61 	bl	404d8 <dwt_write32bitoffsetreg>
   40816:	1e63      	subs	r3, r4, #1
   40818:	009b      	lsls	r3, r3, #2
   4081a:	fa05 f303 	lsl.w	r3, r5, r3
   4081e:	2200      	movs	r2, #0
   40820:	4903      	ldr	r1, [pc, #12]	; (40830 <ull_repeated_cw+0x44>)
   40822:	4630      	mov	r0, r6
   40824:	f7ff fe58 	bl	404d8 <dwt_write32bitoffsetreg>
   40828:	bd70      	pop	{r4, r5, r6, pc}
   4082a:	bf00      	nop
   4082c:	00070028 	.word	0x00070028
   40830:	00080018 	.word	0x00080018

00040834 <ull_readrxdata>:
   40834:	b5f0      	push	{r4, r5, r6, r7, lr}
   40836:	b083      	sub	sp, #12
   40838:	6d04      	ldr	r4, [r0, #80]	; 0x50
   4083a:	7ba4      	ldrb	r4, [r4, #14]
   4083c:	2c03      	cmp	r4, #3
   4083e:	bf0c      	ite	eq
   40840:	f44f 1c98 	moveq.w	ip, #1245184	; 0x130000
   40844:	f44f 1c90 	movne.w	ip, #1179648	; 0x120000
   40848:	189c      	adds	r4, r3, r2
   4084a:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   4084e:	da19      	bge.n	40884 <ull_readrxdata+0x50>
   40850:	461d      	mov	r5, r3
   40852:	4616      	mov	r6, r2
   40854:	460f      	mov	r7, r1
   40856:	4604      	mov	r4, r0
   40858:	2b7f      	cmp	r3, #127	; 0x7f
   4085a:	d915      	bls.n	40888 <ull_readrxdata+0x54>
   4085c:	ea4f 431c 	mov.w	r3, ip, lsr #16
   40860:	2200      	movs	r2, #0
   40862:	490d      	ldr	r1, [pc, #52]	; (40898 <ull_readrxdata+0x64>)
   40864:	f7ff fe38 	bl	404d8 <dwt_write32bitoffsetreg>
   40868:	462b      	mov	r3, r5
   4086a:	2200      	movs	r2, #0
   4086c:	490b      	ldr	r1, [pc, #44]	; (4089c <ull_readrxdata+0x68>)
   4086e:	4620      	mov	r0, r4
   40870:	f7ff fe32 	bl	404d8 <dwt_write32bitoffsetreg>
   40874:	9700      	str	r7, [sp, #0]
   40876:	4633      	mov	r3, r6
   40878:	2200      	movs	r2, #0
   4087a:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   4087e:	4620      	mov	r0, r4
   40880:	f7ff f941 	bl	3fb06 <dwt_readfromdevice>
   40884:	b003      	add	sp, #12
   40886:	bdf0      	pop	{r4, r5, r6, r7, pc}
   40888:	9100      	str	r1, [sp, #0]
   4088a:	4613      	mov	r3, r2
   4088c:	462a      	mov	r2, r5
   4088e:	4661      	mov	r1, ip
   40890:	f7ff f939 	bl	3fb06 <dwt_readfromdevice>
   40894:	e7f6      	b.n	40884 <ull_readrxdata+0x50>
   40896:	bf00      	nop
   40898:	001f0004 	.word	0x001f0004
   4089c:	001f0008 	.word	0x001f0008

000408a0 <dwt_write8bitoffsetreg>:
   408a0:	b510      	push	{r4, lr}
   408a2:	b084      	sub	sp, #16
   408a4:	ac04      	add	r4, sp, #16
   408a6:	f804 3d01 	strb.w	r3, [r4, #-1]!
   408aa:	9400      	str	r4, [sp, #0]
   408ac:	2301      	movs	r3, #1
   408ae:	b292      	uxth	r2, r2
   408b0:	f7ff fd9c 	bl	403ec <dwt_writetodevice>
   408b4:	b004      	add	sp, #16
   408b6:	bd10      	pop	{r4, pc}

000408b8 <ull_getframelength>:
   408b8:	b510      	push	{r4, lr}
   408ba:	4604      	mov	r4, r0
   408bc:	6d03      	ldr	r3, [r0, #80]	; 0x50
   408be:	7b9b      	ldrb	r3, [r3, #14]
   408c0:	2b01      	cmp	r3, #1
   408c2:	d013      	beq.n	408ec <ull_getframelength+0x34>
   408c4:	2b03      	cmp	r3, #3
   408c6:	d11d      	bne.n	40904 <ull_getframelength+0x4c>
   408c8:	23f0      	movs	r3, #240	; 0xf0
   408ca:	2200      	movs	r2, #0
   408cc:	4912      	ldr	r1, [pc, #72]	; (40918 <ull_getframelength+0x60>)
   408ce:	f7ff ffe7 	bl	408a0 <dwt_write8bitoffsetreg>
   408d2:	2200      	movs	r2, #0
   408d4:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   408d8:	4620      	mov	r0, r4
   408da:	f7ff f934 	bl	3fb46 <dwt_read16bitoffsetreg>
   408de:	6d23      	ldr	r3, [r4, #80]	; 0x50
   408e0:	7ada      	ldrb	r2, [r3, #11]
   408e2:	b1a2      	cbz	r2, 4090e <ull_getframelength+0x56>
   408e4:	f3c0 0009 	ubfx	r0, r0, #0, #10
   408e8:	83d8      	strh	r0, [r3, #30]
   408ea:	bd10      	pop	{r4, pc}
   408ec:	230f      	movs	r3, #15
   408ee:	2200      	movs	r2, #0
   408f0:	4909      	ldr	r1, [pc, #36]	; (40918 <ull_getframelength+0x60>)
   408f2:	f7ff ffd5 	bl	408a0 <dwt_write8bitoffsetreg>
   408f6:	2200      	movs	r2, #0
   408f8:	f44f 11c0 	mov.w	r1, #1572864	; 0x180000
   408fc:	4620      	mov	r0, r4
   408fe:	f7ff f922 	bl	3fb46 <dwt_read16bitoffsetreg>
   40902:	e7ec      	b.n	408de <ull_getframelength+0x26>
   40904:	2200      	movs	r2, #0
   40906:	214c      	movs	r1, #76	; 0x4c
   40908:	f7ff f91d 	bl	3fb46 <dwt_read16bitoffsetreg>
   4090c:	e7e7      	b.n	408de <ull_getframelength+0x26>
   4090e:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   40912:	83d8      	strh	r0, [r3, #30]
   40914:	e7e9      	b.n	408ea <ull_getframelength+0x32>
   40916:	bf00      	nop
   40918:	00010018 	.word	0x00010018

0004091c <_dwt_clear_db_events>:
   4091c:	b510      	push	{r4, lr}
   4091e:	4604      	mov	r4, r0
   40920:	6d03      	ldr	r3, [r0, #80]	; 0x50
   40922:	7b9b      	ldrb	r3, [r3, #14]
   40924:	2b01      	cmp	r3, #1
   40926:	d004      	beq.n	40932 <_dwt_clear_db_events+0x16>
   40928:	6d23      	ldr	r3, [r4, #80]	; 0x50
   4092a:	7b9b      	ldrb	r3, [r3, #14]
   4092c:	2b03      	cmp	r3, #3
   4092e:	d006      	beq.n	4093e <_dwt_clear_db_events+0x22>
   40930:	bd10      	pop	{r4, pc}
   40932:	230f      	movs	r3, #15
   40934:	2200      	movs	r2, #0
   40936:	4905      	ldr	r1, [pc, #20]	; (4094c <_dwt_clear_db_events+0x30>)
   40938:	f7ff ffb2 	bl	408a0 <dwt_write8bitoffsetreg>
   4093c:	e7f4      	b.n	40928 <_dwt_clear_db_events+0xc>
   4093e:	23f0      	movs	r3, #240	; 0xf0
   40940:	2200      	movs	r2, #0
   40942:	4902      	ldr	r1, [pc, #8]	; (4094c <_dwt_clear_db_events+0x30>)
   40944:	4620      	mov	r0, r4
   40946:	f7ff ffab 	bl	408a0 <dwt_write8bitoffsetreg>
   4094a:	e7f1      	b.n	40930 <_dwt_clear_db_events+0x14>
   4094c:	00010018 	.word	0x00010018

00040950 <ull_clearaonconfig>:
   40950:	b538      	push	{r3, r4, r5, lr}
   40952:	4604      	mov	r4, r0
   40954:	2300      	movs	r3, #0
   40956:	461a      	mov	r2, r3
   40958:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   4095c:	f7ff fd51 	bl	40402 <dwt_write16bitoffsetreg>
   40960:	2300      	movs	r3, #0
   40962:	461a      	mov	r2, r3
   40964:	4908      	ldr	r1, [pc, #32]	; (40988 <ull_clearaonconfig+0x38>)
   40966:	4620      	mov	r0, r4
   40968:	f7ff ff9a 	bl	408a0 <dwt_write8bitoffsetreg>
   4096c:	4d07      	ldr	r5, [pc, #28]	; (4098c <ull_clearaonconfig+0x3c>)
   4096e:	2300      	movs	r3, #0
   40970:	461a      	mov	r2, r3
   40972:	4629      	mov	r1, r5
   40974:	4620      	mov	r0, r4
   40976:	f7ff ff93 	bl	408a0 <dwt_write8bitoffsetreg>
   4097a:	2302      	movs	r3, #2
   4097c:	2200      	movs	r2, #0
   4097e:	4629      	mov	r1, r5
   40980:	4620      	mov	r0, r4
   40982:	f7ff ff8d 	bl	408a0 <dwt_write8bitoffsetreg>
   40986:	bd38      	pop	{r3, r4, r5, pc}
   40988:	000a0014 	.word	0x000a0014
   4098c:	000a0004 	.word	0x000a0004

00040990 <ull_configeventcounters>:
   40990:	b538      	push	{r3, r4, r5, lr}
   40992:	4605      	mov	r5, r0
   40994:	460c      	mov	r4, r1
   40996:	2302      	movs	r3, #2
   40998:	2200      	movs	r2, #0
   4099a:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   4099e:	f7ff ff7f 	bl	408a0 <dwt_write8bitoffsetreg>
   409a2:	b904      	cbnz	r4, 409a6 <ull_configeventcounters+0x16>
   409a4:	bd38      	pop	{r3, r4, r5, pc}
   409a6:	2301      	movs	r3, #1
   409a8:	2200      	movs	r2, #0
   409aa:	f44f 2170 	mov.w	r1, #983040	; 0xf0000
   409ae:	4628      	mov	r0, r5
   409b0:	f7ff ff76 	bl	408a0 <dwt_write8bitoffsetreg>
   409b4:	e7f6      	b.n	409a4 <ull_configeventcounters+0x14>
	...

000409b8 <ull_aon_read>:
   409b8:	b538      	push	{r3, r4, r5, lr}
   409ba:	4604      	mov	r4, r0
   409bc:	460b      	mov	r3, r1
   409be:	2200      	movs	r2, #0
   409c0:	490a      	ldr	r1, [pc, #40]	; (409ec <ull_aon_read+0x34>)
   409c2:	f7ff fd1e 	bl	40402 <dwt_write16bitoffsetreg>
   409c6:	4d0a      	ldr	r5, [pc, #40]	; (409f0 <ull_aon_read+0x38>)
   409c8:	2388      	movs	r3, #136	; 0x88
   409ca:	2200      	movs	r2, #0
   409cc:	4629      	mov	r1, r5
   409ce:	4620      	mov	r0, r4
   409d0:	f7ff ff66 	bl	408a0 <dwt_write8bitoffsetreg>
   409d4:	2300      	movs	r3, #0
   409d6:	461a      	mov	r2, r3
   409d8:	4629      	mov	r1, r5
   409da:	4620      	mov	r0, r4
   409dc:	f7ff ff60 	bl	408a0 <dwt_write8bitoffsetreg>
   409e0:	2200      	movs	r2, #0
   409e2:	4904      	ldr	r1, [pc, #16]	; (409f4 <ull_aon_read+0x3c>)
   409e4:	4620      	mov	r0, r4
   409e6:	f7ff f8ed 	bl	3fbc4 <dwt_read8bitoffsetreg>
   409ea:	bd38      	pop	{r3, r4, r5, pc}
   409ec:	000a000c 	.word	0x000a000c
   409f0:	000a0004 	.word	0x000a0004
   409f4:	000a0008 	.word	0x000a0008

000409f8 <ull_aon_write>:
   409f8:	b570      	push	{r4, r5, r6, lr}
   409fa:	4604      	mov	r4, r0
   409fc:	460b      	mov	r3, r1
   409fe:	4615      	mov	r5, r2
   40a00:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
   40a04:	bf34      	ite	cc
   40a06:	2600      	movcc	r6, #0
   40a08:	2620      	movcs	r6, #32
   40a0a:	2200      	movs	r2, #0
   40a0c:	490b      	ldr	r1, [pc, #44]	; (40a3c <ull_aon_write+0x44>)
   40a0e:	f7ff fcf8 	bl	40402 <dwt_write16bitoffsetreg>
   40a12:	462b      	mov	r3, r5
   40a14:	2200      	movs	r2, #0
   40a16:	490a      	ldr	r1, [pc, #40]	; (40a40 <ull_aon_write+0x48>)
   40a18:	4620      	mov	r0, r4
   40a1a:	f7ff ff41 	bl	408a0 <dwt_write8bitoffsetreg>
   40a1e:	4d09      	ldr	r5, [pc, #36]	; (40a44 <ull_aon_write+0x4c>)
   40a20:	f046 0390 	orr.w	r3, r6, #144	; 0x90
   40a24:	2200      	movs	r2, #0
   40a26:	4629      	mov	r1, r5
   40a28:	4620      	mov	r0, r4
   40a2a:	f7ff ff39 	bl	408a0 <dwt_write8bitoffsetreg>
   40a2e:	2300      	movs	r3, #0
   40a30:	461a      	mov	r2, r3
   40a32:	4629      	mov	r1, r5
   40a34:	4620      	mov	r0, r4
   40a36:	f7ff ff33 	bl	408a0 <dwt_write8bitoffsetreg>
   40a3a:	bd70      	pop	{r4, r5, r6, pc}
   40a3c:	000a000c 	.word	0x000a000c
   40a40:	000a0010 	.word	0x000a0010
   40a44:	000a0004 	.word	0x000a0004

00040a48 <ull_configuresleep>:
   40a48:	b570      	push	{r4, r5, r6, lr}
   40a4a:	4604      	mov	r4, r0
   40a4c:	460d      	mov	r5, r1
   40a4e:	4616      	mov	r6, r2
   40a50:	2200      	movs	r2, #0
   40a52:	f240 110b 	movw	r1, #267	; 0x10b
   40a56:	f7ff ffcf 	bl	409f8 <ull_aon_write>
   40a5a:	f44f 7182 	mov.w	r1, #260	; 0x104
   40a5e:	4620      	mov	r0, r4
   40a60:	f7ff ffaa 	bl	409b8 <ull_aon_read>
   40a64:	f000 021f 	and.w	r2, r0, #31
   40a68:	f44f 7182 	mov.w	r1, #260	; 0x104
   40a6c:	4620      	mov	r0, r4
   40a6e:	f7ff ffc3 	bl	409f8 <ull_aon_write>
   40a72:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40a74:	8a1a      	ldrh	r2, [r3, #16]
   40a76:	4315      	orrs	r5, r2
   40a78:	821d      	strh	r5, [r3, #16]
   40a7a:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40a7c:	8a13      	ldrh	r3, [r2, #16]
   40a7e:	f413 6f00 	tst.w	r3, #2048	; 0x800
   40a82:	bf1c      	itt	ne
   40a84:	f423 6300 	bicne.w	r3, r3, #2048	; 0x800
   40a88:	8213      	strhne	r3, [r2, #16]
   40a8a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40a8c:	8a1b      	ldrh	r3, [r3, #16]
   40a8e:	2200      	movs	r2, #0
   40a90:	f44f 2120 	mov.w	r1, #655360	; 0xa0000
   40a94:	4620      	mov	r0, r4
   40a96:	f7ff fcb4 	bl	40402 <dwt_write16bitoffsetreg>
   40a9a:	4633      	mov	r3, r6
   40a9c:	2200      	movs	r2, #0
   40a9e:	4902      	ldr	r1, [pc, #8]	; (40aa8 <ull_configuresleep+0x60>)
   40aa0:	4620      	mov	r0, r4
   40aa2:	f7ff fefd 	bl	408a0 <dwt_write8bitoffsetreg>
   40aa6:	bd70      	pop	{r4, r5, r6, pc}
   40aa8:	000a0014 	.word	0x000a0014

00040aac <ull_setplenfine>:
   40aac:	b508      	push	{r3, lr}
   40aae:	460b      	mov	r3, r1
   40ab0:	2201      	movs	r2, #1
   40ab2:	2124      	movs	r1, #36	; 0x24
   40ab4:	f7ff fef4 	bl	408a0 <dwt_write8bitoffsetreg>
   40ab8:	bd08      	pop	{r3, pc}
	...

00040abc <ull_update_nonce_GCM>:
   40abc:	b500      	push	{lr}
   40abe:	b083      	sub	sp, #12
   40ac0:	9100      	str	r1, [sp, #0]
   40ac2:	230c      	movs	r3, #12
   40ac4:	2200      	movs	r2, #0
   40ac6:	4903      	ldr	r1, [pc, #12]	; (40ad4 <ull_update_nonce_GCM+0x18>)
   40ac8:	f7ff fc90 	bl	403ec <dwt_writetodevice>
   40acc:	b003      	add	sp, #12
   40ace:	f85d fb04 	ldr.w	pc, [sp], #4
   40ad2:	bf00      	nop
   40ad4:	00010034 	.word	0x00010034

00040ad8 <ull_update_nonce_CCM>:
   40ad8:	b500      	push	{lr}
   40ada:	b087      	sub	sp, #28
   40adc:	4613      	mov	r3, r2
   40ade:	7a8a      	ldrb	r2, [r1, #10]
   40ae0:	f88d 2008 	strb.w	r2, [sp, #8]
   40ae4:	7a4a      	ldrb	r2, [r1, #9]
   40ae6:	f88d 2009 	strb.w	r2, [sp, #9]
   40aea:	7a0a      	ldrb	r2, [r1, #8]
   40aec:	f88d 200a 	strb.w	r2, [sp, #10]
   40af0:	79ca      	ldrb	r2, [r1, #7]
   40af2:	f88d 200b 	strb.w	r2, [sp, #11]
   40af6:	798a      	ldrb	r2, [r1, #6]
   40af8:	f88d 200c 	strb.w	r2, [sp, #12]
   40afc:	794a      	ldrb	r2, [r1, #5]
   40afe:	f88d 200d 	strb.w	r2, [sp, #13]
   40b02:	790a      	ldrb	r2, [r1, #4]
   40b04:	f88d 200e 	strb.w	r2, [sp, #14]
   40b08:	78ca      	ldrb	r2, [r1, #3]
   40b0a:	f88d 200f 	strb.w	r2, [sp, #15]
   40b0e:	788a      	ldrb	r2, [r1, #2]
   40b10:	f88d 2010 	strb.w	r2, [sp, #16]
   40b14:	784a      	ldrb	r2, [r1, #1]
   40b16:	f88d 2011 	strb.w	r2, [sp, #17]
   40b1a:	780a      	ldrb	r2, [r1, #0]
   40b1c:	f88d 2012 	strb.w	r2, [sp, #18]
   40b20:	2200      	movs	r2, #0
   40b22:	f88d 2013 	strb.w	r2, [sp, #19]
   40b26:	f88d 3014 	strb.w	r3, [sp, #20]
   40b2a:	0a1b      	lsrs	r3, r3, #8
   40b2c:	f88d 3015 	strb.w	r3, [sp, #21]
   40b30:	7b0b      	ldrb	r3, [r1, #12]
   40b32:	f88d 3016 	strb.w	r3, [sp, #22]
   40b36:	7acb      	ldrb	r3, [r1, #11]
   40b38:	f88d 3017 	strb.w	r3, [sp, #23]
   40b3c:	ab02      	add	r3, sp, #8
   40b3e:	9300      	str	r3, [sp, #0]
   40b40:	2310      	movs	r3, #16
   40b42:	4903      	ldr	r1, [pc, #12]	; (40b50 <ull_update_nonce_CCM+0x78>)
   40b44:	f7ff fc52 	bl	403ec <dwt_writetodevice>
   40b48:	b007      	add	sp, #28
   40b4a:	f85d fb04 	ldr.w	pc, [sp], #4
   40b4e:	bf00      	nop
   40b50:	00010034 	.word	0x00010034

00040b54 <ull_writetxdata>:
   40b54:	b5f0      	push	{r4, r5, r6, r7, lr}
   40b56:	b083      	sub	sp, #12
   40b58:	185c      	adds	r4, r3, r1
   40b5a:	f5b4 6f80 	cmp.w	r4, #1024	; 0x400
   40b5e:	da24      	bge.n	40baa <ull_writetxdata+0x56>
   40b60:	461c      	mov	r4, r3
   40b62:	4617      	mov	r7, r2
   40b64:	460e      	mov	r6, r1
   40b66:	4605      	mov	r5, r0
   40b68:	2b7f      	cmp	r3, #127	; 0x7f
   40b6a:	d915      	bls.n	40b98 <ull_writetxdata+0x44>
   40b6c:	2314      	movs	r3, #20
   40b6e:	2200      	movs	r2, #0
   40b70:	490f      	ldr	r1, [pc, #60]	; (40bb0 <ull_writetxdata+0x5c>)
   40b72:	f7ff fcb1 	bl	404d8 <dwt_write32bitoffsetreg>
   40b76:	4623      	mov	r3, r4
   40b78:	2200      	movs	r2, #0
   40b7a:	490e      	ldr	r1, [pc, #56]	; (40bb4 <ull_writetxdata+0x60>)
   40b7c:	4628      	mov	r0, r5
   40b7e:	f7ff fcab 	bl	404d8 <dwt_write32bitoffsetreg>
   40b82:	9700      	str	r7, [sp, #0]
   40b84:	4633      	mov	r3, r6
   40b86:	2200      	movs	r2, #0
   40b88:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   40b8c:	4628      	mov	r0, r5
   40b8e:	f7ff fc2d 	bl	403ec <dwt_writetodevice>
   40b92:	2000      	movs	r0, #0
   40b94:	b003      	add	sp, #12
   40b96:	bdf0      	pop	{r4, r5, r6, r7, pc}
   40b98:	9200      	str	r2, [sp, #0]
   40b9a:	460b      	mov	r3, r1
   40b9c:	4622      	mov	r2, r4
   40b9e:	f44f 11a0 	mov.w	r1, #1310720	; 0x140000
   40ba2:	f7ff fc23 	bl	403ec <dwt_writetodevice>
   40ba6:	2000      	movs	r0, #0
   40ba8:	e7f4      	b.n	40b94 <ull_writetxdata+0x40>
   40baa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   40bae:	e7f1      	b.n	40b94 <ull_writetxdata+0x40>
   40bb0:	001f0004 	.word	0x001f0004
   40bb4:	001f0008 	.word	0x001f0008

00040bb8 <ull_signal_rx_buff_free>:
   40bb8:	b510      	push	{r4, lr}
   40bba:	b082      	sub	sp, #8
   40bbc:	4604      	mov	r4, r0
   40bbe:	2302      	movs	r3, #2
   40bc0:	9301      	str	r3, [sp, #4]
   40bc2:	2200      	movs	r2, #0
   40bc4:	9200      	str	r2, [sp, #0]
   40bc6:	4613      	mov	r3, r2
   40bc8:	2113      	movs	r1, #19
   40bca:	f7fe ff1e 	bl	3fa0a <dwt_xfer3xxx>
   40bce:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40bd0:	7b9a      	ldrb	r2, [r3, #14]
   40bd2:	2a03      	cmp	r2, #3
   40bd4:	bf0c      	ite	eq
   40bd6:	2201      	moveq	r2, #1
   40bd8:	2203      	movne	r2, #3
   40bda:	739a      	strb	r2, [r3, #14]
   40bdc:	b002      	add	sp, #8
   40bde:	bd10      	pop	{r4, pc}

00040be0 <ull_isr>:
   40be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   40be4:	4604      	mov	r4, r0
   40be6:	2200      	movs	r2, #0
   40be8:	f44f 11f8 	mov.w	r1, #2031616	; 0x1f0000
   40bec:	f7fe ffea 	bl	3fbc4 <dwt_read8bitoffsetreg>
   40bf0:	4605      	mov	r5, r0
   40bf2:	2200      	movs	r2, #0
   40bf4:	2144      	movs	r1, #68	; 0x44
   40bf6:	4620      	mov	r0, r4
   40bf8:	f7fe ff8f 	bl	3fb1a <dwt_read32bitoffsetreg>
   40bfc:	4606      	mov	r6, r0
   40bfe:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c00:	2200      	movs	r2, #0
   40c02:	83da      	strh	r2, [r3, #30]
   40c04:	f883 2020 	strb.w	r2, [r3, #32]
   40c08:	619a      	str	r2, [r3, #24]
   40c0a:	839a      	strh	r2, [r3, #28]
   40c0c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
   40c10:	625a      	str	r2, [r3, #36]	; 0x24
   40c12:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c14:	625c      	str	r4, [r3, #36]	; 0x24
   40c16:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c18:	7b9f      	ldrb	r7, [r3, #14]
   40c1a:	2f00      	cmp	r7, #0
   40c1c:	d17f      	bne.n	40d1e <ull_isr+0x13e>
   40c1e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c20:	619e      	str	r6, [r3, #24]
   40c22:	f8d4 8050 	ldr.w	r8, [r4, #80]	; 0x50
   40c26:	f898 3015 	ldrb.w	r3, [r8, #21]
   40c2a:	f003 0303 	and.w	r3, r3, #3
   40c2e:	2b03      	cmp	r3, #3
   40c30:	f000 8090 	beq.w	40d54 <ull_isr+0x174>
   40c34:	f015 0f80 	tst.w	r5, #128	; 0x80
   40c38:	f040 8093 	bne.w	40d62 <ull_isr+0x182>
   40c3c:	f015 0f01 	tst.w	r5, #1
   40c40:	f040 80c1 	bne.w	40dc6 <ull_isr+0x1e6>
   40c44:	f015 0f40 	tst.w	r5, #64	; 0x40
   40c48:	d00b      	beq.n	40c62 <ull_isr+0x82>
   40c4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
   40c4c:	b113      	cbz	r3, 40c54 <ull_isr+0x74>
   40c4e:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40c50:	3018      	adds	r0, #24
   40c52:	4798      	blx	r3
   40c54:	f44f 73c0 	mov.w	r3, #384	; 0x180
   40c58:	2202      	movs	r2, #2
   40c5a:	2144      	movs	r1, #68	; 0x44
   40c5c:	4620      	mov	r0, r4
   40c5e:	f7ff fbd0 	bl	40402 <dwt_write16bitoffsetreg>
   40c62:	f015 0f08 	tst.w	r5, #8
   40c66:	d107      	bne.n	40c78 <ull_isr+0x98>
   40c68:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c6a:	7b9b      	ldrb	r3, [r3, #14]
   40c6c:	2b00      	cmp	r3, #0
   40c6e:	f000 80ea 	beq.w	40e46 <ull_isr+0x266>
   40c72:	2f00      	cmp	r7, #0
   40c74:	f000 80e7 	beq.w	40e46 <ull_isr+0x266>
   40c78:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40c7a:	2200      	movs	r2, #0
   40c7c:	f883 2020 	strb.w	r2, [r3, #32]
   40c80:	f416 2f80 	tst.w	r6, #262144	; 0x40000
   40c84:	f000 80ad 	beq.w	40de2 <ull_isr+0x202>
   40c88:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40c8a:	f892 3020 	ldrb.w	r3, [r2, #32]
   40c8e:	f043 0308 	orr.w	r3, r3, #8
   40c92:	f882 3020 	strb.w	r3, [r2, #32]
   40c96:	f44f 2780 	mov.w	r7, #262144	; 0x40000
   40c9a:	f016 5f80 	tst.w	r6, #268435456	; 0x10000000
   40c9e:	d008      	beq.n	40cb2 <ull_isr+0xd2>
   40ca0:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40ca2:	f892 3020 	ldrb.w	r3, [r2, #32]
   40ca6:	f043 0310 	orr.w	r3, r3, #16
   40caa:	f882 3020 	strb.w	r3, [r2, #32]
   40cae:	f047 5780 	orr.w	r7, r7, #268435456	; 0x10000000
   40cb2:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   40cb6:	d006      	beq.n	40cc6 <ull_isr+0xe6>
   40cb8:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40cba:	7d53      	ldrb	r3, [r2, #21]
   40cbc:	f003 0303 	and.w	r3, r3, #3
   40cc0:	2b03      	cmp	r3, #3
   40cc2:	f000 809a 	beq.w	40dfa <ull_isr+0x21a>
   40cc6:	f416 4f80 	tst.w	r6, #16384	; 0x4000
   40cca:	f040 80a2 	bne.w	40e12 <ull_isr+0x232>
   40cce:	f447 43de 	orr.w	r3, r7, #28416	; 0x6f00
   40cd2:	2200      	movs	r2, #0
   40cd4:	2144      	movs	r1, #68	; 0x44
   40cd6:	4620      	mov	r0, r4
   40cd8:	f7ff fbfe 	bl	404d8 <dwt_write32bitoffsetreg>
   40cdc:	4620      	mov	r0, r4
   40cde:	f7ff fe1d 	bl	4091c <_dwt_clear_db_events>
   40ce2:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40ce4:	8bc3      	ldrh	r3, [r0, #30]
   40ce6:	2b00      	cmp	r3, #0
   40ce8:	f040 80a2 	bne.w	40e30 <ull_isr+0x250>
   40cec:	7d43      	ldrb	r3, [r0, #21]
   40cee:	f003 0303 	and.w	r3, r3, #3
   40cf2:	2b03      	cmp	r3, #3
   40cf4:	f000 809c 	beq.w	40e30 <ull_isr+0x250>
   40cf8:	6983      	ldr	r3, [r0, #24]
   40cfa:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
   40cfe:	6183      	str	r3, [r0, #24]
   40d00:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40d02:	6993      	ldr	r3, [r2, #24]
   40d04:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   40d08:	6193      	str	r3, [r2, #24]
   40d0a:	69e3      	ldr	r3, [r4, #28]
   40d0c:	b113      	cbz	r3, 40d14 <ull_isr+0x134>
   40d0e:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40d10:	3018      	adds	r0, #24
   40d12:	4798      	blx	r3
   40d14:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40d16:	2200      	movs	r2, #0
   40d18:	f883 2020 	strb.w	r2, [r3, #32]
   40d1c:	e08c      	b.n	40e38 <ull_isr+0x258>
   40d1e:	496d      	ldr	r1, [pc, #436]	; (40ed4 <ull_isr+0x2f4>)
   40d20:	4620      	mov	r0, r4
   40d22:	f7fe ff4f 	bl	3fbc4 <dwt_read8bitoffsetreg>
   40d26:	4607      	mov	r7, r0
   40d28:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40d2a:	7b9b      	ldrb	r3, [r3, #14]
   40d2c:	2b03      	cmp	r3, #3
   40d2e:	bf08      	it	eq
   40d30:	f3c0 1707 	ubfxeq	r7, r0, #4, #8
   40d34:	f017 0f01 	tst.w	r7, #1
   40d38:	bf18      	it	ne
   40d3a:	f446 4680 	orrne.w	r6, r6, #16384	; 0x4000
   40d3e:	f017 0f02 	tst.w	r7, #2
   40d42:	bf18      	it	ne
   40d44:	f446 5600 	orrne.w	r6, r6, #8192	; 0x2000
   40d48:	f017 0f04 	tst.w	r7, #4
   40d4c:	bf18      	it	ne
   40d4e:	f446 6680 	orrne.w	r6, r6, #1024	; 0x400
   40d52:	e764      	b.n	40c1e <ull_isr+0x3e>
   40d54:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   40d58:	bf1c      	itt	ne
   40d5a:	f045 0508 	orrne.w	r5, r5, #8
   40d5e:	b2ed      	uxtbne	r5, r5
   40d60:	e768      	b.n	40c34 <ull_isr+0x54>
   40d62:	2200      	movs	r2, #0
   40d64:	2148      	movs	r1, #72	; 0x48
   40d66:	4620      	mov	r0, r4
   40d68:	f7fe feed 	bl	3fb46 <dwt_read16bitoffsetreg>
   40d6c:	f8a8 001c 	strh.w	r0, [r8, #28]
   40d70:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40d72:	7d1a      	ldrb	r2, [r3, #20]
   40d74:	b11a      	cbz	r2, 40d7e <ull_isr+0x19e>
   40d76:	699a      	ldr	r2, [r3, #24]
   40d78:	f012 0f04 	tst.w	r2, #4
   40d7c:	d103      	bne.n	40d86 <ull_isr+0x1a6>
   40d7e:	8b9b      	ldrh	r3, [r3, #28]
   40d80:	f403 6360 	and.w	r3, r3, #3584	; 0xe00
   40d84:	b18b      	cbz	r3, 40daa <ull_isr+0x1ca>
   40d86:	2304      	movs	r3, #4
   40d88:	2200      	movs	r2, #0
   40d8a:	2144      	movs	r1, #68	; 0x44
   40d8c:	4620      	mov	r0, r4
   40d8e:	f7ff fd87 	bl	408a0 <dwt_write8bitoffsetreg>
   40d92:	f44f 6360 	mov.w	r3, #3584	; 0xe00
   40d96:	2200      	movs	r2, #0
   40d98:	2148      	movs	r1, #72	; 0x48
   40d9a:	4620      	mov	r0, r4
   40d9c:	f7ff fb31 	bl	40402 <dwt_write16bitoffsetreg>
   40da0:	6a23      	ldr	r3, [r4, #32]
   40da2:	b113      	cbz	r3, 40daa <ull_isr+0x1ca>
   40da4:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40da6:	3018      	adds	r0, #24
   40da8:	4798      	blx	r3
   40daa:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40dac:	8b9b      	ldrh	r3, [r3, #28]
   40dae:	f413 7f80 	tst.w	r3, #256	; 0x100
   40db2:	f43f af43 	beq.w	40c3c <ull_isr+0x5c>
   40db6:	f44f 7380 	mov.w	r3, #256	; 0x100
   40dba:	2200      	movs	r2, #0
   40dbc:	2148      	movs	r1, #72	; 0x48
   40dbe:	4620      	mov	r0, r4
   40dc0:	f7ff fb1f 	bl	40402 <dwt_write16bitoffsetreg>
   40dc4:	e73a      	b.n	40c3c <ull_isr+0x5c>
   40dc6:	23f8      	movs	r3, #248	; 0xf8
   40dc8:	2200      	movs	r2, #0
   40dca:	2144      	movs	r1, #68	; 0x44
   40dcc:	4620      	mov	r0, r4
   40dce:	f7ff fd67 	bl	408a0 <dwt_write8bitoffsetreg>
   40dd2:	6923      	ldr	r3, [r4, #16]
   40dd4:	2b00      	cmp	r3, #0
   40dd6:	f43f af35 	beq.w	40c44 <ull_isr+0x64>
   40dda:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40ddc:	3018      	adds	r0, #24
   40dde:	4798      	blx	r3
   40de0:	e730      	b.n	40c44 <ull_isr+0x64>
   40de2:	f416 6f80 	tst.w	r6, #1024	; 0x400
   40de6:	bf1f      	itttt	ne
   40de8:	6d22      	ldrne	r2, [r4, #80]	; 0x50
   40dea:	f892 3020 	ldrbne.w	r3, [r2, #32]
   40dee:	f043 0304 	orrne.w	r3, r3, #4
   40df2:	f882 3020 	strbne.w	r3, [r2, #32]
   40df6:	2700      	movs	r7, #0
   40df8:	e74f      	b.n	40c9a <ull_isr+0xba>
   40dfa:	f892 3020 	ldrb.w	r3, [r2, #32]
   40dfe:	f043 0302 	orr.w	r3, r3, #2
   40e02:	f882 3020 	strb.w	r3, [r2, #32]
   40e06:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40e08:	2200      	movs	r2, #0
   40e0a:	83da      	strh	r2, [r3, #30]
   40e0c:	f447 4700 	orr.w	r7, r7, #32768	; 0x8000
   40e10:	e75d      	b.n	40cce <ull_isr+0xee>
   40e12:	4620      	mov	r0, r4
   40e14:	f7ff fd50 	bl	408b8 <ull_getframelength>
   40e18:	f410 4f00 	tst.w	r0, #32768	; 0x8000
   40e1c:	f43f af57 	beq.w	40cce <ull_isr+0xee>
   40e20:	6d22      	ldr	r2, [r4, #80]	; 0x50
   40e22:	f892 3020 	ldrb.w	r3, [r2, #32]
   40e26:	f043 0301 	orr.w	r3, r3, #1
   40e2a:	f882 3020 	strb.w	r3, [r2, #32]
   40e2e:	e74e      	b.n	40cce <ull_isr+0xee>
   40e30:	6963      	ldr	r3, [r4, #20]
   40e32:	b10b      	cbz	r3, 40e38 <ull_isr+0x258>
   40e34:	3018      	adds	r0, #24
   40e36:	4798      	blx	r3
   40e38:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40e3a:	7b9b      	ldrb	r3, [r3, #14]
   40e3c:	bb03      	cbnz	r3, 40e80 <ull_isr+0x2a0>
   40e3e:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40e40:	2200      	movs	r2, #0
   40e42:	f883 2020 	strb.w	r2, [r3, #32]
   40e46:	f015 0f10 	tst.w	r5, #16
   40e4a:	d11d      	bne.n	40e88 <ull_isr+0x2a8>
   40e4c:	f015 0f20 	tst.w	r5, #32
   40e50:	d12d      	bne.n	40eae <ull_isr+0x2ce>
   40e52:	2200      	movs	r2, #0
   40e54:	4920      	ldr	r1, [pc, #128]	; (40ed8 <ull_isr+0x2f8>)
   40e56:	4620      	mov	r0, r4
   40e58:	f7fe feb4 	bl	3fbc4 <dwt_read8bitoffsetreg>
   40e5c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40e5e:	f883 0021 	strb.w	r0, [r3, #33]	; 0x21
   40e62:	f010 0303 	ands.w	r3, r0, #3
   40e66:	d009      	beq.n	40e7c <ull_isr+0x29c>
   40e68:	2200      	movs	r2, #0
   40e6a:	491b      	ldr	r1, [pc, #108]	; (40ed8 <ull_isr+0x2f8>)
   40e6c:	4620      	mov	r0, r4
   40e6e:	f7ff fd17 	bl	408a0 <dwt_write8bitoffsetreg>
   40e72:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   40e74:	b113      	cbz	r3, 40e7c <ull_isr+0x29c>
   40e76:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40e78:	3018      	adds	r0, #24
   40e7a:	4798      	blx	r3
   40e7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   40e80:	4620      	mov	r0, r4
   40e82:	f7ff fe99 	bl	40bb8 <ull_signal_rx_buff_free>
   40e86:	e7da      	b.n	40e3e <ull_isr+0x25e>
   40e88:	4b14      	ldr	r3, [pc, #80]	; (40edc <ull_isr+0x2fc>)
   40e8a:	2200      	movs	r2, #0
   40e8c:	2144      	movs	r1, #68	; 0x44
   40e8e:	4620      	mov	r0, r4
   40e90:	f7ff fb22 	bl	404d8 <dwt_write32bitoffsetreg>
   40e94:	4620      	mov	r0, r4
   40e96:	f7ff fd41 	bl	4091c <_dwt_clear_db_events>
   40e9a:	69e3      	ldr	r3, [r4, #28]
   40e9c:	b113      	cbz	r3, 40ea4 <ull_isr+0x2c4>
   40e9e:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40ea0:	3018      	adds	r0, #24
   40ea2:	4798      	blx	r3
   40ea4:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40ea6:	2200      	movs	r2, #0
   40ea8:	f883 2020 	strb.w	r2, [r3, #32]
   40eac:	e7ce      	b.n	40e4c <ull_isr+0x26c>
   40eae:	4b0c      	ldr	r3, [pc, #48]	; (40ee0 <ull_isr+0x300>)
   40eb0:	2200      	movs	r2, #0
   40eb2:	2144      	movs	r1, #68	; 0x44
   40eb4:	4620      	mov	r0, r4
   40eb6:	f7ff fb0f 	bl	404d8 <dwt_write32bitoffsetreg>
   40eba:	4620      	mov	r0, r4
   40ebc:	f7ff fd2e 	bl	4091c <_dwt_clear_db_events>
   40ec0:	69a3      	ldr	r3, [r4, #24]
   40ec2:	b113      	cbz	r3, 40eca <ull_isr+0x2ea>
   40ec4:	6d20      	ldr	r0, [r4, #80]	; 0x50
   40ec6:	3018      	adds	r0, #24
   40ec8:	4798      	blx	r3
   40eca:	6d23      	ldr	r3, [r4, #80]	; 0x50
   40ecc:	2200      	movs	r2, #0
   40ece:	f883 2020 	strb.w	r2, [r3, #32]
   40ed2:	e7be      	b.n	40e52 <ull_isr+0x272>
   40ed4:	00010018 	.word	0x00010018
   40ed8:	00110038 	.word	0x00110038
   40edc:	34059400 	.word	0x34059400
   40ee0:	10220400 	.word	0x10220400

00040ee4 <dwt_modify32bitoffsetreg>:
   40ee4:	b530      	push	{r4, r5, lr}
   40ee6:	b085      	sub	sp, #20
   40ee8:	9c08      	ldr	r4, [sp, #32]
   40eea:	f88d 3008 	strb.w	r3, [sp, #8]
   40eee:	0a1d      	lsrs	r5, r3, #8
   40ef0:	f88d 5009 	strb.w	r5, [sp, #9]
   40ef4:	0c1d      	lsrs	r5, r3, #16
   40ef6:	f88d 500a 	strb.w	r5, [sp, #10]
   40efa:	0e1b      	lsrs	r3, r3, #24
   40efc:	f88d 300b 	strb.w	r3, [sp, #11]
   40f00:	f88d 400c 	strb.w	r4, [sp, #12]
   40f04:	0a23      	lsrs	r3, r4, #8
   40f06:	f88d 300d 	strb.w	r3, [sp, #13]
   40f0a:	0c23      	lsrs	r3, r4, #16
   40f0c:	f88d 300e 	strb.w	r3, [sp, #14]
   40f10:	0e24      	lsrs	r4, r4, #24
   40f12:	f88d 400f 	strb.w	r4, [sp, #15]
   40f16:	f248 0303 	movw	r3, #32771	; 0x8003
   40f1a:	9301      	str	r3, [sp, #4]
   40f1c:	ab02      	add	r3, sp, #8
   40f1e:	9300      	str	r3, [sp, #0]
   40f20:	2308      	movs	r3, #8
   40f22:	b292      	uxth	r2, r2
   40f24:	f7fe fd71 	bl	3fa0a <dwt_xfer3xxx>
   40f28:	b005      	add	sp, #20
   40f2a:	bd30      	pop	{r4, r5, pc}

00040f2c <ull_enablegpioclocks>:
   40f2c:	b500      	push	{lr}
   40f2e:	b083      	sub	sp, #12
   40f30:	f44f 3380 	mov.w	r3, #65536	; 0x10000
   40f34:	9300      	str	r3, [sp, #0]
   40f36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40f3a:	2200      	movs	r2, #0
   40f3c:	4902      	ldr	r1, [pc, #8]	; (40f48 <ull_enablegpioclocks+0x1c>)
   40f3e:	f7ff ffd1 	bl	40ee4 <dwt_modify32bitoffsetreg>
   40f42:	b003      	add	sp, #12
   40f44:	f85d fb04 	ldr.w	pc, [sp], #4
   40f48:	00110004 	.word	0x00110004

00040f4c <ull_enable_rf_tx>:
   40f4c:	b570      	push	{r4, r5, r6, lr}
   40f4e:	b082      	sub	sp, #8
   40f50:	4604      	mov	r4, r0
   40f52:	460e      	mov	r6, r1
   40f54:	4d13      	ldr	r5, [pc, #76]	; (40fa4 <ull_enable_rf_tx+0x58>)
   40f56:	f04f 2308 	mov.w	r3, #134219776	; 0x8000800
   40f5a:	9300      	str	r3, [sp, #0]
   40f5c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40f60:	2200      	movs	r2, #0
   40f62:	4629      	mov	r1, r5
   40f64:	f7ff ffbe 	bl	40ee4 <dwt_modify32bitoffsetreg>
   40f68:	f04f 1360 	mov.w	r3, #6291552	; 0x600060
   40f6c:	9300      	str	r3, [sp, #0]
   40f6e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40f72:	2200      	movs	r2, #0
   40f74:	4629      	mov	r1, r5
   40f76:	4620      	mov	r0, r4
   40f78:	f7ff ffb4 	bl	40ee4 <dwt_modify32bitoffsetreg>
   40f7c:	4b0a      	ldr	r3, [pc, #40]	; (40fa8 <ull_enable_rf_tx+0x5c>)
   40f7e:	9300      	str	r3, [sp, #0]
   40f80:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40f84:	2200      	movs	r2, #0
   40f86:	f44f 21e0 	mov.w	r1, #458752	; 0x70000
   40f8a:	4620      	mov	r0, r4
   40f8c:	f7ff ffaa 	bl	40ee4 <dwt_modify32bitoffsetreg>
   40f90:	b90e      	cbnz	r6, 40f96 <ull_enable_rf_tx+0x4a>
   40f92:	b002      	add	sp, #8
   40f94:	bd70      	pop	{r4, r5, r6, pc}
   40f96:	4b05      	ldr	r3, [pc, #20]	; (40fac <ull_enable_rf_tx+0x60>)
   40f98:	2200      	movs	r2, #0
   40f9a:	4905      	ldr	r1, [pc, #20]	; (40fb0 <ull_enable_rf_tx+0x64>)
   40f9c:	4620      	mov	r0, r4
   40f9e:	f7ff fa9b 	bl	404d8 <dwt_write32bitoffsetreg>
   40fa2:	e7f6      	b.n	40f92 <ull_enable_rf_tx+0x46>
   40fa4:	00070048 	.word	0x00070048
   40fa8:	02003c00 	.word	0x02003c00
   40fac:	01011100 	.word	0x01011100
   40fb0:	00070014 	.word	0x00070014

00040fb4 <ull_enable_rftx_blocks>:
   40fb4:	b500      	push	{lr}
   40fb6:	b083      	sub	sp, #12
   40fb8:	4b05      	ldr	r3, [pc, #20]	; (40fd0 <ull_enable_rftx_blocks+0x1c>)
   40fba:	9300      	str	r3, [sp, #0]
   40fbc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40fc0:	2200      	movs	r2, #0
   40fc2:	4904      	ldr	r1, [pc, #16]	; (40fd4 <ull_enable_rftx_blocks+0x20>)
   40fc4:	f7ff ff8e 	bl	40ee4 <dwt_modify32bitoffsetreg>
   40fc8:	b003      	add	sp, #12
   40fca:	f85d fb04 	ldr.w	pc, [sp], #4
   40fce:	bf00      	nop
   40fd0:	02003c00 	.word	0x02003c00
   40fd4:	00070004 	.word	0x00070004

00040fd8 <_dwt_otpprogword32>:
   40fd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   40fdc:	b083      	sub	sp, #12
   40fde:	4604      	mov	r4, r0
   40fe0:	460d      	mov	r5, r1
   40fe2:	4617      	mov	r7, r2
   40fe4:	4e56      	ldr	r6, [pc, #344]	; (41140 <_dwt_otpprogword32+0x168>)
   40fe6:	2200      	movs	r2, #0
   40fe8:	4631      	mov	r1, r6
   40fea:	f7fe fd96 	bl	3fb1a <dwt_read32bitoffsetreg>
   40fee:	4681      	mov	r9, r0
   40ff0:	f44f 4370 	mov.w	r3, #61440	; 0xf000
   40ff4:	9300      	str	r3, [sp, #0]
   40ff6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   40ffa:	2200      	movs	r2, #0
   40ffc:	4631      	mov	r1, r6
   40ffe:	4620      	mov	r0, r4
   41000:	f7ff ff70 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41004:	f8df 813c 	ldr.w	r8, [pc, #316]	; 41144 <_dwt_otpprogword32+0x16c>
   41008:	2318      	movs	r3, #24
   4100a:	2200      	movs	r2, #0
   4100c:	4641      	mov	r1, r8
   4100e:	4620      	mov	r0, r4
   41010:	f7ff f9f7 	bl	40402 <dwt_write16bitoffsetreg>
   41014:	2125      	movs	r1, #37	; 0x25
   41016:	4620      	mov	r0, r4
   41018:	f7ff fa28 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4101c:	2102      	movs	r1, #2
   4101e:	4620      	mov	r0, r4
   41020:	f7ff fa24 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41024:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
   41028:	4620      	mov	r0, r4
   4102a:	f7ff fa1f 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4102e:	b2f9      	uxtb	r1, r7
   41030:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   41034:	4620      	mov	r0, r4
   41036:	f7ff fa19 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4103a:	f44f 7180 	mov.w	r1, #256	; 0x100
   4103e:	4620      	mov	r0, r4
   41040:	f7ff fa14 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41044:	2100      	movs	r1, #0
   41046:	4620      	mov	r0, r4
   41048:	f7ff fa10 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4104c:	2102      	movs	r1, #2
   4104e:	4620      	mov	r0, r4
   41050:	f7ff fa0c 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41054:	f44f 71e0 	mov.w	r1, #448	; 0x1c0
   41058:	4620      	mov	r0, r4
   4105a:	f7ff fa07 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4105e:	b2e9      	uxtb	r1, r5
   41060:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   41064:	4620      	mov	r0, r4
   41066:	f7ff fa01 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4106a:	f3c5 2107 	ubfx	r1, r5, #8, #8
   4106e:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   41072:	4620      	mov	r0, r4
   41074:	f7ff f9fa 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41078:	f3c5 4107 	ubfx	r1, r5, #16, #8
   4107c:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   41080:	4620      	mov	r0, r4
   41082:	f7ff f9f3 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41086:	0e29      	lsrs	r1, r5, #24
   41088:	f441 7180 	orr.w	r1, r1, #256	; 0x100
   4108c:	4620      	mov	r0, r4
   4108e:	f7ff f9ed 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41092:	2100      	movs	r1, #0
   41094:	4620      	mov	r0, r4
   41096:	f7ff f9e9 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   4109a:	213a      	movs	r1, #58	; 0x3a
   4109c:	4620      	mov	r0, r4
   4109e:	f7ff f9e5 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410a2:	f240 11ff 	movw	r1, #511	; 0x1ff
   410a6:	4620      	mov	r0, r4
   410a8:	f7ff f9e0 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410ac:	f44f 7185 	mov.w	r1, #266	; 0x10a
   410b0:	4620      	mov	r0, r4
   410b2:	f7ff f9db 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410b6:	2100      	movs	r1, #0
   410b8:	4620      	mov	r0, r4
   410ba:	f7ff f9d7 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410be:	213a      	movs	r1, #58	; 0x3a
   410c0:	4620      	mov	r0, r4
   410c2:	f7ff f9d3 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410c6:	f240 1101 	movw	r1, #257	; 0x101
   410ca:	4620      	mov	r0, r4
   410cc:	f7ff f9ce 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410d0:	2302      	movs	r3, #2
   410d2:	2200      	movs	r2, #0
   410d4:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   410d8:	4620      	mov	r0, r4
   410da:	f7ff f992 	bl	40402 <dwt_write16bitoffsetreg>
   410de:	2300      	movs	r3, #0
   410e0:	461a      	mov	r2, r3
   410e2:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   410e6:	4620      	mov	r0, r4
   410e8:	f7ff f98b 	bl	40402 <dwt_write16bitoffsetreg>
   410ec:	2002      	movs	r0, #2
   410ee:	f7ed fb6e 	bl	2e7ce <deca_sleep>
   410f2:	213a      	movs	r1, #58	; 0x3a
   410f4:	4620      	mov	r0, r4
   410f6:	f7ff f9b9 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   410fa:	f44f 7181 	mov.w	r1, #258	; 0x102
   410fe:	4620      	mov	r0, r4
   41100:	f7ff f9b4 	bl	4046c <__dwt_otp_write_wdata_id_reg>
   41104:	2302      	movs	r3, #2
   41106:	2200      	movs	r2, #0
   41108:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   4110c:	4620      	mov	r0, r4
   4110e:	f7ff f978 	bl	40402 <dwt_write16bitoffsetreg>
   41112:	2300      	movs	r3, #0
   41114:	461a      	mov	r2, r3
   41116:	f44f 2130 	mov.w	r1, #720896	; 0xb0000
   4111a:	4620      	mov	r0, r4
   4111c:	f7ff f971 	bl	40402 <dwt_write16bitoffsetreg>
   41120:	2300      	movs	r3, #0
   41122:	461a      	mov	r2, r3
   41124:	4641      	mov	r1, r8
   41126:	4620      	mov	r0, r4
   41128:	f7ff f96b 	bl	40402 <dwt_write16bitoffsetreg>
   4112c:	464b      	mov	r3, r9
   4112e:	2200      	movs	r2, #0
   41130:	4631      	mov	r1, r6
   41132:	4620      	mov	r0, r4
   41134:	f7ff f9d0 	bl	404d8 <dwt_write32bitoffsetreg>
   41138:	b003      	add	sp, #12
   4113a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   4113e:	bf00      	nop
   41140:	00070044 	.word	0x00070044
   41144:	000b0008 	.word	0x000b0008

00041148 <ull_setgpiomode>:
   41148:	b5f0      	push	{r4, r5, r6, r7, lr}
   4114a:	b083      	sub	sp, #12
   4114c:	2400      	movs	r4, #0
   4114e:	4623      	mov	r3, r4
   41150:	2601      	movs	r6, #1
   41152:	2707      	movs	r7, #7
   41154:	e002      	b.n	4115c <ull_setgpiomode+0x14>
   41156:	3401      	adds	r4, #1
   41158:	2c09      	cmp	r4, #9
   4115a:	d009      	beq.n	41170 <ull_setgpiomode+0x28>
   4115c:	fa06 f504 	lsl.w	r5, r6, r4
   41160:	420d      	tst	r5, r1
   41162:	d0f8      	beq.n	41156 <ull_setgpiomode+0xe>
   41164:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   41168:	fa07 f505 	lsl.w	r5, r7, r5
   4116c:	432b      	orrs	r3, r5
   4116e:	e7f2      	b.n	41156 <ull_setgpiomode+0xe>
   41170:	401a      	ands	r2, r3
   41172:	9200      	str	r2, [sp, #0]
   41174:	43db      	mvns	r3, r3
   41176:	2200      	movs	r2, #0
   41178:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   4117c:	f7ff feb2 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41180:	b003      	add	sp, #12
   41182:	bdf0      	pop	{r4, r5, r6, r7, pc}

00041184 <ull_writetxfctrl>:
   41184:	b500      	push	{lr}
   41186:	b083      	sub	sp, #12
   41188:	2a7f      	cmp	r2, #127	; 0x7f
   4118a:	bf88      	it	hi
   4118c:	3280      	addhi	r2, #128	; 0x80
   4118e:	ea41 21c3 	orr.w	r1, r1, r3, lsl #11
   41192:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
   41196:	9100      	str	r1, [sp, #0]
   41198:	4b03      	ldr	r3, [pc, #12]	; (411a8 <ull_writetxfctrl+0x24>)
   4119a:	2200      	movs	r2, #0
   4119c:	2120      	movs	r1, #32
   4119e:	f7ff fea1 	bl	40ee4 <dwt_modify32bitoffsetreg>
   411a2:	b003      	add	sp, #12
   411a4:	f85d fb04 	ldr.w	pc, [sp], #4
   411a8:	fc00f400 	.word	0xfc00f400

000411ac <prs_sys_status_and_or>:
   411ac:	b500      	push	{lr}
   411ae:	b083      	sub	sp, #12
   411b0:	9200      	str	r2, [sp, #0]
   411b2:	460b      	mov	r3, r1
   411b4:	2200      	movs	r2, #0
   411b6:	2144      	movs	r1, #68	; 0x44
   411b8:	f7ff fe94 	bl	40ee4 <dwt_modify32bitoffsetreg>
   411bc:	2000      	movs	r0, #0
   411be:	b003      	add	sp, #12
   411c0:	f85d fb04 	ldr.w	pc, [sp], #4

000411c4 <dwt_modify8bitoffsetreg>:
   411c4:	b500      	push	{lr}
   411c6:	b085      	sub	sp, #20
   411c8:	f88d 300c 	strb.w	r3, [sp, #12]
   411cc:	f89d 3018 	ldrb.w	r3, [sp, #24]
   411d0:	f88d 300d 	strb.w	r3, [sp, #13]
   411d4:	f248 0301 	movw	r3, #32769	; 0x8001
   411d8:	9301      	str	r3, [sp, #4]
   411da:	ab03      	add	r3, sp, #12
   411dc:	9300      	str	r3, [sp, #0]
   411de:	2302      	movs	r3, #2
   411e0:	b292      	uxth	r2, r2
   411e2:	f7fe fc12 	bl	3fa0a <dwt_xfer3xxx>
   411e6:	b005      	add	sp, #20
   411e8:	f85d fb04 	ldr.w	pc, [sp], #4

000411ec <ull_enablespicrccheck>:
   411ec:	b570      	push	{r4, r5, r6, lr}
   411ee:	b082      	sub	sp, #8
   411f0:	4604      	mov	r4, r0
   411f2:	460d      	mov	r5, r1
   411f4:	b159      	cbz	r1, 4120e <ull_enablespicrccheck+0x22>
   411f6:	4616      	mov	r6, r2
   411f8:	2340      	movs	r3, #64	; 0x40
   411fa:	9300      	str	r3, [sp, #0]
   411fc:	23ff      	movs	r3, #255	; 0xff
   411fe:	2200      	movs	r2, #0
   41200:	2110      	movs	r1, #16
   41202:	f7ff ffdf 	bl	411c4 <dwt_modify8bitoffsetreg>
   41206:	2d02      	cmp	r5, #2
   41208:	d107      	bne.n	4121a <ull_enablespicrccheck+0x2e>
   4120a:	60e6      	str	r6, [r4, #12]
   4120c:	e005      	b.n	4121a <ull_enablespicrccheck+0x2e>
   4120e:	2200      	movs	r2, #0
   41210:	9200      	str	r2, [sp, #0]
   41212:	23bf      	movs	r3, #191	; 0xbf
   41214:	2110      	movs	r1, #16
   41216:	f7ff ffd5 	bl	411c4 <dwt_modify8bitoffsetreg>
   4121a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   4121c:	751d      	strb	r5, [r3, #20]
   4121e:	b002      	add	sp, #8
   41220:	bd70      	pop	{r4, r5, r6, pc}
	...

00041224 <ull_configciadiag>:
   41224:	b530      	push	{r4, r5, lr}
   41226:	b083      	sub	sp, #12
   41228:	4604      	mov	r4, r0
   4122a:	460d      	mov	r5, r1
   4122c:	f011 0f01 	tst.w	r1, #1
   41230:	d015      	beq.n	4125e <ull_configciadiag+0x3a>
   41232:	2300      	movs	r3, #0
   41234:	9300      	str	r3, [sp, #0]
   41236:	23ef      	movs	r3, #239	; 0xef
   41238:	2202      	movs	r2, #2
   4123a:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   4123e:	f7ff ffc1 	bl	411c4 <dwt_modify8bitoffsetreg>
   41242:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41244:	759d      	strb	r5, [r3, #22]
   41246:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41248:	7d9b      	ldrb	r3, [r3, #22]
   4124a:	085b      	lsrs	r3, r3, #1
   4124c:	d010      	beq.n	41270 <ull_configciadiag+0x4c>
   4124e:	086b      	lsrs	r3, r5, #1
   41250:	2200      	movs	r2, #0
   41252:	490e      	ldr	r1, [pc, #56]	; (4128c <ull_configciadiag+0x68>)
   41254:	4620      	mov	r0, r4
   41256:	f7ff fb23 	bl	408a0 <dwt_write8bitoffsetreg>
   4125a:	b003      	add	sp, #12
   4125c:	bd30      	pop	{r4, r5, pc}
   4125e:	2310      	movs	r3, #16
   41260:	9300      	str	r3, [sp, #0]
   41262:	23ff      	movs	r3, #255	; 0xff
   41264:	2202      	movs	r2, #2
   41266:	f44f 2160 	mov.w	r1, #917504	; 0xe0000
   4126a:	f7ff ffab 	bl	411c4 <dwt_modify8bitoffsetreg>
   4126e:	e7e8      	b.n	41242 <ull_configciadiag+0x1e>
   41270:	2301      	movs	r3, #1
   41272:	9300      	str	r3, [sp, #0]
   41274:	23ff      	movs	r3, #255	; 0xff
   41276:	2200      	movs	r2, #0
   41278:	4904      	ldr	r1, [pc, #16]	; (4128c <ull_configciadiag+0x68>)
   4127a:	4620      	mov	r0, r4
   4127c:	f7ff ffa2 	bl	411c4 <dwt_modify8bitoffsetreg>
   41280:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41282:	7d93      	ldrb	r3, [r2, #22]
   41284:	f043 0302 	orr.w	r3, r3, #2
   41288:	7593      	strb	r3, [r2, #22]
   4128a:	e7e6      	b.n	4125a <ull_configciadiag+0x36>
   4128c:	00010020 	.word	0x00010020

00041290 <ull_configurestsloadiv>:
   41290:	b500      	push	{lr}
   41292:	b083      	sub	sp, #12
   41294:	2301      	movs	r3, #1
   41296:	9300      	str	r3, [sp, #0]
   41298:	23ff      	movs	r3, #255	; 0xff
   4129a:	2200      	movs	r2, #0
   4129c:	4902      	ldr	r1, [pc, #8]	; (412a8 <ull_configurestsloadiv+0x18>)
   4129e:	f7ff ff91 	bl	411c4 <dwt_modify8bitoffsetreg>
   412a2:	b003      	add	sp, #12
   412a4:	f85d fb04 	ldr.w	pc, [sp], #4
   412a8:	00020004 	.word	0x00020004

000412ac <ull_adcoffsetscalibration>:
   412ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   412b0:	b08b      	sub	sp, #44	; 0x2c
   412b2:	4607      	mov	r7, r0
   412b4:	f8df 8220 	ldr.w	r8, [pc, #544]	; 414d8 <ull_adcoffsetscalibration+0x22c>
   412b8:	2200      	movs	r2, #0
   412ba:	4641      	mov	r1, r8
   412bc:	f7fe fc2d 	bl	3fb1a <dwt_read32bitoffsetreg>
   412c0:	9004      	str	r0, [sp, #16]
   412c2:	4c7d      	ldr	r4, [pc, #500]	; (414b8 <ull_adcoffsetscalibration+0x20c>)
   412c4:	2200      	movs	r2, #0
   412c6:	4621      	mov	r1, r4
   412c8:	4638      	mov	r0, r7
   412ca:	f7fe fc26 	bl	3fb1a <dwt_read32bitoffsetreg>
   412ce:	9005      	str	r0, [sp, #20]
   412d0:	4d7a      	ldr	r5, [pc, #488]	; (414bc <ull_adcoffsetscalibration+0x210>)
   412d2:	2200      	movs	r2, #0
   412d4:	4629      	mov	r1, r5
   412d6:	4638      	mov	r0, r7
   412d8:	f7fe fc74 	bl	3fbc4 <dwt_read8bitoffsetreg>
   412dc:	9006      	str	r0, [sp, #24]
   412de:	4e78      	ldr	r6, [pc, #480]	; (414c0 <ull_adcoffsetscalibration+0x214>)
   412e0:	2200      	movs	r2, #0
   412e2:	4631      	mov	r1, r6
   412e4:	4638      	mov	r0, r7
   412e6:	f7fe fc18 	bl	3fb1a <dwt_read32bitoffsetreg>
   412ea:	4682      	mov	sl, r0
   412ec:	9007      	str	r0, [sp, #28]
   412ee:	2200      	movs	r2, #0
   412f0:	4974      	ldr	r1, [pc, #464]	; (414c4 <ull_adcoffsetscalibration+0x218>)
   412f2:	4638      	mov	r0, r7
   412f4:	f7fe fc11 	bl	3fb1a <dwt_read32bitoffsetreg>
   412f8:	4681      	mov	r9, r0
   412fa:	4b73      	ldr	r3, [pc, #460]	; (414c8 <ull_adcoffsetscalibration+0x21c>)
   412fc:	9300      	str	r3, [sp, #0]
   412fe:	f06f 537c 	mvn.w	r3, #1056964608	; 0x3f000000
   41302:	2200      	movs	r2, #0
   41304:	4641      	mov	r1, r8
   41306:	4638      	mov	r0, r7
   41308:	f7ff fdec 	bl	40ee4 <dwt_modify32bitoffsetreg>
   4130c:	464b      	mov	r3, r9
   4130e:	2200      	movs	r2, #0
   41310:	4631      	mov	r1, r6
   41312:	4638      	mov	r0, r7
   41314:	f7ff f8e0 	bl	404d8 <dwt_write32bitoffsetreg>
   41318:	4653      	mov	r3, sl
   4131a:	00db      	lsls	r3, r3, #3
   4131c:	f003 0338 	and.w	r3, r3, #56	; 0x38
   41320:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   41324:	9300      	str	r3, [sp, #0]
   41326:	2386      	movs	r3, #134	; 0x86
   41328:	2200      	movs	r2, #0
   4132a:	4621      	mov	r1, r4
   4132c:	4638      	mov	r0, r7
   4132e:	f7ff ff49 	bl	411c4 <dwt_modify8bitoffsetreg>
   41332:	2300      	movs	r3, #0
   41334:	2203      	movs	r2, #3
   41336:	4621      	mov	r1, r4
   41338:	4638      	mov	r0, r7
   4133a:	f7ff fab1 	bl	408a0 <dwt_write8bitoffsetreg>
   4133e:	f04f 0900 	mov.w	r9, #0
   41342:	f8cd 9000 	str.w	r9, [sp]
   41346:	23fe      	movs	r3, #254	; 0xfe
   41348:	464a      	mov	r2, r9
   4134a:	4629      	mov	r1, r5
   4134c:	4638      	mov	r0, r7
   4134e:	f7ff ff39 	bl	411c4 <dwt_modify8bitoffsetreg>
   41352:	464a      	mov	r2, r9
   41354:	213c      	movs	r1, #60	; 0x3c
   41356:	4638      	mov	r0, r7
   41358:	f7fe fbdf 	bl	3fb1a <dwt_read32bitoffsetreg>
   4135c:	9008      	str	r0, [sp, #32]
   4135e:	464a      	mov	r2, r9
   41360:	2140      	movs	r1, #64	; 0x40
   41362:	4638      	mov	r0, r7
   41364:	f7fe fbd9 	bl	3fb1a <dwt_read32bitoffsetreg>
   41368:	9009      	str	r0, [sp, #36]	; 0x24
   4136a:	464b      	mov	r3, r9
   4136c:	464a      	mov	r2, r9
   4136e:	213c      	movs	r1, #60	; 0x3c
   41370:	4638      	mov	r0, r7
   41372:	f7ff f8b1 	bl	404d8 <dwt_write32bitoffsetreg>
   41376:	464b      	mov	r3, r9
   41378:	464a      	mov	r2, r9
   4137a:	2140      	movs	r1, #64	; 0x40
   4137c:	4638      	mov	r0, r7
   4137e:	f7ff f8ab 	bl	404d8 <dwt_write32bitoffsetreg>
   41382:	f7f5 fee1 	bl	37148 <dwt_forcetrxoff>
   41386:	f04f 0b02 	mov.w	fp, #2
   4138a:	464c      	mov	r4, r9
   4138c:	464d      	mov	r5, r9
   4138e:	464e      	mov	r6, r9
   41390:	46c8      	mov	r8, r9
   41392:	f8cd 900c 	str.w	r9, [sp, #12]
   41396:	46ca      	mov	sl, r9
   41398:	e00e      	b.n	413b8 <ull_adcoffsetscalibration+0x10c>
   4139a:	f7f5 fed5 	bl	37148 <dwt_forcetrxoff>
   4139e:	9b03      	ldr	r3, [sp, #12]
   413a0:	2b00      	cmp	r3, #0
   413a2:	f000 8082 	beq.w	414aa <ull_adcoffsetscalibration+0x1fe>
   413a6:	f1bb 0f01 	cmp.w	fp, #1
   413aa:	f000 8081 	beq.w	414b0 <ull_adcoffsetscalibration+0x204>
   413ae:	2301      	movs	r3, #1
   413b0:	9303      	str	r3, [sp, #12]
   413b2:	f1bb 0b01 	subs.w	fp, fp, #1
   413b6:	d043      	beq.n	41440 <ull_adcoffsetscalibration+0x194>
   413b8:	4650      	mov	r0, sl
   413ba:	f7f5 fed3 	bl	37164 <dwt_rxenable>
   413be:	2014      	movs	r0, #20
   413c0:	f7ed fa15 	bl	2e7ee <deca_usleep>
   413c4:	f04f 0904 	mov.w	r9, #4
   413c8:	f8cd a000 	str.w	sl, [sp]
   413cc:	23fe      	movs	r3, #254	; 0xfe
   413ce:	4652      	mov	r2, sl
   413d0:	f44f 3140 	mov.w	r1, #196608	; 0x30000
   413d4:	4638      	mov	r0, r7
   413d6:	f7ff fef5 	bl	411c4 <dwt_modify8bitoffsetreg>
   413da:	2301      	movs	r3, #1
   413dc:	9300      	str	r3, [sp, #0]
   413de:	23fe      	movs	r3, #254	; 0xfe
   413e0:	4652      	mov	r2, sl
   413e2:	f44f 3140 	mov.w	r1, #196608	; 0x30000
   413e6:	4638      	mov	r0, r7
   413e8:	f7ff feec 	bl	411c4 <dwt_modify8bitoffsetreg>
   413ec:	4652      	mov	r2, sl
   413ee:	4937      	ldr	r1, [pc, #220]	; (414cc <ull_adcoffsetscalibration+0x220>)
   413f0:	4638      	mov	r0, r7
   413f2:	f7fe fb92 	bl	3fb1a <dwt_read32bitoffsetreg>
   413f6:	fa58 f880 	uxtab	r8, r8, r0
   413fa:	fa1f f888 	uxth.w	r8, r8
   413fe:	f3c0 2307 	ubfx	r3, r0, #8, #8
   41402:	441e      	add	r6, r3
   41404:	b2b6      	uxth	r6, r6
   41406:	f3c0 4307 	ubfx	r3, r0, #16, #8
   4140a:	441d      	add	r5, r3
   4140c:	b2ad      	uxth	r5, r5
   4140e:	eb04 6410 	add.w	r4, r4, r0, lsr #24
   41412:	b2a4      	uxth	r4, r4
   41414:	f1b9 0901 	subs.w	r9, r9, #1
   41418:	d1d6      	bne.n	413c8 <ull_adcoffsetscalibration+0x11c>
   4141a:	f3c8 0887 	ubfx	r8, r8, #2, #8
   4141e:	f3c6 0687 	ubfx	r6, r6, #2, #8
   41422:	f3c5 0587 	ubfx	r5, r5, #2, #8
   41426:	f3c4 0487 	ubfx	r4, r4, #2, #8
   4142a:	4652      	mov	r2, sl
   4142c:	2144      	movs	r1, #68	; 0x44
   4142e:	4638      	mov	r0, r7
   41430:	f7fe fb73 	bl	3fb1a <dwt_read32bitoffsetreg>
   41434:	4b26      	ldr	r3, [pc, #152]	; (414d0 <ull_adcoffsetscalibration+0x224>)
   41436:	4218      	tst	r0, r3
   41438:	d0af      	beq.n	4139a <ull_adcoffsetscalibration+0xee>
   4143a:	f7f5 fe85 	bl	37148 <dwt_forcetrxoff>
   4143e:	e7b2      	b.n	413a6 <ull_adcoffsetscalibration+0xfa>
   41440:	f04f 0900 	mov.w	r9, #0
   41444:	9b08      	ldr	r3, [sp, #32]
   41446:	2200      	movs	r2, #0
   41448:	213c      	movs	r1, #60	; 0x3c
   4144a:	4638      	mov	r0, r7
   4144c:	f7ff f844 	bl	404d8 <dwt_write32bitoffsetreg>
   41450:	9b09      	ldr	r3, [sp, #36]	; 0x24
   41452:	2200      	movs	r2, #0
   41454:	2140      	movs	r1, #64	; 0x40
   41456:	4638      	mov	r0, r7
   41458:	f7ff f83e 	bl	404d8 <dwt_write32bitoffsetreg>
   4145c:	042b      	lsls	r3, r5, #16
   4145e:	eb03 6304 	add.w	r3, r3, r4, lsl #24
   41462:	eb03 2306 	add.w	r3, r3, r6, lsl #8
   41466:	4443      	add	r3, r8
   41468:	2200      	movs	r2, #0
   4146a:	491a      	ldr	r1, [pc, #104]	; (414d4 <ull_adcoffsetscalibration+0x228>)
   4146c:	4638      	mov	r0, r7
   4146e:	f7ff f833 	bl	404d8 <dwt_write32bitoffsetreg>
   41472:	9b04      	ldr	r3, [sp, #16]
   41474:	2200      	movs	r2, #0
   41476:	4918      	ldr	r1, [pc, #96]	; (414d8 <ull_adcoffsetscalibration+0x22c>)
   41478:	4638      	mov	r0, r7
   4147a:	f7ff f82d 	bl	404d8 <dwt_write32bitoffsetreg>
   4147e:	9b05      	ldr	r3, [sp, #20]
   41480:	2200      	movs	r2, #0
   41482:	490d      	ldr	r1, [pc, #52]	; (414b8 <ull_adcoffsetscalibration+0x20c>)
   41484:	4638      	mov	r0, r7
   41486:	f7ff f827 	bl	404d8 <dwt_write32bitoffsetreg>
   4148a:	9b06      	ldr	r3, [sp, #24]
   4148c:	2200      	movs	r2, #0
   4148e:	490b      	ldr	r1, [pc, #44]	; (414bc <ull_adcoffsetscalibration+0x210>)
   41490:	4638      	mov	r0, r7
   41492:	f7ff fa05 	bl	408a0 <dwt_write8bitoffsetreg>
   41496:	9b07      	ldr	r3, [sp, #28]
   41498:	2200      	movs	r2, #0
   4149a:	4909      	ldr	r1, [pc, #36]	; (414c0 <ull_adcoffsetscalibration+0x214>)
   4149c:	4638      	mov	r0, r7
   4149e:	f7ff f81b 	bl	404d8 <dwt_write32bitoffsetreg>
   414a2:	4648      	mov	r0, r9
   414a4:	b00b      	add	sp, #44	; 0x2c
   414a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   414aa:	f04f 0900 	mov.w	r9, #0
   414ae:	e7c9      	b.n	41444 <ull_adcoffsetscalibration+0x198>
   414b0:	f06f 0905 	mvn.w	r9, #5
   414b4:	e7c6      	b.n	41444 <ull_adcoffsetscalibration+0x198>
   414b6:	bf00      	nop
   414b8:	00030014 	.word	0x00030014
   414bc:	00030018 	.word	0x00030018
   414c0:	0003002c 	.word	0x0003002c
   414c4:	00030044 	.word	0x00030044
   414c8:	38010000 	.word	0x38010000
   414cc:	0003004c 	.word	0x0003004c
   414d0:	3427ff00 	.word	0x3427ff00
   414d4:	00030010 	.word	0x00030010
   414d8:	00070014 	.word	0x00070014

000414dc <ull_restoreconfig>:
   414dc:	b510      	push	{r4, lr}
   414de:	4604      	mov	r4, r0
   414e0:	6d03      	ldr	r3, [r0, #80]	; 0x50
   414e2:	7d9b      	ldrb	r3, [r3, #22]
   414e4:	085b      	lsrs	r3, r3, #1
   414e6:	d01a      	beq.n	4151e <ull_restoreconfig+0x42>
   414e8:	2200      	movs	r2, #0
   414ea:	4912      	ldr	r1, [pc, #72]	; (41534 <ull_restoreconfig+0x58>)
   414ec:	4620      	mov	r0, r4
   414ee:	f7fe fb2a 	bl	3fb46 <dwt_read16bitoffsetreg>
   414f2:	f3c0 03c4 	ubfx	r3, r0, #3, #5
   414f6:	3b09      	subs	r3, #9
   414f8:	2b0f      	cmp	r3, #15
   414fa:	d80c      	bhi.n	41516 <ull_restoreconfig+0x3a>
   414fc:	f000 0001 	and.w	r0, r0, #1
   41500:	2800      	cmp	r0, #0
   41502:	bf0c      	ite	eq
   41504:	2105      	moveq	r1, #5
   41506:	2109      	movne	r1, #9
   41508:	6d23      	ldr	r3, [r4, #80]	; 0x50
   4150a:	7a1b      	ldrb	r3, [r3, #8]
   4150c:	2b01      	cmp	r3, #1
   4150e:	d002      	beq.n	41516 <ull_restoreconfig+0x3a>
   41510:	4620      	mov	r0, r4
   41512:	f7ff f8ad 	bl	40670 <ull_configmrxlut>
   41516:	4620      	mov	r0, r4
   41518:	f7ff fec8 	bl	412ac <ull_adcoffsetscalibration>
   4151c:	bd10      	pop	{r4, pc}
   4151e:	2301      	movs	r3, #1
   41520:	2200      	movs	r2, #0
   41522:	4905      	ldr	r1, [pc, #20]	; (41538 <ull_restoreconfig+0x5c>)
   41524:	f7ff f9bc 	bl	408a0 <dwt_write8bitoffsetreg>
   41528:	6d22      	ldr	r2, [r4, #80]	; 0x50
   4152a:	7d93      	ldrb	r3, [r2, #22]
   4152c:	f043 0302 	orr.w	r3, r3, #2
   41530:	7593      	strb	r3, [r2, #22]
   41532:	e7d9      	b.n	414e8 <ull_restoreconfig+0xc>
   41534:	00010008 	.word	0x00010008
   41538:	00010020 	.word	0x00010020

0004153c <ull_calcbandwidthadj>:
   4153c:	b570      	push	{r4, r5, r6, lr}
   4153e:	b082      	sub	sp, #8
   41540:	4604      	mov	r4, r0
   41542:	460d      	mov	r5, r1
   41544:	2101      	movs	r1, #1
   41546:	f7fe ff7b 	bl	40440 <ull_force_clocks>
   4154a:	2100      	movs	r1, #0
   4154c:	4620      	mov	r0, r4
   4154e:	f7ff fcfd 	bl	40f4c <ull_enable_rf_tx>
   41552:	4620      	mov	r0, r4
   41554:	f7ff fd2e 	bl	40fb4 <ull_enable_rftx_blocks>
   41558:	f3c5 030b 	ubfx	r3, r5, #0, #12
   4155c:	2200      	movs	r2, #0
   4155e:	4915      	ldr	r1, [pc, #84]	; (415b4 <ull_calcbandwidthadj+0x78>)
   41560:	4620      	mov	r0, r4
   41562:	f7fe ff4e 	bl	40402 <dwt_write16bitoffsetreg>
   41566:	2303      	movs	r3, #3
   41568:	9300      	str	r3, [sp, #0]
   4156a:	23ff      	movs	r3, #255	; 0xff
   4156c:	2200      	movs	r2, #0
   4156e:	4912      	ldr	r1, [pc, #72]	; (415b8 <ull_calcbandwidthadj+0x7c>)
   41570:	4620      	mov	r0, r4
   41572:	f7ff fe27 	bl	411c4 <dwt_modify8bitoffsetreg>
   41576:	4e10      	ldr	r6, [pc, #64]	; (415b8 <ull_calcbandwidthadj+0x7c>)
   41578:	2500      	movs	r5, #0
   4157a:	462a      	mov	r2, r5
   4157c:	4631      	mov	r1, r6
   4157e:	4620      	mov	r0, r4
   41580:	f7fe fb20 	bl	3fbc4 <dwt_read8bitoffsetreg>
   41584:	f010 0f01 	tst.w	r0, #1
   41588:	d1f7      	bne.n	4157a <ull_calcbandwidthadj+0x3e>
   4158a:	4620      	mov	r0, r4
   4158c:	f7ff f906 	bl	4079c <ull_disable_rftx_blocks>
   41590:	2100      	movs	r1, #0
   41592:	4620      	mov	r0, r4
   41594:	f7ff f90c 	bl	407b0 <ull_disable_rf_tx>
   41598:	2105      	movs	r1, #5
   4159a:	4620      	mov	r0, r4
   4159c:	f7fe ff50 	bl	40440 <ull_force_clocks>
   415a0:	2200      	movs	r2, #0
   415a2:	4906      	ldr	r1, [pc, #24]	; (415bc <ull_calcbandwidthadj+0x80>)
   415a4:	4620      	mov	r0, r4
   415a6:	f7fe fb0d 	bl	3fbc4 <dwt_read8bitoffsetreg>
   415aa:	f000 003f 	and.w	r0, r0, #63	; 0x3f
   415ae:	b002      	add	sp, #8
   415b0:	bd70      	pop	{r4, r5, r6, pc}
   415b2:	bf00      	nop
   415b4:	0008001c 	.word	0x0008001c
   415b8:	00080010 	.word	0x00080010
   415bc:	0007001c 	.word	0x0007001c

000415c0 <ull_configuretxrf>:
   415c0:	b538      	push	{r3, r4, r5, lr}
   415c2:	4605      	mov	r5, r0
   415c4:	460c      	mov	r4, r1
   415c6:	f8b1 1005 	ldrh.w	r1, [r1, #5]
   415ca:	b149      	cbz	r1, 415e0 <ull_configuretxrf+0x20>
   415cc:	f7ff ffb6 	bl	4153c <ull_calcbandwidthadj>
   415d0:	f8d4 3001 	ldr.w	r3, [r4, #1]
   415d4:	2200      	movs	r2, #0
   415d6:	4905      	ldr	r1, [pc, #20]	; (415ec <ull_configuretxrf+0x2c>)
   415d8:	4628      	mov	r0, r5
   415da:	f7fe ff7d 	bl	404d8 <dwt_write32bitoffsetreg>
   415de:	bd38      	pop	{r3, r4, r5, pc}
   415e0:	7823      	ldrb	r3, [r4, #0]
   415e2:	2200      	movs	r2, #0
   415e4:	4902      	ldr	r1, [pc, #8]	; (415f0 <ull_configuretxrf+0x30>)
   415e6:	f7ff f95b 	bl	408a0 <dwt_write8bitoffsetreg>
   415ea:	e7f1      	b.n	415d0 <ull_configuretxrf+0x10>
   415ec:	00010004 	.word	0x00010004
   415f0:	0007001c 	.word	0x0007001c

000415f4 <ull_repeated_frames>:
   415f4:	b530      	push	{r4, r5, lr}
   415f6:	b083      	sub	sp, #12
   415f8:	4604      	mov	r4, r0
   415fa:	460d      	mov	r5, r1
   415fc:	2310      	movs	r3, #16
   415fe:	9300      	str	r3, [sp, #0]
   41600:	23ff      	movs	r3, #255	; 0xff
   41602:	2200      	movs	r2, #0
   41604:	4906      	ldr	r1, [pc, #24]	; (41620 <ull_repeated_frames+0x2c>)
   41606:	f7ff fddd 	bl	411c4 <dwt_modify8bitoffsetreg>
   4160a:	462b      	mov	r3, r5
   4160c:	2d02      	cmp	r5, #2
   4160e:	bf38      	it	cc
   41610:	2302      	movcc	r3, #2
   41612:	2200      	movs	r2, #0
   41614:	2128      	movs	r1, #40	; 0x28
   41616:	4620      	mov	r0, r4
   41618:	f7fe ff5e 	bl	404d8 <dwt_write32bitoffsetreg>
   4161c:	b003      	add	sp, #12
   4161e:	bd30      	pop	{r4, r5, pc}
   41620:	000f0028 	.word	0x000f0028

00041624 <ull_setdwstate>:
   41624:	b530      	push	{r4, r5, lr}
   41626:	b083      	sub	sp, #12
   41628:	4604      	mov	r4, r0
   4162a:	2901      	cmp	r1, #1
   4162c:	d01d      	beq.n	4166a <ull_setdwstate+0x46>
   4162e:	2902      	cmp	r1, #2
   41630:	d030      	beq.n	41694 <ull_setdwstate+0x70>
   41632:	2301      	movs	r3, #1
   41634:	9300      	str	r3, [sp, #0]
   41636:	23ff      	movs	r3, #255	; 0xff
   41638:	2200      	movs	r2, #0
   4163a:	4926      	ldr	r1, [pc, #152]	; (416d4 <ull_setdwstate+0xb0>)
   4163c:	f7ff fdc2 	bl	411c4 <dwt_modify8bitoffsetreg>
   41640:	4d25      	ldr	r5, [pc, #148]	; (416d8 <ull_setdwstate+0xb4>)
   41642:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   41646:	9300      	str	r3, [sp, #0]
   41648:	f46f 7380 	mvn.w	r3, #256	; 0x100
   4164c:	2200      	movs	r2, #0
   4164e:	4629      	mov	r1, r5
   41650:	4620      	mov	r0, r4
   41652:	f7ff fc47 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41656:	2300      	movs	r3, #0
   41658:	9300      	str	r3, [sp, #0]
   4165a:	237f      	movs	r3, #127	; 0x7f
   4165c:	2202      	movs	r2, #2
   4165e:	4629      	mov	r1, r5
   41660:	4620      	mov	r0, r4
   41662:	f7ff fdaf 	bl	411c4 <dwt_modify8bitoffsetreg>
   41666:	b003      	add	sp, #12
   41668:	bd30      	pop	{r4, r5, pc}
   4166a:	2105      	movs	r1, #5
   4166c:	f7fe fee8 	bl	40440 <ull_force_clocks>
   41670:	f44f 7381 	mov.w	r3, #258	; 0x102
   41674:	9300      	str	r3, [sp, #0]
   41676:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4167a:	2200      	movs	r2, #0
   4167c:	4917      	ldr	r1, [pc, #92]	; (416dc <ull_setdwstate+0xb8>)
   4167e:	4620      	mov	r0, r4
   41680:	f7ff fc30 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41684:	2201      	movs	r2, #1
   41686:	9200      	str	r2, [sp, #0]
   41688:	23ff      	movs	r3, #255	; 0xff
   4168a:	4913      	ldr	r1, [pc, #76]	; (416d8 <ull_setdwstate+0xb4>)
   4168c:	4620      	mov	r0, r4
   4168e:	f7ff fd99 	bl	411c4 <dwt_modify8bitoffsetreg>
   41692:	e7e8      	b.n	41666 <ull_setdwstate+0x42>
   41694:	2303      	movs	r3, #3
   41696:	9300      	str	r3, [sp, #0]
   41698:	23ff      	movs	r3, #255	; 0xff
   4169a:	2200      	movs	r2, #0
   4169c:	490d      	ldr	r1, [pc, #52]	; (416d4 <ull_setdwstate+0xb0>)
   4169e:	f7ff fd91 	bl	411c4 <dwt_modify8bitoffsetreg>
   416a2:	4d0d      	ldr	r5, [pc, #52]	; (416d8 <ull_setdwstate+0xb4>)
   416a4:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
   416a8:	9300      	str	r3, [sp, #0]
   416aa:	f46f 7380 	mvn.w	r3, #256	; 0x100
   416ae:	2200      	movs	r2, #0
   416b0:	4629      	mov	r1, r5
   416b2:	4620      	mov	r0, r4
   416b4:	f7ff fc16 	bl	40ee4 <dwt_modify32bitoffsetreg>
   416b8:	2300      	movs	r3, #0
   416ba:	9300      	str	r3, [sp, #0]
   416bc:	237f      	movs	r3, #127	; 0x7f
   416be:	2202      	movs	r2, #2
   416c0:	4629      	mov	r1, r5
   416c2:	4620      	mov	r0, r4
   416c4:	f7ff fd7e 	bl	411c4 <dwt_modify8bitoffsetreg>
   416c8:	2105      	movs	r1, #5
   416ca:	4620      	mov	r0, r4
   416cc:	f7fe feb8 	bl	40440 <ull_force_clocks>
   416d0:	e7c9      	b.n	41666 <ull_setdwstate+0x42>
   416d2:	bf00      	nop
   416d4:	00110004 	.word	0x00110004
   416d8:	00110008 	.word	0x00110008
   416dc:	00090008 	.word	0x00090008

000416e0 <ull_configureframefilter>:
   416e0:	b530      	push	{r4, r5, lr}
   416e2:	b083      	sub	sp, #12
   416e4:	4605      	mov	r5, r0
   416e6:	2902      	cmp	r1, #2
   416e8:	d00e      	beq.n	41708 <ull_configureframefilter+0x28>
   416ea:	2400      	movs	r4, #0
   416ec:	9400      	str	r4, [sp, #0]
   416ee:	23fe      	movs	r3, #254	; 0xfe
   416f0:	4622      	mov	r2, r4
   416f2:	2110      	movs	r1, #16
   416f4:	f7ff fd66 	bl	411c4 <dwt_modify8bitoffsetreg>
   416f8:	4623      	mov	r3, r4
   416fa:	4622      	mov	r2, r4
   416fc:	2114      	movs	r1, #20
   416fe:	4628      	mov	r0, r5
   41700:	f7fe fe7f 	bl	40402 <dwt_write16bitoffsetreg>
   41704:	b003      	add	sp, #12
   41706:	bd30      	pop	{r4, r5, pc}
   41708:	4614      	mov	r4, r2
   4170a:	2301      	movs	r3, #1
   4170c:	9300      	str	r3, [sp, #0]
   4170e:	23ff      	movs	r3, #255	; 0xff
   41710:	2200      	movs	r2, #0
   41712:	2110      	movs	r1, #16
   41714:	f7ff fd56 	bl	411c4 <dwt_modify8bitoffsetreg>
   41718:	4623      	mov	r3, r4
   4171a:	2200      	movs	r2, #0
   4171c:	2114      	movs	r1, #20
   4171e:	4628      	mov	r0, r5
   41720:	f7fe fe6f 	bl	40402 <dwt_write16bitoffsetreg>
   41724:	e7ee      	b.n	41704 <ull_configureframefilter+0x24>
	...

00041728 <ull_run_pgfcal>:
   41728:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   4172c:	b082      	sub	sp, #8
   4172e:	4605      	mov	r5, r0
   41730:	4c2a      	ldr	r4, [pc, #168]	; (417dc <ull_run_pgfcal+0xb4>)
   41732:	2301      	movs	r3, #1
   41734:	9300      	str	r3, [sp, #0]
   41736:	23ff      	movs	r3, #255	; 0xff
   41738:	2200      	movs	r2, #0
   4173a:	4621      	mov	r1, r4
   4173c:	f7ff fd42 	bl	411c4 <dwt_modify8bitoffsetreg>
   41740:	2310      	movs	r3, #16
   41742:	9300      	str	r3, [sp, #0]
   41744:	23ff      	movs	r3, #255	; 0xff
   41746:	2200      	movs	r2, #0
   41748:	4621      	mov	r1, r4
   4174a:	4628      	mov	r0, r5
   4174c:	f7ff fd3a 	bl	411c4 <dwt_modify8bitoffsetreg>
   41750:	2403      	movs	r4, #3
   41752:	f04f 0814 	mov.w	r8, #20
   41756:	4f22      	ldr	r7, [pc, #136]	; (417e0 <ull_run_pgfcal+0xb8>)
   41758:	2600      	movs	r6, #0
   4175a:	4640      	mov	r0, r8
   4175c:	f7ed f847 	bl	2e7ee <deca_usleep>
   41760:	4632      	mov	r2, r6
   41762:	4639      	mov	r1, r7
   41764:	4628      	mov	r0, r5
   41766:	f7fe fa2d 	bl	3fbc4 <dwt_read8bitoffsetreg>
   4176a:	2801      	cmp	r0, #1
   4176c:	d034      	beq.n	417d8 <ull_run_pgfcal+0xb0>
   4176e:	1e63      	subs	r3, r4, #1
   41770:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   41774:	d1f1      	bne.n	4175a <ull_run_pgfcal+0x32>
   41776:	f06f 0402 	mvn.w	r4, #2
   4177a:	4e18      	ldr	r6, [pc, #96]	; (417dc <ull_run_pgfcal+0xb4>)
   4177c:	2300      	movs	r3, #0
   4177e:	461a      	mov	r2, r3
   41780:	4631      	mov	r1, r6
   41782:	4628      	mov	r0, r5
   41784:	f7ff f88c 	bl	408a0 <dwt_write8bitoffsetreg>
   41788:	2301      	movs	r3, #1
   4178a:	2200      	movs	r2, #0
   4178c:	4914      	ldr	r1, [pc, #80]	; (417e0 <ull_run_pgfcal+0xb8>)
   4178e:	4628      	mov	r0, r5
   41790:	f7ff f886 	bl	408a0 <dwt_write8bitoffsetreg>
   41794:	2301      	movs	r3, #1
   41796:	9300      	str	r3, [sp, #0]
   41798:	23ff      	movs	r3, #255	; 0xff
   4179a:	2202      	movs	r2, #2
   4179c:	4631      	mov	r1, r6
   4179e:	4628      	mov	r0, r5
   417a0:	f7ff fd10 	bl	411c4 <dwt_modify8bitoffsetreg>
   417a4:	2200      	movs	r2, #0
   417a6:	490f      	ldr	r1, [pc, #60]	; (417e4 <ull_run_pgfcal+0xbc>)
   417a8:	4628      	mov	r0, r5
   417aa:	f7fe f9b6 	bl	3fb1a <dwt_read32bitoffsetreg>
   417ae:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   417b2:	4298      	cmp	r0, r3
   417b4:	bf08      	it	eq
   417b6:	f06f 0403 	mvneq.w	r4, #3
   417ba:	2200      	movs	r2, #0
   417bc:	490a      	ldr	r1, [pc, #40]	; (417e8 <ull_run_pgfcal+0xc0>)
   417be:	4628      	mov	r0, r5
   417c0:	f7fe f9ab 	bl	3fb1a <dwt_read32bitoffsetreg>
   417c4:	f06f 4360 	mvn.w	r3, #3758096384	; 0xe0000000
   417c8:	4298      	cmp	r0, r3
   417ca:	bf14      	ite	ne
   417cc:	4620      	movne	r0, r4
   417ce:	f06f 0004 	mvneq.w	r0, #4
   417d2:	b002      	add	sp, #8
   417d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   417d8:	2400      	movs	r4, #0
   417da:	e7ce      	b.n	4177a <ull_run_pgfcal+0x52>
   417dc:	0004000c 	.word	0x0004000c
   417e0:	00040020 	.word	0x00040020
   417e4:	00040014 	.word	0x00040014
   417e8:	0004001c 	.word	0x0004001c

000417ec <ull_setinterrupt>:
   417ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   417f0:	b083      	sub	sp, #12
   417f2:	4605      	mov	r5, r0
   417f4:	4688      	mov	r8, r1
   417f6:	4617      	mov	r7, r2
   417f8:	461c      	mov	r4, r3
   417fa:	f7ec ffd5 	bl	2e7a8 <decamutexon>
   417fe:	4606      	mov	r6, r0
   41800:	2c02      	cmp	r4, #2
   41802:	d019      	beq.n	41838 <ull_setinterrupt+0x4c>
   41804:	2c04      	cmp	r4, #4
   41806:	d017      	beq.n	41838 <ull_setinterrupt+0x4c>
   41808:	f004 03fd 	and.w	r3, r4, #253	; 0xfd
   4180c:	2b01      	cmp	r3, #1
   4180e:	d03f      	beq.n	41890 <ull_setinterrupt+0xa4>
   41810:	f04f 0900 	mov.w	r9, #0
   41814:	f8cd 9000 	str.w	r9, [sp]
   41818:	ea6f 0308 	mvn.w	r3, r8
   4181c:	464a      	mov	r2, r9
   4181e:	213c      	movs	r1, #60	; 0x3c
   41820:	4628      	mov	r0, r5
   41822:	f7ff fb5f 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41826:	f8cd 9000 	str.w	r9, [sp]
   4182a:	43fb      	mvns	r3, r7
   4182c:	464a      	mov	r2, r9
   4182e:	2140      	movs	r1, #64	; 0x40
   41830:	4628      	mov	r0, r5
   41832:	f7ff fb57 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41836:	e00b      	b.n	41850 <ull_setinterrupt+0x64>
   41838:	4643      	mov	r3, r8
   4183a:	2200      	movs	r2, #0
   4183c:	213c      	movs	r1, #60	; 0x3c
   4183e:	4628      	mov	r0, r5
   41840:	f7fe fe4a 	bl	404d8 <dwt_write32bitoffsetreg>
   41844:	463b      	mov	r3, r7
   41846:	2200      	movs	r2, #0
   41848:	2140      	movs	r1, #64	; 0x40
   4184a:	4628      	mov	r0, r5
   4184c:	f7fe fe44 	bl	404d8 <dwt_write32bitoffsetreg>
   41850:	3c03      	subs	r4, #3
   41852:	b2e4      	uxtb	r4, r4
   41854:	2c01      	cmp	r4, #1
   41856:	d92d      	bls.n	418b4 <ull_setinterrupt+0xc8>
   41858:	2200      	movs	r2, #0
   4185a:	213c      	movs	r1, #60	; 0x3c
   4185c:	4628      	mov	r0, r5
   4185e:	f7fe f95c 	bl	3fb1a <dwt_read32bitoffsetreg>
   41862:	4603      	mov	r3, r0
   41864:	2200      	movs	r2, #0
   41866:	2144      	movs	r1, #68	; 0x44
   41868:	4628      	mov	r0, r5
   4186a:	f7fe fe35 	bl	404d8 <dwt_write32bitoffsetreg>
   4186e:	2200      	movs	r2, #0
   41870:	2140      	movs	r1, #64	; 0x40
   41872:	4628      	mov	r0, r5
   41874:	f7fe f951 	bl	3fb1a <dwt_read32bitoffsetreg>
   41878:	4603      	mov	r3, r0
   4187a:	2200      	movs	r2, #0
   4187c:	2148      	movs	r1, #72	; 0x48
   4187e:	4628      	mov	r0, r5
   41880:	f7fe fe2a 	bl	404d8 <dwt_write32bitoffsetreg>
   41884:	4630      	mov	r0, r6
   41886:	f7ec ff96 	bl	2e7b6 <decamutexoff>
   4188a:	b003      	add	sp, #12
   4188c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   41890:	f8cd 8000 	str.w	r8, [sp]
   41894:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   41898:	2200      	movs	r2, #0
   4189a:	213c      	movs	r1, #60	; 0x3c
   4189c:	4628      	mov	r0, r5
   4189e:	f7ff fb21 	bl	40ee4 <dwt_modify32bitoffsetreg>
   418a2:	9700      	str	r7, [sp, #0]
   418a4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   418a8:	2200      	movs	r2, #0
   418aa:	2140      	movs	r1, #64	; 0x40
   418ac:	4628      	mov	r0, r5
   418ae:	f7ff fb19 	bl	40ee4 <dwt_modify32bitoffsetreg>
   418b2:	e7cd      	b.n	41850 <ull_setinterrupt+0x64>
   418b4:	2110      	movs	r1, #16
   418b6:	9100      	str	r1, [sp, #0]
   418b8:	23ff      	movs	r3, #255	; 0xff
   418ba:	2202      	movs	r2, #2
   418bc:	4628      	mov	r0, r5
   418be:	f7ff fc81 	bl	411c4 <dwt_modify8bitoffsetreg>
   418c2:	e7c9      	b.n	41858 <ull_setinterrupt+0x6c>

000418c4 <prs_ack_enable>:
   418c4:	b500      	push	{lr}
   418c6:	b083      	sub	sp, #12
   418c8:	2900      	cmp	r1, #0
   418ca:	bf0b      	itete	eq
   418cc:	23ff      	moveq	r3, #255	; 0xff
   418ce:	23f7      	movne	r3, #247	; 0xf7
   418d0:	2200      	moveq	r2, #0
   418d2:	2208      	movne	r2, #8
   418d4:	9200      	str	r2, [sp, #0]
   418d6:	2201      	movs	r2, #1
   418d8:	2110      	movs	r1, #16
   418da:	f7ff fc73 	bl	411c4 <dwt_modify8bitoffsetreg>
   418de:	b003      	add	sp, #12
   418e0:	f85d fb04 	ldr.w	pc, [sp], #4

000418e4 <dwt_modify16bitoffsetreg>:
   418e4:	b510      	push	{r4, lr}
   418e6:	b084      	sub	sp, #16
   418e8:	f8bd 4018 	ldrh.w	r4, [sp, #24]
   418ec:	f88d 300c 	strb.w	r3, [sp, #12]
   418f0:	0a1b      	lsrs	r3, r3, #8
   418f2:	f88d 300d 	strb.w	r3, [sp, #13]
   418f6:	f88d 400e 	strb.w	r4, [sp, #14]
   418fa:	0a24      	lsrs	r4, r4, #8
   418fc:	f88d 400f 	strb.w	r4, [sp, #15]
   41900:	f248 0302 	movw	r3, #32770	; 0x8002
   41904:	9301      	str	r3, [sp, #4]
   41906:	ab03      	add	r3, sp, #12
   41908:	9300      	str	r3, [sp, #0]
   4190a:	2304      	movs	r3, #4
   4190c:	b292      	uxth	r2, r2
   4190e:	f7fe f87c 	bl	3fa0a <dwt_xfer3xxx>
   41912:	b004      	add	sp, #16
   41914:	bd10      	pop	{r4, pc}
	...

00041918 <ull_configurestsmode>:
   41918:	b530      	push	{r4, r5, lr}
   4191a:	b083      	sub	sp, #12
   4191c:	4605      	mov	r5, r0
   4191e:	460c      	mov	r4, r1
   41920:	6d03      	ldr	r3, [r0, #80]	; 0x50
   41922:	7559      	strb	r1, [r3, #21]
   41924:	030b      	lsls	r3, r1, #12
   41926:	f403 4330 	and.w	r3, r3, #45056	; 0xb000
   4192a:	9300      	str	r3, [sp, #0]
   4192c:	f644 73ff 	movw	r3, #20479	; 0x4fff
   41930:	2200      	movs	r2, #0
   41932:	2110      	movs	r1, #16
   41934:	f7ff ffd6 	bl	418e4 <dwt_modify16bitoffsetreg>
   41938:	f004 0403 	and.w	r4, r4, #3
   4193c:	2c03      	cmp	r4, #3
   4193e:	bf0c      	ite	eq
   41940:	4b04      	ldreq	r3, [pc, #16]	; (41954 <ull_configurestsmode+0x3c>)
   41942:	4b05      	ldrne	r3, [pc, #20]	; (41958 <ull_configurestsmode+0x40>)
   41944:	2200      	movs	r2, #0
   41946:	4905      	ldr	r1, [pc, #20]	; (4195c <ull_configurestsmode+0x44>)
   41948:	4628      	mov	r0, r5
   4194a:	f7fe fdc5 	bl	404d8 <dwt_write32bitoffsetreg>
   4194e:	b003      	add	sp, #12
   41950:	bd30      	pop	{r4, r5, pc}
   41952:	bf00      	nop
   41954:	af5f35cc 	.word	0xaf5f35cc
   41958:	af5f584c 	.word	0xaf5f584c
   4195c:	0006000c 	.word	0x0006000c

00041960 <ull_setleds>:
   41960:	b530      	push	{r4, r5, lr}
   41962:	b083      	sub	sp, #12
   41964:	4604      	mov	r4, r0
   41966:	f011 0f01 	tst.w	r1, #1
   4196a:	d01f      	beq.n	419ac <ull_setleds+0x4c>
   4196c:	460d      	mov	r5, r1
   4196e:	f44f 7310 	mov.w	r3, #576	; 0x240
   41972:	9300      	str	r3, [sp, #0]
   41974:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   41978:	2200      	movs	r2, #0
   4197a:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   4197e:	f7ff fab1 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41982:	f44f 0304 	mov.w	r3, #8650752	; 0x840000
   41986:	9300      	str	r3, [sp, #0]
   41988:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   4198c:	2200      	movs	r2, #0
   4198e:	4918      	ldr	r1, [pc, #96]	; (419f0 <ull_setleds+0x90>)
   41990:	4620      	mov	r0, r4
   41992:	f7ff faa7 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41996:	f015 0f02 	tst.w	r5, #2
   4199a:	d11a      	bne.n	419d2 <ull_setleds+0x72>
   4199c:	f44f 7388 	mov.w	r3, #272	; 0x110
   419a0:	2200      	movs	r2, #0
   419a2:	4914      	ldr	r1, [pc, #80]	; (419f4 <ull_setleds+0x94>)
   419a4:	4620      	mov	r0, r4
   419a6:	f7fe fd97 	bl	404d8 <dwt_write32bitoffsetreg>
   419aa:	e010      	b.n	419ce <ull_setleds+0x6e>
   419ac:	2500      	movs	r5, #0
   419ae:	9500      	str	r5, [sp, #0]
   419b0:	f46f 637c 	mvn.w	r3, #4032	; 0xfc0
   419b4:	462a      	mov	r2, r5
   419b6:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   419ba:	f7ff fa93 	bl	40ee4 <dwt_modify32bitoffsetreg>
   419be:	9500      	str	r5, [sp, #0]
   419c0:	f64f 63ff 	movw	r3, #65279	; 0xfeff
   419c4:	462a      	mov	r2, r5
   419c6:	490b      	ldr	r1, [pc, #44]	; (419f4 <ull_setleds+0x94>)
   419c8:	4620      	mov	r0, r4
   419ca:	f7ff ff8b 	bl	418e4 <dwt_modify16bitoffsetreg>
   419ce:	b003      	add	sp, #12
   419d0:	bd30      	pop	{r4, r5, pc}
   419d2:	4d08      	ldr	r5, [pc, #32]	; (419f4 <ull_setleds+0x94>)
   419d4:	4b08      	ldr	r3, [pc, #32]	; (419f8 <ull_setleds+0x98>)
   419d6:	2200      	movs	r2, #0
   419d8:	4629      	mov	r1, r5
   419da:	4620      	mov	r0, r4
   419dc:	f7fe fd7c 	bl	404d8 <dwt_write32bitoffsetreg>
   419e0:	f44f 7388 	mov.w	r3, #272	; 0x110
   419e4:	2200      	movs	r2, #0
   419e6:	4629      	mov	r1, r5
   419e8:	4620      	mov	r0, r4
   419ea:	f7fe fd75 	bl	404d8 <dwt_write32bitoffsetreg>
   419ee:	e7ee      	b.n	419ce <ull_setleds+0x6e>
   419f0:	00110004 	.word	0x00110004
   419f4:	00110018 	.word	0x00110018
   419f8:	000f0110 	.word	0x000f0110

000419fc <ull_pgf_cal>:
   419fc:	b5f0      	push	{r4, r5, r6, r7, lr}
   419fe:	b083      	sub	sp, #12
   41a00:	4604      	mov	r4, r0
   41a02:	2901      	cmp	r1, #1
   41a04:	d009      	beq.n	41a1a <ull_pgf_cal+0x1e>
   41a06:	2014      	movs	r0, #20
   41a08:	f7ec fef1 	bl	2e7ee <deca_usleep>
   41a0c:	4620      	mov	r0, r4
   41a0e:	f7ff fe8b 	bl	41728 <ull_run_pgfcal>
   41a12:	4605      	mov	r5, r0
   41a14:	4628      	mov	r0, r5
   41a16:	b003      	add	sp, #12
   41a18:	bdf0      	pop	{r4, r5, r6, r7, pc}
   41a1a:	4e0f      	ldr	r6, [pc, #60]	; (41a58 <ull_pgf_cal+0x5c>)
   41a1c:	2200      	movs	r2, #0
   41a1e:	4631      	mov	r1, r6
   41a20:	f7fe f891 	bl	3fb46 <dwt_read16bitoffsetreg>
   41a24:	4607      	mov	r7, r0
   41a26:	f240 1307 	movw	r3, #263	; 0x107
   41a2a:	9300      	str	r3, [sp, #0]
   41a2c:	f64f 73ff 	movw	r3, #65535	; 0xffff
   41a30:	2200      	movs	r2, #0
   41a32:	4631      	mov	r1, r6
   41a34:	4620      	mov	r0, r4
   41a36:	f7ff ff55 	bl	418e4 <dwt_modify16bitoffsetreg>
   41a3a:	2014      	movs	r0, #20
   41a3c:	f7ec fed7 	bl	2e7ee <deca_usleep>
   41a40:	4620      	mov	r0, r4
   41a42:	f7ff fe71 	bl	41728 <ull_run_pgfcal>
   41a46:	4605      	mov	r5, r0
   41a48:	2200      	movs	r2, #0
   41a4a:	9200      	str	r2, [sp, #0]
   41a4c:	463b      	mov	r3, r7
   41a4e:	4631      	mov	r1, r6
   41a50:	4620      	mov	r0, r4
   41a52:	f7ff ff47 	bl	418e4 <dwt_modify16bitoffsetreg>
   41a56:	e7dd      	b.n	41a14 <ull_pgf_cal+0x18>
   41a58:	00070048 	.word	0x00070048

00041a5c <ull_setgpiovalue>:
   41a5c:	b500      	push	{lr}
   41a5e:	b083      	sub	sp, #12
   41a60:	2a01      	cmp	r2, #1
   41a62:	d009      	beq.n	41a78 <ull_setgpiovalue+0x1c>
   41a64:	43cb      	mvns	r3, r1
   41a66:	2200      	movs	r2, #0
   41a68:	9200      	str	r2, [sp, #0]
   41a6a:	b29b      	uxth	r3, r3
   41a6c:	4906      	ldr	r1, [pc, #24]	; (41a88 <ull_setgpiovalue+0x2c>)
   41a6e:	f7ff ff39 	bl	418e4 <dwt_modify16bitoffsetreg>
   41a72:	b003      	add	sp, #12
   41a74:	f85d fb04 	ldr.w	pc, [sp], #4
   41a78:	9100      	str	r1, [sp, #0]
   41a7a:	f64f 73ff 	movw	r3, #65535	; 0xffff
   41a7e:	2200      	movs	r2, #0
   41a80:	4901      	ldr	r1, [pc, #4]	; (41a88 <ull_setgpiovalue+0x2c>)
   41a82:	f7ff ff2f 	bl	418e4 <dwt_modify16bitoffsetreg>
   41a86:	e7f4      	b.n	41a72 <ull_setgpiovalue+0x16>
   41a88:	0005000c 	.word	0x0005000c

00041a8c <ull_readaccdata>:
   41a8c:	b5f0      	push	{r4, r5, r6, r7, lr}
   41a8e:	b083      	sub	sp, #12
   41a90:	4604      	mov	r4, r0
   41a92:	460f      	mov	r7, r1
   41a94:	4616      	mov	r6, r2
   41a96:	461d      	mov	r5, r3
   41a98:	f248 0340 	movw	r3, #32832	; 0x8040
   41a9c:	9300      	str	r3, [sp, #0]
   41a9e:	f64f 73ff 	movw	r3, #65535	; 0xffff
   41aa2:	2200      	movs	r2, #0
   41aa4:	4918      	ldr	r1, [pc, #96]	; (41b08 <ull_readaccdata+0x7c>)
   41aa6:	f7ff ff1d 	bl	418e4 <dwt_modify16bitoffsetreg>
   41aaa:	19aa      	adds	r2, r5, r6
   41aac:	f243 0301 	movw	r3, #12289	; 0x3001
   41ab0:	429a      	cmp	r2, r3
   41ab2:	dc15      	bgt.n	41ae0 <ull_readaccdata+0x54>
   41ab4:	2d7f      	cmp	r5, #127	; 0x7f
   41ab6:	d91d      	bls.n	41af4 <ull_readaccdata+0x68>
   41ab8:	2315      	movs	r3, #21
   41aba:	2200      	movs	r2, #0
   41abc:	4913      	ldr	r1, [pc, #76]	; (41b0c <ull_readaccdata+0x80>)
   41abe:	4620      	mov	r0, r4
   41ac0:	f7fe fd0a 	bl	404d8 <dwt_write32bitoffsetreg>
   41ac4:	462b      	mov	r3, r5
   41ac6:	2200      	movs	r2, #0
   41ac8:	4911      	ldr	r1, [pc, #68]	; (41b10 <ull_readaccdata+0x84>)
   41aca:	4620      	mov	r0, r4
   41acc:	f7fe fd04 	bl	404d8 <dwt_write32bitoffsetreg>
   41ad0:	9700      	str	r7, [sp, #0]
   41ad2:	4633      	mov	r3, r6
   41ad4:	2200      	movs	r2, #0
   41ad6:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   41ada:	4620      	mov	r0, r4
   41adc:	f7fe f813 	bl	3fb06 <dwt_readfromdevice>
   41ae0:	2200      	movs	r2, #0
   41ae2:	9200      	str	r2, [sp, #0]
   41ae4:	f647 73bf 	movw	r3, #32703	; 0x7fbf
   41ae8:	4907      	ldr	r1, [pc, #28]	; (41b08 <ull_readaccdata+0x7c>)
   41aea:	4620      	mov	r0, r4
   41aec:	f7ff fefa 	bl	418e4 <dwt_modify16bitoffsetreg>
   41af0:	b003      	add	sp, #12
   41af2:	bdf0      	pop	{r4, r5, r6, r7, pc}
   41af4:	9700      	str	r7, [sp, #0]
   41af6:	4633      	mov	r3, r6
   41af8:	462a      	mov	r2, r5
   41afa:	f44f 11a8 	mov.w	r1, #1376256	; 0x150000
   41afe:	4620      	mov	r0, r4
   41b00:	f7fe f801 	bl	3fb06 <dwt_readfromdevice>
   41b04:	e7ec      	b.n	41ae0 <ull_readaccdata+0x54>
   41b06:	bf00      	nop
   41b08:	00110004 	.word	0x00110004
   41b0c:	001f0004 	.word	0x001f0004
   41b10:	001f0008 	.word	0x001f0008

00041b14 <ull_configure>:
   41b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   41b18:	b083      	sub	sp, #12
   41b1a:	4604      	mov	r4, r0
   41b1c:	460d      	mov	r5, r1
   41b1e:	f891 9000 	ldrb.w	r9, [r1]
   41b22:	790b      	ldrb	r3, [r1, #4]
   41b24:	2b18      	cmp	r3, #24
   41b26:	d814      	bhi.n	41b52 <ull_configure+0x3e>
   41b28:	78cf      	ldrb	r7, [r1, #3]
   41b2a:	2f18      	cmp	r7, #24
   41b2c:	bf94      	ite	ls
   41b2e:	2700      	movls	r7, #0
   41b30:	2701      	movhi	r7, #1
   41b32:	b2ff      	uxtb	r7, r7
   41b34:	79eb      	ldrb	r3, [r5, #7]
   41b36:	2b01      	cmp	r3, #1
   41b38:	bf0c      	ite	eq
   41b3a:	2110      	moveq	r1, #16
   41b3c:	2100      	movne	r1, #0
   41b3e:	786b      	ldrb	r3, [r5, #1]
   41b40:	3b01      	subs	r3, #1
   41b42:	2b06      	cmp	r3, #6
   41b44:	d810      	bhi.n	41b68 <ull_configure+0x54>
   41b46:	e8df f003 	tbb	[pc, r3]
   41b4a:	0f06      	.short	0x0f06
   41b4c:	0f0c120f 	.word	0x0f0c120f
   41b50:	09          	.byte	0x09
   41b51:	00          	.byte	0x00
   41b52:	2701      	movs	r7, #1
   41b54:	e7ed      	b.n	41b32 <ull_configure+0x1e>
   41b56:	f04f 0a40 	mov.w	sl, #64	; 0x40
   41b5a:	e00a      	b.n	41b72 <ull_configure+0x5e>
   41b5c:	f04f 0a48 	mov.w	sl, #72	; 0x48
   41b60:	e007      	b.n	41b72 <ull_configure+0x5e>
   41b62:	f04f 0a80 	mov.w	sl, #128	; 0x80
   41b66:	e004      	b.n	41b72 <ull_configure+0x5e>
   41b68:	f44f 7a80 	mov.w	sl, #256	; 0x100
   41b6c:	e001      	b.n	41b72 <ull_configure+0x5e>
   41b6e:	f04f 0a20 	mov.w	sl, #32
   41b72:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41b74:	8a13      	ldrh	r3, [r2, #16]
   41b76:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
   41b7a:	8213      	strh	r3, [r2, #16]
   41b7c:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41b7e:	79ea      	ldrb	r2, [r5, #7]
   41b80:	72da      	strb	r2, [r3, #11]
   41b82:	7b2e      	ldrb	r6, [r5, #12]
   41b84:	1cb3      	adds	r3, r6, #2
   41b86:	2601      	movs	r6, #1
   41b88:	409e      	lsls	r6, r3
   41b8a:	fa1f f886 	uxth.w	r8, r6
   41b8e:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41b90:	4bca      	ldr	r3, [pc, #808]	; (41ebc <ull_configure+0x3a8>)
   41b92:	fb03 f308 	mul.w	r3, r3, r8
   41b96:	0bdb      	lsrs	r3, r3, #15
   41b98:	8253      	strh	r3, [r2, #18]
   41b9a:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41b9c:	7aea      	ldrb	r2, [r5, #11]
   41b9e:	755a      	strb	r2, [r3, #21]
   41ba0:	7a2b      	ldrb	r3, [r5, #8]
   41ba2:	015b      	lsls	r3, r3, #5
   41ba4:	f003 0320 	and.w	r3, r3, #32
   41ba8:	7b6a      	ldrb	r2, [r5, #13]
   41baa:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
   41bae:	7aea      	ldrb	r2, [r5, #11]
   41bb0:	0312      	lsls	r2, r2, #12
   41bb2:	f402 4230 	and.w	r2, r2, #45056	; 0xb000
   41bb6:	4313      	orrs	r3, r2
   41bb8:	430b      	orrs	r3, r1
   41bba:	9300      	str	r3, [sp, #0]
   41bbc:	4bc0      	ldr	r3, [pc, #768]	; (41ec0 <ull_configure+0x3ac>)
   41bbe:	2200      	movs	r2, #0
   41bc0:	2110      	movs	r1, #16
   41bc2:	4620      	mov	r0, r4
   41bc4:	f7ff f98e 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41bc8:	2f00      	cmp	r7, #0
   41bca:	f040 80fe 	bne.w	41dca <ull_configure+0x2b6>
   41bce:	7aeb      	ldrb	r3, [r5, #11]
   41bd0:	b1bb      	cbz	r3, 41c02 <ull_configure+0xee>
   41bd2:	7b6b      	ldrb	r3, [r5, #13]
   41bd4:	2b01      	cmp	r3, #1
   41bd6:	7b28      	ldrb	r0, [r5, #12]
   41bd8:	bf94      	ite	ls
   41bda:	2203      	movls	r2, #3
   41bdc:	2204      	movhi	r2, #4
   41bde:	2110      	movs	r1, #16
   41be0:	4bb8      	ldr	r3, [pc, #736]	; (41ec4 <ull_configure+0x3b0>)
   41be2:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   41be6:	f7fd fef3 	bl	3f9d0 <get_sts_mnth>
   41bea:	eb0a 0ac8 	add.w	sl, sl, r8, lsl #3
   41bee:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   41bf2:	9000      	str	r0, [sp, #0]
   41bf4:	f64f 7380 	movw	r3, #65408	; 0xff80
   41bf8:	2202      	movs	r2, #2
   41bfa:	49b3      	ldr	r1, [pc, #716]	; (41ec8 <ull_configure+0x3b4>)
   41bfc:	4620      	mov	r0, r4
   41bfe:	f7ff fe71 	bl	418e4 <dwt_modify16bitoffsetreg>
   41c02:	2394      	movs	r3, #148	; 0x94
   41c04:	9300      	str	r3, [sp, #0]
   41c06:	4bb1      	ldr	r3, [pc, #708]	; (41ecc <ull_configure+0x3b8>)
   41c08:	2200      	movs	r2, #0
   41c0a:	49b1      	ldr	r1, [pc, #708]	; (41ed0 <ull_configure+0x3bc>)
   41c0c:	4620      	mov	r0, r4
   41c0e:	f7ff f969 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41c12:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
   41c16:	f340 8103 	ble.w	41e20 <ull_configure+0x30c>
   41c1a:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41c1c:	8a13      	ldrh	r3, [r2, #16]
   41c1e:	f043 0320 	orr.w	r3, r3, #32
   41c22:	8213      	strh	r3, [r2, #16]
   41c24:	f44f 6300 	mov.w	r3, #2048	; 0x800
   41c28:	9300      	str	r3, [sp, #0]
   41c2a:	f64c 73ff 	movw	r3, #53247	; 0xcfff
   41c2e:	2200      	movs	r2, #0
   41c30:	49a8      	ldr	r1, [pc, #672]	; (41ed4 <ull_configure+0x3c0>)
   41c32:	4620      	mov	r0, r4
   41c34:	f7ff fe56 	bl	418e4 <dwt_modify16bitoffsetreg>
   41c38:	7b6b      	ldrb	r3, [r5, #13]
   41c3a:	2b01      	cmp	r3, #1
   41c3c:	f000 80fb 	beq.w	41e36 <ull_configure+0x322>
   41c40:	78ab      	ldrb	r3, [r5, #2]
   41c42:	f043 0310 	orr.w	r3, r3, #16
   41c46:	9300      	str	r3, [sp, #0]
   41c48:	23fc      	movs	r3, #252	; 0xfc
   41c4a:	2200      	movs	r2, #0
   41c4c:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   41c50:	4620      	mov	r0, r4
   41c52:	f7ff fab7 	bl	411c4 <dwt_modify8bitoffsetreg>
   41c56:	1e73      	subs	r3, r6, #1
   41c58:	b2db      	uxtb	r3, r3
   41c5a:	2200      	movs	r2, #0
   41c5c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   41c60:	4620      	mov	r0, r4
   41c62:	f7fe fe1d 	bl	408a0 <dwt_write8bitoffsetreg>
   41c66:	786b      	ldrb	r3, [r5, #1]
   41c68:	2b07      	cmp	r3, #7
   41c6a:	bf0c      	ite	eq
   41c6c:	2108      	moveq	r1, #8
   41c6e:	2100      	movne	r1, #0
   41c70:	4620      	mov	r0, r4
   41c72:	f7fe ff1b 	bl	40aac <ull_setplenfine>
   41c76:	7aeb      	ldrb	r3, [r5, #11]
   41c78:	f003 0303 	and.w	r3, r3, #3
   41c7c:	2b03      	cmp	r3, #3
   41c7e:	bf0c      	ite	eq
   41c80:	4b95      	ldreq	r3, [pc, #596]	; (41ed8 <ull_configure+0x3c4>)
   41c82:	4b96      	ldrne	r3, [pc, #600]	; (41edc <ull_configure+0x3c8>)
   41c84:	2200      	movs	r2, #0
   41c86:	4996      	ldr	r1, [pc, #600]	; (41ee0 <ull_configure+0x3cc>)
   41c88:	4620      	mov	r0, r4
   41c8a:	f7fe fc25 	bl	404d8 <dwt_write32bitoffsetreg>
   41c8e:	2200      	movs	r2, #0
   41c90:	4994      	ldr	r1, [pc, #592]	; (41ee4 <ull_configure+0x3d0>)
   41c92:	4620      	mov	r0, r4
   41c94:	f7fd ff41 	bl	3fb1a <dwt_read32bitoffsetreg>
   41c98:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
   41c9c:	f020 001f 	bic.w	r0, r0, #31
   41ca0:	f1b9 0f09 	cmp.w	r9, #9
   41ca4:	bf08      	it	eq
   41ca6:	f040 0001 	orreq.w	r0, r0, #1
   41caa:	792a      	ldrb	r2, [r5, #4]
   41cac:	0212      	lsls	r2, r2, #8
   41cae:	f402 52f8 	and.w	r2, r2, #7936	; 0x1f00
   41cb2:	78eb      	ldrb	r3, [r5, #3]
   41cb4:	00db      	lsls	r3, r3, #3
   41cb6:	b2db      	uxtb	r3, r3
   41cb8:	431a      	orrs	r2, r3
   41cba:	796b      	ldrb	r3, [r5, #5]
   41cbc:	005b      	lsls	r3, r3, #1
   41cbe:	f003 0306 	and.w	r3, r3, #6
   41cc2:	4313      	orrs	r3, r2
   41cc4:	4303      	orrs	r3, r0
   41cc6:	2200      	movs	r2, #0
   41cc8:	4986      	ldr	r1, [pc, #536]	; (41ee4 <ull_configure+0x3d0>)
   41cca:	4620      	mov	r0, r4
   41ccc:	f7fe fc04 	bl	404d8 <dwt_write32bitoffsetreg>
   41cd0:	79aa      	ldrb	r2, [r5, #6]
   41cd2:	786b      	ldrb	r3, [r5, #1]
   41cd4:	031b      	lsls	r3, r3, #12
   41cd6:	ea43 2382 	orr.w	r3, r3, r2, lsl #10
   41cda:	9300      	str	r3, [sp, #0]
   41cdc:	f46f 4374 	mvn.w	r3, #62464	; 0xf400
   41ce0:	2200      	movs	r2, #0
   41ce2:	2120      	movs	r1, #32
   41ce4:	4620      	mov	r0, r4
   41ce6:	f7ff f8fd 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41cea:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   41cee:	b923      	cbnz	r3, 41cfa <ull_configure+0x1e6>
   41cf0:	f06f 037e 	mvn.w	r3, #126	; 0x7e
   41cf4:	726b      	strb	r3, [r5, #9]
   41cf6:	2300      	movs	r3, #0
   41cf8:	72ab      	strb	r3, [r5, #10]
   41cfa:	f8b5 3009 	ldrh.w	r3, [r5, #9]
   41cfe:	2202      	movs	r2, #2
   41d00:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   41d04:	4620      	mov	r0, r4
   41d06:	f7fe fb7c 	bl	40402 <dwt_write16bitoffsetreg>
   41d0a:	2202      	movs	r2, #2
   41d0c:	4976      	ldr	r1, [pc, #472]	; (41ee8 <ull_configure+0x3d4>)
   41d0e:	4620      	mov	r0, r4
   41d10:	f7fd ff58 	bl	3fbc4 <dwt_read8bitoffsetreg>
   41d14:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41d16:	7bdb      	ldrb	r3, [r3, #15]
   41d18:	454b      	cmp	r3, r9
   41d1a:	f000 8096 	beq.w	41e4a <ull_configure+0x336>
   41d1e:	2803      	cmp	r0, #3
   41d20:	f000 8097 	beq.w	41e52 <ull_configure+0x33e>
   41d24:	f1b9 0f09 	cmp.w	r9, #9
   41d28:	f000 8098 	beq.w	41e5c <ull_configure+0x348>
   41d2c:	4b6f      	ldr	r3, [pc, #444]	; (41eec <ull_configure+0x3d8>)
   41d2e:	9300      	str	r3, [sp, #0]
   41d30:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   41d34:	2200      	movs	r2, #0
   41d36:	496e      	ldr	r1, [pc, #440]	; (41ef0 <ull_configure+0x3dc>)
   41d38:	4620      	mov	r0, r4
   41d3a:	f7ff f8d3 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41d3e:	f641 733c 	movw	r3, #7996	; 0x1f3c
   41d42:	2200      	movs	r2, #0
   41d44:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   41d48:	4620      	mov	r0, r4
   41d4a:	f7fe fb5a 	bl	40402 <dwt_write16bitoffsetreg>
   41d4e:	2314      	movs	r3, #20
   41d50:	2201      	movs	r2, #1
   41d52:	4968      	ldr	r1, [pc, #416]	; (41ef4 <ull_configure+0x3e0>)
   41d54:	4620      	mov	r0, r4
   41d56:	f7fe fda3 	bl	408a0 <dwt_write8bitoffsetreg>
   41d5a:	230e      	movs	r3, #14
   41d5c:	2202      	movs	r2, #2
   41d5e:	4966      	ldr	r1, [pc, #408]	; (41ef8 <ull_configure+0x3e4>)
   41d60:	4620      	mov	r0, r4
   41d62:	f7fe fd9d 	bl	408a0 <dwt_write8bitoffsetreg>
   41d66:	2381      	movs	r3, #129	; 0x81
   41d68:	2200      	movs	r2, #0
   41d6a:	4964      	ldr	r1, [pc, #400]	; (41efc <ull_configure+0x3e8>)
   41d6c:	4620      	mov	r0, r4
   41d6e:	f7fe fd97 	bl	408a0 <dwt_write8bitoffsetreg>
   41d72:	2600      	movs	r6, #0
   41d74:	9600      	str	r6, [sp, #0]
   41d76:	23fc      	movs	r3, #252	; 0xfc
   41d78:	2203      	movs	r2, #3
   41d7a:	4961      	ldr	r1, [pc, #388]	; (41f00 <ull_configure+0x3ec>)
   41d7c:	4620      	mov	r0, r4
   41d7e:	f7ff fa21 	bl	411c4 <dwt_modify8bitoffsetreg>
   41d82:	2302      	movs	r3, #2
   41d84:	4632      	mov	r2, r6
   41d86:	2144      	movs	r1, #68	; 0x44
   41d88:	4620      	mov	r0, r4
   41d8a:	f7fe fd89 	bl	408a0 <dwt_write8bitoffsetreg>
   41d8e:	2101      	movs	r1, #1
   41d90:	4620      	mov	r0, r4
   41d92:	f7ff fc47 	bl	41624 <ull_setdwstate>
   41d96:	f04f 0b32 	mov.w	fp, #50	; 0x32
   41d9a:	f04f 0814 	mov.w	r8, #20
   41d9e:	4637      	mov	r7, r6
   41da0:	2644      	movs	r6, #68	; 0x44
   41da2:	4640      	mov	r0, r8
   41da4:	f7ec fd23 	bl	2e7ee <deca_usleep>
   41da8:	463a      	mov	r2, r7
   41daa:	4631      	mov	r1, r6
   41dac:	4620      	mov	r0, r4
   41dae:	f7fd ff09 	bl	3fbc4 <dwt_read8bitoffsetreg>
   41db2:	f010 0f02 	tst.w	r0, #2
   41db6:	f040 80af 	bne.w	41f18 <ull_configure+0x404>
   41dba:	f10b 33ff 	add.w	r3, fp, #4294967295	; 0xffffffff
   41dbe:	f013 0bff 	ands.w	fp, r3, #255	; 0xff
   41dc2:	d1ee      	bne.n	41da2 <ull_configure+0x28e>
   41dc4:	f06f 0001 	mvn.w	r0, #1
   41dc8:	e0e6      	b.n	41f98 <ull_configure+0x484>
   41dca:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41dcc:	8a13      	ldrh	r3, [r2, #16]
   41dce:	f043 0360 	orr.w	r3, r3, #96	; 0x60
   41dd2:	8213      	strh	r3, [r2, #16]
   41dd4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
   41dd8:	9300      	str	r3, [sp, #0]
   41dda:	f46f 5340 	mvn.w	r3, #12288	; 0x3000
   41dde:	2200      	movs	r2, #0
   41de0:	493c      	ldr	r1, [pc, #240]	; (41ed4 <ull_configure+0x3c0>)
   41de2:	4620      	mov	r0, r4
   41de4:	f7ff f87e 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41de8:	f240 3306 	movw	r3, #774	; 0x306
   41dec:	2200      	movs	r2, #0
   41dee:	4945      	ldr	r1, [pc, #276]	; (41f04 <ull_configure+0x3f0>)
   41df0:	4620      	mov	r0, r4
   41df2:	f7fe fb71 	bl	404d8 <dwt_write32bitoffsetreg>
   41df6:	2300      	movs	r3, #0
   41df8:	461a      	mov	r2, r3
   41dfa:	4943      	ldr	r1, [pc, #268]	; (41f08 <ull_configure+0x3f4>)
   41dfc:	4620      	mov	r0, r4
   41dfe:	f7fe fb6b 	bl	404d8 <dwt_write32bitoffsetreg>
   41e02:	4b42      	ldr	r3, [pc, #264]	; (41f0c <ull_configure+0x3f8>)
   41e04:	2200      	movs	r2, #0
   41e06:	4930      	ldr	r1, [pc, #192]	; (41ec8 <ull_configure+0x3b4>)
   41e08:	4620      	mov	r0, r4
   41e0a:	f7fe fb65 	bl	404d8 <dwt_write32bitoffsetreg>
   41e0e:	239d      	movs	r3, #157	; 0x9d
   41e10:	9300      	str	r3, [sp, #0]
   41e12:	4b2e      	ldr	r3, [pc, #184]	; (41ecc <ull_configure+0x3b8>)
   41e14:	2200      	movs	r2, #0
   41e16:	492e      	ldr	r1, [pc, #184]	; (41ed0 <ull_configure+0x3bc>)
   41e18:	4620      	mov	r0, r4
   41e1a:	f7ff f863 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41e1e:	e70b      	b.n	41c38 <ull_configure+0x124>
   41e20:	f44f 5320 	mov.w	r3, #10240	; 0x2800
   41e24:	9300      	str	r3, [sp, #0]
   41e26:	f64c 73ff 	movw	r3, #53247	; 0xcfff
   41e2a:	2200      	movs	r2, #0
   41e2c:	4929      	ldr	r1, [pc, #164]	; (41ed4 <ull_configure+0x3c0>)
   41e2e:	4620      	mov	r0, r4
   41e30:	f7ff fd58 	bl	418e4 <dwt_modify16bitoffsetreg>
   41e34:	e700      	b.n	41c38 <ull_configure+0x124>
   41e36:	78ab      	ldrb	r3, [r5, #2]
   41e38:	9300      	str	r3, [sp, #0]
   41e3a:	23ec      	movs	r3, #236	; 0xec
   41e3c:	2200      	movs	r2, #0
   41e3e:	f44f 21c0 	mov.w	r1, #393216	; 0x60000
   41e42:	4620      	mov	r0, r4
   41e44:	f7ff f9be 	bl	411c4 <dwt_modify8bitoffsetreg>
   41e48:	e705      	b.n	41c56 <ull_configure+0x142>
   41e4a:	2803      	cmp	r0, #3
   41e4c:	f47f af6a 	bne.w	41d24 <ull_configure+0x210>
   41e50:	e065      	b.n	41f1e <ull_configure+0x40a>
   41e52:	2102      	movs	r1, #2
   41e54:	4620      	mov	r0, r4
   41e56:	f7ff fbe5 	bl	41624 <ull_setdwstate>
   41e5a:	e763      	b.n	41d24 <ull_configure+0x210>
   41e5c:	4b2c      	ldr	r3, [pc, #176]	; (41f10 <ull_configure+0x3fc>)
   41e5e:	9300      	str	r3, [sp, #0]
   41e60:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   41e64:	2200      	movs	r2, #0
   41e66:	4922      	ldr	r1, [pc, #136]	; (41ef0 <ull_configure+0x3dc>)
   41e68:	4620      	mov	r0, r4
   41e6a:	f7ff f83b 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41e6e:	f640 733c 	movw	r3, #3900	; 0xf3c
   41e72:	2200      	movs	r2, #0
   41e74:	f44f 2110 	mov.w	r1, #589824	; 0x90000
   41e78:	4620      	mov	r0, r4
   41e7a:	f7fe fac2 	bl	40402 <dwt_write16bitoffsetreg>
   41e7e:	e766      	b.n	41d4e <ull_configure+0x23a>
   41e80:	f44f 7380 	mov.w	r3, #256	; 0x100
   41e84:	9300      	str	r3, [sp, #0]
   41e86:	f64f 73ff 	movw	r3, #65535	; 0xffff
   41e8a:	2200      	movs	r2, #0
   41e8c:	4911      	ldr	r1, [pc, #68]	; (41ed4 <ull_configure+0x3c0>)
   41e8e:	4620      	mov	r0, r4
   41e90:	f7ff fd28 	bl	418e4 <dwt_modify16bitoffsetreg>
   41e94:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41e96:	8a13      	ldrh	r3, [r2, #16]
   41e98:	f043 0308 	orr.w	r3, r3, #8
   41e9c:	8213      	strh	r3, [r2, #16]
   41e9e:	e050      	b.n	41f42 <ull_configure+0x42e>
   41ea0:	2200      	movs	r2, #0
   41ea2:	9200      	str	r2, [sp, #0]
   41ea4:	23fe      	movs	r3, #254	; 0xfe
   41ea6:	491b      	ldr	r1, [pc, #108]	; (41f14 <ull_configure+0x400>)
   41ea8:	4620      	mov	r0, r4
   41eaa:	f7ff f98b 	bl	411c4 <dwt_modify8bitoffsetreg>
   41eae:	e052      	b.n	41f56 <ull_configure+0x442>
   41eb0:	2101      	movs	r1, #1
   41eb2:	4620      	mov	r0, r4
   41eb4:	f7ff fda2 	bl	419fc <ull_pgf_cal>
   41eb8:	e06b      	b.n	41f92 <ull_configure+0x47e>
   41eba:	bf00      	nop
   41ebc:	00026668 	.word	0x00026668
   41ec0:	fffc4fcf 	.word	0xfffc4fcf
   41ec4:	0004707c 	.word	0x0004707c
   41ec8:	000e0014 	.word	0x000e0014
   41ecc:	bfffff00 	.word	0xbfffff00
   41ed0:	000e0018 	.word	0x000e0018
   41ed4:	000b0008 	.word	0x000b0008
   41ed8:	af5f35cc 	.word	0xaf5f35cc
   41edc:	af5f584c 	.word	0xaf5f584c
   41ee0:	0006000c 	.word	0x0006000c
   41ee4:	00010008 	.word	0x00010008
   41ee8:	000f0030 	.word	0x000f0030
   41eec:	1c071134 	.word	0x1c071134
   41ef0:	0007001c 	.word	0x0007001c
   41ef4:	00070050 	.word	0x00070050
   41ef8:	00070018 	.word	0x00070018
   41efc:	00090008 	.word	0x00090008
   41f00:	00090004 	.word	0x00090004
   41f04:	000e000c 	.word	0x000e000c
   41f08:	000e0010 	.word	0x000e0010
   41f0c:	000c5a0a 	.word	0x000c5a0a
   41f10:	1c010034 	.word	0x1c010034
   41f14:	00030018 	.word	0x00030018
   41f18:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41f1a:	f883 900f 	strb.w	r9, [r3, #15]
   41f1e:	792b      	ldrb	r3, [r5, #4]
   41f20:	3b09      	subs	r3, #9
   41f22:	b2db      	uxtb	r3, r3
   41f24:	2b0f      	cmp	r3, #15
   41f26:	d8bb      	bhi.n	41ea0 <ull_configure+0x38c>
   41f28:	6d23      	ldr	r3, [r4, #80]	; 0x50
   41f2a:	7a1b      	ldrb	r3, [r3, #8]
   41f2c:	2b01      	cmp	r3, #1
   41f2e:	d0a7      	beq.n	41e80 <ull_configure+0x36c>
   41f30:	4649      	mov	r1, r9
   41f32:	4620      	mov	r0, r4
   41f34:	f7fe fb9c 	bl	40670 <ull_configmrxlut>
   41f38:	6d22      	ldr	r2, [r4, #80]	; 0x50
   41f3a:	8a13      	ldrh	r3, [r2, #16]
   41f3c:	f023 0308 	bic.w	r3, r3, #8
   41f40:	8213      	strh	r3, [r2, #16]
   41f42:	f44f 43c8 	mov.w	r3, #25600	; 0x6400
   41f46:	9300      	str	r3, [sp, #0]
   41f48:	f248 13ff 	movw	r3, #33279	; 0x81ff
   41f4c:	2200      	movs	r2, #0
   41f4e:	4914      	ldr	r1, [pc, #80]	; (41fa0 <ull_configure+0x48c>)
   41f50:	4620      	mov	r0, r4
   41f52:	f7ff fcc7 	bl	418e4 <dwt_modify16bitoffsetreg>
   41f56:	f1ba 0f40 	cmp.w	sl, #64	; 0x40
   41f5a:	bfcc      	ite	gt
   41f5c:	f04f 5300 	movgt.w	r3, #536870912	; 0x20000000
   41f60:	f04f 53a0 	movle.w	r3, #335544320	; 0x14000000
   41f64:	9300      	str	r3, [sp, #0]
   41f66:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
   41f6a:	2200      	movs	r2, #0
   41f6c:	490d      	ldr	r1, [pc, #52]	; (41fa4 <ull_configure+0x490>)
   41f6e:	4620      	mov	r0, r4
   41f70:	f7fe ffb8 	bl	40ee4 <dwt_modify32bitoffsetreg>
   41f74:	2301      	movs	r3, #1
   41f76:	9300      	str	r3, [sp, #0]
   41f78:	23ff      	movs	r3, #255	; 0xff
   41f7a:	2202      	movs	r2, #2
   41f7c:	490a      	ldr	r1, [pc, #40]	; (41fa8 <ull_configure+0x494>)
   41f7e:	4620      	mov	r0, r4
   41f80:	f7ff f920 	bl	411c4 <dwt_modify8bitoffsetreg>
   41f84:	2200      	movs	r2, #0
   41f86:	4909      	ldr	r1, [pc, #36]	; (41fac <ull_configure+0x498>)
   41f88:	4620      	mov	r0, r4
   41f8a:	f7fd fdc6 	bl	3fb1a <dwt_read32bitoffsetreg>
   41f8e:	2800      	cmp	r0, #0
   41f90:	d08e      	beq.n	41eb0 <ull_configure+0x39c>
   41f92:	4620      	mov	r0, r4
   41f94:	f7ff f98a 	bl	412ac <ull_adcoffsetscalibration>
   41f98:	b003      	add	sp, #12
   41f9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   41f9e:	bf00      	nop
   41fa0:	00030018 	.word	0x00030018
   41fa4:	00060010 	.word	0x00060010
   41fa8:	0004000c 	.word	0x0004000c
   41fac:	00040014 	.word	0x00040014

00041fb0 <ull_initialise>:
   41fb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   41fb4:	b082      	sub	sp, #8
   41fb6:	4605      	mov	r5, r0
   41fb8:	460e      	mov	r6, r1
   41fba:	6d03      	ldr	r3, [r0, #80]	; 0x50
   41fbc:	2b00      	cmp	r3, #0
   41fbe:	d05b      	beq.n	42078 <ull_initialise+0xc8>
   41fc0:	6d2c      	ldr	r4, [r5, #80]	; 0x50
   41fc2:	2300      	movs	r3, #0
   41fc4:	73a3      	strb	r3, [r4, #14]
   41fc6:	2202      	movs	r2, #2
   41fc8:	8222      	strh	r2, [r4, #16]
   41fca:	7523      	strb	r3, [r4, #20]
   41fcc:	7563      	strb	r3, [r4, #21]
   41fce:	73e3      	strb	r3, [r4, #15]
   41fd0:	7263      	strb	r3, [r4, #9]
   41fd2:	72a3      	strb	r3, [r4, #10]
   41fd4:	2104      	movs	r1, #4
   41fd6:	4628      	mov	r0, r5
   41fd8:	f7fe fa5c 	bl	40494 <_dwt_otpread>
   41fdc:	4607      	mov	r7, r0
   41fde:	2105      	movs	r1, #5
   41fe0:	4628      	mov	r0, r5
   41fe2:	f7fe fa57 	bl	40494 <_dwt_otpread>
   41fe6:	4680      	mov	r8, r0
   41fe8:	210a      	movs	r1, #10
   41fea:	4628      	mov	r0, r5
   41fec:	f7fe fa52 	bl	40494 <_dwt_otpread>
   41ff0:	b12f      	cbz	r7, 41ffe <ull_initialise+0x4e>
   41ff2:	f1b8 0f00 	cmp.w	r8, #0
   41ff6:	d002      	beq.n	41ffe <ull_initialise+0x4e>
   41ff8:	b280      	uxth	r0, r0
   41ffa:	2800      	cmp	r0, #0
   41ffc:	d141      	bne.n	42082 <ull_initialise+0xd2>
   41ffe:	2120      	movs	r1, #32
   42000:	4628      	mov	r0, r5
   42002:	f7fe fa47 	bl	40494 <_dwt_otpread>
   42006:	f5b0 7f10 	cmp.w	r0, #576	; 0x240
   4200a:	bf0c      	ite	eq
   4200c:	2301      	moveq	r3, #1
   4200e:	2300      	movne	r3, #0
   42010:	7223      	strb	r3, [r4, #8]
   42012:	f016 0f10 	tst.w	r6, #16
   42016:	d143      	bne.n	420a0 <ull_initialise+0xf0>
   42018:	f016 0f20 	tst.w	r6, #32
   4201c:	d146      	bne.n	420ac <ull_initialise+0xfc>
   4201e:	f016 0f40 	tst.w	r6, #64	; 0x40
   42022:	d149      	bne.n	420b8 <ull_initialise+0x108>
   42024:	f016 0f80 	tst.w	r6, #128	; 0x80
   42028:	d14d      	bne.n	420c6 <ull_initialise+0x116>
   4202a:	7aa3      	ldrb	r3, [r4, #10]
   4202c:	b90b      	cbnz	r3, 42032 <ull_initialise+0x82>
   4202e:	2385      	movs	r3, #133	; 0x85
   42030:	72a3      	strb	r3, [r4, #10]
   42032:	7a63      	ldrb	r3, [r4, #9]
   42034:	b90b      	cbnz	r3, 4203a <ull_initialise+0x8a>
   42036:	2374      	movs	r3, #116	; 0x74
   42038:	7263      	strb	r3, [r4, #9]
   4203a:	211f      	movs	r1, #31
   4203c:	4628      	mov	r0, r5
   4203e:	f7fe fa29 	bl	40494 <_dwt_otpread>
   42042:	7320      	strb	r0, [r4, #12]
   42044:	211e      	movs	r1, #30
   42046:	4628      	mov	r0, r5
   42048:	f7fe fa24 	bl	40494 <_dwt_otpread>
   4204c:	f010 003f 	ands.w	r0, r0, #63	; 0x3f
   42050:	bf12      	itee	ne
   42052:	7360      	strbne	r0, [r4, #13]
   42054:	232e      	moveq	r3, #46	; 0x2e
   42056:	7363      	strbeq	r3, [r4, #13]
   42058:	7b63      	ldrb	r3, [r4, #13]
   4205a:	2200      	movs	r2, #0
   4205c:	4920      	ldr	r1, [pc, #128]	; (420e0 <ull_initialise+0x130>)
   4205e:	4628      	mov	r0, r5
   42060:	f7fe fc1e 	bl	408a0 <dwt_write8bitoffsetreg>
   42064:	2135      	movs	r1, #53	; 0x35
   42066:	4628      	mov	r0, r5
   42068:	f7fe fa14 	bl	40494 <_dwt_otpread>
   4206c:	4603      	mov	r3, r0
   4206e:	bb80      	cbnz	r0, 420d2 <ull_initialise+0x122>
   42070:	2000      	movs	r0, #0
   42072:	b002      	add	sp, #8
   42074:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   42078:	2028      	movs	r0, #40	; 0x28
   4207a:	f7ee fe55 	bl	30d28 <malloc>
   4207e:	6528      	str	r0, [r5, #80]	; 0x50
   42080:	e79e      	b.n	41fc0 <ull_initialise+0x10>
   42082:	f44f 63c0 	mov.w	r3, #1536	; 0x600
   42086:	9300      	str	r3, [sp, #0]
   42088:	f64f 73ff 	movw	r3, #65535	; 0xffff
   4208c:	2200      	movs	r2, #0
   4208e:	4915      	ldr	r1, [pc, #84]	; (420e4 <ull_initialise+0x134>)
   42090:	4628      	mov	r0, r5
   42092:	f7ff fc27 	bl	418e4 <dwt_modify16bitoffsetreg>
   42096:	8a23      	ldrh	r3, [r4, #16]
   42098:	f043 0314 	orr.w	r3, r3, #20
   4209c:	8223      	strh	r3, [r4, #16]
   4209e:	e7ae      	b.n	41ffe <ull_initialise+0x4e>
   420a0:	2106      	movs	r1, #6
   420a2:	4628      	mov	r0, r5
   420a4:	f7fe f9f6 	bl	40494 <_dwt_otpread>
   420a8:	6020      	str	r0, [r4, #0]
   420aa:	e7b5      	b.n	42018 <ull_initialise+0x68>
   420ac:	2107      	movs	r1, #7
   420ae:	4628      	mov	r0, r5
   420b0:	f7fe f9f0 	bl	40494 <_dwt_otpread>
   420b4:	6060      	str	r0, [r4, #4]
   420b6:	e7b2      	b.n	4201e <ull_initialise+0x6e>
   420b8:	2108      	movs	r1, #8
   420ba:	4628      	mov	r0, r5
   420bc:	f7fe f9ea 	bl	40494 <_dwt_otpread>
   420c0:	0c00      	lsrs	r0, r0, #16
   420c2:	7260      	strb	r0, [r4, #9]
   420c4:	e7ae      	b.n	42024 <ull_initialise+0x74>
   420c6:	2109      	movs	r1, #9
   420c8:	4628      	mov	r0, r5
   420ca:	f7fe f9e3 	bl	40494 <_dwt_otpread>
   420ce:	72a0      	strb	r0, [r4, #10]
   420d0:	e7ab      	b.n	4202a <ull_initialise+0x7a>
   420d2:	2200      	movs	r2, #0
   420d4:	4904      	ldr	r1, [pc, #16]	; (420e8 <ull_initialise+0x138>)
   420d6:	4628      	mov	r0, r5
   420d8:	f7fe f9fe 	bl	404d8 <dwt_write32bitoffsetreg>
   420dc:	e7c8      	b.n	42070 <ull_initialise+0xc0>
   420de:	bf00      	nop
   420e0:	00090014 	.word	0x00090014
   420e4:	000b0008 	.word	0x000b0008
   420e8:	00090004 	.word	0x00090004

000420ec <ull_rxenable>:
   420ec:	b530      	push	{r4, r5, lr}
   420ee:	b083      	sub	sp, #12
   420f0:	4605      	mov	r5, r0
   420f2:	460c      	mov	r4, r1
   420f4:	b171      	cbz	r1, 42114 <ull_rxenable+0x28>
   420f6:	f021 0302 	bic.w	r3, r1, #2
   420fa:	3b01      	subs	r3, #1
   420fc:	2b0f      	cmp	r3, #15
   420fe:	d862      	bhi.n	421c6 <ull_rxenable+0xda>
   42100:	e8df f003 	tbb	[pc, r3]
   42104:	24616111 	.word	0x24616111
   42108:	2d616161 	.word	0x2d616161
   4210c:	61616161 	.word	0x61616161
   42110:	3a616161 	.word	0x3a616161
   42114:	2102      	movs	r1, #2
   42116:	9101      	str	r1, [sp, #4]
   42118:	2200      	movs	r2, #0
   4211a:	9200      	str	r2, [sp, #0]
   4211c:	4613      	mov	r3, r2
   4211e:	f7fd fc74 	bl	3fa0a <dwt_xfer3xxx>
   42122:	4620      	mov	r0, r4
   42124:	e010      	b.n	42148 <ull_rxenable+0x5c>
   42126:	2302      	movs	r3, #2
   42128:	9301      	str	r3, [sp, #4]
   4212a:	2200      	movs	r2, #0
   4212c:	9200      	str	r2, [sp, #0]
   4212e:	4613      	mov	r3, r2
   42130:	2104      	movs	r1, #4
   42132:	f7fd fc6a 	bl	3fa0a <dwt_xfer3xxx>
   42136:	2203      	movs	r2, #3
   42138:	2144      	movs	r1, #68	; 0x44
   4213a:	4628      	mov	r0, r5
   4213c:	f7fd fd42 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42140:	f010 0f08 	tst.w	r0, #8
   42144:	d125      	bne.n	42192 <ull_rxenable+0xa6>
   42146:	2000      	movs	r0, #0
   42148:	b003      	add	sp, #12
   4214a:	bd30      	pop	{r4, r5, pc}
   4214c:	2302      	movs	r3, #2
   4214e:	9301      	str	r3, [sp, #4]
   42150:	2200      	movs	r2, #0
   42152:	9200      	str	r2, [sp, #0]
   42154:	4613      	mov	r3, r2
   42156:	210a      	movs	r1, #10
   42158:	f7fd fc57 	bl	3fa0a <dwt_xfer3xxx>
   4215c:	e7eb      	b.n	42136 <ull_rxenable+0x4a>
   4215e:	2100      	movs	r1, #0
   42160:	f7fe f9cf 	bl	40502 <_dwt_adjust_delaytime>
   42164:	2302      	movs	r3, #2
   42166:	9301      	str	r3, [sp, #4]
   42168:	2200      	movs	r2, #0
   4216a:	9200      	str	r2, [sp, #0]
   4216c:	4613      	mov	r3, r2
   4216e:	2108      	movs	r1, #8
   42170:	4628      	mov	r0, r5
   42172:	f7fd fc4a 	bl	3fa0a <dwt_xfer3xxx>
   42176:	e7de      	b.n	42136 <ull_rxenable+0x4a>
   42178:	2101      	movs	r1, #1
   4217a:	f7fe f9c2 	bl	40502 <_dwt_adjust_delaytime>
   4217e:	2302      	movs	r3, #2
   42180:	9301      	str	r3, [sp, #4]
   42182:	2200      	movs	r2, #0
   42184:	9200      	str	r2, [sp, #0]
   42186:	4613      	mov	r3, r2
   42188:	2106      	movs	r1, #6
   4218a:	4628      	mov	r0, r5
   4218c:	f7fd fc3d 	bl	3fa0a <dwt_xfer3xxx>
   42190:	e7d1      	b.n	42136 <ull_rxenable+0x4a>
   42192:	2302      	movs	r3, #2
   42194:	9301      	str	r3, [sp, #4]
   42196:	2100      	movs	r1, #0
   42198:	9100      	str	r1, [sp, #0]
   4219a:	460b      	mov	r3, r1
   4219c:	460a      	mov	r2, r1
   4219e:	4628      	mov	r0, r5
   421a0:	f7fd fc33 	bl	3fa0a <dwt_xfer3xxx>
   421a4:	f014 0f02 	tst.w	r4, #2
   421a8:	d002      	beq.n	421b0 <ull_rxenable+0xc4>
   421aa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   421ae:	e7cb      	b.n	42148 <ull_rxenable+0x5c>
   421b0:	2102      	movs	r1, #2
   421b2:	9101      	str	r1, [sp, #4]
   421b4:	2200      	movs	r2, #0
   421b6:	9200      	str	r2, [sp, #0]
   421b8:	4613      	mov	r3, r2
   421ba:	4628      	mov	r0, r5
   421bc:	f7fd fc25 	bl	3fa0a <dwt_xfer3xxx>
   421c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   421c4:	e7c0      	b.n	42148 <ull_rxenable+0x5c>
   421c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   421ca:	e7bd      	b.n	42148 <ull_rxenable+0x5c>

000421cc <ull_softreset_no_sema_fcmd>:
   421cc:	b570      	push	{r4, r5, r6, lr}
   421ce:	b082      	sub	sp, #8
   421d0:	4606      	mov	r6, r0
   421d2:	2502      	movs	r5, #2
   421d4:	9501      	str	r5, [sp, #4]
   421d6:	2400      	movs	r4, #0
   421d8:	9400      	str	r4, [sp, #0]
   421da:	4623      	mov	r3, r4
   421dc:	4622      	mov	r2, r4
   421de:	2119      	movs	r1, #25
   421e0:	f7fd fc13 	bl	3fa0a <dwt_xfer3xxx>
   421e4:	6d33      	ldr	r3, [r6, #80]	; 0x50
   421e6:	739c      	strb	r4, [r3, #14]
   421e8:	821d      	strh	r5, [r3, #16]
   421ea:	751c      	strb	r4, [r3, #20]
   421ec:	755c      	strb	r4, [r3, #21]
   421ee:	73dc      	strb	r4, [r3, #15]
   421f0:	b002      	add	sp, #8
   421f2:	bd70      	pop	{r4, r5, r6, pc}

000421f4 <ull_softreset_fcmd>:
   421f4:	b570      	push	{r4, r5, r6, lr}
   421f6:	b082      	sub	sp, #8
   421f8:	4606      	mov	r6, r0
   421fa:	2502      	movs	r5, #2
   421fc:	9501      	str	r5, [sp, #4]
   421fe:	2400      	movs	r4, #0
   42200:	9400      	str	r4, [sp, #0]
   42202:	4623      	mov	r3, r4
   42204:	4622      	mov	r2, r4
   42206:	2118      	movs	r1, #24
   42208:	f7fd fbff 	bl	3fa0a <dwt_xfer3xxx>
   4220c:	6d33      	ldr	r3, [r6, #80]	; 0x50
   4220e:	739c      	strb	r4, [r3, #14]
   42210:	821d      	strh	r5, [r3, #16]
   42212:	751c      	strb	r4, [r3, #20]
   42214:	755c      	strb	r4, [r3, #21]
   42216:	73dc      	strb	r4, [r3, #15]
   42218:	b002      	add	sp, #8
   4221a:	bd70      	pop	{r4, r5, r6, pc}

0004221c <dwt_ioctl>:
   4221c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   42220:	b08d      	sub	sp, #52	; 0x34
   42222:	4606      	mov	r6, r0
   42224:	4615      	mov	r5, r2
   42226:	461c      	mov	r4, r3
   42228:	299c      	cmp	r1, #156	; 0x9c
   4222a:	f200 809f 	bhi.w	4236c <dwt_ioctl+0x150>
   4222e:	e8df f011 	tbh	[pc, r1, lsl #1]
   42232:	09b9      	.short	0x09b9
   42234:	00a109c4 	.word	0x00a109c4
   42238:	00c100a6 	.word	0x00c100a6
   4223c:	019d0151 	.word	0x019d0151
   42240:	015c0176 	.word	0x015c0176
   42244:	01b301ae 	.word	0x01b301ae
   42248:	01c501bc 	.word	0x01c501bc
   4224c:	01d701ce 	.word	0x01d701ce
   42250:	01e501e0 	.word	0x01e501e0
   42254:	027201ee 	.word	0x027201ee
   42258:	027e0278 	.word	0x027e0278
   4225c:	028f0289 	.word	0x028f0289
   42260:	029a0295 	.word	0x029a0295
   42264:	02a502a0 	.word	0x02a502a0
   42268:	02b702ae 	.word	0x02b702ae
   4226c:	02c902c0 	.word	0x02c902c0
   42270:	02f90304 	.word	0x02f90304
   42274:	02d202ee 	.word	0x02d202ee
   42278:	031e02e0 	.word	0x031e02e0
   4227c:	021a01f8 	.word	0x021a01f8
   42280:	02420239 	.word	0x02420239
   42284:	08ba0258 	.word	0x08ba0258
   42288:	031508bf 	.word	0x031508bf
   4228c:	032c0327 	.word	0x032c0327
   42290:	033c0336 	.word	0x033c0336
   42294:	03520347 	.word	0x03520347
   42298:	0386035b 	.word	0x0386035b
   4229c:	03a9039d 	.word	0x03a9039d
   422a0:	03b5030a 	.word	0x03b5030a
   422a4:	03d203bf 	.word	0x03d203bf
   422a8:	040b03f9 	.word	0x040b03f9
   422ac:	0457044d 	.word	0x0457044d
   422b0:	048c047d 	.word	0x048c047d
   422b4:	049504a7 	.word	0x049504a7
   422b8:	04f704b1 	.word	0x04f704b1
   422bc:	052f050f 	.word	0x052f050f
   422c0:	05580544 	.word	0x05580544
   422c4:	057d0561 	.word	0x057d0561
   422c8:	0692056a 	.word	0x0692056a
   422cc:	071106c1 	.word	0x071106c1
   422d0:	07220717 	.word	0x07220717
   422d4:	075b073b 	.word	0x075b073b
   422d8:	078f0765 	.word	0x078f0765
   422dc:	07c607bd 	.word	0x07c607bd
   422e0:	07d507cc 	.word	0x07d507cc
   422e4:	07ef07e2 	.word	0x07ef07e2
   422e8:	080207f9 	.word	0x080207f9
   422ec:	0816080b 	.word	0x0816080b
   422f0:	08270821 	.word	0x08270821
   422f4:	0855084a 	.word	0x0855084a
   422f8:	086b0860 	.word	0x086b0860
   422fc:	0898088d 	.word	0x0898088d
   42300:	08c508b1 	.word	0x08c508b1
   42304:	0959094f 	.word	0x0959094f
   42308:	09cc0964 	.word	0x09cc0964
   4230c:	09ae096e 	.word	0x09ae096e
   42310:	090306b3 	.word	0x090306b3
   42314:	0a3a0924 	.word	0x0a3a0924
   42318:	09d90a2f 	.word	0x09d90a2f
   4231c:	09ef09e4 	.word	0x09ef09e4
   42320:	0a0509fa 	.word	0x0a0509fa
   42324:	0a1b0a10 	.word	0x0a1b0a10
   42328:	0c320a24 	.word	0x0c320a24
   4232c:	0ca30c69 	.word	0x0ca30c69
   42330:	0e2d0cc5 	.word	0x0e2d0cc5
   42334:	0a4a0e41 	.word	0x0a4a0e41
   42338:	0b890b57 	.word	0x0b890b57
   4233c:	0b970b93 	.word	0x0b970b93
   42340:	0ba50b9b 	.word	0x0ba50b9b
   42344:	0bc10bb7 	.word	0x0bc10bb7
   42348:	0be80bd4 	.word	0x0be80bd4
   4234c:	0cdb0c22 	.word	0x0cdb0c22
   42350:	0cfd0ce5 	.word	0x0cfd0ce5
   42354:	0d2d0d18 	.word	0x0d2d0d18
   42358:	0d890d4d 	.word	0x0d890d4d
   4235c:	0db70da1 	.word	0x0db70da1
   42360:	0efc0dc7 	.word	0x0efc0dc7
   42364:	0dec0df6 	.word	0x0dec0df6
   42368:	0e000e08 	.word	0x0e000e08
   4236c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   42370:	f001 be5c 	b.w	4402c <dwt_ioctl+0x1e10>
   42374:	f7fd fb28 	bl	3f9c8 <ull_wakeup_ic>
   42378:	2500      	movs	r5, #0
   4237a:	f001 be57 	b.w	4402c <dwt_ioctl+0x1e10>
   4237e:	2202      	movs	r2, #2
   42380:	49c0      	ldr	r1, [pc, #768]	; (42684 <dwt_ioctl+0x468>)
   42382:	f7fd fc1f 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42386:	2803      	cmp	r0, #3
   42388:	d802      	bhi.n	42390 <dwt_ioctl+0x174>
   4238a:	2500      	movs	r5, #0
   4238c:	f001 be4e 	b.w	4402c <dwt_ioctl+0x1e10>
   42390:	f7ec fa0a 	bl	2e7a8 <decamutexon>
   42394:	4604      	mov	r4, r0
   42396:	2302      	movs	r3, #2
   42398:	9301      	str	r3, [sp, #4]
   4239a:	2500      	movs	r5, #0
   4239c:	9500      	str	r5, [sp, #0]
   4239e:	462b      	mov	r3, r5
   423a0:	462a      	mov	r2, r5
   423a2:	4629      	mov	r1, r5
   423a4:	4630      	mov	r0, r6
   423a6:	f7fd fb30 	bl	3fa0a <dwt_xfer3xxx>
   423aa:	4620      	mov	r0, r4
   423ac:	f7ec fa03 	bl	2e7b6 <decamutexoff>
   423b0:	f001 be3c 	b.w	4402c <dwt_ioctl+0x1e10>
   423b4:	2c00      	cmp	r4, #0
   423b6:	f001 863d 	beq.w	44034 <dwt_ioctl+0x1e18>
   423ba:	7824      	ldrb	r4, [r4, #0]
   423bc:	f014 0f1d 	tst.w	r4, #29
   423c0:	d063      	beq.n	4248a <dwt_ioctl+0x26e>
   423c2:	f014 0f01 	tst.w	r4, #1
   423c6:	d025      	beq.n	42414 <dwt_ioctl+0x1f8>
   423c8:	f014 0f02 	tst.w	r4, #2
   423cc:	f04f 0302 	mov.w	r3, #2
   423d0:	9301      	str	r3, [sp, #4]
   423d2:	f04f 0200 	mov.w	r2, #0
   423d6:	9200      	str	r2, [sp, #0]
   423d8:	4613      	mov	r3, r2
   423da:	bf14      	ite	ne
   423dc:	210d      	movne	r1, #13
   423de:	2103      	moveq	r1, #3
   423e0:	f7fd fb13 	bl	3fa0a <dwt_xfer3xxx>
   423e4:	2203      	movs	r2, #3
   423e6:	2144      	movs	r1, #68	; 0x44
   423e8:	4630      	mov	r0, r6
   423ea:	f7fd fbeb 	bl	3fbc4 <dwt_read8bitoffsetreg>
   423ee:	f010 0f08 	tst.w	r0, #8
   423f2:	bf08      	it	eq
   423f4:	2500      	moveq	r5, #0
   423f6:	f001 8619 	beq.w	4402c <dwt_ioctl+0x1e10>
   423fa:	2302      	movs	r3, #2
   423fc:	9301      	str	r3, [sp, #4]
   423fe:	2100      	movs	r1, #0
   42400:	9100      	str	r1, [sp, #0]
   42402:	460b      	mov	r3, r1
   42404:	460a      	mov	r2, r1
   42406:	4630      	mov	r0, r6
   42408:	f7fd faff 	bl	3fa0a <dwt_xfer3xxx>
   4240c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   42410:	f001 be0c 	b.w	4402c <dwt_ioctl+0x1e10>
   42414:	f014 0f08 	tst.w	r4, #8
   42418:	d111      	bne.n	4243e <dwt_ioctl+0x222>
   4241a:	f014 0f10 	tst.w	r4, #16
   4241e:	d121      	bne.n	42464 <dwt_ioctl+0x248>
   42420:	f014 0f02 	tst.w	r4, #2
   42424:	f04f 0302 	mov.w	r3, #2
   42428:	9301      	str	r3, [sp, #4]
   4242a:	f04f 0200 	mov.w	r2, #0
   4242e:	9200      	str	r2, [sp, #0]
   42430:	4613      	mov	r3, r2
   42432:	bf14      	ite	ne
   42434:	2110      	movne	r1, #16
   42436:	2109      	moveq	r1, #9
   42438:	f7fd fae7 	bl	3fa0a <dwt_xfer3xxx>
   4243c:	e7d2      	b.n	423e4 <dwt_ioctl+0x1c8>
   4243e:	2100      	movs	r1, #0
   42440:	f7fe f85f 	bl	40502 <_dwt_adjust_delaytime>
   42444:	f014 0f02 	tst.w	r4, #2
   42448:	f04f 0302 	mov.w	r3, #2
   4244c:	9301      	str	r3, [sp, #4]
   4244e:	f04f 0200 	mov.w	r2, #0
   42452:	9200      	str	r2, [sp, #0]
   42454:	4613      	mov	r3, r2
   42456:	bf14      	ite	ne
   42458:	210f      	movne	r1, #15
   4245a:	2107      	moveq	r1, #7
   4245c:	4630      	mov	r0, r6
   4245e:	f7fd fad4 	bl	3fa0a <dwt_xfer3xxx>
   42462:	e7bf      	b.n	423e4 <dwt_ioctl+0x1c8>
   42464:	2101      	movs	r1, #1
   42466:	f7fe f84c 	bl	40502 <_dwt_adjust_delaytime>
   4246a:	f014 0f02 	tst.w	r4, #2
   4246e:	f04f 0302 	mov.w	r3, #2
   42472:	9301      	str	r3, [sp, #4]
   42474:	f04f 0200 	mov.w	r2, #0
   42478:	9200      	str	r2, [sp, #0]
   4247a:	4613      	mov	r3, r2
   4247c:	bf14      	ite	ne
   4247e:	210e      	movne	r1, #14
   42480:	2105      	moveq	r1, #5
   42482:	4630      	mov	r0, r6
   42484:	f7fd fac1 	bl	3fa0a <dwt_xfer3xxx>
   42488:	e7ac      	b.n	423e4 <dwt_ioctl+0x1c8>
   4248a:	f014 0f20 	tst.w	r4, #32
   4248e:	d010      	beq.n	424b2 <dwt_ioctl+0x296>
   42490:	f014 0f02 	tst.w	r4, #2
   42494:	f04f 0302 	mov.w	r3, #2
   42498:	9301      	str	r3, [sp, #4]
   4249a:	f04f 0500 	mov.w	r5, #0
   4249e:	9500      	str	r5, [sp, #0]
   424a0:	462b      	mov	r3, r5
   424a2:	462a      	mov	r2, r5
   424a4:	bf14      	ite	ne
   424a6:	2111      	movne	r1, #17
   424a8:	210b      	moveq	r1, #11
   424aa:	f7fd faae 	bl	3fa0a <dwt_xfer3xxx>
   424ae:	f001 bdbd 	b.w	4402c <dwt_ioctl+0x1e10>
   424b2:	f014 0f02 	tst.w	r4, #2
   424b6:	f04f 0302 	mov.w	r3, #2
   424ba:	9301      	str	r3, [sp, #4]
   424bc:	f04f 0500 	mov.w	r5, #0
   424c0:	9500      	str	r5, [sp, #0]
   424c2:	462b      	mov	r3, r5
   424c4:	462a      	mov	r2, r5
   424c6:	bf14      	ite	ne
   424c8:	210c      	movne	r1, #12
   424ca:	2101      	moveq	r1, #1
   424cc:	f7fd fa9d 	bl	3fa0a <dwt_xfer3xxx>
   424d0:	f001 bdac 	b.w	4402c <dwt_ioctl+0x1e10>
   424d4:	2c00      	cmp	r4, #0
   424d6:	f001 85af 	beq.w	44038 <dwt_ioctl+0x1e1c>
   424da:	6823      	ldr	r3, [r4, #0]
   424dc:	2200      	movs	r2, #0
   424de:	2128      	movs	r1, #40	; 0x28
   424e0:	f7fd fffa 	bl	404d8 <dwt_write32bitoffsetreg>
   424e4:	2500      	movs	r5, #0
   424e6:	f001 bda1 	b.w	4402c <dwt_ioctl+0x1e10>
   424ea:	6823      	ldr	r3, [r4, #0]
   424ec:	2200      	movs	r2, #0
   424ee:	4966      	ldr	r1, [pc, #408]	; (42688 <dwt_ioctl+0x46c>)
   424f0:	f7fd fff2 	bl	404d8 <dwt_write32bitoffsetreg>
   424f4:	6863      	ldr	r3, [r4, #4]
   424f6:	2200      	movs	r2, #0
   424f8:	4964      	ldr	r1, [pc, #400]	; (4268c <dwt_ioctl+0x470>)
   424fa:	4630      	mov	r0, r6
   424fc:	f7fd ffec 	bl	404d8 <dwt_write32bitoffsetreg>
   42500:	68a3      	ldr	r3, [r4, #8]
   42502:	2200      	movs	r2, #0
   42504:	4962      	ldr	r1, [pc, #392]	; (42690 <dwt_ioctl+0x474>)
   42506:	4630      	mov	r0, r6
   42508:	f7fd ffe6 	bl	404d8 <dwt_write32bitoffsetreg>
   4250c:	68e3      	ldr	r3, [r4, #12]
   4250e:	2200      	movs	r2, #0
   42510:	4960      	ldr	r1, [pc, #384]	; (42694 <dwt_ioctl+0x478>)
   42512:	4630      	mov	r0, r6
   42514:	f7fd ffe0 	bl	404d8 <dwt_write32bitoffsetreg>
   42518:	2500      	movs	r5, #0
   4251a:	f001 bd87 	b.w	4402c <dwt_ioctl+0x1e10>
   4251e:	2c00      	cmp	r4, #0
   42520:	f001 858c 	beq.w	4403c <dwt_ioctl+0x1e20>
   42524:	8823      	ldrh	r3, [r4, #0]
   42526:	6865      	ldr	r5, [r4, #4]
   42528:	2d03      	cmp	r5, #3
   4252a:	f201 8589 	bhi.w	44040 <dwt_ioctl+0x1e24>
   4252e:	e8df f005 	tbb	[pc, r5]
   42532:	0802      	.short	0x0802
   42534:	160f      	.short	0x160f
   42536:	2200      	movs	r2, #0
   42538:	4957      	ldr	r1, [pc, #348]	; (42698 <dwt_ioctl+0x47c>)
   4253a:	f7fd ff62 	bl	40402 <dwt_write16bitoffsetreg>
   4253e:	f001 bd75 	b.w	4402c <dwt_ioctl+0x1e10>
   42542:	2202      	movs	r2, #2
   42544:	4954      	ldr	r1, [pc, #336]	; (42698 <dwt_ioctl+0x47c>)
   42546:	f7fd ff5c 	bl	40402 <dwt_write16bitoffsetreg>
   4254a:	2500      	movs	r5, #0
   4254c:	f001 bd6e 	b.w	4402c <dwt_ioctl+0x1e10>
   42550:	2200      	movs	r2, #0
   42552:	4952      	ldr	r1, [pc, #328]	; (4269c <dwt_ioctl+0x480>)
   42554:	f7fd ff55 	bl	40402 <dwt_write16bitoffsetreg>
   42558:	2500      	movs	r5, #0
   4255a:	f001 bd67 	b.w	4402c <dwt_ioctl+0x1e10>
   4255e:	2202      	movs	r2, #2
   42560:	494e      	ldr	r1, [pc, #312]	; (4269c <dwt_ioctl+0x480>)
   42562:	f7fd ff4e 	bl	40402 <dwt_write16bitoffsetreg>
   42566:	2500      	movs	r5, #0
   42568:	f001 bd60 	b.w	4402c <dwt_ioctl+0x1e10>
   4256c:	2c00      	cmp	r4, #0
   4256e:	f001 8569 	beq.w	44044 <dwt_ioctl+0x1e28>
   42572:	7823      	ldrb	r3, [r4, #0]
   42574:	005b      	lsls	r3, r3, #1
   42576:	f003 0306 	and.w	r3, r3, #6
   4257a:	9300      	str	r3, [sp, #0]
   4257c:	f06f 0306 	mvn.w	r3, #6
   42580:	2200      	movs	r2, #0
   42582:	4947      	ldr	r1, [pc, #284]	; (426a0 <dwt_ioctl+0x484>)
   42584:	f7fe fcae 	bl	40ee4 <dwt_modify32bitoffsetreg>
   42588:	2500      	movs	r5, #0
   4258a:	f001 bd4f 	b.w	4402c <dwt_ioctl+0x1e10>
   4258e:	f7fe fccd 	bl	40f2c <ull_enablegpioclocks>
   42592:	2500      	movs	r5, #0
   42594:	f001 bd4a 	b.w	4402c <dwt_ioctl+0x1e10>
   42598:	2c00      	cmp	r4, #0
   4259a:	f001 8555 	beq.w	44048 <dwt_ioctl+0x1e2c>
   4259e:	6d03      	ldr	r3, [r0, #80]	; 0x50
   425a0:	7b1b      	ldrb	r3, [r3, #12]
   425a2:	7023      	strb	r3, [r4, #0]
   425a4:	2500      	movs	r5, #0
   425a6:	f001 bd41 	b.w	4402c <dwt_ioctl+0x1e10>
   425aa:	2c00      	cmp	r4, #0
   425ac:	f001 854e 	beq.w	4404c <dwt_ioctl+0x1e30>
   425b0:	6d03      	ldr	r3, [r0, #80]	; 0x50
   425b2:	7a5b      	ldrb	r3, [r3, #9]
   425b4:	7023      	strb	r3, [r4, #0]
   425b6:	2500      	movs	r5, #0
   425b8:	f001 bd38 	b.w	4402c <dwt_ioctl+0x1e10>
   425bc:	2c00      	cmp	r4, #0
   425be:	f001 8547 	beq.w	44050 <dwt_ioctl+0x1e34>
   425c2:	6d03      	ldr	r3, [r0, #80]	; 0x50
   425c4:	7a9b      	ldrb	r3, [r3, #10]
   425c6:	7023      	strb	r3, [r4, #0]
   425c8:	2500      	movs	r5, #0
   425ca:	f001 bd2f 	b.w	4402c <dwt_ioctl+0x1e10>
   425ce:	2c00      	cmp	r4, #0
   425d0:	f001 8540 	beq.w	44054 <dwt_ioctl+0x1e38>
   425d4:	6d03      	ldr	r3, [r0, #80]	; 0x50
   425d6:	681b      	ldr	r3, [r3, #0]
   425d8:	6023      	str	r3, [r4, #0]
   425da:	2500      	movs	r5, #0
   425dc:	f001 bd26 	b.w	4402c <dwt_ioctl+0x1e10>
   425e0:	2c00      	cmp	r4, #0
   425e2:	f001 8539 	beq.w	44058 <dwt_ioctl+0x1e3c>
   425e6:	6d03      	ldr	r3, [r0, #80]	; 0x50
   425e8:	685b      	ldr	r3, [r3, #4]
   425ea:	6023      	str	r3, [r4, #0]
   425ec:	2500      	movs	r5, #0
   425ee:	f001 bd1d 	b.w	4402c <dwt_ioctl+0x1e10>
   425f2:	f7fe fae1 	bl	40bb8 <ull_signal_rx_buff_free>
   425f6:	2500      	movs	r5, #0
   425f8:	f001 bd18 	b.w	4402c <dwt_ioctl+0x1e10>
   425fc:	2c00      	cmp	r4, #0
   425fe:	f001 852d 	beq.w	4405c <dwt_ioctl+0x1e40>
   42602:	6821      	ldr	r1, [r4, #0]
   42604:	f7fd ffa3 	bl	4054e <ull_setrxaftertxdelay>
   42608:	2500      	movs	r5, #0
   4260a:	f001 bd0f 	b.w	4402c <dwt_ioctl+0x1e10>
   4260e:	2c00      	cmp	r4, #0
   42610:	f001 8526 	beq.w	44060 <dwt_ioctl+0x1e44>
   42614:	6862      	ldr	r2, [r4, #4]
   42616:	7821      	ldrb	r1, [r4, #0]
   42618:	f7fe fde8 	bl	411ec <ull_enablespicrccheck>
   4261c:	2500      	movs	r5, #0
   4261e:	f001 bd05 	b.w	4402c <dwt_ioctl+0x1e10>
   42622:	2c00      	cmp	r4, #0
   42624:	f001 851e 	beq.w	44064 <dwt_ioctl+0x1e48>
   42628:	6865      	ldr	r5, [r4, #4]
   4262a:	7823      	ldrb	r3, [r4, #0]
   4262c:	2203      	movs	r2, #3
   4262e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
   42632:	f7fe f935 	bl	408a0 <dwt_write8bitoffsetreg>
   42636:	b94d      	cbnz	r5, 4264c <dwt_ioctl+0x430>
   42638:	2200      	movs	r2, #0
   4263a:	9200      	str	r2, [sp, #0]
   4263c:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   42640:	2110      	movs	r1, #16
   42642:	4630      	mov	r0, r6
   42644:	f7ff f94e 	bl	418e4 <dwt_modify16bitoffsetreg>
   42648:	f001 bcf0 	b.w	4402c <dwt_ioctl+0x1e10>
   4264c:	f44f 2381 	mov.w	r3, #264192	; 0x40800
   42650:	9300      	str	r3, [sp, #0]
   42652:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42656:	2200      	movs	r2, #0
   42658:	2110      	movs	r1, #16
   4265a:	4630      	mov	r0, r6
   4265c:	f7fe fc42 	bl	40ee4 <dwt_modify32bitoffsetreg>
   42660:	2500      	movs	r5, #0
   42662:	f001 bce3 	b.w	4402c <dwt_ioctl+0x1e10>
   42666:	2200      	movs	r2, #0
   42668:	4611      	mov	r1, r2
   4266a:	f7fd fa56 	bl	3fb1a <dwt_read32bitoffsetreg>
   4266e:	68b2      	ldr	r2, [r6, #8]
   42670:	6813      	ldr	r3, [r2, #0]
   42672:	4043      	eors	r3, r0
   42674:	6852      	ldr	r2, [r2, #4]
   42676:	4213      	tst	r3, r2
   42678:	bf14      	ite	ne
   4267a:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   4267e:	2500      	moveq	r5, #0
   42680:	f001 bcd4 	b.w	4402c <dwt_ioctl+0x1e10>
   42684:	000f0030 	.word	0x000f0030
   42688:	00010054 	.word	0x00010054
   4268c:	00010058 	.word	0x00010058
   42690:	0001005c 	.word	0x0001005c
   42694:	00010060 	.word	0x00010060
   42698:	0001000c 	.word	0x0001000c
   4269c:	00010010 	.word	0x00010010
   426a0:	00010008 	.word	0x00010008
   426a4:	2c00      	cmp	r4, #0
   426a6:	f001 84df 	beq.w	44068 <dwt_ioctl+0x1e4c>
   426aa:	7821      	ldrb	r1, [r4, #0]
   426ac:	f7fe fdba 	bl	41224 <ull_configciadiag>
   426b0:	2500      	movs	r5, #0
   426b2:	f001 bcbb 	b.w	4402c <dwt_ioctl+0x1e10>
   426b6:	b942      	cbnz	r2, 426ca <dwt_ioctl+0x4ae>
   426b8:	2200      	movs	r2, #0
   426ba:	9200      	str	r2, [sp, #0]
   426bc:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
   426c0:	49d2      	ldr	r1, [pc, #840]	; (42a0c <dwt_ioctl+0x7f0>)
   426c2:	f7ff f90f 	bl	418e4 <dwt_modify16bitoffsetreg>
   426c6:	f001 bcb1 	b.w	4402c <dwt_ioctl+0x1e10>
   426ca:	f44f 6300 	mov.w	r3, #2048	; 0x800
   426ce:	9300      	str	r3, [sp, #0]
   426d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
   426d4:	2200      	movs	r2, #0
   426d6:	49cd      	ldr	r1, [pc, #820]	; (42a0c <dwt_ioctl+0x7f0>)
   426d8:	f7ff f904 	bl	418e4 <dwt_modify16bitoffsetreg>
   426dc:	2500      	movs	r5, #0
   426de:	f001 bca5 	b.w	4402c <dwt_ioctl+0x1e10>
   426e2:	f002 0201 	and.w	r2, r2, #1
   426e6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   426ea:	f24f 71ff 	movw	r1, #63487	; 0xf7ff
   426ee:	2a00      	cmp	r2, #0
   426f0:	bf08      	it	eq
   426f2:	460b      	moveq	r3, r1
   426f4:	02d2      	lsls	r2, r2, #11
   426f6:	f015 0f02 	tst.w	r5, #2
   426fa:	bf12      	itee	ne
   426fc:	f442 5280 	orrne.w	r2, r2, #4096	; 0x1000
   42700:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   42704:	b29b      	uxtheq	r3, r3
   42706:	9200      	str	r2, [sp, #0]
   42708:	2200      	movs	r2, #0
   4270a:	49c0      	ldr	r1, [pc, #768]	; (42a0c <dwt_ioctl+0x7f0>)
   4270c:	f7ff f8ea 	bl	418e4 <dwt_modify16bitoffsetreg>
   42710:	2500      	movs	r5, #0
   42712:	f001 bc8b 	b.w	4402c <dwt_ioctl+0x1e10>
   42716:	4611      	mov	r1, r2
   42718:	f7fd ff2e 	bl	40578 <ull_setfinegraintxseq>
   4271c:	2500      	movs	r5, #0
   4271e:	f001 bc85 	b.w	4402c <dwt_ioctl+0x1e10>
   42722:	4611      	mov	r1, r2
   42724:	f7fd ff3c 	bl	405a0 <ull_setlnapamode>
   42728:	2500      	movs	r5, #0
   4272a:	f001 bc7f 	b.w	4402c <dwt_ioctl+0x1e10>
   4272e:	2c00      	cmp	r4, #0
   42730:	f001 849c 	beq.w	4406c <dwt_ioctl+0x1e50>
   42734:	2200      	movs	r2, #0
   42736:	49b6      	ldr	r1, [pc, #728]	; (42a10 <dwt_ioctl+0x7f4>)
   42738:	f7fd fa44 	bl	3fbc4 <dwt_read8bitoffsetreg>
   4273c:	7020      	strb	r0, [r4, #0]
   4273e:	2500      	movs	r5, #0
   42740:	f001 bc74 	b.w	4402c <dwt_ioctl+0x1e10>
   42744:	4621      	mov	r1, r4
   42746:	f7fd ff4b 	bl	405e0 <ull_configurestskey>
   4274a:	2500      	movs	r5, #0
   4274c:	f001 bc6e 	b.w	4402c <dwt_ioctl+0x1e10>
   42750:	4621      	mov	r1, r4
   42752:	f7fd ff69 	bl	40628 <ull_configurestsiv>
   42756:	2500      	movs	r5, #0
   42758:	f001 bc68 	b.w	4402c <dwt_ioctl+0x1e10>
   4275c:	f7fe fd98 	bl	41290 <ull_configurestsloadiv>
   42760:	2500      	movs	r5, #0
   42762:	f001 bc63 	b.w	4402c <dwt_ioctl+0x1e10>
   42766:	4611      	mov	r1, r2
   42768:	f7fd ff82 	bl	40670 <ull_configmrxlut>
   4276c:	2500      	movs	r5, #0
   4276e:	f001 bc5d 	b.w	4402c <dwt_ioctl+0x1e10>
   42772:	f7fe feb3 	bl	414dc <ull_restoreconfig>
   42776:	2500      	movs	r5, #0
   42778:	f001 bc58 	b.w	4402c <dwt_ioctl+0x1e10>
   4277c:	2c00      	cmp	r4, #0
   4277e:	f001 8477 	beq.w	44070 <dwt_ioctl+0x1e54>
   42782:	7821      	ldrb	r1, [r4, #0]
   42784:	f7ff f8c8 	bl	41918 <ull_configurestsmode>
   42788:	2500      	movs	r5, #0
   4278a:	f001 bc4f 	b.w	4402c <dwt_ioctl+0x1e10>
   4278e:	2c00      	cmp	r4, #0
   42790:	f001 8470 	beq.w	44074 <dwt_ioctl+0x1e58>
   42794:	8821      	ldrh	r1, [r4, #0]
   42796:	f7fd fe44 	bl	40422 <ull_setrxantennadelay>
   4279a:	2500      	movs	r5, #0
   4279c:	f001 bc46 	b.w	4402c <dwt_ioctl+0x1e10>
   427a0:	2c00      	cmp	r4, #0
   427a2:	f001 8469 	beq.w	44078 <dwt_ioctl+0x1e5c>
   427a6:	f7fd f9e0 	bl	3fb6a <ull_getrxantennadelay>
   427aa:	8020      	strh	r0, [r4, #0]
   427ac:	2500      	movs	r5, #0
   427ae:	f001 bc3d 	b.w	4402c <dwt_ioctl+0x1e10>
   427b2:	2c00      	cmp	r4, #0
   427b4:	f001 8462 	beq.w	4407c <dwt_ioctl+0x1e60>
   427b8:	8821      	ldrh	r1, [r4, #0]
   427ba:	f7fd fe3a 	bl	40432 <ull_settxantennadelay>
   427be:	2500      	movs	r5, #0
   427c0:	f001 bc34 	b.w	4402c <dwt_ioctl+0x1e10>
   427c4:	2c00      	cmp	r4, #0
   427c6:	f001 845b 	beq.w	44080 <dwt_ioctl+0x1e64>
   427ca:	f7fd f9d5 	bl	3fb78 <ull_gettxantennadelay>
   427ce:	8020      	strh	r0, [r4, #0]
   427d0:	2500      	movs	r5, #0
   427d2:	f001 bc2b 	b.w	4402c <dwt_ioctl+0x1e10>
   427d6:	2c00      	cmp	r4, #0
   427d8:	f001 8454 	beq.w	44084 <dwt_ioctl+0x1e68>
   427dc:	88a3      	ldrh	r3, [r4, #4]
   427de:	88e2      	ldrh	r2, [r4, #6]
   427e0:	6821      	ldr	r1, [r4, #0]
   427e2:	9100      	str	r1, [sp, #0]
   427e4:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   427e8:	f7fd fe00 	bl	403ec <dwt_writetodevice>
   427ec:	2500      	movs	r5, #0
   427ee:	f001 bc1d 	b.w	4402c <dwt_ioctl+0x1e10>
   427f2:	2c00      	cmp	r4, #0
   427f4:	f001 8448 	beq.w	44088 <dwt_ioctl+0x1e6c>
   427f8:	88a3      	ldrh	r3, [r4, #4]
   427fa:	88e2      	ldrh	r2, [r4, #6]
   427fc:	6821      	ldr	r1, [r4, #0]
   427fe:	9100      	str	r1, [sp, #0]
   42800:	f44f 11b0 	mov.w	r1, #1441792	; 0x160000
   42804:	f7fd f97f 	bl	3fb06 <dwt_readfromdevice>
   42808:	2500      	movs	r5, #0
   4280a:	f001 bc0f 	b.w	4402c <dwt_ioctl+0x1e10>
   4280e:	2c00      	cmp	r4, #0
   42810:	f001 843c 	beq.w	4408c <dwt_ioctl+0x1e70>
   42814:	88e3      	ldrh	r3, [r4, #6]
   42816:	88a2      	ldrh	r2, [r4, #4]
   42818:	6821      	ldr	r1, [r4, #0]
   4281a:	f7fe f80b 	bl	40834 <ull_readrxdata>
   4281e:	2500      	movs	r5, #0
   42820:	f001 bc04 	b.w	4402c <dwt_ioctl+0x1e10>
   42824:	2c00      	cmp	r4, #0
   42826:	f001 8433 	beq.w	44090 <dwt_ioctl+0x1e74>
   4282a:	88e3      	ldrh	r3, [r4, #6]
   4282c:	6822      	ldr	r2, [r4, #0]
   4282e:	88a1      	ldrh	r1, [r4, #4]
   42830:	f7fe f990 	bl	40b54 <ull_writetxdata>
   42834:	2500      	movs	r5, #0
   42836:	f001 bbf9 	b.w	4402c <dwt_ioctl+0x1e10>
   4283a:	4611      	mov	r1, r2
   4283c:	f7ff fc56 	bl	420ec <ull_rxenable>
   42840:	2500      	movs	r5, #0
   42842:	f001 bbf3 	b.w	4402c <dwt_ioctl+0x1e10>
   42846:	2c00      	cmp	r4, #0
   42848:	f001 8424 	beq.w	44094 <dwt_ioctl+0x1e78>
   4284c:	7923      	ldrb	r3, [r4, #4]
   4284e:	8862      	ldrh	r2, [r4, #2]
   42850:	8821      	ldrh	r1, [r4, #0]
   42852:	f7fe fc97 	bl	41184 <ull_writetxfctrl>
   42856:	2500      	movs	r5, #0
   42858:	f001 bbe8 	b.w	4402c <dwt_ioctl+0x1e10>
   4285c:	2c00      	cmp	r4, #0
   4285e:	f001 841b 	beq.w	44098 <dwt_ioctl+0x1e7c>
   42862:	f7fd f98f 	bl	3fb84 <ull_readclockoffset>
   42866:	8020      	strh	r0, [r4, #0]
   42868:	2500      	movs	r5, #0
   4286a:	f001 bbdf 	b.w	4402c <dwt_ioctl+0x1e10>
   4286e:	2c00      	cmp	r4, #0
   42870:	f001 8414 	beq.w	4409c <dwt_ioctl+0x1e80>
   42874:	f7fd f9b4 	bl	3fbe0 <ull_readcarrierintegrator>
   42878:	6020      	str	r0, [r4, #0]
   4287a:	2500      	movs	r5, #0
   4287c:	f001 bbd6 	b.w	4402c <dwt_ioctl+0x1e10>
   42880:	f7fe f866 	bl	40950 <ull_clearaonconfig>
   42884:	2500      	movs	r5, #0
   42886:	f001 bbd1 	b.w	4402c <dwt_ioctl+0x1e10>
   4288a:	2c00      	cmp	r4, #0
   4288c:	f001 8408 	beq.w	440a0 <dwt_ioctl+0x1e84>
   42890:	8861      	ldrh	r1, [r4, #2]
   42892:	f7fe fe53 	bl	4153c <ull_calcbandwidthadj>
   42896:	7020      	strb	r0, [r4, #0]
   42898:	2500      	movs	r5, #0
   4289a:	f001 bbc7 	b.w	4402c <dwt_ioctl+0x1e10>
   4289e:	4621      	mov	r1, r4
   428a0:	f7fd f9be 	bl	3fc20 <ull_readdiagnostics>
   428a4:	2500      	movs	r5, #0
   428a6:	f001 bbc1 	b.w	4402c <dwt_ioctl+0x1e10>
   428aa:	2c00      	cmp	r4, #0
   428ac:	f001 83fa 	beq.w	440a4 <dwt_ioctl+0x1e88>
   428b0:	2201      	movs	r2, #1
   428b2:	2170      	movs	r1, #112	; 0x70
   428b4:	f7fd f931 	bl	3fb1a <dwt_read32bitoffsetreg>
   428b8:	6020      	str	r0, [r4, #0]
   428ba:	2500      	movs	r5, #0
   428bc:	f001 bbb6 	b.w	4402c <dwt_ioctl+0x1e10>
   428c0:	2c00      	cmp	r4, #0
   428c2:	f001 83f1 	beq.w	440a8 <dwt_ioctl+0x1e8c>
   428c6:	2200      	movs	r2, #0
   428c8:	2170      	movs	r1, #112	; 0x70
   428ca:	f7fd f926 	bl	3fb1a <dwt_read32bitoffsetreg>
   428ce:	6020      	str	r0, [r4, #0]
   428d0:	2500      	movs	r5, #0
   428d2:	f001 bbab 	b.w	4402c <dwt_ioctl+0x1e10>
   428d6:	9400      	str	r4, [sp, #0]
   428d8:	2305      	movs	r3, #5
   428da:	2200      	movs	r2, #0
   428dc:	2170      	movs	r1, #112	; 0x70
   428de:	f7fd f912 	bl	3fb06 <dwt_readfromdevice>
   428e2:	2500      	movs	r5, #0
   428e4:	f001 bba2 	b.w	4402c <dwt_ioctl+0x1e10>
   428e8:	2c00      	cmp	r4, #0
   428ea:	f001 83df 	beq.w	440ac <dwt_ioctl+0x1e90>
   428ee:	6d03      	ldr	r3, [r0, #80]	; 0x50
   428f0:	7b9b      	ldrb	r3, [r3, #14]
   428f2:	2b01      	cmp	r3, #1
   428f4:	d015      	beq.n	42922 <dwt_ioctl+0x706>
   428f6:	2b03      	cmp	r3, #3
   428f8:	d11a      	bne.n	42930 <dwt_ioctl+0x714>
   428fa:	2216      	movs	r2, #22
   428fc:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   42900:	f7fd f921 	bl	3fb46 <dwt_read16bitoffsetreg>
   42904:	f3c0 000d 	ubfx	r0, r0, #0, #14
   42908:	b283      	uxth	r3, r0
   4290a:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   4290e:	d004      	beq.n	4291a <dwt_ioctl+0x6fe>
   42910:	ea6f 4383 	mvn.w	r3, r3, lsl #18
   42914:	ea6f 4393 	mvn.w	r3, r3, lsr #18
   42918:	b218      	sxth	r0, r3
   4291a:	8020      	strh	r0, [r4, #0]
   4291c:	2500      	movs	r5, #0
   4291e:	f001 bb85 	b.w	4402c <dwt_ioctl+0x1e10>
   42922:	2202      	movs	r2, #2
   42924:	493b      	ldr	r1, [pc, #236]	; (42a14 <dwt_ioctl+0x7f8>)
   42926:	f7fd f90e 	bl	3fb46 <dwt_read16bitoffsetreg>
   4292a:	f3c0 000d 	ubfx	r0, r0, #0, #14
   4292e:	e7eb      	b.n	42908 <dwt_ioctl+0x6ec>
   42930:	2202      	movs	r2, #2
   42932:	4939      	ldr	r1, [pc, #228]	; (42a18 <dwt_ioctl+0x7fc>)
   42934:	f7fd f907 	bl	3fb46 <dwt_read16bitoffsetreg>
   42938:	f3c0 000d 	ubfx	r0, r0, #0, #14
   4293c:	e7e4      	b.n	42908 <dwt_ioctl+0x6ec>
   4293e:	9400      	str	r4, [sp, #0]
   42940:	2306      	movs	r3, #6
   42942:	2200      	movs	r2, #0
   42944:	4935      	ldr	r1, [pc, #212]	; (42a1c <dwt_ioctl+0x800>)
   42946:	f7fd f8de 	bl	3fb06 <dwt_readfromdevice>
   4294a:	f994 3001 	ldrsb.w	r3, [r4, #1]
   4294e:	2b00      	cmp	r3, #0
   42950:	db06      	blt.n	42960 <dwt_ioctl+0x744>
   42952:	7963      	ldrb	r3, [r4, #5]
   42954:	f003 0301 	and.w	r3, r3, #1
   42958:	7163      	strb	r3, [r4, #5]
   4295a:	2500      	movs	r5, #0
   4295c:	f001 bb66 	b.w	4402c <dwt_ioctl+0x1e10>
   42960:	23ff      	movs	r3, #255	; 0xff
   42962:	70a3      	strb	r3, [r4, #2]
   42964:	70e3      	strb	r3, [r4, #3]
   42966:	7123      	strb	r3, [r4, #4]
   42968:	7163      	strb	r3, [r4, #5]
   4296a:	e7f2      	b.n	42952 <dwt_ioctl+0x736>
   4296c:	2c00      	cmp	r4, #0
   4296e:	f001 839f 	beq.w	440b0 <dwt_ioctl+0x1e94>
   42972:	2201      	movs	r2, #1
   42974:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   42978:	f7fd f924 	bl	3fbc4 <dwt_read8bitoffsetreg>
   4297c:	7020      	strb	r0, [r4, #0]
   4297e:	2500      	movs	r5, #0
   42980:	f001 bb54 	b.w	4402c <dwt_ioctl+0x1e10>
   42984:	2c00      	cmp	r4, #0
   42986:	f001 8395 	beq.w	440b4 <dwt_ioctl+0x1e98>
   4298a:	2200      	movs	r2, #0
   4298c:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   42990:	f7fd f918 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42994:	7020      	strb	r0, [r4, #0]
   42996:	2500      	movs	r5, #0
   42998:	f001 bb48 	b.w	4402c <dwt_ioctl+0x1e10>
   4299c:	2c00      	cmp	r4, #0
   4299e:	f001 838b 	beq.w	440b8 <dwt_ioctl+0x1e9c>
   429a2:	88a2      	ldrh	r2, [r4, #4]
   429a4:	6821      	ldr	r1, [r4, #0]
   429a6:	f7fe fb17 	bl	40fd8 <_dwt_otpprogword32>
   429aa:	2500      	movs	r5, #0
   429ac:	f001 bb3e 	b.w	4402c <dwt_ioctl+0x1e10>
   429b0:	2c00      	cmp	r4, #0
   429b2:	f001 8383 	beq.w	440bc <dwt_ioctl+0x1ea0>
   429b6:	6825      	ldr	r5, [r4, #0]
   429b8:	88a4      	ldrh	r4, [r4, #4]
   429ba:	4622      	mov	r2, r4
   429bc:	4629      	mov	r1, r5
   429be:	f7fe fb0b 	bl	40fd8 <_dwt_otpprogword32>
   429c2:	4621      	mov	r1, r4
   429c4:	4630      	mov	r0, r6
   429c6:	f7fd fd65 	bl	40494 <_dwt_otpread>
   429ca:	1a2d      	subs	r5, r5, r0
   429cc:	bf18      	it	ne
   429ce:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
   429d2:	f001 bb2b 	b.w	4402c <dwt_ioctl+0x1e10>
   429d6:	2a02      	cmp	r2, #2
   429d8:	d00f      	beq.n	429fa <dwt_ioctl+0x7de>
   429da:	4c11      	ldr	r4, [pc, #68]	; (42a20 <dwt_ioctl+0x804>)
   429dc:	2300      	movs	r3, #0
   429de:	461a      	mov	r2, r3
   429e0:	4621      	mov	r1, r4
   429e2:	4630      	mov	r0, r6
   429e4:	f7fd ff5c 	bl	408a0 <dwt_write8bitoffsetreg>
   429e8:	2302      	movs	r3, #2
   429ea:	2200      	movs	r2, #0
   429ec:	4621      	mov	r1, r4
   429ee:	4630      	mov	r0, r6
   429f0:	f7fd ff56 	bl	408a0 <dwt_write8bitoffsetreg>
   429f4:	2500      	movs	r5, #0
   429f6:	f001 bb19 	b.w	4402c <dwt_ioctl+0x1e10>
   429fa:	2300      	movs	r3, #0
   429fc:	9300      	str	r3, [sp, #0]
   429fe:	23fe      	movs	r3, #254	; 0xfe
   42a00:	2201      	movs	r2, #1
   42a02:	4902      	ldr	r1, [pc, #8]	; (42a0c <dwt_ioctl+0x7f0>)
   42a04:	f7fe fbde 	bl	411c4 <dwt_modify8bitoffsetreg>
   42a08:	e7e7      	b.n	429da <dwt_ioctl+0x7be>
   42a0a:	bf00      	nop
   42a0c:	00110008 	.word	0x00110008
   42a10:	0007001c 	.word	0x0007001c
   42a14:	00180014 	.word	0x00180014
   42a18:	000c001c 	.word	0x000c001c
   42a1c:	000c0018 	.word	0x000c0018
   42a20:	000a0004 	.word	0x000a0004
   42a24:	2c00      	cmp	r4, #0
   42a26:	f001 834b 	beq.w	440c0 <dwt_ioctl+0x1ea4>
   42a2a:	8824      	ldrh	r4, [r4, #0]
   42a2c:	b2e2      	uxtb	r2, r4
   42a2e:	f44f 7181 	mov.w	r1, #258	; 0x102
   42a32:	f7fd ffe1 	bl	409f8 <ull_aon_write>
   42a36:	0a22      	lsrs	r2, r4, #8
   42a38:	f240 1103 	movw	r1, #259	; 0x103
   42a3c:	4630      	mov	r0, r6
   42a3e:	f7fd ffdb 	bl	409f8 <ull_aon_write>
   42a42:	2500      	movs	r5, #0
   42a44:	f001 baf2 	b.w	4402c <dwt_ioctl+0x1e10>
   42a48:	2c00      	cmp	r4, #0
   42a4a:	f001 833b 	beq.w	440c4 <dwt_ioctl+0x1ea8>
   42a4e:	f8df 8370 	ldr.w	r8, [pc, #880]	; 42dc0 <dwt_ioctl+0xba4>
   42a52:	2310      	movs	r3, #16
   42a54:	9300      	str	r3, [sp, #0]
   42a56:	23ff      	movs	r3, #255	; 0xff
   42a58:	2200      	movs	r2, #0
   42a5a:	4641      	mov	r1, r8
   42a5c:	f7fe fbb2 	bl	411c4 <dwt_modify8bitoffsetreg>
   42a60:	f44f 7182 	mov.w	r1, #260	; 0x104
   42a64:	4630      	mov	r0, r6
   42a66:	f7fd ffa7 	bl	409b8 <ull_aon_read>
   42a6a:	f000 05e0 	and.w	r5, r0, #224	; 0xe0
   42a6e:	462a      	mov	r2, r5
   42a70:	f44f 7182 	mov.w	r1, #260	; 0x104
   42a74:	4630      	mov	r0, r6
   42a76:	f7fd ffbf 	bl	409f8 <ull_aon_write>
   42a7a:	f045 0204 	orr.w	r2, r5, #4
   42a7e:	f44f 7182 	mov.w	r1, #260	; 0x104
   42a82:	4630      	mov	r0, r6
   42a84:	f7fd ffb8 	bl	409f8 <ull_aon_write>
   42a88:	2002      	movs	r0, #2
   42a8a:	f7eb fea0 	bl	2e7ce <deca_sleep>
   42a8e:	f44f 7187 	mov.w	r1, #270	; 0x10e
   42a92:	4630      	mov	r0, r6
   42a94:	f7fd ff90 	bl	409b8 <ull_aon_read>
   42a98:	4607      	mov	r7, r0
   42a9a:	f240 110f 	movw	r1, #271	; 0x10f
   42a9e:	4630      	mov	r0, r6
   42aa0:	f7fd ff8a 	bl	409b8 <ull_aon_read>
   42aa4:	4681      	mov	r9, r0
   42aa6:	462a      	mov	r2, r5
   42aa8:	f44f 7182 	mov.w	r1, #260	; 0x104
   42aac:	4630      	mov	r0, r6
   42aae:	f7fd ffa3 	bl	409f8 <ull_aon_write>
   42ab2:	2500      	movs	r5, #0
   42ab4:	9500      	str	r5, [sp, #0]
   42ab6:	23ef      	movs	r3, #239	; 0xef
   42ab8:	462a      	mov	r2, r5
   42aba:	4641      	mov	r1, r8
   42abc:	4630      	mov	r0, r6
   42abe:	f7fe fb81 	bl	411c4 <dwt_modify8bitoffsetreg>
   42ac2:	ea47 2709 	orr.w	r7, r7, r9, lsl #8
   42ac6:	8027      	strh	r7, [r4, #0]
   42ac8:	f001 bab0 	b.w	4402c <dwt_ioctl+0x1e10>
   42acc:	2c00      	cmp	r4, #0
   42ace:	f001 82fb 	beq.w	440c8 <dwt_ioctl+0x1eac>
   42ad2:	78a2      	ldrb	r2, [r4, #2]
   42ad4:	8821      	ldrh	r1, [r4, #0]
   42ad6:	f7fd ffb7 	bl	40a48 <ull_configuresleep>
   42ada:	2500      	movs	r5, #0
   42adc:	f001 baa6 	b.w	4402c <dwt_ioctl+0x1e10>
   42ae0:	2c00      	cmp	r4, #0
   42ae2:	f001 82f3 	beq.w	440cc <dwt_ioctl+0x1eb0>
   42ae6:	6824      	ldr	r4, [r4, #0]
   42ae8:	f7fd ff32 	bl	40950 <ull_clearaonconfig>
   42aec:	2001      	movs	r0, #1
   42aee:	f7eb fe6e 	bl	2e7ce <deca_sleep>
   42af2:	2303      	movs	r3, #3
   42af4:	9300      	str	r3, [sp, #0]
   42af6:	23ff      	movs	r3, #255	; 0xff
   42af8:	2200      	movs	r2, #0
   42afa:	49af      	ldr	r1, [pc, #700]	; (42db8 <dwt_ioctl+0xb9c>)
   42afc:	4630      	mov	r0, r6
   42afe:	f7fe fb61 	bl	411c4 <dwt_modify8bitoffsetreg>
   42b02:	b97c      	cbnz	r4, 42b24 <dwt_ioctl+0x908>
   42b04:	4630      	mov	r0, r6
   42b06:	f7ff fb61 	bl	421cc <ull_softreset_no_sema_fcmd>
   42b0a:	2001      	movs	r0, #1
   42b0c:	f7eb fe5f 	bl	2e7ce <deca_sleep>
   42b10:	6d33      	ldr	r3, [r6, #80]	; 0x50
   42b12:	2500      	movs	r5, #0
   42b14:	739d      	strb	r5, [r3, #14]
   42b16:	2202      	movs	r2, #2
   42b18:	821a      	strh	r2, [r3, #16]
   42b1a:	751d      	strb	r5, [r3, #20]
   42b1c:	755d      	strb	r5, [r3, #21]
   42b1e:	73dd      	strb	r5, [r3, #15]
   42b20:	f001 ba84 	b.w	4402c <dwt_ioctl+0x1e10>
   42b24:	4630      	mov	r0, r6
   42b26:	f7ff fb65 	bl	421f4 <ull_softreset_fcmd>
   42b2a:	e7ee      	b.n	42b0a <dwt_ioctl+0x8ee>
   42b2c:	2c00      	cmp	r4, #0
   42b2e:	f001 82cf 	beq.w	440d0 <dwt_ioctl+0x1eb4>
   42b32:	7823      	ldrb	r3, [r4, #0]
   42b34:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   42b38:	6d02      	ldr	r2, [r0, #80]	; 0x50
   42b3a:	7353      	strb	r3, [r2, #13]
   42b3c:	2200      	movs	r2, #0
   42b3e:	499f      	ldr	r1, [pc, #636]	; (42dbc <dwt_ioctl+0xba0>)
   42b40:	f7fd feae 	bl	408a0 <dwt_write8bitoffsetreg>
   42b44:	2500      	movs	r5, #0
   42b46:	f001 ba71 	b.w	4402c <dwt_ioctl+0x1e10>
   42b4a:	2c00      	cmp	r4, #0
   42b4c:	f001 82c2 	beq.w	440d4 <dwt_ioctl+0x1eb8>
   42b50:	6d03      	ldr	r3, [r0, #80]	; 0x50
   42b52:	7b5b      	ldrb	r3, [r3, #13]
   42b54:	7023      	strb	r3, [r4, #0]
   42b56:	2500      	movs	r5, #0
   42b58:	f001 ba68 	b.w	4402c <dwt_ioctl+0x1e10>
   42b5c:	2101      	movs	r1, #1
   42b5e:	f7fe f9f5 	bl	40f4c <ull_enable_rf_tx>
   42b62:	4630      	mov	r0, r6
   42b64:	f7fe fa26 	bl	40fb4 <ull_enable_rftx_blocks>
   42b68:	2101      	movs	r1, #1
   42b6a:	4630      	mov	r0, r6
   42b6c:	f7fd fc68 	bl	40440 <ull_force_clocks>
   42b70:	220f      	movs	r2, #15
   42b72:	2101      	movs	r1, #1
   42b74:	4630      	mov	r0, r6
   42b76:	f7fd fe39 	bl	407ec <ull_repeated_cw>
   42b7a:	2500      	movs	r5, #0
   42b7c:	f001 ba56 	b.w	4402c <dwt_ioctl+0x1e10>
   42b80:	2c00      	cmp	r4, #0
   42b82:	f001 82a9 	beq.w	440d8 <dwt_ioctl+0x1ebc>
   42b86:	6862      	ldr	r2, [r4, #4]
   42b88:	6821      	ldr	r1, [r4, #0]
   42b8a:	f7fd fe2f 	bl	407ec <ull_repeated_cw>
   42b8e:	2500      	movs	r5, #0
   42b90:	f001 ba4c 	b.w	4402c <dwt_ioctl+0x1e10>
   42b94:	2c00      	cmp	r4, #0
   42b96:	f001 82a1 	beq.w	440dc <dwt_ioctl+0x1ec0>
   42b9a:	4d89      	ldr	r5, [pc, #548]	; (42dc0 <dwt_ioctl+0xba4>)
   42b9c:	2200      	movs	r2, #0
   42b9e:	4629      	mov	r1, r5
   42ba0:	f7fd f810 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42ba4:	4680      	mov	r8, r0
   42ba6:	2302      	movs	r3, #2
   42ba8:	9300      	str	r3, [sp, #0]
   42baa:	23ff      	movs	r3, #255	; 0xff
   42bac:	2200      	movs	r2, #0
   42bae:	4629      	mov	r1, r5
   42bb0:	4630      	mov	r0, r6
   42bb2:	f7fe fb07 	bl	411c4 <dwt_modify8bitoffsetreg>
   42bb6:	2304      	movs	r3, #4
   42bb8:	2200      	movs	r2, #0
   42bba:	4982      	ldr	r1, [pc, #520]	; (42dc4 <dwt_ioctl+0xba8>)
   42bbc:	4630      	mov	r0, r6
   42bbe:	f7fd fe6f 	bl	408a0 <dwt_write8bitoffsetreg>
   42bc2:	2301      	movs	r3, #1
   42bc4:	2200      	movs	r2, #0
   42bc6:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   42bca:	4630      	mov	r0, r6
   42bcc:	f7fd fe68 	bl	408a0 <dwt_write8bitoffsetreg>
   42bd0:	4f7d      	ldr	r7, [pc, #500]	; (42dc8 <dwt_ioctl+0xbac>)
   42bd2:	2500      	movs	r5, #0
   42bd4:	462a      	mov	r2, r5
   42bd6:	4639      	mov	r1, r7
   42bd8:	4630      	mov	r0, r6
   42bda:	f7fc fff3 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42bde:	f010 0f01 	tst.w	r0, #1
   42be2:	d0f7      	beq.n	42bd4 <dwt_ioctl+0x9b8>
   42be4:	2200      	movs	r2, #0
   42be6:	f04f 1108 	mov.w	r1, #524296	; 0x80008
   42bea:	4630      	mov	r0, r6
   42bec:	f7fc ffab 	bl	3fb46 <dwt_read16bitoffsetreg>
   42bf0:	4605      	mov	r5, r0
   42bf2:	2300      	movs	r3, #0
   42bf4:	461a      	mov	r2, r3
   42bf6:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   42bfa:	4630      	mov	r0, r6
   42bfc:	f7fd fe50 	bl	408a0 <dwt_write8bitoffsetreg>
   42c00:	2300      	movs	r3, #0
   42c02:	461a      	mov	r2, r3
   42c04:	496f      	ldr	r1, [pc, #444]	; (42dc4 <dwt_ioctl+0xba8>)
   42c06:	4630      	mov	r0, r6
   42c08:	f7fd fe4a 	bl	408a0 <dwt_write8bitoffsetreg>
   42c0c:	4643      	mov	r3, r8
   42c0e:	2200      	movs	r2, #0
   42c10:	496b      	ldr	r1, [pc, #428]	; (42dc0 <dwt_ioctl+0xba4>)
   42c12:	4630      	mov	r0, r6
   42c14:	f7fd fe44 	bl	408a0 <dwt_write8bitoffsetreg>
   42c18:	8025      	strh	r5, [r4, #0]
   42c1a:	2500      	movs	r5, #0
   42c1c:	f001 ba06 	b.w	4402c <dwt_ioctl+0x1e10>
   42c20:	2c00      	cmp	r4, #0
   42c22:	f001 825d 	beq.w	440e0 <dwt_ioctl+0x1ec4>
   42c26:	7923      	ldrb	r3, [r4, #4]
   42c28:	6d02      	ldr	r2, [r0, #80]	; 0x50
   42c2a:	7a92      	ldrb	r2, [r2, #10]
   42c2c:	1a9b      	subs	r3, r3, r2
   42c2e:	ee07 3a90 	vmov	s15, r3
   42c32:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   42c36:	ed9f 7a65 	vldr	s14, [pc, #404]	; 42dcc <dwt_ioctl+0xbb0>
   42c3a:	ee67 7a87 	vmul.f32	s15, s15, s14
   42c3e:	eeb3 7a06 	vmov.f32	s14, #54	; 0x41b00000  22.0
   42c42:	ee77 7a87 	vadd.f32	s15, s15, s14
   42c46:	edc4 7a00 	vstr	s15, [r4]
   42c4a:	2500      	movs	r5, #0
   42c4c:	f001 b9ee 	b.w	4402c <dwt_ioctl+0x1e10>
   42c50:	2c00      	cmp	r4, #0
   42c52:	f001 8247 	beq.w	440e4 <dwt_ioctl+0x1ec8>
   42c56:	7923      	ldrb	r3, [r4, #4]
   42c58:	6d02      	ldr	r2, [r0, #80]	; 0x50
   42c5a:	7a52      	ldrb	r2, [r2, #9]
   42c5c:	1a9b      	subs	r3, r3, r2
   42c5e:	ee07 3a90 	vmov	s15, r3
   42c62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
   42c66:	ed9f 7a5a 	vldr	s14, [pc, #360]	; 42dd0 <dwt_ioctl+0xbb4>
   42c6a:	ee67 7a87 	vmul.f32	s15, s15, s14
   42c6e:	eeb3 7a00 	vmov.f32	s14, #48	; 0x41800000  16.0
   42c72:	ee67 7a87 	vmul.f32	s15, s15, s14
   42c76:	eddf 6a57 	vldr	s13, [pc, #348]	; 42dd4 <dwt_ioctl+0xbb8>
   42c7a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
   42c7e:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
   42c82:	ee77 7a27 	vadd.f32	s15, s14, s15
   42c86:	edc4 7a00 	vstr	s15, [r4]
   42c8a:	2500      	movs	r5, #0
   42c8c:	f001 b9ce 	b.w	4402c <dwt_ioctl+0x1e10>
   42c90:	2c00      	cmp	r4, #0
   42c92:	f001 8229 	beq.w	440e8 <dwt_ioctl+0x1ecc>
   42c96:	6824      	ldr	r4, [r4, #0]
   42c98:	2101      	movs	r1, #1
   42c9a:	f7fe f957 	bl	40f4c <ull_enable_rf_tx>
   42c9e:	4630      	mov	r0, r6
   42ca0:	f7fe f988 	bl	40fb4 <ull_enable_rftx_blocks>
   42ca4:	2101      	movs	r1, #1
   42ca6:	4630      	mov	r0, r6
   42ca8:	f7fd fbca 	bl	40440 <ull_force_clocks>
   42cac:	4621      	mov	r1, r4
   42cae:	4630      	mov	r0, r6
   42cb0:	f7fe fca0 	bl	415f4 <ull_repeated_frames>
   42cb4:	2500      	movs	r5, #0
   42cb6:	f001 b9b9 	b.w	4402c <dwt_ioctl+0x1e10>
   42cba:	2500      	movs	r5, #0
   42cbc:	9500      	str	r5, [sp, #0]
   42cbe:	23ef      	movs	r3, #239	; 0xef
   42cc0:	462a      	mov	r2, r5
   42cc2:	4945      	ldr	r1, [pc, #276]	; (42dd8 <dwt_ioctl+0xbbc>)
   42cc4:	f7fe fa7e 	bl	411c4 <dwt_modify8bitoffsetreg>
   42cc8:	2105      	movs	r1, #5
   42cca:	4630      	mov	r0, r6
   42ccc:	f7fd fbb8 	bl	40440 <ull_force_clocks>
   42cd0:	2101      	movs	r1, #1
   42cd2:	4630      	mov	r0, r6
   42cd4:	f7fd fd6c 	bl	407b0 <ull_disable_rf_tx>
   42cd8:	4630      	mov	r0, r6
   42cda:	f7fd fd5f 	bl	4079c <ull_disable_rftx_blocks>
   42cde:	f001 b9a5 	b.w	4402c <dwt_ioctl+0x1e10>
   42ce2:	2500      	movs	r5, #0
   42ce4:	9500      	str	r5, [sp, #0]
   42ce6:	23ef      	movs	r3, #239	; 0xef
   42ce8:	462a      	mov	r2, r5
   42cea:	493b      	ldr	r1, [pc, #236]	; (42dd8 <dwt_ioctl+0xbbc>)
   42cec:	f7fe fa6a 	bl	411c4 <dwt_modify8bitoffsetreg>
   42cf0:	f001 b99c 	b.w	4402c <dwt_ioctl+0x1e10>
   42cf4:	2c00      	cmp	r4, #0
   42cf6:	f001 81f9 	beq.w	440ec <dwt_ioctl+0x1ed0>
   42cfa:	6821      	ldr	r1, [r4, #0]
   42cfc:	f7fe fc7a 	bl	415f4 <ull_repeated_frames>
   42d00:	2500      	movs	r5, #0
   42d02:	f001 b993 	b.w	4402c <dwt_ioctl+0x1e10>
   42d06:	2200      	movs	r2, #0
   42d08:	4934      	ldr	r1, [pc, #208]	; (42ddc <dwt_ioctl+0xbc0>)
   42d0a:	f7fc ff1c 	bl	3fb46 <dwt_read16bitoffsetreg>
   42d0e:	f3c0 050b 	ubfx	r5, r0, #0, #12
   42d12:	f410 6f00 	tst.w	r0, #2048	; 0x800
   42d16:	bf18      	it	ne
   42d18:	f445 4570 	orrne.w	r5, r5, #61440	; 0xf000
   42d1c:	b22d      	sxth	r5, r5
   42d1e:	8025      	strh	r5, [r4, #0]
   42d20:	6d33      	ldr	r3, [r6, #80]	; 0x50
   42d22:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
   42d26:	1aed      	subs	r5, r5, r3
   42d28:	f001 b980 	b.w	4402c <dwt_ioctl+0x1e10>
   42d2c:	2c00      	cmp	r4, #0
   42d2e:	f001 81df 	beq.w	440f0 <dwt_ioctl+0x1ed4>
   42d32:	f8d4 9004 	ldr.w	r9, [r4, #4]
   42d36:	7a23      	ldrb	r3, [r4, #8]
   42d38:	f899 2013 	ldrb.w	r2, [r9, #19]
   42d3c:	2aff      	cmp	r2, #255	; 0xff
   42d3e:	f000 80fe 	beq.w	42f3e <dwt_ioctl+0xd22>
   42d42:	bb93      	cbnz	r3, 42daa <dwt_ioctl+0xb8e>
   42d44:	f8d9 1000 	ldr.w	r1, [r9]
   42d48:	f7fd feb8 	bl	40abc <ull_update_nonce_GCM>
   42d4c:	f899 300c 	ldrb.w	r3, [r9, #12]
   42d50:	f8b9 200e 	ldrh.w	r2, [r9, #14]
   42d54:	18d1      	adds	r1, r2, r3
   42d56:	f899 2012 	ldrb.w	r2, [r9, #18]
   42d5a:	2a00      	cmp	r2, #0
   42d5c:	d140      	bne.n	42de0 <dwt_ioctl+0xbc4>
   42d5e:	f899 0010 	ldrb.w	r0, [r9, #16]
   42d62:	2800      	cmp	r0, #0
   42d64:	bf0b      	itete	eq
   42d66:	227f      	moveq	r2, #127	; 0x7f
   42d68:	f44f 6280 	movne.w	r2, #1024	; 0x400
   42d6c:	f44f 15b0 	moveq.w	r5, #1441792	; 0x160000
   42d70:	f44f 15a0 	movne.w	r5, #1310720	; 0x140000
   42d74:	f899 0013 	ldrb.w	r0, [r9, #19]
   42d78:	1a12      	subs	r2, r2, r0
   42d7a:	3a02      	subs	r2, #2
   42d7c:	4291      	cmp	r1, r2
   42d7e:	f200 80e7 	bhi.w	42f50 <dwt_ioctl+0xd34>
   42d82:	f8d9 2004 	ldr.w	r2, [r9, #4]
   42d86:	9200      	str	r2, [sp, #0]
   42d88:	2200      	movs	r2, #0
   42d8a:	4629      	mov	r1, r5
   42d8c:	4630      	mov	r0, r6
   42d8e:	f7fd fb2d 	bl	403ec <dwt_writetodevice>
   42d92:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   42d96:	f899 200c 	ldrb.w	r2, [r9, #12]
   42d9a:	f8d9 1008 	ldr.w	r1, [r9, #8]
   42d9e:	9100      	str	r1, [sp, #0]
   42da0:	4629      	mov	r1, r5
   42da2:	4630      	mov	r0, r6
   42da4:	f7fd fb22 	bl	403ec <dwt_writetodevice>
   42da8:	e02b      	b.n	42e02 <dwt_ioctl+0xbe6>
   42daa:	f8b9 200e 	ldrh.w	r2, [r9, #14]
   42dae:	f8d9 1000 	ldr.w	r1, [r9]
   42db2:	f7fd fe91 	bl	40ad8 <ull_update_nonce_CCM>
   42db6:	e7c9      	b.n	42d4c <dwt_ioctl+0xb30>
   42db8:	00110004 	.word	0x00110004
   42dbc:	00090014 	.word	0x00090014
   42dc0:	00070048 	.word	0x00070048
   42dc4:	00070034 	.word	0x00070034
   42dc8:	00080004 	.word	0x00080004
   42dcc:	3f866666 	.word	0x3f866666
   42dd0:	3ecccccd 	.word	0x3ecccccd
   42dd4:	437f0000 	.word	0x437f0000
   42dd8:	000f0028 	.word	0x000f0028
   42ddc:	00020008 	.word	0x00020008
   42de0:	2a01      	cmp	r2, #1
   42de2:	f040 80af 	bne.w	42f44 <dwt_ioctl+0xd28>
   42de6:	f899 3011 	ldrb.w	r3, [r9, #17]
   42dea:	2b00      	cmp	r3, #0
   42dec:	f240 33ff 	movw	r3, #1023	; 0x3ff
   42df0:	bf08      	it	eq
   42df2:	237f      	moveq	r3, #127	; 0x7f
   42df4:	f899 2013 	ldrb.w	r2, [r9, #19]
   42df8:	1a9b      	subs	r3, r3, r2
   42dfa:	3b02      	subs	r3, #2
   42dfc:	4299      	cmp	r1, r3
   42dfe:	f200 80a4 	bhi.w	42f4a <dwt_ioctl+0xd2e>
   42e02:	f899 2010 	ldrb.w	r2, [r9, #16]
   42e06:	1e53      	subs	r3, r2, #1
   42e08:	b2db      	uxtb	r3, r3
   42e0a:	2b01      	cmp	r3, #1
   42e0c:	d940      	bls.n	42e90 <dwt_ioctl+0xc74>
   42e0e:	f899 3011 	ldrb.w	r3, [r9, #17]
   42e12:	1e59      	subs	r1, r3, #1
   42e14:	b2c9      	uxtb	r1, r1
   42e16:	2901      	cmp	r1, #1
   42e18:	d947      	bls.n	42eaa <dwt_ioctl+0xc8e>
   42e1a:	2b04      	cmp	r3, #4
   42e1c:	d04c      	beq.n	42eb8 <dwt_ioctl+0xc9c>
   42e1e:	ea42 3343 	orr.w	r3, r2, r3, lsl #13
   42e22:	2200      	movs	r2, #0
   42e24:	49ba      	ldr	r1, [pc, #744]	; (43110 <dwt_ioctl+0xef4>)
   42e26:	4630      	mov	r0, r6
   42e28:	f7fd fb56 	bl	404d8 <dwt_write32bitoffsetreg>
   42e2c:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   42e30:	4ab8      	ldr	r2, [pc, #736]	; (43114 <dwt_ioctl+0xef8>)
   42e32:	ea02 12c3 	and.w	r2, r2, r3, lsl #7
   42e36:	f899 300c 	ldrb.w	r3, [r9, #12]
   42e3a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
   42e3e:	4313      	orrs	r3, r2
   42e40:	2200      	movs	r2, #0
   42e42:	49b5      	ldr	r1, [pc, #724]	; (43118 <dwt_ioctl+0xefc>)
   42e44:	4630      	mov	r0, r6
   42e46:	f7fd fb47 	bl	404d8 <dwt_write32bitoffsetreg>
   42e4a:	2301      	movs	r3, #1
   42e4c:	2200      	movs	r2, #0
   42e4e:	49b3      	ldr	r1, [pc, #716]	; (4311c <dwt_ioctl+0xf00>)
   42e50:	4630      	mov	r0, r6
   42e52:	f7fd fd25 	bl	408a0 <dwt_write8bitoffsetreg>
   42e56:	f8df 82c8 	ldr.w	r8, [pc, #712]	; 43120 <dwt_ioctl+0xf04>
   42e5a:	2700      	movs	r7, #0
   42e5c:	463a      	mov	r2, r7
   42e5e:	4641      	mov	r1, r8
   42e60:	4630      	mov	r0, r6
   42e62:	f7fc feaf 	bl	3fbc4 <dwt_read8bitoffsetreg>
   42e66:	f010 0f05 	tst.w	r0, #5
   42e6a:	d0f7      	beq.n	42e5c <dwt_ioctl+0xc40>
   42e6c:	4605      	mov	r5, r0
   42e6e:	4603      	mov	r3, r0
   42e70:	2200      	movs	r2, #0
   42e72:	49ab      	ldr	r1, [pc, #684]	; (43120 <dwt_ioctl+0xf04>)
   42e74:	4630      	mov	r0, r6
   42e76:	f7fd fd13 	bl	408a0 <dwt_write8bitoffsetreg>
   42e7a:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   42e7e:	f025 0330 	bic.w	r3, r5, #48	; 0x30
   42e82:	2b01      	cmp	r3, #1
   42e84:	d025      	beq.n	42ed2 <dwt_ioctl+0xcb6>
   42e86:	b26b      	sxtb	r3, r5
   42e88:	7023      	strb	r3, [r4, #0]
   42e8a:	2500      	movs	r5, #0
   42e8c:	f001 b8ce 	b.w	4402c <dwt_ioctl+0x1e10>
   42e90:	6d33      	ldr	r3, [r6, #80]	; 0x50
   42e92:	7b9b      	ldrb	r3, [r3, #14]
   42e94:	2b03      	cmp	r3, #3
   42e96:	f001 81af 	beq.w	441f8 <dwt_ioctl+0x1fdc>
   42e9a:	f899 3011 	ldrb.w	r3, [r9, #17]
   42e9e:	1e5a      	subs	r2, r3, #1
   42ea0:	b2d2      	uxtb	r2, r2
   42ea2:	2a01      	cmp	r2, #1
   42ea4:	d912      	bls.n	42ecc <dwt_ioctl+0xcb0>
   42ea6:	2201      	movs	r2, #1
   42ea8:	e7b7      	b.n	42e1a <dwt_ioctl+0xbfe>
   42eaa:	6d33      	ldr	r3, [r6, #80]	; 0x50
   42eac:	7b9b      	ldrb	r3, [r3, #14]
   42eae:	2b03      	cmp	r3, #3
   42eb0:	bf0c      	ite	eq
   42eb2:	2302      	moveq	r3, #2
   42eb4:	2301      	movne	r3, #1
   42eb6:	e7b2      	b.n	42e1e <dwt_ioctl+0xc02>
   42eb8:	f8b9 100e 	ldrh.w	r1, [r9, #14]
   42ebc:	2910      	cmp	r1, #16
   42ebe:	d9ae      	bls.n	42e1e <dwt_ioctl+0xc02>
   42ec0:	f06f 0303 	mvn.w	r3, #3
   42ec4:	e7e0      	b.n	42e88 <dwt_ioctl+0xc6c>
   42ec6:	2202      	movs	r2, #2
   42ec8:	4613      	mov	r3, r2
   42eca:	e7a8      	b.n	42e1e <dwt_ioctl+0xc02>
   42ecc:	2201      	movs	r2, #1
   42ece:	4613      	mov	r3, r2
   42ed0:	e7a5      	b.n	42e1e <dwt_ioctl+0xc02>
   42ed2:	f899 3012 	ldrb.w	r3, [r9, #18]
   42ed6:	2b01      	cmp	r3, #1
   42ed8:	d1d5      	bne.n	42e86 <dwt_ioctl+0xc6a>
   42eda:	f899 2011 	ldrb.w	r2, [r9, #17]
   42ede:	1e53      	subs	r3, r2, #1
   42ee0:	b2db      	uxtb	r3, r3
   42ee2:	2b01      	cmp	r3, #1
   42ee4:	d91b      	bls.n	42f1e <dwt_ioctl+0xd02>
   42ee6:	2a03      	cmp	r2, #3
   42ee8:	bf0c      	ite	eq
   42eea:	f44f 17a0 	moveq.w	r7, #1310720	; 0x140000
   42eee:	f44f 17b0 	movne.w	r7, #1441792	; 0x160000
   42ef2:	f8d9 2004 	ldr.w	r2, [r9, #4]
   42ef6:	b112      	cbz	r2, 42efe <dwt_ioctl+0xce2>
   42ef8:	f899 300c 	ldrb.w	r3, [r9, #12]
   42efc:	b9c3      	cbnz	r3, 42f30 <dwt_ioctl+0xd14>
   42efe:	f8d9 1008 	ldr.w	r1, [r9, #8]
   42f02:	2900      	cmp	r1, #0
   42f04:	d0bf      	beq.n	42e86 <dwt_ioctl+0xc6a>
   42f06:	f8b9 300e 	ldrh.w	r3, [r9, #14]
   42f0a:	2b00      	cmp	r3, #0
   42f0c:	d0bb      	beq.n	42e86 <dwt_ioctl+0xc6a>
   42f0e:	f899 200c 	ldrb.w	r2, [r9, #12]
   42f12:	9100      	str	r1, [sp, #0]
   42f14:	4639      	mov	r1, r7
   42f16:	4630      	mov	r0, r6
   42f18:	f7fc fdf5 	bl	3fb06 <dwt_readfromdevice>
   42f1c:	e7b3      	b.n	42e86 <dwt_ioctl+0xc6a>
   42f1e:	6d33      	ldr	r3, [r6, #80]	; 0x50
   42f20:	7b9b      	ldrb	r3, [r3, #14]
   42f22:	2b03      	cmp	r3, #3
   42f24:	bf0c      	ite	eq
   42f26:	f44f 1798 	moveq.w	r7, #1245184	; 0x130000
   42f2a:	f44f 1790 	movne.w	r7, #1179648	; 0x120000
   42f2e:	e7e0      	b.n	42ef2 <dwt_ioctl+0xcd6>
   42f30:	9200      	str	r2, [sp, #0]
   42f32:	2200      	movs	r2, #0
   42f34:	4639      	mov	r1, r7
   42f36:	4630      	mov	r0, r6
   42f38:	f7fc fde5 	bl	3fb06 <dwt_readfromdevice>
   42f3c:	e7df      	b.n	42efe <dwt_ioctl+0xce2>
   42f3e:	f06f 0302 	mvn.w	r3, #2
   42f42:	e7a1      	b.n	42e88 <dwt_ioctl+0xc6c>
   42f44:	f06f 0301 	mvn.w	r3, #1
   42f48:	e79e      	b.n	42e88 <dwt_ioctl+0xc6c>
   42f4a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42f4e:	e79b      	b.n	42e88 <dwt_ioctl+0xc6c>
   42f50:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   42f54:	e798      	b.n	42e88 <dwt_ioctl+0xc6c>
   42f56:	7a23      	ldrb	r3, [r4, #8]
   42f58:	79e1      	ldrb	r1, [r4, #7]
   42f5a:	79a2      	ldrb	r2, [r4, #6]
   42f5c:	00d2      	lsls	r2, r2, #3
   42f5e:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
   42f62:	4313      	orrs	r3, r2
   42f64:	7962      	ldrb	r2, [r4, #5]
   42f66:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
   42f6a:	7922      	ldrb	r2, [r4, #4]
   42f6c:	ea43 13c2 	orr.w	r3, r3, r2, lsl #7
   42f70:	78e2      	ldrb	r2, [r4, #3]
   42f72:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   42f76:	78a2      	ldrb	r2, [r4, #2]
   42f78:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
   42f7c:	7862      	ldrb	r2, [r4, #1]
   42f7e:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
   42f82:	7822      	ldrb	r2, [r4, #0]
   42f84:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
   42f88:	b29b      	uxth	r3, r3
   42f8a:	2200      	movs	r2, #0
   42f8c:	4965      	ldr	r1, [pc, #404]	; (43124 <dwt_ioctl+0xf08>)
   42f8e:	f7fd fa38 	bl	40402 <dwt_write16bitoffsetreg>
   42f92:	2500      	movs	r5, #0
   42f94:	f001 b84a 	b.w	4402c <dwt_ioctl+0x1e10>
   42f98:	2c00      	cmp	r4, #0
   42f9a:	f001 80ab 	beq.w	440f4 <dwt_ioctl+0x1ed8>
   42f9e:	7863      	ldrb	r3, [r4, #1]
   42fa0:	b133      	cbz	r3, 42fb0 <dwt_ioctl+0xd94>
   42fa2:	085b      	lsrs	r3, r3, #1
   42fa4:	3b01      	subs	r3, #1
   42fa6:	b2db      	uxtb	r3, r3
   42fa8:	7023      	strb	r3, [r4, #0]
   42faa:	2500      	movs	r5, #0
   42fac:	f001 b83e 	b.w	4402c <dwt_ioctl+0x1e10>
   42fb0:	2300      	movs	r3, #0
   42fb2:	e7f9      	b.n	42fa8 <dwt_ioctl+0xd8c>
   42fb4:	2200      	movs	r2, #0
   42fb6:	495c      	ldr	r1, [pc, #368]	; (43128 <dwt_ioctl+0xf0c>)
   42fb8:	f7fc fdaf 	bl	3fb1a <dwt_read32bitoffsetreg>
   42fbc:	f3c0 030b 	ubfx	r3, r0, #0, #12
   42fc0:	8023      	strh	r3, [r4, #0]
   42fc2:	f3c0 400b 	ubfx	r0, r0, #16, #12
   42fc6:	8060      	strh	r0, [r4, #2]
   42fc8:	2200      	movs	r2, #0
   42fca:	4958      	ldr	r1, [pc, #352]	; (4312c <dwt_ioctl+0xf10>)
   42fcc:	4630      	mov	r0, r6
   42fce:	f7fc fda4 	bl	3fb1a <dwt_read32bitoffsetreg>
   42fd2:	f3c0 030b 	ubfx	r3, r0, #0, #12
   42fd6:	80a3      	strh	r3, [r4, #4]
   42fd8:	f3c0 400b 	ubfx	r0, r0, #16, #12
   42fdc:	80e0      	strh	r0, [r4, #6]
   42fde:	2200      	movs	r2, #0
   42fe0:	4953      	ldr	r1, [pc, #332]	; (43130 <dwt_ioctl+0xf14>)
   42fe2:	4630      	mov	r0, r6
   42fe4:	f7fc fd99 	bl	3fb1a <dwt_read32bitoffsetreg>
   42fe8:	7220      	strb	r0, [r4, #8]
   42fea:	0c00      	lsrs	r0, r0, #16
   42fec:	7260      	strb	r0, [r4, #9]
   42fee:	2200      	movs	r2, #0
   42ff0:	4950      	ldr	r1, [pc, #320]	; (43134 <dwt_ioctl+0xf18>)
   42ff2:	4630      	mov	r0, r6
   42ff4:	f7fc fd91 	bl	3fb1a <dwt_read32bitoffsetreg>
   42ff8:	f3c0 430b 	ubfx	r3, r0, #16, #12
   42ffc:	81a3      	strh	r3, [r4, #12]
   42ffe:	f3c0 000b 	ubfx	r0, r0, #0, #12
   43002:	8160      	strh	r0, [r4, #10]
   43004:	2200      	movs	r2, #0
   43006:	494c      	ldr	r1, [pc, #304]	; (43138 <dwt_ioctl+0xf1c>)
   43008:	4630      	mov	r0, r6
   4300a:	f7fc fd86 	bl	3fb1a <dwt_read32bitoffsetreg>
   4300e:	f3c0 430b 	ubfx	r3, r0, #16, #12
   43012:	f8a4 300f 	strh.w	r3, [r4, #15]
   43016:	73a0      	strb	r0, [r4, #14]
   43018:	2200      	movs	r2, #0
   4301a:	4948      	ldr	r1, [pc, #288]	; (4313c <dwt_ioctl+0xf20>)
   4301c:	4630      	mov	r0, r6
   4301e:	f7fc fd7c 	bl	3fb1a <dwt_read32bitoffsetreg>
   43022:	7460      	strb	r0, [r4, #17]
   43024:	0c00      	lsrs	r0, r0, #16
   43026:	74a0      	strb	r0, [r4, #18]
   43028:	2200      	movs	r2, #0
   4302a:	4945      	ldr	r1, [pc, #276]	; (43140 <dwt_ioctl+0xf24>)
   4302c:	4630      	mov	r0, r6
   4302e:	f7fc fd74 	bl	3fb1a <dwt_read32bitoffsetreg>
   43032:	f3c0 030b 	ubfx	r3, r0, #0, #12
   43036:	f8a4 3013 	strh.w	r3, [r4, #19]
   4303a:	f3c0 400b 	ubfx	r0, r0, #16, #12
   4303e:	f8a4 0015 	strh.w	r0, [r4, #21]
   43042:	2200      	movs	r2, #0
   43044:	493f      	ldr	r1, [pc, #252]	; (43144 <dwt_ioctl+0xf28>)
   43046:	4630      	mov	r0, r6
   43048:	f7fc fdbc 	bl	3fbc4 <dwt_read8bitoffsetreg>
   4304c:	75e0      	strb	r0, [r4, #23]
   4304e:	2500      	movs	r5, #0
   43050:	f000 bfec 	b.w	4402c <dwt_ioctl+0x1e10>
   43054:	4611      	mov	r1, r2
   43056:	f7fd fc9b 	bl	40990 <ull_configeventcounters>
   4305a:	2500      	movs	r5, #0
   4305c:	f000 bfe6 	b.w	4402c <dwt_ioctl+0x1e10>
   43060:	2c00      	cmp	r4, #0
   43062:	f001 8049 	beq.w	440f8 <dwt_ioctl+0x1edc>
   43066:	8823      	ldrh	r3, [r4, #0]
   43068:	2200      	movs	r2, #0
   4306a:	4937      	ldr	r1, [pc, #220]	; (43148 <dwt_ioctl+0xf2c>)
   4306c:	f7fd f9c9 	bl	40402 <dwt_write16bitoffsetreg>
   43070:	2500      	movs	r5, #0
   43072:	f000 bfdb 	b.w	4402c <dwt_ioctl+0x1e10>
   43076:	2c00      	cmp	r4, #0
   43078:	f001 8040 	beq.w	440fc <dwt_ioctl+0x1ee0>
   4307c:	6825      	ldr	r5, [r4, #0]
   4307e:	b935      	cbnz	r5, 4308e <dwt_ioctl+0xe72>
   43080:	2300      	movs	r3, #0
   43082:	461a      	mov	r2, r3
   43084:	4931      	ldr	r1, [pc, #196]	; (4314c <dwt_ioctl+0xf30>)
   43086:	f7fd f9bc 	bl	40402 <dwt_write16bitoffsetreg>
   4308a:	f000 bfcf 	b.w	4402c <dwt_ioctl+0x1e10>
   4308e:	7962      	ldrb	r2, [r4, #5]
   43090:	7923      	ldrb	r3, [r4, #4]
   43092:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   43096:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
   4309a:	2200      	movs	r2, #0
   4309c:	492b      	ldr	r1, [pc, #172]	; (4314c <dwt_ioctl+0xf30>)
   4309e:	f7fd f9b0 	bl	40402 <dwt_write16bitoffsetreg>
   430a2:	2500      	movs	r5, #0
   430a4:	f000 bfc2 	b.w	4402c <dwt_ioctl+0x1e10>
   430a8:	2c00      	cmp	r4, #0
   430aa:	f001 8029 	beq.w	44100 <dwt_ioctl+0x1ee4>
   430ae:	6823      	ldr	r3, [r4, #0]
   430b0:	b94b      	cbnz	r3, 430c6 <dwt_ioctl+0xeaa>
   430b2:	2500      	movs	r5, #0
   430b4:	9500      	str	r5, [sp, #0]
   430b6:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   430ba:	462a      	mov	r2, r5
   430bc:	2110      	movs	r1, #16
   430be:	f7fe fc11 	bl	418e4 <dwt_modify16bitoffsetreg>
   430c2:	f000 bfb3 	b.w	4402c <dwt_ioctl+0x1e10>
   430c6:	2200      	movs	r2, #0
   430c8:	2134      	movs	r1, #52	; 0x34
   430ca:	f7fd fa05 	bl	404d8 <dwt_write32bitoffsetreg>
   430ce:	f44f 7300 	mov.w	r3, #512	; 0x200
   430d2:	9300      	str	r3, [sp, #0]
   430d4:	f64f 73ff 	movw	r3, #65535	; 0xffff
   430d8:	2200      	movs	r2, #0
   430da:	2110      	movs	r1, #16
   430dc:	4630      	mov	r0, r6
   430de:	f7fe fc01 	bl	418e4 <dwt_modify16bitoffsetreg>
   430e2:	2500      	movs	r5, #0
   430e4:	f000 bfa2 	b.w	4402c <dwt_ioctl+0x1e10>
   430e8:	2c00      	cmp	r4, #0
   430ea:	f001 800b 	beq.w	44104 <dwt_ioctl+0x1ee8>
   430ee:	8861      	ldrh	r1, [r4, #2]
   430f0:	f7fd fc62 	bl	409b8 <ull_aon_read>
   430f4:	7020      	strb	r0, [r4, #0]
   430f6:	2500      	movs	r5, #0
   430f8:	f000 bf98 	b.w	4402c <dwt_ioctl+0x1e10>
   430fc:	2c00      	cmp	r4, #0
   430fe:	f001 8003 	beq.w	44108 <dwt_ioctl+0x1eec>
   43102:	78a2      	ldrb	r2, [r4, #2]
   43104:	8821      	ldrh	r1, [r4, #0]
   43106:	f7fd fc77 	bl	409f8 <ull_aon_write>
   4310a:	2500      	movs	r5, #0
   4310c:	f000 bf8e 	b.w	4402c <dwt_ioctl+0x1e10>
   43110:	00010044 	.word	0x00010044
   43114:	0001ff80 	.word	0x0001ff80
   43118:	00010048 	.word	0x00010048
   4311c:	0001004c 	.word	0x0001004c
   43120:	00010050 	.word	0x00010050
   43124:	00010030 	.word	0x00010030
   43128:	000f0004 	.word	0x000f0004
   4312c:	000f0008 	.word	0x000f0008
   43130:	000f000c 	.word	0x000f000c
   43134:	000f0010 	.word	0x000f0010
   43138:	000f0014 	.word	0x000f0014
   4313c:	000f0018 	.word	0x000f0018
   43140:	000f001c 	.word	0x000f001c
   43144:	000f0020 	.word	0x000f0020
   43148:	00060004 	.word	0x00060004
   4314c:	0011001c 	.word	0x0011001c
   43150:	4bd5      	ldr	r3, [pc, #852]	; (434a8 <dwt_ioctl+0x128c>)
   43152:	4ad6      	ldr	r2, [pc, #856]	; (434ac <dwt_ioctl+0x1290>)
   43154:	2d01      	cmp	r5, #1
   43156:	bf18      	it	ne
   43158:	4613      	movne	r3, r2
   4315a:	2d01      	cmp	r5, #1
   4315c:	49d4      	ldr	r1, [pc, #848]	; (434b0 <dwt_ioctl+0x1294>)
   4315e:	bf18      	it	ne
   43160:	f04f 110c 	movne.w	r1, #786444	; 0xc000c
   43164:	6d02      	ldr	r2, [r0, #80]	; 0x50
   43166:	7b92      	ldrb	r2, [r2, #14]
   43168:	2a01      	cmp	r2, #1
   4316a:	d012      	beq.n	43192 <dwt_ioctl+0xf76>
   4316c:	2a03      	cmp	r2, #3
   4316e:	d117      	bne.n	431a0 <dwt_ioctl+0xf84>
   43170:	f5a2 12c0 	sub.w	r2, r2, #1572864	; 0x180000
   43174:	3a01      	subs	r2, #1
   43176:	441a      	add	r2, r3
   43178:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   4317c:	f7fc fce3 	bl	3fb46 <dwt_read16bitoffsetreg>
   43180:	09c0      	lsrs	r0, r0, #7
   43182:	8020      	strh	r0, [r4, #0]
   43184:	8825      	ldrh	r5, [r4, #0]
   43186:	3500      	adds	r5, #0
   43188:	bf18      	it	ne
   4318a:	2501      	movne	r5, #1
   4318c:	426d      	negs	r5, r5
   4318e:	f000 bf4d 	b.w	4402c <dwt_ioctl+0x1e10>
   43192:	2202      	movs	r2, #2
   43194:	4619      	mov	r1, r3
   43196:	f7fc fcd6 	bl	3fb46 <dwt_read16bitoffsetreg>
   4319a:	09c0      	lsrs	r0, r0, #7
   4319c:	8020      	strh	r0, [r4, #0]
   4319e:	e7f1      	b.n	43184 <dwt_ioctl+0xf68>
   431a0:	2202      	movs	r2, #2
   431a2:	f7fc fcd0 	bl	3fb46 <dwt_read16bitoffsetreg>
   431a6:	09c0      	lsrs	r0, r0, #7
   431a8:	8020      	strh	r0, [r4, #0]
   431aa:	e7eb      	b.n	43184 <dwt_ioctl+0xf68>
   431ac:	2c00      	cmp	r4, #0
   431ae:	f000 87ad 	beq.w	4410c <dwt_ioctl+0x1ef0>
   431b2:	7821      	ldrb	r1, [r4, #0]
   431b4:	f7fe fbd4 	bl	41960 <ull_setleds>
   431b8:	2500      	movs	r5, #0
   431ba:	f000 bf37 	b.w	4402c <dwt_ioctl+0x1e10>
   431be:	4611      	mov	r1, r2
   431c0:	f7fe fa30 	bl	41624 <ull_setdwstate>
   431c4:	2500      	movs	r5, #0
   431c6:	f000 bf31 	b.w	4402c <dwt_ioctl+0x1e10>
   431ca:	9400      	str	r4, [sp, #0]
   431cc:	2304      	movs	r3, #4
   431ce:	2200      	movs	r2, #0
   431d0:	211c      	movs	r1, #28
   431d2:	f7fc fc98 	bl	3fb06 <dwt_readfromdevice>
   431d6:	2500      	movs	r5, #0
   431d8:	f000 bf28 	b.w	4402c <dwt_ioctl+0x1e10>
   431dc:	2c00      	cmp	r4, #0
   431de:	f000 8797 	beq.w	44110 <dwt_ioctl+0x1ef4>
   431e2:	2202      	movs	r2, #2
   431e4:	2144      	movs	r1, #68	; 0x44
   431e6:	f7fc fcae 	bl	3fb46 <dwt_read16bitoffsetreg>
   431ea:	f3c0 2000 	ubfx	r0, r0, #8, #1
   431ee:	7020      	strb	r0, [r4, #0]
   431f0:	2500      	movs	r5, #0
   431f2:	f000 bf1b 	b.w	4402c <dwt_ioctl+0x1e10>
   431f6:	2c00      	cmp	r4, #0
   431f8:	f000 878c 	beq.w	44114 <dwt_ioctl+0x1ef8>
   431fc:	2200      	movs	r2, #0
   431fe:	2144      	movs	r1, #68	; 0x44
   43200:	f7fc fce0 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43204:	f000 0001 	and.w	r0, r0, #1
   43208:	7020      	strb	r0, [r4, #0]
   4320a:	2500      	movs	r5, #0
   4320c:	f000 bf0e 	b.w	4402c <dwt_ioctl+0x1e10>
   43210:	2c00      	cmp	r4, #0
   43212:	f000 8781 	beq.w	44118 <dwt_ioctl+0x1efc>
   43216:	8862      	ldrh	r2, [r4, #2]
   43218:	8821      	ldrh	r1, [r4, #0]
   4321a:	f7fe fa61 	bl	416e0 <ull_configureframefilter>
   4321e:	2500      	movs	r5, #0
   43220:	f000 bf04 	b.w	4402c <dwt_ioctl+0x1e10>
   43224:	9400      	str	r4, [sp, #0]
   43226:	2308      	movs	r3, #8
   43228:	2200      	movs	r2, #0
   4322a:	2104      	movs	r1, #4
   4322c:	f7fd f8de 	bl	403ec <dwt_writetodevice>
   43230:	2500      	movs	r5, #0
   43232:	f000 befb 	b.w	4402c <dwt_ioctl+0x1e10>
   43236:	9400      	str	r4, [sp, #0]
   43238:	2308      	movs	r3, #8
   4323a:	2200      	movs	r2, #0
   4323c:	2104      	movs	r1, #4
   4323e:	f7fc fc62 	bl	3fb06 <dwt_readfromdevice>
   43242:	2500      	movs	r5, #0
   43244:	f000 bef2 	b.w	4402c <dwt_ioctl+0x1e10>
   43248:	2c00      	cmp	r4, #0
   4324a:	f000 8767 	beq.w	4411c <dwt_ioctl+0x1f00>
   4324e:	8823      	ldrh	r3, [r4, #0]
   43250:	2202      	movs	r2, #2
   43252:	210c      	movs	r1, #12
   43254:	f7fd f8d5 	bl	40402 <dwt_write16bitoffsetreg>
   43258:	2500      	movs	r5, #0
   4325a:	f000 bee7 	b.w	4402c <dwt_ioctl+0x1e10>
   4325e:	2c00      	cmp	r4, #0
   43260:	f000 875e 	beq.w	44120 <dwt_ioctl+0x1f04>
   43264:	8823      	ldrh	r3, [r4, #0]
   43266:	2200      	movs	r2, #0
   43268:	210c      	movs	r1, #12
   4326a:	f7fd f8ca 	bl	40402 <dwt_write16bitoffsetreg>
   4326e:	2500      	movs	r5, #0
   43270:	f000 bedc 	b.w	4402c <dwt_ioctl+0x1e10>
   43274:	4621      	mov	r1, r4
   43276:	f7fd f897 	bl	403a8 <ull_readrxtimestamp>
   4327a:	2500      	movs	r5, #0
   4327c:	f000 bed6 	b.w	4402c <dwt_ioctl+0x1e10>
   43280:	6d03      	ldr	r3, [r0, #80]	; 0x50
   43282:	7b9b      	ldrb	r3, [r3, #14]
   43284:	2b01      	cmp	r3, #1
   43286:	d00b      	beq.n	432a0 <dwt_ioctl+0x1084>
   43288:	2b03      	cmp	r3, #3
   4328a:	d112      	bne.n	432b2 <dwt_ioctl+0x1096>
   4328c:	9400      	str	r4, [sp, #0]
   4328e:	2305      	movs	r3, #5
   43290:	2220      	movs	r2, #32
   43292:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   43296:	f7fc fc36 	bl	3fb06 <dwt_readfromdevice>
   4329a:	2500      	movs	r5, #0
   4329c:	f000 bec6 	b.w	4402c <dwt_ioctl+0x1e10>
   432a0:	9400      	str	r4, [sp, #0]
   432a2:	2305      	movs	r3, #5
   432a4:	2200      	movs	r2, #0
   432a6:	4983      	ldr	r1, [pc, #524]	; (434b4 <dwt_ioctl+0x1298>)
   432a8:	f7fc fc2d 	bl	3fb06 <dwt_readfromdevice>
   432ac:	2500      	movs	r5, #0
   432ae:	f000 bebd 	b.w	4402c <dwt_ioctl+0x1e10>
   432b2:	9400      	str	r4, [sp, #0]
   432b4:	2305      	movs	r3, #5
   432b6:	2200      	movs	r2, #0
   432b8:	f44f 2140 	mov.w	r1, #786432	; 0xc0000
   432bc:	f7fc fc23 	bl	3fb06 <dwt_readfromdevice>
   432c0:	2500      	movs	r5, #0
   432c2:	f000 beb3 	b.w	4402c <dwt_ioctl+0x1e10>
   432c6:	2500      	movs	r5, #0
   432c8:	f804 5b01 	strb.w	r5, [r4], #1
   432cc:	9400      	str	r4, [sp, #0]
   432ce:	2304      	movs	r3, #4
   432d0:	462a      	mov	r2, r5
   432d2:	216c      	movs	r1, #108	; 0x6c
   432d4:	f7fc fc17 	bl	3fb06 <dwt_readfromdevice>
   432d8:	f000 bea8 	b.w	4402c <dwt_ioctl+0x1e10>
   432dc:	2c00      	cmp	r4, #0
   432de:	f000 8721 	beq.w	44124 <dwt_ioctl+0x1f08>
   432e2:	2201      	movs	r2, #1
   432e4:	2160      	movs	r1, #96	; 0x60
   432e6:	f7fc fc18 	bl	3fb1a <dwt_read32bitoffsetreg>
   432ea:	6020      	str	r0, [r4, #0]
   432ec:	2500      	movs	r5, #0
   432ee:	f000 be9d 	b.w	4402c <dwt_ioctl+0x1e10>
   432f2:	2c00      	cmp	r4, #0
   432f4:	f000 8718 	beq.w	44128 <dwt_ioctl+0x1f0c>
   432f8:	2200      	movs	r2, #0
   432fa:	2160      	movs	r1, #96	; 0x60
   432fc:	f7fc fc0d 	bl	3fb1a <dwt_read32bitoffsetreg>
   43300:	6020      	str	r0, [r4, #0]
   43302:	2500      	movs	r5, #0
   43304:	f000 be92 	b.w	4402c <dwt_ioctl+0x1e10>
   43308:	6d03      	ldr	r3, [r0, #80]	; 0x50
   4330a:	7b9b      	ldrb	r3, [r3, #14]
   4330c:	2b01      	cmp	r3, #1
   4330e:	d00b      	beq.n	43328 <dwt_ioctl+0x110c>
   43310:	2b03      	cmp	r3, #3
   43312:	d112      	bne.n	4333a <dwt_ioctl+0x111e>
   43314:	9400      	str	r4, [sp, #0]
   43316:	2305      	movs	r3, #5
   43318:	2228      	movs	r2, #40	; 0x28
   4331a:	f44f 11f0 	mov.w	r1, #1966080	; 0x1e0000
   4331e:	f7fc fbf2 	bl	3fb06 <dwt_readfromdevice>
   43322:	2500      	movs	r5, #0
   43324:	f000 be82 	b.w	4402c <dwt_ioctl+0x1e10>
   43328:	9400      	str	r4, [sp, #0]
   4332a:	2305      	movs	r3, #5
   4332c:	2200      	movs	r2, #0
   4332e:	4962      	ldr	r1, [pc, #392]	; (434b8 <dwt_ioctl+0x129c>)
   43330:	f7fc fbe9 	bl	3fb06 <dwt_readfromdevice>
   43334:	2500      	movs	r5, #0
   43336:	f000 be79 	b.w	4402c <dwt_ioctl+0x1e10>
   4333a:	9400      	str	r4, [sp, #0]
   4333c:	2305      	movs	r3, #5
   4333e:	2200      	movs	r2, #0
   43340:	495e      	ldr	r1, [pc, #376]	; (434bc <dwt_ioctl+0x12a0>)
   43342:	f7fc fbe0 	bl	3fb06 <dwt_readfromdevice>
   43346:	2500      	movs	r5, #0
   43348:	f000 be70 	b.w	4402c <dwt_ioctl+0x1e10>
   4334c:	2c00      	cmp	r4, #0
   4334e:	f000 86ed 	beq.w	4412c <dwt_ioctl+0x1f10>
   43352:	2200      	movs	r2, #0
   43354:	211c      	movs	r1, #28
   43356:	f7fc fbe0 	bl	3fb1a <dwt_read32bitoffsetreg>
   4335a:	6020      	str	r0, [r4, #0]
   4335c:	2500      	movs	r5, #0
   4335e:	f000 be65 	b.w	4402c <dwt_ioctl+0x1e10>
   43362:	2c00      	cmp	r4, #0
   43364:	f000 86e4 	beq.w	44130 <dwt_ioctl+0x1f14>
   43368:	8825      	ldrh	r5, [r4, #0]
   4336a:	6867      	ldr	r7, [r4, #4]
   4336c:	7a23      	ldrb	r3, [r4, #8]
   4336e:	2b00      	cmp	r3, #0
   43370:	f000 86e0 	beq.w	44134 <dwt_ioctl+0x1f18>
   43374:	463c      	mov	r4, r7
   43376:	eb07 0783 	add.w	r7, r7, r3, lsl #2
   4337a:	4629      	mov	r1, r5
   4337c:	4630      	mov	r0, r6
   4337e:	f7fd f889 	bl	40494 <_dwt_otpread>
   43382:	f844 0b04 	str.w	r0, [r4], #4
   43386:	3501      	adds	r5, #1
   43388:	b2ad      	uxth	r5, r5
   4338a:	42bc      	cmp	r4, r7
   4338c:	d1f5      	bne.n	4337a <dwt_ioctl+0x115e>
   4338e:	2500      	movs	r5, #0
   43390:	f000 be4c 	b.w	4402c <dwt_ioctl+0x1e10>
   43394:	2c00      	cmp	r4, #0
   43396:	f000 86cf 	beq.w	44138 <dwt_ioctl+0x1f1c>
   4339a:	7821      	ldrb	r1, [r4, #0]
   4339c:	f7fd fb86 	bl	40aac <ull_setplenfine>
   433a0:	2500      	movs	r5, #0
   433a2:	f000 be43 	b.w	4402c <dwt_ioctl+0x1e10>
   433a6:	f7fe f9bf 	bl	41728 <ull_run_pgfcal>
   433aa:	4605      	mov	r5, r0
   433ac:	f000 be3e 	b.w	4402c <dwt_ioctl+0x1e10>
   433b0:	4611      	mov	r1, r2
   433b2:	f7fe fb23 	bl	419fc <ull_pgf_cal>
   433b6:	4605      	mov	r5, r0
   433b8:	f000 be38 	b.w	4402c <dwt_ioctl+0x1e10>
   433bc:	2c00      	cmp	r4, #0
   433be:	f000 86bd 	beq.w	4413c <dwt_ioctl+0x1f20>
   433c2:	78a5      	ldrb	r5, [r4, #2]
   433c4:	2101      	movs	r1, #1
   433c6:	f7fd f83b 	bl	40440 <ull_force_clocks>
   433ca:	2100      	movs	r1, #0
   433cc:	4630      	mov	r0, r6
   433ce:	f7fd fdbd 	bl	40f4c <ull_enable_rf_tx>
   433d2:	4630      	mov	r0, r6
   433d4:	f7fd fdee 	bl	40fb4 <ull_enable_rftx_blocks>
   433d8:	f005 033f 	and.w	r3, r5, #63	; 0x3f
   433dc:	2200      	movs	r2, #0
   433de:	4938      	ldr	r1, [pc, #224]	; (434c0 <dwt_ioctl+0x12a4>)
   433e0:	4630      	mov	r0, r6
   433e2:	f7fd fa5d 	bl	408a0 <dwt_write8bitoffsetreg>
   433e6:	2301      	movs	r3, #1
   433e8:	9300      	str	r3, [sp, #0]
   433ea:	23ff      	movs	r3, #255	; 0xff
   433ec:	2200      	movs	r2, #0
   433ee:	4935      	ldr	r1, [pc, #212]	; (434c4 <dwt_ioctl+0x12a8>)
   433f0:	4630      	mov	r0, r6
   433f2:	f7fd fee7 	bl	411c4 <dwt_modify8bitoffsetreg>
   433f6:	4f33      	ldr	r7, [pc, #204]	; (434c4 <dwt_ioctl+0x12a8>)
   433f8:	2500      	movs	r5, #0
   433fa:	462a      	mov	r2, r5
   433fc:	4639      	mov	r1, r7
   433fe:	4630      	mov	r0, r6
   43400:	f7fc fbe0 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43404:	f010 0f01 	tst.w	r0, #1
   43408:	d1f7      	bne.n	433fa <dwt_ioctl+0x11de>
   4340a:	2200      	movs	r2, #0
   4340c:	492e      	ldr	r1, [pc, #184]	; (434c8 <dwt_ioctl+0x12ac>)
   4340e:	4630      	mov	r0, r6
   43410:	f7fc fb99 	bl	3fb46 <dwt_read16bitoffsetreg>
   43414:	4605      	mov	r5, r0
   43416:	4630      	mov	r0, r6
   43418:	f7fd f9c0 	bl	4079c <ull_disable_rftx_blocks>
   4341c:	2100      	movs	r1, #0
   4341e:	4630      	mov	r0, r6
   43420:	f7fd f9c6 	bl	407b0 <ull_disable_rf_tx>
   43424:	2105      	movs	r1, #5
   43426:	4630      	mov	r0, r6
   43428:	f7fd f80a 	bl	40440 <ull_force_clocks>
   4342c:	f3c5 050b 	ubfx	r5, r5, #0, #12
   43430:	8025      	strh	r5, [r4, #0]
   43432:	2500      	movs	r5, #0
   43434:	f000 bdfa 	b.w	4402c <dwt_ioctl+0x1e10>
   43438:	2102      	movs	r1, #2
   4343a:	f7fe f8f3 	bl	41624 <ull_setdwstate>
   4343e:	2101      	movs	r1, #1
   43440:	4630      	mov	r0, r6
   43442:	f7fe f8ef 	bl	41624 <ull_setdwstate>
   43446:	2432      	movs	r4, #50	; 0x32
   43448:	f04f 0814 	mov.w	r8, #20
   4344c:	2700      	movs	r7, #0
   4344e:	2544      	movs	r5, #68	; 0x44
   43450:	4640      	mov	r0, r8
   43452:	f7eb f9cc 	bl	2e7ee <deca_usleep>
   43456:	463a      	mov	r2, r7
   43458:	4629      	mov	r1, r5
   4345a:	4630      	mov	r0, r6
   4345c:	f7fc fbb2 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43460:	f010 0f02 	tst.w	r0, #2
   43464:	d105      	bne.n	43472 <dwt_ioctl+0x1256>
   43466:	1e63      	subs	r3, r4, #1
   43468:	f013 04ff 	ands.w	r4, r3, #255	; 0xff
   4346c:	d1f0      	bne.n	43450 <dwt_ioctl+0x1234>
   4346e:	2501      	movs	r5, #1
   43470:	e000      	b.n	43474 <dwt_ioctl+0x1258>
   43472:	2500      	movs	r5, #0
   43474:	426d      	negs	r5, r5
   43476:	f000 bdd9 	b.w	4402c <dwt_ioctl+0x1e10>
   4347a:	2c00      	cmp	r4, #0
   4347c:	f000 8660 	beq.w	44140 <dwt_ioctl+0x1f24>
   43480:	7823      	ldrb	r3, [r4, #0]
   43482:	031b      	lsls	r3, r3, #12
   43484:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
   43488:	7862      	ldrb	r2, [r4, #1]
   4348a:	2a01      	cmp	r2, #1
   4348c:	bf08      	it	eq
   4348e:	f443 7380 	orreq.w	r3, r3, #256	; 0x100
   43492:	9300      	str	r3, [sp, #0]
   43494:	f46f 43e2 	mvn.w	r3, #28928	; 0x7100
   43498:	2200      	movs	r2, #0
   4349a:	490c      	ldr	r1, [pc, #48]	; (434cc <dwt_ioctl+0x12b0>)
   4349c:	f7fd fd22 	bl	40ee4 <dwt_modify32bitoffsetreg>
   434a0:	2500      	movs	r5, #0
   434a2:	f000 bdc3 	b.w	4402c <dwt_ioctl+0x1e10>
   434a6:	bf00      	nop
   434a8:	00180034 	.word	0x00180034
   434ac:	0018002c 	.word	0x0018002c
   434b0:	000c0014 	.word	0x000c0014
   434b4:	00180020 	.word	0x00180020
   434b8:	00180028 	.word	0x00180028
   434bc:	000c0008 	.word	0x000c0008
   434c0:	0007001c 	.word	0x0007001c
   434c4:	00080010 	.word	0x00080010
   434c8:	00080014 	.word	0x00080014
   434cc:	00070014 	.word	0x00070014
   434d0:	2c00      	cmp	r4, #0
   434d2:	f000 8637 	beq.w	44144 <dwt_ioctl+0x1f28>
   434d6:	6862      	ldr	r2, [r4, #4]
   434d8:	6821      	ldr	r1, [r4, #0]
   434da:	f7fd fe35 	bl	41148 <ull_setgpiomode>
   434de:	2500      	movs	r5, #0
   434e0:	f000 bda4 	b.w	4402c <dwt_ioctl+0x1e10>
   434e4:	2c00      	cmp	r4, #0
   434e6:	f000 862f 	beq.w	44148 <dwt_ioctl+0x1f2c>
   434ea:	8823      	ldrh	r3, [r4, #0]
   434ec:	2200      	movs	r2, #0
   434ee:	49c4      	ldr	r1, [pc, #784]	; (43800 <dwt_ioctl+0x15e4>)
   434f0:	f7fc ff87 	bl	40402 <dwt_write16bitoffsetreg>
   434f4:	2500      	movs	r5, #0
   434f6:	f000 bd99 	b.w	4402c <dwt_ioctl+0x1e10>
   434fa:	2c00      	cmp	r4, #0
   434fc:	f000 8626 	beq.w	4414c <dwt_ioctl+0x1f30>
   43500:	6862      	ldr	r2, [r4, #4]
   43502:	8821      	ldrh	r1, [r4, #0]
   43504:	f7fe faaa 	bl	41a5c <ull_setgpiovalue>
   43508:	2500      	movs	r5, #0
   4350a:	f000 bd8f 	b.w	4402c <dwt_ioctl+0x1e10>
   4350e:	2c00      	cmp	r4, #0
   43510:	f000 861e 	beq.w	44150 <dwt_ioctl+0x1f34>
   43514:	7865      	ldrb	r5, [r4, #1]
   43516:	7823      	ldrb	r3, [r4, #0]
   43518:	b18b      	cbz	r3, 4353e <dwt_ioctl+0x1322>
   4351a:	6d03      	ldr	r3, [r0, #80]	; 0x50
   4351c:	2200      	movs	r2, #0
   4351e:	739a      	strb	r2, [r3, #14]
   43520:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43524:	2208      	movs	r2, #8
   43526:	b37d      	cbz	r5, 43588 <dwt_ioctl+0x136c>
   43528:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
   4352c:	9200      	str	r2, [sp, #0]
   4352e:	2200      	movs	r2, #0
   43530:	2110      	movs	r1, #16
   43532:	4630      	mov	r0, r6
   43534:	f7fd fcd6 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43538:	2500      	movs	r5, #0
   4353a:	f000 bd77 	b.w	4402c <dwt_ioctl+0x1e10>
   4353e:	6d03      	ldr	r3, [r0, #80]	; 0x50
   43540:	2201      	movs	r2, #1
   43542:	739a      	strb	r2, [r3, #14]
   43544:	2318      	movs	r3, #24
   43546:	2200      	movs	r2, #0
   43548:	49ae      	ldr	r1, [pc, #696]	; (43804 <dwt_ioctl+0x15e8>)
   4354a:	f7fc ffc5 	bl	404d8 <dwt_write32bitoffsetreg>
   4354e:	23e8      	movs	r3, #232	; 0xe8
   43550:	2200      	movs	r2, #0
   43552:	49ad      	ldr	r1, [pc, #692]	; (43808 <dwt_ioctl+0x15ec>)
   43554:	4630      	mov	r0, r6
   43556:	f7fc ffbf 	bl	404d8 <dwt_write32bitoffsetreg>
   4355a:	6d33      	ldr	r3, [r6, #80]	; 0x50
   4355c:	7d9b      	ldrb	r3, [r3, #22]
   4355e:	085b      	lsrs	r3, r3, #1
   43560:	d003      	beq.n	4356a <dwt_ioctl+0x134e>
   43562:	f06f 0308 	mvn.w	r3, #8
   43566:	2200      	movs	r2, #0
   43568:	e7dd      	b.n	43526 <dwt_ioctl+0x130a>
   4356a:	2301      	movs	r3, #1
   4356c:	2200      	movs	r2, #0
   4356e:	49a7      	ldr	r1, [pc, #668]	; (4380c <dwt_ioctl+0x15f0>)
   43570:	4630      	mov	r0, r6
   43572:	f7fd f995 	bl	408a0 <dwt_write8bitoffsetreg>
   43576:	6d32      	ldr	r2, [r6, #80]	; 0x50
   43578:	7d93      	ldrb	r3, [r2, #22]
   4357a:	f043 0302 	orr.w	r3, r3, #2
   4357e:	7593      	strb	r3, [r2, #22]
   43580:	f06f 0308 	mvn.w	r3, #8
   43584:	2200      	movs	r2, #0
   43586:	e7ce      	b.n	43526 <dwt_ioctl+0x130a>
   43588:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   4358c:	e7ce      	b.n	4352c <dwt_ioctl+0x1310>
   4358e:	2c00      	cmp	r4, #0
   43590:	f000 85e0 	beq.w	44154 <dwt_ioctl+0x1f38>
   43594:	6823      	ldr	r3, [r4, #0]
   43596:	2200      	movs	r2, #0
   43598:	2130      	movs	r1, #48	; 0x30
   4359a:	f7fc ff9d 	bl	404d8 <dwt_write32bitoffsetreg>
   4359e:	2500      	movs	r5, #0
   435a0:	f000 bd44 	b.w	4402c <dwt_ioctl+0x1e10>
   435a4:	2c00      	cmp	r4, #0
   435a6:	f000 85d7 	beq.w	44158 <dwt_ioctl+0x1f3c>
   435aa:	2200      	movs	r2, #0
   435ac:	4629      	mov	r1, r5
   435ae:	f7fc fab4 	bl	3fb1a <dwt_read32bitoffsetreg>
   435b2:	6020      	str	r0, [r4, #0]
   435b4:	2500      	movs	r5, #0
   435b6:	f000 bd39 	b.w	4402c <dwt_ioctl+0x1e10>
   435ba:	4623      	mov	r3, r4
   435bc:	2200      	movs	r2, #0
   435be:	4629      	mov	r1, r5
   435c0:	f7fc ff8a 	bl	404d8 <dwt_write32bitoffsetreg>
   435c4:	2500      	movs	r5, #0
   435c6:	f000 bd31 	b.w	4402c <dwt_ioctl+0x1e10>
   435ca:	2c00      	cmp	r4, #0
   435cc:	f000 85c6 	beq.w	4415c <dwt_ioctl+0x1f40>
   435d0:	2203      	movs	r2, #3
   435d2:	498f      	ldr	r1, [pc, #572]	; (43810 <dwt_ioctl+0x15f4>)
   435d4:	f7fc faf6 	bl	3fbc4 <dwt_read8bitoffsetreg>
   435d8:	f3c0 1002 	ubfx	r0, r0, #4, #3
   435dc:	7020      	strb	r0, [r4, #0]
   435de:	2500      	movs	r5, #0
   435e0:	f000 bd24 	b.w	4402c <dwt_ioctl+0x1e10>
   435e4:	2c00      	cmp	r4, #0
   435e6:	f000 85bb 	beq.w	44160 <dwt_ioctl+0x1f44>
   435ea:	6823      	ldr	r3, [r4, #0]
   435ec:	2200      	movs	r2, #0
   435ee:	2144      	movs	r1, #68	; 0x44
   435f0:	f7fc ff72 	bl	404d8 <dwt_write32bitoffsetreg>
   435f4:	2500      	movs	r5, #0
   435f6:	f000 bd19 	b.w	4402c <dwt_ioctl+0x1e10>
   435fa:	2c00      	cmp	r4, #0
   435fc:	f000 85b2 	beq.w	44164 <dwt_ioctl+0x1f48>
   43600:	8823      	ldrh	r3, [r4, #0]
   43602:	2200      	movs	r2, #0
   43604:	2148      	movs	r1, #72	; 0x48
   43606:	f7fc fefc 	bl	40402 <dwt_write16bitoffsetreg>
   4360a:	2500      	movs	r5, #0
   4360c:	f000 bd0e 	b.w	4402c <dwt_ioctl+0x1e10>
   43610:	2c00      	cmp	r4, #0
   43612:	f000 85a9 	beq.w	44168 <dwt_ioctl+0x1f4c>
   43616:	2200      	movs	r2, #0
   43618:	2144      	movs	r1, #68	; 0x44
   4361a:	f7fc fa7e 	bl	3fb1a <dwt_read32bitoffsetreg>
   4361e:	6020      	str	r0, [r4, #0]
   43620:	2500      	movs	r5, #0
   43622:	f000 bd03 	b.w	4402c <dwt_ioctl+0x1e10>
   43626:	2c00      	cmp	r4, #0
   43628:	f000 85a0 	beq.w	4416c <dwt_ioctl+0x1f50>
   4362c:	2200      	movs	r2, #0
   4362e:	2148      	movs	r1, #72	; 0x48
   43630:	f7fc fa89 	bl	3fb46 <dwt_read16bitoffsetreg>
   43634:	6020      	str	r0, [r4, #0]
   43636:	2500      	movs	r5, #0
   43638:	f000 bcf8 	b.w	4402c <dwt_ioctl+0x1e10>
   4363c:	2c00      	cmp	r4, #0
   4363e:	f000 8597 	beq.w	44170 <dwt_ioctl+0x1f54>
   43642:	7823      	ldrb	r3, [r4, #0]
   43644:	2200      	movs	r2, #0
   43646:	4973      	ldr	r1, [pc, #460]	; (43814 <dwt_ioctl+0x15f8>)
   43648:	f7fd f92a 	bl	408a0 <dwt_write8bitoffsetreg>
   4364c:	2500      	movs	r5, #0
   4364e:	f000 bced 	b.w	4402c <dwt_ioctl+0x1e10>
   43652:	2c00      	cmp	r4, #0
   43654:	f000 858e 	beq.w	44174 <dwt_ioctl+0x1f58>
   43658:	2200      	movs	r2, #0
   4365a:	2144      	movs	r1, #68	; 0x44
   4365c:	f7fc fab2 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43660:	7020      	strb	r0, [r4, #0]
   43662:	2500      	movs	r5, #0
   43664:	f000 bce2 	b.w	4402c <dwt_ioctl+0x1e10>
   43668:	2c00      	cmp	r4, #0
   4366a:	f000 8585 	beq.w	44178 <dwt_ioctl+0x1f5c>
   4366e:	f7fd f923 	bl	408b8 <ull_getframelength>
   43672:	6020      	str	r0, [r4, #0]
   43674:	2500      	movs	r5, #0
   43676:	f000 bcd9 	b.w	4402c <dwt_ioctl+0x1e10>
   4367a:	2c00      	cmp	r4, #0
   4367c:	f000 857e 	beq.w	4417c <dwt_ioctl+0x1f60>
   43680:	2200      	movs	r2, #0
   43682:	4965      	ldr	r1, [pc, #404]	; (43818 <dwt_ioctl+0x15fc>)
   43684:	f7fc fa5f 	bl	3fb46 <dwt_read16bitoffsetreg>
   43688:	8020      	strh	r0, [r4, #0]
   4368a:	2500      	movs	r5, #0
   4368c:	f000 bcce 	b.w	4402c <dwt_ioctl+0x1e10>
   43690:	2c00      	cmp	r4, #0
   43692:	f000 8575 	beq.w	44180 <dwt_ioctl+0x1f64>
   43696:	2200      	movs	r2, #0
   43698:	4960      	ldr	r1, [pc, #384]	; (4381c <dwt_ioctl+0x1600>)
   4369a:	f7fc fa3e 	bl	3fb1a <dwt_read32bitoffsetreg>
   4369e:	6020      	str	r0, [r4, #0]
   436a0:	2500      	movs	r5, #0
   436a2:	f000 bcc3 	b.w	4402c <dwt_ioctl+0x1e10>
   436a6:	2c00      	cmp	r4, #0
   436a8:	f000 856c 	beq.w	44184 <dwt_ioctl+0x1f68>
   436ac:	8823      	ldrh	r3, [r4, #0]
   436ae:	f3c3 030d 	ubfx	r3, r3, #0, #14
   436b2:	9300      	str	r3, [sp, #0]
   436b4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
   436b8:	2200      	movs	r2, #0
   436ba:	4958      	ldr	r1, [pc, #352]	; (4381c <dwt_ioctl+0x1600>)
   436bc:	f7fe f912 	bl	418e4 <dwt_modify16bitoffsetreg>
   436c0:	2500      	movs	r5, #0
   436c2:	f000 bcb3 	b.w	4402c <dwt_ioctl+0x1e10>
   436c6:	2c00      	cmp	r4, #0
   436c8:	f000 855e 	beq.w	44188 <dwt_ioctl+0x1f6c>
   436cc:	88a7      	ldrh	r7, [r4, #4]
   436ce:	f8d4 b008 	ldr.w	fp, [r4, #8]
   436d2:	7b23      	ldrb	r3, [r4, #12]
   436d4:	9306      	str	r3, [sp, #24]
   436d6:	6922      	ldr	r2, [r4, #16]
   436d8:	9204      	str	r2, [sp, #16]
   436da:	6962      	ldr	r2, [r4, #20]
   436dc:	9205      	str	r2, [sp, #20]
   436de:	f00b 0203 	and.w	r2, fp, #3
   436e2:	f3cb 0585 	ubfx	r5, fp, #2, #6
   436e6:	2b05      	cmp	r3, #5
   436e8:	d147      	bne.n	4377a <dwt_ioctl+0x155e>
   436ea:	f5b7 7fb1 	cmp.w	r7, #354	; 0x162
   436ee:	bf28      	it	cs
   436f0:	f44f 77b1 	movcs.w	r7, #354	; 0x162
   436f4:	f8df 912c 	ldr.w	r9, [pc, #300]	; 43824 <dwt_ioctl+0x1608>
   436f8:	2f04      	cmp	r7, #4
   436fa:	d805      	bhi.n	43708 <dwt_ioctl+0x14ec>
   436fc:	eb09 0305 	add.w	r3, r9, r5
   43700:	785b      	ldrb	r3, [r3, #1]
   43702:	3b05      	subs	r3, #5
   43704:	429f      	cmp	r7, r3
   43706:	db40      	blt.n	4378a <dwt_ioctl+0x156e>
   43708:	2a01      	cmp	r2, #1
   4370a:	f200 80c8 	bhi.w	4389e <dwt_ioctl+0x1682>
   4370e:	4b44      	ldr	r3, [pc, #272]	; (43820 <dwt_ioctl+0x1604>)
   43710:	5c99      	ldrb	r1, [r3, r2]
   43712:	463e      	mov	r6, r7
   43714:	42b9      	cmp	r1, r7
   43716:	f280 80c4 	bge.w	438a2 <dwt_ioctl+0x1686>
   4371a:	1c50      	adds	r0, r2, #1
   4371c:	fa53 f080 	uxtab	r0, r3, r0
   43720:	2300      	movs	r3, #0
   43722:	440b      	add	r3, r1
   43724:	b29b      	uxth	r3, r3
   43726:	3201      	adds	r2, #1
   43728:	b2d2      	uxtb	r2, r2
   4372a:	2a02      	cmp	r2, #2
   4372c:	d005      	beq.n	4373a <dwt_ioctl+0x151e>
   4372e:	f810 1b01 	ldrb.w	r1, [r0], #1
   43732:	eba6 0c03 	sub.w	ip, r6, r3
   43736:	4561      	cmp	r1, ip
   43738:	dbf3      	blt.n	43722 <dwt_ioctl+0x1506>
   4373a:	429f      	cmp	r7, r3
   4373c:	bf08      	it	eq
   4373e:	9503      	streq	r5, [sp, #12]
   43740:	f000 80b4 	beq.w	438ac <dwt_ioctl+0x1690>
   43744:	f107 0c05 	add.w	ip, r7, #5
   43748:	fa1f fc8c 	uxth.w	ip, ip
   4374c:	2680      	movs	r6, #128	; 0x80
   4374e:	2100      	movs	r1, #0
   43750:	9107      	str	r1, [sp, #28]
   43752:	9103      	str	r1, [sp, #12]
   43754:	9108      	str	r1, [sp, #32]
   43756:	2005      	movs	r0, #5
   43758:	46b8      	mov	r8, r7
   4375a:	4287      	cmp	r7, r0
   4375c:	bf38      	it	cc
   4375e:	4680      	movcc	r8, r0
   43760:	f1a8 0805 	sub.w	r8, r8, #5
   43764:	fa1f f888 	uxth.w	r8, r8
   43768:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 43820 <dwt_ioctl+0x1604>
   4376c:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
   43770:	4683      	mov	fp, r0
   43772:	4620      	mov	r0, r4
   43774:	460c      	mov	r4, r1
   43776:	4686      	mov	lr, r0
   43778:	e031      	b.n	437de <dwt_ioctl+0x15c2>
   4377a:	f240 1331 	movw	r3, #305	; 0x131
   4377e:	429f      	cmp	r7, r3
   43780:	bf28      	it	cs
   43782:	461f      	movcs	r7, r3
   43784:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 43828 <dwt_ioctl+0x160c>
   43788:	e7b6      	b.n	436f8 <dwt_ioctl+0x14dc>
   4378a:	2300      	movs	r3, #0
   4378c:	9a05      	ldr	r2, [sp, #20]
   4378e:	8013      	strh	r3, [r2, #0]
   43790:	9a04      	ldr	r2, [sp, #16]
   43792:	f8c2 b000 	str.w	fp, [r2]
   43796:	e098      	b.n	438ca <dwt_ioctl+0x16ae>
   43798:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
   4379c:	4674      	mov	r4, lr
   4379e:	2300      	movs	r3, #0
   437a0:	9a05      	ldr	r2, [sp, #20]
   437a2:	8013      	strh	r3, [r2, #0]
   437a4:	9b04      	ldr	r3, [sp, #16]
   437a6:	f8c3 b000 	str.w	fp, [r3]
   437aa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   437ae:	e08c      	b.n	438ca <dwt_ioctl+0x16ae>
   437b0:	fa1f fb80 	uxth.w	fp, r0
   437b4:	9207      	str	r2, [sp, #28]
   437b6:	9503      	str	r5, [sp, #12]
   437b8:	9308      	str	r3, [sp, #32]
   437ba:	2401      	movs	r4, #1
   437bc:	2d3f      	cmp	r5, #63	; 0x3f
   437be:	d050      	beq.n	43862 <dwt_ioctl+0x1646>
   437c0:	2900      	cmp	r1, #0
   437c2:	d139      	bne.n	43838 <dwt_ioctl+0x161c>
   437c4:	3501      	adds	r5, #1
   437c6:	f005 053f 	and.w	r5, r5, #63	; 0x3f
   437ca:	f819 0005 	ldrb.w	r0, [r9, r5]
   437ce:	4403      	add	r3, r0
   437d0:	b29b      	uxth	r3, r3
   437d2:	429f      	cmp	r7, r3
   437d4:	d067      	beq.n	438a6 <dwt_ioctl+0x168a>
   437d6:	3e01      	subs	r6, #1
   437d8:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
   437dc:	d0dc      	beq.n	43798 <dwt_ioctl+0x157c>
   437de:	4543      	cmp	r3, r8
   437e0:	d924      	bls.n	4382c <dwt_ioctl+0x1610>
   437e2:	4563      	cmp	r3, ip
   437e4:	d222      	bcs.n	4382c <dwt_ioctl+0x1610>
   437e6:	1af8      	subs	r0, r7, r3
   437e8:	b200      	sxth	r0, r0
   437ea:	2800      	cmp	r0, #0
   437ec:	bfb8      	it	lt
   437ee:	4240      	neglt	r0, r0
   437f0:	4558      	cmp	r0, fp
   437f2:	dddd      	ble.n	437b0 <dwt_ioctl+0x1594>
   437f4:	2c00      	cmp	r4, #0
   437f6:	d0e1      	beq.n	437bc <dwt_ioctl+0x15a0>
   437f8:	4674      	mov	r4, lr
   437fa:	9a07      	ldr	r2, [sp, #28]
   437fc:	9b08      	ldr	r3, [sp, #32]
   437fe:	e055      	b.n	438ac <dwt_ioctl+0x1690>
   43800:	00050008 	.word	0x00050008
   43804:	001f000c 	.word	0x001f000c
   43808:	001f0010 	.word	0x001f0010
   4380c:	00010020 	.word	0x00010020
   43810:	00030054 	.word	0x00030054
   43814:	00010018 	.word	0x00010018
   43818:	0005002c 	.word	0x0005002c
   4381c:	000e001c 	.word	0x000e001c
   43820:	00047070 	.word	0x00047070
   43824:	00046ff0 	.word	0x00046ff0
   43828:	00047030 	.word	0x00047030
   4382c:	b984      	cbnz	r4, 43850 <dwt_ioctl+0x1634>
   4382e:	4563      	cmp	r3, ip
   43830:	d3c4      	bcc.n	437bc <dwt_ioctl+0x15a0>
   43832:	b199      	cbz	r1, 4385c <dwt_ioctl+0x1640>
   43834:	2d3f      	cmp	r5, #63	; 0x3f
   43836:	d014      	beq.n	43862 <dwt_ioctl+0x1646>
   43838:	f819 1005 	ldrb.w	r1, [r9, r5]
   4383c:	1a5b      	subs	r3, r3, r1
   4383e:	b29b      	uxth	r3, r3
   43840:	1e69      	subs	r1, r5, #1
   43842:	f001 053f 	and.w	r5, r1, #63	; 0x3f
   43846:	f011 013f 	ands.w	r1, r1, #63	; 0x3f
   4384a:	bf18      	it	ne
   4384c:	2101      	movne	r1, #1
   4384e:	e7c0      	b.n	437d2 <dwt_ioctl+0x15b6>
   43850:	4674      	mov	r4, lr
   43852:	f819 1005 	ldrb.w	r1, [r9, r5]
   43856:	1a5b      	subs	r3, r3, r1
   43858:	b29b      	uxth	r3, r3
   4385a:	e027      	b.n	438ac <dwt_ioctl+0x1690>
   4385c:	4674      	mov	r4, lr
   4385e:	9503      	str	r5, [sp, #12]
   43860:	e024      	b.n	438ac <dwt_ioctl+0x1690>
   43862:	2c00      	cmp	r4, #0
   43864:	d134      	bne.n	438d0 <dwt_ioctl+0x16b4>
   43866:	2a03      	cmp	r2, #3
   43868:	d036      	beq.n	438d8 <dwt_ioctl+0x16bc>
   4386a:	2a02      	cmp	r2, #2
   4386c:	d009      	beq.n	43882 <dwt_ioctl+0x1666>
   4386e:	f81a 1002 	ldrb.w	r1, [sl, r2]
   43872:	1858      	adds	r0, r3, r1
   43874:	42b8      	cmp	r0, r7
   43876:	dd0b      	ble.n	43890 <dwt_ioctl+0x1674>
   43878:	440b      	add	r3, r1
   4387a:	b29b      	uxth	r3, r3
   4387c:	3201      	adds	r2, #1
   4387e:	b2d2      	uxtb	r2, r2
   43880:	e7da      	b.n	43838 <dwt_ioctl+0x161c>
   43882:	9906      	ldr	r1, [sp, #24]
   43884:	2909      	cmp	r1, #9
   43886:	d1f2      	bne.n	4386e <dwt_ioctl+0x1652>
   43888:	4674      	mov	r4, lr
   4388a:	213f      	movs	r1, #63	; 0x3f
   4388c:	9103      	str	r1, [sp, #12]
   4388e:	e00d      	b.n	438ac <dwt_ioctl+0x1690>
   43890:	4674      	mov	r4, lr
   43892:	b283      	uxth	r3, r0
   43894:	3201      	adds	r2, #1
   43896:	b2d2      	uxtb	r2, r2
   43898:	213f      	movs	r1, #63	; 0x3f
   4389a:	9103      	str	r1, [sp, #12]
   4389c:	e006      	b.n	438ac <dwt_ioctl+0x1690>
   4389e:	2300      	movs	r3, #0
   438a0:	e74b      	b.n	4373a <dwt_ioctl+0x151e>
   438a2:	2300      	movs	r3, #0
   438a4:	e749      	b.n	4373a <dwt_ioctl+0x151e>
   438a6:	4674      	mov	r4, lr
   438a8:	9503      	str	r5, [sp, #12]
   438aa:	463b      	mov	r3, r7
   438ac:	9905      	ldr	r1, [sp, #20]
   438ae:	800b      	strh	r3, [r1, #0]
   438b0:	9b03      	ldr	r3, [sp, #12]
   438b2:	ea42 0383 	orr.w	r3, r2, r3, lsl #2
   438b6:	b2db      	uxtb	r3, r3
   438b8:	041a      	lsls	r2, r3, #16
   438ba:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
   438be:	431a      	orrs	r2, r3
   438c0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
   438c4:	9a04      	ldr	r2, [sp, #16]
   438c6:	6013      	str	r3, [r2, #0]
   438c8:	2300      	movs	r3, #0
   438ca:	6023      	str	r3, [r4, #0]
   438cc:	2500      	movs	r5, #0
   438ce:	e3ad      	b.n	4402c <dwt_ioctl+0x1e10>
   438d0:	4674      	mov	r4, lr
   438d2:	9a07      	ldr	r2, [sp, #28]
   438d4:	9b08      	ldr	r3, [sp, #32]
   438d6:	e7e9      	b.n	438ac <dwt_ioctl+0x1690>
   438d8:	4674      	mov	r4, lr
   438da:	213f      	movs	r1, #63	; 0x3f
   438dc:	9103      	str	r1, [sp, #12]
   438de:	e7e5      	b.n	438ac <dwt_ioctl+0x1690>
   438e0:	2c00      	cmp	r4, #0
   438e2:	f000 8453 	beq.w	4418c <dwt_ioctl+0x1f70>
   438e6:	7827      	ldrb	r7, [r4, #0]
   438e8:	7864      	ldrb	r4, [r4, #1]
   438ea:	f7ea ff5d 	bl	2e7a8 <decamutexon>
   438ee:	4605      	mov	r5, r0
   438f0:	2c02      	cmp	r4, #2
   438f2:	d00e      	beq.n	43912 <dwt_ioctl+0x16f6>
   438f4:	2c04      	cmp	r4, #4
   438f6:	d00c      	beq.n	43912 <dwt_ioctl+0x16f6>
   438f8:	f004 04fd 	and.w	r4, r4, #253	; 0xfd
   438fc:	2c01      	cmp	r4, #1
   438fe:	d019      	beq.n	43934 <dwt_ioctl+0x1718>
   43900:	43fb      	mvns	r3, r7
   43902:	2200      	movs	r2, #0
   43904:	9200      	str	r2, [sp, #0]
   43906:	b2db      	uxtb	r3, r3
   43908:	49c1      	ldr	r1, [pc, #772]	; (43c10 <dwt_ioctl+0x19f4>)
   4390a:	4630      	mov	r0, r6
   4390c:	f7fd fc5a 	bl	411c4 <dwt_modify8bitoffsetreg>
   43910:	e005      	b.n	4391e <dwt_ioctl+0x1702>
   43912:	463b      	mov	r3, r7
   43914:	2200      	movs	r2, #0
   43916:	49be      	ldr	r1, [pc, #760]	; (43c10 <dwt_ioctl+0x19f4>)
   43918:	4630      	mov	r0, r6
   4391a:	f7fc ffc1 	bl	408a0 <dwt_write8bitoffsetreg>
   4391e:	463b      	mov	r3, r7
   43920:	2200      	movs	r2, #0
   43922:	49bc      	ldr	r1, [pc, #752]	; (43c14 <dwt_ioctl+0x19f8>)
   43924:	4630      	mov	r0, r6
   43926:	f7fc fdd7 	bl	404d8 <dwt_write32bitoffsetreg>
   4392a:	4628      	mov	r0, r5
   4392c:	f7ea ff43 	bl	2e7b6 <decamutexoff>
   43930:	2500      	movs	r5, #0
   43932:	e37b      	b.n	4402c <dwt_ioctl+0x1e10>
   43934:	9700      	str	r7, [sp, #0]
   43936:	23ff      	movs	r3, #255	; 0xff
   43938:	2200      	movs	r2, #0
   4393a:	49b5      	ldr	r1, [pc, #724]	; (43c10 <dwt_ioctl+0x19f4>)
   4393c:	4630      	mov	r0, r6
   4393e:	f7fd fc41 	bl	411c4 <dwt_modify8bitoffsetreg>
   43942:	e7ec      	b.n	4391e <dwt_ioctl+0x1702>
   43944:	2302      	movs	r3, #2
   43946:	9301      	str	r3, [sp, #4]
   43948:	2500      	movs	r5, #0
   4394a:	9500      	str	r5, [sp, #0]
   4394c:	462b      	mov	r3, r5
   4394e:	462a      	mov	r2, r5
   43950:	211a      	movs	r1, #26
   43952:	f7fc f85a 	bl	3fa0a <dwt_xfer3xxx>
   43956:	e369      	b.n	4402c <dwt_ioctl+0x1e10>
   43958:	f7fe fc4c 	bl	421f4 <ull_softreset_fcmd>
   4395c:	2500      	movs	r5, #0
   4395e:	e365      	b.n	4402c <dwt_ioctl+0x1e10>
   43960:	f7fe fc34 	bl	421cc <ull_softreset_no_sema_fcmd>
   43964:	2500      	movs	r5, #0
   43966:	e361      	b.n	4402c <dwt_ioctl+0x1e10>
   43968:	2302      	movs	r3, #2
   4396a:	9301      	str	r3, [sp, #4]
   4396c:	2500      	movs	r5, #0
   4396e:	9500      	str	r5, [sp, #0]
   43970:	462b      	mov	r3, r5
   43972:	462a      	mov	r2, r5
   43974:	2114      	movs	r1, #20
   43976:	f7fc f848 	bl	3fa0a <dwt_xfer3xxx>
   4397a:	e357      	b.n	4402c <dwt_ioctl+0x1e10>
   4397c:	2402      	movs	r4, #2
   4397e:	9401      	str	r4, [sp, #4]
   43980:	2500      	movs	r5, #0
   43982:	9500      	str	r5, [sp, #0]
   43984:	462b      	mov	r3, r5
   43986:	462a      	mov	r2, r5
   43988:	2115      	movs	r1, #21
   4398a:	f7fc f83e 	bl	3fa0a <dwt_xfer3xxx>
   4398e:	9401      	str	r4, [sp, #4]
   43990:	9500      	str	r5, [sp, #0]
   43992:	462b      	mov	r3, r5
   43994:	462a      	mov	r2, r5
   43996:	2115      	movs	r1, #21
   43998:	4630      	mov	r0, r6
   4399a:	f7fc f836 	bl	3fa0a <dwt_xfer3xxx>
   4399e:	e345      	b.n	4402c <dwt_ioctl+0x1e10>
   439a0:	2302      	movs	r3, #2
   439a2:	9301      	str	r3, [sp, #4]
   439a4:	2500      	movs	r5, #0
   439a6:	9500      	str	r5, [sp, #0]
   439a8:	462b      	mov	r3, r5
   439aa:	462a      	mov	r2, r5
   439ac:	2116      	movs	r1, #22
   439ae:	f7fc f82c 	bl	3fa0a <dwt_xfer3xxx>
   439b2:	e33b      	b.n	4402c <dwt_ioctl+0x1e10>
   439b4:	2c00      	cmp	r4, #0
   439b6:	f000 83eb 	beq.w	44190 <dwt_ioctl+0x1f74>
   439ba:	b932      	cbnz	r2, 439ca <dwt_ioctl+0x17ae>
   439bc:	2200      	movs	r2, #0
   439be:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   439c2:	f7fc f8ff 	bl	3fbc4 <dwt_read8bitoffsetreg>
   439c6:	7020      	strb	r0, [r4, #0]
   439c8:	e330      	b.n	4402c <dwt_ioctl+0x1e10>
   439ca:	2201      	movs	r2, #1
   439cc:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   439d0:	f7fc f8f8 	bl	3fbc4 <dwt_read8bitoffsetreg>
   439d4:	7020      	strb	r0, [r4, #0]
   439d6:	2500      	movs	r5, #0
   439d8:	e328      	b.n	4402c <dwt_ioctl+0x1e10>
   439da:	2c00      	cmp	r4, #0
   439dc:	f000 83da 	beq.w	44194 <dwt_ioctl+0x1f78>
   439e0:	7824      	ldrb	r4, [r4, #0]
   439e2:	2200      	movs	r2, #0
   439e4:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   439e8:	f7fc f8ec 	bl	3fbc4 <dwt_read8bitoffsetreg>
   439ec:	f000 039f 	and.w	r3, r0, #159	; 0x9f
   439f0:	4323      	orrs	r3, r4
   439f2:	2200      	movs	r2, #0
   439f4:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   439f8:	4630      	mov	r0, r6
   439fa:	f7fc ff51 	bl	408a0 <dwt_write8bitoffsetreg>
   439fe:	2500      	movs	r5, #0
   43a00:	e314      	b.n	4402c <dwt_ioctl+0x1e10>
   43a02:	2c00      	cmp	r4, #0
   43a04:	f000 83c8 	beq.w	44198 <dwt_ioctl+0x1f7c>
   43a08:	7824      	ldrb	r4, [r4, #0]
   43a0a:	f012 05ff 	ands.w	r5, r2, #255	; 0xff
   43a0e:	d01d      	beq.n	43a4c <dwt_ioctl+0x1830>
   43a10:	2d01      	cmp	r5, #1
   43a12:	f040 83c3 	bne.w	4419c <dwt_ioctl+0x1f80>
   43a16:	2502      	movs	r5, #2
   43a18:	2201      	movs	r2, #1
   43a1a:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   43a1e:	4630      	mov	r0, r6
   43a20:	f7fc f8d0 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43a24:	b9a4      	cbnz	r4, 43a50 <dwt_ioctl+0x1834>
   43a26:	ea20 0305 	bic.w	r3, r0, r5
   43a2a:	b2db      	uxtb	r3, r3
   43a2c:	2201      	movs	r2, #1
   43a2e:	f44f 11d0 	mov.w	r1, #1703936	; 0x1a0000
   43a32:	4630      	mov	r0, r6
   43a34:	f7fc ff34 	bl	408a0 <dwt_write8bitoffsetreg>
   43a38:	2200      	movs	r2, #0
   43a3a:	2110      	movs	r1, #16
   43a3c:	4630      	mov	r0, r6
   43a3e:	f7fc f86c 	bl	3fb1a <dwt_read32bitoffsetreg>
   43a42:	f410 1f80 	tst.w	r0, #1048576	; 0x100000
   43a46:	d00a      	beq.n	43a5e <dwt_ioctl+0x1842>
   43a48:	2500      	movs	r5, #0
   43a4a:	e2ef      	b.n	4402c <dwt_ioctl+0x1e10>
   43a4c:	2504      	movs	r5, #4
   43a4e:	e7e3      	b.n	43a18 <dwt_ioctl+0x17fc>
   43a50:	2c01      	cmp	r4, #1
   43a52:	f040 83a6 	bne.w	441a2 <dwt_ioctl+0x1f86>
   43a56:	ea40 0305 	orr.w	r3, r0, r5
   43a5a:	b2db      	uxtb	r3, r3
   43a5c:	e7e6      	b.n	43a2c <dwt_ioctl+0x1810>
   43a5e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   43a62:	9300      	str	r3, [sp, #0]
   43a64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43a68:	2200      	movs	r2, #0
   43a6a:	2110      	movs	r1, #16
   43a6c:	4630      	mov	r0, r6
   43a6e:	f7fd fa39 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43a72:	2500      	movs	r5, #0
   43a74:	e2da      	b.n	4402c <dwt_ioctl+0x1e10>
   43a76:	2c00      	cmp	r4, #0
   43a78:	f000 8396 	beq.w	441a8 <dwt_ioctl+0x1f8c>
   43a7c:	7823      	ldrb	r3, [r4, #0]
   43a7e:	035b      	lsls	r3, r3, #13
   43a80:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
   43a84:	9300      	str	r3, [sp, #0]
   43a86:	f64d 73ff 	movw	r3, #57343	; 0xdfff
   43a8a:	2200      	movs	r2, #0
   43a8c:	4962      	ldr	r1, [pc, #392]	; (43c18 <dwt_ioctl+0x19fc>)
   43a8e:	f7fd ff29 	bl	418e4 <dwt_modify16bitoffsetreg>
   43a92:	2500      	movs	r5, #0
   43a94:	e2ca      	b.n	4402c <dwt_ioctl+0x1e10>
   43a96:	2c00      	cmp	r4, #0
   43a98:	f000 8388 	beq.w	441ac <dwt_ioctl+0x1f90>
   43a9c:	7825      	ldrb	r5, [r4, #0]
   43a9e:	6862      	ldr	r2, [r4, #4]
   43aa0:	2a01      	cmp	r2, #1
   43aa2:	bf15      	itete	ne
   43aa4:	f46f 3360 	mvnne.w	r3, #229376	; 0x38000
   43aa8:	f46f 43e0 	mvneq.w	r3, #28672	; 0x7000
   43aac:	27df      	movne	r7, #223	; 0xdf
   43aae:	27ef      	moveq	r7, #239	; 0xef
   43ab0:	bf14      	ite	ne
   43ab2:	f04f 0820 	movne.w	r8, #32
   43ab6:	f04f 0810 	moveq.w	r8, #16
   43aba:	2400      	movs	r4, #0
   43abc:	9400      	str	r4, [sp, #0]
   43abe:	4622      	mov	r2, r4
   43ac0:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   43ac4:	f7fd fa0e 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43ac8:	9400      	str	r4, [sp, #0]
   43aca:	463b      	mov	r3, r7
   43acc:	4622      	mov	r2, r4
   43ace:	4953      	ldr	r1, [pc, #332]	; (43c1c <dwt_ioctl+0x1a00>)
   43ad0:	4630      	mov	r0, r6
   43ad2:	f7fd fb77 	bl	411c4 <dwt_modify8bitoffsetreg>
   43ad6:	2d01      	cmp	r5, #1
   43ad8:	d002      	beq.n	43ae0 <dwt_ioctl+0x18c4>
   43ada:	b155      	cbz	r5, 43af2 <dwt_ioctl+0x18d6>
   43adc:	2500      	movs	r5, #0
   43ade:	e2a5      	b.n	4402c <dwt_ioctl+0x1e10>
   43ae0:	4625      	mov	r5, r4
   43ae2:	9400      	str	r4, [sp, #0]
   43ae4:	463b      	mov	r3, r7
   43ae6:	4622      	mov	r2, r4
   43ae8:	494d      	ldr	r1, [pc, #308]	; (43c20 <dwt_ioctl+0x1a04>)
   43aea:	4630      	mov	r0, r6
   43aec:	f7fd fb6a 	bl	411c4 <dwt_modify8bitoffsetreg>
   43af0:	e29c      	b.n	4402c <dwt_ioctl+0x1e10>
   43af2:	f8cd 8000 	str.w	r8, [sp]
   43af6:	23ff      	movs	r3, #255	; 0xff
   43af8:	2200      	movs	r2, #0
   43afa:	4949      	ldr	r1, [pc, #292]	; (43c20 <dwt_ioctl+0x1a04>)
   43afc:	4630      	mov	r0, r6
   43afe:	f7fd fb61 	bl	411c4 <dwt_modify8bitoffsetreg>
   43b02:	e293      	b.n	4402c <dwt_ioctl+0x1e10>
   43b04:	2c00      	cmp	r4, #0
   43b06:	f000 8353 	beq.w	441b0 <dwt_ioctl+0x1f94>
   43b0a:	7822      	ldrb	r2, [r4, #0]
   43b0c:	f012 0f01 	tst.w	r2, #1
   43b10:	d02c      	beq.n	43b6c <dwt_ioctl+0x1950>
   43b12:	0157      	lsls	r7, r2, #5
   43b14:	f007 0740 	and.w	r7, r7, #64	; 0x40
   43b18:	2440      	movs	r4, #64	; 0x40
   43b1a:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
   43b1e:	f012 0f04 	tst.w	r2, #4
   43b22:	d027      	beq.n	43b74 <dwt_ioctl+0x1958>
   43b24:	f443 0360 	orr.w	r3, r3, #14680064	; 0xe00000
   43b28:	f044 0480 	orr.w	r4, r4, #128	; 0x80
   43b2c:	0112      	lsls	r2, r2, #4
   43b2e:	f002 0280 	and.w	r2, r2, #128	; 0x80
   43b32:	4317      	orrs	r7, r2
   43b34:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
   43b38:	9200      	str	r2, [sp, #0]
   43b3a:	43db      	mvns	r3, r3
   43b3c:	2200      	movs	r2, #0
   43b3e:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   43b42:	4630      	mov	r0, r6
   43b44:	f7fd f9ce 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43b48:	43e4      	mvns	r4, r4
   43b4a:	b2a4      	uxth	r4, r4
   43b4c:	2500      	movs	r5, #0
   43b4e:	9500      	str	r5, [sp, #0]
   43b50:	4623      	mov	r3, r4
   43b52:	462a      	mov	r2, r5
   43b54:	4931      	ldr	r1, [pc, #196]	; (43c1c <dwt_ioctl+0x1a00>)
   43b56:	4630      	mov	r0, r6
   43b58:	f7fd fec4 	bl	418e4 <dwt_modify16bitoffsetreg>
   43b5c:	9700      	str	r7, [sp, #0]
   43b5e:	4623      	mov	r3, r4
   43b60:	462a      	mov	r2, r5
   43b62:	492f      	ldr	r1, [pc, #188]	; (43c20 <dwt_ioctl+0x1a04>)
   43b64:	4630      	mov	r0, r6
   43b66:	f7fd febd 	bl	418e4 <dwt_modify16bitoffsetreg>
   43b6a:	e25f      	b.n	4402c <dwt_ioctl+0x1e10>
   43b6c:	2700      	movs	r7, #0
   43b6e:	463c      	mov	r4, r7
   43b70:	463b      	mov	r3, r7
   43b72:	e7d4      	b.n	43b1e <dwt_ioctl+0x1902>
   43b74:	2200      	movs	r2, #0
   43b76:	e7df      	b.n	43b38 <dwt_ioctl+0x191c>
   43b78:	2308      	movs	r3, #8
   43b7a:	9300      	str	r3, [sp, #0]
   43b7c:	23ff      	movs	r3, #255	; 0xff
   43b7e:	2201      	movs	r2, #1
   43b80:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   43b84:	f7fd fb1e 	bl	411c4 <dwt_modify8bitoffsetreg>
   43b88:	4c26      	ldr	r4, [pc, #152]	; (43c24 <dwt_ioctl+0x1a08>)
   43b8a:	2302      	movs	r3, #2
   43b8c:	9300      	str	r3, [sp, #0]
   43b8e:	23ff      	movs	r3, #255	; 0xff
   43b90:	2203      	movs	r2, #3
   43b92:	4621      	mov	r1, r4
   43b94:	4630      	mov	r0, r6
   43b96:	f7fd fb15 	bl	411c4 <dwt_modify8bitoffsetreg>
   43b9a:	2500      	movs	r5, #0
   43b9c:	9500      	str	r5, [sp, #0]
   43b9e:	23f7      	movs	r3, #247	; 0xf7
   43ba0:	2201      	movs	r2, #1
   43ba2:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   43ba6:	4630      	mov	r0, r6
   43ba8:	f7fd fb0c 	bl	411c4 <dwt_modify8bitoffsetreg>
   43bac:	9500      	str	r5, [sp, #0]
   43bae:	23fd      	movs	r3, #253	; 0xfd
   43bb0:	2203      	movs	r2, #3
   43bb2:	4621      	mov	r1, r4
   43bb4:	4630      	mov	r0, r6
   43bb6:	f7fd fb05 	bl	411c4 <dwt_modify8bitoffsetreg>
   43bba:	e237      	b.n	4402c <dwt_ioctl+0x1e10>
   43bbc:	2c00      	cmp	r4, #0
   43bbe:	f000 82f9 	beq.w	441b4 <dwt_ioctl+0x1f98>
   43bc2:	8863      	ldrh	r3, [r4, #2]
   43bc4:	00db      	lsls	r3, r3, #3
   43bc6:	f403 63ff 	and.w	r3, r3, #2040	; 0x7f8
   43bca:	7822      	ldrb	r2, [r4, #0]
   43bcc:	b10a      	cbz	r2, 43bd2 <dwt_ioctl+0x19b6>
   43bce:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   43bd2:	9300      	str	r3, [sp, #0]
   43bd4:	f24f 0307 	movw	r3, #61447	; 0xf007
   43bd8:	2200      	movs	r2, #0
   43bda:	f44f 2180 	mov.w	r1, #262144	; 0x40000
   43bde:	4630      	mov	r0, r6
   43be0:	f7fd fe80 	bl	418e4 <dwt_modify16bitoffsetreg>
   43be4:	2500      	movs	r5, #0
   43be6:	e221      	b.n	4402c <dwt_ioctl+0x1e10>
   43be8:	2500      	movs	r5, #0
   43bea:	9500      	str	r5, [sp, #0]
   43bec:	f64f 33ff 	movw	r3, #64511	; 0xfbff
   43bf0:	462a      	mov	r2, r5
   43bf2:	f44f 1188 	mov.w	r1, #1114112	; 0x110000
   43bf6:	f7fd fe75 	bl	418e4 <dwt_modify16bitoffsetreg>
   43bfa:	e217      	b.n	4402c <dwt_ioctl+0x1e10>
   43bfc:	2c00      	cmp	r4, #0
   43bfe:	f000 82db 	beq.w	441b8 <dwt_ioctl+0x1f9c>
   43c02:	2200      	movs	r2, #0
   43c04:	4908      	ldr	r1, [pc, #32]	; (43c28 <dwt_ioctl+0x1a0c>)
   43c06:	f7fb ff9e 	bl	3fb46 <dwt_read16bitoffsetreg>
   43c0a:	8020      	strh	r0, [r4, #0]
   43c0c:	2500      	movs	r5, #0
   43c0e:	e20d      	b.n	4402c <dwt_ioctl+0x1e10>
   43c10:	0001001c 	.word	0x0001001c
   43c14:	00010018 	.word	0x00010018
   43c18:	000e000c 	.word	0x000e000c
   43c1c:	00050008 	.word	0x00050008
   43c20:	0005000c 	.word	0x0005000c
   43c24:	00110008 	.word	0x00110008
   43c28:	00110048 	.word	0x00110048
   43c2c:	2c00      	cmp	r4, #0
   43c2e:	f000 82c5 	beq.w	441bc <dwt_ioctl+0x1fa0>
   43c32:	7823      	ldrb	r3, [r4, #0]
   43c34:	2b01      	cmp	r3, #1
   43c36:	7862      	ldrb	r2, [r4, #1]
   43c38:	78a3      	ldrb	r3, [r4, #2]
   43c3a:	ea4f 23c3 	mov.w	r3, r3, lsl #11
   43c3e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   43c42:	78e2      	ldrb	r2, [r4, #3]
   43c44:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
   43c48:	7922      	ldrb	r2, [r4, #4]
   43c4a:	ea43 3382 	orr.w	r3, r3, r2, lsl #14
   43c4e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   43c52:	bf0c      	ite	eq
   43c54:	2202      	moveq	r2, #2
   43c56:	2200      	movne	r2, #0
   43c58:	49b6      	ldr	r1, [pc, #728]	; (43f34 <dwt_ioctl+0x1d18>)
   43c5a:	f7fc fbd2 	bl	40402 <dwt_write16bitoffsetreg>
   43c5e:	2500      	movs	r5, #0
   43c60:	e1e4      	b.n	4402c <dwt_ioctl+0x1e10>
   43c62:	2c00      	cmp	r4, #0
   43c64:	f000 82ac 	beq.w	441c0 <dwt_ioctl+0x1fa4>
   43c68:	6863      	ldr	r3, [r4, #4]
   43c6a:	7822      	ldrb	r2, [r4, #0]
   43c6c:	b13a      	cbz	r2, 43c7e <dwt_ioctl+0x1a62>
   43c6e:	f3c3 0315 	ubfx	r3, r3, #0, #22
   43c72:	2200      	movs	r2, #0
   43c74:	49b0      	ldr	r1, [pc, #704]	; (43f38 <dwt_ioctl+0x1d1c>)
   43c76:	f7fc fc2f 	bl	404d8 <dwt_write32bitoffsetreg>
   43c7a:	2500      	movs	r5, #0
   43c7c:	e1d6      	b.n	4402c <dwt_ioctl+0x1e10>
   43c7e:	f3c3 0315 	ubfx	r3, r3, #0, #22
   43c82:	49ae      	ldr	r1, [pc, #696]	; (43f3c <dwt_ioctl+0x1d20>)
   43c84:	f7fc fc28 	bl	404d8 <dwt_write32bitoffsetreg>
   43c88:	2500      	movs	r5, #0
   43c8a:	e1cf      	b.n	4402c <dwt_ioctl+0x1e10>
   43c8c:	2c00      	cmp	r4, #0
   43c8e:	f000 8299 	beq.w	441c4 <dwt_ioctl+0x1fa8>
   43c92:	7823      	ldrb	r3, [r4, #0]
   43c94:	2401      	movs	r4, #1
   43c96:	409c      	lsls	r4, r3
   43c98:	b2e4      	uxtb	r4, r4
   43c9a:	2310      	movs	r3, #16
   43c9c:	9300      	str	r3, [sp, #0]
   43c9e:	23ff      	movs	r3, #255	; 0xff
   43ca0:	2200      	movs	r2, #0
   43ca2:	49a7      	ldr	r1, [pc, #668]	; (43f40 <dwt_ioctl+0x1d24>)
   43ca4:	f7fd fa8e 	bl	411c4 <dwt_modify8bitoffsetreg>
   43ca8:	43e3      	mvns	r3, r4
   43caa:	4fa2      	ldr	r7, [pc, #648]	; (43f34 <dwt_ioctl+0x1d18>)
   43cac:	2500      	movs	r5, #0
   43cae:	9500      	str	r5, [sp, #0]
   43cb0:	b2db      	uxtb	r3, r3
   43cb2:	462a      	mov	r2, r5
   43cb4:	4639      	mov	r1, r7
   43cb6:	4630      	mov	r0, r6
   43cb8:	f7fd fa84 	bl	411c4 <dwt_modify8bitoffsetreg>
   43cbc:	9400      	str	r4, [sp, #0]
   43cbe:	23ff      	movs	r3, #255	; 0xff
   43cc0:	462a      	mov	r2, r5
   43cc2:	4639      	mov	r1, r7
   43cc4:	4630      	mov	r0, r6
   43cc6:	f7fd fa7d 	bl	411c4 <dwt_modify8bitoffsetreg>
   43cca:	e1af      	b.n	4402c <dwt_ioctl+0x1e10>
   43ccc:	2c00      	cmp	r4, #0
   43cce:	f000 827b 	beq.w	441c8 <dwt_ioctl+0x1fac>
   43cd2:	7822      	ldrb	r2, [r4, #0]
   43cd4:	7863      	ldrb	r3, [r4, #1]
   43cd6:	b19b      	cbz	r3, 43d00 <dwt_ioctl+0x1ae4>
   43cd8:	2a00      	cmp	r2, #0
   43cda:	f040 8297 	bne.w	4420c <dwt_ioctl+0x1ff0>
   43cde:	2400      	movs	r4, #0
   43ce0:	9400      	str	r4, [sp, #0]
   43ce2:	f06f 73c0 	mvn.w	r3, #25165824	; 0x1800000
   43ce6:	4622      	mov	r2, r4
   43ce8:	2110      	movs	r1, #16
   43cea:	f7fd f8fb 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43cee:	9400      	str	r4, [sp, #0]
   43cf0:	4b94      	ldr	r3, [pc, #592]	; (43f44 <dwt_ioctl+0x1d28>)
   43cf2:	4622      	mov	r2, r4
   43cf4:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   43cf8:	4630      	mov	r0, r6
   43cfa:	f7fd f8f3 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43cfe:	e017      	b.n	43d30 <dwt_ioctl+0x1b14>
   43d00:	2a00      	cmp	r2, #0
   43d02:	f000 8285 	beq.w	44210 <dwt_ioctl+0x1ff4>
   43d06:	f44f 4500 	mov.w	r5, #32768	; 0x8000
   43d0a:	2400      	movs	r4, #0
   43d0c:	9400      	str	r4, [sp, #0]
   43d0e:	f06f 73c0 	mvn.w	r3, #25165824	; 0x1800000
   43d12:	4622      	mov	r2, r4
   43d14:	2110      	movs	r1, #16
   43d16:	4630      	mov	r0, r6
   43d18:	f7fd f8e4 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43d1c:	9500      	str	r5, [sp, #0]
   43d1e:	4b89      	ldr	r3, [pc, #548]	; (43f44 <dwt_ioctl+0x1d28>)
   43d20:	4622      	mov	r2, r4
   43d22:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   43d26:	4630      	mov	r0, r6
   43d28:	f7fd f8dc 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43d2c:	f04f 74c0 	mov.w	r4, #25165824	; 0x1800000
   43d30:	9400      	str	r4, [sp, #0]
   43d32:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43d36:	2200      	movs	r2, #0
   43d38:	2110      	movs	r1, #16
   43d3a:	4630      	mov	r0, r6
   43d3c:	f7fd f8d2 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43d40:	2500      	movs	r5, #0
   43d42:	e173      	b.n	4402c <dwt_ioctl+0x1e10>
   43d44:	2c00      	cmp	r4, #0
   43d46:	f000 8241 	beq.w	441cc <dwt_ioctl+0x1fb0>
   43d4a:	7823      	ldrb	r3, [r4, #0]
   43d4c:	b93b      	cbnz	r3, 43d5e <dwt_ioctl+0x1b42>
   43d4e:	2500      	movs	r5, #0
   43d50:	9500      	str	r5, [sp, #0]
   43d52:	23df      	movs	r3, #223	; 0xdf
   43d54:	2203      	movs	r2, #3
   43d56:	497c      	ldr	r1, [pc, #496]	; (43f48 <dwt_ioctl+0x1d2c>)
   43d58:	f7fd fa34 	bl	411c4 <dwt_modify8bitoffsetreg>
   43d5c:	e166      	b.n	4402c <dwt_ioctl+0x1e10>
   43d5e:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
   43d62:	9300      	str	r3, [sp, #0]
   43d64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   43d68:	2200      	movs	r2, #0
   43d6a:	4977      	ldr	r1, [pc, #476]	; (43f48 <dwt_ioctl+0x1d2c>)
   43d6c:	f7fd f8ba 	bl	40ee4 <dwt_modify32bitoffsetreg>
   43d70:	2500      	movs	r5, #0
   43d72:	e15b      	b.n	4402c <dwt_ioctl+0x1e10>
   43d74:	2c00      	cmp	r4, #0
   43d76:	f000 822b 	beq.w	441d0 <dwt_ioctl+0x1fb4>
   43d7a:	7823      	ldrb	r3, [r4, #0]
   43d7c:	b93b      	cbnz	r3, 43d8e <dwt_ioctl+0x1b72>
   43d7e:	2500      	movs	r5, #0
   43d80:	9500      	str	r5, [sp, #0]
   43d82:	237f      	movs	r3, #127	; 0x7f
   43d84:	2203      	movs	r2, #3
   43d86:	4971      	ldr	r1, [pc, #452]	; (43f4c <dwt_ioctl+0x1d30>)
   43d88:	f7fd fa1c 	bl	411c4 <dwt_modify8bitoffsetreg>
   43d8c:	e14e      	b.n	4402c <dwt_ioctl+0x1e10>
   43d8e:	2380      	movs	r3, #128	; 0x80
   43d90:	9300      	str	r3, [sp, #0]
   43d92:	23ff      	movs	r3, #255	; 0xff
   43d94:	2203      	movs	r2, #3
   43d96:	496d      	ldr	r1, [pc, #436]	; (43f4c <dwt_ioctl+0x1d30>)
   43d98:	f7fd fa14 	bl	411c4 <dwt_modify8bitoffsetreg>
   43d9c:	2500      	movs	r5, #0
   43d9e:	e145      	b.n	4402c <dwt_ioctl+0x1e10>
   43da0:	2c00      	cmp	r4, #0
   43da2:	f000 8217 	beq.w	441d4 <dwt_ioctl+0x1fb8>
   43da6:	b2e3      	uxtb	r3, r4
   43da8:	1c9a      	adds	r2, r3, #2
   43daa:	2301      	movs	r3, #1
   43dac:	4093      	lsls	r3, r2
   43dae:	3b01      	subs	r3, #1
   43db0:	b2db      	uxtb	r3, r3
   43db2:	2200      	movs	r2, #0
   43db4:	f44f 3100 	mov.w	r1, #131072	; 0x20000
   43db8:	f7fc fd72 	bl	408a0 <dwt_write8bitoffsetreg>
   43dbc:	2500      	movs	r5, #0
   43dbe:	e135      	b.n	4402c <dwt_ioctl+0x1e10>
   43dc0:	2c00      	cmp	r4, #0
   43dc2:	f000 8209 	beq.w	441d8 <dwt_ioctl+0x1fbc>
   43dc6:	7ae3      	ldrb	r3, [r4, #11]
   43dc8:	2b00      	cmp	r3, #0
   43dca:	f000 8207 	beq.w	441dc <dwt_ioctl+0x1fc0>
   43dce:	7b63      	ldrb	r3, [r4, #13]
   43dd0:	2b01      	cmp	r3, #1
   43dd2:	7b20      	ldrb	r0, [r4, #12]
   43dd4:	bf94      	ite	ls
   43dd6:	2203      	movls	r2, #3
   43dd8:	2204      	movhi	r2, #4
   43dda:	2110      	movs	r1, #16
   43ddc:	4b5c      	ldr	r3, [pc, #368]	; (43f50 <dwt_ioctl+0x1d34>)
   43dde:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
   43de2:	f7fb fdf5 	bl	3f9d0 <get_sts_mnth>
   43de6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   43dea:	9000      	str	r0, [sp, #0]
   43dec:	f64f 7380 	movw	r3, #65408	; 0xff80
   43df0:	2202      	movs	r2, #2
   43df2:	4958      	ldr	r1, [pc, #352]	; (43f54 <dwt_ioctl+0x1d38>)
   43df4:	4630      	mov	r0, r6
   43df6:	f7fd fd75 	bl	418e4 <dwt_modify16bitoffsetreg>
   43dfa:	2394      	movs	r3, #148	; 0x94
   43dfc:	2200      	movs	r2, #0
   43dfe:	4956      	ldr	r1, [pc, #344]	; (43f58 <dwt_ioctl+0x1d3c>)
   43e00:	4630      	mov	r0, r6
   43e02:	f7fc fd4d 	bl	408a0 <dwt_write8bitoffsetreg>
   43e06:	2500      	movs	r5, #0
   43e08:	e110      	b.n	4402c <dwt_ioctl+0x1e10>
   43e0a:	2c00      	cmp	r4, #0
   43e0c:	f000 81e8 	beq.w	441e0 <dwt_ioctl+0x1fc4>
   43e10:	2200      	movs	r2, #0
   43e12:	4952      	ldr	r1, [pc, #328]	; (43f5c <dwt_ioctl+0x1d40>)
   43e14:	f7fb fe81 	bl	3fb1a <dwt_read32bitoffsetreg>
   43e18:	6020      	str	r0, [r4, #0]
   43e1a:	2500      	movs	r5, #0
   43e1c:	e106      	b.n	4402c <dwt_ioctl+0x1e10>
   43e1e:	2c00      	cmp	r4, #0
   43e20:	f000 81e0 	beq.w	441e4 <dwt_ioctl+0x1fc8>
   43e24:	2200      	movs	r2, #0
   43e26:	494e      	ldr	r1, [pc, #312]	; (43f60 <dwt_ioctl+0x1d44>)
   43e28:	f7fb fe77 	bl	3fb1a <dwt_read32bitoffsetreg>
   43e2c:	6020      	str	r0, [r4, #0]
   43e2e:	2500      	movs	r5, #0
   43e30:	e0fc      	b.n	4402c <dwt_ioctl+0x1e10>
   43e32:	2c00      	cmp	r4, #0
   43e34:	f000 81d8 	beq.w	441e8 <dwt_ioctl+0x1fcc>
   43e38:	f44f 13a8 	mov.w	r3, #1376256	; 0x150000
   43e3c:	6023      	str	r3, [r4, #0]
   43e3e:	2500      	movs	r5, #0
   43e40:	e0f4      	b.n	4402c <dwt_ioctl+0x1e10>
   43e42:	2c00      	cmp	r4, #0
   43e44:	f000 81d2 	beq.w	441ec <dwt_ioctl+0x1fd0>
   43e48:	2500      	movs	r5, #0
   43e4a:	950a      	str	r5, [sp, #40]	; 0x28
   43e4c:	af0c      	add	r7, sp, #48	; 0x30
   43e4e:	2319      	movs	r3, #25
   43e50:	f847 3d04 	str.w	r3, [r7, #-4]!
   43e54:	9700      	str	r7, [sp, #0]
   43e56:	2304      	movs	r3, #4
   43e58:	462a      	mov	r2, r5
   43e5a:	4942      	ldr	r1, [pc, #264]	; (43f64 <dwt_ioctl+0x1d48>)
   43e5c:	f7fc fac6 	bl	403ec <dwt_writetodevice>
   43e60:	f641 7348 	movw	r3, #8008	; 0x1f48
   43e64:	930b      	str	r3, [sp, #44]	; 0x2c
   43e66:	9700      	str	r7, [sp, #0]
   43e68:	2304      	movs	r3, #4
   43e6a:	462a      	mov	r2, r5
   43e6c:	493e      	ldr	r1, [pc, #248]	; (43f68 <dwt_ioctl+0x1d4c>)
   43e6e:	4630      	mov	r0, r6
   43e70:	f7fc fabc 	bl	403ec <dwt_writetodevice>
   43e74:	ab0a      	add	r3, sp, #40	; 0x28
   43e76:	9300      	str	r3, [sp, #0]
   43e78:	2304      	movs	r3, #4
   43e7a:	462a      	mov	r2, r5
   43e7c:	f44f 11e8 	mov.w	r1, #1900544	; 0x1d0000
   43e80:	4630      	mov	r0, r6
   43e82:	f7fb fe40 	bl	3fb06 <dwt_readfromdevice>
   43e86:	9b0a      	ldr	r3, [sp, #40]	; 0x28
   43e88:	6023      	str	r3, [r4, #0]
   43e8a:	e0cf      	b.n	4402c <dwt_ioctl+0x1e10>
   43e8c:	2c00      	cmp	r4, #0
   43e8e:	f000 81af 	beq.w	441f0 <dwt_ioctl+0x1fd4>
   43e92:	2200      	movs	r2, #0
   43e94:	4935      	ldr	r1, [pc, #212]	; (43f6c <dwt_ioctl+0x1d50>)
   43e96:	f7fb fe40 	bl	3fb1a <dwt_read32bitoffsetreg>
   43e9a:	b280      	uxth	r0, r0
   43e9c:	6020      	str	r0, [r4, #0]
   43e9e:	2200      	movs	r2, #0
   43ea0:	4933      	ldr	r1, [pc, #204]	; (43f70 <dwt_ioctl+0x1d54>)
   43ea2:	4630      	mov	r0, r6
   43ea4:	f7fb fe39 	bl	3fb1a <dwt_read32bitoffsetreg>
   43ea8:	0d43      	lsrs	r3, r0, #21
   43eaa:	019b      	lsls	r3, r3, #6
   43eac:	b29b      	uxth	r3, r3
   43eae:	6063      	str	r3, [r4, #4]
   43eb0:	2500      	movs	r5, #0
   43eb2:	e0bb      	b.n	4402c <dwt_ioctl+0x1e10>
   43eb4:	2c00      	cmp	r4, #0
   43eb6:	f000 819d 	beq.w	441f4 <dwt_ioctl+0x1fd8>
   43eba:	7d63      	ldrb	r3, [r4, #21]
   43ebc:	b133      	cbz	r3, 43ecc <dwt_ioctl+0x1cb0>
   43ebe:	2b01      	cmp	r3, #1
   43ec0:	d062      	beq.n	43f88 <dwt_ioctl+0x1d6c>
   43ec2:	2b02      	cmp	r3, #2
   43ec4:	f000 8089 	beq.w	43fda <dwt_ioctl+0x1dbe>
   43ec8:	23ff      	movs	r3, #255	; 0xff
   43eca:	e02f      	b.n	43f2c <dwt_ioctl+0x1d10>
   43ecc:	2200      	movs	r2, #0
   43ece:	4929      	ldr	r1, [pc, #164]	; (43f74 <dwt_ioctl+0x1d58>)
   43ed0:	f7fb fe23 	bl	3fb1a <dwt_read32bitoffsetreg>
   43ed4:	f3c0 000b 	ubfx	r0, r0, #0, #12
   43ed8:	6020      	str	r0, [r4, #0]
   43eda:	2200      	movs	r2, #0
   43edc:	4926      	ldr	r1, [pc, #152]	; (43f78 <dwt_ioctl+0x1d5c>)
   43ede:	4630      	mov	r0, r6
   43ee0:	f7fb fe1b 	bl	3fb1a <dwt_read32bitoffsetreg>
   43ee4:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43ee8:	6060      	str	r0, [r4, #4]
   43eea:	2200      	movs	r2, #0
   43eec:	4923      	ldr	r1, [pc, #140]	; (43f7c <dwt_ioctl+0x1d60>)
   43eee:	4630      	mov	r0, r6
   43ef0:	f7fb fe13 	bl	3fb1a <dwt_read32bitoffsetreg>
   43ef4:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43ef8:	60a0      	str	r0, [r4, #8]
   43efa:	2200      	movs	r2, #0
   43efc:	4920      	ldr	r1, [pc, #128]	; (43f80 <dwt_ioctl+0x1d64>)
   43efe:	4630      	mov	r0, r6
   43f00:	f7fb fe0b 	bl	3fb1a <dwt_read32bitoffsetreg>
   43f04:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43f08:	60e0      	str	r0, [r4, #12]
   43f0a:	2200      	movs	r2, #0
   43f0c:	491d      	ldr	r1, [pc, #116]	; (43f84 <dwt_ioctl+0x1d68>)
   43f0e:	4630      	mov	r0, r6
   43f10:	f7fb fe03 	bl	3fb1a <dwt_read32bitoffsetreg>
   43f14:	f3c0 0013 	ubfx	r0, r0, #0, #20
   43f18:	6120      	str	r0, [r4, #16]
   43f1a:	2203      	movs	r2, #3
   43f1c:	490f      	ldr	r1, [pc, #60]	; (43f5c <dwt_ioctl+0x1d40>)
   43f1e:	4630      	mov	r0, r6
   43f20:	f7fb fe50 	bl	3fbc4 <dwt_read8bitoffsetreg>
   43f24:	f3c0 1002 	ubfx	r0, r0, #4, #3
   43f28:	7520      	strb	r0, [r4, #20]
   43f2a:	2300      	movs	r3, #0
   43f2c:	75a3      	strb	r3, [r4, #22]
   43f2e:	2500      	movs	r5, #0
   43f30:	e07c      	b.n	4402c <dwt_ioctl+0x1e10>
   43f32:	bf00      	nop
   43f34:	0011003c 	.word	0x0011003c
   43f38:	00110044 	.word	0x00110044
   43f3c:	00110040 	.word	0x00110040
   43f40:	00070048 	.word	0x00070048
   43f44:	f7fc0fff 	.word	0xf7fc0fff
   43f48:	000f0028 	.word	0x000f0028
   43f4c:	0007001c 	.word	0x0007001c
   43f50:	0004707c 	.word	0x0004707c
   43f54:	000e0014 	.word	0x000e0014
   43f58:	000e0018 	.word	0x000e0018
   43f5c:	00030054 	.word	0x00030054
   43f60:	000f004c 	.word	0x000f004c
   43f64:	001f0004 	.word	0x001f0004
   43f68:	001f0008 	.word	0x001f0008
   43f6c:	000c0048 	.word	0x000c0048
   43f70:	000c0028 	.word	0x000c0028
   43f74:	000c0058 	.word	0x000c0058
   43f78:	000c0030 	.word	0x000c0030
   43f7c:	000c0034 	.word	0x000c0034
   43f80:	000c0038 	.word	0x000c0038
   43f84:	000c002c 	.word	0x000c002c
   43f88:	2200      	movs	r2, #0
   43f8a:	49aa      	ldr	r1, [pc, #680]	; (44234 <dwt_ioctl+0x2018>)
   43f8c:	f7fb fdc5 	bl	3fb1a <dwt_read32bitoffsetreg>
   43f90:	f3c0 000b 	ubfx	r0, r0, #0, #12
   43f94:	6020      	str	r0, [r4, #0]
   43f96:	2200      	movs	r2, #0
   43f98:	49a7      	ldr	r1, [pc, #668]	; (44238 <dwt_ioctl+0x201c>)
   43f9a:	4630      	mov	r0, r6
   43f9c:	f7fb fdbd 	bl	3fb1a <dwt_read32bitoffsetreg>
   43fa0:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43fa4:	6060      	str	r0, [r4, #4]
   43fa6:	2200      	movs	r2, #0
   43fa8:	49a4      	ldr	r1, [pc, #656]	; (4423c <dwt_ioctl+0x2020>)
   43faa:	4630      	mov	r0, r6
   43fac:	f7fb fdb5 	bl	3fb1a <dwt_read32bitoffsetreg>
   43fb0:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43fb4:	60a0      	str	r0, [r4, #8]
   43fb6:	2200      	movs	r2, #0
   43fb8:	f44f 2150 	mov.w	r1, #851968	; 0xd0000
   43fbc:	4630      	mov	r0, r6
   43fbe:	f7fb fdac 	bl	3fb1a <dwt_read32bitoffsetreg>
   43fc2:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43fc6:	60e0      	str	r0, [r4, #12]
   43fc8:	2200      	movs	r2, #0
   43fca:	499d      	ldr	r1, [pc, #628]	; (44240 <dwt_ioctl+0x2024>)
   43fcc:	4630      	mov	r0, r6
   43fce:	f7fb fda4 	bl	3fb1a <dwt_read32bitoffsetreg>
   43fd2:	f3c0 0013 	ubfx	r0, r0, #0, #20
   43fd6:	6120      	str	r0, [r4, #16]
   43fd8:	e79f      	b.n	43f1a <dwt_ioctl+0x1cfe>
   43fda:	2200      	movs	r2, #0
   43fdc:	4999      	ldr	r1, [pc, #612]	; (44244 <dwt_ioctl+0x2028>)
   43fde:	f7fb fd9c 	bl	3fb1a <dwt_read32bitoffsetreg>
   43fe2:	f3c0 000b 	ubfx	r0, r0, #0, #12
   43fe6:	6020      	str	r0, [r4, #0]
   43fe8:	2200      	movs	r2, #0
   43fea:	4997      	ldr	r1, [pc, #604]	; (44248 <dwt_ioctl+0x202c>)
   43fec:	4630      	mov	r0, r6
   43fee:	f7fb fd94 	bl	3fb1a <dwt_read32bitoffsetreg>
   43ff2:	f3c0 0015 	ubfx	r0, r0, #0, #22
   43ff6:	6060      	str	r0, [r4, #4]
   43ff8:	2200      	movs	r2, #0
   43ffa:	4994      	ldr	r1, [pc, #592]	; (4424c <dwt_ioctl+0x2030>)
   43ffc:	4630      	mov	r0, r6
   43ffe:	f7fb fd8c 	bl	3fb1a <dwt_read32bitoffsetreg>
   44002:	f3c0 0015 	ubfx	r0, r0, #0, #22
   44006:	60a0      	str	r0, [r4, #8]
   44008:	2200      	movs	r2, #0
   4400a:	4991      	ldr	r1, [pc, #580]	; (44250 <dwt_ioctl+0x2034>)
   4400c:	4630      	mov	r0, r6
   4400e:	f7fb fd84 	bl	3fb1a <dwt_read32bitoffsetreg>
   44012:	f3c0 0015 	ubfx	r0, r0, #0, #22
   44016:	60e0      	str	r0, [r4, #12]
   44018:	2200      	movs	r2, #0
   4401a:	498e      	ldr	r1, [pc, #568]	; (44254 <dwt_ioctl+0x2038>)
   4401c:	4630      	mov	r0, r6
   4401e:	f7fb fd7c 	bl	3fb1a <dwt_read32bitoffsetreg>
   44022:	f3c0 0013 	ubfx	r0, r0, #0, #20
   44026:	6120      	str	r0, [r4, #16]
   44028:	e777      	b.n	43f1a <dwt_ioctl+0x1cfe>
   4402a:	2500      	movs	r5, #0
   4402c:	4628      	mov	r0, r5
   4402e:	b00d      	add	sp, #52	; 0x34
   44030:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   44034:	2500      	movs	r5, #0
   44036:	e7f9      	b.n	4402c <dwt_ioctl+0x1e10>
   44038:	2500      	movs	r5, #0
   4403a:	e7f7      	b.n	4402c <dwt_ioctl+0x1e10>
   4403c:	2500      	movs	r5, #0
   4403e:	e7f5      	b.n	4402c <dwt_ioctl+0x1e10>
   44040:	2500      	movs	r5, #0
   44042:	e7f3      	b.n	4402c <dwt_ioctl+0x1e10>
   44044:	2500      	movs	r5, #0
   44046:	e7f1      	b.n	4402c <dwt_ioctl+0x1e10>
   44048:	2500      	movs	r5, #0
   4404a:	e7ef      	b.n	4402c <dwt_ioctl+0x1e10>
   4404c:	2500      	movs	r5, #0
   4404e:	e7ed      	b.n	4402c <dwt_ioctl+0x1e10>
   44050:	2500      	movs	r5, #0
   44052:	e7eb      	b.n	4402c <dwt_ioctl+0x1e10>
   44054:	2500      	movs	r5, #0
   44056:	e7e9      	b.n	4402c <dwt_ioctl+0x1e10>
   44058:	2500      	movs	r5, #0
   4405a:	e7e7      	b.n	4402c <dwt_ioctl+0x1e10>
   4405c:	2500      	movs	r5, #0
   4405e:	e7e5      	b.n	4402c <dwt_ioctl+0x1e10>
   44060:	2500      	movs	r5, #0
   44062:	e7e3      	b.n	4402c <dwt_ioctl+0x1e10>
   44064:	2500      	movs	r5, #0
   44066:	e7e1      	b.n	4402c <dwt_ioctl+0x1e10>
   44068:	2500      	movs	r5, #0
   4406a:	e7df      	b.n	4402c <dwt_ioctl+0x1e10>
   4406c:	2500      	movs	r5, #0
   4406e:	e7dd      	b.n	4402c <dwt_ioctl+0x1e10>
   44070:	2500      	movs	r5, #0
   44072:	e7db      	b.n	4402c <dwt_ioctl+0x1e10>
   44074:	2500      	movs	r5, #0
   44076:	e7d9      	b.n	4402c <dwt_ioctl+0x1e10>
   44078:	2500      	movs	r5, #0
   4407a:	e7d7      	b.n	4402c <dwt_ioctl+0x1e10>
   4407c:	2500      	movs	r5, #0
   4407e:	e7d5      	b.n	4402c <dwt_ioctl+0x1e10>
   44080:	2500      	movs	r5, #0
   44082:	e7d3      	b.n	4402c <dwt_ioctl+0x1e10>
   44084:	2500      	movs	r5, #0
   44086:	e7d1      	b.n	4402c <dwt_ioctl+0x1e10>
   44088:	2500      	movs	r5, #0
   4408a:	e7cf      	b.n	4402c <dwt_ioctl+0x1e10>
   4408c:	2500      	movs	r5, #0
   4408e:	e7cd      	b.n	4402c <dwt_ioctl+0x1e10>
   44090:	2500      	movs	r5, #0
   44092:	e7cb      	b.n	4402c <dwt_ioctl+0x1e10>
   44094:	2500      	movs	r5, #0
   44096:	e7c9      	b.n	4402c <dwt_ioctl+0x1e10>
   44098:	2500      	movs	r5, #0
   4409a:	e7c7      	b.n	4402c <dwt_ioctl+0x1e10>
   4409c:	2500      	movs	r5, #0
   4409e:	e7c5      	b.n	4402c <dwt_ioctl+0x1e10>
   440a0:	2500      	movs	r5, #0
   440a2:	e7c3      	b.n	4402c <dwt_ioctl+0x1e10>
   440a4:	2500      	movs	r5, #0
   440a6:	e7c1      	b.n	4402c <dwt_ioctl+0x1e10>
   440a8:	2500      	movs	r5, #0
   440aa:	e7bf      	b.n	4402c <dwt_ioctl+0x1e10>
   440ac:	2500      	movs	r5, #0
   440ae:	e7bd      	b.n	4402c <dwt_ioctl+0x1e10>
   440b0:	2500      	movs	r5, #0
   440b2:	e7bb      	b.n	4402c <dwt_ioctl+0x1e10>
   440b4:	2500      	movs	r5, #0
   440b6:	e7b9      	b.n	4402c <dwt_ioctl+0x1e10>
   440b8:	2500      	movs	r5, #0
   440ba:	e7b7      	b.n	4402c <dwt_ioctl+0x1e10>
   440bc:	2500      	movs	r5, #0
   440be:	e7b5      	b.n	4402c <dwt_ioctl+0x1e10>
   440c0:	2500      	movs	r5, #0
   440c2:	e7b3      	b.n	4402c <dwt_ioctl+0x1e10>
   440c4:	2500      	movs	r5, #0
   440c6:	e7b1      	b.n	4402c <dwt_ioctl+0x1e10>
   440c8:	2500      	movs	r5, #0
   440ca:	e7af      	b.n	4402c <dwt_ioctl+0x1e10>
   440cc:	2500      	movs	r5, #0
   440ce:	e7ad      	b.n	4402c <dwt_ioctl+0x1e10>
   440d0:	2500      	movs	r5, #0
   440d2:	e7ab      	b.n	4402c <dwt_ioctl+0x1e10>
   440d4:	2500      	movs	r5, #0
   440d6:	e7a9      	b.n	4402c <dwt_ioctl+0x1e10>
   440d8:	2500      	movs	r5, #0
   440da:	e7a7      	b.n	4402c <dwt_ioctl+0x1e10>
   440dc:	2500      	movs	r5, #0
   440de:	e7a5      	b.n	4402c <dwt_ioctl+0x1e10>
   440e0:	2500      	movs	r5, #0
   440e2:	e7a3      	b.n	4402c <dwt_ioctl+0x1e10>
   440e4:	2500      	movs	r5, #0
   440e6:	e7a1      	b.n	4402c <dwt_ioctl+0x1e10>
   440e8:	2500      	movs	r5, #0
   440ea:	e79f      	b.n	4402c <dwt_ioctl+0x1e10>
   440ec:	2500      	movs	r5, #0
   440ee:	e79d      	b.n	4402c <dwt_ioctl+0x1e10>
   440f0:	2500      	movs	r5, #0
   440f2:	e79b      	b.n	4402c <dwt_ioctl+0x1e10>
   440f4:	2500      	movs	r5, #0
   440f6:	e799      	b.n	4402c <dwt_ioctl+0x1e10>
   440f8:	2500      	movs	r5, #0
   440fa:	e797      	b.n	4402c <dwt_ioctl+0x1e10>
   440fc:	2500      	movs	r5, #0
   440fe:	e795      	b.n	4402c <dwt_ioctl+0x1e10>
   44100:	2500      	movs	r5, #0
   44102:	e793      	b.n	4402c <dwt_ioctl+0x1e10>
   44104:	2500      	movs	r5, #0
   44106:	e791      	b.n	4402c <dwt_ioctl+0x1e10>
   44108:	2500      	movs	r5, #0
   4410a:	e78f      	b.n	4402c <dwt_ioctl+0x1e10>
   4410c:	2500      	movs	r5, #0
   4410e:	e78d      	b.n	4402c <dwt_ioctl+0x1e10>
   44110:	2500      	movs	r5, #0
   44112:	e78b      	b.n	4402c <dwt_ioctl+0x1e10>
   44114:	2500      	movs	r5, #0
   44116:	e789      	b.n	4402c <dwt_ioctl+0x1e10>
   44118:	2500      	movs	r5, #0
   4411a:	e787      	b.n	4402c <dwt_ioctl+0x1e10>
   4411c:	2500      	movs	r5, #0
   4411e:	e785      	b.n	4402c <dwt_ioctl+0x1e10>
   44120:	2500      	movs	r5, #0
   44122:	e783      	b.n	4402c <dwt_ioctl+0x1e10>
   44124:	2500      	movs	r5, #0
   44126:	e781      	b.n	4402c <dwt_ioctl+0x1e10>
   44128:	2500      	movs	r5, #0
   4412a:	e77f      	b.n	4402c <dwt_ioctl+0x1e10>
   4412c:	2500      	movs	r5, #0
   4412e:	e77d      	b.n	4402c <dwt_ioctl+0x1e10>
   44130:	2500      	movs	r5, #0
   44132:	e77b      	b.n	4402c <dwt_ioctl+0x1e10>
   44134:	2500      	movs	r5, #0
   44136:	e779      	b.n	4402c <dwt_ioctl+0x1e10>
   44138:	2500      	movs	r5, #0
   4413a:	e777      	b.n	4402c <dwt_ioctl+0x1e10>
   4413c:	2500      	movs	r5, #0
   4413e:	e775      	b.n	4402c <dwt_ioctl+0x1e10>
   44140:	2500      	movs	r5, #0
   44142:	e773      	b.n	4402c <dwt_ioctl+0x1e10>
   44144:	2500      	movs	r5, #0
   44146:	e771      	b.n	4402c <dwt_ioctl+0x1e10>
   44148:	2500      	movs	r5, #0
   4414a:	e76f      	b.n	4402c <dwt_ioctl+0x1e10>
   4414c:	2500      	movs	r5, #0
   4414e:	e76d      	b.n	4402c <dwt_ioctl+0x1e10>
   44150:	2500      	movs	r5, #0
   44152:	e76b      	b.n	4402c <dwt_ioctl+0x1e10>
   44154:	2500      	movs	r5, #0
   44156:	e769      	b.n	4402c <dwt_ioctl+0x1e10>
   44158:	2500      	movs	r5, #0
   4415a:	e767      	b.n	4402c <dwt_ioctl+0x1e10>
   4415c:	2500      	movs	r5, #0
   4415e:	e765      	b.n	4402c <dwt_ioctl+0x1e10>
   44160:	2500      	movs	r5, #0
   44162:	e763      	b.n	4402c <dwt_ioctl+0x1e10>
   44164:	2500      	movs	r5, #0
   44166:	e761      	b.n	4402c <dwt_ioctl+0x1e10>
   44168:	2500      	movs	r5, #0
   4416a:	e75f      	b.n	4402c <dwt_ioctl+0x1e10>
   4416c:	2500      	movs	r5, #0
   4416e:	e75d      	b.n	4402c <dwt_ioctl+0x1e10>
   44170:	2500      	movs	r5, #0
   44172:	e75b      	b.n	4402c <dwt_ioctl+0x1e10>
   44174:	2500      	movs	r5, #0
   44176:	e759      	b.n	4402c <dwt_ioctl+0x1e10>
   44178:	2500      	movs	r5, #0
   4417a:	e757      	b.n	4402c <dwt_ioctl+0x1e10>
   4417c:	2500      	movs	r5, #0
   4417e:	e755      	b.n	4402c <dwt_ioctl+0x1e10>
   44180:	2500      	movs	r5, #0
   44182:	e753      	b.n	4402c <dwt_ioctl+0x1e10>
   44184:	2500      	movs	r5, #0
   44186:	e751      	b.n	4402c <dwt_ioctl+0x1e10>
   44188:	2500      	movs	r5, #0
   4418a:	e74f      	b.n	4402c <dwt_ioctl+0x1e10>
   4418c:	2500      	movs	r5, #0
   4418e:	e74d      	b.n	4402c <dwt_ioctl+0x1e10>
   44190:	2500      	movs	r5, #0
   44192:	e74b      	b.n	4402c <dwt_ioctl+0x1e10>
   44194:	2500      	movs	r5, #0
   44196:	e749      	b.n	4402c <dwt_ioctl+0x1e10>
   44198:	2500      	movs	r5, #0
   4419a:	e747      	b.n	4402c <dwt_ioctl+0x1e10>
   4419c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   441a0:	e744      	b.n	4402c <dwt_ioctl+0x1e10>
   441a2:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   441a6:	e741      	b.n	4402c <dwt_ioctl+0x1e10>
   441a8:	2500      	movs	r5, #0
   441aa:	e73f      	b.n	4402c <dwt_ioctl+0x1e10>
   441ac:	2500      	movs	r5, #0
   441ae:	e73d      	b.n	4402c <dwt_ioctl+0x1e10>
   441b0:	2500      	movs	r5, #0
   441b2:	e73b      	b.n	4402c <dwt_ioctl+0x1e10>
   441b4:	2500      	movs	r5, #0
   441b6:	e739      	b.n	4402c <dwt_ioctl+0x1e10>
   441b8:	2500      	movs	r5, #0
   441ba:	e737      	b.n	4402c <dwt_ioctl+0x1e10>
   441bc:	2500      	movs	r5, #0
   441be:	e735      	b.n	4402c <dwt_ioctl+0x1e10>
   441c0:	2500      	movs	r5, #0
   441c2:	e733      	b.n	4402c <dwt_ioctl+0x1e10>
   441c4:	2500      	movs	r5, #0
   441c6:	e731      	b.n	4402c <dwt_ioctl+0x1e10>
   441c8:	2500      	movs	r5, #0
   441ca:	e72f      	b.n	4402c <dwt_ioctl+0x1e10>
   441cc:	2500      	movs	r5, #0
   441ce:	e72d      	b.n	4402c <dwt_ioctl+0x1e10>
   441d0:	2500      	movs	r5, #0
   441d2:	e72b      	b.n	4402c <dwt_ioctl+0x1e10>
   441d4:	2500      	movs	r5, #0
   441d6:	e729      	b.n	4402c <dwt_ioctl+0x1e10>
   441d8:	2500      	movs	r5, #0
   441da:	e727      	b.n	4402c <dwt_ioctl+0x1e10>
   441dc:	2500      	movs	r5, #0
   441de:	e725      	b.n	4402c <dwt_ioctl+0x1e10>
   441e0:	2500      	movs	r5, #0
   441e2:	e723      	b.n	4402c <dwt_ioctl+0x1e10>
   441e4:	2500      	movs	r5, #0
   441e6:	e721      	b.n	4402c <dwt_ioctl+0x1e10>
   441e8:	2500      	movs	r5, #0
   441ea:	e71f      	b.n	4402c <dwt_ioctl+0x1e10>
   441ec:	2500      	movs	r5, #0
   441ee:	e71d      	b.n	4402c <dwt_ioctl+0x1e10>
   441f0:	2500      	movs	r5, #0
   441f2:	e71b      	b.n	4402c <dwt_ioctl+0x1e10>
   441f4:	2500      	movs	r5, #0
   441f6:	e719      	b.n	4402c <dwt_ioctl+0x1e10>
   441f8:	f899 3011 	ldrb.w	r3, [r9, #17]
   441fc:	1e5a      	subs	r2, r3, #1
   441fe:	b2d2      	uxtb	r2, r2
   44200:	2a01      	cmp	r2, #1
   44202:	f67e ae60 	bls.w	42ec6 <dwt_ioctl+0xcaa>
   44206:	2202      	movs	r2, #2
   44208:	f7fe be07 	b.w	42e1a <dwt_ioctl+0xbfe>
   4420c:	4d12      	ldr	r5, [pc, #72]	; (44258 <dwt_ioctl+0x203c>)
   4420e:	e57c      	b.n	43d0a <dwt_ioctl+0x1aee>
   44210:	2400      	movs	r4, #0
   44212:	9400      	str	r4, [sp, #0]
   44214:	f06f 73c0 	mvn.w	r3, #25165824	; 0x1800000
   44218:	4622      	mov	r2, r4
   4421a:	2110      	movs	r1, #16
   4421c:	f7fc fe62 	bl	40ee4 <dwt_modify32bitoffsetreg>
   44220:	9400      	str	r4, [sp, #0]
   44222:	4b0e      	ldr	r3, [pc, #56]	; (4425c <dwt_ioctl+0x2040>)
   44224:	4622      	mov	r2, r4
   44226:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   4422a:	4630      	mov	r0, r6
   4422c:	f7fc fe5a 	bl	40ee4 <dwt_modify32bitoffsetreg>
   44230:	e57e      	b.n	43d30 <dwt_ioctl+0x1b14>
   44232:	bf00      	nop
   44234:	000d0020 	.word	0x000d0020
   44238:	000c0064 	.word	0x000c0064
   4423c:	000c0068 	.word	0x000c0068
   44240:	000c0060 	.word	0x000c0060
   44244:	000d0068 	.word	0x000d0068
   44248:	000d0040 	.word	0x000d0040
   4424c:	000d0044 	.word	0x000d0044
   44250:	000d0048 	.word	0x000d0048
   44254:	000d003c 	.word	0x000d003c
   44258:	08001000 	.word	0x08001000
   4425c:	f7fc0fff 	.word	0xf7fc0fff

00044260 <_init>:
   44260:	b5f0      	push	{r4, r5, r6, r7, lr}
   44262:	b085      	sub	sp, #20
   44264:	4604      	mov	r4, r0
   44266:	6b43      	ldr	r3, [r0, #52]	; 0x34
   44268:	6819      	ldr	r1, [r3, #0]
   4426a:	f7fd fea1 	bl	41fb0 <ull_initialise>
   4426e:	4606      	mov	r6, r0
   44270:	6823      	ldr	r3, [r4, #0]
   44272:	691b      	ldr	r3, [r3, #16]
   44274:	4798      	blx	r3
   44276:	ab03      	add	r3, sp, #12
   44278:	2200      	movs	r2, #0
   4427a:	4611      	mov	r1, r2
   4427c:	4620      	mov	r0, r4
   4427e:	f7fd ffcd 	bl	4221c <dwt_ioctl>
   44282:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44284:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   44286:	6819      	ldr	r1, [r3, #0]
   44288:	4620      	mov	r0, r4
   4428a:	f7fd fc43 	bl	41b14 <ull_configure>
   4428e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44290:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   44292:	6859      	ldr	r1, [r3, #4]
   44294:	4620      	mov	r0, r4
   44296:	f7fd f993 	bl	415c0 <ull_configuretxrf>
   4429a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4429c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   4429e:	89d9      	ldrh	r1, [r3, #14]
   442a0:	4620      	mov	r0, r4
   442a2:	f7fc f8be 	bl	40422 <ull_setrxantennadelay>
   442a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
   442a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   442aa:	8999      	ldrh	r1, [r3, #12]
   442ac:	4620      	mov	r0, r4
   442ae:	f7fc f8c0 	bl	40432 <ull_settxantennadelay>
   442b2:	2100      	movs	r1, #0
   442b4:	4620      	mov	r0, r4
   442b6:	f7fc f94a 	bl	4054e <ull_setrxaftertxdelay>
   442ba:	2500      	movs	r5, #0
   442bc:	9500      	str	r5, [sp, #0]
   442be:	f64f 53ff 	movw	r3, #65023	; 0xfdff
   442c2:	462a      	mov	r2, r5
   442c4:	2110      	movs	r1, #16
   442c6:	4620      	mov	r0, r4
   442c8:	f7fd fb0c 	bl	418e4 <dwt_modify16bitoffsetreg>
   442cc:	6b63      	ldr	r3, [r4, #52]	; 0x34
   442ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   442d0:	895a      	ldrh	r2, [r3, #10]
   442d2:	8919      	ldrh	r1, [r3, #8]
   442d4:	4620      	mov	r0, r4
   442d6:	f7fd fa03 	bl	416e0 <ull_configureframefilter>
   442da:	6b63      	ldr	r3, [r4, #52]	; 0x34
   442dc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   442de:	8a1b      	ldrh	r3, [r3, #16]
   442e0:	2202      	movs	r2, #2
   442e2:	210c      	movs	r1, #12
   442e4:	4620      	mov	r0, r4
   442e6:	f7fc f88c 	bl	40402 <dwt_write16bitoffsetreg>
   442ea:	6b63      	ldr	r3, [r4, #52]	; 0x34
   442ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   442ee:	8a5b      	ldrh	r3, [r3, #18]
   442f0:	462a      	mov	r2, r5
   442f2:	210c      	movs	r1, #12
   442f4:	4620      	mov	r0, r4
   442f6:	f7fc f884 	bl	40402 <dwt_write16bitoffsetreg>
   442fa:	6b63      	ldr	r3, [r4, #52]	; 0x34
   442fc:	7a19      	ldrb	r1, [r3, #8]
   442fe:	4620      	mov	r0, r4
   44300:	f7fd fb2e 	bl	41960 <ull_setleds>
   44304:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44306:	68d9      	ldr	r1, [r3, #12]
   44308:	4620      	mov	r0, r4
   4430a:	f7fc f949 	bl	405a0 <ull_setlnapamode>
   4430e:	6b61      	ldr	r1, [r4, #52]	; 0x34
   44310:	7e0b      	ldrb	r3, [r1, #24]
   44312:	694a      	ldr	r2, [r1, #20]
   44314:	6909      	ldr	r1, [r1, #16]
   44316:	4620      	mov	r0, r4
   44318:	f7fd fa68 	bl	417ec <ull_setinterrupt>
   4431c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4431e:	7f9a      	ldrb	r2, [r3, #30]
   44320:	8b99      	ldrh	r1, [r3, #28]
   44322:	4620      	mov	r0, r4
   44324:	f7fc fb90 	bl	40a48 <ull_configuresleep>
   44328:	6d22      	ldr	r2, [r4, #80]	; 0x50
   4432a:	7b53      	ldrb	r3, [r2, #13]
   4432c:	2b2e      	cmp	r3, #46	; 0x2e
   4432e:	d005      	beq.n	4433c <_init+0xdc>
   44330:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44332:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   44336:	f033 033f 	bics.w	r3, r3, #63	; 0x3f
   4433a:	d00a      	beq.n	44352 <_init+0xf2>
   4433c:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4433e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
   44342:	f003 033f 	and.w	r3, r3, #63	; 0x3f
   44346:	7353      	strb	r3, [r2, #13]
   44348:	2200      	movs	r2, #0
   4434a:	4928      	ldr	r1, [pc, #160]	; (443ec <_init+0x18c>)
   4434c:	4620      	mov	r0, r4
   4434e:	f7fc faa7 	bl	408a0 <dwt_write8bitoffsetreg>
   44352:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44354:	f893 102d 	ldrb.w	r1, [r3, #45]	; 0x2d
   44358:	4620      	mov	r0, r4
   4435a:	f7fc ff63 	bl	41224 <ull_configciadiag>
   4435e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44360:	6a19      	ldr	r1, [r3, #32]
   44362:	4620      	mov	r0, r4
   44364:	f7fc f93c 	bl	405e0 <ull_configurestskey>
   44368:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4436a:	6a59      	ldr	r1, [r3, #36]	; 0x24
   4436c:	4620      	mov	r0, r4
   4436e:	f7fc f95b 	bl	40628 <ull_configurestsiv>
   44372:	6b63      	ldr	r3, [r4, #52]	; 0x34
   44374:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
   44378:	bb9b      	cbnz	r3, 443e2 <_init+0x182>
   4437a:	6b63      	ldr	r3, [r4, #52]	; 0x34
   4437c:	f893 102f 	ldrb.w	r1, [r3, #47]	; 0x2f
   44380:	4620      	mov	r0, r4
   44382:	f7fc fb05 	bl	40990 <ull_configeventcounters>
   44386:	f994 504c 	ldrsb.w	r5, [r4, #76]	; 0x4c
   4438a:	2d00      	cmp	r5, #0
   4438c:	db26      	blt.n	443dc <_init+0x17c>
   4438e:	2301      	movs	r3, #1
   44390:	fa03 f505 	lsl.w	r5, r3, r5
   44394:	b2af      	uxth	r7, r5
   44396:	4a16      	ldr	r2, [pc, #88]	; (443f0 <_init+0x190>)
   44398:	4639      	mov	r1, r7
   4439a:	4620      	mov	r0, r4
   4439c:	f7fc fed4 	bl	41148 <ull_setgpiomode>
   443a0:	f10d 030a 	add.w	r3, sp, #10
   443a4:	9300      	str	r3, [sp, #0]
   443a6:	2302      	movs	r3, #2
   443a8:	2200      	movs	r2, #0
   443aa:	f44f 21a0 	mov.w	r1, #327680	; 0x50000
   443ae:	4620      	mov	r0, r4
   443b0:	f7fb fba9 	bl	3fb06 <dwt_readfromdevice>
   443b4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
   443b8:	ea23 0305 	bic.w	r3, r3, r5
   443bc:	f8ad 300a 	strh.w	r3, [sp, #10]
   443c0:	2200      	movs	r2, #0
   443c2:	490c      	ldr	r1, [pc, #48]	; (443f4 <_init+0x194>)
   443c4:	4620      	mov	r0, r4
   443c6:	f7fc f81c 	bl	40402 <dwt_write16bitoffsetreg>
   443ca:	f994 204d 	ldrsb.w	r2, [r4, #77]	; 0x4d
   443ce:	fab2 f282 	clz	r2, r2
   443d2:	0952      	lsrs	r2, r2, #5
   443d4:	4639      	mov	r1, r7
   443d6:	4620      	mov	r0, r4
   443d8:	f7fd fb40 	bl	41a5c <ull_setgpiovalue>
   443dc:	4630      	mov	r0, r6
   443de:	b005      	add	sp, #20
   443e0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   443e2:	4620      	mov	r0, r4
   443e4:	f7fc ff54 	bl	41290 <ull_configurestsloadiv>
   443e8:	e7c7      	b.n	4437a <_init+0x11a>
   443ea:	bf00      	nop
   443ec:	00090014 	.word	0x00090014
   443f0:	01200492 	.word	0x01200492
   443f4:	00050008 	.word	0x00050008
   443f8:	20454c42 	.word	0x20454c42
   443fc:	746e6f43 	.word	0x746e6f43
   44400:	6c6c6f72 	.word	0x6c6c6f72
   44404:	49207265 	.word	0x49207265
   44408:	2074696e 	.word	0x2074696e
   4440c:	656e6f44 	.word	0x656e6f44
   44410:	00000a0d 	.word	0x00000a0d
   44414:	20454c42 	.word	0x20454c42
   44418:	746e6f43 	.word	0x746e6f43
   4441c:	6c6c6f72 	.word	0x6c6c6f72
   44420:	53207265 	.word	0x53207265
   44424:	45204c42 	.word	0x45204c42
   44428:	726f7272 	.word	0x726f7272
   4442c:	25783020 	.word	0x25783020
   44430:	000a0d78 	.word	0x000a0d78
   44434:	20454c42 	.word	0x20454c42
   44438:	746e6f43 	.word	0x746e6f43
   4443c:	6c6c6f72 	.word	0x6c6c6f72
   44440:	49207265 	.word	0x49207265
   44444:	3a6f666e 	.word	0x3a6f666e
   44448:	0000000a 	.word	0x0000000a
   4444c:	20574609 	.word	0x20574609
   44450:	3a726556 	.word	0x3a726556
   44454:	20202020 	.word	0x20202020
   44458:	64252020 	.word	0x64252020
   4445c:	0a64252e 	.word	0x0a64252e
   44460:	00000000 	.word	0x00000000
   44464:	20574609 	.word	0x20574609
   44468:	3a726556 	.word	0x3a726556
   4446c:	20202020 	.word	0x20202020
   44470:	64252020 	.word	0x64252020
   44474:	2e64252e 	.word	0x2e64252e
   44478:	252e6425 	.word	0x252e6425
   4447c:	00000a64 	.word	0x00000a64
   44480:	69684309 	.word	0x69684309
   44484:	44492070 	.word	0x44492070
   44488:	20203a30 	.word	0x20203a30
   4448c:	78302020 	.word	0x78302020
   44490:	000a7825 	.word	0x000a7825
   44494:	69684309 	.word	0x69684309
   44498:	44492070 	.word	0x44492070
   4449c:	20203a31 	.word	0x20203a31
   444a0:	78302020 	.word	0x78302020
   444a4:	0a0a7825 	.word	0x0a0a7825
   444a8:	00000000 	.word	0x00000000
   444ac:	65636552 	.word	0x65636552
   444b0:	64657669 	.word	0x64657669
   444b4:	77656e20 	.word	0x77656e20
   444b8:	454c4220 	.word	0x454c4220
   444bc:	6e6f4320 	.word	0x6e6f4320
   444c0:	6c6f7274 	.word	0x6c6f7274
   444c4:	2072656c 	.word	0x2072656c
   444c8:	76205746 	.word	0x76205746
   444cc:	69737265 	.word	0x69737265
   444d0:	3d206e6f 	.word	0x3d206e6f
   444d4:	2e642520 	.word	0x2e642520
   444d8:	47206425 	.word	0x47206425
   444dc:	676e696f 	.word	0x676e696f
   444e0:	726f6620 	.word	0x726f6620
   444e4:	67707520 	.word	0x67707520
   444e8:	65646172 	.word	0x65646172
   444ec:	0000000a 	.word	0x0000000a
   444f0:	65636552 	.word	0x65636552
   444f4:	64657669 	.word	0x64657669
   444f8:	77656e20 	.word	0x77656e20
   444fc:	454c4220 	.word	0x454c4220
   44500:	6e6f4320 	.word	0x6e6f4320
   44504:	6c6f7274 	.word	0x6c6f7274
   44508:	2072656c 	.word	0x2072656c
   4450c:	76205746 	.word	0x76205746
   44510:	69737265 	.word	0x69737265
   44514:	3d206e6f 	.word	0x3d206e6f
   44518:	2e642520 	.word	0x2e642520
   4451c:	252e6425 	.word	0x252e6425
   44520:	64252e64 	.word	0x64252e64
   44524:	696f4720 	.word	0x696f4720
   44528:	6620676e 	.word	0x6620676e
   4452c:	7520726f 	.word	0x7520726f
   44530:	61726770 	.word	0x61726770
   44534:	000a6564 	.word	0x000a6564
   44538:	6e206f4e 	.word	0x6e206f4e
   4453c:	69207765 	.word	0x69207765
   44540:	6567616d 	.word	0x6567616d
   44544:	206f7420 	.word	0x206f7420
   44548:	72677075 	.word	0x72677075
   4454c:	0a656461 	.word	0x0a656461
   44550:	00000000 	.word	0x00000000
   44554:	20454c42 	.word	0x20454c42
   44558:	746e6f43 	.word	0x746e6f43
   4455c:	6c6c6f72 	.word	0x6c6c6f72
   44560:	46207265 	.word	0x46207265
   44564:	75412057 	.word	0x75412057
   44568:	50206874 	.word	0x50206874
   4456c:	65737361 	.word	0x65737361
   44570:	43202c64 	.word	0x43202c64
   44574:	69746e6f 	.word	0x69746e6f
   44578:	2065756e 	.word	0x2065756e
   4457c:	68746977 	.word	0x68746977
   44580:	0a574620 	.word	0x0a574620
   44584:	00000000 	.word	0x00000000
   44588:	20454c42 	.word	0x20454c42
   4458c:	746e6f43 	.word	0x746e6f43
   44590:	6c6c6f72 	.word	0x6c6c6f72
   44594:	52207265 	.word	0x52207265
   44598:	69757165 	.word	0x69757165
   4459c:	20736572 	.word	0x20736572
   445a0:	000a5746 	.word	0x000a5746
   445a4:	20454c42 	.word	0x20454c42
   445a8:	746e6f43 	.word	0x746e6f43
   445ac:	6c6c6f72 	.word	0x6c6c6f72
   445b0:	52207265 	.word	0x52207265
   445b4:	69757165 	.word	0x69757165
   445b8:	20736572 	.word	0x20736572
   445bc:	4f464e49 	.word	0x4f464e49
   445c0:	000a3020 	.word	0x000a3020
   445c4:	20454c42 	.word	0x20454c42
   445c8:	746e6f43 	.word	0x746e6f43
   445cc:	6c6c6f72 	.word	0x6c6c6f72
   445d0:	52207265 	.word	0x52207265
   445d4:	69757165 	.word	0x69757165
   445d8:	20736572 	.word	0x20736572
   445dc:	4f464e49 	.word	0x4f464e49
   445e0:	000a3120 	.word	0x000a3120
   445e4:	20454c42 	.word	0x20454c42
   445e8:	746e6f43 	.word	0x746e6f43
   445ec:	6c6c6f72 	.word	0x6c6c6f72
   445f0:	57207265 	.word	0x57207265
   445f4:	676e6f72 	.word	0x676e6f72
   445f8:	73655220 	.word	0x73655220
   445fc:	736e6f70 	.word	0x736e6f70
   44600:	00000a65 	.word	0x00000a65
   44604:	20454c42 	.word	0x20454c42
   44608:	746e6f63 	.word	0x746e6f63
   4460c:	6c6c6f72 	.word	0x6c6c6f72
   44610:	75207265 	.word	0x75207265
   44614:	61726770 	.word	0x61726770
   44618:	69206564 	.word	0x69206564
   4461c:	7270206e 	.word	0x7270206e
   44620:	6572676f 	.word	0x6572676f
   44624:	202c7373 	.word	0x202c7373
   44628:	74696177 	.word	0x74696177
   4462c:	0a2e2e2e 	.word	0x0a2e2e2e
   44630:	00000000 	.word	0x00000000
   44634:	61656c43 	.word	0x61656c43
   44638:	6f432072 	.word	0x6f432072
   4463c:	7265706f 	.word	0x7265706f
   44640:	67695320 	.word	0x67695320
   44644:	7574616e 	.word	0x7574616e
   44648:	202c6572 	.word	0x202c6572
   4464c:	65736572 	.word	0x65736572
   44650:	6f432074 	.word	0x6f432074
   44654:	7265706f 	.word	0x7265706f
   44658:	646e6120 	.word	0x646e6120
   4465c:	6c617420 	.word	0x6c617420
   44660:	6977206b 	.word	0x6977206b
   44664:	53206874 	.word	0x53206874
   44668:	61204c42 	.word	0x61204c42
   4466c:	6e696167 	.word	0x6e696167
   44670:	0000000a 	.word	0x0000000a
   44674:	61647055 	.word	0x61647055
   44678:	46206574 	.word	0x46206574
   4467c:	656c6961 	.word	0x656c6961
   44680:	21212064 	.word	0x21212064
   44684:	00000a21 	.word	0x00000a21
   44688:	61647055 	.word	0x61647055
   4468c:	66206574 	.word	0x66206574
   44690:	736c6961 	.word	0x736c6961
   44694:	61747320 	.word	0x61747320
   44698:	20737574 	.word	0x20737574
   4469c:	7830203d 	.word	0x7830203d
   446a0:	000a7825 	.word	0x000a7825
   446a4:	61647055 	.word	0x61647055
   446a8:	44206574 	.word	0x44206574
   446ac:	0d656e6f 	.word	0x0d656e6f
   446b0:	0000000a 	.word	0x0000000a
   446b4:	20707041 	.word	0x20707041
   446b8:	20746f67 	.word	0x20746f67
   446bc:	20747665 	.word	0x20747665
   446c0:	00006425 	.word	0x00006425
   446c4:	61656c43 	.word	0x61656c43
   446c8:	6f622072 	.word	0x6f622072
   446cc:	6e69646e 	.word	0x6e69646e
   446d0:	6e692067 	.word	0x6e692067
   446d4:	00006f66 	.word	0x00006f66
   446d8:	6e616353 	.word	0x6e616353
   446dc:	73657220 	.word	0x73657220
   446e0:	73746c75 	.word	0x73746c75
   446e4:	6425203a 	.word	0x6425203a
   446e8:	00000000 	.word	0x00000000
   446ec:	61766e49 	.word	0x61766e49
   446f0:	2064696c 	.word	0x2064696c
   446f4:	73204d44 	.word	0x73204d44
   446f8:	6e6e6163 	.word	0x6e6e6163
   446fc:	20676e69 	.word	0x20676e69
   44700:	65646f6d 	.word	0x65646f6d
   44704:	6f6d203b 	.word	0x6f6d203b
   44708:	63206564 	.word	0x63206564
   4470c:	69666e6f 	.word	0x69666e6f
   44710:	65727567 	.word	0x65727567
   44714:	73612064 	.word	0x73612064
   44718:	74786520 	.word	0x74786520
   4471c:	65646e65 	.word	0x65646e65
   44720:	00000064 	.word	0x00000064
   44724:	6f6d6572 	.word	0x6f6d6572
   44728:	66206574 	.word	0x66206574
   4472c:	75746165 	.word	0x75746165
   44730:	203a6572 	.word	0x203a6572
   44734:	78257830 	.word	0x78257830
   44738:	4420202c 	.word	0x4420202c
   4473c:	303a454c 	.word	0x303a454c
   44740:	00782578 	.word	0x00782578
   44744:	6f6d6552 	.word	0x6f6d6552
   44748:	64206574 	.word	0x64206574
   4474c:	63697665 	.word	0x63697665
   44750:	75732065 	.word	0x75732065
   44754:	726f7070 	.word	0x726f7070
   44758:	4c442074 	.word	0x4c442074
   4475c:	00000045 	.word	0x00000045
   44760:	6f6d6552 	.word	0x6f6d6552
   44764:	64206574 	.word	0x64206574
   44768:	63697665 	.word	0x63697665
   4476c:	6f642065 	.word	0x6f642065
   44770:	276e7365 	.word	0x276e7365
   44774:	75732074 	.word	0x75732074
   44778:	726f7070 	.word	0x726f7070
   4477c:	4c442074 	.word	0x4c442074
   44780:	00000045 	.word	0x00000045
   44784:	61746164 	.word	0x61746164
   44788:	6e656c20 	.word	0x6e656c20
   4478c:	20687467 	.word	0x20687467
   44790:	68637865 	.word	0x68637865
   44794:	65676e61 	.word	0x65676e61
   44798:	7473202c 	.word	0x7473202c
   4479c:	73757461 	.word	0x73757461
   447a0:	6425203d 	.word	0x6425203d
   447a4:	616d202c 	.word	0x616d202c
   447a8:	4c585278 	.word	0x4c585278
   447ac:	203d6e65 	.word	0x203d6e65
   447b0:	202c6425 	.word	0x202c6425
   447b4:	5478616d 	.word	0x5478616d
   447b8:	6e656c58 	.word	0x6e656c58
   447bc:	6425203d 	.word	0x6425203d
   447c0:	00000000 	.word	0x00000000
   447c4:	61766e49 	.word	0x61766e49
   447c8:	2064696c 	.word	0x2064696c
   447cc:	61204d44 	.word	0x61204d44
   447d0:	72657664 	.word	0x72657664
   447d4:	69736974 	.word	0x69736974
   447d8:	6d20676e 	.word	0x6d20676e
   447dc:	3b65646f 	.word	0x3b65646f
   447e0:	646f6d20 	.word	0x646f6d20
   447e4:	6f632065 	.word	0x6f632065
   447e8:	6769666e 	.word	0x6769666e
   447ec:	64657275 	.word	0x64657275
   447f0:	20736120 	.word	0x20736120
   447f4:	65747865 	.word	0x65747865
   447f8:	6465646e 	.word	0x6465646e
   447fc:	00000000 	.word	0x00000000
   44800:	2055544d 	.word	0x2055544d
   44804:	20716572 	.word	0x20716572
   44808:	63736964 	.word	0x63736964
   4480c:	65647261 	.word	0x65647261
   44810:	00000064 	.word	0x00000064
   44814:	63747461 	.word	0x63747461
   44818:	6b6e7520 	.word	0x6b6e7520
   4481c:	6e776f6e 	.word	0x6e776f6e
   44820:	63706f20 	.word	0x63706f20
   44824:	2065646f 	.word	0x2065646f
   44828:	30257830 	.word	0x30257830
   4482c:	00007832 	.word	0x00007832
   44830:	63747461 	.word	0x63747461
   44834:	62636320 	.word	0x62636320
   44838:	746f6e20 	.word	0x746f6e20
   4483c:	206e6920 	.word	0x206e6920
   44840:	3a657375 	.word	0x3a657375
   44844:	00642520 	.word	0x00642520
   44848:	73747461 	.word	0x73747461
   4484c:	4d636343 	.word	0x4d636343
   44850:	436e6961 	.word	0x436e6961
   44854:	6b636162 	.word	0x6b636162
   44858:	6e6f6320 	.word	0x6e6f6320
   4485c:	3d64496e 	.word	0x3d64496e
   44860:	68206425 	.word	0x68206425
   44864:	6c646e61 	.word	0x6c646e61
   44868:	64253d65 	.word	0x64253d65
   4486c:	00000000 	.word	0x00000000
   44870:	73747441 	.word	0x73747441
   44874:	49636343 	.word	0x49636343
   44878:	5474696e 	.word	0x5474696e
   4487c:	656c6261 	.word	0x656c6261
   44880:	6e6f6320 	.word	0x6e6f6320
   44884:	3d64496e 	.word	0x3d64496e
   44888:	00006425 	.word	0x00006425
   4488c:	73747441 	.word	0x73747441
   44890:	43636343 	.word	0x43636343
   44894:	7261656c 	.word	0x7261656c
   44898:	6c626154 	.word	0x6c626154
   4489c:	6f632065 	.word	0x6f632065
   448a0:	64496e6e 	.word	0x64496e6e
   448a4:	0064253d 	.word	0x0064253d
   448a8:	61746144 	.word	0x61746144
   448ac:	65736162 	.word	0x65736162
   448b0:	73616820 	.word	0x73616820
   448b4:	61632068 	.word	0x61632068
   448b8:	6c75636c 	.word	0x6c75636c
   448bc:	6f697461 	.word	0x6f697461
   448c0:	6f63206e 	.word	0x6f63206e
   448c4:	656c706d 	.word	0x656c706d
   448c8:	00006574 	.word	0x00006574
   448cc:	636c6143 	.word	0x636c6143
   448d0:	74616c75 	.word	0x74616c75
   448d4:	20676e69 	.word	0x20676e69
   448d8:	61746164 	.word	0x61746164
   448dc:	65736162 	.word	0x65736162
   448e0:	73616820 	.word	0x73616820
   448e4:	00000068 	.word	0x00000068
   448e8:	6e6e6f43 	.word	0x6e6e6f43
   448ec:	25206449 	.word	0x25206449
   448f0:	68632064 	.word	0x68632064
   448f4:	65676e61 	.word	0x65676e61
   448f8:	61776120 	.word	0x61776120
   448fc:	73206572 	.word	0x73206572
   44900:	65746174 	.word	0x65746174
   44904:	20736920 	.word	0x20736920
   44908:	00006425 	.word	0x00006425
   4490c:	6e6e6f43 	.word	0x6e6e6f43
   44910:	25206449 	.word	0x25206449
   44914:	756f2064 	.word	0x756f2064
   44918:	666f2074 	.word	0x666f2074
   4491c:	6e797320 	.word	0x6e797320
   44920:	50202c63 	.word	0x50202c63
   44924:	77205544 	.word	0x77205544
   44928:	20687469 	.word	0x20687469
   4492c:	6f63706f 	.word	0x6f63706f
   44930:	30206564 	.word	0x30206564
   44934:	32302578 	.word	0x32302578
   44938:	67692078 	.word	0x67692078
   4493c:	65726f6e 	.word	0x65726f6e
   44940:	00002164 	.word	0x00002164
   44944:	6e6e6f63 	.word	0x6e6e6f63
   44948:	25206449 	.word	0x25206449
   4494c:	70752064 	.word	0x70752064
   44950:	65746164 	.word	0x65746164
   44954:	73632064 	.word	0x73632064
   44958:	6f742066 	.word	0x6f742066
   4495c:	25783020 	.word	0x25783020
   44960:	00783230 	.word	0x00783230
   44964:	73747461 	.word	0x73747461
   44968:	62636320 	.word	0x62636320
   4496c:	746f6e20 	.word	0x746f6e20
   44970:	206e6920 	.word	0x206e6920
   44974:	3a657375 	.word	0x3a657375
   44978:	00642520 	.word	0x00642520
   4497c:	64416d64 	.word	0x64416d64
   44980:	74634176 	.word	0x74634176
   44984:	666e6f43 	.word	0x666e6f43
   44988:	203a6769 	.word	0x203a6769
   4498c:	74617473 	.word	0x74617473
   44990:	25203a65 	.word	0x25203a65
   44994:	00000064 	.word	0x00000064
   44998:	64416d44 	.word	0x64416d44
   4499c:	6e6f4376 	.word	0x6e6f4376
   449a0:	20676966 	.word	0x20676966
   449a4:	69727564 	.word	0x69727564
   449a8:	6420676e 	.word	0x6420676e
   449ac:	63657269 	.word	0x63657269
   449b0:	20646574 	.word	0x20646574
   449b4:	65766461 	.word	0x65766461
   449b8:	73697472 	.word	0x73697472
   449bc:	21676e69 	.word	0x21676e69
   449c0:	00000000 	.word	0x00000000
   449c4:	64416d64 	.word	0x64416d64
   449c8:	74634176 	.word	0x74634176
   449cc:	44746553 	.word	0x44746553
   449d0:	3a617461 	.word	0x3a617461
   449d4:	61747320 	.word	0x61747320
   449d8:	203a6574 	.word	0x203a6574
   449dc:	00006425 	.word	0x00006425
   449e0:	64416d64 	.word	0x64416d64
   449e4:	74634176 	.word	0x74634176
   449e8:	72617453 	.word	0x72617453
   449ec:	73203a74 	.word	0x73203a74
   449f0:	65746174 	.word	0x65746174
   449f4:	6425203a 	.word	0x6425203a
   449f8:	00000000 	.word	0x00000000
   449fc:	64416d64 	.word	0x64416d64
   44a00:	74634176 	.word	0x74634176
   44a04:	72617453 	.word	0x72617453
   44a08:	75642074 	.word	0x75642074
   44a0c:	676e6972 	.word	0x676e6972
   44a10:	72696420 	.word	0x72696420
   44a14:	65746365 	.word	0x65746365
   44a18:	64612064 	.word	0x64612064
   44a1c:	74726576 	.word	0x74726576
   44a20:	6e697369 	.word	0x6e697369
   44a24:	00002167 	.word	0x00002167
   44a28:	64416d64 	.word	0x64416d64
   44a2c:	74634176 	.word	0x74634176
   44a30:	706f7453 	.word	0x706f7453
   44a34:	7473203a 	.word	0x7473203a
   44a38:	3a657461 	.word	0x3a657461
   44a3c:	00642520 	.word	0x00642520
   44a40:	64416d44 	.word	0x64416d44
   44a44:	6f745376 	.word	0x6f745376
   44a48:	75642070 	.word	0x75642070
   44a4c:	676e6972 	.word	0x676e6972
   44a50:	72696420 	.word	0x72696420
   44a54:	65746365 	.word	0x65746365
   44a58:	64612064 	.word	0x64612064
   44a5c:	74726576 	.word	0x74726576
   44a60:	6e697369 	.word	0x6e697369
   44a64:	00002167 	.word	0x00002167
   44a68:	64416d64 	.word	0x64416d64
   44a6c:	74634176 	.word	0x74634176
   44a70:	656d6954 	.word	0x656d6954
   44a74:	2174756f 	.word	0x2174756f
   44a78:	00000000 	.word	0x00000000
   44a7c:	5f494348 	.word	0x5f494348
   44a80:	415f454c 	.word	0x415f454c
   44a84:	455f5644 	.word	0x455f5644
   44a88:	4c42414e 	.word	0x4c42414e
   44a8c:	4d435f45 	.word	0x4d435f45
   44a90:	4d435f44 	.word	0x4d435f44
   44a94:	435f4c50 	.word	0x435f4c50
   44a98:	4b434142 	.word	0x4b434142
   44a9c:	5456455f 	.word	0x5456455f
   44aa0:	7473203a 	.word	0x7473203a
   44aa4:	3a657461 	.word	0x3a657461
   44aa8:	00642520 	.word	0x00642520
   44aac:	64416d64 	.word	0x64416d64
   44ab0:	61745376 	.word	0x61745376
   44ab4:	69447472 	.word	0x69447472
   44ab8:	74636572 	.word	0x74636572
   44abc:	203a6465 	.word	0x203a6465
   44ac0:	74617473 	.word	0x74617473
   44ac4:	25203a65 	.word	0x25203a65
   44ac8:	00000064 	.word	0x00000064
   44acc:	64416d64 	.word	0x64416d64
   44ad0:	6f745376 	.word	0x6f745376
   44ad4:	72694470 	.word	0x72694470
   44ad8:	65746365 	.word	0x65746365
   44adc:	73203a64 	.word	0x73203a64
   44ae0:	65746174 	.word	0x65746174
   44ae4:	6425203a 	.word	0x6425203a
   44ae8:	00000000 	.word	0x00000000
   44aec:	64416d64 	.word	0x64416d64
   44af0:	6e6f4376 	.word	0x6e6f4376
   44af4:	7463656e 	.word	0x7463656e
   44af8:	203a6465 	.word	0x203a6465
   44afc:	74617473 	.word	0x74617473
   44b00:	25203a65 	.word	0x25203a65
   44b04:	00000064 	.word	0x00000064
   44b08:	64416d64 	.word	0x64416d64
   44b0c:	6e6f4376 	.word	0x6e6f4376
   44b10:	7463656e 	.word	0x7463656e
   44b14:	6c696146 	.word	0x6c696146
   44b18:	203a6465 	.word	0x203a6465
   44b1c:	74617473 	.word	0x74617473
   44b20:	25203a65 	.word	0x25203a65
   44b24:	00000064 	.word	0x00000064
   44b28:	6f436d64 	.word	0x6f436d64
   44b2c:	6d436e6e 	.word	0x6d436e6e
   44b30:	74536c70 	.word	0x74536c70
   44b34:	73657461 	.word	0x73657461
   44b38:	00642520 	.word	0x00642520
   44b3c:	6f436d64 	.word	0x6f436d64
   44b40:	63436e6e 	.word	0x63436e6e
   44b44:	6c6c4162 	.word	0x6c6c4162
   44b48:	2520636f 	.word	0x2520636f
   44b4c:	00000064 	.word	0x00000064
   44b50:	6f436d64 	.word	0x6f436d64
   44b54:	63436e6e 	.word	0x63436e6e
   44b58:	6c6c4162 	.word	0x6c6c4162
   44b5c:	6620636f 	.word	0x6620636f
   44b60:	656c6961 	.word	0x656c6961
   44b64:	00000064 	.word	0x00000064
   44b68:	6f436d64 	.word	0x6f436d64
   44b6c:	63436e6e 	.word	0x63436e6e
   44b70:	61654462 	.word	0x61654462
   44b74:	636f6c6c 	.word	0x636f6c6c
   44b78:	00642520 	.word	0x00642520
   44b7c:	6f436d64 	.word	0x6f436d64
   44b80:	63436e6e 	.word	0x63436e6e
   44b84:	48794262 	.word	0x48794262
   44b88:	6c646e61 	.word	0x6c646e61
   44b8c:	6f6e2065 	.word	0x6f6e2065
   44b90:	6f662074 	.word	0x6f662074
   44b94:	20646e75 	.word	0x20646e75
   44b98:	30257830 	.word	0x30257830
   44b9c:	00007834 	.word	0x00007834
   44ba0:	6f436d64 	.word	0x6f436d64
   44ba4:	64496e6e 	.word	0x64496e6e
   44ba8:	64427942 	.word	0x64427942
   44bac:	72646441 	.word	0x72646441
   44bb0:	746f6e20 	.word	0x746f6e20
   44bb4:	756f6620 	.word	0x756f6620
   44bb8:	0000646e 	.word	0x0000646e
   44bbc:	6e6e6f63 	.word	0x6e6e6f63
   44bc0:	253d6449 	.word	0x253d6449
   44bc4:	64692064 	.word	0x64692064
   44bc8:	614d656c 	.word	0x614d656c
   44bcc:	303d6b73 	.word	0x303d6b73
   44bd0:	34302578 	.word	0x34302578
   44bd4:	00000078 	.word	0x00000078
   44bd8:	6f436d64 	.word	0x6f436d64
   44bdc:	6d536e6e 	.word	0x6d536e6e
   44be0:	63657845 	.word	0x63657845
   44be4:	20657475 	.word	0x20657475
   44be8:	6e657665 	.word	0x6e657665
   44bec:	64253d74 	.word	0x64253d74
   44bf0:	61747320 	.word	0x61747320
   44bf4:	253d6574 	.word	0x253d6574
   44bf8:	00000064 	.word	0x00000064
   44bfc:	65446d64 	.word	0x65446d64
   44c00:	73615076 	.word	0x73615076
   44c04:	74764573 	.word	0x74764573
   44c08:	65446f54 	.word	0x65446f54
   44c0c:	69725076 	.word	0x69725076
   44c10:	65203a76 	.word	0x65203a76
   44c14:	746e6576 	.word	0x746e6576
   44c18:	6425203a 	.word	0x6425203a
   44c1c:	6170202c 	.word	0x6170202c
   44c20:	3a6d6172 	.word	0x3a6d6172
   44c24:	2c642520 	.word	0x2c642520
   44c28:	76646120 	.word	0x76646120
   44c2c:	646e6148 	.word	0x646e6148
   44c30:	203a656c 	.word	0x203a656c
   44c34:	00006425 	.word	0x00006425
   44c38:	65686373 	.word	0x65686373
   44c3c:	656c7564 	.word	0x656c7564
   44c40:	71657220 	.word	0x71657220
   44c44:	74736575 	.word	0x74736575
   44c48:	6a657220 	.word	0x6a657220
   44c4c:	65746365 	.word	0x65746365
   44c50:	00000064 	.word	0x00000064
   44c54:	65686373 	.word	0x65686373
   44c58:	656c7564 	.word	0x656c7564
   44c5c:	656c6520 	.word	0x656c6520
   44c60:	746e656d 	.word	0x746e656d
   44c64:	746f6e20 	.word	0x746f6e20
   44c68:	756f6620 	.word	0x756f6620
   44c6c:	0000646e 	.word	0x0000646e
   44c70:	65686373 	.word	0x65686373
   44c74:	656c7564 	.word	0x656c7564
   44c78:	71657220 	.word	0x71657220
   44c7c:	74736575 	.word	0x74736575
   44c80:	6a657220 	.word	0x6a657220
   44c84:	65746365 	.word	0x65746365
   44c88:	75642064 	.word	0x75642064
   44c8c:	6f742065 	.word	0x6f742065
   44c90:	6e616220 	.word	0x6e616220
   44c94:	64697764 	.word	0x64697764
   44c98:	66206874 	.word	0x66206874
   44c9c:	006c6c75 	.word	0x006c6c75
   44ca0:	65686373 	.word	0x65686373
   44ca4:	656c7564 	.word	0x656c7564
   44ca8:	656c6520 	.word	0x656c6520
   44cac:	746e656d 	.word	0x746e656d
   44cb0:	6f687320 	.word	0x6f687320
   44cb4:	20646c75 	.word	0x20646c75
   44cb8:	20746f6e 	.word	0x20746f6e
   44cbc:	70206562 	.word	0x70206562
   44cc0:	72676f72 	.word	0x72676f72
   44cc4:	656d6d61 	.word	0x656d6d61
   44cc8:	53412064 	.word	0x53412064
   44ccc:	00005041 	.word	0x00005041
   44cd0:	65686373 	.word	0x65686373
   44cd4:	656c7564 	.word	0x656c7564
   44cd8:	61657220 	.word	0x61657220
   44cdc:	74206863 	.word	0x74206863
   44ce0:	20656d69 	.word	0x20656d69
   44ce4:	696d696c 	.word	0x696d696c
   44ce8:	00646574 	.word	0x00646574
   44cec:	65686373 	.word	0x65686373
   44cf0:	65756c64 	.word	0x65756c64
   44cf4:	6d6c6520 	.word	0x6d6c6520
   44cf8:	20746e65 	.word	0x20746e65
   44cfc:	666e6f63 	.word	0x666e6f63
   44d00:	7463696c 	.word	0x7463696c
   44d04:	61747320 	.word	0x61747320
   44d08:	64657472 	.word	0x64657472
   44d0c:	00000000 	.word	0x00000000
   44d10:	65686373 	.word	0x65686373
   44d14:	656c7564 	.word	0x656c7564
   44d18:	61657220 	.word	0x61657220
   44d1c:	63206863 	.word	0x63206863
   44d20:	75646568 	.word	0x75646568
   44d24:	676e696c 	.word	0x676e696c
   44d28:	6d697420 	.word	0x6d697420
   44d2c:	696c2065 	.word	0x696c2065
   44d30:	2074696d 	.word	0x2074696d
   44d34:	69727564 	.word	0x69727564
   44d38:	6320676e 	.word	0x6320676e
   44d3c:	6c666e6f 	.word	0x6c666e6f
   44d40:	20746369 	.word	0x20746369
   44d44:	65736163 	.word	0x65736163
   44d48:	00000000 	.word	0x00000000
   44d4c:	65636572 	.word	0x65636572
   44d50:	20657669 	.word	0x20657669
   44d54:	6f727265 	.word	0x6f727265
   44d58:	61702072 	.word	0x61702072
   44d5c:	74656b63 	.word	0x74656b63
   44d60:	63786520 	.word	0x63786520
   44d64:	20646565 	.word	0x20646565
   44d68:	65707573 	.word	0x65707573
   44d6c:	73697672 	.word	0x73697672
   44d70:	206e6f69 	.word	0x206e6f69
   44d74:	656d6974 	.word	0x656d6974
   44d78:	0074756f 	.word	0x0074756f
   44d7c:	646e6977 	.word	0x646e6977
   44d80:	7320776f 	.word	0x7320776f
   44d84:	20657a69 	.word	0x20657a69
   44d88:	65637865 	.word	0x65637865
   44d8c:	68206465 	.word	0x68206465
   44d90:	20666c61 	.word	0x20666c61
   44d94:	6e6e6f63 	.word	0x6e6e6f63
   44d98:	69746365 	.word	0x69746365
   44d9c:	69206e6f 	.word	0x69206e6f
   44da0:	7265746e 	.word	0x7265746e
   44da4:	006c6176 	.word	0x006c6176
   44da8:	20696348 	.word	0x20696348
   44dac:	666e6f63 	.word	0x666e6f63
   44db0:	74206769 	.word	0x74206769
   44db4:	65636172 	.word	0x65636172
   44db8:	6b636120 	.word	0x6b636120
   44dbc:	6962202c 	.word	0x6962202c
   44dc0:	70616d74 	.word	0x70616d74
   44dc4:	2578303a 	.word	0x2578303a
   44dc8:	0a783830 	.word	0x0a783830
   44dcc:	00000000 	.word	0x00000000
   44dd0:	3230255b 	.word	0x3230255b
   44dd4:	30253a64 	.word	0x30253a64
   44dd8:	253a6432 	.word	0x253a6432
   44ddc:	3a643230 	.word	0x3a643230
   44de0:	64333025 	.word	0x64333025
   44de4:	3330252e 	.word	0x3330252e
   44de8:	43205d64 	.word	0x43205d64
   44dec:	6f747375 	.word	0x6f747375
   44df0:	6164206d 	.word	0x6164206d
   44df4:	203a6174 	.word	0x203a6174
   44df8:	30206469 	.word	0x30206469
   44dfc:	2c782578 	.word	0x2c782578
   44e00:	25783020 	.word	0x25783020
   44e04:	0a783830 	.word	0x0a783830
   44e08:	00000000 	.word	0x00000000
   44e0c:	204b3233 	.word	0x204b3233
   44e10:	636f6c63 	.word	0x636f6c63
   44e14:	25203d6b 	.word	0x25203d6b
   44e18:	7a482064 	.word	0x7a482064
   44e1c:	0000000a 	.word	0x0000000a
   44e20:	6b6e694c 	.word	0x6b6e694c
   44e24:	20642520 	.word	0x20642520
   44e28:	6e6e6f63 	.word	0x6e6e6f63
   44e2c:	69746365 	.word	0x69746365
   44e30:	74206e6f 	.word	0x74206e6f
   44e34:	6f656d69 	.word	0x6f656d69
   44e38:	203a7475 	.word	0x203a7475
   44e3c:	0a0d7325 	.word	0x0a0d7325
   44e40:	00000000 	.word	0x00000000
   44e44:	6b6e694c 	.word	0x6b6e694c
   44e48:	20642520 	.word	0x20642520
   44e4c:	5f434c4c 	.word	0x5f434c4c
   44e50:	434f5250 	.word	0x434f5250
   44e54:	5059545f 	.word	0x5059545f
   44e58:	25203a45 	.word	0x25203a45
   44e5c:	4c202c64 	.word	0x4c202c64
   44e60:	505f434c 	.word	0x505f434c
   44e64:	5f434f52 	.word	0x5f434f52
   44e68:	203a4449 	.word	0x203a4449
   44e6c:	202c6425 	.word	0x202c6425
   44e70:	6f727265 	.word	0x6f727265
   44e74:	6f6c5f72 	.word	0x6f6c5f72
   44e78:	25203a67 	.word	0x25203a67
   44e7c:	000a0d64 	.word	0x000a0d64
   44e80:	746e6f43 	.word	0x746e6f43
   44e84:	756f6e69 	.word	0x756f6e69
   44e88:	79732073 	.word	0x79732073
   44e8c:	6520636e 	.word	0x6520636e
   44e90:	726f7272 	.word	0x726f7272
   44e94:	20642520 	.word	0x20642520
   44e98:	656d6974 	.word	0x656d6974
   44e9c:	63202c73 	.word	0x63202c73
   44ea0:	69746e6f 	.word	0x69746e6f
   44ea4:	73756f6e 	.word	0x73756f6e
   44ea8:	63726320 	.word	0x63726320
   44eac:	72726520 	.word	0x72726520
   44eb0:	2520726f 	.word	0x2520726f
   44eb4:	69742064 	.word	0x69742064
   44eb8:	0d73656d 	.word	0x0d73656d
   44ebc:	0000000a 	.word	0x0000000a
   44ec0:	6e6b6e75 	.word	0x6e6b6e75
   44ec4:	7420776f 	.word	0x7420776f
   44ec8:	65636172 	.word	0x65636172
   44ecc:	63617020 	.word	0x63617020
   44ed0:	2074656b 	.word	0x2074656b
   44ed4:	65707974 	.word	0x65707974
   44ed8:	0000000a 	.word	0x0000000a
   44edc:	7272450a 	.word	0x7272450a
   44ee0:	6420726f 	.word	0x6420726f
   44ee4:	63657465 	.word	0x63657465
   44ee8:	3a646574 	.word	0x3a646574
   44eec:	25783020 	.word	0x25783020
   44ef0:	0a783830 	.word	0x0a783830
   44ef4:	00000000 	.word	0x00000000
   44ef8:	5252450a 	.word	0x5252450a
   44efc:	203a524f 	.word	0x203a524f
   44f00:	69797254 	.word	0x69797254
   44f04:	7420676e 	.word	0x7420676e
   44f08:	6573206f 	.word	0x6573206f
   44f0c:	6120646e 	.word	0x6120646e
   44f10:	4348206e 	.word	0x4348206e
   44f14:	61702049 	.word	0x61702049
   44f18:	74656b63 	.word	0x74656b63
   44f1c:	72616c20 	.word	0x72616c20
   44f20:	20726567 	.word	0x20726567
   44f24:	6e616874 	.word	0x6e616874
   44f28:	65687420 	.word	0x65687420
   44f2c:	69636820 	.word	0x69636820
   44f30:	69726420 	.word	0x69726420
   44f34:	20726576 	.word	0x20726576
   44f38:	66667562 	.word	0x66667562
   44f3c:	73207265 	.word	0x73207265
   44f40:	20657a69 	.word	0x20657a69
   44f44:	65656e28 	.word	0x65656e28
   44f48:	25207364 	.word	0x25207364
   44f4c:	79622064 	.word	0x79622064
   44f50:	20736574 	.word	0x20736574
   44f54:	7320666f 	.word	0x7320666f
   44f58:	65636170 	.word	0x65636170
   44f5c:	000a2e29 	.word	0x000a2e29
   44f60:	5252450a 	.word	0x5252450a
   44f64:	203a524f 	.word	0x203a524f
   44f68:	69797254 	.word	0x69797254
   44f6c:	7420676e 	.word	0x7420676e
   44f70:	6572206f 	.word	0x6572206f
   44f74:	76696563 	.word	0x76696563
   44f78:	6e612065 	.word	0x6e612065
   44f7c:	49434820 	.word	0x49434820
   44f80:	63617020 	.word	0x63617020
   44f84:	2074656b 	.word	0x2074656b
   44f88:	6772616c 	.word	0x6772616c
   44f8c:	74207265 	.word	0x74207265
   44f90:	206e6168 	.word	0x206e6168
   44f94:	20656874 	.word	0x20656874
   44f98:	20696368 	.word	0x20696368
   44f9c:	76697264 	.word	0x76697264
   44fa0:	62207265 	.word	0x62207265
   44fa4:	65666675 	.word	0x65666675
   44fa8:	69732072 	.word	0x69732072
   44fac:	2820657a 	.word	0x2820657a
   44fb0:	6465656e 	.word	0x6465656e
   44fb4:	64252073 	.word	0x64252073
   44fb8:	74796220 	.word	0x74796220
   44fbc:	6f207365 	.word	0x6f207365
   44fc0:	70732066 	.word	0x70732066
   44fc4:	29656361 	.word	0x29656361
   44fc8:	00000a2e 	.word	0x00000a2e
   44fcc:	4f525245 	.word	0x4f525245
   44fd0:	48435f52 	.word	0x48435f52
   44fd4:	5f4b4345 	.word	0x5f4b4345
   44fd8:	44494f56 	.word	0x44494f56
   44fdc:	49434820 	.word	0x49434820
   44fe0:	5652445f 	.word	0x5652445f
   44fe4:	5f58525f 	.word	0x5f58525f
   44fe8:	4b434150 	.word	0x4b434150
   44fec:	545f5445 	.word	0x545f5445
   44ff0:	4c5f4f4f 	.word	0x4c5f4f4f
   44ff4:	45475241 	.word	0x45475241
   44ff8:	0000000a 	.word	0x0000000a
   44ffc:	4943480a 	.word	0x4943480a
   45000:	41455220 	.word	0x41455220
   45004:	61662044 	.word	0x61662044
   45008:	64656c69 	.word	0x64656c69
   4500c:	74697720 	.word	0x74697720
   45010:	74732068 	.word	0x74732068
   45014:	73757461 	.word	0x73757461
   45018:	2e642520 	.word	0x2e642520
   4501c:	79725420 	.word	0x79725420
   45020:	63657220 	.word	0x63657220
   45024:	6964726f 	.word	0x6964726f
   45028:	7720676e 	.word	0x7720676e
   4502c:	20687469 	.word	0x20687469
   45030:	6f6c2061 	.word	0x6f6c2061
   45034:	20636967 	.word	0x20636967
   45038:	6c616e61 	.word	0x6c616e61
   4503c:	72657a79 	.word	0x72657a79
   45040:	206f7420 	.word	0x206f7420
   45044:	63746163 	.word	0x63746163
   45048:	68742068 	.word	0x68742068
   4504c:	72652065 	.word	0x72652065
   45050:	2e726f72 	.word	0x2e726f72
   45054:	0000000a 	.word	0x0000000a
   45058:	45696368 	.word	0x45696368
   4505c:	72507476 	.word	0x72507476
   45060:	7365636f 	.word	0x7365636f
   45064:	43654c73 	.word	0x43654c73
   45068:	496e6e6f 	.word	0x496e6e6f
   4506c:	70655251 	.word	0x70655251
   45070:	0074726f 	.word	0x0074726f
   45074:	20766372 	.word	0x20766372
   45078:	4320654c 	.word	0x4320654c
   4507c:	496e6e6f 	.word	0x496e6e6f
   45080:	65522051 	.word	0x65522051
   45084:	74726f70 	.word	0x74726f70
   45088:	002e2e2e 	.word	0x002e2e2e
   4508c:	20766372 	.word	0x20766372
   45090:	4320654c 	.word	0x4320654c
   45094:	746e6e6f 	.word	0x746e6e6f
   45098:	7373656c 	.word	0x7373656c
   4509c:	20514920 	.word	0x20514920
   450a0:	6f706552 	.word	0x6f706552
   450a4:	2e2e7472 	.word	0x2e2e7472
   450a8:	0000002e 	.word	0x0000002e
   450ac:	20657463 	.word	0x20657463
   450b0:	20716572 	.word	0x20716572
   450b4:	6c696166 	.word	0x6c696166
   450b8:	2e2e6465 	.word	0x2e2e6465
   450bc:	00002e2e 	.word	0x00002e2e
   450c0:	64766372 	.word	0x64766372
   450c4:	74616420 	.word	0x74616420
   450c8:	6e6f2061 	.word	0x6e6f2061
   450cc:	65727520 	.word	0x65727520
   450d0:	74736967 	.word	0x74736967
   450d4:	64657265 	.word	0x64657265
   450d8:	64696320 	.word	0x64696320
   450dc:	00000000 	.word	0x00000000
   450e0:	6e6b6e75 	.word	0x6e6b6e75
   450e4:	206e776f 	.word	0x206e776f
   450e8:	3d646963 	.word	0x3d646963
   450ec:	30257830 	.word	0x30257830
   450f0:	00007834 	.word	0x00007834
   450f4:	61766e49 	.word	0x61766e49
   450f8:	2064696c 	.word	0x2064696c
   450fc:	656c6f72 	.word	0x656c6f72
   45100:	6e6f6320 	.word	0x6e6f6320
   45104:	75676966 	.word	0x75676966
   45108:	69746172 	.word	0x69746172
   4510c:	203a6e6f 	.word	0x203a6e6f
   45110:	656c6f72 	.word	0x656c6f72
   45114:	0064253d 	.word	0x0064253d
   45118:	676e656c 	.word	0x676e656c
   4511c:	6d206874 	.word	0x6d206874
   45120:	616d7369 	.word	0x616d7369
   45124:	3a686374 	.word	0x3a686374
   45128:	63326c20 	.word	0x63326c20
   4512c:	2075253d 	.word	0x2075253d
   45130:	3d696368 	.word	0x3d696368
   45134:	00007525 	.word	0x00007525
   45138:	61766e69 	.word	0x61766e69
   4513c:	2064696c 	.word	0x2064696c
   45140:	2067736d 	.word	0x2067736d
   45144:	65646f63 	.word	0x65646f63
   45148:	2064253a 	.word	0x2064253a
   4514c:	3a6e656c 	.word	0x3a6e656c
   45150:	6c206425 	.word	0x6c206425
   45154:	654c6332 	.word	0x654c6332
   45158:	64253a6e 	.word	0x64253a6e
   4515c:	00000000 	.word	0x00000000
   45160:	6e6e6f63 	.word	0x6e6e6f63
   45164:	64707520 	.word	0x64707520
   45168:	20657461 	.word	0x20657461
   4516c:	20716572 	.word	0x20716572
   45170:	656d6974 	.word	0x656d6974
   45174:	0074756f 	.word	0x0074756f
   45178:	61766e69 	.word	0x61766e69
   4517c:	2064696c 	.word	0x2064696c
   45180:	2067736d 	.word	0x2067736d
   45184:	65646f63 	.word	0x65646f63
   45188:	2064253a 	.word	0x2064253a
   4518c:	3a6e656c 	.word	0x3a6e656c
   45190:	6c206425 	.word	0x6c206425
   45194:	654c6332 	.word	0x654c6332
   45198:	64253a6e 	.word	0x64253a6e
   4519c:	00000000 	.word	0x00000000
   451a0:	454c4449 	.word	0x454c4449
   451a4:	00000000 	.word	0x00000000
   451a8:	20726d54 	.word	0x20726d54
   451ac:	00637653 	.word	0x00637653
   451b0:	42667357 	.word	0x42667357
   451b4:	6c416675 	.word	0x6c416675
   451b8:	20636f6c 	.word	0x20636f6c
   451bc:	6c696166 	.word	0x6c696166
   451c0:	6c206465 	.word	0x6c206465
   451c4:	253a6e65 	.word	0x253a6e65
   451c8:	00000075 	.word	0x00000075
   451cc:	20465357 	.word	0x20465357
   451d0:	656d6954 	.word	0x656d6954
   451d4:	00000072 	.word	0x00000072
   451d8:	58323025 	.word	0x58323025
   451dc:	00000020 	.word	0x00000020
   451e0:	0000000a 	.word	0x0000000a
   451e4:	00000a0a 	.word	0x00000a0a
   451e8:	412f2e2e 	.word	0x412f2e2e
   451ec:	7169626d 	.word	0x7169626d
   451f0:	2f4b4453 	.word	0x2f4b4453
   451f4:	64726f63 	.word	0x64726f63
   451f8:	772f6f69 	.word	0x772f6f69
   451fc:	732f6673 	.word	0x732f6673
   45200:	6372756f 	.word	0x6372756f
   45204:	702f7365 	.word	0x702f7365
   45208:	2f74726f 	.word	0x2f74726f
   4520c:	65657266 	.word	0x65657266
   45210:	736f7472 	.word	0x736f7472
   45214:	6673772f 	.word	0x6673772f
   45218:	6172745f 	.word	0x6172745f
   4521c:	632e6563 	.word	0x632e6563
   45220:	00000000 	.word	0x00000000
   45224:	54746f54 	.word	0x54746f54
   45228:	42206761 	.word	0x42206761
   4522c:	203a454c 	.word	0x203a454c
   45230:	69766564 	.word	0x69766564
   45234:	614d6563 	.word	0x614d6563
   45238:	6567616e 	.word	0x6567616e
   4523c:	6c614372 	.word	0x6c614372
   45240:	6361626c 	.word	0x6361626c
   45244:	52203a6b 	.word	0x52203a6b
   45248:	69656365 	.word	0x69656365
   4524c:	20646576 	.word	0x20646576
   45250:	525f4d44 	.word	0x525f4d44
   45254:	54455345 	.word	0x54455345
   45258:	504d435f 	.word	0x504d435f
   4525c:	4e495f4c 	.word	0x4e495f4c
   45260:	00000a44 	.word	0x00000a44
   45264:	54746f54 	.word	0x54746f54
   45268:	42206761 	.word	0x42206761
   4526c:	203a454c 	.word	0x203a454c
   45270:	69766564 	.word	0x69766564
   45274:	614d6563 	.word	0x614d6563
   45278:	6567616e 	.word	0x6567616e
   4527c:	6c614372 	.word	0x6c614372
   45280:	6361626c 	.word	0x6361626c
   45284:	52203a6b 	.word	0x52203a6b
   45288:	69656365 	.word	0x69656365
   4528c:	20646576 	.word	0x20646576
   45290:	435f4d44 	.word	0x435f4d44
   45294:	5f4e4e4f 	.word	0x5f4e4e4f
   45298:	4e45504f 	.word	0x4e45504f
   4529c:	444e495f 	.word	0x444e495f
   452a0:	0000000a 	.word	0x0000000a
   452a4:	54746f54 	.word	0x54746f54
   452a8:	42206761 	.word	0x42206761
   452ac:	203a454c 	.word	0x203a454c
   452b0:	69766564 	.word	0x69766564
   452b4:	614d6563 	.word	0x614d6563
   452b8:	6567616e 	.word	0x6567616e
   452bc:	6c614372 	.word	0x6c614372
   452c0:	6361626c 	.word	0x6361626c
   452c4:	52203a6b 	.word	0x52203a6b
   452c8:	69656365 	.word	0x69656365
   452cc:	20646576 	.word	0x20646576
   452d0:	435f4d44 	.word	0x435f4d44
   452d4:	5f4e4e4f 	.word	0x5f4e4e4f
   452d8:	534f4c43 	.word	0x534f4c43
   452dc:	4e495f45 	.word	0x4e495f45
   452e0:	00000a44 	.word	0x00000a44
   452e4:	54746f54 	.word	0x54746f54
   452e8:	42206761 	.word	0x42206761
   452ec:	203a454c 	.word	0x203a454c
   452f0:	69766564 	.word	0x69766564
   452f4:	614d6563 	.word	0x614d6563
   452f8:	6567616e 	.word	0x6567616e
   452fc:	6c614372 	.word	0x6c614372
   45300:	6361626c 	.word	0x6361626c
   45304:	52203a6b 	.word	0x52203a6b
   45308:	69656365 	.word	0x69656365
   4530c:	20646576 	.word	0x20646576
   45310:	415f4d44 	.word	0x415f4d44
   45314:	535f5644 	.word	0x535f5644
   45318:	54524154 	.word	0x54524154
   4531c:	444e495f 	.word	0x444e495f
   45320:	0000000a 	.word	0x0000000a
   45324:	54746f54 	.word	0x54746f54
   45328:	42206761 	.word	0x42206761
   4532c:	203a454c 	.word	0x203a454c
   45330:	69766564 	.word	0x69766564
   45334:	614d6563 	.word	0x614d6563
   45338:	6567616e 	.word	0x6567616e
   4533c:	6c614372 	.word	0x6c614372
   45340:	6361626c 	.word	0x6361626c
   45344:	52203a6b 	.word	0x52203a6b
   45348:	69656365 	.word	0x69656365
   4534c:	20646576 	.word	0x20646576
   45350:	415f4d44 	.word	0x415f4d44
   45354:	535f5644 	.word	0x535f5644
   45358:	5f504f54 	.word	0x5f504f54
   4535c:	0a444e49 	.word	0x0a444e49
   45360:	00000000 	.word	0x00000000
   45364:	54746f54 	.word	0x54746f54
   45368:	42206761 	.word	0x42206761
   4536c:	203a454c 	.word	0x203a454c
   45370:	69766564 	.word	0x69766564
   45374:	614d6563 	.word	0x614d6563
   45378:	6567616e 	.word	0x6567616e
   4537c:	6c614372 	.word	0x6c614372
   45380:	6361626c 	.word	0x6361626c
   45384:	52203a6b 	.word	0x52203a6b
   45388:	69656365 	.word	0x69656365
   4538c:	20646576 	.word	0x20646576
   45390:	535f4d44 	.word	0x535f4d44
   45394:	5f4e4143 	.word	0x5f4e4143
   45398:	52415453 	.word	0x52415453
   4539c:	4e495f54 	.word	0x4e495f54
   453a0:	00000a44 	.word	0x00000a44
   453a4:	54746f54 	.word	0x54746f54
   453a8:	42206761 	.word	0x42206761
   453ac:	203a454c 	.word	0x203a454c
   453b0:	69766564 	.word	0x69766564
   453b4:	614d6563 	.word	0x614d6563
   453b8:	6567616e 	.word	0x6567616e
   453bc:	6c614372 	.word	0x6c614372
   453c0:	6361626c 	.word	0x6361626c
   453c4:	52203a6b 	.word	0x52203a6b
   453c8:	69656365 	.word	0x69656365
   453cc:	20646576 	.word	0x20646576
   453d0:	535f4d44 	.word	0x535f4d44
   453d4:	5f4e4143 	.word	0x5f4e4143
   453d8:	504f5453 	.word	0x504f5453
   453dc:	444e495f 	.word	0x444e495f
   453e0:	0000000a 	.word	0x0000000a
   453e4:	54746f54 	.word	0x54746f54
   453e8:	42206761 	.word	0x42206761
   453ec:	203a454c 	.word	0x203a454c
   453f0:	6e756f46 	.word	0x6e756f46
   453f4:	6f542064 	.word	0x6f542064
   453f8:	67615474 	.word	0x67615474
   453fc:	3025203a 	.word	0x3025203a
   45400:	253a7832 	.word	0x253a7832
   45404:	3a783230 	.word	0x3a783230
   45408:	78323025 	.word	0x78323025
   4540c:	3230253a 	.word	0x3230253a
   45410:	30253a78 	.word	0x30253a78
   45414:	253a7832 	.word	0x253a7832
   45418:	20783230 	.word	0x20783230
   4541c:	69737372 	.word	0x69737372
   45420:	6425203a 	.word	0x6425203a
   45424:	0000000a 	.word	0x0000000a
   45428:	54746f54 	.word	0x54746f54
   4542c:	42206761 	.word	0x42206761
   45430:	203a454c 	.word	0x203a454c
   45434:	69766564 	.word	0x69766564
   45438:	614d6563 	.word	0x614d6563
   4543c:	6567616e 	.word	0x6567616e
   45440:	6c614372 	.word	0x6c614372
   45444:	6361626c 	.word	0x6361626c
   45448:	4e203a6b 	.word	0x4e203a6b
   4544c:	746f6765 	.word	0x746f6765
   45450:	65746169 	.word	0x65746169
   45454:	48502064 	.word	0x48502064
   45458:	52203a59 	.word	0x52203a59
   4545c:	203d2058 	.word	0x203d2058
   45460:	202c6425 	.word	0x202c6425
   45464:	3d205854 	.word	0x3d205854
   45468:	0a642520 	.word	0x0a642520
   4546c:	00000000 	.word	0x00000000
   45470:	54746f54 	.word	0x54746f54
   45474:	42206761 	.word	0x42206761
   45478:	203a454c 	.word	0x203a454c
   4547c:	69766564 	.word	0x69766564
   45480:	614d6563 	.word	0x614d6563
   45484:	6567616e 	.word	0x6567616e
   45488:	6c614372 	.word	0x6c614372
   4548c:	6361626c 	.word	0x6361626c
   45490:	52203a6b 	.word	0x52203a6b
   45494:	69656365 	.word	0x69656365
   45498:	20646576 	.word	0x20646576
   4549c:	6e657645 	.word	0x6e657645
   454a0:	44492074 	.word	0x44492074
   454a4:	0a642520 	.word	0x0a642520
   454a8:	00000000 	.word	0x00000000
   454ac:	54746f54 	.word	0x54746f54
   454b0:	42206761 	.word	0x42206761
   454b4:	203a454c 	.word	0x203a454c
   454b8:	50747461 	.word	0x50747461
   454bc:	6f746f72 	.word	0x6f746f72
   454c0:	436c6f63 	.word	0x436c6f63
   454c4:	626c6c61 	.word	0x626c6c61
   454c8:	3a6b6361 	.word	0x3a6b6361
   454cc:	67654e20 	.word	0x67654e20
   454d0:	6169746f 	.word	0x6169746f
   454d4:	20646574 	.word	0x20646574
   454d8:	2055544d 	.word	0x2055544d
   454dc:	7525203d 	.word	0x7525203d
   454e0:	0000000a 	.word	0x0000000a
   454e4:	54746f54 	.word	0x54746f54
   454e8:	42206761 	.word	0x42206761
   454ec:	203a454c 	.word	0x203a454c
   454f0:	50747461 	.word	0x50747461
   454f4:	6f746f72 	.word	0x6f746f72
   454f8:	436c6f63 	.word	0x436c6f63
   454fc:	626c6c61 	.word	0x626c6c61
   45500:	3a6b6361 	.word	0x3a6b6361
   45504:	74614420 	.word	0x74614420
   45508:	72572061 	.word	0x72572061
   4550c:	20657469 	.word	0x20657469
   45510:	706d6f43 	.word	0x706d6f43
   45514:	6574656c 	.word	0x6574656c
   45518:	203d2064 	.word	0x203d2064
   4551c:	000a7525 	.word	0x000a7525
   45520:	54746f54 	.word	0x54746f54
   45524:	42206761 	.word	0x42206761
   45528:	203a454c 	.word	0x203a454c
   4552c:	50747461 	.word	0x50747461
   45530:	6f746f72 	.word	0x6f746f72
   45534:	436c6f63 	.word	0x436c6f63
   45538:	626c6c61 	.word	0x626c6c61
   4553c:	3a6b6361 	.word	0x3a6b6361
   45540:	74614420 	.word	0x74614420
   45544:	6f4e2061 	.word	0x6f4e2061
   45548:	79666974 	.word	0x79666974
   4554c:	6d6f4320 	.word	0x6d6f4320
   45550:	74656c70 	.word	0x74656c70
   45554:	3d206465 	.word	0x3d206465
   45558:	0a752520 	.word	0x0a752520
   4555c:	00000000 	.word	0x00000000
   45560:	54746f54 	.word	0x54746f54
   45564:	42206761 	.word	0x42206761
   45568:	203a454c 	.word	0x203a454c
   4556c:	50747461 	.word	0x50747461
   45570:	6f746f72 	.word	0x6f746f72
   45574:	436c6f63 	.word	0x436c6f63
   45578:	626c6c61 	.word	0x626c6c61
   4557c:	3a6b6361 	.word	0x3a6b6361
   45580:	63655220 	.word	0x63655220
   45584:	65766965 	.word	0x65766965
   45588:	76452064 	.word	0x76452064
   4558c:	20746e65 	.word	0x20746e65
   45590:	25204449 	.word	0x25204449
   45594:	00000a64 	.word	0x00000a64
   45598:	54746f54 	.word	0x54746f54
   4559c:	42206761 	.word	0x42206761
   455a0:	203a454c 	.word	0x203a454c
   455a4:	43636363 	.word	0x43636363
   455a8:	626c6c61 	.word	0x626c6c61
   455ac:	3a6b6361 	.word	0x3a6b6361
   455b0:	646e6920 	.word	0x646e6920
   455b4:	3d207865 	.word	0x3d207865
   455b8:	2c642520 	.word	0x2c642520
   455bc:	6e616820 	.word	0x6e616820
   455c0:	20656c64 	.word	0x20656c64
   455c4:	6425203d 	.word	0x6425203d
   455c8:	6176202c 	.word	0x6176202c
   455cc:	2065756c 	.word	0x2065756c
   455d0:	6425203d 	.word	0x6425203d
   455d4:	0000000a 	.word	0x0000000a
   455d8:	732f2e2e 	.word	0x732f2e2e
   455dc:	702f6372 	.word	0x702f6372
   455e0:	70697265 	.word	0x70697265
   455e4:	61726568 	.word	0x61726568
   455e8:	732f736c 	.word	0x732f736c
   455ec:	622f6372 	.word	0x622f6372
   455f0:	7465756c 	.word	0x7465756c
   455f4:	68746f6f 	.word	0x68746f6f
   455f8:	0000632e 	.word	0x0000632e
   455fc:	2d2d2d0a 	.word	0x2d2d2d0a
   45600:	2d2d2d2d 	.word	0x2d2d2d2d
   45604:	2d2d2d2d 	.word	0x2d2d2d2d
   45608:	2d2d2d2d 	.word	0x2d2d2d2d
   4560c:	2d2d2d2d 	.word	0x2d2d2d2d
   45610:	2d2d2d2d 	.word	0x2d2d2d2d
   45614:	2d2d2d2d 	.word	0x2d2d2d2d
   45618:	2d2d2d2d 	.word	0x2d2d2d2d
   4561c:	2d2d2d2d 	.word	0x2d2d2d2d
   45620:	2d2d2d2d 	.word	0x2d2d2d2d
   45624:	00000a2d 	.word	0x00000a2d
   45628:	65736552 	.word	0x65736552
   4562c:	65522074 	.word	0x65522074
   45630:	6e6f7361 	.word	0x6e6f7361
   45634:	00203a73 	.word	0x00203a73
   45638:	65747845 	.word	0x65747845
   4563c:	6c616e72 	.word	0x6c616e72
   45640:	73655220 	.word	0x73655220
   45644:	202c7465 	.word	0x202c7465
   45648:	00000000 	.word	0x00000000
   4564c:	50205748 	.word	0x50205748
   45650:	7265776f 	.word	0x7265776f
   45654:	206e4f2d 	.word	0x206e4f2d
   45658:	65736552 	.word	0x65736552
   4565c:	00202c74 	.word	0x00202c74
   45660:	776f7242 	.word	0x776f7242
   45664:	754f2d6e 	.word	0x754f2d6e
   45668:	65522074 	.word	0x65522074
   4566c:	2c746573 	.word	0x2c746573
   45670:	00000020 	.word	0x00000020
   45674:	50205753 	.word	0x50205753
   45678:	7265776f 	.word	0x7265776f
   4567c:	206e4f2d 	.word	0x206e4f2d
   45680:	65736552 	.word	0x65736552
   45684:	00202c74 	.word	0x00202c74
   45688:	50205753 	.word	0x50205753
   4568c:	7265776f 	.word	0x7265776f
   45690:	206e4f2d 	.word	0x206e4f2d
   45694:	74696e49 	.word	0x74696e49
   45698:	696c6169 	.word	0x696c6169
   4569c:	6974617a 	.word	0x6974617a
   456a0:	202c6e6f 	.word	0x202c6e6f
   456a4:	00000000 	.word	0x00000000
   456a8:	75626544 	.word	0x75626544
   456ac:	72656767 	.word	0x72656767
   456b0:	73655220 	.word	0x73655220
   456b4:	202c7465 	.word	0x202c7465
   456b8:	00000000 	.word	0x00000000
   456bc:	63746157 	.word	0x63746157
   456c0:	6f442068 	.word	0x6f442068
   456c4:	69542067 	.word	0x69542067
   456c8:	2072656d 	.word	0x2072656d
   456cc:	65736552 	.word	0x65736552
   456d0:	00202c74 	.word	0x00202c74
   456d4:	65726e55 	.word	0x65726e55
   456d8:	616c7567 	.word	0x616c7567
   456dc:	20646574 	.word	0x20646574
   456e0:	70707553 	.word	0x70707553
   456e4:	4220796c 	.word	0x4220796c
   456e8:	6e776f72 	.word	0x6e776f72
   456ec:	2c74756f 	.word	0x2c74756f
   456f0:	00000020 	.word	0x00000020
   456f4:	65726f43 	.word	0x65726f43
   456f8:	67655220 	.word	0x67655220
   456fc:	74616c75 	.word	0x74616c75
   45700:	4220726f 	.word	0x4220726f
   45704:	6e776f72 	.word	0x6e776f72
   45708:	2c74756f 	.word	0x2c74756f
   4570c:	00000020 	.word	0x00000020
   45710:	6f6d654d 	.word	0x6f6d654d
   45714:	52207972 	.word	0x52207972
   45718:	6c756765 	.word	0x6c756765
   4571c:	726f7461 	.word	0x726f7461
   45720:	6f724220 	.word	0x6f724220
   45724:	756f6e77 	.word	0x756f6e77
   45728:	00202c74 	.word	0x00202c74
   4572c:	68676948 	.word	0x68676948
   45730:	776f502d 	.word	0x776f502d
   45734:	4d207265 	.word	0x4d207265
   45738:	726f6d65 	.word	0x726f6d65
   4573c:	65522079 	.word	0x65522079
   45740:	616c7567 	.word	0x616c7567
   45744:	20726f74 	.word	0x20726f74
   45748:	776f7242 	.word	0x776f7242
   4574c:	74756f6e 	.word	0x74756f6e
   45750:	0000202c 	.word	0x0000202c
   45754:	2d776f4c 	.word	0x2d776f4c
   45758:	65776f50 	.word	0x65776f50
   4575c:	6f432072 	.word	0x6f432072
   45760:	52206572 	.word	0x52206572
   45764:	6c756765 	.word	0x6c756765
   45768:	726f7461 	.word	0x726f7461
   4576c:	6f724220 	.word	0x6f724220
   45770:	756f6e77 	.word	0x756f6e77
   45774:	00202c74 	.word	0x00202c74
   45778:	0000000a 	.word	0x0000000a
   4577c:	72207525 	.word	0x72207525
   45780:	65676e61 	.word	0x65676e61
   45784:	20402073 	.word	0x20402073
   45788:	656d6954 	.word	0x656d6954
   4578c:	6d617473 	.word	0x6d617473
   45790:	75252070 	.word	0x75252070
   45794:	00000a3a 	.word	0x00000a3a
   45798:	52202020 	.word	0x52202020
   4579c:	65676e61 	.word	0x65676e61
   457a0:	206f7420 	.word	0x206f7420
   457a4:	30257830 	.word	0x30257830
   457a8:	203a5832 	.word	0x203a5832
   457ac:	000a6425 	.word	0x000a6425
   457b0:	0021baef 	.word	0x0021baef
   457b4:	732f2e2e 	.word	0x732f2e2e
   457b8:	702f6372 	.word	0x702f6372
   457bc:	70697265 	.word	0x70697265
   457c0:	61726568 	.word	0x61726568
   457c4:	732f736c 	.word	0x732f736c
   457c8:	732f6372 	.word	0x732f6372
   457cc:	61726f74 	.word	0x61726f74
   457d0:	632e6567 	.word	0x632e6567
   457d4:	00000000 	.word	0x00000000
   457d8:	4154454d 	.word	0x4154454d
   457dc:	00000000 	.word	0x00000000
   457e0:	00004144 	.word	0x00004144
   457e4:	732f2e2e 	.word	0x732f2e2e
   457e8:	702f6372 	.word	0x702f6372
   457ec:	70697265 	.word	0x70697265
   457f0:	61726568 	.word	0x61726568
   457f4:	732f736c 	.word	0x732f736c
   457f8:	732f6372 	.word	0x732f6372
   457fc:	65747379 	.word	0x65747379
   45800:	00632e6d 	.word	0x00632e6d
   45804:	07070002 	.word	0x07070002
   45808:	00000001 	.word	0x00000001
   4580c:	00000104 	.word	0x00000104
   45810:	4e524157 	.word	0x4e524157
   45814:	3a474e49 	.word	0x3a474e49
   45818:	776f5020 	.word	0x776f5020
   4581c:	6e697265 	.word	0x6e697265
   45820:	666f2067 	.word	0x666f2067
   45824:	2e2e2e66 	.word	0x2e2e2e66
   45828:	0000000a 	.word	0x0000000a
   4582c:	4f525245 	.word	0x4f525245
   45830:	4d203a52 	.word	0x4d203a52
   45834:	726f6d65 	.word	0x726f6d65
   45838:	6f702079 	.word	0x6f702079
   4583c:	69206c6f 	.word	0x69206c6f
   45840:	6f742073 	.word	0x6f742073
   45844:	6d73206f 	.word	0x6d73206f
   45848:	206c6c61 	.word	0x206c6c61
   4584c:	25207962 	.word	0x25207962
   45850:	00000a64 	.word	0x00000a64
   45854:	54746f54 	.word	0x54746f54
   45858:	42206761 	.word	0x42206761
   4585c:	203a454c 	.word	0x203a454c
   45860:	6576694c 	.word	0x6576694c
   45864:	61745320 	.word	0x61745320
   45868:	52207374 	.word	0x52207374
   4586c:	3a646165 	.word	0x3a646165
   45870:	6e6f6320 	.word	0x6e6f6320
   45874:	2044496e 	.word	0x2044496e
   45878:	6425203d 	.word	0x6425203d
   4587c:	6168202c 	.word	0x6168202c
   45880:	656c646e 	.word	0x656c646e
   45884:	25203d20 	.word	0x25203d20
   45888:	6f202c64 	.word	0x6f202c64
   4588c:	61726570 	.word	0x61726570
   45890:	6e6f6974 	.word	0x6e6f6974
   45894:	25203d20 	.word	0x25203d20
   45898:	00000a64 	.word	0x00000a64
   4589c:	54746f54 	.word	0x54746f54
   458a0:	42206761 	.word	0x42206761
   458a4:	203a454c 	.word	0x203a454c
   458a8:	6576694c 	.word	0x6576694c
   458ac:	61745320 	.word	0x61745320
   458b0:	57207374 	.word	0x57207374
   458b4:	65746972 	.word	0x65746972
   458b8:	6f63203a 	.word	0x6f63203a
   458bc:	44496e6e 	.word	0x44496e6e
   458c0:	25203d20 	.word	0x25203d20
   458c4:	61682064 	.word	0x61682064
   458c8:	656c646e 	.word	0x656c646e
   458cc:	25203d20 	.word	0x25203d20
   458d0:	76202c64 	.word	0x76202c64
   458d4:	65756c61 	.word	0x65756c61
   458d8:	25203d20 	.word	0x25203d20
   458dc:	00000a64 	.word	0x00000a64
   458e0:	54746f54 	.word	0x54746f54
   458e4:	42206761 	.word	0x42206761
   458e8:	203a454c 	.word	0x203a454c
   458ec:	69766544 	.word	0x69766544
   458f0:	4d206563 	.word	0x4d206563
   458f4:	746e6961 	.word	0x746e6961
   458f8:	6e616e65 	.word	0x6e616e65
   458fc:	52206563 	.word	0x52206563
   45900:	3a646165 	.word	0x3a646165
   45904:	6e6f6320 	.word	0x6e6f6320
   45908:	2044496e 	.word	0x2044496e
   4590c:	6425203d 	.word	0x6425203d
   45910:	6168202c 	.word	0x6168202c
   45914:	656c646e 	.word	0x656c646e
   45918:	25203d20 	.word	0x25203d20
   4591c:	6f202c64 	.word	0x6f202c64
   45920:	61726570 	.word	0x61726570
   45924:	6e6f6974 	.word	0x6e6f6974
   45928:	25203d20 	.word	0x25203d20
   4592c:	00000a64 	.word	0x00000a64
   45930:	54746f54 	.word	0x54746f54
   45934:	42206761 	.word	0x42206761
   45938:	203a454c 	.word	0x203a454c
   4593c:	69766544 	.word	0x69766544
   45940:	4d206563 	.word	0x4d206563
   45944:	746e6961 	.word	0x746e6961
   45948:	6e616e65 	.word	0x6e616e65
   4594c:	57206563 	.word	0x57206563
   45950:	65746972 	.word	0x65746972
   45954:	6f63203a 	.word	0x6f63203a
   45958:	44496e6e 	.word	0x44496e6e
   4595c:	25203d20 	.word	0x25203d20
   45960:	61682064 	.word	0x61682064
   45964:	656c646e 	.word	0x656c646e
   45968:	25203d20 	.word	0x25203d20
   4596c:	76202c64 	.word	0x76202c64
   45970:	65756c61 	.word	0x65756c61
   45974:	25203d20 	.word	0x25203d20
   45978:	00000a64 	.word	0x00000a64
   4597c:	54746f54 	.word	0x54746f54
   45980:	42206761 	.word	0x42206761
   45984:	203a454c 	.word	0x203a454c
   45988:	65686353 	.word	0x65686353
   4598c:	696c7564 	.word	0x696c7564
   45990:	5220676e 	.word	0x5220676e
   45994:	3a646165 	.word	0x3a646165
   45998:	6e6f6320 	.word	0x6e6f6320
   4599c:	2044496e 	.word	0x2044496e
   459a0:	6425203d 	.word	0x6425203d
   459a4:	6168202c 	.word	0x6168202c
   459a8:	656c646e 	.word	0x656c646e
   459ac:	25203d20 	.word	0x25203d20
   459b0:	6f202c64 	.word	0x6f202c64
   459b4:	61726570 	.word	0x61726570
   459b8:	6e6f6974 	.word	0x6e6f6974
   459bc:	25203d20 	.word	0x25203d20
   459c0:	00000a64 	.word	0x00000a64
   459c4:	54746f54 	.word	0x54746f54
   459c8:	42206761 	.word	0x42206761
   459cc:	203a454c 	.word	0x203a454c
   459d0:	65686353 	.word	0x65686353
   459d4:	696c7564 	.word	0x696c7564
   459d8:	5720676e 	.word	0x5720676e
   459dc:	65746972 	.word	0x65746972
   459e0:	6f63203a 	.word	0x6f63203a
   459e4:	44496e6e 	.word	0x44496e6e
   459e8:	25203d20 	.word	0x25203d20
   459ec:	61682064 	.word	0x61682064
   459f0:	656c646e 	.word	0x656c646e
   459f4:	25203d20 	.word	0x25203d20
   459f8:	76202c64 	.word	0x76202c64
   459fc:	65756c61 	.word	0x65756c61
   45a00:	25203d20 	.word	0x25203d20
   45a04:	00000a64 	.word	0x00000a64
   45a08:	61656c70 	.word	0x61656c70
   45a0c:	70206573 	.word	0x70206573
   45a10:	746e6972 	.word	0x746e6972
   45a14:	69687420 	.word	0x69687420
   45a18:	00002173 	.word	0x00002173
   45a1c:	54454c42 	.word	0x54454c42
   45a20:	006b7361 	.word	0x006b7361
   45a24:	65702f2e 	.word	0x65702f2e
   45a28:	68706972 	.word	0x68706972
   45a2c:	6c617265 	.word	0x6c617265
   45a30:	65742f73 	.word	0x65742f73
   45a34:	625f7473 	.word	0x625f7473
   45a38:	7465756c 	.word	0x7465756c
   45a3c:	68746f6f 	.word	0x68746f6f
   45a40:	0000632e 	.word	0x0000632e

00045a44 <ui32MCUAllowed>:
	...

00045a58 <ui32DSP0Allowed>:
	...

00045a6c <ui32DSP1Allowed>:
	...

00045a80 <ui32SharedAccess>:
	...

00045a94 <sGlobalAccess>:
   45a94:	00045a80 00045a44 00045a58 00045a6c     .Z..DZ..XZ..lZ..
   45aa4:	10060004 10060018 1006002c              ........,...

00045ab0 <appReqActCfg>:
   45ab0:	00000000                                ....

00045ab4 <attFcnDefault>:
   45ab4:	0001d883 0001d859 0001d859 0001d86d     ....Y...Y...m...

00045ac4 <attPrimSvcUuid>:
   45ac4:	00002800                                .(..

00045ac8 <attChUuid>:
   45ac8:	00002803                                .(..

00045acc <attChUserDescUuid>:
   45acc:	00002901                                .)..

00045ad0 <attCliChCfgUuid>:
   45ad0:	00002902                                .)..

00045ad4 <attDnChUuid>:
   45ad4:	00002a00                                .*..

00045ad8 <attApChUuid>:
   45ad8:	00002a01                                .*..

00045adc <attScChUuid>:
   45adc:	00002a05                                .*..

00045ae0 <attSidChUuid>:
   45ae0:	00002a23                                #*..

00045ae4 <attMnsChUuid>:
   45ae4:	00002a24                                $*..

00045ae8 <attFrsChUuid>:
   45ae8:	00002a26                                &*..

00045aec <attHrsChUuid>:
   45aec:	00002a27                                '*..

00045af0 <attMfnsChUuid>:
   45af0:	00002a29                                )*..

00045af4 <attCarChUuid>:
   45af4:	00002aa6                                .*..

00045af8 <attGattCsfChUuid>:
   45af8:	00002b29                                )+..

00045afc <attGattDbhChUuid>:
   45afc:	00002b2a                                *+..

00045b00 <attcFcnIf>:
   45b00:	0001df9d 0001e015 0001e169 0001e055     ........i...U...

00045b10 <attcSendReqTbl>:
   45b10:	00000000 0001dd99 0001dc91 0001dc91     ................
   45b20:	0001dc91 0001dc39 0001dc91 0001dc39     ....9.......9...
   45b30:	0001dc91 0001dc39 0001dded 0001de31     ....9.......1...
   45b40:	0001dc39                                9...

00045b44 <attcProcRspTbl>:
   45b44:	0001e455 0001e4ed 0001e561 0001eb75     U.......a...u...
   45b54:	0001e561 0001e6d5 0001ec6b 0001e6d5     a.......k.......
   45b64:	0001e561 0001e6f1 00000000 0001ecb3     a...............
   45b74:	0001e6f1                                ....

00045b78 <attcMinPduLen>:
   45b78:	01020305 01010102 05030102 00000001     ................

00045b88 <attsIndFcnIf>:
   45b88:	0001d883 0001f6fd 0001f635 0001f5bd     ........5.......

00045b98 <attsFcnIf>:
   45b98:	0001f9b1 0001fb99 0001fb35 0001fae5     ........5.......

00045ba8 <attsMinPduLen>:
   45ba8:	07050300 05050305 05030305 01000002     ................
   45bb8:	0000000f                                ....

00045bbc <calc128Zeros>:
	...

00045bcc <attCfg>:
   45bcc:	0000000f 041e01e0                       ........

00045bd4 <dmAdvAct>:
   45bd4:	000221dd 00022235 0002228d 000222e9     .!..5"..."..."..
   45be4:	0002233d 00022351 00022365 00022379     =#..Q#..e#..y#..

00045bf4 <dmAdvFcnIf>:
   45bf4:	000223ad 000223f9 00022511              .#...#...%..

00045c00 <dmConnSpecDefaults>:
   45c00:	00280018 07d00000 00000000              ..(.........

00045c0c <dmConnActSetMain>:
   45c0c:	00022a2d 00022a43 00022a65 00022b59     -*..C*..e*..Y+..
   45c1c:	00022bb3 00022c01                       .+...,..

00045c24 <dmConnFcnIf>:
   45c24:	00022c29 00022d09 00022cdd              ),...-...,..

00045c30 <dmConn2FcnIf>:
   45c30:	00023d5d 00022e7d 00022dad              ]=..}....-..

00045c3c <dmConnActSetMaster>:
   45c3c:	00023831 000236b5 000236d7 000236f9     18...6...6...6..

00045c4c <dmConnActSetSlave>:
   45c4c:	000239c5 000239eb 000238b1 00023a09     .9...9...8...:..
   45c5c:	00023a27 00023917                       ':...9..

00045c64 <dmConnStateTbl>:
   45c64:	00001001 00002002 00000000 00000000     ..... ..........
   45c74:	00002303 00000000 00010000 00011104     .#..............
   45c84:	00010001 00010001 02030300 00010300     ................
   45c94:	00010001 21000002 00020002 00020002     .......!........
   45ca4:	24000002 24002303 00020002 00030002     ...$.#.$........
   45cb4:	00030104 22031203 25031303 00030003     ......."...%....
   45cc4:	05030400 05030003 00040004 00040004     ................
   45cd4:	00040004 04000004 04000104 00040004     ................
   45ce4:	00000004                                ....

00045ce8 <dmDevFcnIf>:
   45ce8:	00023d5d 00023bc5 00023c0d              ]=...;...<..

00045cf4 <dmHciToIdTbl>:
   45cf4:	03030307 04020303 04040404 05050505     ................
   45d04:	07070705 06060607 05060606 07040405     ................
   45d14:	04070407 04050504 09090904 00000202     ................
   45d24:	070b0b0b 00020002 0c0b010a 0d0d0d0c     ................
   45d34:	0d0d0d0d 0d100f0f                       ........

00045d3c <dmFcnDefault>:
   45d3c:	00023d5d 00023d6b 00023d6b              ]=..k=..k=..

00045d48 <dmPhyFcnIf>:
   45d48:	00023d5d 00023fd3 00023d6b              ]=...?..k=..

00045d54 <dmScanAct>:
   45d54:	00024425 000244d5 00024501              %D...D...E..

00045d60 <dmScanFcnIf>:
   45d60:	000245b9 00024601 000246bd              .E...F...F..

00045d6c <hciEventMask>:
   45d6c:	02008890 20008000                       ....... 

00045d74 <hciLeEventMask>:
   45d74:	007fffff 00000000                       ........

00045d7c <hciEventMaskPage2>:
   45d7c:	00800000 00000000                       ........

00045d84 <hciEvtParseFcnTbl>:
   45d84:	00000000 00026df5 00026ef9 00027005     .....m...n...p..
   45d94:	00027067 0002711d 00000000 0002714b     gp...q......Kq..
   45da4:	000271af 0002720f 00027263 00027305     .q...r..cr...s..
   45db4:	00027365 000273bb 00027411 00027467     es...s...t..gt..
   45dc4:	000274c9 0002753b 00027575 000275d9     .t..;u..uu...u..
   45dd4:	00027609 0002769f 000276cd 000276fb     .v...v...v...v..
   45de4:	00027729 00027765 000277a1 0002762f     )w..ew...w../v..
   45df4:	00027667 000277cf 00027825 0002787b     gv...w..%x..{x..
   45e04:	000278e9 00027917 0002796d 00027a1b     .x...y..my...z..
   45e14:	00027add 00027b9f 00027bd7 00027c0f     .z...{...{...|..
   45e24:	00027c65 00027ca7 00027d15 00027d43     e|...|...}..C}..
   45e34:	00000000 00028051 0002806b 000280d9     ....Q...k.......
   45e44:	00028119 00000000 000286b9 00000000     ................
   45e54:	0002829d 0002829d 0002829d 0002829d     ................
   45e64:	0002829d 00000000 00000000 00000000     ................
	...
   45e80:	00028561 000285b7 0002860d 00028663     a...........c...

00045e90 <hciEvtCbackLen>:
   45e90:	0a242404 0a1c060e 100e080e 0a080808     .$$.............
   45ea0:	06080610 06060606 16060c0c 0a08080e     ................
   45eb0:	0e0e0806 0826460e 0a060a06 0c0a0424     .....F&.....$...
   45ec0:	04061016 04040404 04040404 08041c04     ................
   45ed0:	00080808                                ....

00045ed4 <adv_local_name>:
   45ed4:	54746f54 00006761                       TotTag..

00045edc <adv_data_flags>:
   45edc:	00000006                                ....

00045ee0 <ble_adv_cfg>:
   45ee0:	00000000 00780000 00780078              ......x.x.x.

00045eec <ble_slave_cfg>:
   45eec:	00000001                                ....

00045ef0 <ble_sec_cfg>:
	...

00045ef8 <ble_update_cfg>:
   45ef8:	00000000 0018000c 00640009 00000005     ..........d.....

00045f08 <ble_att_cfg>:
   45f08:	00000001 040100f7                       ........

00045f10 <ble_master_cfg>:
   45f10:	00a00640 00002710                       @....'..

00045f18 <characteristicSet>:
   45f18:	00020013 004d0000 00000001 0001007a     ......M.....z...
	...

00045f2a <byte_offset.57119>:
	...

00045f2c <byte_offset.57129>:
   45f2c:	00000000                                ....

00045f30 <deviceInfoService>:
   45f30:	                                         ..

00045f32 <deviceInfoServiceLen>:
   45f32:	                                         ..

00045f34 <deviceInfoManufacturerChar>:
   45f34:	29003202                                 .2.)*.

00045f3a <deviceInfoManufacturerCharLen>:
   45f3a:	                                         ..

00045f3c <deviceInfoManufacturer>:
   45f3c:	3162614c                                 Lab11.

00045f42 <deviceInfoManufacturerLen>:
   45f42:	                                         ..

00045f44 <deviceInfoSysIdChar>:
   45f44:	23003402                                 .4.#*.

00045f4a <deviceInfoSysIdCharLen>:
   45f4a:	                                         ..

00045f4c <deviceInfoSysIdLen>:
   45f4c:	00000008                                ....

00045f50 <deviceInfoModelNumChar>:
   45f50:	24003602                                 .6.$*.

00045f56 <deviceInfoModelNumCharLen>:
   45f56:	                                         ..

00045f58 <deviceInfoModelNum>:
   45f58:	54746f54 00006761                       TotTag..

00045f60 <deviceInfoModelNumLen>:
   45f60:	00000007                                ....

00045f64 <deviceInfoFirmwareVerChar>:
   45f64:	26003802                                 .8.&*.

00045f6a <deviceInfoFirmwareVerCharLen>:
   45f6a:	                                         ..

00045f6c <deviceInfoFirmwareVer>:
   45f6c:	20727041 32203132 00333230              Apr 21 2023.

00045f78 <deviceInfoFirmwareVerLen>:
   45f78:	0000000c                                ....

00045f7c <deviceInfoHardwareVerChar>:
   45f7c:	27003a02                                 .:.'*.

00045f82 <deviceInfoHardwareVerCharLen>:
   45f82:	                                         ..

00045f84 <deviceInfoHardwareVer>:
   45f84:	2e766552 42564520                        Rev. EVB..

00045f8e <deviceInfoHardwareVerLen>:
   45f8e:	                                         ..

00045f90 <deviceInfoList>:
   45f90:	00045ac4 00045f30 00045f32 01000002     .Z..0_..2_......
   45fa0:	00045ac8 00045f34 00045f3a 01000005     .Z..4_..:_......
   45fb0:	00045af0 00045f3c 00045f42 01000006     .Z..<_..B_......
   45fc0:	00045ac8 00045f44 00045f4a 01000005     .Z..D_..J_......
   45fd0:	00045ae0 10009c30 00045f4c 01000008     .Z..0...L_......
   45fe0:	00045ac8 00045f50 00045f56 01000005     .Z..P_..V_......
   45ff0:	00045ae4 00045f58 00045f60 01000007     .Z..X_..`_......
   46000:	00045ac8 00045f64 00045f6a 0100000c     .Z..d_..j_......
   46010:	00045ae8 00045f6c 00045f78 0100000c     .Z..l_..x_......
   46020:	00045ac8 00045f7c 00045f82 01000005     .Z..|_..._......
   46030:	00045aec 00045f84 00045f8e 01000009     .Z..._..._......

00046040 <gapServiceVal>:
   46040:	                                         ..

00046042 <gapServiceLen>:
   46042:	                                         ..

00046044 <gapDeviceNameChar>:
   46044:	00000302                                 ....*.

0004604a <gapDeviceNameCharLen>:
   4604a:	                                         ..

0004604c <gapDeviceName>:
   4604c:	54746f54 00006761 00000000 00000000     TotTag..........
   4605c:	00000000                                ....

00046060 <gapDeviceNameLen>:
   46060:	00000006                                ....

00046064 <gapAppearanceChar>:
   46064:	01000502                                 ....*.

0004606a <gapAppearanceCharLen>:
   4606a:	                                         ..

0004606c <gapAppearance>:
   4606c:	                                         Q.

0004606e <gapAppearanceLen>:
   4606e:	                                         ..

00046070 <gapCentralAddrResChar>:
   46070:	a6000702                                 ....*.

00046076 <gapCentralAddrResCharLen>:
   46076:	                                         ..

00046078 <gapCentralAddrResLen>:
   46078:	00000001                                ....

0004607c <gapList>:
   4607c:	00045ac4 00046040 00046042 01000002     .Z..@`..B`......
   4608c:	00045ac8 00046044 0004604a 01000005     .Z..D`..J`......
   4609c:	00045ad4 0004604c 00046060 110a0014     .Z..L`..``......
   460ac:	00045ac8 00046064 0004606a 01000005     .Z..d`..j`......
   460bc:	00045ad8 0004606c 0004606e 01000002     .Z..l`..n`......
   460cc:	00045ac8 00046070 00046076 01000005     .Z..p`..v`......
   460dc:	00045af4 10009c38 00046078 01000001     .Z..8...x`......

000460ec <gattServiceVal>:
   460ec:	                                         ..

000460ee <gattServiceLen>:
   460ee:	                                         ..

000460f0 <gattServiceChangedChar>:
   460f0:	05001220                                  ...*.

000460f6 <gattServiceChangedCharLen>:
   460f6:	                                         ..

000460f8 <gattServiceChanged>:
   460f8:	ffff0001                                ....

000460fc <gattServiceChangedLen>:
   460fc:	                                         ..

000460fe <gattServiceChangedCccLen>:
   460fe:	                                         ..

00046100 <gattCsfChar>:
   46100:	29001502                                 ...)+.

00046106 <gattCsfCharLen>:
   46106:	                                         ..

00046108 <gattCsfLen>:
   46108:	00000001                                ....

0004610c <gattDbHashChar>:
   4610c:	2a001702                                 ...*+.

00046112 <gattDbHashCharLen>:
   46112:	                                         ..

00046114 <gattDbHashLen>:
   46114:	00000010                                ....

00046118 <gattList>:
   46118:	00045ac4 000460ec 000460ee 01000002     .Z...`...`......
   46128:	00045ac8 000460f0 000460f6 01000005     .Z...`...`......
   46138:	00045adc 000460f8 000460fc 00000004     .Z...`...`......
   46148:	00045ad0 10009c3c 000460fe 11200002     .Z..<....`.... .
   46158:	00045ac8 00046100 00046106 01000005     .Z...a...a......
   46168:	00045af8 10009c40 00046108 11060001     .Z..@....a......
   46178:	00045ac8 0004610c 00046112 01000005     .Z...a...a......
   46188:	00045afc 10009c44 00046114 01040010     .Z..D....a......

00046198 <liveStatsService>:
   46198:	395e5d2e 0c455231 a23fee90 d68c3152     .]^91RE...?.R1..

000461a8 <liveStatsServiceLen>:
   461a8:	00000010                                ....

000461ac <battChUuid>:
   461ac:	395e5d2e 0c455231 a23fee90 d68c3153     .]^91RE...?.S1..

000461bc <batteryLevelChar>:
   461bc:	2e004202 31395e5d 900c4552 53a23fee     .B..]^91RE...?.S
   461cc:	00d68c31                                1...

000461d0 <batteryLevelCharLen>:
   461d0:	                                         ..

000461d2 <batteryLevelLen>:
   461d2:	                                         ..

000461d4 <batteryLevelDesc>:
   461d4:	74746142 56797265 61746c6f 00006567     BatteryVoltage..

000461e4 <batteryLevelDescLen>:
   461e4:	0000000f                                ....

000461e8 <timestampChUuid>:
   461e8:	395e5d2e 0c455231 a23fee90 d68c3154     .]^91RE...?.T1..

000461f8 <timestampChar>:
   461f8:	2e00450a 31395e5d 900c4552 54a23fee     .E..]^91RE...?.T
   46208:	00d68c31                                1...

0004620c <timestampCharLen>:
   4620c:	                                         ..

0004620e <timestampLen>:
   4620e:	                                         ..

00046210 <timestampDesc>:
   46210:	72727543 54746e65 73656d69 706d6174     CurrentTimestamp
	...

00046222 <timestampDescLen>:
   46222:	                                         ..

00046224 <findMyTottagChUuid>:
   46224:	395e5d2e 0c455231 a23fee90 d68c3155     .]^91RE...?.U1..

00046234 <findMyTottagChar>:
   46234:	2e004808 31395e5d 900c4552 55a23fee     .H..]^91RE...?.U
   46244:	00d68c31                                1...

00046248 <findMyTottagCharLen>:
   46248:	                                         ..

0004624a <findMyTottagDurationLen>:
   4624a:	                                         ..

0004624c <findMyTottagDesc>:
   4624c:	646e6946 6f54794d 67617474 75716552     FindMyTottagRequ
   4625c:	00747365                                est.

00046260 <findMyTottagDescLen>:
   46260:	00000014                                ....

00046264 <rangingChUuid>:
   46264:	395e5d2e 0c455231 a23fee90 d68c3156     .]^91RE...?.V1..

00046274 <rangesChar>:
   46274:	2e004b10 31395e5d 900c4552 56a23fee     .K..]^91RE...?.V
   46284:	00d68c31                                1...

00046288 <rangesCharLen>:
   46288:	                                         ..

0004628a <rangesLen>:
   4628a:	                                         ..

0004628c <rangesDesc>:
   4628c:	6576694c 676e6152 52676e69 6c757365     LiveRangingResul
   4629c:	00007374                                ts..

000462a0 <rangesDescLen>:
   462a0:	                                         ..

000462a2 <rangesCccLen>:
   462a2:	                                         ..

000462a4 <liveStatsList>:
   462a4:	00045ac4 00046198 000461a8 01000010     .Z...a...a......
   462b4:	00045ac8 000461bc 000461d0 01000013     .Z...a...a......
   462c4:	000461ac 10009c54 000461d2 01050002     .a..T....a......
   462d4:	00045acc 000461d4 000461e4 0100000f     .Z...a...a......
   462e4:	00045ac8 000461f8 0004620c 01000013     .Z...a...b......
   462f4:	000461e8 10009c58 0004620e 11070004     .a..X....b......
   46304:	00045acc 00046210 00046222 01000011     .Z...b.."b......
   46314:	00045ac8 00046234 00046248 01000013     .Z..4b..Hb......
   46324:	00046224 10009c5c 0004624a 10030004     $b..\...Jb......
   46334:	00045acc 0004624c 00046260 01000014     .Z..Lb..`b......
   46344:	00045ac8 00046274 00046288 01000013     .Z..tb...b......
   46354:	00046264 10009c60 0004628a 00090001     db..`....b......
   46364:	00045acc 0004628c 000462a0 01000013     .Z...b...b......
   46374:	00045ad0 10009c64 000462a2 11200002     .Z..d....b.... .

00046384 <maintenanceService>:
   46384:	395e5d2e 0c455231 a23fee90 d68c3160     .]^91RE...?.`1..

00046394 <maintenanceServiceLen>:
   46394:	00000010                                ....

00046398 <experimentDetailsChUuid>:
   46398:	395e5d2e 0c455231 a23fee90 d68c3161     .]^91RE...?.a1..

000463a8 <experimentDetailsChar>:
   463a8:	2e007202 31395e5d 900c4552 61a23fee     .r..]^91RE...?.a
   463b8:	00d68c31                                1...

000463bc <experimentDetailsCharLen>:
   463bc:	                                         ..

000463be <experimentDetailsLen>:
   463be:	                                         ..

000463c0 <experimentDetailsDesc>:
   463c0:	65707845 656d6972 6544746e 6c696174     ExperimentDetail
   463d0:	                                         s.

000463d2 <experimentDetailsDescLen>:
   463d2:	                                         ..

000463d4 <maintenanceCommandChUuid>:
   463d4:	395e5d2e 0c455231 a23fee90 d68c3162     .]^91RE...?.b1..

000463e4 <maintenanceCommandChar>:
   463e4:	2e007508 31395e5d 900c4552 62a23fee     .u..]^91RE...?.b
   463f4:	00d68c31                                1...

000463f8 <maintenanceCommandCharLen>:
   463f8:	                                         ..

000463fa <maintenanceCommandLen>:
   463fa:	                                         ..

000463fc <maintenanceCommandDesc>:
   463fc:	6e69614d 616e6574 4365636e 616d6d6f     MaintenanceComma
   4640c:	0000646e                                nd..

00046410 <maintenanceCommandDescLen>:
   46410:	00000013                                ....

00046414 <maintenanceResultChUuid>:
   46414:	395e5d2e 0c455231 a23fee90 d68c3163     .]^91RE...?.c1..

00046424 <maintenanceResultChar>:
   46424:	2e007810 31395e5d 900c4552 63a23fee     .x..]^91RE...?.c
   46434:	00d68c31                                1...

00046438 <maintenanceResultCharLen>:
   46438:	                                         ..

0004643a <maintenanceResultLen>:
   4643a:	                                         ..

0004643c <maintenanceResultDesc>:
   4643c:	6e69614d 616e6574 4465636e 00617461     MaintenanceData.

0004644c <maintenanceResultDescLen>:
   4644c:	                                         ..

0004644e <maintenanceResultCccLen>:
   4644e:	                                         ..

00046450 <maintenanceList>:
   46450:	00045ac4 00046384 00046394 01000010     .Z...c...c......
   46460:	00045ac8 000463a8 000463bc 01000013     .Z...c...c......
   46470:	00046398 1000ac74 000463be 010500ed     .c..t....c......
   46480:	00045acc 000463c0 000463d2 01000012     .Z...c...c......
   46490:	00045ac8 000463e4 000463f8 01000013     .Z...c...c......
   464a0:	000463d4 1000ad64 000463fa 100b00ee     .c..d....c......
   464b0:	00045acc 000463fc 00046410 01000013     .Z...c...d......
   464c0:	00045ac8 00046424 00046438 01000013     .Z..$d..8d......
   464d0:	00046414 1000ae54 0004643a 00090001     .d..T...:d......
   464e0:	00045acc 0004643c 0004644c 01000010     .Z..<d..Ld......
   464f0:	00045ad0 1000ae58 0004644e 11200002     .Z..X...Nd.... .

00046500 <schedulingService>:
   46500:	395e5d2e 0c455231 a23fee90 d68c315a     .]^91RE...?.Z1..

00046510 <schedulingServiceLen>:
   46510:	00000010                                ....

00046514 <networkRequestChUuid>:
   46514:	395e5d2e 0c455231 a23fee90 d68c315b     .]^91RE...?.[1..

00046524 <networkRequestChar>:
   46524:	2e006208 31395e5d 900c4552 5ba23fee     .b..]^91RE...?.[
   46534:	00d68c31                                1...

00046538 <networkRequestCharLen>:
   46538:	                                         ..

0004653a <networkRequestLen>:
   4653a:	                                         ..

0004653c <networkRequestDesc>:
   4653c:	7774654e 526b726f 65757165 00007473     NetworkRequest..

0004654c <networkRequestDescLen>:
   4654c:	0000000f                                ....

00046550 <schedulingList>:
   46550:	00045ac4 00046500 00046510 01000010     .Z...e...e......
   46560:	00045ac8 00046524 00046538 01000013     .Z..$e..8e......
   46570:	00046514 1000ae60 0004653a 10030006     .e..`...:e......
   46580:	00045acc 0004653c 0004654c 0100000f     .Z..<e..Le......

00046590 <DAYS_IN_MONTH>:
   46590:	0000001f 0000001c 0000001f 0000001e     ................
   465a0:	0000001f 0000001e 0000001f 0000001f     ................
   465b0:	0000001e 0000001f 0000001e 0000001f     ................

000465c0 <_DAYS_BEFORE_MONTH>:
   465c0:	00000000 0000001f 0000003b 0000005a     ........;...Z...
   465d0:	00000078 00000097 000000b5 000000d4     x...............
   465e0:	000000f3 00000111 00000130 0000014e     ........0...N...
   465f0:	00005a54 00544d47 5b303125 392d305e     TZ..GMT.%10[^0-9
   46600:	5d2d2b2c 00006e25 25756825 68253a6e     ,+-]%n..%hu%n:%h
   46610:	3a6e2575 25756825 0000006e 7568254d     u%n:%hu%n...M%hu
   46620:	252e6e25 6e257568 7568252e 00006e25     %n.%hu%n.%hu%n..
   46630:	7568252f 253a6e25 6e257568 7568253a     /%hu%n:%hu%n:%hu
   46640:	00006e25                                %n..

00046644 <__month_lengths>:
   46644:	0000001f 0000001c 0000001f 0000001e     ................
   46654:	0000001f 0000001e 0000001f 0000001f     ................
   46664:	0000001e 0000001f 0000001e 0000001f     ................
   46674:	0000001f 0000001d 0000001f 0000001e     ................
   46684:	0000001f 0000001e 0000001f 0000001f     ................
   46694:	0000001e 0000001f 0000001e 0000001f     ................

000466a4 <basefix.8279>:
   466a4:	0001000a 00030002 00050004 00070006     ................
   466b4:	00090008 000b000a 000d000c 000f000e     ................
   466c4:	00000010                                ....

000466c8 <_ctype_>:
   466c8:	20202000 20202020 28282020 20282828     .         ((((( 
   466d8:	20202020 20202020 20202020 20202020                     
   466e8:	10108820 10101010 10101010 10101010      ...............
   466f8:	04040410 04040404 10040404 10101010     ................
   46708:	41411010 41414141 01010101 01010101     ..AAAAAA........
   46718:	01010101 01010101 01010101 10101010     ................
   46728:	42421010 42424242 02020202 02020202     ..BBBBBB........
   46738:	02020202 02020202 02020202 10101010     ................
   46748:	00000020 00000000 00000000 00000000      ...............
	...
   467cc:	00000043 49534f50 00000058 00000000     C...POSIX.......
   467dc:	0000002e                                ....

000467e0 <am_hal_daxi_defaults>:
   467e0:	0f020100 00000001                       ........

000467e8 <g_am_hal_mcuctrl_sku_mram_size>:
   467e8:	04000200 08000600                       ........

000467f0 <g_am_hal_mcuctrl_sku_ssram_size>:
   467f0:	01800400 01800800 01800400 01800800     ................

00046800 <am_hal_gpio_pincfg_disabled>:
   46800:	00000003                                ....

00046804 <am_hal_gpio_pincfg_input>:
   46804:	00000093                                ....

00046808 <am_hal_gpio_pincfg_output>:
   46808:	00000183                                ....

0004680c <g_ui32DSpintbl>:
   4680c:	8fc007e0 e3fbffff 01ffffff 00000000     ................

0004681c <am_hal_pwrctrl_peripheral_control>:
   4681c:	40021004 00000001 40021008 00000001     ...@.......@....
   4682c:	40021004 00000002 40021008 0000001e     ...@.......@....
   4683c:	40021004 00000004 40021008 0000001e     ...@.......@....
   4684c:	40021004 00000008 40021008 0000001e     ...@.......@....
   4685c:	40021004 00000010 40021008 0000001e     ...@.......@....
   4686c:	40021004 00000020 40021008 000001e0     ...@ ......@....
   4687c:	40021004 00000040 40021008 000001e0     ...@@......@....
   4688c:	40021004 00000080 40021008 000001e0     ...@.......@....
   4689c:	40021004 00000100 40021008 000001e0     ...@.......@....
   468ac:	40021004 00000200 40021008 00001e00     ...@.......@....
   468bc:	40021004 00000400 40021008 00001e00     ...@.......@....
   468cc:	40021004 00000800 40021008 00001e00     ...@.......@....
   468dc:	40021004 00001000 40021008 00001e00     ...@.......@....
   468ec:	40021004 00002000 40021008 00002000     ...@. .....@. ..
   468fc:	40021004 00004000 40021008 0001c000     ...@.@.....@....
   4690c:	40021004 00008000 40021008 0001c000     ...@.......@....
   4691c:	40021004 00010000 40021008 0001c000     ...@.......@....
   4692c:	40021004 00020000 40021008 00020000     ...@.......@....
   4693c:	40021004 00040000 40021008 00040000     ...@.......@....
   4694c:	40021004 00080000 40021008 00080000     ...@.......@....
   4695c:	40021004 00100000 40021008 00100000     ...@.......@....
   4696c:	40021004 00200000 40021008 00200000     ...@.. ....@.. .
   4697c:	40021004 00400000 40021008 00400000     ...@..@....@..@.
   4698c:	40021004 00800000 40021008 00800000     ...@.......@....
   4699c:	40021004 01000000 40021008 01000000     ...@.......@....
   469ac:	4002100c 00000001 40021010 000000ff     ...@.......@....
   469bc:	4002100c 00000002 40021010 000000ff     ...@.......@....
   469cc:	4002100c 00000004 40021010 000000ff     ...@.......@....
   469dc:	4002100c 00000008 40021010 000000ff     ...@.......@....
   469ec:	4002100c 00000010 40021010 000000ff     ...@.......@....
   469fc:	4002100c 00000020 40021010 000000ff     ...@ ......@....
   46a0c:	4002100c 00000040 40021010 000000ff     ...@@......@....
   46a1c:	4002100c 00000080 40021010 000000ff     ...@.......@....
   46a2c:	4002100c 00000400 40021010 00000400     ...@.......@....

00046a3c <g_DefaultMcuMemCfg>:
   46a3c:	07070102 00000001                       ........

00046a44 <g_DefaultSRAMCfg>:
   46a44:	00000003 00000300                       ........

00046a4c <g_am_hal_bootrom_helper>:
   46a4c:	0800004d 08000051 08000055 08000059     M...Q...U...Y...
   46a5c:	0800006d 08000075 08000079 08000081     m...u...y.......
   46a6c:	08000099 0800009d                       ........

00046a74 <gAmHalCmdQReg>:
   46a74:	40050228 4005022c 40050240 40050244     (..@,..@@..@D..@
   46a84:	4005023c 00008000 40050230 00000001     <..@....0..@....
   46a94:	00000004 00000002 40051228 4005122c     ........(..@,..@
   46aa4:	40051240 40051244 4005123c 00008000     @..@D..@<..@....
   46ab4:	40051230 00000001 00000004 00000002     0..@............
   46ac4:	40052228 4005222c 40052240 40052244     (".@,".@@".@D".@
   46ad4:	4005223c 00008000 40052230 00000001     <".@....0".@....
   46ae4:	00000004 00000002 40053228 4005322c     ........(2.@,2.@
   46af4:	40053240 40053244 4005323c 00008000     @2.@D2.@<2.@....
   46b04:	40053230 00000001 00000004 00000002     02.@............
   46b14:	40054228 4005422c 40054240 40054244     (B.@,B.@@B.@DB.@
   46b24:	4005423c 00008000 40054230 00000001     <B.@....0B.@....
   46b34:	00000004 00000002 40055228 4005522c     ........(R.@,R.@
   46b44:	40055240 40055244 4005523c 00008000     @R.@DR.@<R.@....
   46b54:	40055230 00000001 00000004 00000002     0R.@............
   46b64:	40056228 4005622c 40056240 40056244     (b.@,b.@@b.@Db.@
   46b74:	4005623c 00008000 40056230 00000001     <b.@....0b.@....
   46b84:	00000004 00000002 40057228 4005722c     ........(r.@,r.@
   46b94:	40057240 40057244 4005723c 00008000     @r.@Dr.@<r.@....
   46ba4:	40057230 00000001 00000004 00000002     0r.@............
   46bb4:	400602a0 400602a8 400602c0 400602c4     ...@...@...@...@
   46bc4:	400602b8 00004000 400602ac 00000001     ...@.@.....@....
   46bd4:	00000004 00000008 400612a0 400612a8     ...........@...@
   46be4:	400612c0 400612c4 400612b8 00004000     ...@...@...@.@..
   46bf4:	400612ac 00000001 00000004 00000008     ...@............
   46c04:	400622a0 400622a8 400622c0 400622c4     .".@.".@.".@.".@
   46c14:	400622b8 00004000 400622ac 00000001     .".@.@...".@....
   46c24:	00000004 00000008                       ........

00046c2c <crcTable>:
   46c2c:	090e0700 15121b1c 31363f38 2d2a2324     ........8?61$#*-
   46c3c:	797e7770 65626b6c 41464f48 5d5a5354     pw~ylkbeHOFATSZ]
   46c4c:	e9eee7e0 f5f2fbfc d1d6dfd8 cdcac3c4     ................
   46c5c:	999e9790 85828b8c a1a6afa8 bdbab3b4     ................
   46c6c:	cec9c0c7 d2d5dcdb f6f1f8ff eaede4e3     ................
   46c7c:	beb9b0b7 a2a5acab 8681888f 9a9d9493     ................
   46c8c:	2e292027 32353c3b 1611181f 0a0d0403     ' ).;<52........
   46c9c:	5e595057 42454c4b 6661686f 7a7d7473     WPY^KLEBohafst}z
   46cac:	80878e89 9c9b9295 b8bfb6b1 a4a3aaad     ................
   46cbc:	f0f7fef9 ecebe2e5 c8cfc6c1 d4d3dadd     ................
   46ccc:	60676e69 7c7b7275 585f5651 44434a4d     ing`ur{|QV_XMJCD
   46cdc:	10171e19 0c0b0205 282f2621 34333a3d     ........!&/(=:34
   46cec:	4740494e 5b5c5552 7f787176 63646d6a     NI@GRU\[vqx.jmdc
   46cfc:	3730393e 2b2c2522 0f080106 13141d1a     >907"%,+........
   46d0c:	a7a0a9ae bbbcb5b2 9f989196 83848d8a     ................
   46d1c:	d7d0d9de cbccc5c2 efe8e1e6 f3f4fdfa     ................

00046d2c <dw3000_mcps_ops>:
   46d2c:	0003b29d 000371b5 00036e89 00036f51     .....q...n..Qo..
   46d3c:	00036f3d 00036f1b 00037129 00000000     =o...o..)q......
	...
   46d54:	00038835 00038b91 00038735 00039279     5.......5...y...
   46d64:	00037d81                                .}..

00046d68 <dw3000_ops>:
   46d68:	00038e25 00038415 000387e9 000382e1     %...............
   46d78:	00038d49 00037a55 00038965 00038735     I...Uz..e...5...
   46d88:	0003834d 0003b179 000371b7 00039279     M...y....q..y...
   46d98:	00037d81 000371a5                       .}...q..

00046da0 <fine_gain_lut_chan5>:
   46da0:	1c1d2000 0d0c1214 08070a0a 06050706     . ..............
   46db0:	04040505 03030404 03020303 03020302     ................
   46dc0:	02020203 02010201 01010201 01010101     ................
   46dd0:	01010101 01010101 01010101 01010101     ................

00046de0 <fine_gain_lut_chan9>:
   46de0:	120e0b00 0c0a0f0f 08070909 06050706     ................
   46df0:	05040505 04030404 03030303 03020303     ................
   46e00:	02020203 02010202 02020202 02010201     ................
   46e10:	02010101 01010101 01010101 01010100     ................

00046e20 <lut_coarse_gain>:
   46e20:	00050d20                                 ...

00046e24 <regNames>:
	...
   46e2c:	58335744 00005858 58335744 44205858     DW3XXX..DW3XXX D
   46e3c:	63697665 72442065 72657669 72655620     evice Driver Ver
   46e4c:	6e6f6973 2e363020 302e3030 00000037     sion 06.00.07...

00046e5c <sts_length_factors>:
   46e5c:	05a80400 0b500800 16a11000 00002000     ......P...... ..

00046e6c <dw3700_mcps_ops>:
   46e6c:	0003f819 0003b45d 00036e89 00036f51     ....]....n..Qo..
   46e7c:	00036f3d 00036f1b 00037129 00000000     =o...o..)q......
	...
   46e94:	0003c9c9 0003cdf9 0003cd21 0003d72d     ........!...-...
   46ea4:	0003c3fd                                ....

00046ea8 <dw3700_ops>:
   46ea8:	0003d055 0003c371 0003c97d 0003c109     U...q...}.......
   46eb8:	0003cf79 0003bd45 0003caf9 0003cd21     y...E.......!...
   46ec8:	0003d5fd 0003d4d5 0003b45f 0003d72d     ........_...-...
   46ed8:	0003c3fd 0003b44d                       ....M...

00046ee0 <fine_gain_lut_chan5>:
   46ee0:	1c1d2000 0d0c1214 08070a0a 06050706     . ..............
   46ef0:	04040505 03030404 03020303 03020302     ................
   46f00:	02020203 02010201 01010201 01010101     ................
   46f10:	01010101 01010101 01010101 01010101     ................

00046f20 <fine_gain_lut_chan9>:
   46f20:	120e0b00 0c0a0f0f 08070909 06050706     ................
   46f30:	05040505 04030404 03030303 03020303     ................
   46f40:	02020203 02010202 02020202 02010201     ................
   46f50:	02010101 01010101 01010101 01010100     ................

00046f60 <lut_coarse_gain>:
   46f60:	00050d20                                 ...

00046f64 <regNames>:
	...

00046f6c <sts_length_factors>:
   46f6c:	05a80400 0b500800 16a11000 00002000     ......P...... ..

00046f7c <dw3720_mcps_ops>:
   46f7c:	00044261 0003fa09 00036e89 00036f51     aB.......n..Qo..
   46f8c:	00036f3d 00036f1b 00037129 00000000     =o...o..)q......
	...
   46fa4:	000411ad 000418c5 000417ed 0004221d     ............."..
   46fb4:	00040be1                                ....

00046fb8 <dw3720_ops>:
   46fb8:	00041b15 00040b55 00041185 00040835     ....U.......5...
   46fc8:	00041a8d 000403a9 000415c1 000417ed     ................
   46fd8:	000420ed 00041fb1 0003fa0b 0004221d     . ..........."..
   46fe8:	00040be1 0003f9f9                       ........

00046ff0 <fine_gain_lut_chan5>:
   46ff0:	1c1d2000 0d0c1214 08070a0a 06050706     . ..............
   47000:	04040505 03030404 03020303 03020302     ................
   47010:	02020203 02010201 01010201 01010101     ................
   47020:	01010101 01010101 01010101 01010101     ................

00047030 <fine_gain_lut_chan9>:
   47030:	120e0b00 0c0a0f0f 08070909 06050706     ................
   47040:	05040505 04030404 03030303 03020303     ................
   47050:	02020203 02010202 02020202 02010201     ................
   47060:	02010101 01010101 01010101 01010100     ................

00047070 <lut_coarse_gain>:
   47070:	00050d20                                 ...

00047074 <regNames>:
	...

0004707c <sts_length_factors>:
   4707c:	05a80400 0b500800 16a11000 00002000     ......P...... ..
